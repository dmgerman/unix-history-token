begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, 1998  *	Nan Yang Computer Services Limited.  All rights reserved.  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *    * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  * $FreeBSD$  */
end_comment

begin_define
define|#
directive|define
name|STATIC
end_define

begin_comment
comment|/* nothing while we're testing XXX */
end_comment

begin_include
include|#
directive|include
file|"opt_vinum.h"
end_include

begin_define
define|#
directive|define
name|DTYPE_VINUM
value|12
end_define

begin_comment
comment|/* vinum volume */
end_comment

begin_define
define|#
directive|define
name|REALLYKERNEL
end_define

begin_include
include|#
directive|include
file|"vinumhdr.h"
end_include

begin_include
include|#
directive|include
file|"request.h"
end_include

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_decl_stmt
specifier|extern
name|jmp_buf
name|command_fail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* return on a failed command */
end_comment

begin_decl_stmt
name|struct
name|_ioctl_reply
modifier|*
name|ioctl_reply
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data pointer, for returning error messages */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|sappend
parameter_list|(
name|char
modifier|*
name|txt
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|drivecmp
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Open the device associated with the drive, and set drive's vp.  * Return an error number */
end_comment

begin_function
name|int
name|open_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|drive
operator|->
name|devicename
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* no device name */
name|sprintf
argument_list|(
name|drive
operator|->
name|devicename
argument_list|,
literal|"/dev/%s"
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* get it from the drive name */
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_open
argument_list|(
operator|&
name|nd
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* open the device */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* can't open? */
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
name|drive
operator|->
name|lasterror
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"vinum open_drive %s: failed with error %d\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
name|error
return|;
block|}
name|drive
operator|->
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|drive
operator|->
name|p
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|vp
operator|->
name|v_usecount
operator|>
literal|1
condition|)
block|{
comment|/* already in use? */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"open_drive %s: use count %d, ignoring\n"
argument_list|,
comment|/* XXX where does this come from? */
name|drive
operator|->
name|devicename
argument_list|,
name|drive
operator|->
name|vp
operator|->
name|v_usecount
argument_list|)
expr_stmt|;
name|drive
operator|->
name|vp
operator|->
name|v_usecount
operator|=
literal|1
expr_stmt|;
comment|/* will this work? */
block|}
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|drive
operator|->
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|NOCRED
argument_list|,
name|drive
operator|->
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|drive
operator|->
name|vp
argument_list|)
expr_stmt|;
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
name|drive
operator|->
name|lasterror
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"vinum open_drive %s: GETAATTR returns error %d\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
name|error
return|;
block|}
name|drive
operator|->
name|dev
operator|=
name|va
operator|.
name|va_rdev
expr_stmt|;
comment|/* device */
if|if
condition|(
name|va
operator|.
name|va_type
operator|!=
name|VBLK
condition|)
block|{
comment|/* only consider block devices */
name|VOP_UNLOCK
argument_list|(
name|drive
operator|->
name|vp
argument_list|)
expr_stmt|;
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* this also closes the drive */
name|drive
operator|->
name|lasterror
operator|=
name|ENOTBLK
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"vinum open_drive %s: Not a block device\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
name|ENOTBLK
return|;
block|}
name|drive
operator|->
name|vp
operator|->
name|v_numoutput
operator|=
literal|0
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|drive
operator|->
name|vp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set some variables in the drive struct  * in more convenient form.  Return error indication */
end_comment

begin_function
name|int
name|set_drive_parms
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|)
block|{
name|drive
operator|->
name|blocksize
operator|=
name|BLKDEV_IOSIZE
expr_stmt|;
comment|/* XXX do we need this? */
name|drive
operator|->
name|secsperblock
operator|=
name|drive
operator|->
name|blocksize
comment|/* number of sectors per block */
operator|/
name|drive
operator|->
name|partinfo
operator|.
name|disklab
operator|->
name|d_secsize
expr_stmt|;
comment|/* Now update the label part */
name|bcopy
argument_list|(
name|hostname
argument_list|,
name|drive
operator|->
name|label
operator|.
name|sysname
argument_list|,
name|VINUMHOSTNAMELEN
argument_list|)
expr_stmt|;
comment|/* put in host name */
name|drive
operator|->
name|label
operator|.
name|date_of_birth
operator|=
name|time
expr_stmt|;
comment|/* and current time */
name|drive
operator|->
name|label
operator|.
name|drive_size
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|drive
operator|->
name|partinfo
operator|.
name|part
operator|->
name|p_size
operator|)
comment|/* size of the drive in bytes */
operator|*
operator|(
operator|(
name|u_int64_t
operator|)
name|drive
operator|->
name|partinfo
operator|.
name|disklab
operator|->
name|d_secsize
operator|)
expr_stmt|;
comment|/* number of sectors available for subdisks */
name|drive
operator|->
name|sectors_available
operator|=
name|drive
operator|->
name|label
operator|.
name|drive_size
operator|/
name|DEV_BSIZE
operator|-
name|DATASTART
expr_stmt|;
comment|/* XXX Bug in 3.0 as of January 1998: you can open      * non-existent slices.  They have a length of 0 */
if|if
condition|(
name|drive
operator|->
name|label
operator|.
name|drive_size
operator|<
name|MINVINUMSLICE
condition|)
block|{
comment|/* too small to worry about */
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
name|drive
operator|->
name|lasterror
operator|=
name|ENOSPC
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
name|drive
operator|->
name|freelist_size
operator|=
name|INITIAL_DRIVE_FREELIST
expr_stmt|;
comment|/* initial number of entries */
name|drive
operator|->
name|freelist
operator|=
operator|(
expr|struct
name|drive_freelist
operator|*
operator|)
name|Malloc
argument_list|(
name|INITIAL_DRIVE_FREELIST
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive_freelist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|freelist
operator|==
name|NULL
condition|)
comment|/* can't malloc, dammit */
return|return
name|ENOSPC
return|;
name|drive
operator|->
name|freelist_entries
operator|=
literal|1
expr_stmt|;
comment|/* just (almost) the complete drive */
name|drive
operator|->
name|freelist
index|[
literal|0
index|]
operator|.
name|offset
operator|=
name|DATASTART
expr_stmt|;
comment|/* starts here */
name|drive
operator|->
name|freelist
index|[
literal|0
index|]
operator|.
name|sectors
operator|=
operator|(
name|drive
operator|->
name|label
operator|.
name|drive_size
operator|>>
name|DEV_BSHIFT
operator|)
operator|-
name|DATASTART
expr_stmt|;
comment|/* and it's this long */
if|if
condition|(
name|drive
operator|->
name|label
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
comment|/* got a name */
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_up
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* our drive is accessible */
else|else
comment|/* we know about it, but that's all */
name|drive
operator|->
name|state
operator|=
name|drive_uninit
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Initialize a drive: open the device and add device  * information */
end_comment

begin_function
name|int
name|init_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|drive
operator|->
name|devicename
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* no device name yet, default to drive name */
name|drive
operator|->
name|lasterror
operator|=
name|EINVAL
expr_stmt|;
comment|/* This is a bug if it happens internally, 	 * so print a message regardless */
name|printf
argument_list|(
literal|"vinum: Can't open drive without drive name\n"
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|open_drive
argument_list|(
name|drive
argument_list|,
name|curproc
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
comment|/* open the drive */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|VOP_IOCTL
argument_list|(
name|drive
operator|->
name|vp
argument_list|,
comment|/* get the partition information */
name|DIOCGPART
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|drive
operator|->
name|partinfo
argument_list|,
name|FREAD
argument_list|,
name|NOCRED
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"vinum open_drive %s: Can't get partition information, error %d\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* XXX */
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|drive
operator|->
name|lasterror
operator|=
name|error
expr_stmt|;
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|drive
operator|->
name|partinfo
operator|.
name|part
operator|->
name|p_fstype
operator|!=
literal|0
condition|)
block|{
comment|/* not plain */
name|drive
operator|->
name|lasterror
operator|=
name|EFTYPE
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"vinum open_drive %s: Wrong partition type for vinum\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|)
expr_stmt|;
comment|/* XXX */
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
return|return
name|EFTYPE
return|;
block|}
return|return
name|set_drive_parms
argument_list|(
name|drive
argument_list|)
return|;
comment|/* set various odds and ends */
block|}
end_function

begin_comment
comment|/* Close a drive if it's open.  No errors */
end_comment

begin_function
name|void
name|close_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|)
block|{
if|if
condition|(
name|drive
operator|->
name|vp
condition|)
block|{
name|lockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* keep the daemon out */
name|vn_close
argument_list|(
name|drive
operator|->
name|vp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|NOCRED
argument_list|,
name|drive
operator|->
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|vp
operator|->
name|v_usecount
condition|)
block|{
comment|/* XXX shouldn't happen */
name|printf
argument_list|(
literal|"close_drive %s: use count still %d\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|drive
operator|->
name|vp
operator|->
name|v_usecount
argument_list|)
expr_stmt|;
name|drive
operator|->
name|vp
operator|->
name|v_usecount
operator|=
literal|0
expr_stmt|;
comment|/* will this work? */
block|}
name|drive
operator|->
name|vp
operator|=
name|NULL
expr_stmt|;
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove drive from the configuration.  * Caller must ensure that it isn't active  */
end_comment

begin_function
name|void
name|remove_drive
parameter_list|(
name|int
name|driveno
parameter_list|)
block|{
name|struct
name|drive
modifier|*
name|drive
init|=
operator|&
name|vinum_conf
operator|.
name|drive
index|[
name|driveno
index|]
decl_stmt|;
name|long
name|long
name|int
name|nomagic
init|=
name|VINUM_NOMAGIC
decl_stmt|;
comment|/* no magic number */
name|write_drive
argument_list|(
name|drive
argument_list|,
comment|/* obliterate the magic, but leave a hint */
operator|(
name|char
operator|*
operator|)
operator|&
name|nomagic
argument_list|,
literal|8
argument_list|,
name|VINUM_LABEL_OFFSET
argument_list|)
expr_stmt|;
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* close it and free resources */
name|save_config
argument_list|()
expr_stmt|;
comment|/* and save the updated configuration */
block|}
end_function

begin_comment
comment|/* Transfer drive data.  Usually called from one of these defines;  * #define read_drive(a, b, c, d) driveio (a, b, c, d, B_READ)  * #define write_drive(a, b, c, d) driveio (a, b, c, d, B_WRITE)  *  * length and offset are in bytes, but must be multiples of sector  * size.  The function *does not check* for this condition, and  * truncates ruthlessly.  * Return error number  */
end_comment

begin_function
name|int
name|driveio
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|char
name|foo
index|[
literal|40
index|]
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* to keep the compiler happy */
while|while
condition|(
name|length
condition|)
block|{
comment|/* divide into small enough blocks */
name|int
name|len
init|=
name|min
argument_list|(
name|length
argument_list|,
name|MAXBSIZE
argument_list|)
decl_stmt|;
comment|/* maximum block device transfer is MAXBSIZE */
name|bp
operator|=
name|geteblk
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* get a buffer header */
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|flag
expr_stmt|;
comment|/* get busy */
name|bp
operator|->
name|b_proc
operator|=
name|curproc
expr_stmt|;
comment|/* process */
name|bp
operator|->
name|b_dev
operator|=
name|drive
operator|->
name|vp
operator|->
name|v_un
operator|.
name|vu_specinfo
operator|->
name|si_rdev
expr_stmt|;
comment|/* device */
name|bp
operator|->
name|b_blkno
operator|=
name|offset
operator|/
name|drive
operator|->
name|partinfo
operator|.
name|disklab
operator|->
name|d_secsize
expr_stmt|;
comment|/* block number */
name|bp
operator|->
name|b_data
operator|=
name|buf
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|len
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|len
expr_stmt|;
operator|(
operator|*
name|bdevsw
index|[
name|major
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|->
name|d_strategy
operator|)
operator|(
name|bp
operator|)
expr_stmt|;
comment|/* initiate the transfer */
name|error
operator|=
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"driveio: %s dev 0x%x, block 0x%x, len 0x%lx, error %d\n"
argument_list|,
comment|/* XXX */
name|flag
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|bp
operator|->
name|b_dev
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|foo
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|foo
index|[
literal|39
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"---> %s\n"
argument_list|,
name|foo
argument_list|)
expr_stmt|;
comment|/* XXXXXX */
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|length
operator|-=
name|len
expr_stmt|;
comment|/* update pointers */
name|buf
operator|+=
name|len
expr_stmt|;
name|offset
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Read data from a drive   * Return error number  */
end_comment

begin_function
name|int
name|read_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|nextbn
decl_stmt|;
name|long
name|bscale
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|daddr_t
name|blocknum
decl_stmt|;
comment|/* block number */
name|int
name|blockoff
decl_stmt|;
comment|/* offset in block */
name|int
name|count
decl_stmt|;
comment|/* amount to transfer */
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|length
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
name|length
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|length
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uio
operator|.
name|uio_procp
operator|=
name|curproc
expr_stmt|;
name|bscale
operator|=
name|btodb
argument_list|(
name|drive
operator|->
name|blocksize
argument_list|)
expr_stmt|;
comment|/* mask off offset from block number */
do|do
block|{
name|blocknum
operator|=
name|btodb
argument_list|(
name|uio
operator|.
name|uio_offset
argument_list|)
operator|&
operator|~
operator|(
name|bscale
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* get the block number */
name|blockoff
operator|=
name|uio
operator|.
name|uio_offset
operator|%
name|drive
operator|->
name|blocksize
expr_stmt|;
comment|/* offset in block */
name|count
operator|=
name|min
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|drive
operator|->
name|blocksize
operator|-
name|blockoff
argument_list|)
argument_list|,
comment|/* amount to transfer in this block */
name|uio
operator|.
name|uio_resid
argument_list|)
expr_stmt|;
comment|/* XXX Check this.  I think the test is wrong */
if|if
condition|(
name|drive
operator|->
name|vp
operator|->
name|v_lastr
operator|+
name|bscale
operator|==
name|blocknum
condition|)
block|{
comment|/* did our last read finish in this block? */
name|nextbn
operator|=
name|blocknum
operator|+
name|bscale
expr_stmt|;
comment|/* note the end of the transfer */
name|error
operator|=
name|breadn
argument_list|(
name|drive
operator|->
name|vp
argument_list|,
comment|/* and read with read-ahead */
name|blocknum
argument_list|,
operator|(
name|int
operator|)
name|drive
operator|->
name|blocksize
argument_list|,
operator|&
name|nextbn
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|drive
operator|->
name|blocksize
argument_list|,
literal|1
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* random read: just read this block */
name|error
operator|=
name|bread
argument_list|(
name|drive
operator|->
name|vp
argument_list|,
name|blocknum
argument_list|,
operator|(
name|int
operator|)
name|drive
operator|->
name|blocksize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|drive
operator|->
name|vp
operator|->
name|v_lastr
operator|=
name|blocknum
expr_stmt|;
comment|/* note the last block we read */
name|count
operator|=
name|min
argument_list|(
name|count
argument_list|,
name|drive
operator|->
name|blocksize
operator|-
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|blockoff
argument_list|,
name|count
argument_list|,
operator|&
name|uio
argument_list|)
expr_stmt|;
comment|/* move the data */
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
literal|0
operator|&&
name|uio
operator|.
name|uio_resid
operator|>
literal|0
operator|&&
name|count
operator|!=
literal|0
condition|)
do|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Write data to a drive   * Return error number  */
end_comment

begin_function
name|int
name|write_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|length
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|daddr_t
name|blocknum
decl_stmt|;
comment|/* block number */
name|int
name|blockoff
decl_stmt|;
comment|/* offset in block */
name|int
name|count
decl_stmt|;
comment|/* amount to transfer */
name|int
name|blockshift
decl_stmt|;
if|if
condition|(
name|drive
operator|->
name|state
operator|==
name|drive_down
condition|)
comment|/* currently down */
return|return
literal|0
return|;
comment|/* ignore */
if|if
condition|(
name|drive
operator|->
name|vp
operator|==
name|NULL
condition|)
block|{
name|drive
operator|->
name|lasterror
operator|=
name|ENODEV
expr_stmt|;
return|return
name|ENODEV
return|;
comment|/* not configured yet */
block|}
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|length
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
name|length
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|length
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uio
operator|.
name|uio_procp
operator|=
name|curproc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|blockshift
operator|=
name|btodb
argument_list|(
name|drive
operator|->
name|blocksize
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* amount to shift block number 							    * to get sector number */
do|do
block|{
name|blocknum
operator|=
name|btodb
argument_list|(
name|uio
operator|.
name|uio_offset
argument_list|)
operator|&
operator|~
name|blockshift
expr_stmt|;
comment|/* get the block number */
name|blockoff
operator|=
name|uio
operator|.
name|uio_offset
operator|%
name|drive
operator|->
name|blocksize
expr_stmt|;
comment|/* offset in block */
name|count
operator|=
name|min
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|drive
operator|->
name|blocksize
operator|-
name|blockoff
argument_list|)
argument_list|,
comment|/* amount to transfer in this block */
name|uio
operator|.
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|drive
operator|->
name|blocksize
condition|)
comment|/* the whole block */
name|bp
operator|=
name|getblk
argument_list|(
name|drive
operator|->
name|vp
argument_list|,
name|blocknum
argument_list|,
name|drive
operator|->
name|blocksize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* just transfer it */
else|else
comment|/* partial block: */
name|error
operator|=
name|bread
argument_list|(
name|drive
operator|->
name|vp
argument_list|,
comment|/* read it first */
name|blocknum
argument_list|,
name|drive
operator|->
name|blocksize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|count
argument_list|,
name|drive
operator|->
name|blocksize
operator|-
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
comment|/* how much will we transfer now? */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|blockoff
argument_list|,
comment|/* move the data to the block */
name|count
argument_list|,
operator|&
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|drive
operator|->
name|lasterror
operator|=
name|error
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EIO
case|:
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
break|break;
comment|/* XXX Add other possibilities here */
default|default:
block|}
return|return
name|error
return|;
block|}
if|if
condition|(
name|count
operator|+
name|blockoff
operator|==
name|drive
operator|->
name|blocksize
condition|)
comment|/* The transfer goes to the end of the block.  There's 	     * no need to wait for any more data to arrive. */
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* start the write now */
else|else
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* do a delayed write */
block|}
do|while
condition|(
name|error
operator|==
literal|0
operator|&&
name|uio
operator|.
name|uio_resid
operator|>
literal|0
operator|&&
name|count
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|error
condition|)
name|drive
operator|->
name|lasterror
operator|=
name|error
expr_stmt|;
return|return
name|error
return|;
comment|/* OK */
block|}
end_function

begin_comment
comment|/* Wake up on completion */
end_comment

begin_function
name|void
name|drive_io_done
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
comment|/* Wachet auf! */
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_CALL
expr_stmt|;
comment|/* don't do this again */
block|}
end_function

begin_comment
comment|/* Check a drive for a vinum header.  If found,   * update the drive information.  We come here  * with a partially populated drive structure  * which includes the device name.  *  * Return information on what we found.  *  * This function is called from two places: check_drive,  * which wants to find out whether the drive is a  * Vinum drive, and config_drive, which asserts that  * it is a vinum drive.  In the first case, we don't  * print error messages (verbose==0), in the second  * we do (verbose==1).  */
end_comment

begin_function
name|enum
name|drive_label_info
name|read_drive_label
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* result of our search */
name|struct
name|vinum_hdr
modifier|*
name|vhdr
decl_stmt|;
comment|/* and as header */
name|error
operator|=
name|init_drive
argument_list|(
name|drive
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* find the drive */
if|if
condition|(
name|error
condition|)
comment|/* find the drive */
return|return
name|DL_CANT_OPEN
return|;
comment|/* not ours */
name|vhdr
operator|=
operator|(
expr|struct
name|vinum_hdr
operator|*
operator|)
name|Malloc
argument_list|(
name|VINUMHEADERLEN
argument_list|)
expr_stmt|;
comment|/* allocate buffers */
name|CHECKALLOC
argument_list|(
name|vhdr
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
name|error
operator|=
name|read_drive
argument_list|(
name|drive
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vhdr
argument_list|,
name|VINUMHEADERLEN
argument_list|,
name|VINUM_LABEL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|vhdr
operator|->
name|magic
operator|==
name|VINUM_MAGIC
condition|)
block|{
comment|/* ours! */
if|if
condition|(
name|drive
operator|->
name|label
operator|.
name|name
index|[
literal|0
index|]
comment|/* we have a name for this drive */
operator|&&
operator|(
name|strcmp
argument_list|(
name|drive
operator|->
name|label
operator|.
name|name
argument_list|,
name|vhdr
operator|->
name|label
operator|.
name|name
argument_list|)
operator|)
condition|)
block|{
comment|/* but it doesn't match the real name */
name|drive
operator|->
name|lasterror
operator|=
name|EINVAL
expr_stmt|;
name|result
operator|=
name|DL_WRONG_DRIVE
expr_stmt|;
comment|/* it's the wrong drive */
block|}
else|else
block|{
name|drive
operator|->
name|state
operator|=
name|drive_up
expr_stmt|;
comment|/* it's OK by us */
name|result
operator|=
name|DL_OURS
expr_stmt|;
block|}
comment|/* We copy the drive anyway so that we have 	 * the correct name in the drive info.  This 	 * may not be the name specified */
name|drive
operator|->
name|label
operator|=
name|vhdr
operator|->
name|label
expr_stmt|;
comment|/* put in the label information */
block|}
elseif|else
if|if
condition|(
name|vhdr
operator|->
name|magic
operator|==
name|VINUM_NOMAGIC
condition|)
comment|/* was ours, but we gave it away */
name|result
operator|=
name|DL_DELETED_LABEL
expr_stmt|;
else|else
name|result
operator|=
name|DL_NOT_OURS
expr_stmt|;
comment|/* we could have it, but we don't yet */
name|Free
argument_list|(
name|vhdr
argument_list|)
expr_stmt|;
comment|/* that's all. */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Check a drive for a vinum header.  If found,   * read configuration information from the drive and  * incorporate the data into the configuration.  *  * Return   */
end_comment

begin_function
name|struct
name|drive
modifier|*
name|check_drive
parameter_list|(
name|char
modifier|*
name|drivename
parameter_list|)
block|{
name|int
name|driveno
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
name|driveno
operator|=
name|find_drive_by_dev
argument_list|(
name|drivename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* entry doesn't exist, create it */
name|drive
operator|=
operator|&
name|vinum_conf
operator|.
name|drive
index|[
name|driveno
index|]
expr_stmt|;
comment|/* and get a pointer */
if|if
condition|(
name|read_drive_label
argument_list|(
name|drive
argument_list|,
literal|0
argument_list|)
operator|!=
name|DL_OURS
condition|)
block|{
comment|/* not ours */
if|if
condition|(
name|drive
operator|->
name|lasterror
operator|==
literal|0
condition|)
name|drive
operator|->
name|lasterror
operator|=
name|ENODEV
expr_stmt|;
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
block|}
return|return
name|drive
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sappend
parameter_list|(
name|char
modifier|*
name|txt
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s
operator|++
operator|=
operator|*
name|txt
operator|++
condition|)
empty_stmt|;
return|return
name|s
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Kludge: kernel printf doesn't handle quads correctly XXX */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|lltoa
parameter_list|(
name|long
name|long
name|l
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|lltoa
parameter_list|(
name|long
name|long
name|l
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|l
operator|<
literal|0
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'-'
expr_stmt|;
name|l
operator|=
operator|-
name|l
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|>
literal|9
condition|)
block|{
name|s
operator|=
name|lltoa
argument_list|(
name|l
operator|/
literal|10
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|l
operator|%=
literal|10
expr_stmt|;
block|}
operator|*
name|s
operator|++
operator|=
name|l
operator|+
literal|'0'
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Format the configuration in text form into the buffer  * at config.  Don't go beyond len bytes  * XXX this stinks.  Fix soon. */
end_comment

begin_function
name|void
name|format_config
parameter_list|(
name|char
modifier|*
name|config
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|config
decl_stmt|;
name|bzero
argument_list|(
name|config
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* First the volume configuration */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|volumes_used
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|vol
operator|=
operator|&
name|vinum_conf
operator|.
name|volume
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|state
operator|!=
name|volume_unallocated
condition|)
block|{
if|if
condition|(
name|vol
operator|->
name|preferred_plex
operator|>=
literal|0
condition|)
comment|/* preferences, */
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"volume %s state %s readpol prefer %s"
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|volume_state
argument_list|(
name|vol
operator|->
name|state
argument_list|)
argument_list|,
name|vinum_conf
operator|.
name|plex
index|[
name|vol
operator|->
name|preferred_plex
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
comment|/* default round-robin */
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"volume %s state %s"
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|volume_state
argument_list|(
name|vol
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
name|s
operator|=
name|sappend
argument_list|(
literal|"\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
operator|&
name|config
index|[
name|len
operator|-
literal|80
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"vinum: configuration data overflow\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* Then the plex configuration */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|plexes_used
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|plex
operator|=
operator|&
name|vinum_conf
operator|.
name|plex
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|state
operator|!=
name|plex_unallocated
condition|)
block|{
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"plex name %s state %s org %s "
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|plex_state
argument_list|(
name|plex
operator|->
name|state
argument_list|)
argument_list|,
name|plex_org
argument_list|(
name|plex
operator|->
name|organization
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
if|if
condition|(
operator|(
name|plex
operator|->
name|organization
operator|==
name|plex_striped
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%db "
argument_list|,
operator|(
name|int
operator|)
name|plex
operator|->
name|stripesize
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
block|}
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
comment|/* we have a volume */
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"vol %s "
argument_list|,
name|vinum_conf
operator|.
name|volume
index|[
name|plex
operator|->
name|volno
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|j
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|s
argument_list|,
literal|" sd %s"
argument_list|,
name|vinum_conf
operator|.
name|sd
index|[
name|plex
operator|->
name|sdnos
index|[
name|j
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|sappend
argument_list|(
literal|"\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
operator|&
name|config
index|[
name|len
operator|-
literal|80
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"vinum: configuration data overflow\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* And finally the subdisk configuration */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|subdisks_used
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sd
modifier|*
name|sd
init|=
operator|&
name|vinum_conf
operator|.
name|sd
index|[
name|i
index|]
decl_stmt|;
comment|/* XXX */
if|if
condition|(
name|vinum_conf
operator|.
name|sd
index|[
name|i
index|]
operator|.
name|state
operator|!=
name|sd_unallocated
condition|)
block|{
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"sd name %s drive %s plex %s state %s len "
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|vinum_conf
operator|.
name|drive
index|[
name|sd
operator|->
name|driveno
index|]
operator|.
name|label
operator|.
name|name
argument_list|,
name|vinum_conf
operator|.
name|plex
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
comment|/* find the end */
name|s
operator|=
name|lltoa
argument_list|(
name|sd
operator|->
name|sectors
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|sappend
argument_list|(
literal|"b driveoffset "
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|lltoa
argument_list|(
name|sd
operator|->
name|driveoffset
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|sappend
argument_list|(
literal|"b plexoffset "
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|lltoa
argument_list|(
name|sd
operator|->
name|plexoffset
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|sappend
argument_list|(
literal|"b\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
operator|&
name|config
index|[
name|len
operator|-
literal|80
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"vinum: configuration data overflow\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* issue a save config request to the dæmon.  The actual work  * is done in process context by daemon_save_config */
end_comment

begin_function
name|void
name|save_config
parameter_list|(
name|void
parameter_list|)
block|{
name|queue_daemon_request
argument_list|(
name|daemonrq_saveconfig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the configuration to all vinum slices.  This  * is performed by the dæmon only */
end_comment

begin_function
name|void
name|daemon_save_config
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|written_config
decl_stmt|;
comment|/* set when we first write the config to disk */
name|int
name|driveno
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
comment|/* point to current drive info */
name|struct
name|vinum_hdr
modifier|*
name|vhdr
decl_stmt|;
comment|/* and as header */
name|char
modifier|*
name|config
decl_stmt|;
comment|/* point to config data */
name|int
name|wlabel_on
decl_stmt|;
comment|/* to set writing label on/off */
comment|/* don't save the configuration while we're still working on it */
if|if
condition|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_CONFIGURING
condition|)
return|return;
name|written_config
operator|=
literal|0
expr_stmt|;
comment|/* no config written yet */
comment|/* Build a volume header */
name|vhdr
operator|=
operator|(
expr|struct
name|vinum_hdr
operator|*
operator|)
name|Malloc
argument_list|(
name|VINUMHEADERLEN
argument_list|)
expr_stmt|;
comment|/* get space for the config data */
name|CHECKALLOC
argument_list|(
name|vhdr
argument_list|,
literal|"Can't allocate config data"
argument_list|)
expr_stmt|;
name|vhdr
operator|->
name|magic
operator|=
name|VINUM_MAGIC
expr_stmt|;
comment|/* magic number */
name|vhdr
operator|->
name|config_length
operator|=
name|MAXCONFIG
expr_stmt|;
comment|/* length of following config info */
name|config
operator|=
name|Malloc
argument_list|(
name|MAXCONFIG
argument_list|)
expr_stmt|;
comment|/* get space for the config data */
name|CHECKALLOC
argument_list|(
name|config
argument_list|,
literal|"Can't allocate config data"
argument_list|)
expr_stmt|;
name|format_config
argument_list|(
name|config
argument_list|,
name|MAXCONFIG
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* no errors yet */
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|vinum_conf
operator|.
name|drives_used
condition|;
name|driveno
operator|++
control|)
block|{
name|drive
operator|=
operator|&
name|vinum_conf
operator|.
name|drive
index|[
name|driveno
index|]
expr_stmt|;
comment|/* point to drive */
name|lockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* don't let it change */
comment|/* First, do some drive consistency checks.  Some 	 * of these are kludges, others require a process 	 * context and couldn't be done before */
if|if
condition|(
operator|(
name|drive
operator|->
name|devicename
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
comment|/* XXX we keep getting these nameless drives */
operator|||
operator|(
name|drive
operator|->
name|label
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* XXX we keep getting these nameless drives */
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Removing incomplete drive, index %d\n"
argument_list|,
name|driveno
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|vp
condition|)
comment|/* how can it be open without a name? */
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* get rid of it */
break|break;
block|}
if|if
condition|(
operator|(
name|drive
operator|->
name|vp
operator|==
name|NULL
operator|)
comment|/* drive not open */
operator|&&
operator|(
name|drive
operator|->
name|state
operator|>
name|drive_down
operator|)
condition|)
block|{
comment|/* and it thinks it's not down */
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|set_drive_state
argument_list|(
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* tell it what's what */
block|}
if|if
condition|(
operator|(
name|drive
operator|->
name|state
operator|==
name|drive_down
operator|)
comment|/* it's down */
operator|&&
operator|(
name|drive
operator|->
name|vp
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* but open, */
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* close it */
block|}
elseif|else
if|if
condition|(
name|drive
operator|->
name|state
operator|>
name|drive_down
condition|)
block|{
name|drive
operator|->
name|label
operator|.
name|last_update
operator|=
name|time
expr_stmt|;
comment|/* time of last update is now */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|drive
operator|->
name|label
argument_list|,
comment|/* and the label info from the drive structure */
operator|(
name|char
operator|*
operator|)
operator|&
name|vhdr
operator|->
name|label
argument_list|,
sizeof|sizeof
argument_list|(
name|vhdr
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|drive
operator|->
name|state
operator|!=
name|drive_unallocated
operator|)
operator|&&
operator|(
name|drive
operator|->
name|state
operator|!=
name|drive_uninit
operator|)
condition|)
block|{
name|wlabel_on
operator|=
literal|1
expr_stmt|;
comment|/* enable writing the label */
name|error
operator|=
name|VOP_IOCTL
argument_list|(
name|drive
operator|->
name|vp
argument_list|,
comment|/* make the label writeable */
name|DIOCWLABEL
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|wlabel_on
argument_list|,
name|FWRITE
argument_list|,
name|NOCRED
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|write_drive
argument_list|(
name|drive
argument_list|,
operator|(
name|char
operator|*
operator|)
name|vhdr
argument_list|,
name|VINUMHEADERLEN
argument_list|,
name|VINUM_LABEL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|write_drive
argument_list|(
name|drive
argument_list|,
name|config
argument_list|,
name|MAXCONFIG
argument_list|,
name|VINUM_CONFIG_OFFSET
argument_list|)
expr_stmt|;
comment|/* first config copy */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|write_drive
argument_list|(
name|drive
argument_list|,
name|config
argument_list|,
name|MAXCONFIG
argument_list|,
name|VINUM_CONFIG_OFFSET
operator|+
name|MAXCONFIG
argument_list|)
expr_stmt|;
comment|/* second copy */
name|wlabel_on
operator|=
literal|0
expr_stmt|;
comment|/* enable writing the label */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|VOP_IOCTL
argument_list|(
name|drive
operator|->
name|vp
argument_list|,
comment|/* make the label non-writeable again */
name|DIOCWLABEL
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|wlabel_on
argument_list|,
name|FWRITE
argument_list|,
name|NOCRED
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"vinum: Can't write config to %s, error %d\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|set_drive_state
argument_list|(
name|drive
operator|->
name|driveno
argument_list|,
name|drive_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
block|}
else|else
name|written_config
operator|=
literal|1
expr_stmt|;
comment|/* we've written it on at least one drive */
block|}
block|}
block|}
name|Free
argument_list|(
name|vhdr
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Disk labels are a mess.  The correct way to access them  * is with the DIOC[GSW]DINFO ioctls, but some programs, such  * as newfs, access the disk directly, so we have to write  * things there.  We do this only on request.  If a user  * request tries to read it directly, we fake up one on the fly.  */
end_comment

begin_comment
comment|/* get_volume_label returns a label structure to lp, which  * is allocated by the caller */
end_comment

begin_function
name|void
name|get_volume_label
parameter_list|(
name|struct
name|volume
modifier|*
name|vol
parameter_list|,
name|struct
name|disklabel
modifier|*
name|lp
parameter_list|)
block|{
name|bzero
argument_list|(
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disklabel
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|lp
operator|->
name|d_typename
argument_list|,
literal|"vinum"
argument_list|,
sizeof|sizeof
argument_list|(
name|lp
operator|->
name|d_typename
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|d_type
operator|=
name|DTYPE_VINUM
expr_stmt|;
name|strncpy
argument_list|(
name|lp
operator|->
name|d_packname
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|lp
operator|->
name|d_packname
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vol
operator|->
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|d_rpm
operator|=
literal|14400
operator|*
name|vol
operator|->
name|plexes
expr_stmt|;
comment|/* to keep them guessing */
name|lp
operator|->
name|d_interleave
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|d_flags
operator|=
literal|0
expr_stmt|;
comment|/* Fitting unto the vine, a vinum has a single      *  track with all its sectors */
name|lp
operator|->
name|d_secsize
operator|=
name|DEV_BSIZE
expr_stmt|;
comment|/* bytes per sector */
name|lp
operator|->
name|d_nsectors
operator|=
name|vol
operator|->
name|size
expr_stmt|;
comment|/* data sectors per track */
name|lp
operator|->
name|d_ntracks
operator|=
literal|1
expr_stmt|;
comment|/* tracks per cylinder */
name|lp
operator|->
name|d_ncylinders
operator|=
literal|1
expr_stmt|;
comment|/* data cylinders per unit */
name|lp
operator|->
name|d_secpercyl
operator|=
name|vol
operator|->
name|size
expr_stmt|;
comment|/* data sectors per cylinder */
name|lp
operator|->
name|d_secperunit
operator|=
name|vol
operator|->
name|size
expr_stmt|;
comment|/* data sectors per unit */
name|lp
operator|->
name|d_bbsize
operator|=
name|BBSIZE
expr_stmt|;
name|lp
operator|->
name|d_sbsize
operator|=
name|SBSIZE
expr_stmt|;
name|lp
operator|->
name|d_magic
operator|=
name|DISKMAGIC
expr_stmt|;
name|lp
operator|->
name|d_magic2
operator|=
name|DISKMAGIC
expr_stmt|;
comment|/* Set up partitions a, b and c to be identical      * and the size of the volume.  a is UFS, b is      * swap, c is nothing */
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
name|vol
operator|->
name|size
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_fsize
operator|=
literal|1024
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_fstype
operator|=
name|FS_BSDFFS
expr_stmt|;
comment|/* FreeBSD File System :-) */
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_fsize
operator|=
literal|1024
expr_stmt|;
comment|/* FS fragment size */
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_frag
operator|=
literal|8
expr_stmt|;
comment|/* and fragments per block */
name|lp
operator|->
name|d_partitions
index|[
name|SWAP_PART
index|]
operator|.
name|p_size
operator|=
name|vol
operator|->
name|size
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
name|SWAP_PART
index|]
operator|.
name|p_fstype
operator|=
name|FS_SWAP
expr_stmt|;
comment|/* swap partition */
name|lp
operator|->
name|d_partitions
index|[
name|LABEL_PART
index|]
operator|.
name|p_size
operator|=
name|vol
operator|->
name|size
expr_stmt|;
name|lp
operator|->
name|d_npartitions
operator|=
name|LABEL_PART
operator|+
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|lp
operator|->
name|d_packname
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|lp
operator|->
name|d_packname
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vol
operator|->
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|d_checksum
operator|=
name|dkcksum
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a volume label.  This implements the VINUM_LABEL ioctl. */
end_comment

begin_function
name|int
name|write_volume_label
parameter_list|(
name|int
name|volno
parameter_list|)
block|{
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dlp
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|int
name|error
decl_stmt|;
name|lp
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|Malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|disklabel
argument_list|)
operator|+
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|volno
argument_list|)
operator|>=
operator|(
name|unsigned
operator|)
name|vinum_conf
operator|.
name|volumes_used
condition|)
comment|/* invalid volume */
return|return
name|ENOENT
return|;
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
comment|/* volume in question */
if|if
condition|(
name|vol
operator|->
name|state
operator|==
name|volume_unallocated
condition|)
comment|/* nothing there */
return|return
name|ENOENT
return|;
name|get_volume_label
argument_list|(
name|vol
argument_list|,
name|lp
argument_list|)
expr_stmt|;
comment|/* get the label */
comment|/* Now write to disk.  This code is derived from the      * system writedisklabel (), which does silly things      * like reading the label and refusing to write      * unless it's already there. */
name|bp
operator|=
name|geteblk
argument_list|(
operator|(
name|int
operator|)
name|lp
operator|->
name|d_secsize
argument_list|)
expr_stmt|;
comment|/* get a buffer */
name|bp
operator|->
name|b_dev
operator|=
name|minor
argument_list|(
name|vol
operator|->
name|devno
argument_list|)
operator||
operator|(
name|CDEV_MAJOR
operator|<<
name|MAJORDEV_SHIFT
operator|)
expr_stmt|;
comment|/* our own raw volume */
name|bp
operator|->
name|b_blkno
operator|=
name|LABELSECTOR
operator|*
operator|(
operator|(
name|int
operator|)
name|lp
operator|->
name|d_secsize
operator|/
name|DEV_BSIZE
operator|)
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|lp
operator|->
name|d_secsize
argument_list|)
expr_stmt|;
name|dlp
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
operator|*
name|dlp
operator|=
operator|*
name|lp
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_INVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
operator||
name|B_WRITE
expr_stmt|;
name|vinumstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* write it out */
name|error
operator|=
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Initialize a subdisk */
end_comment

begin_function
name|int
name|initsd
parameter_list|(
name|int
name|sdno
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look at all disks on the system for vinum slices */
end_comment

begin_function
name|void
name|vinum_scandisk
parameter_list|(
name|char
modifier|*
name|drivename
index|[]
parameter_list|,
name|int
name|drives
parameter_list|)
block|{
name|struct
name|drive
modifier|*
specifier|volatile
name|drive
decl_stmt|;
specifier|volatile
name|int
name|driveno
decl_stmt|;
name|int
name|firstdrive
decl_stmt|;
comment|/* first drive in this list */
specifier|volatile
name|int
name|gooddrives
decl_stmt|;
comment|/* number of usable drives found */
name|int
name|firsttime
decl_stmt|;
comment|/* set if we have never configured before */
name|int
name|error
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
comment|/* mount point credentials */
name|char
modifier|*
name|config_text
decl_stmt|;
comment|/* read the config info from disk into here */
name|char
modifier|*
specifier|volatile
name|cptr
decl_stmt|;
comment|/* pointer into config information */
name|char
modifier|*
name|eptr
decl_stmt|;
comment|/* end pointer into config information */
name|char
modifier|*
name|config_line
decl_stmt|;
comment|/* copy the config line to */
specifier|volatile
name|int
name|status
decl_stmt|;
name|struct
name|drive
modifier|*
modifier|*
specifier|volatile
name|drivelist
decl_stmt|;
define|#
directive|define
name|DRIVENAMELEN
value|64
define|#
directive|define
name|DRIVEPARTS
value|35
comment|/* max partitions per drive, excluding c */
name|char
name|partname
index|[
name|DRIVENAMELEN
index|]
decl_stmt|;
comment|/* for creating partition names */
name|status
operator|=
literal|0
expr_stmt|;
comment|/* success indication */
name|vinum_conf
operator|.
name|flags
operator||=
name|VF_KERNELOP
operator||
name|VF_READING_CONFIG
expr_stmt|;
comment|/* kernel operation: reading config */
name|gooddrives
operator|=
literal|0
expr_stmt|;
comment|/* number of usable drives found */
name|firstdrive
operator|=
name|vinum_conf
operator|.
name|drives_used
expr_stmt|;
comment|/* the first drive */
name|firsttime
operator|=
name|vinum_conf
operator|.
name|drives_used
operator|==
literal|0
expr_stmt|;
comment|/* are we a virgin? */
comment|/* allocate a drive pointer list */
name|drivelist
operator|=
operator|(
expr|struct
name|drive
operator|*
operator|*
operator|)
name|Malloc
argument_list|(
name|drives
operator|*
name|DRIVEPARTS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|CHECKALLOC
argument_list|(
name|drivelist
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
comment|/* Open all drives and find which was modified most recently */
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|drives
condition|;
name|driveno
operator|++
control|)
block|{
name|char
name|part
decl_stmt|;
comment|/* UNIX partition */
for|for
control|(
name|part
operator|=
literal|'a'
init|;
name|part
operator|<
literal|'i'
condition|;
name|part
operator|++
control|)
if|if
condition|(
name|part
operator|!=
literal|'c'
condition|)
block|{
comment|/* don't do the c partition */
name|sprintf
argument_list|(
name|partname
argument_list|,
comment|/* /dev/sd0a */
literal|"%s%c"
argument_list|,
name|drivename
index|[
name|driveno
index|]
argument_list|,
name|part
argument_list|)
expr_stmt|;
name|drive
operator|=
name|check_drive
argument_list|(
name|partname
argument_list|)
expr_stmt|;
comment|/* try to open it */
if|if
condition|(
name|drive
operator|->
name|lasterror
operator|!=
literal|0
condition|)
comment|/* didn't work, */
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* get rid of it */
elseif|else
if|if
condition|(
name|drive
operator|->
name|flags
operator|&
name|VF_CONFIGURED
condition|)
comment|/* already read this config, */
name|printf
argument_list|(
literal|"vinum: already read config from %s\n"
argument_list|,
comment|/* say so */
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|drivelist
index|[
name|gooddrives
index|]
operator|=
name|drive
expr_stmt|;
comment|/* keep a pointer to the drive */
name|drive
operator|->
name|flags
operator|&=
operator|~
name|VF_NEWBORN
expr_stmt|;
comment|/* which is no longer newly born */
name|gooddrives
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|gooddrives
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vinum: no drives found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We now have at least one drive      * open.  Sort them in order of config time      * and merge the config info with what we      * have already */
name|qsort
argument_list|(
name|drivelist
argument_list|,
name|gooddrives
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|drive
operator|*
argument_list|)
argument_list|,
name|drivecmp
argument_list|)
expr_stmt|;
name|config_text
operator|=
operator|(
name|char
operator|*
operator|)
name|Malloc
argument_list|(
name|MAXCONFIG
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* allocate buffers */
name|CHECKALLOC
argument_list|(
name|config_text
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
name|config_line
operator|=
operator|(
name|char
operator|*
operator|)
name|Malloc
argument_list|(
name|MAXCONFIGLINE
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* allocate buffers */
name|CHECKALLOC
argument_list|(
name|config_line
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|gooddrives
condition|;
name|driveno
operator|++
control|)
block|{
comment|/* now include the config */
name|drive
operator|=
name|drivelist
index|[
name|driveno
index|]
expr_stmt|;
if|if
condition|(
name|firsttime
operator|&&
operator|(
name|driveno
operator|==
literal|0
operator|)
condition|)
comment|/* we've never configured before, */
name|printf
argument_list|(
literal|"vinum: reading configuration from %s\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"vinum: updating configuration from %s\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|)
expr_stmt|;
comment|/* Read in both copies of the configuration information */
name|error
operator|=
name|read_drive
argument_list|(
name|drive
argument_list|,
name|config_text
argument_list|,
name|MAXCONFIG
operator|*
literal|2
argument_list|,
name|VINUM_CONFIG_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vinum: Can't read device %s, error %d\n"
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|config_text
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|config_line
argument_list|)
expr_stmt|;
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* give it back */
name|status
operator|=
name|error
expr_stmt|;
block|}
comment|/* XXX At this point, check that the two copies are the same, and do something useful if not. 	 * In particular, consider which is newer, and what this means for the integrity of the 	 * data on the drive */
else|else
block|{
comment|/* Parse the configuration, and add it to the global configuration */
for|for
control|(
name|cptr
operator|=
name|config_text
init|;
operator|*
name|cptr
operator|!=
literal|'\0'
condition|;
control|)
block|{
comment|/* love this style(9) */
specifier|volatile
name|int
name|parse_status
decl_stmt|;
comment|/* return value from parse_config */
for|for
control|(
name|eptr
operator|=
name|config_line
init|;
operator|(
operator|*
name|cptr
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
operator|*
name|cptr
operator|!=
literal|'\0'
operator|)
condition|;
control|)
comment|/* until the end of the line */
operator|*
name|eptr
operator|++
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
operator|*
name|eptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* and delimit */
if|if
condition|(
name|setjmp
argument_list|(
name|command_fail
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* come back here on error and continue */
name|parse_status
operator|=
name|parse_config
argument_list|(
name|config_line
argument_list|,
operator|&
name|keyword_set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* parse the config line */
if|if
condition|(
name|parse_status
operator|<
literal|0
condition|)
block|{
comment|/* error in config */
comment|/* This config should have been parsed in user 			   * space.  If we run into problems here, something 			   * serious is afoot.  Complain and let the user 			   * snarf the config to see what's wrong */
name|printf
argument_list|(
literal|"vinum: Config error on drive %s, aborting integration\n"
argument_list|,
name|nd
operator|.
name|ni_dirp
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|config_text
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|config_line
argument_list|)
expr_stmt|;
name|free_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* give it back */
name|status
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|*
name|cptr
operator|==
literal|'\n'
condition|)
name|cptr
operator|++
expr_stmt|;
comment|/* skip to next line */
block|}
block|}
name|drive
operator|->
name|flags
operator||=
name|VF_CONFIGURED
expr_stmt|;
comment|/* read this drive's configuration */
block|}
name|Free
argument_list|(
name|config_text
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|drivelist
argument_list|)
expr_stmt|;
name|vinum_conf
operator|.
name|flags
operator|&=
operator|~
operator|(
name|VF_KERNELOP
operator||
name|VF_READING_CONFIG
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|throw_rude_remark
argument_list|(
name|status
argument_list|,
literal|"Couldn't read configuration"
argument_list|)
expr_stmt|;
name|updateconfig
argument_list|(
name|VF_KERNELOP
argument_list|)
expr_stmt|;
comment|/* update from kernel space */
block|}
end_function

begin_comment
comment|/* Compare the modification dates of the drives, for qsort.  * Return 1 if a< b, 0 if a == b, 01 if a> b: in other  * words, sort backwards */
end_comment

begin_function
name|int
name|drivecmp
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
name|struct
name|drive
modifier|*
name|a
init|=
operator|*
operator|(
expr|struct
name|drive
operator|*
operator|*
operator|)
name|va
decl_stmt|;
name|struct
name|drive
modifier|*
name|b
init|=
operator|*
operator|(
expr|struct
name|drive
operator|*
operator|*
operator|)
name|vb
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|==
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_usec
operator|==
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_usec
operator|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|>
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|)
operator|||
operator|(
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|==
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|a
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_usec
operator|>
name|b
operator|->
name|label
operator|.
name|last_update
operator|.
name|tv_usec
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

end_unit

