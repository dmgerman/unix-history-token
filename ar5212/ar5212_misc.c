begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2008 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $Id: ar5212_misc.c,v 1.12 2008/11/27 22:30:00 sam Exp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AH_SUPPORT_AR5212
end_ifdef

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AH_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|"ah_desc.h"
end_include

begin_comment
comment|/* NB: for HAL_PHYERR* */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ar5212/ar5212.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212phy.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AH_SUPPORT_AR5311
end_ifdef

begin_include
include|#
directive|include
file|"ar5212/ar5311reg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ah_eeprom_v3.h"
end_include

begin_define
define|#
directive|define
name|AR_NUM_GPIO
value|6
end_define

begin_comment
comment|/* 6 GPIO pins */
end_comment

begin_define
define|#
directive|define
name|AR_GPIOD_MASK
value|0x0000002F
end_define

begin_comment
comment|/* GPIO data reg r/w mask */
end_comment

begin_function_decl
specifier|extern
name|void
name|ar5212SetRateDurationTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|,
name|HAL_CHANNEL
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ar5212GetMacAddress
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint8_t
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|OS_MEMCPY
argument_list|(
name|mac
argument_list|,
name|ahp
operator|->
name|ah_macaddr
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212SetMacAddress
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|mac
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|OS_MEMCPY
argument_list|(
name|ahp
operator|->
name|ah_macaddr
argument_list|,
name|mac
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|void
name|ar5212GetBssIdMask
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint8_t
modifier|*
name|mask
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|OS_MEMCPY
argument_list|(
name|mask
argument_list|,
name|ahp
operator|->
name|ah_bssidmask
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212SetBssIdMask
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|mask
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* save it since it must be rewritten on reset */
name|OS_MEMCPY
argument_list|(
name|ahp
operator|->
name|ah_bssidmask
argument_list|,
name|mask
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSSMSKL
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_bssidmask
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSSMSKU
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_bssidmask
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to change the cards operating regulatory domain to the given value  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212SetRegulatoryDomain
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint16_t
name|regDomain
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
name|HAL_STATUS
name|ecode
decl_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
operator|==
name|regDomain
condition|)
block|{
name|ecode
operator|=
name|HAL_EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_WRITEPROTECT
argument_list|)
condition|)
block|{
name|ecode
operator|=
name|HAL_EEWRITE
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|AH_SUPPORT_WRITE_REGDOMAIN
if|if
condition|(
name|ath_hal_eepromWrite
argument_list|(
name|ah
argument_list|,
name|AR_EEPROM_REG_DOMAIN
argument_list|,
name|regDomain
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: set regulatory domain to %u (0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|regDomain
argument_list|,
name|regDomain
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_currentRD
operator|=
name|regDomain
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
endif|#
directive|endif
name|ecode
operator|=
name|HAL_EIO
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|ecode
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Return the wireless modes (a,b,g,t) supported by hardware.  *  * This value is what is actually supported by the hardware  * and is unaffected by regulatory/country code settings.  */
end_comment

begin_function
name|u_int
name|ar5212GetWirelessModes
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int
name|mode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_AMODE
argument_list|)
condition|)
block|{
name|mode
operator|=
name|HAL_MODE_11A
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_TURBO5DISABLE
argument_list|)
condition|)
name|mode
operator||=
name|HAL_MODE_TURBO
operator||
name|HAL_MODE_108A
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halChanHalfRate
condition|)
name|mode
operator||=
name|HAL_MODE_11A_HALF_RATE
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halChanQuarterRate
condition|)
name|mode
operator||=
name|HAL_MODE_11A_QUARTER_RATE
expr_stmt|;
block|}
if|if
condition|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_BMODE
argument_list|)
condition|)
name|mode
operator||=
name|HAL_MODE_11B
expr_stmt|;
if|if
condition|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_GMODE
argument_list|)
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_subvendorid
operator|!=
name|AR_SUBVENDOR_ID_NOG
condition|)
block|{
name|mode
operator||=
name|HAL_MODE_11G
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_TURBO2DISABLE
argument_list|)
condition|)
name|mode
operator||=
name|HAL_MODE_108G
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halChanHalfRate
condition|)
name|mode
operator||=
name|HAL_MODE_11G_HALF_RATE
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halChanQuarterRate
condition|)
name|mode
operator||=
name|HAL_MODE_11G_QUARTER_RATE
expr_stmt|;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_comment
comment|/*  * Set the interrupt and GPIO values so the ISR can disable RF  * on a switch signal.  Assumes GPIO port and interrupt polarity  * are set prior to call.  */
end_comment

begin_function
name|void
name|ar5212EnableRfKill
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint16_t
name|rfsilent
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_rfsilent
decl_stmt|;
name|int
name|select
init|=
name|MS
argument_list|(
name|rfsilent
argument_list|,
name|AR_EEPROM_RFSILENT_GPIO_SEL
argument_list|)
decl_stmt|;
name|int
name|polarity
init|=
name|MS
argument_list|(
name|rfsilent
argument_list|,
name|AR_EEPROM_RFSILENT_POLARITY
argument_list|)
decl_stmt|;
comment|/* 	 * Configure the desired GPIO port for input 	 * and enable baseband rf silence. 	 */
name|ath_hal_gpioCfgInput
argument_list|(
name|ah
argument_list|,
name|select
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0x00002000
argument_list|)
expr_stmt|;
comment|/* 	 * If radio disable switch connection to GPIO bit x is enabled 	 * program GPIO interrupt. 	 * If rfkill bit on eeprom is 1, setupeeprommap routine has already 	 * verified that it is a later version of eeprom, it has a place for 	 * rfkill bit and it is set to 1, indicating that GPIO bit x hardware 	 * connection is present. 	 */
name|ath_hal_gpioSetIntr
argument_list|(
name|ah
argument_list|,
name|select
argument_list|,
operator|(
name|ath_hal_gpioGet
argument_list|(
name|ah
argument_list|,
name|select
argument_list|)
operator|==
name|polarity
condition|?
operator|!
name|polarity
else|:
name|polarity
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change the LED blinking pattern to correspond to the connectivity  */
end_comment

begin_function
name|void
name|ar5212SetLedState
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_LED_STATE
name|state
parameter_list|)
block|{
specifier|static
specifier|const
name|uint32_t
name|ledbits
index|[
literal|8
index|]
init|=
block|{
name|AR_PCICFG_LEDCTL_NONE
block|,
comment|/* HAL_LED_INIT */
name|AR_PCICFG_LEDCTL_PEND
block|,
comment|/* HAL_LED_SCAN */
name|AR_PCICFG_LEDCTL_PEND
block|,
comment|/* HAL_LED_AUTH */
name|AR_PCICFG_LEDCTL_ASSOC
block|,
comment|/* HAL_LED_ASSOC*/
name|AR_PCICFG_LEDCTL_ASSOC
block|,
comment|/* HAL_LED_RUN */
name|AR_PCICFG_LEDCTL_NONE
block|,
name|AR_PCICFG_LEDCTL_NONE
block|,
name|AR_PCICFG_LEDCTL_NONE
block|, 	}
decl_stmt|;
name|uint32_t
name|bits
decl_stmt|;
name|bits
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_2417
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* 		 * Enable LED for Nala. There is a bit marked reserved 		 * that must be set and we also turn on the power led. 		 * Because we mark s/w LED control setting the control 		 * status bits below is meangless (the driver must flash 		 * the LED(s) using the GPIO lines). 		 */
name|bits
operator|=
operator|(
name|bits
operator|&
operator|~
name|AR_PCICFG_LEDMODE
operator|)
operator||
name|SM
argument_list|(
name|AR_PCICFG_LEDMODE_POWON
argument_list|,
name|AR_PCICFG_LEDMODE
argument_list|)
if|#
directive|if
literal|0
expr|| SM(AR_PCICFG_LEDMODE_NETON, AR_PCICFG_LEDMODE)
endif|#
directive|endif
operator||
literal|0x08000000
expr_stmt|;
block|}
name|bits
operator|=
operator|(
name|bits
operator|&
operator|~
name|AR_PCICFG_LEDCTL
operator|)
operator||
name|SM
argument_list|(
name|ledbits
index|[
name|state
operator|&
literal|0x7
index|]
argument_list|,
name|AR_PCICFG_LEDCTL
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change association related fields programmed into the hardware.  * Writing a valid BSSID to the hardware effectively enables the hardware  * to synchronize its TSF to the correct beacons and receive frames coming  * from that BSSID. It is called by the SME JOIN operation.  */
end_comment

begin_function
name|void
name|ar5212WriteAssocid
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|bssid
parameter_list|,
name|uint16_t
name|assocId
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* XXX save bssid for possible re-use on reset */
name|OS_MEMCPY
argument_list|(
name|ahp
operator|->
name|ah_bssid
argument_list|,
name|bssid
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID0
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_bssid
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID1
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_bssid
operator|+
literal|4
argument_list|)
operator||
operator|(
operator|(
name|assocId
operator|&
literal|0x3fff
operator|)
operator|<<
name|AR_BSS_ID1_AID_S
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the current hardware tsf for stamlme  */
end_comment

begin_function
name|uint64_t
name|ar5212GetTsf64
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint32_t
name|low1
decl_stmt|,
name|low2
decl_stmt|,
name|u32
decl_stmt|;
comment|/* sync multi-word read */
name|low1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
expr_stmt|;
name|u32
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_U32
argument_list|)
expr_stmt|;
name|low2
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
expr_stmt|;
if|if
condition|(
name|low2
operator|<
name|low1
condition|)
block|{
comment|/* roll over */
comment|/* 		 * If we are not preempted this will work.  If we are 		 * then we re-reading AR_TSF_U32 does no good as the 		 * low bits will be meaningless.  Likewise reading 		 * L32, U32, U32, then comparing the last two reads 		 * to check for rollover doesn't help if preempted--so 		 * we take this approach as it costs one less PCI read 		 * which can be noticeable when doing things like 		 * timestamping packets in monitor mode. 		 */
name|u32
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|u32
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|low2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current hardware tsf for stamlme  */
end_comment

begin_function
name|uint32_t
name|ar5212GetTsf32
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset the current hardware tsf for stamlme.  */
end_comment

begin_function
name|void
name|ar5212ResetTsf
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint32_t
name|val
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|)
decl_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|,
name|val
operator||
name|AR_BEACON_RESET_TSF
argument_list|)
expr_stmt|;
comment|/* 	 * When resetting the TSF, write twice to the 	 * corresponding register; each write to the RESET_TSF bit toggles 	 * the internal signal to cause a reset of the TSF - but if the signal 	 * is left high, it will reset the TSF on the next chip reset also! 	 * writing the bit an even number of times fixes this issue 	 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BEACON
argument_list|,
name|val
operator||
name|AR_BEACON_RESET_TSF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set or clear hardware basic rate bit  * Set hardware basic rate set if basic rate is found  * and basic rate is equal or less than 2Mbps  */
end_comment

begin_function
name|void
name|ar5212SetBasicRate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_RATE_SET
modifier|*
name|rs
parameter_list|)
block|{
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|uint8_t
name|xset
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|chan
operator|==
name|AH_NULL
operator|||
operator|!
name|IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
return|return;
name|xset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_count
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|rset
init|=
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
decl_stmt|;
comment|/* Basic rate defined? */
if|if
condition|(
operator|(
name|rset
operator|&
literal|0x80
operator|)
operator|&&
operator|(
name|rset
operator|&=
literal|0x7f
operator|)
operator|>=
name|xset
condition|)
name|xset
operator|=
name|rset
expr_stmt|;
block|}
comment|/* 	 * Set the h/w bit to reflect whether or not the basic 	 * rate is found to be equal or less than 2Mbps. 	 */
name|reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xset
operator|&&
name|xset
operator|/
literal|2
operator|<=
literal|2
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|reg
operator||
name|AR_STA_ID1_BASE_RATE_11B
argument_list|)
expr_stmt|;
else|else
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|reg
operator|&
operator|~
name|AR_STA_ID1_BASE_RATE_11B
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grab a semi-random value from hardware registers - may not  * change often  */
end_comment

begin_function
name|uint32_t
name|ar5212GetRandomSeed
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint32_t
name|nf
decl_stmt|;
name|nf
operator|=
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|25
argument_list|)
argument_list|)
operator|>>
literal|19
operator|)
operator|&
literal|0x1ff
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_U32
argument_list|)
operator|^
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
operator|^
name|nf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detect if our card is present  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212DetectCardPresent
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint16_t
name|macVersion
decl_stmt|,
name|macRev
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
comment|/* 	 * Read the Silicon Revision register and compare that 	 * to what we read at attach time.  If the same, we say 	 * a card/device is present. 	 */
name|v
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_SREV
argument_list|)
operator|&
name|AR_SREV_ID
expr_stmt|;
name|macVersion
operator|=
name|v
operator|>>
name|AR_SREV_ID_S
expr_stmt|;
name|macRev
operator|=
name|v
operator|&
name|AR_SREV_REVISION
expr_stmt|;
return|return
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
operator|==
name|macVersion
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
operator|==
name|macRev
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ar5212EnableMibCounters
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
comment|/* NB: this just resets the mib counter machinery */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MIBC
argument_list|,
operator|~
operator|(
name|AR_MIBC_COW
operator||
name|AR_MIBC_FMC
operator||
name|AR_MIBC_CMC
operator||
name|AR_MIBC_MCS
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar5212DisableMibCounters
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MIBC
argument_list|,
name|AR_MIBC
operator||
name|AR_MIBC_CMC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update MIB Counters  */
end_comment

begin_function
name|void
name|ar5212UpdateMibCounters
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_MIB_STATS
modifier|*
name|stats
parameter_list|)
block|{
name|stats
operator|->
name|ackrcv_bad
operator|+=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ACK_FAIL
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rts_bad
operator|+=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RTS_FAIL
argument_list|)
expr_stmt|;
name|stats
operator|->
name|fcs_bad
operator|+=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_FCS_FAIL
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rts_good
operator|+=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RTS_OK
argument_list|)
expr_stmt|;
name|stats
operator|->
name|beacons
operator|+=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_BEACON_CNT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Detect if the HW supports spreading a CCK signal on channel 14  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212IsJapanChannelSpreadSupported
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Get the rssi of frame curently being received.  */
end_comment

begin_function
name|uint32_t
name|ar5212GetCurRssi
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CURRENT_RSSI
argument_list|)
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_function
name|u_int
name|ar5212GetDefAntenna
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DEF_ANTENNA
argument_list|)
operator|&
literal|0x7
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ar5212SetDefAntenna
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|antenna
parameter_list|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DEF_ANTENNA
argument_list|,
operator|(
name|antenna
operator|&
literal|0x7
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|HAL_ANT_SETTING
name|ar5212GetAntennaSwitch
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|AH5212
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_antControl
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212SetAntennaSwitch
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_ANT_SETTING
name|setting
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
if|if
condition|(
operator|!
name|ahp
operator|->
name|ah_phyPowerOn
operator|||
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
comment|/* PHY powered off, just stash settings */
name|ahp
operator|->
name|ah_antControl
operator|=
name|setting
expr_stmt|;
name|ahp
operator|->
name|ah_diversity
operator|=
operator|(
name|setting
operator|==
name|HAL_ANT_VARIABLE
operator|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
return|return
name|ar5212SetAntennaSwitchInternal
argument_list|(
name|ah
argument_list|,
name|setting
argument_list|,
name|ichan
argument_list|)
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212IsSleepAfterBeaconBroken
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212SetSifsTime
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|us
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|us
operator|>
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
literal|0xffff
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: bad SIFS time %u\n"
argument_list|,
name|__func__
argument_list|,
name|us
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_sifstime
operator|=
operator|(
name|u_int
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* restore default handling */
return|return
name|AH_FALSE
return|;
block|}
else|else
block|{
comment|/* convert to system clocks */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_SIFS
argument_list|,
name|ath_hal_mac_clks
argument_list|(
name|ah
argument_list|,
name|us
argument_list|)
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_slottime
operator|=
name|us
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
block|}
end_function

begin_function
name|u_int
name|ar5212GetSifsTime
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int
name|clks
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_SIFS
argument_list|)
operator|&
literal|0xffff
decl_stmt|;
return|return
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
name|clks
argument_list|)
return|;
comment|/* convert from system clocks */
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212SetSlotTime
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|us
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|us
operator|<
name|HAL_SLOT_TIME_6
operator|||
name|us
operator|>
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
literal|0xffff
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: bad slot time %u\n"
argument_list|,
name|__func__
argument_list|,
name|us
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_slottime
operator|=
operator|(
name|u_int
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* restore default handling */
return|return
name|AH_FALSE
return|;
block|}
else|else
block|{
comment|/* convert to system clocks */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_SLOT
argument_list|,
name|ath_hal_mac_clks
argument_list|(
name|ah
argument_list|,
name|us
argument_list|)
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_slottime
operator|=
name|us
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
block|}
end_function

begin_function
name|u_int
name|ar5212GetSlotTime
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int
name|clks
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_SLOT
argument_list|)
operator|&
literal|0xffff
decl_stmt|;
return|return
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
name|clks
argument_list|)
return|;
comment|/* convert from system clocks */
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212SetAckTimeout
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|us
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|us
operator|>
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
name|MS
argument_list|(
literal|0xffffffff
argument_list|,
name|AR_TIME_OUT_ACK
argument_list|)
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: bad ack timeout %u\n"
argument_list|,
name|__func__
argument_list|,
name|us
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_acktimeout
operator|=
operator|(
name|u_int
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* restore default handling */
return|return
name|AH_FALSE
return|;
block|}
else|else
block|{
comment|/* convert to system clocks */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_TIME_OUT
argument_list|,
name|AR_TIME_OUT_ACK
argument_list|,
name|ath_hal_mac_clks
argument_list|(
name|ah
argument_list|,
name|us
argument_list|)
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_acktimeout
operator|=
name|us
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
block|}
end_function

begin_function
name|u_int
name|ar5212GetAckTimeout
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int
name|clks
init|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TIME_OUT
argument_list|)
argument_list|,
name|AR_TIME_OUT_ACK
argument_list|)
decl_stmt|;
return|return
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
name|clks
argument_list|)
return|;
comment|/* convert from system clocks */
block|}
end_function

begin_function
name|u_int
name|ar5212GetAckCTSRate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
operator|(
operator|(
name|AH5212
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_staId1Defaults
operator|&
name|AR_STA_ID1_ACKCTS_6MB
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212SetAckCTSRate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|high
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|high
condition|)
block|{
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|AR_STA_ID1_ACKCTS_6MB
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_staId1Defaults
operator|&=
operator|~
name|AR_STA_ID1_ACKCTS_6MB
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|AR_STA_ID1_ACKCTS_6MB
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_staId1Defaults
operator||=
name|AR_STA_ID1_ACKCTS_6MB
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212SetCTSTimeout
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|us
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|us
operator|>
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
name|MS
argument_list|(
literal|0xffffffff
argument_list|,
name|AR_TIME_OUT_CTS
argument_list|)
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: bad cts timeout %u\n"
argument_list|,
name|__func__
argument_list|,
name|us
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_ctstimeout
operator|=
operator|(
name|u_int
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* restore default handling */
return|return
name|AH_FALSE
return|;
block|}
else|else
block|{
comment|/* convert to system clocks */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_TIME_OUT
argument_list|,
name|AR_TIME_OUT_CTS
argument_list|,
name|ath_hal_mac_clks
argument_list|(
name|ah
argument_list|,
name|us
argument_list|)
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_ctstimeout
operator|=
name|us
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
block|}
end_function

begin_function
name|u_int
name|ar5212GetCTSTimeout
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int
name|clks
init|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TIME_OUT
argument_list|)
argument_list|,
name|AR_TIME_OUT_CTS
argument_list|)
decl_stmt|;
return|return
name|ath_hal_mac_usec
argument_list|(
name|ah
argument_list|,
name|clks
argument_list|)
return|;
comment|/* convert from system clocks */
block|}
end_function

begin_comment
comment|/* Setup decompression for given key index */
end_comment

begin_function
name|HAL_BOOL
name|ar5212SetDecompMask
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint16_t
name|keyidx
parameter_list|,
name|int
name|en
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyidx
operator|>=
name|HAL_DECOMP_MASK_SIZE
condition|)
return|return
name|HAL_EINVAL
return|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DCM_A
argument_list|,
name|keyidx
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DCM_D
argument_list|,
name|en
condition|?
name|AR_DCM_D_EN
else|:
literal|0
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_decompMask
index|[
name|keyidx
index|]
operator|=
name|en
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/* Setup coverage class */
end_comment

begin_function
name|void
name|ar5212SetCoverageClass
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|uint8_t
name|coverageclass
parameter_list|,
name|int
name|now
parameter_list|)
block|{
name|uint32_t
name|slot
decl_stmt|,
name|timeout
decl_stmt|,
name|eifs
decl_stmt|;
name|u_int
name|clkRate
decl_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_coverageClass
operator|=
name|coverageclass
expr_stmt|;
if|if
condition|(
name|now
condition|)
block|{
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_coverageClass
operator|==
literal|0
condition|)
return|return;
comment|/* Don't apply coverage class to non A channels */
if|if
condition|(
operator|!
name|IS_CHAN_A
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|)
condition|)
return|return;
comment|/* Get core clock rate */
name|clkRate
operator|=
name|ath_hal_mac_clks
argument_list|(
name|ah
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute EIFS */
name|slot
operator|=
name|coverageclass
operator|*
literal|3
operator|*
name|clkRate
expr_stmt|;
name|eifs
operator|=
name|coverageclass
operator|*
literal|6
operator|*
name|clkRate
expr_stmt|;
if|if
condition|(
name|IS_CHAN_HALF_RATE
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|)
condition|)
block|{
name|slot
operator|+=
name|IFS_SLOT_HALF_RATE
expr_stmt|;
name|eifs
operator|+=
name|IFS_EIFS_HALF_RATE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_CHAN_QUARTER_RATE
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|)
condition|)
block|{
name|slot
operator|+=
name|IFS_SLOT_QUARTER_RATE
expr_stmt|;
name|eifs
operator|+=
name|IFS_EIFS_QUARTER_RATE
expr_stmt|;
block|}
else|else
block|{
comment|/* full rate */
name|slot
operator|+=
name|IFS_SLOT_FULL_RATE
expr_stmt|;
name|eifs
operator|+=
name|IFS_EIFS_FULL_RATE
expr_stmt|;
block|}
comment|/* 		 * Add additional time for air propagation for ACK and CTS 		 * timeouts. This value is in core clocks.   		 */
name|timeout
operator|=
name|ACK_CTS_TIMEOUT_11A
operator|+
operator|(
name|coverageclass
operator|*
literal|3
operator|*
name|clkRate
operator|)
expr_stmt|;
comment|/* 		 * Write the values: slot, eifs, ack/cts timeouts. 		 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_SLOT
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_EIFS
argument_list|,
name|eifs
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TIME_OUT
argument_list|,
name|SM
argument_list|(
name|timeout
argument_list|,
name|AR_TIME_OUT_CTS
argument_list|)
operator||
name|SM
argument_list|(
name|timeout
argument_list|,
name|AR_TIME_OUT_ACK
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ar5212SetPCUConfig
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|ar5212SetOperatingMode
argument_list|(
name|ah
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return whether an external 32KHz crystal should be used  * to reduce power consumption when sleeping.  We do so if  * the crystal is present (obtained from EEPROM) and if we  * are not running as an AP and are configured to use it.  */
end_comment

begin_function
name|HAL_BOOL
name|ar5212Use32KHzclock
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_OPMODE
name|opmode
parameter_list|)
block|{
if|if
condition|(
name|opmode
operator|!=
name|HAL_M_HOSTAP
condition|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
return|return
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_32KHZCRYSTAL
argument_list|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_enable32kHzClock
operator|==
name|USE_32KHZ
operator|||
name|ahp
operator|->
name|ah_enable32kHzClock
operator|==
name|AUTO_32KHZ
operator|)
return|;
block|}
else|else
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * If 32KHz clock exists, use it to lower power consumption during sleep  *  * Note: If clock is set to 32 KHz, delays on accessing certain  *       baseband registers (27-31, 124-127) are required.  */
end_comment

begin_function
name|void
name|ar5212SetupClock
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_OPMODE
name|opmode
parameter_list|)
block|{
if|if
condition|(
name|ar5212Use32KHzclock
argument_list|(
name|ah
argument_list|,
name|opmode
argument_list|)
condition|)
block|{
comment|/* 		 * Enable clocks to be turned OFF in BB during sleep 		 * and also enable turning OFF 32MHz/40MHz Refclk 		 * from A2. 		 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_CTR_CONTROL
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_REFCLKPD
argument_list|,
name|IS_RAD5112_ANY
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_5413
argument_list|(
name|ah
argument_list|)
condition|?
literal|0x14
else|:
literal|0x18
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_USEC
argument_list|,
name|AR_USEC_USEC32
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TSF_PARM
argument_list|,
literal|61
argument_list|)
expr_stmt|;
comment|/* 32 KHz TSF incr */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|AR_PCICFG_SCLK_SEL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_2413
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_5413
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_2417
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_CTR_LIMIT
argument_list|,
literal|0x26
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_SCAL
argument_list|,
literal|0x0d
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_M_SLEEP
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_REFCLKDLY
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
comment|/* # Set sleep clock rate to 32 KHz. */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|AR_PCICFG_SCLK_RATE_IND
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_CTR_LIMIT
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_SCAL
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_M_SLEEP
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_REFCLKDLY
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|AR_PCICFG_SCLK_RATE_IND
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|AR_PCICFG_SCLK_RATE_IND
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|AR_PCICFG_SCLK_SEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TSF_PARM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 32MHz TSF inc */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_CTR_CONTROL
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_CTR_LIMIT
argument_list|,
literal|0x7f
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_2417
argument_list|(
name|ah
argument_list|)
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_SCAL
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_HB63
argument_list|(
name|ah
argument_list|)
condition|)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_SCAL
argument_list|,
literal|0x32
argument_list|)
expr_stmt|;
else|else
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_SCAL
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_M_SLEEP
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_REFCLKDLY
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_REFCLKPD
argument_list|,
name|IS_RAD5112_ANY
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_5413
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_2417
argument_list|(
name|ah
argument_list|)
condition|?
literal|0x14
else|:
literal|0x18
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_USEC
argument_list|,
name|AR_USEC_USEC32
argument_list|,
name|IS_RAD5112_ANY
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_5413
argument_list|(
name|ah
argument_list|)
condition|?
literal|39
else|:
literal|31
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If 32KHz clock exists, turn it off and turn back on the 32Mhz  */
end_comment

begin_function
name|void
name|ar5212RestoreClock
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_OPMODE
name|opmode
parameter_list|)
block|{
if|if
condition|(
name|ar5212Use32KHzclock
argument_list|(
name|ah
argument_list|,
name|opmode
argument_list|)
condition|)
block|{
comment|/* # Set sleep clock rate back to 32 MHz. */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|AR_PCICFG_SCLK_RATE_IND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PCICFG
argument_list|,
name|AR_PCICFG_SCLK_SEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TSF_PARM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 32 MHz TSF incr */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_USEC
argument_list|,
name|AR_USEC_USEC32
argument_list|,
name|IS_RAD5112_ANY
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_5413
argument_list|(
name|ah
argument_list|)
condition|?
literal|39
else|:
literal|31
argument_list|)
expr_stmt|;
comment|/* 		 * Restore BB registers to power-on defaults 		 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_CTR_CONTROL
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_CTR_LIMIT
argument_list|,
literal|0x7f
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SLEEP_SCAL
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_M_SLEEP
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_REFCLKDLY
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_REFCLKPD
argument_list|,
name|IS_RAD5112_ANY
argument_list|(
name|ah
argument_list|)
operator|||
name|IS_5413
argument_list|(
name|ah
argument_list|)
condition|?
literal|0x14
else|:
literal|0x18
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Adjust NF based on statistical values for 5GHz frequencies.  * Default method: this may be overridden by the rf backend.  */
end_comment

begin_function
name|int16_t
name|ar5212GetNfAdjust
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_CHANNEL_INTERNAL
modifier|*
name|c
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
name|uint16_t
name|freqLow
decl_stmt|;
name|int16_t
name|adjust
decl_stmt|;
block|}
name|adjustDef
index|[]
init|=
block|{
block|{
literal|5790
block|,
literal|11
block|}
block|,
comment|/* NB: ordered high -> low */
block|{
literal|5730
block|,
literal|10
block|}
block|,
block|{
literal|5690
block|,
literal|9
block|}
block|,
block|{
literal|5660
block|,
literal|8
block|}
block|,
block|{
literal|5610
block|,
literal|7
block|}
block|,
block|{
literal|5530
block|,
literal|5
block|}
block|,
block|{
literal|5450
block|,
literal|4
block|}
block|,
block|{
literal|5379
block|,
literal|2
block|}
block|,
block|{
literal|5209
block|,
literal|0
block|}
block|,
block|{
literal|3000
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, 	}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|c
operator|->
name|channel
operator|<=
name|adjustDef
index|[
name|i
index|]
operator|.
name|freqLow
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
name|adjustDef
index|[
name|i
index|]
operator|.
name|adjust
return|;
block|}
end_function

begin_function
name|HAL_STATUS
name|ar5212GetCapability
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CAPABILITY_TYPE
name|type
parameter_list|,
name|uint32_t
name|capability
parameter_list|,
name|uint32_t
modifier|*
name|result
parameter_list|)
block|{
define|#
directive|define
name|MACVERSION
parameter_list|(
name|ah
parameter_list|)
value|AH_PRIVATE(ah)->ah_macVersion
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|HAL_CAPABILITIES
modifier|*
name|pCap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
specifier|const
name|struct
name|ar5212AniState
modifier|*
name|ani
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HAL_CAP_CIPHER
case|:
comment|/* cipher handled in hardware */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
name|HAL_CIPHER_AES_CCM
case|:
return|return
name|pCap
operator|->
name|halCipherAesCcmSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CIPHER_AES_OCB
case|:
case|case
name|HAL_CIPHER_TKIP
case|:
case|case
name|HAL_CIPHER_WEP
case|:
case|case
name|HAL_CIPHER_MIC
case|:
case|case
name|HAL_CIPHER_CLR
case|:
return|return
name|HAL_OK
return|;
default|default:
return|return
name|HAL_ENOTSUPP
return|;
block|}
case|case
name|HAL_CAP_TKIP_MIC
case|:
comment|/* handle TKIP MIC in hardware */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|0
case|:
comment|/* hardware capability */
return|return
name|HAL_OK
return|;
case|case
literal|1
case|:
return|return
operator|(
name|ahp
operator|->
name|ah_staId1Defaults
operator|&
name|AR_STA_ID1_CRPT_MIC_ENABLE
operator|)
condition|?
name|HAL_OK
else|:
name|HAL_ENXIO
return|;
block|}
case|case
name|HAL_CAP_TKIP_SPLIT
case|:
comment|/* hardware TKIP uses split keys */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|0
case|:
comment|/* hardware capability */
return|return
name|pCap
operator|->
name|halTkipMicTxRxKeySupport
condition|?
name|HAL_ENXIO
else|:
name|HAL_OK
return|;
case|case
literal|1
case|:
comment|/* current setting */
return|return
operator|(
name|ahp
operator|->
name|ah_miscMode
operator|&
name|AR_MISC_MODE_MIC_NEW_LOC_ENABLE
operator|)
condition|?
name|HAL_ENXIO
else|:
name|HAL_OK
return|;
block|}
return|return
name|HAL_EINVAL
return|;
case|case
name|HAL_CAP_WME_TKIPMIC
case|:
comment|/* hardware can do TKIP MIC w/ WMM */
comment|/* XXX move to capability bit */
return|return
name|MACVERSION
argument_list|(
name|ah
argument_list|)
operator|>
name|AR_SREV_VERSION_VENICE
operator|||
operator|(
name|MACVERSION
argument_list|(
name|ah
argument_list|)
operator|==
name|AR_SREV_VERSION_VENICE
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
operator|>=
literal|8
operator|)
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
name|HAL_CAP_DIVERSITY
case|:
comment|/* hardware supports fast diversity */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|0
case|:
comment|/* hardware capability */
return|return
name|HAL_OK
return|;
case|case
literal|1
case|:
comment|/* current setting */
return|return
name|ahp
operator|->
name|ah_diversity
condition|?
name|HAL_OK
else|:
name|HAL_ENXIO
return|;
block|}
return|return
name|HAL_EINVAL
return|;
case|case
name|HAL_CAP_DIAG
case|:
operator|*
name|result
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_TPC
case|:
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|0
case|:
comment|/* hardware capability */
return|return
name|HAL_OK
return|;
case|case
literal|1
case|:
return|return
name|ahp
operator|->
name|ah_tpcEnabled
condition|?
name|HAL_OK
else|:
name|HAL_ENXIO
return|;
block|}
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_PHYDIAG
case|:
comment|/* radar pulse detection capability */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
name|HAL_CAP_RADAR
case|:
return|return
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_AMODE
argument_list|)
condition|?
name|HAL_OK
else|:
name|HAL_ENXIO
return|;
case|case
name|HAL_CAP_AR
case|:
return|return
operator|(
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_GMODE
argument_list|)
operator|||
name|ath_hal_eepromGetFlag
argument_list|(
name|ah
argument_list|,
name|AR_EEP_BMODE
argument_list|)
operator|)
condition|?
name|HAL_OK
else|:
name|HAL_ENXIO
return|;
block|}
return|return
name|HAL_ENXIO
return|;
case|case
name|HAL_CAP_MCAST_KEYSRCH
case|:
comment|/* multicast frame keycache search */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|0
case|:
comment|/* hardware capability */
return|return
name|HAL_OK
return|;
case|case
literal|1
case|:
return|return
operator|(
name|ahp
operator|->
name|ah_staId1Defaults
operator|&
name|AR_STA_ID1_MCAST_KSRCH
operator|)
condition|?
name|HAL_OK
else|:
name|HAL_ENXIO
return|;
block|}
return|return
name|HAL_EINVAL
return|;
case|case
name|HAL_CAP_TSF_ADJUST
case|:
comment|/* hardware has beacon tsf adjust */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|0
case|:
comment|/* hardware capability */
return|return
name|pCap
operator|->
name|halTsfAddSupport
condition|?
name|HAL_OK
else|:
name|HAL_ENOTSUPP
return|;
case|case
literal|1
case|:
return|return
operator|(
name|ahp
operator|->
name|ah_miscMode
operator|&
name|AR_MISC_MODE_TX_ADD_TSF
operator|)
condition|?
name|HAL_OK
else|:
name|HAL_ENXIO
return|;
block|}
return|return
name|HAL_EINVAL
return|;
case|case
name|HAL_CAP_TPC_ACK
case|:
operator|*
name|result
operator|=
name|MS
argument_list|(
name|ahp
operator|->
name|ah_macTPC
argument_list|,
name|AR_TPC_ACK
argument_list|)
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_TPC_CTS
case|:
operator|*
name|result
operator|=
name|MS
argument_list|(
name|ahp
operator|->
name|ah_macTPC
argument_list|,
name|AR_TPC_CTS
argument_list|)
expr_stmt|;
return|return
name|HAL_OK
return|;
case|case
name|HAL_CAP_INTMIT
case|:
comment|/* interference mitigation */
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|0
case|:
comment|/* hardware capability */
return|return
name|HAL_OK
return|;
case|case
literal|1
case|:
return|return
operator|(
name|ahp
operator|->
name|ah_procPhyErr
operator|&
name|HAL_ANI_ENA
operator|)
condition|?
name|HAL_OK
else|:
name|HAL_ENXIO
return|;
case|case
literal|2
case|:
comment|/* HAL_ANI_NOISE_IMMUNITY_LEVEL */
case|case
literal|3
case|:
comment|/* HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION */
case|case
literal|4
case|:
comment|/* HAL_ANI_CCK_WEAK_SIGNAL_THR */
case|case
literal|5
case|:
comment|/* HAL_ANI_FIRSTEP_LEVEL */
case|case
literal|6
case|:
comment|/* HAL_ANI_SPUR_IMMUNITY_LEVEL */
name|ani
operator|=
name|ar5212AniGetCurrentState
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|ani
operator|==
name|AH_NULL
condition|)
return|return
name|HAL_ENXIO
return|;
switch|switch
condition|(
name|capability
condition|)
block|{
case|case
literal|2
case|:
operator|*
name|result
operator|=
name|ani
operator|->
name|noiseImmunityLevel
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|*
name|result
operator|=
operator|!
name|ani
operator|->
name|ofdmWeakSigDetectOff
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
name|result
operator|=
name|ani
operator|->
name|cckWeakSigThreshold
expr_stmt|;
break|break;
case|case
literal|5
case|:
operator|*
name|result
operator|=
name|ani
operator|->
name|firstepLevel
expr_stmt|;
break|break;
case|case
literal|6
case|:
operator|*
name|result
operator|=
name|ani
operator|->
name|spurImmunityLevel
expr_stmt|;
break|break;
block|}
return|return
name|HAL_OK
return|;
block|}
return|return
name|HAL_EINVAL
return|;
default|default:
return|return
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|type
argument_list|,
name|capability
argument_list|,
name|result
argument_list|)
return|;
block|}
undef|#
directive|undef
name|MACVERSION
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212SetCapability
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CAPABILITY_TYPE
name|type
parameter_list|,
name|uint32_t
name|capability
parameter_list|,
name|uint32_t
name|setting
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|HAL_CAPABILITIES
modifier|*
name|pCap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HAL_CAP_TKIP_MIC
case|:
comment|/* handle TKIP MIC in hardware */
if|if
condition|(
name|setting
condition|)
name|ahp
operator|->
name|ah_staId1Defaults
operator||=
name|AR_STA_ID1_CRPT_MIC_ENABLE
expr_stmt|;
else|else
name|ahp
operator|->
name|ah_staId1Defaults
operator|&=
operator|~
name|AR_STA_ID1_CRPT_MIC_ENABLE
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_CAP_TKIP_SPLIT
case|:
comment|/* hardware TKIP uses split keys */
if|if
condition|(
operator|!
name|pCap
operator|->
name|halTkipMicTxRxKeySupport
condition|)
return|return
name|AH_FALSE
return|;
comment|/* NB: true =>'s use split key cache layout */
if|if
condition|(
name|setting
condition|)
name|ahp
operator|->
name|ah_miscMode
operator|&=
operator|~
name|AR_MISC_MODE_MIC_NEW_LOC_ENABLE
expr_stmt|;
else|else
name|ahp
operator|->
name|ah_miscMode
operator||=
name|AR_MISC_MODE_MIC_NEW_LOC_ENABLE
expr_stmt|;
comment|/* NB: write here so keys can be setup w/o a reset */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MISC_MODE
argument_list|,
name|ahp
operator|->
name|ah_miscMode
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_CAP_DIVERSITY
case|:
if|if
condition|(
name|ahp
operator|->
name|ah_phyPowerOn
condition|)
block|{
name|v
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_DETECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|setting
condition|)
name|v
operator||=
name|AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV
expr_stmt|;
else|else
name|v
operator|&=
operator|~
name|AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_DETECT
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_diversity
operator|=
operator|(
name|setting
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_CAP_DIAG
case|:
comment|/* hardware diagnostic support */
comment|/* 		 * NB: could split this up into virtual capabilities, 		 *     (e.g. 1 => ACK, 2 => CTS, etc.) but it hardly 		 *     seems worth the additional complexity. 		 */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
operator|=
name|setting
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_CAP_TPC
case|:
name|ahp
operator|->
name|ah_tpcEnabled
operator|=
operator|(
name|setting
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_CAP_MCAST_KEYSRCH
case|:
comment|/* multicast frame keycache search */
if|if
condition|(
name|setting
condition|)
name|ahp
operator|->
name|ah_staId1Defaults
operator||=
name|AR_STA_ID1_MCAST_KSRCH
expr_stmt|;
else|else
name|ahp
operator|->
name|ah_staId1Defaults
operator|&=
operator|~
name|AR_STA_ID1_MCAST_KSRCH
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_CAP_TPC_ACK
case|:
case|case
name|HAL_CAP_TPC_CTS
case|:
name|setting
operator|+=
name|ahp
operator|->
name|ah_txPowerIndexOffset
expr_stmt|;
if|if
condition|(
name|setting
operator|>
literal|63
condition|)
name|setting
operator|=
literal|63
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|HAL_CAP_TPC_ACK
condition|)
block|{
name|ahp
operator|->
name|ah_macTPC
operator|&=
name|AR_TPC_ACK
expr_stmt|;
name|ahp
operator|->
name|ah_macTPC
operator||=
name|MS
argument_list|(
name|setting
argument_list|,
name|AR_TPC_ACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_macTPC
operator|&=
name|AR_TPC_CTS
expr_stmt|;
name|ahp
operator|->
name|ah_macTPC
operator||=
name|MS
argument_list|(
name|setting
argument_list|,
name|AR_TPC_CTS
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TPC
argument_list|,
name|ahp
operator|->
name|ah_macTPC
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_CAP_INTMIT
case|:
block|{
comment|/* interference mitigation */
specifier|static
specifier|const
name|HAL_ANI_CMD
name|cmds
index|[]
init|=
block|{
name|HAL_ANI_PRESENT
block|,
name|HAL_ANI_MODE
block|,
name|HAL_ANI_NOISE_IMMUNITY_LEVEL
block|,
name|HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION
block|,
name|HAL_ANI_CCK_WEAK_SIGNAL_THR
block|,
name|HAL_ANI_FIRSTEP_LEVEL
block|,
name|HAL_ANI_SPUR_IMMUNITY_LEVEL
block|, 		}
decl_stmt|;
return|return
name|capability
operator|<
name|N
argument_list|(
name|cmds
argument_list|)
condition|?
name|ar5212AniControl
argument_list|(
name|ah
argument_list|,
name|cmds
index|[
name|capability
index|]
argument_list|,
name|setting
argument_list|)
else|:
name|AH_FALSE
return|;
block|}
case|case
name|HAL_CAP_TSF_ADJUST
case|:
comment|/* hardware has beacon tsf adjust */
if|if
condition|(
name|pCap
operator|->
name|halTsfAddSupport
condition|)
block|{
if|if
condition|(
name|setting
condition|)
name|ahp
operator|->
name|ah_miscMode
operator||=
name|AR_MISC_MODE_TX_ADD_TSF
expr_stmt|;
else|else
name|ahp
operator|->
name|ah_miscMode
operator|&=
operator|~
name|AR_MISC_MODE_TX_ADD_TSF
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
comment|/* fall thru... */
default|default:
return|return
name|ath_hal_setcapability
argument_list|(
name|ah
argument_list|,
name|type
argument_list|,
name|capability
argument_list|,
name|setting
argument_list|,
name|status
argument_list|)
return|;
block|}
undef|#
directive|undef
name|N
block|}
end_function

begin_function
name|HAL_BOOL
name|ar5212GetDiagState
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|request
parameter_list|,
specifier|const
name|void
modifier|*
name|args
parameter_list|,
name|uint32_t
name|argsize
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|,
name|uint32_t
modifier|*
name|resultsize
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|ahp
expr_stmt|;
if|if
condition|(
name|ath_hal_getdiagstate
argument_list|(
name|ah
argument_list|,
name|request
argument_list|,
name|args
argument_list|,
name|argsize
argument_list|,
name|result
argument_list|,
name|resultsize
argument_list|)
condition|)
return|return
name|AH_TRUE
return|;
switch|switch
condition|(
name|request
condition|)
block|{
case|case
name|HAL_DIAG_EEPROM
case|:
case|case
name|HAL_DIAG_EEPROM_EXP_11A
case|:
case|case
name|HAL_DIAG_EEPROM_EXP_11B
case|:
case|case
name|HAL_DIAG_EEPROM_EXP_11G
case|:
case|case
name|HAL_DIAG_RFGAIN
case|:
return|return
name|ath_hal_eepromDiag
argument_list|(
name|ah
argument_list|,
name|request
argument_list|,
name|args
argument_list|,
name|argsize
argument_list|,
name|result
argument_list|,
name|resultsize
argument_list|)
return|;
case|case
name|HAL_DIAG_RFGAIN_CURSTEP
case|:
operator|*
name|result
operator|=
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|ahp
operator|->
name|ah_gainValues
operator|.
name|currStep
argument_list|)
expr_stmt|;
operator|*
name|resultsize
operator|=
operator|(
operator|*
name|result
operator|==
name|AH_NULL
operator|)
condition|?
literal|0
else|:
sizeof|sizeof
argument_list|(
name|GAIN_OPTIMIZATION_STEP
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_PCDAC
case|:
operator|*
name|result
operator|=
name|ahp
operator|->
name|ah_pcdacTable
expr_stmt|;
operator|*
name|resultsize
operator|=
name|ahp
operator|->
name|ah_pcdacTableSize
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_TXRATES
case|:
operator|*
name|result
operator|=
operator|&
name|ahp
operator|->
name|ah_ratesArray
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|resultsize
operator|=
sizeof|sizeof
argument_list|(
name|ahp
operator|->
name|ah_ratesArray
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_ANI_CURRENT
case|:
operator|*
name|result
operator|=
name|ar5212AniGetCurrentState
argument_list|(
name|ah
argument_list|)
expr_stmt|;
operator|*
name|resultsize
operator|=
operator|(
operator|*
name|result
operator|==
name|AH_NULL
operator|)
condition|?
literal|0
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|ar5212AniState
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_ANI_STATS
case|:
operator|*
name|result
operator|=
name|ar5212AniGetCurrentStats
argument_list|(
name|ah
argument_list|)
expr_stmt|;
operator|*
name|resultsize
operator|=
operator|(
operator|*
name|result
operator|==
name|AH_NULL
operator|)
condition|?
literal|0
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|ar5212Stats
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_ANI_CMD
case|:
if|if
condition|(
name|argsize
operator|!=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
name|ar5212AniControl
argument_list|(
name|ah
argument_list|,
operator|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|args
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|args
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
case|case
name|HAL_DIAG_ANI_PARAMS
case|:
comment|/* 		 * NB: We assume struct ar5212AniParams is identical 		 * to HAL_ANI_PARAMS; if they diverge then we'll need 		 * to handle it here 		 */
if|if
condition|(
name|argsize
operator|==
literal|0
operator|&&
name|args
operator|==
name|AH_NULL
condition|)
block|{
name|struct
name|ar5212AniState
modifier|*
name|aniState
init|=
name|ar5212AniGetCurrentState
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|aniState
operator|==
name|AH_NULL
condition|)
return|return
name|AH_FALSE
return|;
operator|*
name|result
operator|=
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|aniState
operator|->
name|params
argument_list|)
expr_stmt|;
operator|*
name|resultsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ar5212AniParams
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
else|else
block|{
if|if
condition|(
name|argsize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ar5212AniParams
argument_list|)
condition|)
return|return
name|AH_FALSE
return|;
return|return
name|ar5212AniSetParams
argument_list|(
name|ah
argument_list|,
name|args
argument_list|,
name|args
argument_list|)
return|;
block|}
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AH_SUPPORT_AR5212 */
end_comment

end_unit

