begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2008 Sam Leffler, Errno Consulting  * Copyright (c) 2002-2008 Atheros Communications, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * $Id: ar5111.c,v 1.7 2008/11/10 04:08:03 sam Exp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AH_SUPPORT_5111
end_ifdef

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_eeprom_v3.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212phy.h"
end_include

begin_define
define|#
directive|define
name|AH_5212_5111
end_define

begin_include
include|#
directive|include
file|"ar5212/ar5212.ini"
end_include

begin_define
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
end_define

begin_struct
struct|struct
name|ar5111State
block|{
name|RF_HAL_FUNCS
name|base
decl_stmt|;
comment|/* public state, must be first */
name|uint16_t
name|pcdacTable
index|[
name|PWR_TABLE_SIZE
index|]
decl_stmt|;
name|uint32_t
name|Bank0Data
index|[
name|N
argument_list|(
name|ar5212Bank0_5111
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|Bank1Data
index|[
name|N
argument_list|(
name|ar5212Bank1_5111
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|Bank2Data
index|[
name|N
argument_list|(
name|ar5212Bank2_5111
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|Bank3Data
index|[
name|N
argument_list|(
name|ar5212Bank3_5111
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|Bank6Data
index|[
name|N
argument_list|(
name|ar5212Bank6_5111
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|Bank7Data
index|[
name|N
argument_list|(
name|ar5212Bank7_5111
argument_list|)
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AR5111
parameter_list|(
name|ah
parameter_list|)
value|((struct ar5111State *) AH5212(ah)->ah_rfHal)
end_define

begin_function_decl
specifier|static
name|uint16_t
name|ar5212GetScaledPower
parameter_list|(
name|uint16_t
name|channel
parameter_list|,
name|uint16_t
name|pcdacValue
parameter_list|,
specifier|const
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar5212FindValueInList
parameter_list|(
name|uint16_t
name|channel
parameter_list|,
name|uint16_t
name|pcdacValue
parameter_list|,
specifier|const
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
parameter_list|,
name|uint16_t
modifier|*
name|powerValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar5212GetLowerUpperPcdacs
parameter_list|(
name|uint16_t
name|pcdac
parameter_list|,
name|uint16_t
name|channel
parameter_list|,
specifier|const
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
parameter_list|,
name|uint16_t
modifier|*
name|pLowerPcdac
parameter_list|,
name|uint16_t
modifier|*
name|pUpperPcdac
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|ar5212GetLowerUpperValues
parameter_list|(
name|uint16_t
name|value
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|pList
parameter_list|,
name|uint16_t
name|listSize
parameter_list|,
name|uint16_t
modifier|*
name|pLowerValue
parameter_list|,
name|uint16_t
modifier|*
name|pUpperValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|ar5212ModifyRfBuffer
parameter_list|(
name|uint32_t
modifier|*
name|rfBuf
parameter_list|,
name|uint32_t
name|reg32
parameter_list|,
name|uint32_t
name|numBits
parameter_list|,
name|uint32_t
name|firstBit
parameter_list|,
name|uint32_t
name|column
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ar5111WriteRegs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|modesIndex
parameter_list|,
name|u_int
name|freqIndex
parameter_list|,
name|int
name|writes
parameter_list|)
block|{
name|HAL_INI_WRITE_ARRAY
argument_list|(
name|ah
argument_list|,
name|ar5212Modes_5111
argument_list|,
name|modesIndex
argument_list|,
name|writes
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_ARRAY
argument_list|(
name|ah
argument_list|,
name|ar5212Common_5111
argument_list|,
literal|1
argument_list|,
name|writes
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_ARRAY
argument_list|(
name|ah
argument_list|,
name|ar5212BB_RfGain_5111
argument_list|,
name|freqIndex
argument_list|,
name|writes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take the MHz channel value and set the Channel value  *  * ASSUMES: Writes enabled to analog bus  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5111SetChannel
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|)
block|{
define|#
directive|define
name|CI_2GHZ_INDEX_CORRECTION
value|19
name|uint32_t
name|refClk
decl_stmt|,
name|reg32
decl_stmt|,
name|data2111
decl_stmt|;
name|int16_t
name|chan5111
decl_stmt|,
name|chanIEEE
decl_stmt|;
comment|/* 	 * Structure to hold 11b tuning information for 5111/2111 	 * 16 MHz mode, divider ratio = 198 = NP+S. N=16, S=4 or 6, P=12 	 */
typedef|typedef
struct|struct
block|{
name|uint32_t
name|refClkSel
decl_stmt|;
comment|/* reference clock, 1 for 16 MHz */
name|uint32_t
name|channelSelect
decl_stmt|;
comment|/* P[7:4]S[3:0] bits */
name|uint16_t
name|channel5111
decl_stmt|;
comment|/* 11a channel for 5111 */
block|}
name|CHAN_INFO_2GHZ
typedef|;
specifier|const
specifier|static
name|CHAN_INFO_2GHZ
name|chan2GHzData
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|0x46
block|,
literal|96
block|}
block|,
comment|/* 2312 -19 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|97
block|}
block|,
comment|/* 2317 -18 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|98
block|}
block|,
comment|/* 2322 -17 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|99
block|}
block|,
comment|/* 2327 -16 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|100
block|}
block|,
comment|/* 2332 -15 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|101
block|}
block|,
comment|/* 2337 -14 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|102
block|}
block|,
comment|/* 2342 -13 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|103
block|}
block|,
comment|/* 2347 -12 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|104
block|}
block|,
comment|/* 2352 -11 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|105
block|}
block|,
comment|/* 2357 -10 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|106
block|}
block|,
comment|/* 2362  -9 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|107
block|}
block|,
comment|/* 2367  -8 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|108
block|}
block|,
comment|/* 2372  -7 */
comment|/* index -6 to 0 are pad to make this a nolookup table */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/*       -6 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/*       -5 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/*       -4 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/*       -3 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/*       -2 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/*       -1 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/*        0 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|116
block|}
block|,
comment|/* 2412   1 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|117
block|}
block|,
comment|/* 2417   2 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|118
block|}
block|,
comment|/* 2422   3 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|119
block|}
block|,
comment|/* 2427   4 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|120
block|}
block|,
comment|/* 2432   5 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|121
block|}
block|,
comment|/* 2437   6 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|122
block|}
block|,
comment|/* 2442   7 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|123
block|}
block|,
comment|/* 2447   8 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|124
block|}
block|,
comment|/* 2452   9 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|125
block|}
block|,
comment|/* 2457  10 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|126
block|}
block|,
comment|/* 2462  11 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|127
block|}
block|,
comment|/* 2467  12 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|128
block|}
block|,
comment|/* 2472  13 */
block|{
literal|1
block|,
literal|0x44
block|,
literal|124
block|}
block|,
comment|/* 2484  14 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|136
block|}
block|,
comment|/* 2512  15 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|140
block|}
block|,
comment|/* 2532  16 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|144
block|}
block|,
comment|/* 2552  17 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|148
block|}
block|,
comment|/* 2572  18 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|152
block|}
block|,
comment|/* 2592  19 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|156
block|}
block|,
comment|/* 2612  20 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|160
block|}
block|,
comment|/* 2632  21 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|164
block|}
block|,
comment|/* 2652  22 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|168
block|}
block|,
comment|/* 2672  23 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|172
block|}
block|,
comment|/* 2692  24 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|176
block|}
block|,
comment|/* 2712  25 */
block|{
literal|1
block|,
literal|0x46
block|,
literal|180
block|}
comment|/* 2732  26 */
block|}
decl_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_SETCHANNEL
argument_list|,
name|chan
operator|->
name|channel
argument_list|)
expr_stmt|;
name|chanIEEE
operator|=
name|ath_hal_mhz2ieee
argument_list|(
name|ah
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|chan
operator|->
name|channelFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
specifier|const
name|CHAN_INFO_2GHZ
modifier|*
name|ci
init|=
operator|&
name|chan2GHzData
index|[
name|chanIEEE
operator|+
name|CI_2GHZ_INDEX_CORRECTION
index|]
decl_stmt|;
name|uint32_t
name|txctl
decl_stmt|;
name|data2111
operator|=
operator|(
operator|(
name|ath_hal_reverseBits
argument_list|(
name|ci
operator|->
name|channelSelect
argument_list|,
literal|8
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|ci
operator|->
name|refClkSel
operator|<<
literal|4
operator|)
expr_stmt|;
name|chan5111
operator|=
name|ci
operator|->
name|channel5111
expr_stmt|;
name|txctl
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|channel
operator|==
literal|2484
condition|)
block|{
comment|/* Enable channel spreading for channel 14 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|,
name|txctl
operator||
name|AR_PHY_CCK_TX_CTRL_JAPAN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_TX_CTRL
argument_list|,
name|txctl
operator|&
operator|~
name|AR_PHY_CCK_TX_CTRL_JAPAN
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|chan5111
operator|=
name|chanIEEE
expr_stmt|;
comment|/* no conversion needed */
name|data2111
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Rest of the code is common for 5 GHz and 2.4 GHz. */
if|if
condition|(
name|chan5111
operator|>=
literal|145
operator|||
operator|(
name|chan5111
operator|&
literal|0x1
operator|)
condition|)
block|{
name|reg32
operator|=
name|ath_hal_reverseBits
argument_list|(
name|chan5111
operator|-
literal|24
argument_list|,
literal|8
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|refClk
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|reg32
operator|=
name|ath_hal_reverseBits
argument_list|(
operator|(
operator|(
name|chan5111
operator|-
literal|24
operator|)
operator|/
literal|2
operator|)
argument_list|,
literal|8
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|refClk
operator|=
literal|0
expr_stmt|;
block|}
name|reg32
operator|=
operator|(
name|reg32
operator|<<
literal|2
operator|)
operator||
operator|(
name|refClk
operator|<<
literal|1
operator|)
operator||
operator|(
literal|1
operator|<<
literal|10
operator|)
operator||
literal|0x1
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0x27
argument_list|)
argument_list|,
operator|(
operator|(
name|data2111
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|reg32
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|reg32
operator|>>=
literal|8
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY
argument_list|(
literal|0x34
argument_list|)
argument_list|,
operator|(
name|data2111
operator|&
literal|0xff00
operator|)
operator||
operator|(
name|reg32
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|=
name|chan
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|CI_2GHZ_INDEX_CORRECTION
block|}
end_function

begin_comment
comment|/*  * Return a reference to the requested RF Bank.  */
end_comment

begin_function
specifier|static
name|uint32_t
modifier|*
name|ar5111GetRfBank
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|bank
parameter_list|)
block|{
name|struct
name|ar5111State
modifier|*
name|priv
init|=
name|AR5111
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HALASSERT
argument_list|(
name|priv
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bank
condition|)
block|{
case|case
literal|0
case|:
return|return
name|priv
operator|->
name|Bank0Data
return|;
case|case
literal|1
case|:
return|return
name|priv
operator|->
name|Bank1Data
return|;
case|case
literal|2
case|:
return|return
name|priv
operator|->
name|Bank2Data
return|;
case|case
literal|3
case|:
return|return
name|priv
operator|->
name|Bank3Data
return|;
case|case
literal|6
case|:
return|return
name|priv
operator|->
name|Bank6Data
return|;
case|case
literal|7
case|:
return|return
name|priv
operator|->
name|Bank7Data
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: unknown RF Bank %d requested\n"
argument_list|,
name|__func__
argument_list|,
name|bank
argument_list|)
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Reads EEPROM header info from device structure and programs  * all rf registers  *  * REQUIRES: Access to the analog rf device  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5111SetRfRegs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|,
name|uint16_t
name|modesIndex
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|uint16_t
name|rfXpdGainFixed
decl_stmt|,
name|rfPloSel
decl_stmt|,
name|rfPwdXpd
decl_stmt|,
name|gainI
decl_stmt|;
name|uint16_t
name|tempOB
decl_stmt|,
name|tempDB
decl_stmt|;
name|uint32_t
name|ob2GHz
decl_stmt|,
name|db2GHz
decl_stmt|,
name|rfReg
index|[
name|N
argument_list|(
name|ar5212Bank6_5111
argument_list|)
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|regWrites
init|=
literal|0
decl_stmt|;
comment|/* Setup rf parameters */
switch|switch
condition|(
name|chan
operator|->
name|channelFlags
operator|&
name|CHANNEL_ALL
condition|)
block|{
case|case
name|CHANNEL_A
case|:
case|case
name|CHANNEL_T
case|:
if|if
condition|(
literal|4000
operator|<
name|chan
operator|->
name|channel
operator|&&
name|chan
operator|->
name|channel
operator|<
literal|5260
condition|)
block|{
name|tempOB
operator|=
name|ee
operator|->
name|ee_ob1
expr_stmt|;
name|tempDB
operator|=
name|ee
operator|->
name|ee_db1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|5260
operator|<=
name|chan
operator|->
name|channel
operator|&&
name|chan
operator|->
name|channel
operator|<
literal|5500
condition|)
block|{
name|tempOB
operator|=
name|ee
operator|->
name|ee_ob2
expr_stmt|;
name|tempDB
operator|=
name|ee
operator|->
name|ee_db2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|5500
operator|<=
name|chan
operator|->
name|channel
operator|&&
name|chan
operator|->
name|channel
operator|<
literal|5725
condition|)
block|{
name|tempOB
operator|=
name|ee
operator|->
name|ee_ob3
expr_stmt|;
name|tempDB
operator|=
name|ee
operator|->
name|ee_db3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chan
operator|->
name|channel
operator|>=
literal|5725
condition|)
block|{
name|tempOB
operator|=
name|ee
operator|->
name|ee_ob4
expr_stmt|;
name|tempDB
operator|=
name|ee
operator|->
name|ee_db4
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX when does this happen??? */
name|tempOB
operator|=
name|tempDB
operator|=
literal|0
expr_stmt|;
block|}
name|ob2GHz
operator|=
name|db2GHz
operator|=
literal|0
expr_stmt|;
name|rfXpdGainFixed
operator|=
name|ee
operator|->
name|ee_xgain
index|[
name|headerInfo11A
index|]
expr_stmt|;
name|rfPloSel
operator|=
name|ee
operator|->
name|ee_xpd
index|[
name|headerInfo11A
index|]
expr_stmt|;
name|rfPwdXpd
operator|=
operator|!
name|ee
operator|->
name|ee_xpd
index|[
name|headerInfo11A
index|]
expr_stmt|;
name|gainI
operator|=
name|ee
operator|->
name|ee_gainI
index|[
name|headerInfo11A
index|]
expr_stmt|;
break|break;
case|case
name|CHANNEL_B
case|:
name|tempOB
operator|=
name|ee
operator|->
name|ee_obFor24
expr_stmt|;
name|tempDB
operator|=
name|ee
operator|->
name|ee_dbFor24
expr_stmt|;
name|ob2GHz
operator|=
name|ee
operator|->
name|ee_ob2GHz
index|[
literal|0
index|]
expr_stmt|;
name|db2GHz
operator|=
name|ee
operator|->
name|ee_db2GHz
index|[
literal|0
index|]
expr_stmt|;
name|rfXpdGainFixed
operator|=
name|ee
operator|->
name|ee_xgain
index|[
name|headerInfo11B
index|]
expr_stmt|;
name|rfPloSel
operator|=
name|ee
operator|->
name|ee_xpd
index|[
name|headerInfo11B
index|]
expr_stmt|;
name|rfPwdXpd
operator|=
operator|!
name|ee
operator|->
name|ee_xpd
index|[
name|headerInfo11B
index|]
expr_stmt|;
name|gainI
operator|=
name|ee
operator|->
name|ee_gainI
index|[
name|headerInfo11B
index|]
expr_stmt|;
break|break;
case|case
name|CHANNEL_G
case|:
name|tempOB
operator|=
name|ee
operator|->
name|ee_obFor24g
expr_stmt|;
name|tempDB
operator|=
name|ee
operator|->
name|ee_dbFor24g
expr_stmt|;
name|ob2GHz
operator|=
name|ee
operator|->
name|ee_ob2GHz
index|[
literal|1
index|]
expr_stmt|;
name|db2GHz
operator|=
name|ee
operator|->
name|ee_db2GHz
index|[
literal|1
index|]
expr_stmt|;
name|rfXpdGainFixed
operator|=
name|ee
operator|->
name|ee_xgain
index|[
name|headerInfo11G
index|]
expr_stmt|;
name|rfPloSel
operator|=
name|ee
operator|->
name|ee_xpd
index|[
name|headerInfo11G
index|]
expr_stmt|;
name|rfPwdXpd
operator|=
operator|!
name|ee
operator|->
name|ee_xpd
index|[
name|headerInfo11G
index|]
expr_stmt|;
name|gainI
operator|=
name|ee
operator|->
name|ee_gainI
index|[
name|headerInfo11G
index|]
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channelFlags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|HALASSERT
argument_list|(
literal|1
operator|<=
name|tempOB
operator|&&
name|tempOB
operator|<=
literal|5
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
literal|1
operator|<=
name|tempDB
operator|&&
name|tempDB
operator|<=
literal|5
argument_list|)
expr_stmt|;
comment|/* Bank 0 Write */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ar5212Bank0_5111
argument_list|)
condition|;
name|i
operator|++
control|)
name|rfReg
index|[
name|i
index|]
operator|=
name|ar5212Bank0_5111
index|[
name|i
index|]
index|[
name|modesIndex
index|]
expr_stmt|;
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ar5212ModifyRfBuffer
argument_list|(
name|rfReg
argument_list|,
name|ob2GHz
argument_list|,
literal|3
argument_list|,
literal|119
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|rfReg
argument_list|,
name|db2GHz
argument_list|,
literal|3
argument_list|,
literal|122
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|HAL_INI_WRITE_BANK
argument_list|(
name|ah
argument_list|,
name|ar5212Bank0_5111
argument_list|,
name|rfReg
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
comment|/* Bank 1 Write */
name|HAL_INI_WRITE_ARRAY
argument_list|(
name|ah
argument_list|,
name|ar5212Bank1_5111
argument_list|,
literal|1
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
comment|/* Bank 2 Write */
name|HAL_INI_WRITE_ARRAY
argument_list|(
name|ah
argument_list|,
name|ar5212Bank2_5111
argument_list|,
name|modesIndex
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
comment|/* Bank 3 Write */
name|HAL_INI_WRITE_ARRAY
argument_list|(
name|ah
argument_list|,
name|ar5212Bank3_5111
argument_list|,
name|modesIndex
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
comment|/* Bank 6 Write */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ar5212Bank6_5111
argument_list|)
condition|;
name|i
operator|++
control|)
name|rfReg
index|[
name|i
index|]
operator|=
name|ar5212Bank6_5111
index|[
name|i
index|]
index|[
name|modesIndex
index|]
expr_stmt|;
if|if
condition|(
name|IS_CHAN_A
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* NB: CHANNEL_A | CHANNEL_T */
name|ar5212ModifyRfBuffer
argument_list|(
name|rfReg
argument_list|,
name|ee
operator|->
name|ee_cornerCal
operator|.
name|pd84
argument_list|,
literal|1
argument_list|,
literal|51
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|rfReg
argument_list|,
name|ee
operator|->
name|ee_cornerCal
operator|.
name|pd90
argument_list|,
literal|1
argument_list|,
literal|45
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|ar5212ModifyRfBuffer
argument_list|(
name|rfReg
argument_list|,
name|rfPwdXpd
argument_list|,
literal|1
argument_list|,
literal|95
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|rfReg
argument_list|,
name|rfXpdGainFixed
argument_list|,
literal|4
argument_list|,
literal|96
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set 5212 OB& DB */
name|ar5212ModifyRfBuffer
argument_list|(
name|rfReg
argument_list|,
name|tempOB
argument_list|,
literal|3
argument_list|,
literal|104
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|rfReg
argument_list|,
name|tempDB
argument_list|,
literal|3
argument_list|,
literal|107
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HAL_INI_WRITE_BANK
argument_list|(
name|ah
argument_list|,
name|ar5212Bank6_5111
argument_list|,
name|rfReg
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
comment|/* Bank 7 Write */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ar5212Bank7_5111
argument_list|)
condition|;
name|i
operator|++
control|)
name|rfReg
index|[
name|i
index|]
operator|=
name|ar5212Bank7_5111
index|[
name|i
index|]
index|[
name|modesIndex
index|]
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|rfReg
argument_list|,
name|gainI
argument_list|,
literal|6
argument_list|,
literal|29
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|rfReg
argument_list|,
name|rfPloSel
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CHAN_QUARTER_RATE
argument_list|(
name|chan
argument_list|)
operator|||
name|IS_CHAN_HALF_RATE
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|uint32_t
name|rfWaitI
decl_stmt|,
name|rfWaitS
decl_stmt|,
name|rfMaxTime
decl_stmt|;
name|rfWaitS
operator|=
literal|0x1f
expr_stmt|;
name|rfWaitI
operator|=
operator|(
name|IS_CHAN_HALF_RATE
argument_list|(
name|chan
argument_list|)
operator|)
condition|?
literal|0x10
else|:
literal|0x1f
expr_stmt|;
name|rfMaxTime
operator|=
literal|3
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|rfReg
argument_list|,
name|rfWaitS
argument_list|,
literal|5
argument_list|,
literal|19
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|rfReg
argument_list|,
name|rfWaitI
argument_list|,
literal|5
argument_list|,
literal|24
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar5212ModifyRfBuffer
argument_list|(
name|rfReg
argument_list|,
name|rfMaxTime
argument_list|,
literal|2
argument_list|,
literal|49
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|HAL_INI_WRITE_BANK
argument_list|(
name|ah
argument_list|,
name|ar5212Bank7_5111
argument_list|,
name|rfReg
argument_list|,
name|regWrites
argument_list|)
expr_stmt|;
comment|/* Now that we have reprogrammed rfgain value, clear the flag. */
name|ahp
operator|->
name|ah_rfgainState
operator|=
name|HAL_RFGAIN_INACTIVE
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Returns interpolated or the scaled up interpolated value  */
end_comment

begin_function
specifier|static
name|uint16_t
name|interpolate
parameter_list|(
name|uint16_t
name|target
parameter_list|,
name|uint16_t
name|srcLeft
parameter_list|,
name|uint16_t
name|srcRight
parameter_list|,
name|uint16_t
name|targetLeft
parameter_list|,
name|uint16_t
name|targetRight
parameter_list|)
block|{
name|uint16_t
name|rv
decl_stmt|;
name|int16_t
name|lRatio
decl_stmt|;
comment|/* to get an accurate ratio, always scale, if want to scale, then don't scale back down */
if|if
condition|(
operator|(
name|targetLeft
operator|*
name|targetRight
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|srcRight
operator|!=
name|srcLeft
condition|)
block|{
comment|/* 		 * Note the ratio always need to be scaled, 		 * since it will be a fraction. 		 */
name|lRatio
operator|=
operator|(
name|target
operator|-
name|srcLeft
operator|)
operator|*
name|EEP_SCALE
operator|/
operator|(
name|srcRight
operator|-
name|srcLeft
operator|)
expr_stmt|;
if|if
condition|(
name|lRatio
operator|<
literal|0
condition|)
block|{
comment|/* Return as Left target if value would be negative */
name|rv
operator|=
name|targetLeft
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lRatio
operator|>
name|EEP_SCALE
condition|)
block|{
comment|/* Return as Right target if Ratio is greater than 100% (SCALE) */
name|rv
operator|=
name|targetRight
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
operator|(
name|lRatio
operator|*
name|targetRight
operator|+
operator|(
name|EEP_SCALE
operator|-
name|lRatio
operator|)
operator|*
name|targetLeft
operator|)
operator|/
name|EEP_SCALE
expr_stmt|;
block|}
block|}
else|else
block|{
name|rv
operator|=
name|targetLeft
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/*  * Read the transmit power levels from the structures taken from EEPROM  * Interpolate read transmit power values for this channel  * Organize the transmit power values into a table for writing into the hardware  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5111SetPowerTable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int16_t
modifier|*
name|pMinPower
parameter_list|,
name|int16_t
modifier|*
name|pMaxPower
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|,
name|uint16_t
modifier|*
name|rfXpdGain
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|HAL_EEPROM
modifier|*
name|ee
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|FULL_PCDAC_STRUCT
name|pcdacStruct
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint16_t
modifier|*
name|pPcdacValues
decl_stmt|;
name|int16_t
modifier|*
name|pScaledUpDbm
decl_stmt|;
name|int16_t
name|minScaledPwr
decl_stmt|;
name|int16_t
name|maxScaledPwr
decl_stmt|;
name|int16_t
name|pwr
decl_stmt|;
name|uint16_t
name|pcdacMin
init|=
literal|0
decl_stmt|;
name|uint16_t
name|pcdacMax
init|=
name|PCDAC_STOP
decl_stmt|;
name|uint16_t
name|pcdacTableIndex
decl_stmt|;
name|uint16_t
name|scaledPcdac
decl_stmt|;
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
decl_stmt|;
name|PCDACS_EEPROM
name|eepromPcdacs
decl_stmt|;
comment|/* setup the pcdac struct to point to the correct info, based on mode */
switch|switch
condition|(
name|chan
operator|->
name|channelFlags
operator|&
name|CHANNEL_ALL
condition|)
block|{
case|case
name|CHANNEL_A
case|:
case|case
name|CHANNEL_T
case|:
name|eepromPcdacs
operator|.
name|numChannels
operator|=
name|ee
operator|->
name|ee_numChannels11a
expr_stmt|;
name|eepromPcdacs
operator|.
name|pChannelList
operator|=
name|ee
operator|->
name|ee_channels11a
expr_stmt|;
name|eepromPcdacs
operator|.
name|pDataPerChannel
operator|=
name|ee
operator|->
name|ee_dataPerChannel11a
expr_stmt|;
break|break;
case|case
name|CHANNEL_B
case|:
name|eepromPcdacs
operator|.
name|numChannels
operator|=
name|ee
operator|->
name|ee_numChannels2_4
expr_stmt|;
name|eepromPcdacs
operator|.
name|pChannelList
operator|=
name|ee
operator|->
name|ee_channels11b
expr_stmt|;
name|eepromPcdacs
operator|.
name|pDataPerChannel
operator|=
name|ee
operator|->
name|ee_dataPerChannel11b
expr_stmt|;
break|break;
case|case
name|CHANNEL_G
case|:
case|case
name|CHANNEL_108G
case|:
name|eepromPcdacs
operator|.
name|numChannels
operator|=
name|ee
operator|->
name|ee_numChannels2_4
expr_stmt|;
name|eepromPcdacs
operator|.
name|pChannelList
operator|=
name|ee
operator|->
name|ee_channels11g
expr_stmt|;
name|eepromPcdacs
operator|.
name|pDataPerChannel
operator|=
name|ee
operator|->
name|ee_dataPerChannel11g
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: invalid channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channelFlags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|pSrcStruct
operator|=
operator|&
name|eepromPcdacs
expr_stmt|;
name|OS_MEMZERO
argument_list|(
operator|&
name|pcdacStruct
argument_list|,
sizeof|sizeof
argument_list|(
name|pcdacStruct
argument_list|)
argument_list|)
expr_stmt|;
name|pPcdacValues
operator|=
name|pcdacStruct
operator|.
name|PcdacValues
expr_stmt|;
name|pScaledUpDbm
operator|=
name|pcdacStruct
operator|.
name|PwrValues
expr_stmt|;
comment|/* Initialize the pcdacs to dBM structs pcdacs to be 1 to 63 */
for|for
control|(
name|i
operator|=
name|PCDAC_START
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<=
name|PCDAC_STOP
condition|;
name|i
operator|+=
name|PCDAC_STEP
operator|,
name|j
operator|++
control|)
name|pPcdacValues
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
name|pcdacStruct
operator|.
name|numPcdacValues
operator|=
name|j
expr_stmt|;
name|pcdacStruct
operator|.
name|pcdacMin
operator|=
name|PCDAC_START
expr_stmt|;
name|pcdacStruct
operator|.
name|pcdacMax
operator|=
name|PCDAC_STOP
expr_stmt|;
comment|/* Fill out the power values for this channel */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pcdacStruct
operator|.
name|numPcdacValues
condition|;
name|j
operator|++
control|)
name|pScaledUpDbm
index|[
name|j
index|]
operator|=
name|ar5212GetScaledPower
argument_list|(
name|chan
operator|->
name|channel
argument_list|,
name|pPcdacValues
index|[
name|j
index|]
argument_list|,
name|pSrcStruct
argument_list|)
expr_stmt|;
comment|/* Now scale the pcdac values to fit in the 64 entry power table */
name|minScaledPwr
operator|=
name|pScaledUpDbm
index|[
literal|0
index|]
expr_stmt|;
name|maxScaledPwr
operator|=
name|pScaledUpDbm
index|[
name|pcdacStruct
operator|.
name|numPcdacValues
operator|-
literal|1
index|]
expr_stmt|;
comment|/* find minimum and make monotonic */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pcdacStruct
operator|.
name|numPcdacValues
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|minScaledPwr
operator|>=
name|pScaledUpDbm
index|[
name|j
index|]
condition|)
block|{
name|minScaledPwr
operator|=
name|pScaledUpDbm
index|[
name|j
index|]
expr_stmt|;
name|pcdacMin
operator|=
name|j
expr_stmt|;
block|}
comment|/* 		 * Make the full_hsh monotonically increasing otherwise 		 * interpolation algorithm will get fooled gotta start 		 * working from the top, hence i = 63 - j. 		 */
name|i
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|pcdacStruct
operator|.
name|numPcdacValues
operator|-
literal|1
operator|-
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|pScaledUpDbm
index|[
name|i
operator|-
literal|1
index|]
operator|>
name|pScaledUpDbm
index|[
name|i
index|]
condition|)
block|{
comment|/* 			 * It could be a glitch, so make the power for 			 * this pcdac the same as the power from the 			 * next highest pcdac. 			 */
name|pScaledUpDbm
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|pScaledUpDbm
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pcdacStruct
operator|.
name|numPcdacValues
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|maxScaledPwr
operator|<
name|pScaledUpDbm
index|[
name|j
index|]
condition|)
block|{
name|maxScaledPwr
operator|=
name|pScaledUpDbm
index|[
name|j
index|]
expr_stmt|;
name|pcdacMax
operator|=
name|j
expr_stmt|;
block|}
comment|/* Find the first power level with a pcdac */
name|pwr
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|PWR_STEP
operator|*
operator|(
operator|(
name|minScaledPwr
operator|-
name|PWR_MIN
operator|+
name|PWR_STEP
operator|/
literal|2
operator|)
operator|/
name|PWR_STEP
operator|)
operator|+
name|PWR_MIN
argument_list|)
expr_stmt|;
comment|/* Write all the first pcdac entries based off the pcdacMin */
name|pcdacTableIndex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|2
operator|*
operator|(
name|pwr
operator|-
name|PWR_MIN
operator|)
operator|/
name|EEP_SCALE
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|HALASSERT
argument_list|(
name|pcdacTableIndex
operator|<
name|PWR_TABLE_SIZE
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_pcdacTable
index|[
name|pcdacTableIndex
operator|++
index|]
operator|=
name|pcdacMin
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pwr
operator|<
name|pScaledUpDbm
index|[
name|pcdacStruct
operator|.
name|numPcdacValues
operator|-
literal|1
index|]
operator|&&
name|pcdacTableIndex
operator|<
name|PWR_TABLE_SIZE
condition|)
block|{
name|pwr
operator|+=
name|PWR_STEP
expr_stmt|;
comment|/* stop if dbM> max_power_possible */
while|while
condition|(
name|pwr
operator|<
name|pScaledUpDbm
index|[
name|pcdacStruct
operator|.
name|numPcdacValues
operator|-
literal|1
index|]
operator|&&
operator|(
name|pwr
operator|-
name|pScaledUpDbm
index|[
name|i
index|]
operator|)
operator|*
operator|(
name|pwr
operator|-
name|pScaledUpDbm
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|>
literal|0
condition|)
name|i
operator|++
expr_stmt|;
comment|/* scale by 2 and add 1 to enable round up or down as needed */
name|scaledPcdac
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|interpolate
argument_list|(
name|pwr
argument_list|,
name|pScaledUpDbm
index|[
name|i
index|]
argument_list|,
name|pScaledUpDbm
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|pPcdacValues
index|[
name|i
index|]
operator|*
literal|2
argument_list|)
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|pPcdacValues
index|[
name|i
operator|+
literal|1
index|]
operator|*
literal|2
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|pcdacTableIndex
operator|<
name|PWR_TABLE_SIZE
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_pcdacTable
index|[
name|pcdacTableIndex
index|]
operator|=
name|scaledPcdac
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_pcdacTable
index|[
name|pcdacTableIndex
index|]
operator|>
name|pcdacMax
condition|)
name|ahp
operator|->
name|ah_pcdacTable
index|[
name|pcdacTableIndex
index|]
operator|=
name|pcdacMax
expr_stmt|;
name|pcdacTableIndex
operator|++
expr_stmt|;
block|}
comment|/* Write all the last pcdac entries based off the last valid pcdac */
while|while
condition|(
name|pcdacTableIndex
operator|<
name|PWR_TABLE_SIZE
condition|)
block|{
name|ahp
operator|->
name|ah_pcdacTable
index|[
name|pcdacTableIndex
index|]
operator|=
name|ahp
operator|->
name|ah_pcdacTable
index|[
name|pcdacTableIndex
operator|-
literal|1
index|]
expr_stmt|;
name|pcdacTableIndex
operator|++
expr_stmt|;
block|}
comment|/* No power table adjustment for 5111 */
name|ahp
operator|->
name|ah_txPowerIndexOffset
operator|=
literal|0
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Get or interpolate the pcdac value from the calibrated data.  */
end_comment

begin_function
specifier|static
name|uint16_t
name|ar5212GetScaledPower
parameter_list|(
name|uint16_t
name|channel
parameter_list|,
name|uint16_t
name|pcdacValue
parameter_list|,
specifier|const
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
parameter_list|)
block|{
name|uint16_t
name|powerValue
decl_stmt|;
name|uint16_t
name|lFreq
decl_stmt|,
name|rFreq
decl_stmt|;
comment|/* left and right frequency values */
name|uint16_t
name|llPcdac
decl_stmt|,
name|ulPcdac
decl_stmt|;
comment|/* lower and upper left pcdac values */
name|uint16_t
name|lrPcdac
decl_stmt|,
name|urPcdac
decl_stmt|;
comment|/* lower and upper right pcdac values */
name|uint16_t
name|lPwr
decl_stmt|,
name|uPwr
decl_stmt|;
comment|/* lower and upper temp pwr values */
name|uint16_t
name|lScaledPwr
decl_stmt|,
name|rScaledPwr
decl_stmt|;
comment|/* left and right scaled power */
if|if
condition|(
name|ar5212FindValueInList
argument_list|(
name|channel
argument_list|,
name|pcdacValue
argument_list|,
name|pSrcStruct
argument_list|,
operator|&
name|powerValue
argument_list|)
condition|)
block|{
comment|/* value was copied from srcStruct */
return|return
name|powerValue
return|;
block|}
name|ar5212GetLowerUpperValues
argument_list|(
name|channel
argument_list|,
name|pSrcStruct
operator|->
name|pChannelList
argument_list|,
name|pSrcStruct
operator|->
name|numChannels
argument_list|,
operator|&
name|lFreq
argument_list|,
operator|&
name|rFreq
argument_list|)
expr_stmt|;
name|ar5212GetLowerUpperPcdacs
argument_list|(
name|pcdacValue
argument_list|,
name|lFreq
argument_list|,
name|pSrcStruct
argument_list|,
operator|&
name|llPcdac
argument_list|,
operator|&
name|ulPcdac
argument_list|)
expr_stmt|;
name|ar5212GetLowerUpperPcdacs
argument_list|(
name|pcdacValue
argument_list|,
name|rFreq
argument_list|,
name|pSrcStruct
argument_list|,
operator|&
name|lrPcdac
argument_list|,
operator|&
name|urPcdac
argument_list|)
expr_stmt|;
comment|/* get the power index for the pcdac value */
name|ar5212FindValueInList
argument_list|(
name|lFreq
argument_list|,
name|llPcdac
argument_list|,
name|pSrcStruct
argument_list|,
operator|&
name|lPwr
argument_list|)
expr_stmt|;
name|ar5212FindValueInList
argument_list|(
name|lFreq
argument_list|,
name|ulPcdac
argument_list|,
name|pSrcStruct
argument_list|,
operator|&
name|uPwr
argument_list|)
expr_stmt|;
name|lScaledPwr
operator|=
name|interpolate
argument_list|(
name|pcdacValue
argument_list|,
name|llPcdac
argument_list|,
name|ulPcdac
argument_list|,
name|lPwr
argument_list|,
name|uPwr
argument_list|)
expr_stmt|;
name|ar5212FindValueInList
argument_list|(
name|rFreq
argument_list|,
name|lrPcdac
argument_list|,
name|pSrcStruct
argument_list|,
operator|&
name|lPwr
argument_list|)
expr_stmt|;
name|ar5212FindValueInList
argument_list|(
name|rFreq
argument_list|,
name|urPcdac
argument_list|,
name|pSrcStruct
argument_list|,
operator|&
name|uPwr
argument_list|)
expr_stmt|;
name|rScaledPwr
operator|=
name|interpolate
argument_list|(
name|pcdacValue
argument_list|,
name|lrPcdac
argument_list|,
name|urPcdac
argument_list|,
name|lPwr
argument_list|,
name|uPwr
argument_list|)
expr_stmt|;
return|return
name|interpolate
argument_list|(
name|channel
argument_list|,
name|lFreq
argument_list|,
name|rFreq
argument_list|,
name|lScaledPwr
argument_list|,
name|rScaledPwr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the value from the calibrated source data struct  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar5212FindValueInList
parameter_list|(
name|uint16_t
name|channel
parameter_list|,
name|uint16_t
name|pcdacValue
parameter_list|,
specifier|const
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
parameter_list|,
name|uint16_t
modifier|*
name|powerValue
parameter_list|)
block|{
specifier|const
name|DATA_PER_CHANNEL
modifier|*
name|pChannelData
init|=
name|pSrcStruct
operator|->
name|pDataPerChannel
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pSrcStruct
operator|->
name|numChannels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pChannelData
operator|->
name|channelValue
operator|==
name|channel
condition|)
block|{
specifier|const
name|uint16_t
modifier|*
name|pPcdac
init|=
name|pChannelData
operator|->
name|PcdacValues
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pChannelData
operator|->
name|numPcdacValues
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|pPcdac
operator|==
name|pcdacValue
condition|)
block|{
operator|*
name|powerValue
operator|=
name|pChannelData
operator|->
name|PwrValues
index|[
name|j
index|]
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
name|pPcdac
operator|++
expr_stmt|;
block|}
block|}
name|pChannelData
operator|++
expr_stmt|;
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Get the upper and lower pcdac given the channel and the pcdac  * used in the search  */
end_comment

begin_function
specifier|static
name|void
name|ar5212GetLowerUpperPcdacs
parameter_list|(
name|uint16_t
name|pcdac
parameter_list|,
name|uint16_t
name|channel
parameter_list|,
specifier|const
name|PCDACS_EEPROM
modifier|*
name|pSrcStruct
parameter_list|,
name|uint16_t
modifier|*
name|pLowerPcdac
parameter_list|,
name|uint16_t
modifier|*
name|pUpperPcdac
parameter_list|)
block|{
specifier|const
name|DATA_PER_CHANNEL
modifier|*
name|pChannelData
init|=
name|pSrcStruct
operator|->
name|pDataPerChannel
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find the channel information */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pSrcStruct
operator|->
name|numChannels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pChannelData
operator|->
name|channelValue
operator|==
name|channel
condition|)
break|break;
name|pChannelData
operator|++
expr_stmt|;
block|}
name|ar5212GetLowerUpperValues
argument_list|(
name|pcdac
argument_list|,
name|pChannelData
operator|->
name|PcdacValues
argument_list|,
name|pChannelData
operator|->
name|numPcdacValues
argument_list|,
name|pLowerPcdac
argument_list|,
name|pUpperPcdac
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar5111GetChannelMaxMinPower
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|maxPow
parameter_list|,
name|int16_t
modifier|*
name|minPow
parameter_list|)
block|{
comment|/* XXX - Get 5111 power limits! */
comment|/* NB: caller will cope */
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust NF based on statistical values for 5GHz frequencies.  */
end_comment

begin_function
specifier|static
name|int16_t
name|ar5111GetNfAdjust
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_CHANNEL_INTERNAL
modifier|*
name|c
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
name|uint16_t
name|freqLow
decl_stmt|;
name|int16_t
name|adjust
decl_stmt|;
block|}
name|adjust5111
index|[]
init|=
block|{
block|{
literal|5790
block|,
literal|6
block|}
block|,
comment|/* NB: ordered high -> low */
block|{
literal|5730
block|,
literal|4
block|}
block|,
block|{
literal|5690
block|,
literal|3
block|}
block|,
block|{
literal|5660
block|,
literal|2
block|}
block|,
block|{
literal|5610
block|,
literal|1
block|}
block|,
block|{
literal|5530
block|,
literal|0
block|}
block|,
block|{
literal|5450
block|,
literal|0
block|}
block|,
block|{
literal|5379
block|,
literal|1
block|}
block|,
block|{
literal|5209
block|,
literal|3
block|}
block|,
block|{
literal|3000
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, 	}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|c
operator|->
name|channel
operator|<=
name|adjust5111
index|[
name|i
index|]
operator|.
name|freqLow
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
name|adjust5111
index|[
name|i
index|]
operator|.
name|adjust
return|;
block|}
end_function

begin_comment
comment|/*  * Free memory for analog bank scratch buffers  */
end_comment

begin_function
specifier|static
name|void
name|ar5111RfDetach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HALASSERT
argument_list|(
name|ahp
operator|->
name|ah_rfHal
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
name|ath_hal_free
argument_list|(
name|ahp
operator|->
name|ah_rfHal
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_rfHal
operator|=
name|AH_NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate memory for analog bank scratch buffers  * Scratch Buffer will be reinitialized every reset so no need to zero now  */
end_comment

begin_function
name|HAL_BOOL
name|ar5111RfAttach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
name|struct
name|ath_hal_5212
modifier|*
name|ahp
init|=
name|AH5212
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar5111State
modifier|*
name|priv
decl_stmt|;
name|HALASSERT
argument_list|(
name|ah
operator|->
name|ah_magic
operator|==
name|AR5212_MAGIC
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|ahp
operator|->
name|ah_rfHal
operator|==
name|AH_NULL
argument_list|)
expr_stmt|;
name|priv
operator|=
name|ath_hal_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ar5111State
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANY
argument_list|,
literal|"%s: cannot allocate private state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|HAL_ENOMEM
expr_stmt|;
comment|/* XXX */
return|return
name|AH_FALSE
return|;
block|}
name|priv
operator|->
name|base
operator|.
name|rfDetach
operator|=
name|ar5111RfDetach
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|writeRegs
operator|=
name|ar5111WriteRegs
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getRfBank
operator|=
name|ar5111GetRfBank
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setChannel
operator|=
name|ar5111SetChannel
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setRfRegs
operator|=
name|ar5111SetRfRegs
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|setPowerTable
operator|=
name|ar5111SetPowerTable
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getChannelMaxMinPower
operator|=
name|ar5111GetChannelMaxMinPower
expr_stmt|;
name|priv
operator|->
name|base
operator|.
name|getNfAdjust
operator|=
name|ar5111GetNfAdjust
expr_stmt|;
name|ahp
operator|->
name|ah_pcdacTable
operator|=
name|priv
operator|->
name|pcdacTable
expr_stmt|;
name|ahp
operator|->
name|ah_pcdacTableSize
operator|=
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|pcdacTable
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_rfHal
operator|=
operator|&
name|priv
operator|->
name|base
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AH_SUPPORT_5111 */
end_comment

end_unit

