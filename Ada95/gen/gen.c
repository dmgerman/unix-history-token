begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998,2010,2011 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *   Author:  Juergen Pfeifer, 1996                                         *  ****************************************************************************/
end_comment

begin_comment
comment|/*     Version Control     $Id: gen.c,v 1.59 2011/03/31 23:50:24 tom Exp $   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*   This program generates various record structures and constants from the   ncurses header file for the Ada95 packages. Essentially it produces   Ada95 source on stdout, which is then merged using m4 into a template   to produce the real source.   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<ncurses_cfg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<ncurses.h>
end_include

begin_define
define|#
directive|define
name|HAVE_USE_DEFAULT_COLORS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<menu.h>
end_include

begin_include
include|#
directive|include
file|<form.h>
end_include

begin_define
define|#
directive|define
name|UChar
parameter_list|(
name|c
parameter_list|)
value|((unsigned char)(c))
end_define

begin_define
define|#
directive|define
name|RES_NAME
value|"Reserved"
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|model
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|little_endian
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|attr
decl_stmt|;
block|}
name|name_attribute_pair
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|find_pos
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|len
parameter_list|,
name|int
modifier|*
name|low
parameter_list|,
name|int
modifier|*
name|high
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
operator|*
name|high
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|low
operator|=
call|(
name|int
call|)
argument_list|(
literal|8
operator|*
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|little_endian
operator|&&
operator|(
operator|(
operator|*
name|s
operator|)
operator|&
literal|0x01
operator|)
operator|)
operator|||
operator|(
operator|!
name|little_endian
operator|&&
operator|(
operator|(
operator|*
name|s
operator|)
operator|&
literal|0x80
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|l
operator|>
operator|*
name|high
condition|)
operator|*
name|high
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|l
operator|<
operator|*
name|low
condition|)
operator|*
name|low
operator|=
name|l
expr_stmt|;
block|}
name|l
operator|++
expr_stmt|;
if|if
condition|(
name|little_endian
condition|)
block|{
operator|*
name|s
operator|>>=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|=
call|(
name|char
call|)
argument_list|(
operator|*
name|s
operator|<<
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|l
operator|+=
literal|8
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|high
operator|>=
literal|0
operator|&&
operator|(
operator|*
name|low
operator|<=
operator|*
name|high
operator|)
operator|)
condition|?
operator|*
name|low
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * This helper routine generates a representation clause for a  * record type defined in the binding.  * We are only dealing with record types which are of 32 or 16  * bit size, i.e. they fit into an (u)int or a (u)short.  */
end_comment

begin_function
specifier|static
name|void
name|gen_reps
parameter_list|(
specifier|const
name|name_attribute_pair
modifier|*
name|nap
parameter_list|,
comment|/* array of name_attribute_pair records */
specifier|const
name|char
modifier|*
name|name
parameter_list|,
comment|/* name of the represented record type  */
name|int
name|len
parameter_list|,
comment|/* size of the record in bytes          */
name|int
name|bias
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|unused_name
init|=
literal|"Unused"
decl_stmt|;
name|int
name|long_bits
init|=
operator|(
literal|8
operator|*
operator|(
name|int
operator|)
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|)
decl_stmt|;
name|int
name|len_bits
init|=
operator|(
literal|8
operator|*
name|len
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|,
name|l
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|width
init|=
name|strlen
argument_list|(
name|RES_NAME
argument_list|)
operator|+
literal|3
decl_stmt|;
name|unsigned
name|long
name|a
decl_stmt|;
name|unsigned
name|long
name|mask
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|nap
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nap
index|[
name|i
index|]
operator|.
name|name
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|cnt
operator|++
expr_stmt|;
name|l
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|nap
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|width
condition|)
name|width
operator|=
name|l
expr_stmt|;
block|}
name|assert
argument_list|(
name|width
operator|>
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   type %s is\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      record\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nap
index|[
name|i
index|]
operator|.
name|name
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|mask
operator||=
name|nap
index|[
name|i
index|]
operator|.
name|attr
expr_stmt|;
name|printf
argument_list|(
literal|"         %-*s : Boolean;\n"
argument_list|,
name|width
argument_list|,
name|nap
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|/*    * Compute a mask for the unused bits in this target.    */
name|mask
operator|=
operator|~
name|mask
expr_stmt|;
comment|/*    * Bits in the biased area are unused by the target.    */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bias
condition|;
operator|++
name|j
control|)
block|{
name|mask
operator|&=
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|~
operator|(
literal|1L
operator|<<
name|j
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*    * Bits past the target's size are really unused.    */
for|for
control|(
name|j
operator|=
name|len_bits
operator|+
name|bias
init|;
name|j
operator|<
name|long_bits
condition|;
operator|++
name|j
control|)
block|{
name|mask
operator|&=
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|~
operator|(
literal|1L
operator|<<
name|j
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"         %-*s : Boolean;\n"
argument_list|,
name|width
argument_list|,
name|unused_name
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"      end record;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   pragma Convention (C, %s);\n\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   for %s use\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      record\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nap
index|[
name|i
index|]
operator|.
name|name
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
name|nap
index|[
name|i
index|]
operator|.
name|attr
expr_stmt|;
name|l
operator|=
name|find_pos
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"         %-*s at 0 range %2d .. %2d;\n"
argument_list|,
name|width
argument_list|,
name|nap
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|low
operator|-
name|bias
argument_list|,
name|high
operator|-
name|bias
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
name|l
operator|=
name|find_pos
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"         %-*s at 0 range %2d .. %2d;\n"
argument_list|,
name|width
argument_list|,
name|unused_name
argument_list|,
name|low
operator|-
name|bias
argument_list|,
name|high
operator|-
name|bias
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|1
expr_stmt|;
name|n
operator|=
name|cnt
expr_stmt|;
name|printf
argument_list|(
literal|"      end record;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   for %s'Size use %d;\n"
argument_list|,
name|name
argument_list|,
name|len_bits
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   --  Please note: this rep. clause is generated and may be\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   --               different on your system."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|chtype_rep
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|attr_t
name|mask
parameter_list|)
block|{
name|attr_t
name|x
init|=
operator|(
name|attr_t
operator|)
operator|-
literal|1
decl_stmt|;
name|attr_t
name|t
init|=
name|x
operator|&
name|mask
decl_stmt|;
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|l
init|=
name|find_pos
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"         %-5s at 0 range %2d .. %2d;\n"
argument_list|,
name|name
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_chtype_rep
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|printf
argument_list|(
literal|"   for %s use\n      record\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|chtype_rep
argument_list|(
literal|"Ch"
argument_list|,
name|A_CHARTEXT
argument_list|)
expr_stmt|;
name|chtype_rep
argument_list|(
literal|"Color"
argument_list|,
name|A_COLOR
argument_list|)
expr_stmt|;
name|chtype_rep
argument_list|(
literal|"Attr"
argument_list|,
operator|(
name|A_ATTRIBUTES
operator|&
operator|~
name|A_COLOR
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      end record;\n   for %s'Size use %ld;\n"
argument_list|,
name|name
argument_list|,
call|(
name|long
call|)
argument_list|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|chtype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      --  Please note: this rep. clause is generated and may be\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      --               different on your system.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mrep_rep
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|rec
parameter_list|)
block|{
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|l
init|=
name|find_pos
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rec
argument_list|,
sizeof|sizeof
argument_list|(
name|MEVENT
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"         %-7s at 0 range %3d .. %3d;\n"
argument_list|,
name|name
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_mrep_rep
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|MEVENT
name|x
decl_stmt|;
name|printf
argument_list|(
literal|"   for %s use\n      record\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|x
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|id
operator|=
operator|-
literal|1
expr_stmt|;
name|mrep_rep
argument_list|(
literal|"Id"
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|x
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|x
operator|=
operator|-
literal|1
expr_stmt|;
name|mrep_rep
argument_list|(
literal|"X"
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|x
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|y
operator|=
operator|-
literal|1
expr_stmt|;
name|mrep_rep
argument_list|(
literal|"Y"
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|x
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|z
operator|=
operator|-
literal|1
expr_stmt|;
name|mrep_rep
argument_list|(
literal|"Z"
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|x
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|bstate
operator|=
operator|(
name|mmask_t
operator|)
operator|-
literal|1
expr_stmt|;
name|mrep_rep
argument_list|(
literal|"Bstate"
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      end record;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      --  Please note: this rep. clause is generated and may be\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      --               different on your system.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_attr_set
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* All of the A_xxx symbols are defined in ncurses, but not all are nonzero    * if "configure --enable-widec" is not specified.  Originally (in    * 1999-2000), the ifdef's also were needed since the proposed bit-layout    * for wide characters allocated 16-bits for A_CHARTEXT, leaving too few    * bits for a few of the A_xxx symbols.    */
specifier|static
specifier|const
name|name_attribute_pair
name|nap
index|[]
init|=
block|{
if|#
directive|if
name|A_STANDOUT
block|{
literal|"Stand_Out"
block|,
name|A_STANDOUT
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|A_UNDERLINE
block|{
literal|"Under_Line"
block|,
name|A_UNDERLINE
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|A_REVERSE
block|{
literal|"Reverse_Video"
block|,
name|A_REVERSE
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|A_BLINK
block|{
literal|"Blink"
block|,
name|A_BLINK
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|A_DIM
block|{
literal|"Dim_Character"
block|,
name|A_DIM
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|A_BOLD
block|{
literal|"Bold_Character"
block|,
name|A_BOLD
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|A_ALTCHARSET
block|{
literal|"Alternate_Character_Set"
block|,
name|A_ALTCHARSET
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|A_INVIS
block|{
literal|"Invisible_Character"
block|,
name|A_INVIS
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|A_PROTECT
block|{
literal|"Protected_Character"
block|,
name|A_PROTECT
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|A_HORIZONTAL
block|{
literal|"Horizontal"
block|,
name|A_HORIZONTAL
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|A_LEFT
block|{
literal|"Left"
block|,
name|A_LEFT
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|A_LOW
block|{
literal|"Low"
block|,
name|A_LOW
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|A_RIGHT
block|{
literal|"Right"
block|,
name|A_RIGHT
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|A_TOP
block|{
literal|"Top"
block|,
name|A_TOP
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|A_VERTICAL
block|{
literal|"Vertical"
block|,
name|A_VERTICAL
block|}
block|,
endif|#
directive|endif
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|chtype
name|attr
init|=
name|A_ATTRIBUTES
operator|&
operator|~
name|A_COLOR
decl_stmt|;
name|int
name|start
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|chtype
name|set
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|chtype
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|set
operator|=
operator|(
name|attr
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|start
operator|>=
literal|0
condition|)
block|{
name|len
operator|++
expr_stmt|;
block|}
block|}
name|attr
operator|=
name|attr
operator|>>
literal|1
expr_stmt|;
block|}
name|gen_reps
argument_list|(
name|nap
argument_list|,
name|name
argument_list|,
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
name|little_endian
condition|?
name|start
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_trace
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
specifier|const
name|name_attribute_pair
name|nap
index|[]
init|=
block|{
block|{
literal|"Times"
block|,
name|TRACE_TIMES
block|}
block|,
block|{
literal|"Tputs"
block|,
name|TRACE_TPUTS
block|}
block|,
block|{
literal|"Update"
block|,
name|TRACE_UPDATE
block|}
block|,
block|{
literal|"Cursor_Move"
block|,
name|TRACE_MOVE
block|}
block|,
block|{
literal|"Character_Output"
block|,
name|TRACE_CHARPUT
block|}
block|,
block|{
literal|"Calls"
block|,
name|TRACE_CALLS
block|}
block|,
block|{
literal|"Virtual_Puts"
block|,
name|TRACE_VIRTPUT
block|}
block|,
block|{
literal|"Input_Events"
block|,
name|TRACE_IEVENT
block|}
block|,
block|{
literal|"TTY_State"
block|,
name|TRACE_BITS
block|}
block|,
block|{
literal|"Internal_Calls"
block|,
name|TRACE_ICALLS
block|}
block|,
block|{
literal|"Character_Calls"
block|,
name|TRACE_CCALLS
block|}
block|,
block|{
literal|"Termcap_TermInfo"
block|,
name|TRACE_DATABASE
block|}
block|,
block|{
literal|"Attributes_And_Colors"
block|,
name|TRACE_ATTRS
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|gen_reps
argument_list|(
name|nap
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_menu_opt_rep
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
specifier|const
name|name_attribute_pair
name|nap
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|O_ONEVALUE
block|{
literal|"One_Valued"
block|,
name|O_ONEVALUE
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_SHOWDESC
block|{
literal|"Show_Descriptions"
block|,
name|O_SHOWDESC
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_ROWMAJOR
block|{
literal|"Row_Major_Order"
block|,
name|O_ROWMAJOR
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_IGNORECASE
block|{
literal|"Ignore_Case"
block|,
name|O_IGNORECASE
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_SHOWMATCH
block|{
literal|"Show_Matches"
block|,
name|O_SHOWMATCH
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_NONCYCLIC
block|{
literal|"Non_Cyclic"
block|,
name|O_NONCYCLIC
block|}
block|,
endif|#
directive|endif
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|gen_reps
argument_list|(
name|nap
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_item_opt_rep
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
specifier|const
name|name_attribute_pair
name|nap
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|O_SELECTABLE
block|{
literal|"Selectable"
block|,
name|O_SELECTABLE
block|}
block|,
endif|#
directive|endif
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|gen_reps
argument_list|(
name|nap
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_form_opt_rep
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
specifier|const
name|name_attribute_pair
name|nap
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|O_NL_OVERLOAD
block|{
literal|"NL_Overload"
block|,
name|O_NL_OVERLOAD
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_BS_OVERLOAD
block|{
literal|"BS_Overload"
block|,
name|O_BS_OVERLOAD
block|}
block|,
endif|#
directive|endif
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|gen_reps
argument_list|(
name|nap
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the representation clause for the Field_Option_Set record  */
end_comment

begin_function
specifier|static
name|void
name|gen_field_opt_rep
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
specifier|const
name|name_attribute_pair
name|nap
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|O_VISIBLE
block|{
literal|"Visible"
block|,
name|O_VISIBLE
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_ACTIVE
block|{
literal|"Active"
block|,
name|O_ACTIVE
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_PUBLIC
block|{
literal|"Public"
block|,
name|O_PUBLIC
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_EDIT
block|{
literal|"Edit"
block|,
name|O_EDIT
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_WRAP
block|{
literal|"Wrap"
block|,
name|O_WRAP
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_BLANK
block|{
literal|"Blank"
block|,
name|O_BLANK
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_AUTOSKIP
block|{
literal|"Auto_Skip"
block|,
name|O_AUTOSKIP
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_NULLOK
block|{
literal|"Null_Ok"
block|,
name|O_NULLOK
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_PASSOK
block|{
literal|"Pass_Ok"
block|,
name|O_PASSOK
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_STATIC
block|{
literal|"Static"
block|,
name|O_STATIC
block|}
block|,
endif|#
directive|endif
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|gen_reps
argument_list|(
name|nap
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate a single key code constant definition.  */
end_comment

begin_function
specifier|static
name|void
name|keydef
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|old_name
parameter_list|,
name|int
name|value
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
comment|/* Generate the new name */
name|printf
argument_list|(
literal|"   %-30s : constant Special_Key_Code := 8#%3o#;\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|old_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|t
init|=
name|name
decl_stmt|;
comment|/* generate the old name, but only if it doesn't conflict with the old        * name (Ada95 isn't case sensitive!)        */
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|t
operator|&&
operator|(
name|toupper
argument_list|(
name|UChar
argument_list|(
operator|*
name|s
operator|++
argument_list|)
argument_list|)
operator|==
name|toupper
argument_list|(
name|UChar
argument_list|(
operator|*
name|t
operator|++
argument_list|)
argument_list|)
operator|)
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|||
operator|*
name|t
condition|)
name|printf
argument_list|(
literal|"   %-16s : Special_Key_Code renames %s;\n"
argument_list|,
name|old_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Generate constants for the key codes. When called with mode==0, a  * complete list with nice constant names in proper casing style will  * be generated. Otherwise a list of old (i.e. C-style) names will be  * generated, given that the name wasn't already defined in the "nice"  * list.  */
end_comment

begin_function
specifier|static
name|void
name|gen_keydefs
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|char
name|obuf
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|KEY_CODE_YES
name|keydef
argument_list|(
literal|"Key_Code_Yes"
argument_list|,
literal|"KEY_CODE_YES"
argument_list|,
name|KEY_CODE_YES
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_MIN
name|keydef
argument_list|(
literal|"Key_Min"
argument_list|,
literal|"KEY_MIN"
argument_list|,
name|KEY_MIN
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_BREAK
name|keydef
argument_list|(
literal|"Key_Break"
argument_list|,
literal|"KEY_BREAK"
argument_list|,
name|KEY_BREAK
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_DOWN
name|keydef
argument_list|(
literal|"Key_Cursor_Down"
argument_list|,
literal|"KEY_DOWN"
argument_list|,
name|KEY_DOWN
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_UP
name|keydef
argument_list|(
literal|"Key_Cursor_Up"
argument_list|,
literal|"KEY_UP"
argument_list|,
name|KEY_UP
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_LEFT
name|keydef
argument_list|(
literal|"Key_Cursor_Left"
argument_list|,
literal|"KEY_LEFT"
argument_list|,
name|KEY_LEFT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_RIGHT
name|keydef
argument_list|(
literal|"Key_Cursor_Right"
argument_list|,
literal|"KEY_RIGHT"
argument_list|,
name|KEY_RIGHT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_HOME
name|keydef
argument_list|(
literal|"Key_Home"
argument_list|,
literal|"KEY_HOME"
argument_list|,
name|KEY_HOME
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_BACKSPACE
name|keydef
argument_list|(
literal|"Key_Backspace"
argument_list|,
literal|"KEY_BACKSPACE"
argument_list|,
name|KEY_BACKSPACE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_F0
name|keydef
argument_list|(
literal|"Key_F0"
argument_list|,
literal|"KEY_F0"
argument_list|,
name|KEY_F0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_F
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|24
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Key_F%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|obuf
argument_list|,
literal|"KEY_F%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|keydef
argument_list|(
name|buf
argument_list|,
name|obuf
argument_list|,
name|KEY_F
argument_list|(
name|i
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_DL
name|keydef
argument_list|(
literal|"Key_Delete_Line"
argument_list|,
literal|"KEY_DL"
argument_list|,
name|KEY_DL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_IL
name|keydef
argument_list|(
literal|"Key_Insert_Line"
argument_list|,
literal|"KEY_IL"
argument_list|,
name|KEY_IL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_DC
name|keydef
argument_list|(
literal|"Key_Delete_Char"
argument_list|,
literal|"KEY_DC"
argument_list|,
name|KEY_DC
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_IC
name|keydef
argument_list|(
literal|"Key_Insert_Char"
argument_list|,
literal|"KEY_IC"
argument_list|,
name|KEY_IC
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_EIC
name|keydef
argument_list|(
literal|"Key_Exit_Insert_Mode"
argument_list|,
literal|"KEY_EIC"
argument_list|,
name|KEY_EIC
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_CLEAR
name|keydef
argument_list|(
literal|"Key_Clear_Screen"
argument_list|,
literal|"KEY_CLEAR"
argument_list|,
name|KEY_CLEAR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_EOS
name|keydef
argument_list|(
literal|"Key_Clear_End_Of_Screen"
argument_list|,
literal|"KEY_EOS"
argument_list|,
name|KEY_EOS
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_EOL
name|keydef
argument_list|(
literal|"Key_Clear_End_Of_Line"
argument_list|,
literal|"KEY_EOL"
argument_list|,
name|KEY_EOL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SF
name|keydef
argument_list|(
literal|"Key_Scroll_1_Forward"
argument_list|,
literal|"KEY_SF"
argument_list|,
name|KEY_SF
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SR
name|keydef
argument_list|(
literal|"Key_Scroll_1_Backward"
argument_list|,
literal|"KEY_SR"
argument_list|,
name|KEY_SR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_NPAGE
name|keydef
argument_list|(
literal|"Key_Next_Page"
argument_list|,
literal|"KEY_NPAGE"
argument_list|,
name|KEY_NPAGE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_PPAGE
name|keydef
argument_list|(
literal|"Key_Previous_Page"
argument_list|,
literal|"KEY_PPAGE"
argument_list|,
name|KEY_PPAGE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_STAB
name|keydef
argument_list|(
literal|"Key_Set_Tab"
argument_list|,
literal|"KEY_STAB"
argument_list|,
name|KEY_STAB
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_CTAB
name|keydef
argument_list|(
literal|"Key_Clear_Tab"
argument_list|,
literal|"KEY_CTAB"
argument_list|,
name|KEY_CTAB
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_CATAB
name|keydef
argument_list|(
literal|"Key_Clear_All_Tabs"
argument_list|,
literal|"KEY_CATAB"
argument_list|,
name|KEY_CATAB
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_ENTER
name|keydef
argument_list|(
literal|"Key_Enter_Or_Send"
argument_list|,
literal|"KEY_ENTER"
argument_list|,
name|KEY_ENTER
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SRESET
name|keydef
argument_list|(
literal|"Key_Soft_Reset"
argument_list|,
literal|"KEY_SRESET"
argument_list|,
name|KEY_SRESET
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_RESET
name|keydef
argument_list|(
literal|"Key_Reset"
argument_list|,
literal|"KEY_RESET"
argument_list|,
name|KEY_RESET
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_PRINT
name|keydef
argument_list|(
literal|"Key_Print"
argument_list|,
literal|"KEY_PRINT"
argument_list|,
name|KEY_PRINT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_LL
name|keydef
argument_list|(
literal|"Key_Bottom"
argument_list|,
literal|"KEY_LL"
argument_list|,
name|KEY_LL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_A1
name|keydef
argument_list|(
literal|"Key_Upper_Left_Of_Keypad"
argument_list|,
literal|"KEY_A1"
argument_list|,
name|KEY_A1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_A3
name|keydef
argument_list|(
literal|"Key_Upper_Right_Of_Keypad"
argument_list|,
literal|"KEY_A3"
argument_list|,
name|KEY_A3
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_B2
name|keydef
argument_list|(
literal|"Key_Center_Of_Keypad"
argument_list|,
literal|"KEY_B2"
argument_list|,
name|KEY_B2
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_C1
name|keydef
argument_list|(
literal|"Key_Lower_Left_Of_Keypad"
argument_list|,
literal|"KEY_C1"
argument_list|,
name|KEY_C1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_C3
name|keydef
argument_list|(
literal|"Key_Lower_Right_Of_Keypad"
argument_list|,
literal|"KEY_C3"
argument_list|,
name|KEY_C3
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_BTAB
name|keydef
argument_list|(
literal|"Key_Back_Tab"
argument_list|,
literal|"KEY_BTAB"
argument_list|,
name|KEY_BTAB
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_BEG
name|keydef
argument_list|(
literal|"Key_Beginning"
argument_list|,
literal|"KEY_BEG"
argument_list|,
name|KEY_BEG
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_CANCEL
name|keydef
argument_list|(
literal|"Key_Cancel"
argument_list|,
literal|"KEY_CANCEL"
argument_list|,
name|KEY_CANCEL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_CLOSE
name|keydef
argument_list|(
literal|"Key_Close"
argument_list|,
literal|"KEY_CLOSE"
argument_list|,
name|KEY_CLOSE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_COMMAND
name|keydef
argument_list|(
literal|"Key_Command"
argument_list|,
literal|"KEY_COMMAND"
argument_list|,
name|KEY_COMMAND
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_COPY
name|keydef
argument_list|(
literal|"Key_Copy"
argument_list|,
literal|"KEY_COPY"
argument_list|,
name|KEY_COPY
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_CREATE
name|keydef
argument_list|(
literal|"Key_Create"
argument_list|,
literal|"KEY_CREATE"
argument_list|,
name|KEY_CREATE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_END
name|keydef
argument_list|(
literal|"Key_End"
argument_list|,
literal|"KEY_END"
argument_list|,
name|KEY_END
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_EXIT
name|keydef
argument_list|(
literal|"Key_Exit"
argument_list|,
literal|"KEY_EXIT"
argument_list|,
name|KEY_EXIT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_FIND
name|keydef
argument_list|(
literal|"Key_Find"
argument_list|,
literal|"KEY_FIND"
argument_list|,
name|KEY_FIND
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_HELP
name|keydef
argument_list|(
literal|"Key_Help"
argument_list|,
literal|"KEY_HELP"
argument_list|,
name|KEY_HELP
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_MARK
name|keydef
argument_list|(
literal|"Key_Mark"
argument_list|,
literal|"KEY_MARK"
argument_list|,
name|KEY_MARK
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_MESSAGE
name|keydef
argument_list|(
literal|"Key_Message"
argument_list|,
literal|"KEY_MESSAGE"
argument_list|,
name|KEY_MESSAGE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_MOVE
name|keydef
argument_list|(
literal|"Key_Move"
argument_list|,
literal|"KEY_MOVE"
argument_list|,
name|KEY_MOVE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_NEXT
name|keydef
argument_list|(
literal|"Key_Next"
argument_list|,
literal|"KEY_NEXT"
argument_list|,
name|KEY_NEXT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_OPEN
name|keydef
argument_list|(
literal|"Key_Open"
argument_list|,
literal|"KEY_OPEN"
argument_list|,
name|KEY_OPEN
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_OPTIONS
name|keydef
argument_list|(
literal|"Key_Options"
argument_list|,
literal|"KEY_OPTIONS"
argument_list|,
name|KEY_OPTIONS
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_PREVIOUS
name|keydef
argument_list|(
literal|"Key_Previous"
argument_list|,
literal|"KEY_PREVIOUS"
argument_list|,
name|KEY_PREVIOUS
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_REDO
name|keydef
argument_list|(
literal|"Key_Redo"
argument_list|,
literal|"KEY_REDO"
argument_list|,
name|KEY_REDO
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_REFERENCE
name|keydef
argument_list|(
literal|"Key_Reference"
argument_list|,
literal|"KEY_REFERENCE"
argument_list|,
name|KEY_REFERENCE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_REFRESH
name|keydef
argument_list|(
literal|"Key_Refresh"
argument_list|,
literal|"KEY_REFRESH"
argument_list|,
name|KEY_REFRESH
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_REPLACE
name|keydef
argument_list|(
literal|"Key_Replace"
argument_list|,
literal|"KEY_REPLACE"
argument_list|,
name|KEY_REPLACE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_RESTART
name|keydef
argument_list|(
literal|"Key_Restart"
argument_list|,
literal|"KEY_RESTART"
argument_list|,
name|KEY_RESTART
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_RESUME
name|keydef
argument_list|(
literal|"Key_Resume"
argument_list|,
literal|"KEY_RESUME"
argument_list|,
name|KEY_RESUME
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SAVE
name|keydef
argument_list|(
literal|"Key_Save"
argument_list|,
literal|"KEY_SAVE"
argument_list|,
name|KEY_SAVE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SBEG
name|keydef
argument_list|(
literal|"Key_Shift_Begin"
argument_list|,
literal|"KEY_SBEG"
argument_list|,
name|KEY_SBEG
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SCANCEL
name|keydef
argument_list|(
literal|"Key_Shift_Cancel"
argument_list|,
literal|"KEY_SCANCEL"
argument_list|,
name|KEY_SCANCEL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SCOMMAND
name|keydef
argument_list|(
literal|"Key_Shift_Command"
argument_list|,
literal|"KEY_SCOMMAND"
argument_list|,
name|KEY_SCOMMAND
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SCOPY
name|keydef
argument_list|(
literal|"Key_Shift_Copy"
argument_list|,
literal|"KEY_SCOPY"
argument_list|,
name|KEY_SCOPY
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SCREATE
name|keydef
argument_list|(
literal|"Key_Shift_Create"
argument_list|,
literal|"KEY_SCREATE"
argument_list|,
name|KEY_SCREATE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SDC
name|keydef
argument_list|(
literal|"Key_Shift_Delete_Char"
argument_list|,
literal|"KEY_SDC"
argument_list|,
name|KEY_SDC
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SDL
name|keydef
argument_list|(
literal|"Key_Shift_Delete_Line"
argument_list|,
literal|"KEY_SDL"
argument_list|,
name|KEY_SDL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SELECT
name|keydef
argument_list|(
literal|"Key_Select"
argument_list|,
literal|"KEY_SELECT"
argument_list|,
name|KEY_SELECT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SEND
name|keydef
argument_list|(
literal|"Key_Shift_End"
argument_list|,
literal|"KEY_SEND"
argument_list|,
name|KEY_SEND
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SEOL
name|keydef
argument_list|(
literal|"Key_Shift_Clear_End_Of_Line"
argument_list|,
literal|"KEY_SEOL"
argument_list|,
name|KEY_SEOL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SEXIT
name|keydef
argument_list|(
literal|"Key_Shift_Exit"
argument_list|,
literal|"KEY_SEXIT"
argument_list|,
name|KEY_SEXIT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SFIND
name|keydef
argument_list|(
literal|"Key_Shift_Find"
argument_list|,
literal|"KEY_SFIND"
argument_list|,
name|KEY_SFIND
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SHELP
name|keydef
argument_list|(
literal|"Key_Shift_Help"
argument_list|,
literal|"KEY_SHELP"
argument_list|,
name|KEY_SHELP
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SHOME
name|keydef
argument_list|(
literal|"Key_Shift_Home"
argument_list|,
literal|"KEY_SHOME"
argument_list|,
name|KEY_SHOME
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SIC
name|keydef
argument_list|(
literal|"Key_Shift_Insert_Char"
argument_list|,
literal|"KEY_SIC"
argument_list|,
name|KEY_SIC
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SLEFT
name|keydef
argument_list|(
literal|"Key_Shift_Cursor_Left"
argument_list|,
literal|"KEY_SLEFT"
argument_list|,
name|KEY_SLEFT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SMESSAGE
name|keydef
argument_list|(
literal|"Key_Shift_Message"
argument_list|,
literal|"KEY_SMESSAGE"
argument_list|,
name|KEY_SMESSAGE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SMOVE
name|keydef
argument_list|(
literal|"Key_Shift_Move"
argument_list|,
literal|"KEY_SMOVE"
argument_list|,
name|KEY_SMOVE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SNEXT
name|keydef
argument_list|(
literal|"Key_Shift_Next_Page"
argument_list|,
literal|"KEY_SNEXT"
argument_list|,
name|KEY_SNEXT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SOPTIONS
name|keydef
argument_list|(
literal|"Key_Shift_Options"
argument_list|,
literal|"KEY_SOPTIONS"
argument_list|,
name|KEY_SOPTIONS
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SPREVIOUS
name|keydef
argument_list|(
literal|"Key_Shift_Previous_Page"
argument_list|,
literal|"KEY_SPREVIOUS"
argument_list|,
name|KEY_SPREVIOUS
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SPRINT
name|keydef
argument_list|(
literal|"Key_Shift_Print"
argument_list|,
literal|"KEY_SPRINT"
argument_list|,
name|KEY_SPRINT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SREDO
name|keydef
argument_list|(
literal|"Key_Shift_Redo"
argument_list|,
literal|"KEY_SREDO"
argument_list|,
name|KEY_SREDO
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SREPLACE
name|keydef
argument_list|(
literal|"Key_Shift_Replace"
argument_list|,
literal|"KEY_SREPLACE"
argument_list|,
name|KEY_SREPLACE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SRIGHT
name|keydef
argument_list|(
literal|"Key_Shift_Cursor_Right"
argument_list|,
literal|"KEY_SRIGHT"
argument_list|,
name|KEY_SRIGHT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SRSUME
name|keydef
argument_list|(
literal|"Key_Shift_Resume"
argument_list|,
literal|"KEY_SRSUME"
argument_list|,
name|KEY_SRSUME
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SSAVE
name|keydef
argument_list|(
literal|"Key_Shift_Save"
argument_list|,
literal|"KEY_SSAVE"
argument_list|,
name|KEY_SSAVE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SSUSPEND
name|keydef
argument_list|(
literal|"Key_Shift_Suspend"
argument_list|,
literal|"KEY_SSUSPEND"
argument_list|,
name|KEY_SSUSPEND
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SUNDO
name|keydef
argument_list|(
literal|"Key_Shift_Undo"
argument_list|,
literal|"KEY_SUNDO"
argument_list|,
name|KEY_SUNDO
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_SUSPEND
name|keydef
argument_list|(
literal|"Key_Suspend"
argument_list|,
literal|"KEY_SUSPEND"
argument_list|,
name|KEY_SUSPEND
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_UNDO
name|keydef
argument_list|(
literal|"Key_Undo"
argument_list|,
literal|"KEY_UNDO"
argument_list|,
name|KEY_UNDO
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_MOUSE
name|keydef
argument_list|(
literal|"Key_Mouse"
argument_list|,
literal|"KEY_MOUSE"
argument_list|,
name|KEY_MOUSE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEY_RESIZE
name|keydef
argument_list|(
literal|"Key_Resize"
argument_list|,
literal|"KEY_RESIZE"
argument_list|,
name|KEY_RESIZE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Generate a constant with the given name. The second parameter  * is a reference to the ACS character in the acs_map[] array and  * will be translated into an index.  */
end_comment

begin_function
specifier|static
name|void
name|acs_def
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|chtype
modifier|*
name|a
parameter_list|)
block|{
name|int
name|c
init|=
call|(
name|int
call|)
argument_list|(
name|a
operator|-
operator|&
name|acs_map
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"   %-24s : constant Character := "
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|UChar
argument_list|(
name|c
argument_list|)
argument_list|)
operator|&&
operator|(
name|c
operator|!=
literal|'`'
operator|)
condition|)
name|printf
argument_list|(
literal|"'%c';\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Character'Val (%d);\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the constants for the ACS characters  */
end_comment

begin_function
specifier|static
name|void
name|gen_acs
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"   type C_ACS_Map is array (Character'Val (0) .. Character'Val (127))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        of Attributed_Character;\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_REENTRANT
operator|||
name|BROKEN_LINKER
name|printf
argument_list|(
literal|"   type C_ACS_Ptr is access C_ACS_Map;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   function ACS_Map return C_ACS_Ptr;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   pragma Import (C, ACS_Map, \""
name|NCURSES_WRAP_PREFIX
literal|"acs_map\");\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"   ACS_Map : C_ACS_Map;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   pragma Import (C, ACS_Map, \"acs_map\");\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"   --\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   --\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   --  Constants for several characters from the Alternate Character Set\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   --  You must use these constants as indices into the ACS_Map array\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   --  to get the corresponding attributed character at runtime.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   --\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACS_ULCORNER
name|acs_def
argument_list|(
literal|"ACS_Upper_Left_Corner"
argument_list|,
operator|&
name|ACS_ULCORNER
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_LLCORNER
name|acs_def
argument_list|(
literal|"ACS_Lower_Left_Corner"
argument_list|,
operator|&
name|ACS_LLCORNER
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_URCORNER
name|acs_def
argument_list|(
literal|"ACS_Upper_Right_Corner"
argument_list|,
operator|&
name|ACS_URCORNER
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_LRCORNER
name|acs_def
argument_list|(
literal|"ACS_Lower_Right_Corner"
argument_list|,
operator|&
name|ACS_LRCORNER
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_LTEE
name|acs_def
argument_list|(
literal|"ACS_Left_Tee"
argument_list|,
operator|&
name|ACS_LTEE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_RTEE
name|acs_def
argument_list|(
literal|"ACS_Right_Tee"
argument_list|,
operator|&
name|ACS_RTEE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_BTEE
name|acs_def
argument_list|(
literal|"ACS_Bottom_Tee"
argument_list|,
operator|&
name|ACS_BTEE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_TTEE
name|acs_def
argument_list|(
literal|"ACS_Top_Tee"
argument_list|,
operator|&
name|ACS_TTEE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_HLINE
name|acs_def
argument_list|(
literal|"ACS_Horizontal_Line"
argument_list|,
operator|&
name|ACS_HLINE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_VLINE
name|acs_def
argument_list|(
literal|"ACS_Vertical_Line"
argument_list|,
operator|&
name|ACS_VLINE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_PLUS
name|acs_def
argument_list|(
literal|"ACS_Plus_Symbol"
argument_list|,
operator|&
name|ACS_PLUS
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_S1
name|acs_def
argument_list|(
literal|"ACS_Scan_Line_1"
argument_list|,
operator|&
name|ACS_S1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_S9
name|acs_def
argument_list|(
literal|"ACS_Scan_Line_9"
argument_list|,
operator|&
name|ACS_S9
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_DIAMOND
name|acs_def
argument_list|(
literal|"ACS_Diamond"
argument_list|,
operator|&
name|ACS_DIAMOND
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_CKBOARD
name|acs_def
argument_list|(
literal|"ACS_Checker_Board"
argument_list|,
operator|&
name|ACS_CKBOARD
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_DEGREE
name|acs_def
argument_list|(
literal|"ACS_Degree"
argument_list|,
operator|&
name|ACS_DEGREE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_PLMINUS
name|acs_def
argument_list|(
literal|"ACS_Plus_Minus"
argument_list|,
operator|&
name|ACS_PLMINUS
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_BULLET
name|acs_def
argument_list|(
literal|"ACS_Bullet"
argument_list|,
operator|&
name|ACS_BULLET
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_LARROW
name|acs_def
argument_list|(
literal|"ACS_Left_Arrow"
argument_list|,
operator|&
name|ACS_LARROW
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_RARROW
name|acs_def
argument_list|(
literal|"ACS_Right_Arrow"
argument_list|,
operator|&
name|ACS_RARROW
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_DARROW
name|acs_def
argument_list|(
literal|"ACS_Down_Arrow"
argument_list|,
operator|&
name|ACS_DARROW
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_UARROW
name|acs_def
argument_list|(
literal|"ACS_Up_Arrow"
argument_list|,
operator|&
name|ACS_UARROW
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_BOARD
name|acs_def
argument_list|(
literal|"ACS_Board_Of_Squares"
argument_list|,
operator|&
name|ACS_BOARD
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_LANTERN
name|acs_def
argument_list|(
literal|"ACS_Lantern"
argument_list|,
operator|&
name|ACS_LANTERN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_BLOCK
name|acs_def
argument_list|(
literal|"ACS_Solid_Block"
argument_list|,
operator|&
name|ACS_BLOCK
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_S3
name|acs_def
argument_list|(
literal|"ACS_Scan_Line_3"
argument_list|,
operator|&
name|ACS_S3
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_S7
name|acs_def
argument_list|(
literal|"ACS_Scan_Line_7"
argument_list|,
operator|&
name|ACS_S7
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_LEQUAL
name|acs_def
argument_list|(
literal|"ACS_Less_Or_Equal"
argument_list|,
operator|&
name|ACS_LEQUAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_GEQUAL
name|acs_def
argument_list|(
literal|"ACS_Greater_Or_Equal"
argument_list|,
operator|&
name|ACS_GEQUAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_PI
name|acs_def
argument_list|(
literal|"ACS_PI"
argument_list|,
operator|&
name|ACS_PI
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_NEQUAL
name|acs_def
argument_list|(
literal|"ACS_Not_Equal"
argument_list|,
operator|&
name|ACS_NEQUAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ACS_STERLING
name|acs_def
argument_list|(
literal|"ACS_Sterling"
argument_list|,
operator|&
name|ACS_STERLING
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|GEN_EVENT
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
define|\
value|printf("   %-25s : constant Event_Mask := 8#%011lo#;\n", \           #name, value)
end_define

begin_define
define|#
directive|define
name|GEN_MEVENT
parameter_list|(
name|name
parameter_list|)
define|\
value|printf("   %-25s : constant Event_Mask := 8#%011lo#;\n", \           #name, name)
end_define

begin_function
specifier|static
name|void
name|gen_mouse_events
parameter_list|(
name|void
parameter_list|)
block|{
name|mmask_t
name|all1
init|=
literal|0
decl_stmt|;
name|mmask_t
name|all2
init|=
literal|0
decl_stmt|;
name|mmask_t
name|all3
init|=
literal|0
decl_stmt|;
name|mmask_t
name|all4
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|BUTTON1_RELEASED
name|GEN_MEVENT
argument_list|(
name|BUTTON1_RELEASED
argument_list|)
expr_stmt|;
name|all1
operator||=
name|BUTTON1_RELEASED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON1_PRESSED
name|GEN_MEVENT
argument_list|(
name|BUTTON1_PRESSED
argument_list|)
expr_stmt|;
name|all1
operator||=
name|BUTTON1_PRESSED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON1_CLICKED
name|GEN_MEVENT
argument_list|(
name|BUTTON1_CLICKED
argument_list|)
expr_stmt|;
name|all1
operator||=
name|BUTTON1_CLICKED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON1_DOUBLE_CLICKED
name|GEN_MEVENT
argument_list|(
name|BUTTON1_DOUBLE_CLICKED
argument_list|)
expr_stmt|;
name|all1
operator||=
name|BUTTON1_DOUBLE_CLICKED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON1_TRIPLE_CLICKED
name|GEN_MEVENT
argument_list|(
name|BUTTON1_TRIPLE_CLICKED
argument_list|)
expr_stmt|;
name|all1
operator||=
name|BUTTON1_TRIPLE_CLICKED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON1_RESERVED_EVENT
name|GEN_MEVENT
argument_list|(
name|BUTTON1_RESERVED_EVENT
argument_list|)
expr_stmt|;
name|all1
operator||=
name|BUTTON1_RESERVED_EVENT
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON2_RELEASED
name|GEN_MEVENT
argument_list|(
name|BUTTON2_RELEASED
argument_list|)
expr_stmt|;
name|all2
operator||=
name|BUTTON2_RELEASED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON2_PRESSED
name|GEN_MEVENT
argument_list|(
name|BUTTON2_PRESSED
argument_list|)
expr_stmt|;
name|all2
operator||=
name|BUTTON2_PRESSED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON2_CLICKED
name|GEN_MEVENT
argument_list|(
name|BUTTON2_CLICKED
argument_list|)
expr_stmt|;
name|all2
operator||=
name|BUTTON2_CLICKED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON2_DOUBLE_CLICKED
name|GEN_MEVENT
argument_list|(
name|BUTTON2_DOUBLE_CLICKED
argument_list|)
expr_stmt|;
name|all2
operator||=
name|BUTTON2_DOUBLE_CLICKED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON2_TRIPLE_CLICKED
name|GEN_MEVENT
argument_list|(
name|BUTTON2_TRIPLE_CLICKED
argument_list|)
expr_stmt|;
name|all2
operator||=
name|BUTTON2_TRIPLE_CLICKED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON2_RESERVED_EVENT
name|GEN_MEVENT
argument_list|(
name|BUTTON2_RESERVED_EVENT
argument_list|)
expr_stmt|;
name|all2
operator||=
name|BUTTON2_RESERVED_EVENT
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON3_RELEASED
name|GEN_MEVENT
argument_list|(
name|BUTTON3_RELEASED
argument_list|)
expr_stmt|;
name|all3
operator||=
name|BUTTON3_RELEASED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON3_PRESSED
name|GEN_MEVENT
argument_list|(
name|BUTTON3_PRESSED
argument_list|)
expr_stmt|;
name|all3
operator||=
name|BUTTON3_PRESSED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON3_CLICKED
name|GEN_MEVENT
argument_list|(
name|BUTTON3_CLICKED
argument_list|)
expr_stmt|;
name|all3
operator||=
name|BUTTON3_CLICKED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON3_DOUBLE_CLICKED
name|GEN_MEVENT
argument_list|(
name|BUTTON3_DOUBLE_CLICKED
argument_list|)
expr_stmt|;
name|all3
operator||=
name|BUTTON3_DOUBLE_CLICKED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON3_TRIPLE_CLICKED
name|GEN_MEVENT
argument_list|(
name|BUTTON3_TRIPLE_CLICKED
argument_list|)
expr_stmt|;
name|all3
operator||=
name|BUTTON3_TRIPLE_CLICKED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON3_RESERVED_EVENT
name|GEN_MEVENT
argument_list|(
name|BUTTON3_RESERVED_EVENT
argument_list|)
expr_stmt|;
name|all3
operator||=
name|BUTTON3_RESERVED_EVENT
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON4_RELEASED
name|GEN_MEVENT
argument_list|(
name|BUTTON4_RELEASED
argument_list|)
expr_stmt|;
name|all4
operator||=
name|BUTTON4_RELEASED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON4_PRESSED
name|GEN_MEVENT
argument_list|(
name|BUTTON4_PRESSED
argument_list|)
expr_stmt|;
name|all4
operator||=
name|BUTTON4_PRESSED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON4_CLICKED
name|GEN_MEVENT
argument_list|(
name|BUTTON4_CLICKED
argument_list|)
expr_stmt|;
name|all4
operator||=
name|BUTTON4_CLICKED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON4_DOUBLE_CLICKED
name|GEN_MEVENT
argument_list|(
name|BUTTON4_DOUBLE_CLICKED
argument_list|)
expr_stmt|;
name|all4
operator||=
name|BUTTON4_DOUBLE_CLICKED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON4_TRIPLE_CLICKED
name|GEN_MEVENT
argument_list|(
name|BUTTON4_TRIPLE_CLICKED
argument_list|)
expr_stmt|;
name|all4
operator||=
name|BUTTON4_TRIPLE_CLICKED
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON4_RESERVED_EVENT
name|GEN_MEVENT
argument_list|(
name|BUTTON4_RESERVED_EVENT
argument_list|)
expr_stmt|;
name|all4
operator||=
name|BUTTON4_RESERVED_EVENT
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON_CTRL
name|GEN_MEVENT
argument_list|(
name|BUTTON_CTRL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON_SHIFT
name|GEN_MEVENT
argument_list|(
name|BUTTON_SHIFT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUTTON_ALT
name|GEN_MEVENT
argument_list|(
name|BUTTON_ALT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REPORT_MOUSE_POSITION
name|GEN_MEVENT
argument_list|(
name|REPORT_MOUSE_POSITION
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALL_MOUSE_EVENTS
name|GEN_MEVENT
argument_list|(
name|ALL_MOUSE_EVENTS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|GEN_EVENT
argument_list|(
name|BUTTON1_EVENTS
argument_list|,
name|all1
argument_list|)
expr_stmt|;
name|GEN_EVENT
argument_list|(
name|BUTTON2_EVENTS
argument_list|,
name|all2
argument_list|)
expr_stmt|;
name|GEN_EVENT
argument_list|(
name|BUTTON3_EVENTS
argument_list|,
name|all3
argument_list|)
expr_stmt|;
name|GEN_EVENT
argument_list|(
name|BUTTON4_EVENTS
argument_list|,
name|all4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wrap_one_var
parameter_list|(
specifier|const
name|char
modifier|*
name|c_var
parameter_list|,
specifier|const
name|char
modifier|*
name|c_type
parameter_list|,
specifier|const
name|char
modifier|*
name|ada_func
parameter_list|,
specifier|const
name|char
modifier|*
name|ada_type
parameter_list|)
block|{
if|#
directive|if
name|USE_REENTRANT
comment|/* must wrap variables */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   function %s return %s\n"
argument_list|,
name|ada_func
argument_list|,
name|ada_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   is\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      function Result return %s;\n"
argument_list|,
name|c_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      pragma Import (C, Result, \""
name|NCURSES_WRAP_PREFIX
literal|"%s\");\n"
argument_list|,
name|c_var
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   begin\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|c_type
argument_list|,
name|ada_type
argument_list|)
condition|)
name|printf
argument_list|(
literal|"      return %s (Result);\n"
argument_list|,
name|ada_type
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"      return Result;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   end %s;\n"
argument_list|,
name|ada_func
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* global variables are really global */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   function %s return %s\n"
argument_list|,
name|ada_func
argument_list|,
name|ada_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   is\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Result : %s;\n"
argument_list|,
name|c_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      pragma Import (C, Result, \"%s\");\n"
argument_list|,
name|c_var
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   begin\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|c_type
argument_list|,
name|ada_type
argument_list|)
condition|)
name|printf
argument_list|(
literal|"      return %s (Result);\n"
argument_list|,
name|ada_type
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"      return Result;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   end %s;\n"
argument_list|,
name|ada_func
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|GEN_PUBLIC_VAR
parameter_list|(
name|c_var
parameter_list|,
name|c_type
parameter_list|,
name|ada_func
parameter_list|,
name|ada_type
parameter_list|)
define|\
value|wrap_one_var(#c_var, #c_type, #ada_func, #ada_type)
end_define

begin_function
specifier|static
name|void
name|gen_public_vars
parameter_list|(
name|void
parameter_list|)
block|{
name|GEN_PUBLIC_VAR
argument_list|(
name|stdscr
argument_list|,
name|Window
argument_list|,
name|Standard_Window
argument_list|,
name|Window
argument_list|)
expr_stmt|;
name|GEN_PUBLIC_VAR
argument_list|(
name|curscr
argument_list|,
name|Window
argument_list|,
name|Current_Window
argument_list|,
name|Window
argument_list|)
expr_stmt|;
name|GEN_PUBLIC_VAR
argument_list|(
name|LINES
argument_list|,
name|C_Int
argument_list|,
name|Lines
argument_list|,
name|Line_Count
argument_list|)
expr_stmt|;
name|GEN_PUBLIC_VAR
argument_list|(
name|COLS
argument_list|,
name|C_Int
argument_list|,
name|Columns
argument_list|,
name|Column_Count
argument_list|)
expr_stmt|;
name|GEN_PUBLIC_VAR
argument_list|(
name|TABSIZE
argument_list|,
name|C_Int
argument_list|,
name|Tab_Size
argument_list|,
name|Natural
argument_list|)
expr_stmt|;
name|GEN_PUBLIC_VAR
argument_list|(
name|COLORS
argument_list|,
name|C_Int
argument_list|,
name|Number_Of_Colors
argument_list|,
name|Natural
argument_list|)
expr_stmt|;
name|GEN_PUBLIC_VAR
argument_list|(
name|COLOR_PAIRS
argument_list|,
name|C_Int
argument_list|,
name|Number_Of_Color_Pairs
argument_list|,
name|Natural
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Output some comment lines indicating that the file is generated.  * The name parameter is the name of the facility to be used in  * the comment.  */
end_comment

begin_function
specifier|static
name|void
name|prologue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|printf
argument_list|(
literal|"--  %s binding.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--  This module is generated. Please don't change it manually!\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--  Run the generator instead.\n--  |"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"define(`M4_BIT_ORDER',`%s_Order_First')"
argument_list|,
name|little_endian
condition|?
literal|"Low"
else|:
literal|"High"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the prologue for the curses facility and make sure that  * KEY_MIN and KEY_MAX are defined for the rest of this source.  */
end_comment

begin_function
specifier|static
name|void
name|basedefs
parameter_list|(
name|void
parameter_list|)
block|{
name|prologue
argument_list|(
literal|"curses"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|KEY_MAX
define|#
directive|define
name|KEY_MAX
value|0777
endif|#
directive|endif
name|printf
argument_list|(
literal|"define(`M4_KEY_MAX',`8#%o#')"
argument_list|,
name|KEY_MAX
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|KEY_MIN
define|#
directive|define
name|KEY_MIN
value|0401
endif|#
directive|endif
if|if
condition|(
name|KEY_MIN
operator|==
literal|256
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unexpected value for KEY_MIN: %d\n"
argument_list|,
name|KEY_MIN
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"define(`M4_SPECIAL_FIRST',`8#%o#')"
argument_list|,
name|KEY_MIN
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write out the comment lines for the menu facility  */
end_comment

begin_function
specifier|static
name|void
name|menu_basedefs
parameter_list|(
name|void
parameter_list|)
block|{
name|prologue
argument_list|(
literal|"menu"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write out the comment lines for the form facility  */
end_comment

begin_function
specifier|static
name|void
name|form_basedefs
parameter_list|(
name|void
parameter_list|)
block|{
name|prologue
argument_list|(
literal|"form"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write out the comment lines for the mouse facility  */
end_comment

begin_function
specifier|static
name|void
name|mouse_basedefs
parameter_list|(
name|void
parameter_list|)
block|{
name|prologue
argument_list|(
literal|"mouse"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the definition of a single color  */
end_comment

begin_function
specifier|static
name|void
name|color_def
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|printf
argument_list|(
literal|"   %-16s : constant Color_Number := %d;\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate all color definitions  */
end_comment

begin_function
specifier|static
name|void
name|gen_color
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|HAVE_USE_DEFAULT_COLORS
name|color_def
argument_list|(
literal|"Default_Color"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COLOR_BLACK
name|color_def
argument_list|(
literal|"Black"
argument_list|,
name|COLOR_BLACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COLOR_RED
name|color_def
argument_list|(
literal|"Red"
argument_list|,
name|COLOR_RED
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COLOR_GREEN
name|color_def
argument_list|(
literal|"Green"
argument_list|,
name|COLOR_GREEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COLOR_YELLOW
name|color_def
argument_list|(
literal|"Yellow"
argument_list|,
name|COLOR_YELLOW
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COLOR_BLUE
name|color_def
argument_list|(
literal|"Blue"
argument_list|,
name|COLOR_BLUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COLOR_MAGENTA
name|color_def
argument_list|(
literal|"Magenta"
argument_list|,
name|COLOR_MAGENTA
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COLOR_CYAN
name|color_def
argument_list|(
literal|"Cyan"
argument_list|,
name|COLOR_CYAN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COLOR_WHITE
name|color_def
argument_list|(
literal|"White"
argument_list|,
name|COLOR_WHITE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Generate the linker options for the base facility  */
end_comment

begin_function
specifier|static
name|void
name|gen_linkopts
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"   pragma Linker_Options (\"-lncurses%s\");\n"
argument_list|,
name|model
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the linker options for the menu facility  */
end_comment

begin_function
specifier|static
name|void
name|gen_menu_linkopts
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"   pragma Linker_Options (\"-lmenu%s\");\n"
argument_list|,
name|model
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the linker options for the form facility  */
end_comment

begin_function
specifier|static
name|void
name|gen_form_linkopts
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"   pragma Linker_Options (\"-lform%s\");\n"
argument_list|,
name|model
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the linker options for the panel facility  */
end_comment

begin_function
specifier|static
name|void
name|gen_panel_linkopts
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"   pragma Linker_Options (\"-lpanel%s\");\n"
argument_list|,
name|model
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_version_info
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|v1
init|=
literal|"   NC_Major_Version : constant := %d; --  Major version of the library\n"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|v2
init|=
literal|"   NC_Minor_Version : constant := %d; --  Minor version of the library\n"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|v3
init|=
literal|"   NC_Version : constant String := %c%d.%d%c;  --  Version of library\n"
decl_stmt|;
name|printf
argument_list|(
name|v1
argument_list|,
name|NCURSES_VERSION_MAJOR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|v2
argument_list|,
name|NCURSES_VERSION_MINOR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|v3
argument_list|,
literal|'"'
argument_list|,
name|NCURSES_VERSION_MAJOR
argument_list|,
name|NCURSES_VERSION_MINOR
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|eti_gen
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|etimin
parameter_list|,
name|int
modifier|*
name|etimax
parameter_list|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"   E_%-16s : constant Eti_Error := %d;\n"
argument_list|,
name|name
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
operator|*
name|etimin
condition|)
operator|*
name|etimin
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|code
operator|>
operator|*
name|etimax
condition|)
operator|*
name|etimax
operator|=
name|code
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_offsets
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s_bool
init|=
literal|""
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
block|{
name|s_bool
operator|=
literal|"char"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
condition|)
block|{
name|s_bool
operator|=
literal|"short"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|s_bool
operator|=
literal|"int"
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"   Sizeof%-*s : constant Natural := %2ld; --  %s\n"
argument_list|,
literal|12
argument_list|,
literal|"_bool"
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|,
literal|"bool"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   type Curses_Bool is mod 2 ** Interfaces.C.%s'Size;\n"
argument_list|,
name|s_bool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * main() expects two arguments on the commandline, both single characters.  * The first character denotes the facility for which we generate output.  * Possible values are  *   B - Base  *   M - Menus  *   F - Forms  *   P - Pointer Device (Mouse)  *   E - ETI base definitions  *  * The second character then denotes the specific output that should be  * generated for the selected facility.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|x
init|=
literal|0x12345678
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|x
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0x78
condition|)
name|little_endian
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|model
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
condition|)
block|{
comment|/* --------------------------------------------------------------- */
case|case
literal|'B'
case|:
comment|/* The Base facility */
switch|switch
condition|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* chtype translation into Ada95 record type */
name|gen_attr_set
argument_list|(
literal|"Character_Attribute_Set"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* write some initial comment lines */
name|basedefs
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* generate color constants */
name|gen_color
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* generate displacements of fields in WINDOW struct. */
name|gen_offsets
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* generate Mouse Event codes */
name|gen_mouse_events
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
comment|/* translation of keycodes */
name|gen_keydefs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* generate the Linker_Options pragma */
name|gen_linkopts
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* generate constants for the ACS characters */
name|gen_acs
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* generate definitions of the old key code names */
name|gen_keydefs
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* generate definitions of the public variables */
name|gen_public_vars
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* generate representation clause for Attributed character */
name|gen_chtype_rep
argument_list|(
literal|"Attributed_Character"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* generate the Trace info */
name|gen_trace
argument_list|(
literal|"Trace_Attribute_Set"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* generate version info */
name|gen_version_info
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
comment|/* --------------------------------------------------------------- */
case|case
literal|'M'
case|:
comment|/* The Menu facility */
switch|switch
condition|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'R'
case|:
comment|/* generate representation clause for Menu_Option_Set */
name|gen_menu_opt_rep
argument_list|(
literal|"Menu_Option_Set"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* write some initial comment lines */
name|menu_basedefs
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* generate the Linker_Options pragma */
name|gen_menu_linkopts
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* generate representation clause for Item_Option_Set */
name|gen_item_opt_rep
argument_list|(
literal|"Item_Option_Set"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
comment|/* --------------------------------------------------------------- */
case|case
literal|'F'
case|:
comment|/* The Form facility */
switch|switch
condition|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'R'
case|:
comment|/* generate representation clause for Form_Option_Set */
name|gen_form_opt_rep
argument_list|(
literal|"Form_Option_Set"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* write some initial comment lines */
name|form_basedefs
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* generate the Linker_Options pragma */
name|gen_form_linkopts
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* generate representation clause for Field_Option_Set */
name|gen_field_opt_rep
argument_list|(
literal|"Field_Option_Set"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
comment|/* --------------------------------------------------------------- */
case|case
literal|'P'
case|:
comment|/* The Pointer(=Mouse) facility */
switch|switch
condition|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'B'
case|:
comment|/* write some initial comment lines */
name|mouse_basedefs
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* generate representation clause for Mouse_Event */
name|gen_mrep_rep
argument_list|(
literal|"Mouse_Event"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* generate the Linker_Options pragma */
name|gen_panel_linkopts
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
comment|/* --------------------------------------------------------------- */
case|case
literal|'E'
case|:
comment|/* chtype size detection */
switch|switch
condition|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'C'
case|:
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
literal|"   type    C_Chtype   is new %s;\n"
decl_stmt|;
specifier|const
name|char
modifier|*
name|afmt
init|=
literal|"   type    C_AttrType is new %s;\n"
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|chtype
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|printf
argument_list|(
name|fmt
argument_list|,
literal|"C_ULong"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|fmt
argument_list|,
literal|"C_UInt"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|chtype
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|fmt
argument_list|,
literal|"C_ULong"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|attr_t
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|printf
argument_list|(
name|afmt
argument_list|,
literal|"C_ULong"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|afmt
argument_list|,
literal|"C_UInt"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|attr_t
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|afmt
argument_list|,
literal|"C_ULong"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Error\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"define(`CF_CURSES_OK',`%d')"
argument_list|,
name|OK
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"define(`CF_CURSES_ERR',`%d')"
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"define(`CF_CURSES_TRUE',`%d')"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"define(`CF_CURSES_FALSE',`%d')"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'E'
case|:
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|2048
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|int
name|etimin
init|=
name|E_OK
decl_stmt|;
name|int
name|etimax
init|=
name|E_OK
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_OK
argument_list|,
literal|"Ok"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_SYSTEM_ERROR
argument_list|,
literal|"System_Error"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_BAD_ARGUMENT
argument_list|,
literal|"Bad_Argument"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_POSTED
argument_list|,
literal|"Posted"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_CONNECTED
argument_list|,
literal|"Connected"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_BAD_STATE
argument_list|,
literal|"Bad_State"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_NO_ROOM
argument_list|,
literal|"No_Room"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_NOT_POSTED
argument_list|,
literal|"Not_Posted"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_UNKNOWN_COMMAND
argument_list|,
literal|"Unknown_Command"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_NO_MATCH
argument_list|,
literal|"No_Match"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_NOT_SELECTABLE
argument_list|,
literal|"Not_Selectable"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_NOT_CONNECTED
argument_list|,
literal|"Not_Connected"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_REQUEST_DENIED
argument_list|,
literal|"Request_Denied"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_INVALID_FIELD
argument_list|,
literal|"Invalid_Field"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
name|p
operator|+=
name|eti_gen
argument_list|(
name|p
argument_list|,
name|E_CURRENT
argument_list|,
literal|"Current"
argument_list|,
operator|&
name|etimin
argument_list|,
operator|&
name|etimax
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"   subtype Eti_Error is C_Int range %d .. %d;\n\n"
argument_list|,
name|etimin
argument_list|,
name|etimax
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
comment|/* --------------------------------------------------------------- */
case|case
literal|'V'
case|:
comment|/* plain version dump */
block|{
switch|switch
condition|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'1'
case|:
comment|/* major version */
ifdef|#
directive|ifdef
name|NCURSES_VERSION_MAJOR
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|NCURSES_VERSION_MAJOR
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'2'
case|:
comment|/* minor version */
ifdef|#
directive|ifdef
name|NCURSES_VERSION_MINOR
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|NCURSES_VERSION_MINOR
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'3'
case|:
comment|/* patch level */
ifdef|#
directive|ifdef
name|NCURSES_VERSION_PATCH
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|NCURSES_VERSION_PATCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
break|break;
block|}
block|}
break|break;
comment|/* --------------------------------------------------------------- */
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

