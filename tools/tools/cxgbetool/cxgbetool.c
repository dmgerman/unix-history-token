begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|"t4_ioctl.h"
end_include

begin_define
define|#
directive|define
name|ARRAY_SIZE
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a) / sizeof((a)[0]))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|progname
decl_stmt|,
modifier|*
name|nexus
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|reg_info
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mod_regs
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|reg_info
modifier|*
name|ri
decl_stmt|;
block|}
struct|;
end_struct

begin_include
include|#
directive|include
file|"reg_defs_t4.c"
end_include

begin_include
include|#
directive|include
file|"reg_defs_t4vf.c"
end_include

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Usage: %s<nexus> [operation]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tfilter<idx> [<param><val>] ...    set a filter\n"
literal|"\tfilter<idx> delete|clear           delete a filter\n"
literal|"\tfilter list                         list all filters\n"
literal|"\tfilter mode [<match>] ...           get/set global filter mode\n"
literal|"\treg<address>[=<val>]               read/write register\n"
literal|"\treg64<address>[=<val>]             read/write 64 bit register\n"
literal|"\tregdump [<module>] ...              dump registers\n"
literal|"\tstdio                               interactive mode\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|get_card_vers
parameter_list|(
name|unsigned
name|int
name|version
parameter_list|)
block|{
return|return
operator|(
name|version
operator|&
literal|0x3ff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|real_doit
parameter_list|(
name|unsigned
name|long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|cmdstr
parameter_list|)
block|{
specifier|static
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"/dev/%s"
argument_list|,
name|nexus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"open(%s)"
argument_list|,
name|nexus
argument_list|)
expr_stmt|;
name|rc
operator|=
name|errno
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
name|rc
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|cmdstr
argument_list|)
expr_stmt|;
name|rc
operator|=
name|errno
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|doit
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|real_doit(x, y, #x)
end_define

begin_function
specifier|static
name|char
modifier|*
name|str_to_number
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|long
modifier|*
name|val
parameter_list|,
name|long
name|long
modifier|*
name|vall
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|vall
condition|)
operator|*
name|vall
operator|=
name|strtoll
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
condition|)
operator|*
name|val
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_reg
parameter_list|(
name|long
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|long
name|long
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|t4_reg
name|reg
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|reg
operator|.
name|addr
operator|=
operator|(
name|uint32_t
operator|)
name|addr
expr_stmt|;
name|reg
operator|.
name|size
operator|=
operator|(
name|uint32_t
operator|)
name|size
expr_stmt|;
name|reg
operator|.
name|val
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|doit
argument_list|(
name|CHELSIO_T4_GETREG
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|reg
operator|.
name|val
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_reg
parameter_list|(
name|long
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|long
name|long
name|val
parameter_list|)
block|{
name|struct
name|t4_reg
name|reg
decl_stmt|;
name|reg
operator|.
name|addr
operator|=
operator|(
name|uint32_t
operator|)
name|addr
expr_stmt|;
name|reg
operator|.
name|size
operator|=
operator|(
name|uint32_t
operator|)
name|size
expr_stmt|;
name|reg
operator|.
name|val
operator|=
operator|(
name|uint64_t
operator|)
name|val
expr_stmt|;
return|return
name|doit
argument_list|(
name|CHELSIO_T4_SETREG
argument_list|,
operator|&
name|reg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|register_io
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|long
name|addr
decl_stmt|;
name|long
name|long
name|val
decl_stmt|;
name|int
name|w
init|=
literal|0
decl_stmt|,
name|rc
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
comment|/*<reg> OR<reg>=<value> */
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'='
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid register \"%s\""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|w
operator|=
literal|1
expr_stmt|;
name|v
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|str_to_number
argument_list|(
name|v
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid value \"%s\""
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
comment|/*<reg><value> */
name|w
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid register \"%s\""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid value \"%s\""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"reg: invalid number of arguments (%d)"
argument_list|,
name|argc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|w
condition|)
name|rc
operator|=
name|write_reg
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|read_reg
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"0x%llx [%llu]\n"
argument_list|,
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|xtract
parameter_list|(
name|uint32_t
name|val
parameter_list|,
name|int
name|shift
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
operator|(
name|val
operator|>>
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|len
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_block_regs
parameter_list|(
specifier|const
name|struct
name|reg_info
modifier|*
name|reg_array
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|regs
parameter_list|)
block|{
name|uint32_t
name|reg_val
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|reg_array
operator|->
name|name
condition|;
operator|++
name|reg_array
control|)
if|if
condition|(
operator|!
name|reg_array
operator|->
name|len
condition|)
block|{
name|reg_val
operator|=
name|regs
index|[
name|reg_array
operator|->
name|addr
operator|/
literal|4
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"[%#7x] %-47s %#-10x %u\n"
argument_list|,
name|reg_array
operator|->
name|addr
argument_list|,
name|reg_array
operator|->
name|name
argument_list|,
name|reg_val
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|v
init|=
name|xtract
argument_list|(
name|reg_val
argument_list|,
name|reg_array
operator|->
name|addr
argument_list|,
name|reg_array
operator|->
name|len
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"    %*u:%u %-47s %#-10x %u\n"
argument_list|,
name|reg_array
operator|->
name|addr
operator|<
literal|10
condition|?
literal|3
else|:
literal|2
argument_list|,
name|reg_array
operator|->
name|addr
operator|+
name|reg_array
operator|->
name|len
operator|-
literal|1
argument_list|,
name|reg_array
operator|->
name|addr
argument_list|,
name|reg_array
operator|->
name|name
argument_list|,
name|v
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_regs_table
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|regs
parameter_list|,
specifier|const
name|struct
name|mod_regs
modifier|*
name|modtab
parameter_list|,
name|int
name|nmodules
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|match
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nmodules
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|modtab
index|[
name|j
index|]
operator|.
name|name
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|nmodules
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid register block \"%s\""
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nAvailable blocks:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|nmodules
condition|;
name|nmodules
operator|--
operator|,
name|modtab
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|modtab
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
for|for
control|(
init|;
name|nmodules
condition|;
name|nmodules
operator|--
operator|,
name|modtab
operator|++
control|)
block|{
name|match
operator|=
name|argc
operator|==
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|match
operator|&&
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|modtab
operator|->
name|name
argument_list|)
condition|)
name|match
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|match
condition|)
name|dump_block_regs
argument_list|(
name|modtab
operator|->
name|ri
argument_list|,
name|regs
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|T4_MODREGS
parameter_list|(
name|name
parameter_list|)
value|{ #name, t4_##name##_regs }
end_define

begin_function
specifier|static
name|int
name|dump_regs_t4
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|regs
parameter_list|)
block|{
specifier|static
name|struct
name|mod_regs
name|t4_mod
index|[]
init|=
block|{
name|T4_MODREGS
argument_list|(
name|sge
argument_list|)
block|,
block|{
literal|"pci"
block|,
name|t4_pcie_regs
block|}
block|,
name|T4_MODREGS
argument_list|(
name|dbg
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|mc
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|ma
argument_list|)
block|,
block|{
literal|"edc0"
block|,
name|t4_edc_0_regs
block|}
block|,
block|{
literal|"edc1"
block|,
name|t4_edc_1_regs
block|}
block|,
name|T4_MODREGS
argument_list|(
name|cim
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|tp
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|ulp_rx
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|ulp_tx
argument_list|)
block|,
block|{
literal|"pmrx"
block|,
name|t4_pm_rx_regs
block|}
block|,
block|{
literal|"pmtx"
block|,
name|t4_pm_tx_regs
block|}
block|,
name|T4_MODREGS
argument_list|(
name|mps
argument_list|)
block|,
block|{
literal|"cplsw"
block|,
name|t4_cpl_switch_regs
block|}
block|,
name|T4_MODREGS
argument_list|(
name|smb
argument_list|)
block|,
block|{
literal|"i2c"
block|,
name|t4_i2cm_regs
block|}
block|,
name|T4_MODREGS
argument_list|(
name|mi
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|uart
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|pmu
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|sf
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|pl
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|le
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|ncsi
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
argument|xgmac
argument_list|)
block|}
decl_stmt|;
return|return
name|dump_regs_table
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|regs
argument_list|,
name|t4_mod
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|t4_mod
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|T4_MODREGS
end_undef

begin_function
specifier|static
name|int
name|dump_regs_t4vf
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|regs
parameter_list|)
block|{
specifier|static
name|struct
name|mod_regs
name|t4vf_mod
index|[]
init|=
block|{
block|{
literal|"sge"
block|,
name|t4vf_sge_regs
block|}
block|,
block|{
literal|"mps"
block|,
name|t4vf_mps_regs
block|}
block|,
block|{
literal|"pl"
block|,
name|t4vf_pl_regs
block|}
block|,
block|{
literal|"mbdata"
block|,
name|t4vf_mbdata_regs
block|}
block|,
block|{
literal|"cim"
block|,
name|t4vf_cim_regs
block|}
block|, 	}
decl_stmt|;
return|return
name|dump_regs_table
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|regs
argument_list|,
name|t4vf_mod
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|t4vf_mod
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_regs
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|vers
decl_stmt|,
name|revision
decl_stmt|,
name|is_pcie
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|t4_regdump
name|regs
decl_stmt|;
name|regs
operator|.
name|data
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|T4_REGDUMP_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|data
operator|==
name|NULL
condition|)
block|{
name|warnc
argument_list|(
name|ENOMEM
argument_list|,
literal|"regdump"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|regs
operator|.
name|len
operator|=
name|T4_REGDUMP_SIZE
expr_stmt|;
name|rc
operator|=
name|doit
argument_list|(
name|CHELSIO_T4_REGDUMP
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|vers
operator|=
name|get_card_vers
argument_list|(
name|regs
operator|.
name|version
argument_list|)
expr_stmt|;
name|revision
operator|=
operator|(
name|regs
operator|.
name|version
operator|>>
literal|10
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|is_pcie
operator|=
operator|(
name|regs
operator|.
name|version
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|vers
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|revision
operator|==
literal|0x3f
condition|)
name|rc
operator|=
name|dump_regs_t4vf
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|regs
operator|.
name|data
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|dump_regs_t4
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|regs
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"%s (type %d, rev %d) is not a T4 card."
argument_list|,
name|nexus
argument_list|,
name|vers
argument_list|,
name|revision
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|free
argument_list|(
name|regs
operator|.
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_show_info_header
parameter_list|(
name|uint32_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"%4s %8s"
argument_list|,
literal|"Idx"
argument_list|,
literal|"Hits"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|T4_FILTER_FCoE
init|;
name|i
operator|<=
name|T4_FILTER_IP_FRAGMENT
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
switch|switch
condition|(
name|mode
operator|&
name|i
condition|)
block|{
case|case
name|T4_FILTER_FCoE
case|:
name|printf
argument_list|(
literal|" FCoE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_PORT
case|:
name|printf
argument_list|(
literal|" Port"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_OVLAN
case|:
name|printf
argument_list|(
literal|"     vld:oVLAN"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_IVLAN
case|:
name|printf
argument_list|(
literal|"     vld:iVLAN"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_IP_TOS
case|:
name|printf
argument_list|(
literal|"   TOS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_IP_PROTO
case|:
name|printf
argument_list|(
literal|"  Prot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_ETH_TYPE
case|:
name|printf
argument_list|(
literal|"   EthType"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_MAC_IDX
case|:
name|printf
argument_list|(
literal|"  MACIdx"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_MPS_HIT_TYPE
case|:
name|printf
argument_list|(
literal|" MPS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_IP_FRAGMENT
case|:
name|printf
argument_list|(
literal|" Frag"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* compressed filter field not enabled */
break|break;
block|}
block|}
name|printf
argument_list|(
literal|" %20s %20s %9s %9s %s\n"
argument_list|,
literal|"DIP"
argument_list|,
literal|"SIP"
argument_list|,
literal|"DPORT"
argument_list|,
literal|"SPORT"
argument_list|,
literal|"Action"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse an argument sub-vector as a {<parameter name><value>[:<mask>] }  * ordered tuple.  If the parameter name in the argument sub-vector does not  * match the passed in parameter name, then a zero is returned for the  * function and no parsing is performed.  If there is a match, then the value  * and optional mask are parsed and returned in the provided return value  * pointers.  If no optional mask is specified, then a default mask of all 1s  * will be returned.  *  * An error in parsing the value[:mask] will result in an error message and  * program termination.  */
end_comment

begin_function
specifier|static
name|int
name|parse_val_mask
parameter_list|(
specifier|const
name|char
modifier|*
name|param
parameter_list|,
specifier|const
name|char
modifier|*
name|args
index|[]
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|,
name|uint32_t
modifier|*
name|mask
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|param
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|val
operator|=
name|strtoul
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|args
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
operator|*
name|mask
operator|=
operator|~
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
operator|*
name|mask
operator|=
name|strtoul
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|warnx
argument_list|(
literal|"parameter \"%s\" has bad \"value[:mask]\" %s"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse an argument sub-vector as a {<parameter name><addr>[/<mask>] }  * ordered tuple.  If the parameter name in the argument sub-vector does not  * match the passed in parameter name, then a zero is returned for the  * function and no parsing is performed.  If there is a match, then the value  * and optional mask are parsed and returned in the provided return value  * pointers.  If no optional mask is specified, then a default mask of all 1s  * will be returned.  *  * The value return parameter "afp" is used to specify the expected address  * family -- IPv4 or IPv6 -- of the address[/mask] and return its actual  * format.  A passed in value of AF_UNSPEC indicates that either IPv4 or IPv6  * is acceptable; AF_INET means that only IPv4 addresses are acceptable; and  * AF_INET6 means that only IPv6 are acceptable.  AF_INET is returned for IPv4  * and AF_INET6 for IPv6 addresses, respectively.  IPv4 address/mask pairs are  * returned in the first four bytes of the address and mask return values with  * the address A.B.C.D returned with { A, B, C, D } returned in addresses { 0,  * 1, 2, 3}, respectively.  *  * An error in parsing the value[:mask] will result in an error message and  * program termination.  */
end_comment

begin_function
specifier|static
name|int
name|parse_ipaddr
parameter_list|(
specifier|const
name|char
modifier|*
name|param
parameter_list|,
specifier|const
name|char
modifier|*
name|args
index|[]
parameter_list|,
name|int
modifier|*
name|afp
parameter_list|,
name|uint8_t
name|addr
index|[]
parameter_list|,
name|uint8_t
name|mask
index|[]
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|afn
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|;
name|uint8_t
modifier|*
name|m
decl_stmt|;
name|int
name|af
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|int
name|masksize
decl_stmt|;
comment|/* 	 * Is this our parameter? 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|param
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Fundamental IPv4 versus IPv6 selection. 	 */
name|colon
operator|=
name|strchr
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|colon
condition|)
block|{
name|afn
operator|=
literal|"IPv4"
expr_stmt|;
name|af
operator|=
name|AF_INET
expr_stmt|;
name|masksize
operator|=
literal|32
expr_stmt|;
block|}
else|else
block|{
name|afn
operator|=
literal|"IPv6"
expr_stmt|;
name|af
operator|=
name|AF_INET6
expr_stmt|;
name|masksize
operator|=
literal|128
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|afp
operator|==
name|AF_UNSPEC
condition|)
operator|*
name|afp
operator|=
name|af
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|afp
operator|!=
name|af
condition|)
block|{
name|warnx
argument_list|(
literal|"address %s is not of expected family %s"
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
operator|*
name|afp
operator|==
name|AF_INET
condition|?
literal|"IP"
else|:
literal|"IPv6"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Parse address (temporarily stripping off any "/mask" 	 * specification). 	 */
name|slash
operator|=
name|strchr
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
operator|*
name|slash
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|inet_pton
argument_list|(
name|af
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Cannot parse %s %s address %s"
argument_list|,
name|param
argument_list|,
name|afn
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Parse optional mask specification. 	 */
if|if
condition|(
name|slash
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|prefix
init|=
name|strtoul
argument_list|(
name|slash
operator|+
literal|1
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|slash
operator|+
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"missing address prefix for %s"
argument_list|,
name|param
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|warnx
argument_list|(
literal|"%s is not a valid address prefix"
argument_list|,
name|slash
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|prefix
operator|>
name|masksize
condition|)
block|{
name|warnx
argument_list|(
literal|"prefix %u is too long for an %s address"
argument_list|,
name|prefix
argument_list|,
name|afn
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|memset
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|,
name|masksize
operator|/
literal|8
argument_list|)
expr_stmt|;
name|masksize
operator|=
name|prefix
expr_stmt|;
block|}
comment|/* 	 * Fill in mask. 	 */
for|for
control|(
name|m
operator|=
name|mask
init|;
name|masksize
operator|>=
literal|8
condition|;
name|m
operator|++
operator|,
name|masksize
operator|-=
literal|8
control|)
operator|*
name|m
operator|=
operator|~
literal|0
expr_stmt|;
if|if
condition|(
name|masksize
condition|)
operator|*
name|m
operator|=
operator|~
literal|0
operator|<<
operator|(
literal|8
operator|-
name|masksize
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse an argument sub-vector as a {<parameter name><value> } ordered  * tuple.  If the parameter name in the argument sub-vector does not match the  * passed in parameter name, then a zero is returned for the function and no  * parsing is performed.  If there is a match, then the value is parsed and  * returned in the provided return value pointer.  */
end_comment

begin_function
specifier|static
name|int
name|parse_val
parameter_list|(
specifier|const
name|char
modifier|*
name|param
parameter_list|,
specifier|const
name|char
modifier|*
name|args
index|[]
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|param
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|val
operator|=
name|strtoul
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|args
index|[
literal|1
index|]
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|warnx
argument_list|(
literal|"parameter \"%s\" has bad \"value\" %s"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filters_show_ipaddr
parameter_list|(
name|int
name|type
parameter_list|,
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint8_t
modifier|*
name|addrm
parameter_list|)
block|{
name|int
name|noctets
decl_stmt|,
name|octet
decl_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|noctets
operator|=
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|"%3s"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
name|noctets
operator|=
literal|16
expr_stmt|;
for|for
control|(
name|octet
operator|=
literal|0
init|;
name|octet
operator|<
name|noctets
condition|;
name|octet
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|addr
index|[
name|octet
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
for|for
control|(
name|octet
operator|=
literal|0
init|;
name|octet
operator|<
name|noctets
condition|;
name|octet
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|addrm
index|[
name|octet
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_show_one_filter_info
parameter_list|(
name|struct
name|t4_filter
modifier|*
name|t
parameter_list|,
name|uint32_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"%4d"
argument_list|,
name|t
operator|->
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|hits
operator|==
name|UINT64_MAX
condition|)
name|printf
argument_list|(
literal|" %8s"
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %8ju"
argument_list|,
name|t
operator|->
name|hits
argument_list|)
expr_stmt|;
comment|/* 	 * Compressed header portion of filter. 	 */
for|for
control|(
name|i
operator|=
name|T4_FILTER_FCoE
init|;
name|i
operator|<=
name|T4_FILTER_IP_FRAGMENT
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
switch|switch
condition|(
name|mode
operator|&
name|i
condition|)
block|{
case|case
name|T4_FILTER_FCoE
case|:
name|printf
argument_list|(
literal|"  %1d/%1d"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|fcoe
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|fcoe
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_PORT
case|:
name|printf
argument_list|(
literal|"  %1d/%1d"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|iport
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|iport
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_OVLAN
case|:
name|printf
argument_list|(
literal|" %1d:%1x:%02x/%1d:%1x:%02x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|ovlan_vld
argument_list|,
operator|(
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|ovlan
operator|>>
literal|7
operator|)
operator|&
literal|0x7
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|ovlan
operator|&
literal|0x7f
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|ovlan_vld
argument_list|,
operator|(
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|ovlan
operator|>>
literal|7
operator|)
operator|&
literal|0x7
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|ovlan
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_IVLAN
case|:
name|printf
argument_list|(
literal|" %1d:%04x/%1d:%04x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|ivlan_vld
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|ivlan
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|ivlan_vld
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|ivlan
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_IP_TOS
case|:
name|printf
argument_list|(
literal|" %02x/%02x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|tos
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|tos
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_IP_PROTO
case|:
name|printf
argument_list|(
literal|" %02x/%02x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|proto
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|proto
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_ETH_TYPE
case|:
name|printf
argument_list|(
literal|" %04x/%04x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|ethtype
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|ethtype
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_MAC_IDX
case|:
name|printf
argument_list|(
literal|" %03x/%03x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|macidx
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|macidx
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_MPS_HIT_TYPE
case|:
name|printf
argument_list|(
literal|" %1x/%1x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|matchtype
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|matchtype
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_IP_FRAGMENT
case|:
name|printf
argument_list|(
literal|"  %1d/%1d"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|frag
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|frag
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* compressed filter field not enabled */
break|break;
block|}
block|}
comment|/* 	 * Fixed portion of filter. 	 */
name|filters_show_ipaddr
argument_list|(
name|t
operator|->
name|fs
operator|.
name|type
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|dip
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|dip
argument_list|)
expr_stmt|;
name|filters_show_ipaddr
argument_list|(
name|t
operator|->
name|fs
operator|.
name|type
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|sip
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|sip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %04x/%04x %04x/%04x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|dport
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|dport
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|sport
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|sport
argument_list|)
expr_stmt|;
comment|/* 	 * Variable length filter action. 	 */
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|action
operator|==
name|FILTER_DROP
condition|)
name|printf
argument_list|(
literal|" Drop"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|action
operator|==
name|FILTER_SWITCH
condition|)
block|{
name|printf
argument_list|(
literal|" Switch: port=%d"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|eport
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|newdmac
condition|)
name|printf
argument_list|(
literal|", dmac=%02x:%02x:%02x:%02x:%02x:%02x "
literal|", l2tidx=%d"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|dmac
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|dmac
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|dmac
index|[
literal|2
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|dmac
index|[
literal|3
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|dmac
index|[
literal|4
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|dmac
index|[
literal|5
index|]
argument_list|,
name|t
operator|->
name|l2tidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|newsmac
condition|)
name|printf
argument_list|(
literal|", smac=%02x:%02x:%02x:%02x:%02x:%02x "
literal|", smtidx=%d"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|smac
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|smac
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|smac
index|[
literal|2
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|smac
index|[
literal|3
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|smac
index|[
literal|4
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|smac
index|[
literal|5
index|]
argument_list|,
name|t
operator|->
name|smtidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REMOVE
condition|)
name|printf
argument_list|(
literal|", vlan=none"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_INSERT
condition|)
name|printf
argument_list|(
literal|", vlan=insert(%x)"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|vlan
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REWRITE
condition|)
name|printf
argument_list|(
literal|", vlan=rewrite(%x)"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|vlan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" Pass: Q="
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|dirsteer
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"RSS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|maskhash
condition|)
name|printf
argument_list|(
literal|"(TCB=hash)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|iq
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|dirsteerhash
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"(QID)"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"(hash)"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|prio
condition|)
name|printf
argument_list|(
literal|" Prio"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|rpttid
condition|)
name|printf
argument_list|(
literal|" RptTID"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|show_filters
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|mode
init|=
literal|0
decl_stmt|,
name|header
init|=
literal|0
decl_stmt|;
name|struct
name|t4_filter
name|t
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Get the global filter mode first */
name|rc
operator|=
name|doit
argument_list|(
name|CHELSIO_T4_GET_FILTER_MODE
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|t
operator|.
name|idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|.
name|idx
operator|=
literal|0
init|;
condition|;
name|t
operator|.
name|idx
operator|++
control|)
block|{
name|rc
operator|=
name|doit
argument_list|(
name|CHELSIO_T4_GET_FILTER
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|t
operator|.
name|idx
operator|==
literal|0xffffffff
condition|)
break|break;
if|if
condition|(
operator|!
name|header
condition|)
block|{
name|do_show_info_header
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|header
operator|=
literal|1
expr_stmt|;
block|}
name|do_show_one_filter_info
argument_list|(
operator|&
name|t
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_filter_mode
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|mode
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|doit
argument_list|(
name|CHELSIO_T4_GET_FILTER_MODE
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IPv4
condition|)
name|printf
argument_list|(
literal|"ipv4 "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IPv6
condition|)
name|printf
argument_list|(
literal|"ipv6 "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_SADDR
condition|)
name|printf
argument_list|(
literal|"sip "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_DADDR
condition|)
name|printf
argument_list|(
literal|"dip "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_SPORT
condition|)
name|printf
argument_list|(
literal|"sport "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_DPORT
condition|)
name|printf
argument_list|(
literal|"dport "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_MPS_HIT_TYPE
condition|)
name|printf
argument_list|(
literal|"matchtype "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_MAC_IDX
condition|)
name|printf
argument_list|(
literal|"macidx "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_ETH_TYPE
condition|)
name|printf
argument_list|(
literal|"ethtype "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_PROTO
condition|)
name|printf
argument_list|(
literal|"proto "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_TOS
condition|)
name|printf
argument_list|(
literal|"tos "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IVLAN
condition|)
name|printf
argument_list|(
literal|"ivlan "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_OVLAN
condition|)
name|printf
argument_list|(
literal|"ovlan "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_PORT
condition|)
name|printf
argument_list|(
literal|"iport "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_FCoE
condition|)
name|printf
argument_list|(
literal|"fcoe "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter_mode
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|uint32_t
name|mode
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|argc
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"matchtype"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_MPS_HIT_TYPE
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"macidx"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_MAC_IDX
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"ethtype"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_ETH_TYPE
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"proto"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_IP_PROTO
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"tos"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_IP_TOS
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"ivlan"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_IVLAN
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"ovlan"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_OVLAN
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"iport"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_PORT
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"fcoe"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_FCoE
expr_stmt|;
block|}
return|return
name|doit
argument_list|(
name|CHELSIO_T4_SET_FILTER_MODE
argument_list|,
operator|&
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|del_filter
parameter_list|(
name|uint32_t
name|idx
parameter_list|)
block|{
name|struct
name|t4_filter
name|t
decl_stmt|;
name|t
operator|.
name|idx
operator|=
name|idx
expr_stmt|;
return|return
name|doit
argument_list|(
name|CHELSIO_T4_DEL_FILTER
argument_list|,
operator|&
name|t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter
parameter_list|(
name|uint32_t
name|idx
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|af
init|=
name|AF_UNSPEC
decl_stmt|,
name|start_arg
init|=
literal|0
decl_stmt|;
name|struct
name|t4_filter
name|t
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|warnc
argument_list|(
name|EINVAL
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
empty_stmt|;
name|bzero
argument_list|(
operator|&
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|idx
operator|=
name|idx
expr_stmt|;
for|for
control|(
name|start_arg
operator|=
literal|0
init|;
name|start_arg
operator|+
literal|2
operator|<=
name|argc
condition|;
name|start_arg
operator|+=
literal|2
control|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|args
init|=
operator|&
name|argv
index|[
name|start_arg
index|]
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|mask
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
index|]
argument_list|,
literal|"type"
argument_list|)
condition|)
block|{
name|int
name|newaf
decl_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|,
literal|"ipv4"
argument_list|)
condition|)
name|newaf
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|,
literal|"ipv6"
argument_list|)
condition|)
name|newaf
operator|=
name|AF_INET6
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"invalid type \"%s\"; "
literal|"must be one of \"ipv4\" or \"ipv6\""
argument_list|,
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|af
operator|!=
name|AF_UNSPEC
operator|&&
name|af
operator|!=
name|newaf
condition|)
block|{
name|warnx
argument_list|(
literal|"conflicting IPv4/IPv6 specifications."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|af
operator|=
name|newaf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"fcoe"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|fcoe
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|fcoe
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"iport"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|iport
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|iport
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"ovlan"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|ovlan
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|ovlan
operator|=
name|mask
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|ovlan_vld
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|ovlan_vld
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"ivlan"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|ivlan
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|ivlan
operator|=
name|mask
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|ivlan_vld
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|ivlan_vld
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"tos"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|tos
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|tos
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"proto"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|proto
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|proto
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"ethtype"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|ethtype
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|ethtype
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"macidx"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|macidx
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|macidx
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"matchtype"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|matchtype
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|matchtype
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"frag"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|frag
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|frag
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"dport"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|dport
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|dport
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"sport"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|sport
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|sport
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_ipaddr
argument_list|(
literal|"dip"
argument_list|,
name|args
argument_list|,
operator|&
name|af
argument_list|,
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|dip
argument_list|,
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|dip
argument_list|)
condition|)
block|{
comment|/* nada */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_ipaddr
argument_list|(
literal|"sip"
argument_list|,
name|args
argument_list|,
operator|&
name|af
argument_list|,
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|sip
argument_list|,
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|sip
argument_list|)
condition|)
block|{
comment|/* nada */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
index|]
argument_list|,
literal|"action"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|,
literal|"pass"
argument_list|)
condition|)
name|t
operator|.
name|fs
operator|.
name|action
operator|=
name|FILTER_PASS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|,
literal|"drop"
argument_list|)
condition|)
name|t
operator|.
name|fs
operator|.
name|action
operator|=
name|FILTER_DROP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|,
literal|"switch"
argument_list|)
condition|)
name|t
operator|.
name|fs
operator|.
name|action
operator|=
name|FILTER_SWITCH
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"invalid action \"%s\"; must be one of"
literal|" \"pass\", \"drop\" or \"switch\""
argument_list|,
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val
argument_list|(
literal|"hitcnts"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|hitcnts
operator|=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val
argument_list|(
literal|"prio"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|prio
operator|=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val
argument_list|(
literal|"rpttid"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|rpttid
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val
argument_list|(
literal|"queue"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|dirsteer
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|iq
operator|=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val
argument_list|(
literal|"tcbhash"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|maskhash
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|dirsteerhash
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val
argument_list|(
literal|"eport"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|eport
operator|=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
index|]
argument_list|,
literal|"dmac"
argument_list|)
condition|)
block|{
name|struct
name|ether_addr
modifier|*
name|daddr
decl_stmt|;
name|daddr
operator|=
name|ether_aton
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|daddr
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid dmac address \"%s\""
argument_list|,
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|t
operator|.
name|fs
operator|.
name|dmac
argument_list|,
name|daddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|newdmac
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
index|]
argument_list|,
literal|"smac"
argument_list|)
condition|)
block|{
name|struct
name|ether_addr
modifier|*
name|saddr
decl_stmt|;
name|saddr
operator|=
name|ether_aton
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|saddr
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid smac address \"%s\""
argument_list|,
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|t
operator|.
name|fs
operator|.
name|smac
argument_list|,
name|saddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|newsmac
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
index|]
argument_list|,
literal|"vlan"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|,
literal|"none"
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|newvlan
operator|=
name|VLAN_REMOVE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|newvlan
operator|=
name|VLAN_REWRITE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|newvlan
operator|=
name|VLAN_INSERT
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"unknown vlan parameter \"%s\"; must"
literal|" be one of \"none\", \"=<vlan>\" or"
literal|" \"+<vlan>\""
argument_list|,
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|.
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REWRITE
operator|||
name|t
operator|.
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_INSERT
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|vlan
operator|=
name|strtoul
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
operator|+
literal|1
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
operator|+
literal|1
operator|||
name|p
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid vlan \"%s\""
argument_list|,
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"invalid parameter \"%s\""
argument_list|,
name|argv
index|[
name|start_arg
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|start_arg
operator|!=
name|argc
condition|)
block|{
name|warnx
argument_list|(
literal|"no value for \"%s\""
argument_list|,
name|argv
index|[
name|start_arg
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Check basic sanity of option combinations. 	 */
if|if
condition|(
name|t
operator|.
name|fs
operator|.
name|action
operator|!=
name|FILTER_SWITCH
operator|&&
operator|(
name|t
operator|.
name|fs
operator|.
name|eport
operator|||
name|t
operator|.
name|fs
operator|.
name|newdmac
operator|||
name|t
operator|.
name|fs
operator|.
name|newsmac
operator|||
name|t
operator|.
name|fs
operator|.
name|newvlan
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"prio, port dmac, smac and vlan only make sense with"
literal|" \"action switch\""
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|.
name|fs
operator|.
name|action
operator|!=
name|FILTER_PASS
operator|&&
operator|(
name|t
operator|.
name|fs
operator|.
name|rpttid
operator|||
name|t
operator|.
name|fs
operator|.
name|dirsteer
operator|||
name|t
operator|.
name|fs
operator|.
name|maskhash
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"rpttid, queue and tcbhash don't make sense with"
literal|" action \"drop\" or \"switch\""
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|t
operator|.
name|fs
operator|.
name|type
operator|=
operator|(
name|af
operator|==
name|AF_INET6
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* default IPv4 */
return|return
name|doit
argument_list|(
name|CHELSIO_T4_SET_FILTER
argument_list|,
operator|&
name|t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|filter_cmd
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|long
name|long
name|val
decl_stmt|;
name|uint32_t
name|idx
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"filter: no arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
empty_stmt|;
comment|/* list */
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|warnx
argument_list|(
literal|"trailing arguments after \"list\" ignored."
argument_list|)
expr_stmt|;
return|return
name|show_filters
argument_list|()
return|;
block|}
comment|/* mode */
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"mode"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|get_filter_mode
argument_list|()
return|;
comment|/* mode<mode> */
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"mode"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|set_filter_mode
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
return|;
comment|/*<idx> ... */
name|s
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|||
name|val
operator|>
literal|0xffffffffU
condition|)
block|{
name|warnx
argument_list|(
literal|"\"%s\" is neither an index nor a filter subcommand."
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|idx
operator|=
operator|(
name|uint32_t
operator|)
name|val
expr_stmt|;
comment|/*<idx> delete|clear */
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"clear"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|del_filter
argument_list|(
name|idx
argument_list|)
return|;
block|}
comment|/*<idx> [<param><val>] ... */
return|return
name|set_filter
argument_list|(
name|idx
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|run_cmd
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|rc
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmd
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
comment|/* command */
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"reg"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"reg32"
argument_list|)
condition|)
name|rc
operator|=
name|register_io
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"reg64"
argument_list|)
condition|)
name|rc
operator|=
name|register_io
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|8
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"regdump"
argument_list|)
condition|)
name|rc
operator|=
name|dump_regs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"filter"
argument_list|)
condition|)
name|rc
operator|=
name|filter_cmd
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
name|warnx
argument_list|(
literal|"invalid command \"%s\""
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_ARGS
value|15
end_define

begin_function
specifier|static
name|int
name|run_cmd_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|char
name|buffer
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
index|[
name|MAX_ARGS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * Simple loop: displays a "> " prompt and processes any input as a 	 * cxgbetool command.  You're supposed to enter only the part after 	 * "cxgbetool t4nexX".  Use "quit" or "exit" to exit. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"> "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|buf
operator|=
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"stdin error"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|errno
expr_stmt|;
comment|/* errno from fgets */
block|}
break|break;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|args
index|[
name|i
index|]
operator|=
name|strsep
argument_list|(
operator|&
name|buf
argument_list|,
literal|" \t\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
operator|++
name|i
operator|==
name|MAX_ARGS
condition|)
break|break;
block|}
name|args
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
comment|/* skip empty line */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|"quit"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|"exit"
argument_list|)
condition|)
break|break;
name|rc
operator|=
name|run_cmd
argument_list|(
name|i
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* rc normally comes from the last command (not including quit/exit) */
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|rc
init|=
operator|-
literal|1
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-h"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--help"
argument_list|)
condition|)
block|{
name|usage
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|usage
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
name|nexus
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* progname and nexus */
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"stdio"
argument_list|)
condition|)
name|rc
operator|=
name|run_cmd_loop
argument_list|()
expr_stmt|;
else|else
name|rc
operator|=
name|run_cmd
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

end_unit

