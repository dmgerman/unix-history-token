begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Chelsio Communications, Inc.  * All rights reserved.  * Written by: Navdeep Parhar<np@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|"t4_ioctl.h"
end_include

begin_define
define|#
directive|define
name|ARRAY_SIZE
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a) / sizeof((a)[0]))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)> (y) ? (x) : (y))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|progname
decl_stmt|,
modifier|*
name|nexus
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|reg_info
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mod_regs
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|reg_info
modifier|*
name|ri
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|field_desc
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Field name */
name|unsigned
name|short
name|start
decl_stmt|;
comment|/* Start bit position */
name|unsigned
name|short
name|end
decl_stmt|;
comment|/* End bit position */
name|unsigned
name|char
name|shift
decl_stmt|;
comment|/* # of low order bits omitted and implicitly 0 */
name|unsigned
name|char
name|hex
decl_stmt|;
comment|/* Print field in hex instead of decimal */
name|unsigned
name|char
name|islog2
decl_stmt|;
comment|/* Field contains the base-2 log of the value */
block|}
struct|;
end_struct

begin_include
include|#
directive|include
file|"reg_defs_t4.c"
end_include

begin_include
include|#
directive|include
file|"reg_defs_t4vf.c"
end_include

begin_include
include|#
directive|include
file|"reg_defs_t5.c"
end_include

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Usage: %s<nexus> [operation]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tclearstats<port>                   clear port statistics\n"
literal|"\tcontext<type><id>                 show an SGE context\n"
literal|"\tfilter<idx> [<param><val>] ...    set a filter\n"
literal|"\tfilter<idx> delete|clear           delete a filter\n"
literal|"\tfilter list                         list all filters\n"
literal|"\tfilter mode [<match>] ...           get/set global filter mode\n"
literal|"\ti2c<port><devaddr><addr> [<len>] read from i2c device\n"
literal|"\tloadfw<fw-image.bin>               install firmware\n"
literal|"\tmemdump<addr><len>                dump a memory range\n"
literal|"\treg<address>[=<val>]               read/write register\n"
literal|"\treg64<address>[=<val>]             read/write 64 bit register\n"
literal|"\tregdump [<module>] ...              dump registers\n"
literal|"\tstdio                               interactive mode\n"
literal|"\ttcb<tid>                           read TCB\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|get_card_vers
parameter_list|(
name|unsigned
name|int
name|version
parameter_list|)
block|{
return|return
operator|(
name|version
operator|&
literal|0x3ff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|real_doit
parameter_list|(
name|unsigned
name|long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|cmdstr
parameter_list|)
block|{
specifier|static
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"/dev/%s"
argument_list|,
name|nexus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"open(%s)"
argument_list|,
name|nexus
argument_list|)
expr_stmt|;
name|rc
operator|=
name|errno
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
name|rc
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|cmdstr
argument_list|)
expr_stmt|;
name|rc
operator|=
name|errno
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|doit
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|real_doit(x, y, #x)
end_define

begin_function
specifier|static
name|char
modifier|*
name|str_to_number
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|long
modifier|*
name|val
parameter_list|,
name|long
name|long
modifier|*
name|vall
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|vall
condition|)
operator|*
name|vall
operator|=
name|strtoll
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
condition|)
operator|*
name|val
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_reg
parameter_list|(
name|long
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|long
name|long
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|t4_reg
name|reg
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|reg
operator|.
name|addr
operator|=
operator|(
name|uint32_t
operator|)
name|addr
expr_stmt|;
name|reg
operator|.
name|size
operator|=
operator|(
name|uint32_t
operator|)
name|size
expr_stmt|;
name|reg
operator|.
name|val
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|doit
argument_list|(
name|CHELSIO_T4_GETREG
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|reg
operator|.
name|val
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_reg
parameter_list|(
name|long
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|long
name|long
name|val
parameter_list|)
block|{
name|struct
name|t4_reg
name|reg
decl_stmt|;
name|reg
operator|.
name|addr
operator|=
operator|(
name|uint32_t
operator|)
name|addr
expr_stmt|;
name|reg
operator|.
name|size
operator|=
operator|(
name|uint32_t
operator|)
name|size
expr_stmt|;
name|reg
operator|.
name|val
operator|=
operator|(
name|uint64_t
operator|)
name|val
expr_stmt|;
return|return
name|doit
argument_list|(
name|CHELSIO_T4_SETREG
argument_list|,
operator|&
name|reg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|register_io
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|long
name|addr
decl_stmt|;
name|long
name|long
name|val
decl_stmt|;
name|int
name|w
init|=
literal|0
decl_stmt|,
name|rc
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
comment|/*<reg> OR<reg>=<value> */
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'='
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid register \"%s\""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|w
operator|=
literal|1
expr_stmt|;
name|v
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|str_to_number
argument_list|(
name|v
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid value \"%s\""
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
comment|/*<reg><value> */
name|w
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid register \"%s\""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid value \"%s\""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"reg: invalid number of arguments (%d)"
argument_list|,
name|argc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|w
condition|)
name|rc
operator|=
name|write_reg
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|read_reg
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"0x%llx [%llu]\n"
argument_list|,
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|xtract
parameter_list|(
name|uint32_t
name|val
parameter_list|,
name|int
name|shift
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
operator|(
name|val
operator|>>
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|len
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_block_regs
parameter_list|(
specifier|const
name|struct
name|reg_info
modifier|*
name|reg_array
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|regs
parameter_list|)
block|{
name|uint32_t
name|reg_val
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|reg_array
operator|->
name|name
condition|;
operator|++
name|reg_array
control|)
if|if
condition|(
operator|!
name|reg_array
operator|->
name|len
condition|)
block|{
name|reg_val
operator|=
name|regs
index|[
name|reg_array
operator|->
name|addr
operator|/
literal|4
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"[%#7x] %-47s %#-10x %u\n"
argument_list|,
name|reg_array
operator|->
name|addr
argument_list|,
name|reg_array
operator|->
name|name
argument_list|,
name|reg_val
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|v
init|=
name|xtract
argument_list|(
name|reg_val
argument_list|,
name|reg_array
operator|->
name|addr
argument_list|,
name|reg_array
operator|->
name|len
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"    %*u:%u %-47s %#-10x %u\n"
argument_list|,
name|reg_array
operator|->
name|addr
operator|<
literal|10
condition|?
literal|3
else|:
literal|2
argument_list|,
name|reg_array
operator|->
name|addr
operator|+
name|reg_array
operator|->
name|len
operator|-
literal|1
argument_list|,
name|reg_array
operator|->
name|addr
argument_list|,
name|reg_array
operator|->
name|name
argument_list|,
name|v
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_regs_table
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|regs
parameter_list|,
specifier|const
name|struct
name|mod_regs
modifier|*
name|modtab
parameter_list|,
name|int
name|nmodules
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|match
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nmodules
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|modtab
index|[
name|j
index|]
operator|.
name|name
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|nmodules
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid register block \"%s\""
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nAvailable blocks:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|nmodules
condition|;
name|nmodules
operator|--
operator|,
name|modtab
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|modtab
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
for|for
control|(
init|;
name|nmodules
condition|;
name|nmodules
operator|--
operator|,
name|modtab
operator|++
control|)
block|{
name|match
operator|=
name|argc
operator|==
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|match
operator|&&
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|modtab
operator|->
name|name
argument_list|)
condition|)
name|match
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|match
condition|)
name|dump_block_regs
argument_list|(
name|modtab
operator|->
name|ri
argument_list|,
name|regs
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|T4_MODREGS
parameter_list|(
name|name
parameter_list|)
value|{ #name, t4_##name##_regs }
end_define

begin_function
specifier|static
name|int
name|dump_regs_t4
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|regs
parameter_list|)
block|{
specifier|static
name|struct
name|mod_regs
name|t4_mod
index|[]
init|=
block|{
name|T4_MODREGS
argument_list|(
name|sge
argument_list|)
block|,
block|{
literal|"pci"
block|,
name|t4_pcie_regs
block|}
block|,
name|T4_MODREGS
argument_list|(
name|dbg
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|mc
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|ma
argument_list|)
block|,
block|{
literal|"edc0"
block|,
name|t4_edc_0_regs
block|}
block|,
block|{
literal|"edc1"
block|,
name|t4_edc_1_regs
block|}
block|,
name|T4_MODREGS
argument_list|(
name|cim
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|tp
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|ulp_rx
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|ulp_tx
argument_list|)
block|,
block|{
literal|"pmrx"
block|,
name|t4_pm_rx_regs
block|}
block|,
block|{
literal|"pmtx"
block|,
name|t4_pm_tx_regs
block|}
block|,
name|T4_MODREGS
argument_list|(
name|mps
argument_list|)
block|,
block|{
literal|"cplsw"
block|,
name|t4_cpl_switch_regs
block|}
block|,
name|T4_MODREGS
argument_list|(
name|smb
argument_list|)
block|,
block|{
literal|"i2c"
block|,
name|t4_i2cm_regs
block|}
block|,
name|T4_MODREGS
argument_list|(
name|mi
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|uart
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|pmu
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|sf
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|pl
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|le
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
name|ncsi
argument_list|)
block|,
name|T4_MODREGS
argument_list|(
argument|xgmac
argument_list|)
block|}
decl_stmt|;
return|return
name|dump_regs_table
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|regs
argument_list|,
name|t4_mod
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|t4_mod
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|T4_MODREGS
end_undef

begin_function
specifier|static
name|int
name|dump_regs_t4vf
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|regs
parameter_list|)
block|{
specifier|static
name|struct
name|mod_regs
name|t4vf_mod
index|[]
init|=
block|{
block|{
literal|"sge"
block|,
name|t4vf_sge_regs
block|}
block|,
block|{
literal|"mps"
block|,
name|t4vf_mps_regs
block|}
block|,
block|{
literal|"pl"
block|,
name|t4vf_pl_regs
block|}
block|,
block|{
literal|"mbdata"
block|,
name|t4vf_mbdata_regs
block|}
block|,
block|{
literal|"cim"
block|,
name|t4vf_cim_regs
block|}
block|, 	}
decl_stmt|;
return|return
name|dump_regs_table
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|regs
argument_list|,
name|t4vf_mod
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|t4vf_mod
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|T5_MODREGS
parameter_list|(
name|name
parameter_list|)
value|{ #name, t5_##name##_regs }
end_define

begin_function
specifier|static
name|int
name|dump_regs_t5
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|regs
parameter_list|)
block|{
specifier|static
name|struct
name|mod_regs
name|t5_mod
index|[]
init|=
block|{
name|T5_MODREGS
argument_list|(
name|sge
argument_list|)
block|,
block|{
literal|"pci"
block|,
name|t5_pcie_regs
block|}
block|,
name|T5_MODREGS
argument_list|(
name|dbg
argument_list|)
block|,
block|{
literal|"mc0"
block|,
name|t5_mc_0_regs
block|}
block|,
block|{
literal|"mc1"
block|,
name|t5_mc_1_regs
block|}
block|,
name|T5_MODREGS
argument_list|(
name|ma
argument_list|)
block|,
block|{
literal|"edc0"
block|,
name|t5_edc_t50_regs
block|}
block|,
block|{
literal|"edc1"
block|,
name|t5_edc_t51_regs
block|}
block|,
name|T5_MODREGS
argument_list|(
name|cim
argument_list|)
block|,
name|T5_MODREGS
argument_list|(
name|tp
argument_list|)
block|,
block|{
literal|"ulprx"
block|,
name|t5_ulp_rx_regs
block|}
block|,
block|{
literal|"ulptx"
block|,
name|t5_ulp_tx_regs
block|}
block|,
block|{
literal|"pmrx"
block|,
name|t5_pm_rx_regs
block|}
block|,
block|{
literal|"pmtx"
block|,
name|t5_pm_tx_regs
block|}
block|,
name|T5_MODREGS
argument_list|(
name|mps
argument_list|)
block|,
block|{
literal|"cplsw"
block|,
name|t5_cpl_switch_regs
block|}
block|,
name|T5_MODREGS
argument_list|(
name|smb
argument_list|)
block|,
block|{
literal|"i2c"
block|,
name|t5_i2cm_regs
block|}
block|,
name|T5_MODREGS
argument_list|(
name|mi
argument_list|)
block|,
name|T5_MODREGS
argument_list|(
name|uart
argument_list|)
block|,
name|T5_MODREGS
argument_list|(
name|pmu
argument_list|)
block|,
name|T5_MODREGS
argument_list|(
name|sf
argument_list|)
block|,
name|T5_MODREGS
argument_list|(
name|pl
argument_list|)
block|,
name|T5_MODREGS
argument_list|(
name|le
argument_list|)
block|,
name|T5_MODREGS
argument_list|(
name|ncsi
argument_list|)
block|,
name|T5_MODREGS
argument_list|(
name|mac
argument_list|)
block|,
block|{
literal|"hma"
block|,
name|t5_hma_t5_regs
block|}
block|}
decl_stmt|;
return|return
name|dump_regs_table
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|regs
argument_list|,
name|t5_mod
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|t5_mod
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|T5_MODREGS
end_undef

begin_function
specifier|static
name|int
name|dump_regs
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|vers
decl_stmt|,
name|revision
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|t4_regdump
name|regs
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|len
operator|=
name|max
argument_list|(
name|T4_REGDUMP_SIZE
argument_list|,
name|T5_REGDUMP_SIZE
argument_list|)
expr_stmt|;
name|regs
operator|.
name|data
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|data
operator|==
name|NULL
condition|)
block|{
name|warnc
argument_list|(
name|ENOMEM
argument_list|,
literal|"regdump"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|regs
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|rc
operator|=
name|doit
argument_list|(
name|CHELSIO_T4_REGDUMP
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|vers
operator|=
name|get_card_vers
argument_list|(
name|regs
operator|.
name|version
argument_list|)
expr_stmt|;
name|revision
operator|=
operator|(
name|regs
operator|.
name|version
operator|>>
literal|10
operator|)
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|vers
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|revision
operator|==
literal|0x3f
condition|)
name|rc
operator|=
name|dump_regs_t4vf
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|regs
operator|.
name|data
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|dump_regs_t4
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|regs
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vers
operator|==
literal|5
condition|)
name|rc
operator|=
name|dump_regs_t5
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|regs
operator|.
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"%s (type %d, rev %d) is not a known card."
argument_list|,
name|nexus
argument_list|,
name|vers
argument_list|,
name|revision
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|free
argument_list|(
name|regs
operator|.
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_show_info_header
parameter_list|(
name|uint32_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"%4s %8s"
argument_list|,
literal|"Idx"
argument_list|,
literal|"Hits"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|T4_FILTER_FCoE
init|;
name|i
operator|<=
name|T4_FILTER_IP_FRAGMENT
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
switch|switch
condition|(
name|mode
operator|&
name|i
condition|)
block|{
case|case
name|T4_FILTER_FCoE
case|:
name|printf
argument_list|(
literal|" FCoE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_PORT
case|:
name|printf
argument_list|(
literal|" Port"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_VNIC
case|:
name|printf
argument_list|(
literal|"      vld:VNIC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_VLAN
case|:
name|printf
argument_list|(
literal|"      vld:VLAN"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_IP_TOS
case|:
name|printf
argument_list|(
literal|"   TOS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_IP_PROTO
case|:
name|printf
argument_list|(
literal|"  Prot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_ETH_TYPE
case|:
name|printf
argument_list|(
literal|"   EthType"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_MAC_IDX
case|:
name|printf
argument_list|(
literal|"  MACIdx"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_MPS_HIT_TYPE
case|:
name|printf
argument_list|(
literal|" MPS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_IP_FRAGMENT
case|:
name|printf
argument_list|(
literal|" Frag"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* compressed filter field not enabled */
break|break;
block|}
block|}
name|printf
argument_list|(
literal|" %20s %20s %9s %9s %s\n"
argument_list|,
literal|"DIP"
argument_list|,
literal|"SIP"
argument_list|,
literal|"DPORT"
argument_list|,
literal|"SPORT"
argument_list|,
literal|"Action"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse an argument sub-vector as a {<parameter name><value>[:<mask>] }  * ordered tuple.  If the parameter name in the argument sub-vector does not  * match the passed in parameter name, then a zero is returned for the  * function and no parsing is performed.  If there is a match, then the value  * and optional mask are parsed and returned in the provided return value  * pointers.  If no optional mask is specified, then a default mask of all 1s  * will be returned.  *  * An error in parsing the value[:mask] will result in an error message and  * program termination.  */
end_comment

begin_function
specifier|static
name|int
name|parse_val_mask
parameter_list|(
specifier|const
name|char
modifier|*
name|param
parameter_list|,
specifier|const
name|char
modifier|*
name|args
index|[]
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|,
name|uint32_t
modifier|*
name|mask
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|param
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|val
operator|=
name|strtoul
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|args
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
operator|*
name|mask
operator|=
operator|~
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
operator|*
name|mask
operator|=
name|strtoul
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|warnx
argument_list|(
literal|"parameter \"%s\" has bad \"value[:mask]\" %s"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse an argument sub-vector as a {<parameter name><addr>[/<mask>] }  * ordered tuple.  If the parameter name in the argument sub-vector does not  * match the passed in parameter name, then a zero is returned for the  * function and no parsing is performed.  If there is a match, then the value  * and optional mask are parsed and returned in the provided return value  * pointers.  If no optional mask is specified, then a default mask of all 1s  * will be returned.  *  * The value return parameter "afp" is used to specify the expected address  * family -- IPv4 or IPv6 -- of the address[/mask] and return its actual  * format.  A passed in value of AF_UNSPEC indicates that either IPv4 or IPv6  * is acceptable; AF_INET means that only IPv4 addresses are acceptable; and  * AF_INET6 means that only IPv6 are acceptable.  AF_INET is returned for IPv4  * and AF_INET6 for IPv6 addresses, respectively.  IPv4 address/mask pairs are  * returned in the first four bytes of the address and mask return values with  * the address A.B.C.D returned with { A, B, C, D } returned in addresses { 0,  * 1, 2, 3}, respectively.  *  * An error in parsing the value[:mask] will result in an error message and  * program termination.  */
end_comment

begin_function
specifier|static
name|int
name|parse_ipaddr
parameter_list|(
specifier|const
name|char
modifier|*
name|param
parameter_list|,
specifier|const
name|char
modifier|*
name|args
index|[]
parameter_list|,
name|int
modifier|*
name|afp
parameter_list|,
name|uint8_t
name|addr
index|[]
parameter_list|,
name|uint8_t
name|mask
index|[]
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|afn
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|;
name|uint8_t
modifier|*
name|m
decl_stmt|;
name|int
name|af
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|int
name|masksize
decl_stmt|;
comment|/* 	 * Is this our parameter? 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|param
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Fundamental IPv4 versus IPv6 selection. 	 */
name|colon
operator|=
name|strchr
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|colon
condition|)
block|{
name|afn
operator|=
literal|"IPv4"
expr_stmt|;
name|af
operator|=
name|AF_INET
expr_stmt|;
name|masksize
operator|=
literal|32
expr_stmt|;
block|}
else|else
block|{
name|afn
operator|=
literal|"IPv6"
expr_stmt|;
name|af
operator|=
name|AF_INET6
expr_stmt|;
name|masksize
operator|=
literal|128
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|afp
operator|==
name|AF_UNSPEC
condition|)
operator|*
name|afp
operator|=
name|af
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|afp
operator|!=
name|af
condition|)
block|{
name|warnx
argument_list|(
literal|"address %s is not of expected family %s"
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
operator|*
name|afp
operator|==
name|AF_INET
condition|?
literal|"IP"
else|:
literal|"IPv6"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Parse address (temporarily stripping off any "/mask" 	 * specification). 	 */
name|slash
operator|=
name|strchr
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
operator|*
name|slash
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|inet_pton
argument_list|(
name|af
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Cannot parse %s %s address %s"
argument_list|,
name|param
argument_list|,
name|afn
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Parse optional mask specification. 	 */
if|if
condition|(
name|slash
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|prefix
init|=
name|strtoul
argument_list|(
name|slash
operator|+
literal|1
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|slash
operator|+
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"missing address prefix for %s"
argument_list|,
name|param
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|warnx
argument_list|(
literal|"%s is not a valid address prefix"
argument_list|,
name|slash
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|prefix
operator|>
name|masksize
condition|)
block|{
name|warnx
argument_list|(
literal|"prefix %u is too long for an %s address"
argument_list|,
name|prefix
argument_list|,
name|afn
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|memset
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|,
name|masksize
operator|/
literal|8
argument_list|)
expr_stmt|;
name|masksize
operator|=
name|prefix
expr_stmt|;
block|}
comment|/* 	 * Fill in mask. 	 */
for|for
control|(
name|m
operator|=
name|mask
init|;
name|masksize
operator|>=
literal|8
condition|;
name|m
operator|++
operator|,
name|masksize
operator|-=
literal|8
control|)
operator|*
name|m
operator|=
operator|~
literal|0
expr_stmt|;
if|if
condition|(
name|masksize
condition|)
operator|*
name|m
operator|=
operator|~
literal|0
operator|<<
operator|(
literal|8
operator|-
name|masksize
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse an argument sub-vector as a {<parameter name><value> } ordered  * tuple.  If the parameter name in the argument sub-vector does not match the  * passed in parameter name, then a zero is returned for the function and no  * parsing is performed.  If there is a match, then the value is parsed and  * returned in the provided return value pointer.  */
end_comment

begin_function
specifier|static
name|int
name|parse_val
parameter_list|(
specifier|const
name|char
modifier|*
name|param
parameter_list|,
specifier|const
name|char
modifier|*
name|args
index|[]
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|param
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|val
operator|=
name|strtoul
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|args
index|[
literal|1
index|]
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|warnx
argument_list|(
literal|"parameter \"%s\" has bad \"value\" %s"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filters_show_ipaddr
parameter_list|(
name|int
name|type
parameter_list|,
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint8_t
modifier|*
name|addrm
parameter_list|)
block|{
name|int
name|noctets
decl_stmt|,
name|octet
decl_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|noctets
operator|=
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|"%3s"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
name|noctets
operator|=
literal|16
expr_stmt|;
for|for
control|(
name|octet
operator|=
literal|0
init|;
name|octet
operator|<
name|noctets
condition|;
name|octet
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|addr
index|[
name|octet
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
for|for
control|(
name|octet
operator|=
literal|0
init|;
name|octet
operator|<
name|noctets
condition|;
name|octet
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|addrm
index|[
name|octet
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_show_one_filter_info
parameter_list|(
name|struct
name|t4_filter
modifier|*
name|t
parameter_list|,
name|uint32_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"%4d"
argument_list|,
name|t
operator|->
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|hits
operator|==
name|UINT64_MAX
condition|)
name|printf
argument_list|(
literal|" %8s"
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %8ju"
argument_list|,
name|t
operator|->
name|hits
argument_list|)
expr_stmt|;
comment|/* 	 * Compressed header portion of filter. 	 */
for|for
control|(
name|i
operator|=
name|T4_FILTER_FCoE
init|;
name|i
operator|<=
name|T4_FILTER_IP_FRAGMENT
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
switch|switch
condition|(
name|mode
operator|&
name|i
condition|)
block|{
case|case
name|T4_FILTER_FCoE
case|:
name|printf
argument_list|(
literal|"  %1d/%1d"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|fcoe
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|fcoe
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_PORT
case|:
name|printf
argument_list|(
literal|"  %1d/%1d"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|iport
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|iport
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_VNIC
case|:
name|printf
argument_list|(
literal|" %1d:%1x:%02x/%1d:%1x:%02x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|vnic_vld
argument_list|,
operator|(
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|vnic
operator|>>
literal|7
operator|)
operator|&
literal|0x7
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|vnic
operator|&
literal|0x7f
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|vnic_vld
argument_list|,
operator|(
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|vnic
operator|>>
literal|7
operator|)
operator|&
literal|0x7
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|vnic
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_VLAN
case|:
name|printf
argument_list|(
literal|" %1d:%04x/%1d:%04x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|vlan_vld
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|vlan
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|vlan_vld
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|vlan
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_IP_TOS
case|:
name|printf
argument_list|(
literal|" %02x/%02x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|tos
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|tos
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_IP_PROTO
case|:
name|printf
argument_list|(
literal|" %02x/%02x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|proto
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|proto
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_ETH_TYPE
case|:
name|printf
argument_list|(
literal|" %04x/%04x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|ethtype
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|ethtype
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_MAC_IDX
case|:
name|printf
argument_list|(
literal|" %03x/%03x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|macidx
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|macidx
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_MPS_HIT_TYPE
case|:
name|printf
argument_list|(
literal|" %1x/%1x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|matchtype
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|matchtype
argument_list|)
expr_stmt|;
break|break;
case|case
name|T4_FILTER_IP_FRAGMENT
case|:
name|printf
argument_list|(
literal|"  %1d/%1d"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|frag
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|frag
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* compressed filter field not enabled */
break|break;
block|}
block|}
comment|/* 	 * Fixed portion of filter. 	 */
name|filters_show_ipaddr
argument_list|(
name|t
operator|->
name|fs
operator|.
name|type
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|dip
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|dip
argument_list|)
expr_stmt|;
name|filters_show_ipaddr
argument_list|(
name|t
operator|->
name|fs
operator|.
name|type
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|sip
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|sip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %04x/%04x %04x/%04x"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|dport
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|dport
argument_list|,
name|t
operator|->
name|fs
operator|.
name|val
operator|.
name|sport
argument_list|,
name|t
operator|->
name|fs
operator|.
name|mask
operator|.
name|sport
argument_list|)
expr_stmt|;
comment|/* 	 * Variable length filter action. 	 */
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|action
operator|==
name|FILTER_DROP
condition|)
name|printf
argument_list|(
literal|" Drop"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|action
operator|==
name|FILTER_SWITCH
condition|)
block|{
name|printf
argument_list|(
literal|" Switch: port=%d"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|eport
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|newdmac
condition|)
name|printf
argument_list|(
literal|", dmac=%02x:%02x:%02x:%02x:%02x:%02x "
literal|", l2tidx=%d"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|dmac
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|dmac
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|dmac
index|[
literal|2
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|dmac
index|[
literal|3
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|dmac
index|[
literal|4
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|dmac
index|[
literal|5
index|]
argument_list|,
name|t
operator|->
name|l2tidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|newsmac
condition|)
name|printf
argument_list|(
literal|", smac=%02x:%02x:%02x:%02x:%02x:%02x "
literal|", smtidx=%d"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|smac
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|smac
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|smac
index|[
literal|2
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|smac
index|[
literal|3
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|smac
index|[
literal|4
index|]
argument_list|,
name|t
operator|->
name|fs
operator|.
name|smac
index|[
literal|5
index|]
argument_list|,
name|t
operator|->
name|smtidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REMOVE
condition|)
name|printf
argument_list|(
literal|", vlan=none"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_INSERT
condition|)
name|printf
argument_list|(
literal|", vlan=insert(%x)"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|vlan
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REWRITE
condition|)
name|printf
argument_list|(
literal|", vlan=rewrite(%x)"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|vlan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" Pass: Q="
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|dirsteer
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"RSS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|maskhash
condition|)
name|printf
argument_list|(
literal|"(TCB=hash)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|t
operator|->
name|fs
operator|.
name|iq
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|dirsteerhash
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"(QID)"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"(hash)"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|prio
condition|)
name|printf
argument_list|(
literal|" Prio"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fs
operator|.
name|rpttid
condition|)
name|printf
argument_list|(
literal|" RptTID"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|show_filters
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|mode
init|=
literal|0
decl_stmt|,
name|header
init|=
literal|0
decl_stmt|;
name|struct
name|t4_filter
name|t
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Get the global filter mode first */
name|rc
operator|=
name|doit
argument_list|(
name|CHELSIO_T4_GET_FILTER_MODE
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|t
operator|.
name|idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|.
name|idx
operator|=
literal|0
init|;
condition|;
name|t
operator|.
name|idx
operator|++
control|)
block|{
name|rc
operator|=
name|doit
argument_list|(
name|CHELSIO_T4_GET_FILTER
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|||
name|t
operator|.
name|idx
operator|==
literal|0xffffffff
condition|)
break|break;
if|if
condition|(
operator|!
name|header
condition|)
block|{
name|do_show_info_header
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|header
operator|=
literal|1
expr_stmt|;
block|}
name|do_show_one_filter_info
argument_list|(
operator|&
name|t
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_filter_mode
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|mode
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|doit
argument_list|(
name|CHELSIO_T4_GET_FILTER_MODE
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IPv4
condition|)
name|printf
argument_list|(
literal|"ipv4 "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IPv6
condition|)
name|printf
argument_list|(
literal|"ipv6 "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_SADDR
condition|)
name|printf
argument_list|(
literal|"sip "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_DADDR
condition|)
name|printf
argument_list|(
literal|"dip "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_SPORT
condition|)
name|printf
argument_list|(
literal|"sport "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_DPORT
condition|)
name|printf
argument_list|(
literal|"dport "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_FRAGMENT
condition|)
name|printf
argument_list|(
literal|"frag "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_MPS_HIT_TYPE
condition|)
name|printf
argument_list|(
literal|"matchtype "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_MAC_IDX
condition|)
name|printf
argument_list|(
literal|"macidx "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_ETH_TYPE
condition|)
name|printf
argument_list|(
literal|"ethtype "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_PROTO
condition|)
name|printf
argument_list|(
literal|"proto "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_IP_TOS
condition|)
name|printf
argument_list|(
literal|"tos "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_VLAN
condition|)
name|printf
argument_list|(
literal|"vlan "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_VNIC
condition|)
name|printf
argument_list|(
literal|"vnic/ovlan "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_PORT
condition|)
name|printf
argument_list|(
literal|"iport "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|T4_FILTER_FCoE
condition|)
name|printf
argument_list|(
literal|"fcoe "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter_mode
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|uint32_t
name|mode
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|argc
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"frag"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_IP_FRAGMENT
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"matchtype"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_MPS_HIT_TYPE
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"macidx"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_MAC_IDX
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"ethtype"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_ETH_TYPE
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"proto"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_IP_PROTO
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"tos"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_IP_TOS
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"vlan"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_VLAN
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"ovlan"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"vnic"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_VNIC
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"iport"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_PORT
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"fcoe"
argument_list|)
condition|)
name|mode
operator||=
name|T4_FILTER_FCoE
expr_stmt|;
block|}
return|return
name|doit
argument_list|(
name|CHELSIO_T4_SET_FILTER_MODE
argument_list|,
operator|&
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|del_filter
parameter_list|(
name|uint32_t
name|idx
parameter_list|)
block|{
name|struct
name|t4_filter
name|t
decl_stmt|;
name|t
operator|.
name|idx
operator|=
name|idx
expr_stmt|;
return|return
name|doit
argument_list|(
name|CHELSIO_T4_DEL_FILTER
argument_list|,
operator|&
name|t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter
parameter_list|(
name|uint32_t
name|idx
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|af
init|=
name|AF_UNSPEC
decl_stmt|,
name|start_arg
init|=
literal|0
decl_stmt|;
name|struct
name|t4_filter
name|t
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|warnc
argument_list|(
name|EINVAL
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
empty_stmt|;
name|bzero
argument_list|(
operator|&
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|idx
operator|=
name|idx
expr_stmt|;
for|for
control|(
name|start_arg
operator|=
literal|0
init|;
name|start_arg
operator|+
literal|2
operator|<=
name|argc
condition|;
name|start_arg
operator|+=
literal|2
control|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|args
init|=
operator|&
name|argv
index|[
name|start_arg
index|]
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|mask
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
index|]
argument_list|,
literal|"type"
argument_list|)
condition|)
block|{
name|int
name|newaf
decl_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|,
literal|"ipv4"
argument_list|)
condition|)
name|newaf
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|,
literal|"ipv6"
argument_list|)
condition|)
name|newaf
operator|=
name|AF_INET6
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"invalid type \"%s\"; "
literal|"must be one of \"ipv4\" or \"ipv6\""
argument_list|,
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|af
operator|!=
name|AF_UNSPEC
operator|&&
name|af
operator|!=
name|newaf
condition|)
block|{
name|warnx
argument_list|(
literal|"conflicting IPv4/IPv6 specifications."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|af
operator|=
name|newaf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"fcoe"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|fcoe
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|fcoe
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"iport"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|iport
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|iport
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"ovlan"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|vnic
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|vnic
operator|=
name|mask
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|vnic_vld
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|vnic_vld
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"vnic"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|vnic
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|vnic
operator|=
name|mask
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|vnic_vld
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|vnic_vld
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"ivlan"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|vlan
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|vlan
operator|=
name|mask
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|vlan_vld
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|vlan_vld
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"tos"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|tos
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|tos
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"proto"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|proto
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|proto
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"ethtype"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|ethtype
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|ethtype
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"macidx"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|macidx
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|macidx
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"matchtype"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|matchtype
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|matchtype
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"frag"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|frag
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|frag
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"dport"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|dport
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|dport
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val_mask
argument_list|(
literal|"sport"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|sport
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|sport
operator|=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_ipaddr
argument_list|(
literal|"dip"
argument_list|,
name|args
argument_list|,
operator|&
name|af
argument_list|,
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|dip
argument_list|,
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|dip
argument_list|)
condition|)
block|{
comment|/* nada */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_ipaddr
argument_list|(
literal|"sip"
argument_list|,
name|args
argument_list|,
operator|&
name|af
argument_list|,
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|sip
argument_list|,
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|sip
argument_list|)
condition|)
block|{
comment|/* nada */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
index|]
argument_list|,
literal|"action"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|,
literal|"pass"
argument_list|)
condition|)
name|t
operator|.
name|fs
operator|.
name|action
operator|=
name|FILTER_PASS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|,
literal|"drop"
argument_list|)
condition|)
name|t
operator|.
name|fs
operator|.
name|action
operator|=
name|FILTER_DROP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|,
literal|"switch"
argument_list|)
condition|)
name|t
operator|.
name|fs
operator|.
name|action
operator|=
name|FILTER_SWITCH
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"invalid action \"%s\"; must be one of"
literal|" \"pass\", \"drop\" or \"switch\""
argument_list|,
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val
argument_list|(
literal|"hitcnts"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|hitcnts
operator|=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val
argument_list|(
literal|"prio"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|prio
operator|=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val
argument_list|(
literal|"rpttid"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|rpttid
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val
argument_list|(
literal|"queue"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|dirsteer
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|iq
operator|=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val
argument_list|(
literal|"tcbhash"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|maskhash
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|dirsteerhash
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parse_val
argument_list|(
literal|"eport"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|eport
operator|=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
index|]
argument_list|,
literal|"dmac"
argument_list|)
condition|)
block|{
name|struct
name|ether_addr
modifier|*
name|daddr
decl_stmt|;
name|daddr
operator|=
name|ether_aton
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|daddr
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid dmac address \"%s\""
argument_list|,
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|t
operator|.
name|fs
operator|.
name|dmac
argument_list|,
name|daddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|newdmac
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
index|]
argument_list|,
literal|"smac"
argument_list|)
condition|)
block|{
name|struct
name|ether_addr
modifier|*
name|saddr
decl_stmt|;
name|saddr
operator|=
name|ether_aton
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|saddr
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid smac address \"%s\""
argument_list|,
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|t
operator|.
name|fs
operator|.
name|smac
argument_list|,
name|saddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|newsmac
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
index|]
argument_list|,
literal|"vlan"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|,
literal|"none"
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|newvlan
operator|=
name|VLAN_REMOVE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|newvlan
operator|=
name|VLAN_REWRITE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|newvlan
operator|=
name|VLAN_INSERT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|parse_val_mask
argument_list|(
literal|"vlan"
argument_list|,
name|args
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|vlan
operator|=
name|val
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|vlan
operator|=
name|mask
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|val
operator|.
name|vlan_vld
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|fs
operator|.
name|mask
operator|.
name|vlan_vld
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"unknown vlan parameter \"%s\"; must"
literal|" be one of \"none\", \"=<vlan>\", "
literal|" \"+<vlan>\", or \"<vlan>\""
argument_list|,
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|.
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_REWRITE
operator|||
name|t
operator|.
name|fs
operator|.
name|newvlan
operator|==
name|VLAN_INSERT
condition|)
block|{
name|t
operator|.
name|fs
operator|.
name|vlan
operator|=
name|strtoul
argument_list|(
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
operator|+
literal|1
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
operator|+
literal|1
operator|||
name|p
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid vlan \"%s\""
argument_list|,
name|argv
index|[
name|start_arg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"invalid parameter \"%s\""
argument_list|,
name|argv
index|[
name|start_arg
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|start_arg
operator|!=
name|argc
condition|)
block|{
name|warnx
argument_list|(
literal|"no value for \"%s\""
argument_list|,
name|argv
index|[
name|start_arg
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Check basic sanity of option combinations. 	 */
if|if
condition|(
name|t
operator|.
name|fs
operator|.
name|action
operator|!=
name|FILTER_SWITCH
operator|&&
operator|(
name|t
operator|.
name|fs
operator|.
name|eport
operator|||
name|t
operator|.
name|fs
operator|.
name|newdmac
operator|||
name|t
operator|.
name|fs
operator|.
name|newsmac
operator|||
name|t
operator|.
name|fs
operator|.
name|newvlan
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"prio, port dmac, smac and vlan only make sense with"
literal|" \"action switch\""
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|.
name|fs
operator|.
name|action
operator|!=
name|FILTER_PASS
operator|&&
operator|(
name|t
operator|.
name|fs
operator|.
name|rpttid
operator|||
name|t
operator|.
name|fs
operator|.
name|dirsteer
operator|||
name|t
operator|.
name|fs
operator|.
name|maskhash
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"rpttid, queue and tcbhash don't make sense with"
literal|" action \"drop\" or \"switch\""
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|t
operator|.
name|fs
operator|.
name|type
operator|=
operator|(
name|af
operator|==
name|AF_INET6
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* default IPv4 */
return|return
name|doit
argument_list|(
name|CHELSIO_T4_SET_FILTER
argument_list|,
operator|&
name|t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|filter_cmd
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|long
name|long
name|val
decl_stmt|;
name|uint32_t
name|idx
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"filter: no arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
empty_stmt|;
comment|/* list */
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|warnx
argument_list|(
literal|"trailing arguments after \"list\" ignored."
argument_list|)
expr_stmt|;
return|return
name|show_filters
argument_list|()
return|;
block|}
comment|/* mode */
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"mode"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|get_filter_mode
argument_list|()
return|;
comment|/* mode<mode> */
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"mode"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|set_filter_mode
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
return|;
comment|/*<idx> ... */
name|s
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|||
name|val
operator|>
literal|0xffffffffU
condition|)
block|{
name|warnx
argument_list|(
literal|"\"%s\" is neither an index nor a filter subcommand."
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|idx
operator|=
operator|(
name|uint32_t
operator|)
name|val
expr_stmt|;
comment|/*<idx> delete|clear */
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"clear"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|del_filter
argument_list|(
name|idx
argument_list|)
return|;
block|}
comment|/*<idx> [<param><val>] ... */
return|return
name|set_filter
argument_list|(
name|idx
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shows the fields of a multi-word structure.  The structure is considered to  * consist of @nwords 32-bit words (i.e, it's an (@nwords * 32)-bit structure)  * whose fields are described by @fd.  The 32-bit words are given in @words  * starting with the least significant 32-bit word.  */
end_comment

begin_function
specifier|static
name|void
name|show_struct
parameter_list|(
specifier|const
name|uint32_t
modifier|*
name|words
parameter_list|,
name|int
name|nwords
parameter_list|,
specifier|const
name|struct
name|field_desc
modifier|*
name|fd
parameter_list|)
block|{
name|unsigned
name|int
name|w
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|field_desc
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|fd
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
control|)
name|w
operator|=
name|max
argument_list|(
name|w
argument_list|,
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|fd
operator|->
name|name
condition|)
block|{
name|unsigned
name|long
name|long
name|data
decl_stmt|;
name|int
name|first_word
init|=
name|fd
operator|->
name|start
operator|/
literal|32
decl_stmt|;
name|int
name|shift
init|=
name|fd
operator|->
name|start
operator|%
literal|32
decl_stmt|;
name|int
name|width
init|=
name|fd
operator|->
name|end
operator|-
name|fd
operator|->
name|start
operator|+
literal|1
decl_stmt|;
name|unsigned
name|long
name|long
name|mask
init|=
operator|(
literal|1ULL
operator|<<
name|width
operator|)
operator|-
literal|1
decl_stmt|;
name|data
operator|=
operator|(
name|words
index|[
name|first_word
index|]
operator|>>
name|shift
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|words
index|[
name|first_word
operator|+
literal|1
index|]
operator|<<
operator|(
literal|32
operator|-
name|shift
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|shift
condition|)
name|data
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|words
index|[
name|first_word
operator|+
literal|2
index|]
operator|<<
operator|(
literal|64
operator|-
name|shift
operator|)
operator|)
expr_stmt|;
name|data
operator|&=
name|mask
expr_stmt|;
if|if
condition|(
name|fd
operator|->
name|islog2
condition|)
name|data
operator|=
literal|1
operator|<<
name|data
expr_stmt|;
name|printf
argument_list|(
literal|"%-*s "
argument_list|,
name|w
argument_list|,
name|fd
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|fd
operator|->
name|hex
condition|?
literal|"%#llx\n"
else|:
literal|"%llu\n"
argument_list|,
name|data
operator|<<
name|fd
operator|->
name|shift
argument_list|)
expr_stmt|;
name|fd
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|FIELD
parameter_list|(
name|name
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
value|{ name, start, end, 0, 0, 0 }
end_define

begin_define
define|#
directive|define
name|FIELD1
parameter_list|(
name|name
parameter_list|,
name|start
parameter_list|)
value|FIELD(name, start, start)
end_define

begin_function
specifier|static
name|void
name|show_sge_context
parameter_list|(
specifier|const
name|struct
name|t4_sge_context
modifier|*
name|p
parameter_list|)
block|{
specifier|static
name|struct
name|field_desc
name|egress
index|[]
init|=
block|{
name|FIELD1
argument_list|(
literal|"StatusPgNS:"
argument_list|,
literal|180
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"StatusPgRO:"
argument_list|,
literal|179
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"FetchNS:"
argument_list|,
literal|178
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"FetchRO:"
argument_list|,
literal|177
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"Valid:"
argument_list|,
literal|176
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"PCIeDataChannel:"
argument_list|,
literal|174
argument_list|,
literal|175
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"DCAEgrQEn:"
argument_list|,
literal|173
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"DCACPUID:"
argument_list|,
literal|168
argument_list|,
literal|172
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"FCThreshOverride:"
argument_list|,
literal|167
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"WRLength:"
argument_list|,
literal|162
argument_list|,
literal|166
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"WRLengthKnown:"
argument_list|,
literal|161
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"ReschedulePending:"
argument_list|,
literal|160
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"OnChipQueue:"
argument_list|,
literal|159
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"FetchSizeMode"
argument_list|,
literal|158
argument_list|)
block|,
block|{
literal|"FetchBurstMin:"
block|,
literal|156
block|,
literal|157
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"FetchBurstMax:"
block|,
literal|153
block|,
literal|154
block|,
literal|6
block|,
literal|0
block|,
literal|1
block|}
block|,
name|FIELD
argument_list|(
literal|"uPToken:"
argument_list|,
literal|133
argument_list|,
literal|152
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"uPTokenEn:"
argument_list|,
literal|132
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"UserModeIO:"
argument_list|,
literal|131
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"uPFLCredits:"
argument_list|,
literal|123
argument_list|,
literal|130
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"uPFLCreditEn:"
argument_list|,
literal|122
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"FID:"
argument_list|,
literal|111
argument_list|,
literal|121
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"HostFCMode:"
argument_list|,
literal|109
argument_list|,
literal|110
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"HostFCOwner:"
argument_list|,
literal|108
argument_list|)
block|,
block|{
literal|"CIDXFlushThresh:"
block|,
literal|105
block|,
literal|107
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
name|FIELD
argument_list|(
literal|"CIDX:"
argument_list|,
literal|89
argument_list|,
literal|104
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"PIDX:"
argument_list|,
literal|73
argument_list|,
literal|88
argument_list|)
block|,
block|{
literal|"BaseAddress:"
block|,
literal|18
block|,
literal|72
block|,
literal|9
block|,
literal|1
block|}
block|,
name|FIELD
argument_list|(
literal|"QueueSize:"
argument_list|,
literal|2
argument_list|,
literal|17
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"QueueType:"
argument_list|,
literal|1
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"CachePriority:"
argument_list|,
literal|0
argument_list|)
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|field_desc
name|fl
index|[]
init|=
block|{
name|FIELD1
argument_list|(
literal|"StatusPgNS:"
argument_list|,
literal|180
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"StatusPgRO:"
argument_list|,
literal|179
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"FetchNS:"
argument_list|,
literal|178
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"FetchRO:"
argument_list|,
literal|177
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"Valid:"
argument_list|,
literal|176
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"PCIeDataChannel:"
argument_list|,
literal|174
argument_list|,
literal|175
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"DCAEgrQEn:"
argument_list|,
literal|173
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"DCACPUID:"
argument_list|,
literal|168
argument_list|,
literal|172
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"FCThreshOverride:"
argument_list|,
literal|167
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"WRLength:"
argument_list|,
literal|162
argument_list|,
literal|166
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"WRLengthKnown:"
argument_list|,
literal|161
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"ReschedulePending:"
argument_list|,
literal|160
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"OnChipQueue:"
argument_list|,
literal|159
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"FetchSizeMode"
argument_list|,
literal|158
argument_list|)
block|,
block|{
literal|"FetchBurstMin:"
block|,
literal|156
block|,
literal|157
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"FetchBurstMax:"
block|,
literal|153
block|,
literal|154
block|,
literal|6
block|,
literal|0
block|,
literal|1
block|}
block|,
name|FIELD1
argument_list|(
literal|"FLMcongMode:"
argument_list|,
literal|152
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"MaxuPFLCredits:"
argument_list|,
literal|144
argument_list|,
literal|151
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"FLMcontextID:"
argument_list|,
literal|133
argument_list|,
literal|143
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"uPTokenEn:"
argument_list|,
literal|132
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"UserModeIO:"
argument_list|,
literal|131
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"uPFLCredits:"
argument_list|,
literal|123
argument_list|,
literal|130
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"uPFLCreditEn:"
argument_list|,
literal|122
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"FID:"
argument_list|,
literal|111
argument_list|,
literal|121
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"HostFCMode:"
argument_list|,
literal|109
argument_list|,
literal|110
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"HostFCOwner:"
argument_list|,
literal|108
argument_list|)
block|,
block|{
literal|"CIDXFlushThresh:"
block|,
literal|105
block|,
literal|107
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
name|FIELD
argument_list|(
literal|"CIDX:"
argument_list|,
literal|89
argument_list|,
literal|104
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"PIDX:"
argument_list|,
literal|73
argument_list|,
literal|88
argument_list|)
block|,
block|{
literal|"BaseAddress:"
block|,
literal|18
block|,
literal|72
block|,
literal|9
block|,
literal|1
block|}
block|,
name|FIELD
argument_list|(
literal|"QueueSize:"
argument_list|,
literal|2
argument_list|,
literal|17
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"QueueType:"
argument_list|,
literal|1
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"CachePriority:"
argument_list|,
literal|0
argument_list|)
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|field_desc
name|ingress
index|[]
init|=
block|{
name|FIELD1
argument_list|(
literal|"NoSnoop:"
argument_list|,
literal|145
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"RelaxedOrdering:"
argument_list|,
literal|144
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"GTSmode:"
argument_list|,
literal|143
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"ISCSICoalescing:"
argument_list|,
literal|142
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"Valid:"
argument_list|,
literal|141
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"TimerPending:"
argument_list|,
literal|140
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"DropRSS:"
argument_list|,
literal|139
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"PCIeChannel:"
argument_list|,
literal|137
argument_list|,
literal|138
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"SEInterruptArmed:"
argument_list|,
literal|136
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"CongestionMgtEnable:"
argument_list|,
literal|135
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"DCAIngQEnable:"
argument_list|,
literal|134
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"DCACPUID:"
argument_list|,
literal|129
argument_list|,
literal|133
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"UpdateScheduling:"
argument_list|,
literal|128
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"UpdateDelivery:"
argument_list|,
literal|126
argument_list|,
literal|127
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"InterruptSent:"
argument_list|,
literal|125
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"InterruptIDX:"
argument_list|,
literal|114
argument_list|,
literal|124
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"InterruptDestination:"
argument_list|,
literal|113
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"InterruptArmed:"
argument_list|,
literal|112
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"RxIntCounter:"
argument_list|,
literal|106
argument_list|,
literal|111
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"RxIntCounterThreshold:"
argument_list|,
literal|104
argument_list|,
literal|105
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"Generation:"
argument_list|,
literal|103
argument_list|)
block|,
block|{
literal|"BaseAddress:"
block|,
literal|48
block|,
literal|102
block|,
literal|9
block|,
literal|1
block|}
block|,
name|FIELD
argument_list|(
literal|"PIDX:"
argument_list|,
literal|32
argument_list|,
literal|47
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"CIDX:"
argument_list|,
literal|16
argument_list|,
literal|31
argument_list|)
block|,
block|{
literal|"QueueSize:"
block|,
literal|4
block|,
literal|15
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|"QueueEntrySize:"
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|}
block|,
name|FIELD1
argument_list|(
literal|"QueueEntryOverride:"
argument_list|,
literal|1
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"CachePriority:"
argument_list|,
literal|0
argument_list|)
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|field_desc
name|flm
index|[]
init|=
block|{
name|FIELD1
argument_list|(
literal|"NoSnoop:"
argument_list|,
literal|79
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"RelaxedOrdering:"
argument_list|,
literal|78
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"Valid:"
argument_list|,
literal|77
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"DCACPUID:"
argument_list|,
literal|72
argument_list|,
literal|76
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"DCAFLEn:"
argument_list|,
literal|71
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"EQid:"
argument_list|,
literal|54
argument_list|,
literal|70
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"SplitEn:"
argument_list|,
literal|52
argument_list|,
literal|53
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"PadEn:"
argument_list|,
literal|51
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"PackEn:"
argument_list|,
literal|50
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"DBpriority:"
argument_list|,
literal|48
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"PackOffset:"
argument_list|,
literal|16
argument_list|,
literal|47
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"CIDX:"
argument_list|,
literal|8
argument_list|,
literal|15
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"PIDX:"
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|field_desc
name|conm
index|[]
init|=
block|{
name|FIELD1
argument_list|(
literal|"CngDBPHdr:"
argument_list|,
literal|6
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"CngDBPData:"
argument_list|,
literal|5
argument_list|)
block|,
name|FIELD1
argument_list|(
literal|"CngIMSG:"
argument_list|,
literal|4
argument_list|)
block|,
name|FIELD
argument_list|(
literal|"CngChMap:"
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|mem_id
operator|==
name|SGE_CONTEXT_EGRESS
condition|)
name|show_struct
argument_list|(
name|p
operator|->
name|data
argument_list|,
literal|6
argument_list|,
operator|(
name|p
operator|->
name|data
index|[
literal|0
index|]
operator|&
literal|2
operator|)
condition|?
name|fl
else|:
name|egress
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|mem_id
operator|==
name|SGE_CONTEXT_FLM
condition|)
name|show_struct
argument_list|(
name|p
operator|->
name|data
argument_list|,
literal|3
argument_list|,
name|flm
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|mem_id
operator|==
name|SGE_CONTEXT_INGRESS
condition|)
name|show_struct
argument_list|(
name|p
operator|->
name|data
argument_list|,
literal|5
argument_list|,
name|ingress
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|mem_id
operator|==
name|SGE_CONTEXT_CNM
condition|)
name|show_struct
argument_list|(
name|p
operator|->
name|data
argument_list|,
literal|1
argument_list|,
name|conm
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|FIELD
end_undef

begin_undef
undef|#
directive|undef
name|FIELD1
end_undef

begin_function
specifier|static
name|int
name|get_sge_context
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|cid
decl_stmt|;
name|struct
name|t4_sge_context
name|cntxt
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"sge_context: incorrect number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"egress"
argument_list|)
condition|)
name|cntxt
operator|.
name|mem_id
operator|=
name|SGE_CONTEXT_EGRESS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"ingress"
argument_list|)
condition|)
name|cntxt
operator|.
name|mem_id
operator|=
name|SGE_CONTEXT_INGRESS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"fl"
argument_list|)
condition|)
name|cntxt
operator|.
name|mem_id
operator|=
name|SGE_CONTEXT_FLM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"cong"
argument_list|)
condition|)
name|cntxt
operator|.
name|mem_id
operator|=
name|SGE_CONTEXT_CNM
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"unknown context type \"%s\"; known types are egress, "
literal|"ingress, fl, and cong."
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid context id \"%s\""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|cntxt
operator|.
name|cid
operator|=
name|cid
expr_stmt|;
name|rc
operator|=
name|doit
argument_list|(
name|CHELSIO_T4_GET_SGE_CONTEXT
argument_list|,
operator|&
name|cntxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|show_sge_context
argument_list|(
operator|&
name|cntxt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|loadfw
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|t4_data
name|data
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|stat
name|st
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"loadfw: incorrect number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"open(%s)"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"fstat"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
name|data
operator|.
name|len
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|data
operator|.
name|data
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|data
operator|.
name|len
argument_list|,
name|PROT_READ
argument_list|,
literal|0
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|data
operator|==
name|MAP_FAILED
condition|)
block|{
name|warn
argument_list|(
literal|"mmap"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
name|rc
operator|=
name|doit
argument_list|(
name|CHELSIO_T4_LOAD_FW
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|len
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_mem
parameter_list|(
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|void
function_decl|(
modifier|*
name|output
function_decl|)
parameter_list|(
name|uint32_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|t4_mem_range
name|mr
decl_stmt|;
name|mr
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|mr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|mr
operator|.
name|data
operator|=
name|malloc
argument_list|(
name|mr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mr
operator|.
name|data
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"read_mem: malloc"
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
name|rc
operator|=
name|doit
argument_list|(
name|CHELSIO_T4_GET_MEM
argument_list|,
operator|&
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|output
condition|)
call|(
modifier|*
name|output
call|)
argument_list|(
name|mr
operator|.
name|data
argument_list|,
name|mr
operator|.
name|len
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|mr
operator|.
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Display memory as list of 'n' 4-byte values per line.  */
end_comment

begin_function
specifier|static
name|void
name|show_mem
parameter_list|(
name|uint32_t
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
init|=
literal|8
decl_stmt|;
while|while
condition|(
name|len
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|len
operator|&&
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|buf
operator|++
operator|,
name|len
operator|-=
literal|4
control|)
block|{
name|s
operator|=
name|i
condition|?
literal|" "
else|:
literal|""
expr_stmt|;
name|printf
argument_list|(
literal|"%s%08x"
argument_list|,
name|s
argument_list|,
name|htonl
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|memdump
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|l
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"incorrect number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid address \"%s\""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|addr
operator|=
name|l
expr_stmt|;
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|warnx
argument_list|(
literal|"memdump: invalid length \"%s\""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|len
operator|=
name|l
expr_stmt|;
return|return
operator|(
name|read_mem
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|show_mem
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Display TCB as list of 'n' 4-byte values per line.  */
end_comment

begin_function
specifier|static
name|void
name|show_tcb
parameter_list|(
name|uint32_t
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
init|=
literal|8
decl_stmt|;
while|while
condition|(
name|len
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|len
operator|&&
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|buf
operator|++
operator|,
name|len
operator|-=
literal|4
control|)
block|{
name|s
operator|=
name|i
condition|?
literal|" "
else|:
literal|""
expr_stmt|;
name|printf
argument_list|(
literal|"%s%08x"
argument_list|,
name|s
argument_list|,
name|htonl
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|A_TP_CMM_TCB_BASE
value|0x7d10
end_define

begin_define
define|#
directive|define
name|TCB_SIZE
value|128
end_define

begin_function
specifier|static
name|int
name|read_tcb
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|l
decl_stmt|;
name|long
name|long
name|val
decl_stmt|;
name|unsigned
name|int
name|tid
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"incorrect number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid tid \"%s\""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|tid
operator|=
name|l
expr_stmt|;
name|rc
operator|=
name|read_reg
argument_list|(
name|A_TP_CMM_TCB_BASE
argument_list|,
literal|4
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|addr
operator|=
name|val
operator|+
name|tid
operator|*
name|TCB_SIZE
expr_stmt|;
return|return
operator|(
name|read_mem
argument_list|(
name|addr
argument_list|,
name|TCB_SIZE
argument_list|,
name|show_tcb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_i2c
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|l
decl_stmt|;
name|struct
name|t4_i2c_data
name|i2cd
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
operator|||
name|argc
operator|>
literal|4
condition|)
block|{
name|warnx
argument_list|(
literal|"incorrect number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|||
name|l
operator|>
name|UCHAR_MAX
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid port id \"%s\""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|i2cd
operator|.
name|port_id
operator|=
name|l
expr_stmt|;
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|||
name|l
operator|>
name|UCHAR_MAX
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid i2c device address \"%s\""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|i2cd
operator|.
name|dev_addr
operator|=
name|l
expr_stmt|;
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|||
name|l
operator|>
name|UCHAR_MAX
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid byte offset \"%s\""
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|i2cd
operator|.
name|offset
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
block|{
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|||
name|l
operator|>
sizeof|sizeof
argument_list|(
name|i2cd
operator|.
name|data
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid number of bytes \"%s\""
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|i2cd
operator|.
name|len
operator|=
name|l
expr_stmt|;
block|}
else|else
name|i2cd
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|rc
operator|=
name|doit
argument_list|(
name|CHELSIO_T4_GET_I2C
argument_list|,
operator|&
name|i2cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|i2cd
operator|.
name|len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"0x%x [%u]\n"
argument_list|,
name|i2cd
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|i2cd
operator|.
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|clearstats
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|l
decl_stmt|;
name|uint32_t
name|port
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"incorrect number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|p
operator|=
name|str_to_number
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid port id \"%s\""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|port
operator|=
name|l
expr_stmt|;
return|return
name|doit
argument_list|(
name|CHELSIO_T4_CLEAR_STATS
argument_list|,
operator|&
name|port
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|run_cmd
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|rc
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmd
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
comment|/* command */
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"reg"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"reg32"
argument_list|)
condition|)
name|rc
operator|=
name|register_io
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"reg64"
argument_list|)
condition|)
name|rc
operator|=
name|register_io
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|8
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"regdump"
argument_list|)
condition|)
name|rc
operator|=
name|dump_regs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"filter"
argument_list|)
condition|)
name|rc
operator|=
name|filter_cmd
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"context"
argument_list|)
condition|)
name|rc
operator|=
name|get_sge_context
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"loadfw"
argument_list|)
condition|)
name|rc
operator|=
name|loadfw
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"memdump"
argument_list|)
condition|)
name|rc
operator|=
name|memdump
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"tcb"
argument_list|)
condition|)
name|rc
operator|=
name|read_tcb
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"i2c"
argument_list|)
condition|)
name|rc
operator|=
name|read_i2c
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"clearstats"
argument_list|)
condition|)
name|rc
operator|=
name|clearstats
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
name|warnx
argument_list|(
literal|"invalid command \"%s\""
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_ARGS
value|15
end_define

begin_function
specifier|static
name|int
name|run_cmd_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|char
name|buffer
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
index|[
name|MAX_ARGS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * Simple loop: displays a "> " prompt and processes any input as a 	 * cxgbetool command.  You're supposed to enter only the part after 	 * "cxgbetool t4nexX".  Use "quit" or "exit" to exit. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"> "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|buf
operator|=
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"stdin error"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|errno
expr_stmt|;
comment|/* errno from fgets */
block|}
break|break;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|args
index|[
name|i
index|]
operator|=
name|strsep
argument_list|(
operator|&
name|buf
argument_list|,
literal|" \t\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
operator|++
name|i
operator|==
name|MAX_ARGS
condition|)
break|break;
block|}
name|args
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
comment|/* skip empty line */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|"quit"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|"exit"
argument_list|)
condition|)
break|break;
name|rc
operator|=
name|run_cmd
argument_list|(
name|i
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* rc normally comes from the last command (not including quit/exit) */
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|rc
init|=
operator|-
literal|1
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-h"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--help"
argument_list|)
condition|)
block|{
name|usage
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|usage
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
name|nexus
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* progname and nexus */
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"stdio"
argument_list|)
condition|)
name|rc
operator|=
name|run_cmd_loop
argument_list|()
expr_stmt|;
else|else
name|rc
operator|=
name|run_cmd
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

end_unit

