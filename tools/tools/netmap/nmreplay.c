begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2016 Universita` di Pisa. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* COMMENT */
end_comment

begin_endif
unit|This program implements NMREPLAY, a program to replay a pcap file enforcing the output rate and possibly random losses and delay distributions. It is meant to be run from the command line and implemented with a main control thread for monitoring, plus a thread to push packets out.  The control thread parses command line arguments, prepares a schedule for transmission in a memory buffer and then sits in a loop where it periodically reads traffic statistics from the other threads and prints them out on the console.  The transmit buffer contains headers and packets. Each header includes a timestamp that determines when the packet should be sent out. A "consumer" thread cons() reads from the queue and transmits packets on the output netmap port when their time has come.  The program does CPU pinning and sets the scheduler and priority for the "cons" threads. Externally one should do the assignment of other threads (e.g. interrupt handlers) and make sure that network interfaces are configured properly.  --- Main functions of the program --- within each function, q is used as a pointer to the queue holding packets and parameters.  pcap_prod()      reads from the pcap file and prepares packets to transmit.     After reading a packet from the pcap file, the following information     are extracted which can be used to determine the schedule:      	q->cur_pkt	points to the buffer containing the packet 	q->cur_len	packet length, excluding CRC 	q->cur_caplen	available packet length (may be shorter than cur_len) 	q->cur_tt	transmission time for the packet, computed from the trace.      The following functions are then called in sequence:      q->c_loss (set with the -L command line option) decides     	whether the packet should be dropped before even queuing. 	This is generally useful to emulate random loss. 	The function is supposed to set q->c_drop = 1 if the 	packet should be dropped, or leave it to 0 otherwise.      q->c_bw (set with the -B command line option) is used to         enforce the transmit bandwidth. The function must store 	in q->cur_tt the transmission time (in nanoseconds) of 	the packet, which is typically proportional to the length 	of the packet, i.e. q->cur_tt = q->cur_len /<bandwidth> 	Variants are possible, eg. to account for constant framing 	bits as on the ethernet, or variable channel acquisition times, 	etc. 	This mechanism can also be used to simulate variable queueing 	delay e.g. due to the presence of cross traffic.      q->c_delay (set with the -D option) implements delay emulation. 	The function should set q->cur_delay to the additional 	delay the packet is subject to. The framework will take care of 	computing the actual exit time of a packet so that there is no 	reordering.
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMMENT */
end_comment

begin_comment
comment|// debugging macros
end_comment

begin_define
define|#
directive|define
name|NED
parameter_list|(
name|_fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {} while (0)
end_define

begin_define
define|#
directive|define
name|ED
parameter_list|(
name|_fmt
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {							\ 		struct timeval _t0;				\ 		gettimeofday(&_t0, NULL);			\ 		fprintf(stderr, "%03d.%03d %-10.10s [%5d] \t" _fmt "\n", \ 		(int)(_t0.tv_sec % 1000), (int)_t0.tv_usec/1000, \ 		__FUNCTION__, __LINE__, ##__VA_ARGS__);     \ 	} while (0)
end_define

begin_comment
comment|/* WWW is for warnings, EEE is for errors */
end_comment

begin_define
define|#
directive|define
name|WWW
parameter_list|(
name|_fmt
parameter_list|,
modifier|...
parameter_list|)
value|ED("--WWW-- " _fmt, ##__VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|EEE
parameter_list|(
name|_fmt
parameter_list|,
modifier|...
parameter_list|)
value|ED("--EEE-- " _fmt, ##__VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|DDD
parameter_list|(
name|_fmt
parameter_list|,
modifier|...
parameter_list|)
value|ED("--DDD-- " _fmt, ##__VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_comment
comment|// for CPU_SET() etc
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|NETMAP_WITH_LIBS
end_define

begin_include
include|#
directive|include
file|<net/netmap_user.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_comment
comment|/*  * A packet in the queue is q_pkt plus the payload.  For the packet descriptor we need the following:      -	position of next packet in the queue (can go backwards). 	We can reduce to 32 bits if we consider alignments, 	or we just store the length to be added to the current 	value and assume 0 as a special index.     -	actual packet length (16 bits may be ok)     -	queue output time, in nanoseconds (64 bits)     -	delay line output time, in nanoseconds 	One of the two can be packed to a 32bit value  A convenient coding uses 32 bytes per packet.   */
end_comment

begin_struct
struct|struct
name|q_pkt
block|{
name|uint64_t
name|next
decl_stmt|;
comment|/* buffer index for next packet */
name|uint64_t
name|pktlen
decl_stmt|;
comment|/* actual packet len */
name|uint64_t
name|pt_qout
decl_stmt|;
comment|/* time of output from queue */
name|uint64_t
name|pt_tx
decl_stmt|;
comment|/* transmit time */
block|}
struct|;
end_struct

begin_comment
comment|/*  * The header for a pcap file  */
end_comment

begin_struct
struct|struct
name|pcap_file_header
block|{
name|uint32_t
name|magic
decl_stmt|;
comment|/*used to detect the file format itself and the byte     ordering. The writing application writes 0xa1b2c3d4 with it's native byte     ordering format into this field. The reading application will read either     0xa1b2c3d4 (identical) or 0xd4c3b2a1 (swapped). If the reading application     reads the swapped 0xd4c3b2a1 value, it knows that all the following fields     will have to be swapped too. For nanosecond-resolution files, the writing     application writes 0xa1b23c4d, with the two nibbles of the two lower-order     bytes swapped, and the reading application will read either 0xa1b23c4d     (identical) or 0x4d3cb2a1 (swapped)*/
name|uint16_t
name|version_major
decl_stmt|;
name|uint16_t
name|version_minor
decl_stmt|;
comment|/*the version number of this file format */
name|int32_t
name|thiszone
decl_stmt|;
comment|/*the correction time in seconds between GMT (UTC) and the     local timezone of the following packet header timestamps. Examples: If the     timestamps are in GMT (UTC), thiszone is simply 0. If the timestamps are in     Central European time (Amsterdam, Berlin, ...) which is GMT + 1:00, thiszone     must be -3600*/
name|uint32_t
name|stampacc
decl_stmt|;
comment|/*the accuracy of time stamps in the capture*/
name|uint32_t
name|snaplen
decl_stmt|;
comment|/*the "snapshot length" for the capture (typically 65535     or even more, but might be limited by the user)*/
name|uint32_t
name|network
decl_stmt|;
comment|/*link-layer header type, specifying the type of headers     at the beginning of the packet (e.g. 1 for Ethernet); this can be various     types such as 802.11, 802.11 with various radio information, PPP, Token     Ring, FDDI, etc.*/
block|}
struct|;
end_struct

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* from pcap.h */
end_comment

begin_comment
unit|struct pcap_file_header {         bpf_u_int32 magic;         u_short version_major;         u_short version_minor;         bpf_int32 thiszone;
comment|/* gmt to local correction */
end_comment

begin_comment
unit|bpf_u_int32 sigfigs;
comment|/* accuracy of timestamps */
end_comment

begin_comment
unit|bpf_u_int32 snaplen;
comment|/* max length saved portion of each pkt */
end_comment

begin_comment
unit|bpf_u_int32 linktype;
comment|/* data link type (LINKTYPE_*) */
end_comment

begin_comment
unit|};  struct pcap_pkthdr {         struct timeval ts;
comment|/* time stamp */
end_comment

begin_comment
unit|bpf_u_int32 caplen;
comment|/* length of portion present */
end_comment

begin_comment
unit|bpf_u_int32 len;
comment|/* length this packet (off wire) */
end_comment

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_comment
comment|/* from pcap.h */
end_comment

begin_struct
struct|struct
name|pcap_pkthdr
block|{
name|uint32_t
name|ts_sec
decl_stmt|;
comment|/* seconds from epoch */
name|uint32_t
name|ts_frac
decl_stmt|;
comment|/* microseconds or nanoseconds depending on sigfigs */
name|uint32_t
name|caplen
decl_stmt|;
comment|/*the number of bytes of packet data actually captured     and saved in the file. This value should never become larger than orig_len     or the snaplen value of the global header*/
name|uint32_t
name|len
decl_stmt|;
comment|/* wire length */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PKT_PAD
value|(32)
end_define

begin_comment
comment|/* padding on packets */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|pad
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
operator|(
operator|(
name|x
operator|)
operator|+
name|PKT_PAD
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|PKT_PAD
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wrapper around the pcap file.  * We mmap the file so it is easy to do multiple passes through it.  */
end_comment

begin_struct
struct|struct
name|nm_pcap_file
block|{
name|int
name|fd
decl_stmt|;
name|uint64_t
name|filesize
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
comment|/* mmapped file */
name|uint64_t
name|tot_pkt
decl_stmt|;
name|uint64_t
name|tot_bytes
decl_stmt|;
name|uint64_t
name|tot_bytes_rounded
decl_stmt|;
comment|/* need hdr + pad(len) */
name|uint32_t
name|resolution
decl_stmt|;
comment|/* 1000 for us, 1 for ns */
name|int
name|swap
decl_stmt|;
comment|/* need to swap fields ? */
name|uint64_t
name|first_ts
decl_stmt|;
name|uint64_t
name|total_tx_time
decl_stmt|;
comment|/* 	 * total_tx_time is computed as last_ts - first_ts, plus the 	 * transmission time for the first packet which in turn is 	 * computed according to the average bandwidth 	 */
name|uint64_t
name|file_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|cur
decl_stmt|;
comment|/* running pointer */
specifier|const
name|char
modifier|*
name|lim
decl_stmt|;
comment|/* data + file_len */
name|int
name|err
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|nm_pcap_file
modifier|*
name|readpcap
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_pcap
parameter_list|(
name|struct
name|nm_pcap_file
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memcpy */
end_comment

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_define
define|#
directive|define
name|NS_SCALE
value|1000000000UL
end_define

begin_comment
comment|/* nanoseconds in 1s */
end_comment

begin_function
specifier|static
name|void
name|destroy_pcap
parameter_list|(
name|struct
name|nm_pcap_file
modifier|*
name|pf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pf
condition|)
return|return;
name|munmap
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|pf
operator|->
name|data
argument_list|,
name|pf
operator|->
name|filesize
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pf
operator|->
name|fd
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|// convert a field of given size if swap is needed.
end_comment

begin_function
specifier|static
name|uint32_t
name|cvt
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|int
name|size
parameter_list|,
name|char
name|swap
parameter_list|)
block|{
name|uint32_t
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|!=
literal|2
operator|&&
name|size
operator|!=
literal|4
condition|)
block|{
name|EEE
argument_list|(
literal|"Invalid size %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|ret
argument_list|,
name|src
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap
condition|)
block|{
name|unsigned
name|char
name|tmp
decl_stmt|,
modifier|*
name|data
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
name|data
index|[
name|size
operator|-
operator|(
literal|1
operator|+
name|i
operator|)
index|]
expr_stmt|;
name|data
index|[
name|size
operator|-
operator|(
literal|1
operator|+
name|i
operator|)
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|read_next_info
parameter_list|(
name|struct
name|nm_pcap_file
modifier|*
name|pf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|pf
operator|->
name|cur
operator|+
name|size
decl_stmt|;
name|uint32_t
name|ret
decl_stmt|;
if|if
condition|(
name|end
operator|>
name|pf
operator|->
name|lim
condition|)
block|{
name|pf
operator|->
name|err
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|cvt
argument_list|(
name|pf
operator|->
name|cur
argument_list|,
name|size
argument_list|,
name|pf
operator|->
name|swap
argument_list|)
expr_stmt|;
name|pf
operator|->
name|cur
operator|=
name|end
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * mmap the file, make sure timestamps are sorted, and count  * packets and sizes  * Timestamps represent the receive time of the packets.  * We need to compute also the 'first_ts' which refers to a hypotetical  * packet right before the first one, see the code for details.  */
end_comment

begin_function
specifier|static
name|struct
name|nm_pcap_file
modifier|*
name|readpcap
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|struct
name|nm_pcap_file
name|_f
decl_stmt|,
modifier|*
name|pf
init|=
operator|&
name|_f
decl_stmt|;
name|uint64_t
name|prev_ts
decl_stmt|,
name|first_pkt_time
decl_stmt|;
name|uint32_t
name|magic
decl_stmt|,
name|first_len
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
name|pf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pf
argument_list|)
argument_list|)
expr_stmt|;
name|pf
operator|->
name|fd
operator|=
name|open
argument_list|(
name|fn
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
name|EEE
argument_list|(
literal|"cannot open file %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* compute length */
name|pf
operator|->
name|filesize
operator|=
name|lseek
argument_list|(
name|pf
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|pf
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|ED
argument_list|(
literal|"filesize is %lu"
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|pf
operator|->
name|filesize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|filesize
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_file_header
argument_list|)
condition|)
block|{
name|EEE
argument_list|(
literal|"file too short %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pf
operator|->
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pf
operator|->
name|data
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|pf
operator|->
name|filesize
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|pf
operator|->
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|data
operator|==
name|MAP_FAILED
condition|)
block|{
name|EEE
argument_list|(
literal|"cannot mmap file %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pf
operator|->
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pf
operator|->
name|cur
operator|=
name|pf
operator|->
name|data
expr_stmt|;
name|pf
operator|->
name|lim
operator|=
name|pf
operator|->
name|data
operator|+
name|pf
operator|->
name|filesize
expr_stmt|;
name|pf
operator|->
name|err
operator|=
literal|0
expr_stmt|;
name|pf
operator|->
name|swap
operator|=
literal|0
expr_stmt|;
comment|/* default, same endianness when read magic */
name|magic
operator|=
name|read_next_info
argument_list|(
name|pf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ED
argument_list|(
literal|"magic is 0x%x"
argument_list|,
name|magic
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|magic
condition|)
block|{
case|case
literal|0xa1b2c3d4
case|:
comment|/* native, us resolution */
name|pf
operator|->
name|swap
operator|=
literal|0
expr_stmt|;
name|pf
operator|->
name|resolution
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
literal|0xd4c3b2a1
case|:
comment|/* swapped, us resolution */
name|pf
operator|->
name|swap
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|resolution
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
literal|0xa1b23c4d
case|:
comment|/* native, ns resolution */
name|pf
operator|->
name|swap
operator|=
literal|0
expr_stmt|;
name|pf
operator|->
name|resolution
operator|=
literal|1
expr_stmt|;
comment|/* nanoseconds */
break|break;
case|case
literal|0x4d3cb2a1
case|:
comment|/* swapped, ns resolution */
name|pf
operator|->
name|swap
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|resolution
operator|=
literal|1
expr_stmt|;
comment|/* nanoseconds */
break|break;
default|default:
name|EEE
argument_list|(
literal|"unknown magic 0x%x"
argument_list|,
name|magic
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ED
argument_list|(
literal|"swap %d res %d\n"
argument_list|,
name|pf
operator|->
name|swap
argument_list|,
name|pf
operator|->
name|resolution
argument_list|)
expr_stmt|;
name|pf
operator|->
name|cur
operator|=
name|pf
operator|->
name|data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_file_header
argument_list|)
expr_stmt|;
name|pf
operator|->
name|lim
operator|=
name|pf
operator|->
name|data
operator|+
name|pf
operator|->
name|filesize
expr_stmt|;
name|pf
operator|->
name|err
operator|=
literal|0
expr_stmt|;
name|prev_ts
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pf
operator|->
name|cur
operator|<
name|pf
operator|->
name|lim
operator|&&
name|pf
operator|->
name|err
operator|==
literal|0
condition|)
block|{
name|uint32_t
name|base
init|=
name|pf
operator|->
name|cur
operator|-
name|pf
operator|->
name|data
decl_stmt|;
name|uint64_t
name|cur_ts
init|=
name|read_next_info
argument_list|(
name|pf
argument_list|,
literal|4
argument_list|)
operator|*
name|NS_SCALE
operator|+
name|read_next_info
argument_list|(
name|pf
argument_list|,
literal|4
argument_list|)
operator|*
name|pf
operator|->
name|resolution
decl_stmt|;
name|uint32_t
name|caplen
init|=
name|read_next_info
argument_list|(
name|pf
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|uint32_t
name|len
init|=
name|read_next_info
argument_list|(
name|pf
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|pf
operator|->
name|err
condition|)
block|{
name|WWW
argument_list|(
literal|"end of pcap file after %d packets\n"
argument_list|,
operator|(
name|int
operator|)
name|pf
operator|->
name|tot_pkt
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cur_ts
operator|<
name|prev_ts
condition|)
block|{
name|WWW
argument_list|(
literal|"reordered packet %d\n"
argument_list|,
operator|(
name|int
operator|)
name|pf
operator|->
name|tot_pkt
argument_list|)
expr_stmt|;
block|}
name|prev_ts
operator|=
name|cur_ts
expr_stmt|;
operator|(
name|void
operator|)
name|base
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|tot_pkt
operator|==
literal|0
condition|)
block|{
name|pf
operator|->
name|first_ts
operator|=
name|cur_ts
expr_stmt|;
name|first_len
operator|=
name|len
expr_stmt|;
block|}
name|pf
operator|->
name|tot_pkt
operator|++
expr_stmt|;
name|pf
operator|->
name|tot_bytes
operator|+=
name|len
expr_stmt|;
name|pf
operator|->
name|tot_bytes_rounded
operator|+=
name|pad
argument_list|(
name|len
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|q_pkt
argument_list|)
expr_stmt|;
name|pf
operator|->
name|cur
operator|+=
name|caplen
expr_stmt|;
block|}
name|pf
operator|->
name|total_tx_time
operator|=
name|prev_ts
operator|-
name|pf
operator|->
name|first_ts
expr_stmt|;
comment|/* excluding first packet */
name|ED
argument_list|(
literal|"tot_pkt %lu tot_bytes %lu tx_time %.6f s first_len %lu"
argument_list|,
operator|(
name|u_long
operator|)
name|pf
operator|->
name|tot_pkt
argument_list|,
operator|(
name|u_long
operator|)
name|pf
operator|->
name|tot_bytes
argument_list|,
literal|1e-9
operator|*
name|pf
operator|->
name|total_tx_time
argument_list|,
operator|(
name|u_long
operator|)
name|first_len
argument_list|)
expr_stmt|;
comment|/*      * We determine that based on the      * average bandwidth of the trace, as follows      *   first_pkt_ts = p[0].len / avg_bw      * In turn avg_bw = (total_len - p[0].len)/(p[n-1].ts - p[0].ts)      * so       *   first_ts =  p[0].ts - p[0].len * (p[n-1].ts - p[0].ts) / (total_len - p[0].len)      */
if|if
condition|(
name|pf
operator|->
name|tot_bytes
operator|==
name|first_len
condition|)
block|{
comment|/* cannot estimate bandwidth, so force 1 Gbit */
name|first_pkt_time
operator|=
name|first_len
operator|*
literal|8
expr_stmt|;
comment|/* * 10^9 / bw */
block|}
else|else
block|{
name|first_pkt_time
operator|=
name|pf
operator|->
name|total_tx_time
operator|*
name|first_len
operator|/
operator|(
name|pf
operator|->
name|tot_bytes
operator|-
name|first_len
operator|)
expr_stmt|;
block|}
name|ED
argument_list|(
literal|"first_pkt_time %.6f s"
argument_list|,
literal|1e-9
operator|*
name|first_pkt_time
argument_list|)
expr_stmt|;
name|pf
operator|->
name|total_tx_time
operator|+=
name|first_pkt_time
expr_stmt|;
name|pf
operator|->
name|first_ts
operator|-=
name|first_pkt_time
expr_stmt|;
comment|/* all correct, allocate a record and copy */
name|pf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pf
operator|=
name|_f
expr_stmt|;
comment|/* reset pointer to start */
name|pf
operator|->
name|cur
operator|=
name|pf
operator|->
name|data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_file_header
argument_list|)
expr_stmt|;
name|pf
operator|->
name|err
operator|=
literal|0
expr_stmt|;
return|return
name|pf
return|;
block|}
end_function

begin_enum
enum|enum
name|my_pcap_mode
block|{
name|PM_NONE
block|,
name|PM_FAST
block|,
name|PM_FIXED
block|,
name|PM_REAL
block|}
enum|;
end_enum

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_abort
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_comment
comment|// setpriority
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<pthread_np.h>
end_include

begin_comment
comment|/* pthread w/ affinity */
end_comment

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_comment
comment|/* cpu_set */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_define
define|#
directive|define
name|cpuset_t
value|cpu_set_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__APPLE__
end_ifdef

begin_define
define|#
directive|define
name|cpuset_t
value|uint64_t
end_define

begin_comment
comment|// XXX
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|CPU_ZERO
parameter_list|(
name|cpuset_t
modifier|*
name|p
parameter_list|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|CPU_SET
parameter_list|(
name|uint32_t
name|i
parameter_list|,
name|cpuset_t
modifier|*
name|p
parameter_list|)
block|{
operator|*
name|p
operator||=
literal|1
operator|<<
operator|(
name|i
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|pthread_setaffinity_np
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|((void)a, 0)
end_define

begin_define
define|#
directive|define
name|sched_setscheduler
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(1)
end_define

begin_comment
comment|/* error */
end_comment

begin_define
define|#
directive|define
name|clock_gettime
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|do {struct timespec t0 = {0,0}; *(b) = t0; } while (0)
end_define

begin_define
define|#
directive|define
name|_P64
value|unsigned long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_P64
end_ifndef

begin_comment
comment|/* we use uint64_t widely, but printf gives trouble on different  * platforms so we use _P64 as a cast  */
end_comment

begin_define
define|#
directive|define
name|_P64
value|uint64_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* print stuff */
end_comment

begin_struct_decl
struct_decl|struct
name|_qs
struct_decl|;
end_struct_decl

begin_comment
comment|/* forward */
end_comment

begin_comment
comment|/*  * descriptor of a configuration entry.  * Each handler has a parse function which takes ac/av[] and returns  * true if successful. Any allocated space is stored into struct _cfg *  * that is passed as argument.  * arg and arg_len are included for convenience.  */
end_comment

begin_struct
struct|struct
name|_cfg
block|{
name|int
function_decl|(
modifier|*
name|parse
function_decl|)
parameter_list|(
name|struct
name|_qs
modifier|*
parameter_list|,
name|struct
name|_cfg
modifier|*
parameter_list|,
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
function_decl|;
comment|/* 0 ok, 1 on error */
name|int
function_decl|(
modifier|*
name|run
function_decl|)
parameter_list|(
name|struct
name|_qs
modifier|*
parameter_list|,
name|struct
name|_cfg
modifier|*
name|arg
parameter_list|)
function_decl|;
comment|/* 0 Ok, 1 on error */
comment|// int close(struct _qs *, void *arg);              /* 0 Ok, 1 on error */
specifier|const
name|char
modifier|*
name|optarg
decl_stmt|;
comment|/* command line argument. Initial value is the error message */
comment|/* placeholders for common values */
name|void
modifier|*
name|arg
decl_stmt|;
comment|/* allocated memory if any */
name|int
name|arg_len
decl_stmt|;
comment|/* size of *arg in case a realloc is needed */
name|uint64_t
name|d
index|[
literal|16
index|]
decl_stmt|;
comment|/* static storage for simple cases */
name|double
name|f
index|[
literal|4
index|]
decl_stmt|;
comment|/* static storage for simple cases */
block|}
struct|;
end_struct

begin_comment
comment|/*  * communication occurs through this data structure, with fields  * cache-aligned according to who are the readers/writers.  *  The queue is an array of memory  (buf) of size buflen (does not change).  The producer uses 'tail' as an index in the queue to indicate the first empty location (ie. after the last byte of data), the consumer uses head to indicate the next byte to consume.  For best performance we should align buffers and packets to multiples of cacheline, but this would explode memory too much. Worst case memory explosion is with 65 byte packets. Memory usage as shown below:  		qpkt-pad 	size	32-16	32-32	32-64	64-64  	64	96	96	96	128 	65	112	128	160	192   An empty queue has head == tail, a full queue will have free space below a threshold.  In our case the queue is large enough and we are non blocking so we can simply drop traffic when the queue approaches a full state.  To simulate bandwidth limitations efficiently, the producer has a second pointer, prod_tail_1, used to check for expired packets. This is done lazily.   */
end_comment

begin_comment
comment|/*  * When sizing the buffer, we must assume some value for the bandwidth.  * INFINITE_BW is supposed to be faster than what we support  */
end_comment

begin_define
define|#
directive|define
name|INFINITE_BW
value|(200ULL*1000000*1000)
end_define

begin_define
define|#
directive|define
name|MY_CACHELINE
value|(128ULL)
end_define

begin_define
define|#
directive|define
name|MAX_PKT
value|(9200)
end_define

begin_comment
comment|/* max packet size */
end_comment

begin_define
define|#
directive|define
name|ALIGN_CACHE
value|__attribute__ ((aligned (MY_CACHELINE)))
end_define

begin_struct
struct|struct
name|_qs
block|{
comment|/* shared queue */
name|uint64_t
name|t0
decl_stmt|;
comment|/* start of times */
name|uint64_t
name|buflen
decl_stmt|;
comment|/* queue length */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* handlers for various options */
name|struct
name|_cfg
name|c_delay
decl_stmt|;
name|struct
name|_cfg
name|c_bw
decl_stmt|;
name|struct
name|_cfg
name|c_loss
decl_stmt|;
comment|/* producer's fields */
name|uint64_t
name|tx
name|ALIGN_CACHE
decl_stmt|;
comment|/* tx counter */
name|uint64_t
name|prod_tail_1
decl_stmt|;
comment|/* head of queue */
name|uint64_t
name|prod_head
decl_stmt|;
comment|/* cached copy */
name|uint64_t
name|prod_tail
decl_stmt|;
comment|/* cached copy */
name|uint64_t
name|prod_drop
decl_stmt|;
comment|/* drop packet count */
name|uint64_t
name|prod_max_gap
decl_stmt|;
comment|/* rx round duration */
name|struct
name|nm_pcap_file
modifier|*
name|pcap
decl_stmt|;
comment|/* the pcap struct */
comment|/* parameters for reading from the netmap port */
name|struct
name|nm_desc
modifier|*
name|src_port
decl_stmt|;
comment|/* netmap descriptor */
specifier|const
name|char
modifier|*
name|prod_ifname
decl_stmt|;
comment|/* interface name or pcap file */
name|struct
name|netmap_ring
modifier|*
name|rxring
decl_stmt|;
comment|/* current ring being handled */
name|uint32_t
name|si
decl_stmt|;
comment|/* ring index */
name|int
name|burst
decl_stmt|;
name|uint32_t
name|rx_qmax
decl_stmt|;
comment|/* stats on max queued */
name|uint64_t
name|qt_qout
decl_stmt|;
comment|/* queue exit time for last packet */
comment|/* 		 * when doing shaping, the software computes and stores here 		 * the time when the most recently queued packet will exit from 		 * the queue. 		 */
name|uint64_t
name|qt_tx
decl_stmt|;
comment|/* delay line exit time for last packet */
comment|/* 		 * The software computes the time at which the most recently 		 * queued packet exits from the queue. 		 * To avoid reordering, the next packet should exit at least 		 * at qt_tx + cur_tt 		 */
comment|/* producer's fields controlling the queueing */
specifier|const
name|char
modifier|*
name|cur_pkt
decl_stmt|;
comment|/* current packet being analysed */
name|uint32_t
name|cur_len
decl_stmt|;
comment|/* length of current packet */
name|uint32_t
name|cur_caplen
decl_stmt|;
comment|/* captured length of current packet */
name|int
name|cur_drop
decl_stmt|;
comment|/* 1 if current  packet should be dropped. */
comment|/* 		 * cur_drop can be set as a result of the loss emulation, 		 * and may need to use the packet size, current time, etc. 		 */
name|uint64_t
name|cur_tt
decl_stmt|;
comment|/* transmission time (ns) for current packet */
comment|/* 		 * The transmission time is how much link time the packet will consume. 		 * should be set by the function that does the bandwidth emulation, 		 * but could also be the result of a function that emulates the 		 * presence of competing traffic, MAC protocols etc. 		 * cur_tt is 0 for links with infinite bandwidth. 		 */
name|uint64_t
name|cur_delay
decl_stmt|;
comment|/* delay (ns) for current packet from c_delay.run() */
comment|/* 		 * this should be set by the function that computes the extra delay 		 * applied to the packet. 		 * The code makes sure that there is no reordering and possibly 		 * bumps the output time as needed. 		 */
comment|/* consumer's fields */
specifier|const
name|char
modifier|*
name|cons_ifname
decl_stmt|;
name|uint64_t
name|rx
name|ALIGN_CACHE
decl_stmt|;
comment|/* rx counter */
name|uint64_t
name|cons_head
decl_stmt|;
comment|/* cached copy */
name|uint64_t
name|cons_tail
decl_stmt|;
comment|/* cached copy */
name|uint64_t
name|cons_now
decl_stmt|;
comment|/* most recent producer timestamp */
name|uint64_t
name|rx_wait
decl_stmt|;
comment|/* stats */
comment|/* shared fields */
specifier|volatile
name|uint64_t
name|_tail
name|ALIGN_CACHE
decl_stmt|;
comment|/* producer writes here */
specifier|volatile
name|uint64_t
name|_head
name|ALIGN_CACHE
decl_stmt|;
comment|/* consumer reads from here */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pipe_args
block|{
name|int
name|wait_link
decl_stmt|;
name|pthread_t
name|cons_tid
decl_stmt|;
comment|/* main thread */
name|pthread_t
name|prod_tid
decl_stmt|;
comment|/* producer thread */
comment|/* Affinity: */
name|int
name|cons_core
decl_stmt|;
comment|/* core for cons() */
name|int
name|prod_core
decl_stmt|;
comment|/* core for prod() */
name|struct
name|nm_desc
modifier|*
name|pa
decl_stmt|;
comment|/* netmap descriptor */
name|struct
name|nm_desc
modifier|*
name|pb
decl_stmt|;
name|struct
name|_qs
name|q
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NS_IN_S
value|(1000000000ULL)
end_define

begin_comment
comment|// nanoseconds
end_comment

begin_define
define|#
directive|define
name|TIME_UNITS
value|NS_IN_S
end_define

begin_comment
comment|/* set the thread affinity. */
end_comment

begin_function
specifier|static
name|int
name|setaffinity
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|cpuset_t
name|cpumask
decl_stmt|;
name|struct
name|sched_param
name|p
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Set thread affinity affinity.*/
name|CPU_ZERO
argument_list|(
operator|&
name|cpumask
argument_list|)
expr_stmt|;
name|CPU_SET
argument_list|(
name|i
argument_list|,
operator|&
name|cpumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|pthread_setaffinity_np
argument_list|(
name|pthread_self
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
argument_list|,
operator|&
name|cpumask
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|WWW
argument_list|(
literal|"Unable to set affinity: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
operator|-
literal|10
argument_list|)
condition|)
block|{
empty_stmt|;
comment|// XXX not meaningful
name|WWW
argument_list|(
literal|"Unable to set priority: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|sched_priority
operator|=
literal|10
expr_stmt|;
comment|// 99 on linux ?
comment|// use SCHED_RR or SCHED_FIFO
if|if
condition|(
name|sched_setscheduler
argument_list|(
literal|0
argument_list|,
name|SCHED_RR
argument_list|,
operator|&
name|p
argument_list|)
condition|)
block|{
name|WWW
argument_list|(
literal|"Unable to set scheduler: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * set the timestamp from the clock, subtract t0  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_tns_now
parameter_list|(
name|uint64_t
modifier|*
name|now
parameter_list|,
name|uint64_t
name|t0
parameter_list|)
block|{
name|struct
name|timespec
name|t
decl_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
comment|// XXX precise on FreeBSD ?
operator|*
name|now
operator|=
call|(
name|uint64_t
call|)
argument_list|(
name|t
operator|.
name|tv_nsec
operator|+
name|NS_IN_S
operator|*
name|t
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
operator|*
name|now
operator|-=
name|t0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* compare two timestamps */
end_comment

begin_function
specifier|static
specifier|inline
name|int64_t
name|ts_cmp
parameter_list|(
name|uint64_t
name|a
parameter_list|,
name|uint64_t
name|b
parameter_list|)
block|{
return|return
call|(
name|int64_t
call|)
argument_list|(
name|a
operator|-
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* create a packet descriptor */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|q_pkt
modifier|*
name|pkt_at
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|uint64_t
name|ofs
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|q_pkt
operator|*
operator|)
operator|(
name|q
operator|->
name|buf
operator|+
name|ofs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * we have already checked for room and prepared p->next  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|enq
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|q_pkt
modifier|*
name|p
init|=
name|pkt_at
argument_list|(
name|q
argument_list|,
name|q
operator|->
name|prod_tail
argument_list|)
decl_stmt|;
comment|/* hopefully prefetch has been done ahead */
name|nm_pkt_copy
argument_list|(
name|q
operator|->
name|cur_pkt
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|,
name|q
operator|->
name|cur_caplen
argument_list|)
expr_stmt|;
name|p
operator|->
name|pktlen
operator|=
name|q
operator|->
name|cur_len
expr_stmt|;
name|p
operator|->
name|pt_qout
operator|=
name|q
operator|->
name|qt_qout
expr_stmt|;
name|p
operator|->
name|pt_tx
operator|=
name|q
operator|->
name|qt_tx
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|q
operator|->
name|prod_tail
operator|+
name|pad
argument_list|(
name|q
operator|->
name|cur_len
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|q_pkt
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"enqueue len %d at %d new tail %ld qout %.6f tx %.6f"
argument_list|,
name|q
operator|->
name|cur_len
argument_list|,
operator|(
name|int
operator|)
name|q
operator|->
name|prod_tail
argument_list|,
name|p
operator|->
name|next
argument_list|,
literal|1e-9
operator|*
name|p
operator|->
name|pt_qout
argument_list|,
literal|1e-9
operator|*
name|p
operator|->
name|pt_tx
argument_list|)
expr_stmt|;
name|q
operator|->
name|prod_tail
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|tx
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * simple handler for parameters not supplied  */
end_comment

begin_function
specifier|static
name|int
name|null_run_fn
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|cfg
parameter_list|)
block|{
operator|(
name|void
operator|)
name|q
expr_stmt|;
operator|(
name|void
operator|)
name|cfg
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * put packet data into the buffer.  * We read from the mmapped pcap file, construct header, copy  * the captured length of the packet and pad with zeroes.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|pcap_prod
parameter_list|(
name|void
modifier|*
name|_pa
parameter_list|)
block|{
name|struct
name|pipe_args
modifier|*
name|pa
init|=
name|_pa
decl_stmt|;
name|struct
name|_qs
modifier|*
name|q
init|=
operator|&
name|pa
operator|->
name|q
decl_stmt|;
name|struct
name|nm_pcap_file
modifier|*
name|pf
init|=
name|q
operator|->
name|pcap
decl_stmt|;
comment|/* already opened by readpcap */
name|uint32_t
name|loops
decl_stmt|,
name|i
decl_stmt|,
name|tot_pkts
decl_stmt|;
comment|/* data plus the loop record */
name|uint64_t
name|need
decl_stmt|;
name|uint64_t
name|t_tx
decl_stmt|,
name|tt
decl_stmt|,
name|last_ts
decl_stmt|;
comment|/* last timestamp from trace */
comment|/*      * For speed we make sure the trace is at least some 1000 packets,      * so we may need to loop the trace more than once (for short traces)      */
name|loops
operator|=
operator|(
literal|1
operator|+
literal|10000
operator|/
name|pf
operator|->
name|tot_pkt
operator|)
expr_stmt|;
name|tot_pkts
operator|=
name|loops
operator|*
name|pf
operator|->
name|tot_pkt
expr_stmt|;
name|need
operator|=
name|loops
operator|*
name|pf
operator|->
name|tot_bytes_rounded
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|q_pkt
argument_list|)
expr_stmt|;
name|q
operator|->
name|buf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|need
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"alloc %ld bytes for queue failed, exiting"
argument_list|,
operator|(
name|_P64
operator|)
name|need
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|q
operator|->
name|prod_head
operator|=
name|q
operator|->
name|prod_tail
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|buflen
operator|=
name|need
expr_stmt|;
name|pf
operator|->
name|cur
operator|=
name|pf
operator|->
name|data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_file_header
argument_list|)
expr_stmt|;
name|pf
operator|->
name|err
operator|=
literal|0
expr_stmt|;
name|ED
argument_list|(
literal|"--- start create %lu packets at tail %d"
argument_list|,
operator|(
name|u_long
operator|)
name|tot_pkts
argument_list|,
operator|(
name|int
operator|)
name|q
operator|->
name|prod_tail
argument_list|)
expr_stmt|;
name|last_ts
operator|=
name|pf
operator|->
name|first_ts
expr_stmt|;
comment|/* beginning of the trace */
name|q
operator|->
name|qt_qout
operator|=
literal|0
expr_stmt|;
comment|/* first packet out of the queue */
for|for
control|(
name|loops
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tot_pkts
operator|&&
operator|!
name|do_abort
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|next_pkt
decl_stmt|;
comment|/* in the pcap buffer */
name|uint64_t
name|cur_ts
decl_stmt|;
comment|/* read values from the pcap buffer */
name|cur_ts
operator|=
name|read_next_info
argument_list|(
name|pf
argument_list|,
literal|4
argument_list|)
operator|*
name|NS_SCALE
operator|+
name|read_next_info
argument_list|(
name|pf
argument_list|,
literal|4
argument_list|)
operator|*
name|pf
operator|->
name|resolution
expr_stmt|;
name|q
operator|->
name|cur_caplen
operator|=
name|read_next_info
argument_list|(
name|pf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|q
operator|->
name|cur_len
operator|=
name|read_next_info
argument_list|(
name|pf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|next_pkt
operator|=
name|pf
operator|->
name|cur
operator|+
name|q
operator|->
name|cur_caplen
expr_stmt|;
comment|/* prepare fields in q for the generator */
name|q
operator|->
name|cur_pkt
operator|=
name|pf
operator|->
name|cur
expr_stmt|;
comment|/* initial estimate of tx time */
name|q
operator|->
name|cur_tt
operator|=
name|cur_ts
operator|-
name|last_ts
expr_stmt|;
comment|// -pf->first_ts + loops * pf->total_tx_time - last_ts;
if|if
condition|(
operator|(
name|i
operator|%
name|pf
operator|->
name|tot_pkt
operator|)
operator|==
literal|0
condition|)
name|ED
argument_list|(
literal|"insert %5d len %lu cur_tt %.6f"
argument_list|,
name|i
argument_list|,
operator|(
name|u_long
operator|)
name|q
operator|->
name|cur_len
argument_list|,
literal|1e-9
operator|*
name|q
operator|->
name|cur_tt
argument_list|)
expr_stmt|;
comment|/* prepare for next iteration */
name|pf
operator|->
name|cur
operator|=
name|next_pkt
expr_stmt|;
name|last_ts
operator|=
name|cur_ts
expr_stmt|;
if|if
condition|(
name|next_pkt
operator|==
name|pf
operator|->
name|lim
condition|)
block|{
comment|//last pkt
name|pf
operator|->
name|cur
operator|=
name|pf
operator|->
name|data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_file_header
argument_list|)
expr_stmt|;
name|last_ts
operator|=
name|pf
operator|->
name|first_ts
expr_stmt|;
comment|/* beginning of the trace */
name|loops
operator|++
expr_stmt|;
block|}
name|q
operator|->
name|c_loss
operator|.
name|run
argument_list|(
name|q
argument_list|,
operator|&
name|q
operator|->
name|c_loss
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|cur_drop
condition|)
continue|continue;
name|q
operator|->
name|c_bw
operator|.
name|run
argument_list|(
name|q
argument_list|,
operator|&
name|q
operator|->
name|c_bw
argument_list|)
expr_stmt|;
name|tt
operator|=
name|q
operator|->
name|cur_tt
expr_stmt|;
name|q
operator|->
name|qt_qout
operator|+=
name|tt
expr_stmt|;
if|#
directive|if
literal|0
block|if (drop_after(q)) 	    continue;
endif|#
directive|endif
name|q
operator|->
name|c_delay
operator|.
name|run
argument_list|(
name|q
argument_list|,
operator|&
name|q
operator|->
name|c_delay
argument_list|)
expr_stmt|;
comment|/* compute delay */
name|t_tx
operator|=
name|q
operator|->
name|qt_qout
operator|+
name|q
operator|->
name|cur_delay
expr_stmt|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"tt %ld qout %ld tx %ld qt_tx %ld"
argument_list|,
name|tt
argument_list|,
name|q
operator|->
name|qt_qout
argument_list|,
name|t_tx
argument_list|,
name|q
operator|->
name|qt_tx
argument_list|)
expr_stmt|;
comment|/* insure no reordering and spacing by transmission time */
name|q
operator|->
name|qt_tx
operator|=
operator|(
name|t_tx
operator|>=
name|q
operator|->
name|qt_tx
operator|+
name|tt
operator|)
condition|?
name|t_tx
else|:
name|q
operator|->
name|qt_tx
operator|+
name|tt
expr_stmt|;
name|enq
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|tx
operator|++
expr_stmt|;
name|ND
argument_list|(
literal|"ins %d q->prod_tail = %lu"
argument_list|,
operator|(
name|int
operator|)
name|insert
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|q
operator|->
name|prod_tail
argument_list|)
expr_stmt|;
block|}
comment|/* loop marker ? */
name|ED
argument_list|(
literal|"done q->prod_tail:%d"
argument_list|,
operator|(
name|int
operator|)
name|q
operator|->
name|prod_tail
argument_list|)
expr_stmt|;
name|q
operator|->
name|_tail
operator|=
name|q
operator|->
name|prod_tail
expr_stmt|;
comment|/* publish */
return|return
name|NULL
return|;
name|fail
label|:
if|if
condition|(
name|q
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|q
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
name|nm_close
argument_list|(
name|pa
operator|->
name|pb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * the consumer reads from the queue using head,  * advances it every now and then.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|cons
parameter_list|(
name|void
modifier|*
name|_pa
parameter_list|)
block|{
name|struct
name|pipe_args
modifier|*
name|pa
init|=
name|_pa
decl_stmt|;
name|struct
name|_qs
modifier|*
name|q
init|=
operator|&
name|pa
operator|->
name|q
decl_stmt|;
name|int
name|pending
init|=
literal|0
decl_stmt|;
name|uint64_t
name|last_ts
init|=
literal|0
decl_stmt|;
comment|/* read the start of times in q->t0 */
name|set_tns_now
argument_list|(
operator|&
name|q
operator|->
name|t0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set the time (cons_now) to clock - q->t0 */
name|set_tns_now
argument_list|(
operator|&
name|q
operator|->
name|cons_now
argument_list|,
name|q
operator|->
name|t0
argument_list|)
expr_stmt|;
name|q
operator|->
name|cons_head
operator|=
name|q
operator|->
name|_head
expr_stmt|;
name|q
operator|->
name|cons_tail
operator|=
name|q
operator|->
name|_tail
expr_stmt|;
while|while
condition|(
operator|!
name|do_abort
condition|)
block|{
comment|/* consumer, infinite */
name|struct
name|q_pkt
modifier|*
name|p
init|=
name|pkt_at
argument_list|(
name|q
argument_list|,
name|q
operator|->
name|cons_head
argument_list|)
decl_stmt|;
name|__builtin_prefetch
argument_list|(
name|q
operator|->
name|buf
operator|+
name|p
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|cons_head
operator|==
name|q
operator|->
name|cons_tail
condition|)
block|{
comment|//reset record
name|ND
argument_list|(
literal|"Transmission restarted"
argument_list|)
expr_stmt|;
comment|/* 	     * add to q->t0 the time for the last packet 	     */
name|q
operator|->
name|t0
operator|+=
name|last_ts
expr_stmt|;
name|q
operator|->
name|cons_head
operator|=
literal|0
expr_stmt|;
comment|//restart from beginning of the queue
continue|continue;
block|}
name|last_ts
operator|=
name|p
operator|->
name|pt_tx
expr_stmt|;
if|if
condition|(
name|ts_cmp
argument_list|(
name|p
operator|->
name|pt_tx
argument_list|,
name|q
operator|->
name|cons_now
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|// packet not ready
name|q
operator|->
name|rx_wait
operator|++
expr_stmt|;
comment|/* the ioctl should be conditional */
name|ioctl
argument_list|(
name|pa
operator|->
name|pb
operator|->
name|fd
argument_list|,
name|NIOCTXSYNC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// XXX just in case
name|pending
operator|=
literal|0
expr_stmt|;
name|usleep
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|set_tns_now
argument_list|(
operator|&
name|q
operator|->
name|cons_now
argument_list|,
name|q
operator|->
name|t0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* XXX copy is inefficient but simple */
name|pending
operator|++
expr_stmt|;
if|if
condition|(
name|nm_inject
argument_list|(
name|pa
operator|->
name|pb
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|,
name|p
operator|->
name|pktlen
argument_list|)
operator|==
literal|0
operator|||
name|pending
operator|>
name|q
operator|->
name|burst
condition|)
block|{
name|RD
argument_list|(
literal|1
argument_list|,
literal|"inject failed len %d now %ld tx %ld h %ld t %ld next %ld"
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|pktlen
argument_list|,
operator|(
name|u_long
operator|)
name|q
operator|->
name|cons_now
argument_list|,
operator|(
name|u_long
operator|)
name|p
operator|->
name|pt_tx
argument_list|,
operator|(
name|u_long
operator|)
name|q
operator|->
name|_head
argument_list|,
operator|(
name|u_long
operator|)
name|q
operator|->
name|_tail
argument_list|,
operator|(
name|u_long
operator|)
name|p
operator|->
name|next
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pa
operator|->
name|pb
operator|->
name|fd
argument_list|,
name|NIOCTXSYNC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pending
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|q
operator|->
name|cons_head
operator|=
name|p
operator|->
name|next
expr_stmt|;
comment|/* drain packets from the queue */
name|q
operator|->
name|rx
operator|++
expr_stmt|;
block|}
name|D
argument_list|(
literal|"exiting on abort"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * In case of pcap file as input, the program acts in 2 different  * phases. It first fill the queue and then starts the cons()  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|nmreplay_main
parameter_list|(
name|void
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|pipe_args
modifier|*
name|a
init|=
name|_a
decl_stmt|;
name|struct
name|_qs
modifier|*
name|q
init|=
operator|&
name|a
operator|->
name|q
decl_stmt|;
specifier|const
name|char
modifier|*
name|cap_fname
init|=
name|q
operator|->
name|prod_ifname
decl_stmt|;
name|setaffinity
argument_list|(
name|a
operator|->
name|cons_core
argument_list|)
expr_stmt|;
name|set_tns_now
argument_list|(
operator|&
name|q
operator|->
name|t0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* starting reference */
if|if
condition|(
name|cap_fname
operator|==
name|NULL
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
name|q
operator|->
name|pcap
operator|=
name|readpcap
argument_list|(
name|cap_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|pcap
operator|==
name|NULL
condition|)
block|{
name|EEE
argument_list|(
literal|"unable to read file %s"
argument_list|,
name|cap_fname
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|pcap_prod
argument_list|(
operator|(
name|void
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
name|destroy_pcap
argument_list|(
name|q
operator|->
name|pcap
argument_list|)
expr_stmt|;
name|q
operator|->
name|pcap
operator|=
name|NULL
expr_stmt|;
name|a
operator|->
name|pb
operator|=
name|nm_open
argument_list|(
name|q
operator|->
name|cons_ifname
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|pb
operator|==
name|NULL
condition|)
block|{
name|EEE
argument_list|(
literal|"cannot open netmap on %s"
argument_list|,
name|q
operator|->
name|cons_ifname
argument_list|)
expr_stmt|;
name|do_abort
operator|=
literal|1
expr_stmt|;
comment|// XXX any better way ?
return|return
name|NULL
return|;
block|}
comment|/* continue as cons() */
name|WWW
argument_list|(
literal|"prepare to send packets"
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|cons
argument_list|(
operator|(
name|void
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
name|EEE
argument_list|(
literal|"exiting on abort"
argument_list|)
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|q
operator|->
name|pcap
operator|!=
name|NULL
condition|)
block|{
name|destroy_pcap
argument_list|(
name|q
operator|->
name|pcap
argument_list|)
expr_stmt|;
block|}
name|do_abort
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sigint_h
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
operator|(
name|void
operator|)
name|sig
expr_stmt|;
comment|/* UNUSED */
name|do_abort
operator|=
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: nmreplay [-v] [-D delay] [-B {[constant,]bps|ether,bps|real,speedup}] [-L loss]\n"
literal|"\t[-b burst] -i ifa-or-pcap-file -i ifb\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---- configuration handling ---- */
end_comment

begin_comment
comment|/*  * support routine: split argument, returns ac and *av.  * av contains two extra entries, a NULL and a pointer  * to the entire string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|split_arg
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
modifier|*
name|_ac
parameter_list|)
block|{
name|char
modifier|*
name|my
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|av
init|=
name|NULL
decl_stmt|,
modifier|*
name|seps
init|=
literal|" \t\r\n,"
decl_stmt|;
name|int
name|l
decl_stmt|,
name|i
decl_stmt|,
name|ac
decl_stmt|;
comment|/* number of entries */
if|if
condition|(
operator|!
name|src
condition|)
return|return
name|NULL
return|;
name|l
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|/* in the first pass we count fields, in the second pass      * we allocate the av[] array and a copy of the string      * and fill av[]. av[ac] = NULL, av[ac+1]      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|ac
operator|=
literal|0
expr_stmt|;
name|ND
argument_list|(
literal|"start pass %d:<%s>"
argument_list|,
name|av
condition|?
literal|1
else|:
literal|0
argument_list|,
name|my
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|l
condition|)
block|{
comment|/* trim leading separator */
while|while
condition|(
name|i
operator|<
name|l
operator|&&
name|strchr
argument_list|(
name|seps
argument_list|,
name|src
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|l
condition|)
break|break;
name|ND
argument_list|(
literal|"   pass %d arg %d:<%s>"
argument_list|,
name|av
condition|?
literal|1
else|:
literal|0
argument_list|,
name|ac
argument_list|,
name|src
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|av
condition|)
comment|/* in the second pass, set the result */
name|av
index|[
name|ac
index|]
operator|=
name|my
operator|+
name|i
expr_stmt|;
name|ac
operator|++
expr_stmt|;
comment|/* skip string */
while|while
condition|(
name|i
operator|<
name|l
operator|&&
operator|!
name|strchr
argument_list|(
name|seps
argument_list|,
name|src
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|av
condition|)
name|my
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* write marker */
block|}
if|if
condition|(
operator|!
name|av
condition|)
block|{
comment|/* end of first pass */
name|ND
argument_list|(
literal|"ac is %d"
argument_list|,
name|ac
argument_list|)
expr_stmt|;
name|av
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|l
operator|+
literal|1
operator|)
operator|+
operator|(
name|ac
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|my
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|av
index|[
name|ac
operator|+
literal|2
index|]
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|my
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|NED
argument_list|(
literal|"%d:<%s>"
argument_list|,
name|i
argument_list|,
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|av
index|[
name|i
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
name|av
index|[
name|i
operator|++
index|]
operator|=
name|my
expr_stmt|;
operator|*
name|_ac
operator|=
name|ac
expr_stmt|;
return|return
name|av
return|;
block|}
end_function

begin_comment
comment|/*  * apply a command against a set of functions,  * install a handler in *dst  */
end_comment

begin_function
specifier|static
name|int
name|cmd_apply
parameter_list|(
specifier|const
name|struct
name|_cfg
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|dst
parameter_list|)
block|{
name|int
name|ac
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
operator|*
name|arg
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
comment|/* no argument may be ok */
if|if
condition|(
name|a
operator|==
name|NULL
operator|||
name|dst
operator|==
name|NULL
condition|)
block|{
name|ED
argument_list|(
literal|"program error - invalid arguments"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|av
operator|=
name|split_arg
argument_list|(
name|arg
argument_list|,
operator|&
name|ac
argument_list|)
expr_stmt|;
if|if
condition|(
name|av
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* error */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|a
index|[
name|i
index|]
operator|.
name|parse
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|_cfg
name|x
init|=
name|a
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|x
operator|.
name|optarg
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|x
operator|.
name|arg
operator|=
name|NULL
expr_stmt|;
name|x
operator|.
name|arg_len
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|x
operator|.
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|x
operator|.
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"apply %s to %s"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|x
operator|.
name|parse
argument_list|(
name|q
argument_list|,
operator|&
name|x
argument_list|,
name|ac
argument_list|,
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|2
condition|)
comment|/* not recognised */
continue|continue;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|ED
argument_list|(
literal|"invalid arguments: need '%s' have '%s'"
argument_list|,
name|errmsg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
name|x
operator|.
name|optarg
operator|=
name|arg
expr_stmt|;
operator|*
name|dst
operator|=
name|x
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ED
argument_list|(
literal|"arguments %s not recognised"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|_cfg
name|delay_cfg
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|_cfg
name|bw_cfg
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|_cfg
name|loss_cfg
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|uint64_t
name|parse_bw
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * prodcons [options]  * accept separate sets of arguments for the two directions  *  */
end_comment

begin_function
specifier|static
name|void
name|add_to
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|v
parameter_list|,
name|int
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
for|for
control|(
init|;
name|l
operator|>
literal|0
operator|&&
operator|*
name|v
operator|!=
name|NULL
condition|;
name|l
operator|--
operator|,
name|v
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|ED
argument_list|(
literal|"%s %s"
argument_list|,
name|msg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|v
operator|=
name|arg
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|N_OPTS
value|1
name|struct
name|pipe_args
name|bp
index|[
name|N_OPTS
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
index|[
name|N_OPTS
index|]
decl_stmt|,
modifier|*
name|b
index|[
name|N_OPTS
index|]
decl_stmt|,
modifier|*
name|l
index|[
name|N_OPTS
index|]
decl_stmt|,
modifier|*
name|q
index|[
name|N_OPTS
index|]
decl_stmt|,
modifier|*
name|ifname
index|[
name|N_OPTS
index|]
decl_stmt|,
modifier|*
name|m
index|[
name|N_OPTS
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|pcap_file
index|[
name|N_OPTS
index|]
decl_stmt|;
name|int
name|cores
index|[
literal|4
index|]
init|=
block|{
literal|2
block|,
literal|8
block|,
literal|4
block|,
literal|10
block|}
decl_stmt|;
comment|/* default values */
name|bzero
argument_list|(
operator|&
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* all data initially go here */
name|bzero
argument_list|(
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|q
argument_list|,
sizeof|sizeof
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pcap_file
argument_list|,
sizeof|sizeof
argument_list|(
name|pcap_file
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set default values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_OPTS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|_qs
modifier|*
name|q
init|=
operator|&
name|bp
index|[
name|i
index|]
operator|.
name|q
decl_stmt|;
name|q
operator|->
name|burst
operator|=
literal|128
expr_stmt|;
name|q
operator|->
name|c_delay
operator|.
name|optarg
operator|=
literal|"0"
expr_stmt|;
name|q
operator|->
name|c_delay
operator|.
name|run
operator|=
name|null_run_fn
expr_stmt|;
name|q
operator|->
name|c_loss
operator|.
name|optarg
operator|=
literal|"0"
expr_stmt|;
name|q
operator|->
name|c_loss
operator|.
name|run
operator|=
name|null_run_fn
expr_stmt|;
name|q
operator|->
name|c_bw
operator|.
name|optarg
operator|=
literal|"0"
expr_stmt|;
name|q
operator|->
name|c_bw
operator|.
name|run
operator|=
name|null_run_fn
expr_stmt|;
block|}
comment|// Options:
comment|// B	bandwidth in bps
comment|// D	delay in seconds
comment|// L	loss probability
comment|// f	pcap file
comment|// i	interface name
comment|// w	wait link
comment|// b	batch size
comment|// v	verbose
comment|// C	cpu placement
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"B:C:D:L:b:f:i:vw:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
default|default:
name|D
argument_list|(
literal|"bad option %c %s"
argument_list|,
name|ch
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* CPU placement, up to 4 arguments */
block|{
name|int
name|ac
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
init|=
name|split_arg
argument_list|(
name|optarg
argument_list|,
operator|&
name|ac
argument_list|)
decl_stmt|;
if|if
condition|(
name|ac
operator|==
literal|1
condition|)
block|{
comment|/* sequential after the first */
name|cores
index|[
literal|0
index|]
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cores
index|[
literal|1
index|]
operator|=
name|cores
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|cores
index|[
literal|2
index|]
operator|=
name|cores
index|[
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|cores
index|[
literal|3
index|]
operator|=
name|cores
index|[
literal|2
index|]
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ac
operator|==
literal|2
condition|)
block|{
comment|/* two sequential pairs */
name|cores
index|[
literal|0
index|]
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cores
index|[
literal|1
index|]
operator|=
name|cores
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|cores
index|[
literal|2
index|]
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cores
index|[
literal|3
index|]
operator|=
name|cores
index|[
literal|2
index|]
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ac
operator|==
literal|4
condition|)
block|{
comment|/* four values */
name|cores
index|[
literal|0
index|]
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cores
index|[
literal|1
index|]
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cores
index|[
literal|2
index|]
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|cores
index|[
literal|3
index|]
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ED
argument_list|(
literal|" -C accepts 1, 2 or 4 comma separated arguments"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|av
condition|)
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'B'
case|:
comment|/* bandwidth in bps */
name|add_to
argument_list|(
name|b
argument_list|,
name|N_OPTS
argument_list|,
name|optarg
argument_list|,
literal|"-B too many times"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* delay in seconds (float) */
name|add_to
argument_list|(
name|d
argument_list|,
name|N_OPTS
argument_list|,
name|optarg
argument_list|,
literal|"-D too many times"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* loss probability */
name|add_to
argument_list|(
name|l
argument_list|,
name|N_OPTS
argument_list|,
name|optarg
argument_list|,
literal|"-L too many times"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* burst */
name|bp
index|[
literal|0
index|]
operator|.
name|q
operator|.
name|burst
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* pcap_file */
name|add_to
argument_list|(
name|pcap_file
argument_list|,
name|N_OPTS
argument_list|,
name|optarg
argument_list|,
literal|"-f too many times"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* interface */
name|add_to
argument_list|(
name|ifname
argument_list|,
name|N_OPTS
argument_list|,
name|optarg
argument_list|,
literal|"-i too many times"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|bp
index|[
literal|0
index|]
operator|.
name|wait_link
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* 	 * consistency checks for common arguments 	 * if pcap file has been provided we need just one interface, two otherwise 	 */
if|if
condition|(
operator|!
name|pcap_file
index|[
literal|0
index|]
condition|)
block|{
name|ED
argument_list|(
literal|"missing pcap file"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ifname
index|[
literal|0
index|]
condition|)
block|{
name|ED
argument_list|(
literal|"missing interface"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|.
name|q
operator|.
name|burst
operator|<
literal|1
operator|||
name|bp
index|[
literal|0
index|]
operator|.
name|q
operator|.
name|burst
operator|>
literal|8192
condition|)
block|{
name|WWW
argument_list|(
literal|"invalid burst %d, set to 1024"
argument_list|,
name|bp
index|[
literal|0
index|]
operator|.
name|q
operator|.
name|burst
argument_list|)
expr_stmt|;
name|bp
index|[
literal|0
index|]
operator|.
name|q
operator|.
name|burst
operator|=
literal|1024
expr_stmt|;
comment|// XXX 128 is probably better
block|}
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|.
name|wait_link
operator|>
literal|100
condition|)
block|{
name|ED
argument_list|(
literal|"invalid wait_link %d, set to 4"
argument_list|,
name|bp
index|[
literal|0
index|]
operator|.
name|wait_link
argument_list|)
expr_stmt|;
name|bp
index|[
literal|0
index|]
operator|.
name|wait_link
operator|=
literal|4
expr_stmt|;
block|}
name|bp
index|[
literal|0
index|]
operator|.
name|q
operator|.
name|prod_ifname
operator|=
name|pcap_file
index|[
literal|0
index|]
expr_stmt|;
name|bp
index|[
literal|0
index|]
operator|.
name|q
operator|.
name|cons_ifname
operator|=
name|ifname
index|[
literal|0
index|]
expr_stmt|;
comment|/* assign cores. prod and cons work better if on the same HT */
name|bp
index|[
literal|0
index|]
operator|.
name|cons_core
operator|=
name|cores
index|[
literal|0
index|]
expr_stmt|;
name|bp
index|[
literal|0
index|]
operator|.
name|prod_core
operator|=
name|cores
index|[
literal|1
index|]
expr_stmt|;
name|ED
argument_list|(
literal|"running on cores %d %d %d %d"
argument_list|,
name|cores
index|[
literal|0
index|]
argument_list|,
name|cores
index|[
literal|1
index|]
argument_list|,
name|cores
index|[
literal|2
index|]
argument_list|,
name|cores
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* apply commands */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_OPTS
condition|;
name|i
operator|++
control|)
block|{
comment|/* once per queue */
name|struct
name|_qs
modifier|*
name|q
init|=
operator|&
name|bp
index|[
name|i
index|]
operator|.
name|q
decl_stmt|;
name|err
operator|+=
name|cmd_apply
argument_list|(
name|delay_cfg
argument_list|,
name|d
index|[
name|i
index|]
argument_list|,
name|q
argument_list|,
operator|&
name|q
operator|->
name|c_delay
argument_list|)
expr_stmt|;
name|err
operator|+=
name|cmd_apply
argument_list|(
name|bw_cfg
argument_list|,
name|b
index|[
name|i
index|]
argument_list|,
name|q
argument_list|,
operator|&
name|q
operator|->
name|c_bw
argument_list|)
expr_stmt|;
name|err
operator|+=
name|cmd_apply
argument_list|(
name|loss_cfg
argument_list|,
name|l
index|[
name|i
index|]
argument_list|,
name|q
argument_list|,
operator|&
name|q
operator|->
name|c_loss
argument_list|)
expr_stmt|;
block|}
name|pthread_create
argument_list|(
operator|&
name|bp
index|[
literal|0
index|]
operator|.
name|cons_tid
argument_list|,
name|NULL
argument_list|,
name|nmreplay_main
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|bp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint_h
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|do_abort
condition|)
block|{
name|struct
name|_qs
name|olda
init|=
name|bp
index|[
literal|0
index|]
operator|.
name|q
decl_stmt|;
name|struct
name|_qs
modifier|*
name|q0
init|=
operator|&
name|bp
index|[
literal|0
index|]
operator|.
name|q
decl_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ED
argument_list|(
literal|"%ld -> %ld maxq %d round %ld"
argument_list|,
call|(
name|_P64
call|)
argument_list|(
name|q0
operator|->
name|rx
operator|-
name|olda
operator|.
name|rx
argument_list|)
argument_list|,
call|(
name|_P64
call|)
argument_list|(
name|q0
operator|->
name|tx
operator|-
name|olda
operator|.
name|tx
argument_list|)
argument_list|,
name|q0
operator|->
name|rx_qmax
argument_list|,
operator|(
name|_P64
operator|)
name|q0
operator|->
name|prod_max_gap
argument_list|)
expr_stmt|;
name|ED
argument_list|(
literal|"plr nominal %le actual %le"
argument_list|,
call|(
name|double
call|)
argument_list|(
name|q0
operator|->
name|c_loss
operator|.
name|d
index|[
literal|0
index|]
argument_list|)
operator|/
operator|(
literal|1
operator|<<
literal|24
operator|)
argument_list|,
name|q0
operator|->
name|c_loss
operator|.
name|d
index|[
literal|1
index|]
operator|==
literal|0
condition|?
literal|0
else|:
call|(
name|double
call|)
argument_list|(
name|q0
operator|->
name|c_loss
operator|.
name|d
index|[
literal|2
index|]
argument_list|)
operator|/
name|q0
operator|->
name|c_loss
operator|.
name|d
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bp
index|[
literal|0
index|]
operator|.
name|q
operator|.
name|rx_qmax
operator|=
operator|(
name|bp
index|[
literal|0
index|]
operator|.
name|q
operator|.
name|rx_qmax
operator|*
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
comment|// ewma
name|bp
index|[
literal|0
index|]
operator|.
name|q
operator|.
name|prod_max_gap
operator|=
operator|(
name|bp
index|[
literal|0
index|]
operator|.
name|q
operator|.
name|prod_max_gap
operator|*
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
comment|// ewma
block|}
name|D
argument_list|(
literal|"exiting on abort"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* conversion factor for numbers.  * Each entry has a set of characters and conversion factor,  * the first entry should have an empty string and default factor,  * the final entry has s = NULL.  */
end_comment

begin_struct
struct|struct
name|_sm
block|{
comment|/* string and multiplier */
name|char
modifier|*
name|s
decl_stmt|;
name|double
name|m
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * parse a generic value  */
end_comment

begin_function
specifier|static
name|double
name|parse_gen
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
specifier|const
name|struct
name|_sm
modifier|*
name|conv
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|double
name|d
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|int
name|dummy
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|NULL
condition|)
name|err
operator|=
operator|&
name|dummy
expr_stmt|;
operator|*
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|d
operator|=
name|strtod
argument_list|(
name|arg
argument_list|,
operator|&
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|arg
condition|)
block|{
comment|/* no value */
name|ED
argument_list|(
literal|"bad argument %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* special case, no conversion */
if|if
condition|(
name|conv
operator|==
name|NULL
operator|&&
operator|*
name|ep
operator|==
literal|'\0'
condition|)
goto|goto
name|done
goto|;
name|ND
argument_list|(
literal|"checking %s [%s]"
argument_list|,
name|arg
argument_list|,
name|ep
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|conv
operator|->
name|s
condition|;
name|conv
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|conv
operator|->
name|s
argument_list|,
operator|*
name|ep
argument_list|)
condition|)
goto|goto
name|done
goto|;
block|}
name|error
label|:
operator|*
name|err
operator|=
literal|1
expr_stmt|;
comment|/* unrecognised */
return|return
literal|0
return|;
name|done
label|:
if|if
condition|(
name|conv
condition|)
block|{
name|ND
argument_list|(
literal|"scale is %s %lf"
argument_list|,
name|conv
operator|->
name|s
argument_list|,
name|conv
operator|->
name|m
argument_list|)
expr_stmt|;
name|d
operator|*=
name|conv
operator|->
name|m
expr_stmt|;
comment|/* apply default conversion */
block|}
name|ND
argument_list|(
literal|"returning %lf"
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_define
define|#
directive|define
name|U_PARSE_ERR
value|~(0ULL)
end_define

begin_comment
comment|/* returns a value in nanoseconds */
end_comment

begin_function
specifier|static
name|uint64_t
name|parse_time
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|_sm
name|a
index|[]
init|=
block|{
block|{
literal|""
block|,
literal|1000000000
comment|/* seconds */
block|}
block|,
block|{
literal|"n"
block|,
literal|1
comment|/* nanoseconds */
block|}
block|,
block|{
literal|"u"
block|,
literal|1000
comment|/* microseconds */
block|}
block|,
block|{
literal|"m"
block|,
literal|1000000
comment|/* milliseconds */
block|}
block|,
block|{
literal|"s"
block|,
literal|1000000000
comment|/* seconds */
block|}
block|,
block|{
name|NULL
block|,
literal|0
comment|/* seconds */
block|}
block|}
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|ret
init|=
operator|(
name|uint64_t
operator|)
name|parse_gen
argument_list|(
name|arg
argument_list|,
name|a
argument_list|,
operator|&
name|err
argument_list|)
decl_stmt|;
return|return
name|err
condition|?
name|U_PARSE_ERR
else|:
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * parse a bandwidth, returns value in bps or U_PARSE_ERR if error.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|parse_bw
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|_sm
name|a
index|[]
init|=
block|{
block|{
literal|""
block|,
literal|1
block|}
block|,
block|{
literal|"kK"
block|,
literal|1000
block|}
block|,
block|{
literal|"mM"
block|,
literal|1000000
block|}
block|,
block|{
literal|"gG"
block|,
literal|1000000000
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|ret
init|=
operator|(
name|uint64_t
operator|)
name|parse_gen
argument_list|(
name|arg
argument_list|,
name|a
argument_list|,
operator|&
name|err
argument_list|)
decl_stmt|;
return|return
name|err
condition|?
name|U_PARSE_ERR
else|:
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * For some function we need random bits.  * This is a wrapper to whatever function you want that returns  * 24 useful random bits.  */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/* log, exp etc. */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|my_random24
parameter_list|(
name|void
parameter_list|)
comment|/* 24 useful bits */
block|{
return|return
name|random
argument_list|()
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-------------- user-configuration -----------------*/
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* start of comment block */
end_comment

begin_endif
unit|Here we place the functions to implement the various features of the system. For each feature one should define a struct _cfg (see at the beginning for definition) that refers a *_parse() function to extract values from the command line, and a *_run() function that is invoked on each packet to implement the desired function.  Examples of the two functions are below. In general:  - the *_parse() function takes argc/argv[], matches the function   name in argv[0], extracts the operating parameters, allocates memory   if needed, and stores them in the struct _cfg.   Return value is 2 if argv[0] is not recosnised, 1 if there is an   error in the arguments, 0 if all ok.    On the command line, argv[] is a single, comma separated argument   that follow the specific option eg -D constant,20ms    struct _cfg has some preallocated space (e.g an array of uint64_t) so simple   function can use that without having to allocate memory.  - the *_run() function takes struct _q *q and struct _cfg *cfg as arguments.   *q contains all the informatio that may be possibly needed, including   those on the packet currently under processing.   The basic values are the following:  	char *	 cur_pkt 	points to the current packet (linear buffer) 	uint32_t cur_len;	length of the current packet 		the functions are not supposed to modify these values  	int	 cur_drop;	true if current packet must be dropped. 		Must be set to non-zero by the loss emulation function  	uint64_t cur_delay;	delay in nanoseconds for the current packet 		Must be set by the delay emulation function     More sophisticated functions may need to access other fields in *q,    see the structure description for that.  When implementing a new function for a feature (e.g. for delay, bandwidth, loss...) the struct _cfg should be added to the array that contains all possible options.  		--- Specific notes ---  DELAY emulation		-D option_arguments      If the option is not supplied, the system applies 0 extra delay      The resolution for times is 1ns, the precision is load dependent and     generally in the order of 20-50us.     Times are in nanoseconds, can be followed by a character specifying     a different unit e.g.  	n	nanoseconds 	u	microseconds 	m	milliseconds 	s	seconds      Currently implemented options:      constant,t		constant delay equal to t      uniform,tmin,tmax	uniform delay between tmin and tmax      exp,tavg,tmin	exponential distribution with average tavg 			and minimum tmin (corresponds to an exponential 			distribution with argument 1/(tavg-tmin) )   LOSS emulation		-L option_arguments      Loss is expressed as packet or bit error rate, which is an absolute     number between 0 and 1 (typically small).      Currently implemented options      plr,p		uniform packet loss rate p, independent 			of packet size      burst,p,lmin,lmax 	burst loss with burst probability p and 			burst length uniformly distributed between 			lmin and lmax      ber,p		uniformly distributed bit error rate p, 			so actual loss prob. depends on size.  BANDWIDTH emulation	-B option_arguments      Bandwidths are expressed in bits per second, can be followed by a     character specifying a different unit e.g.  	b/B	bits per second 	k/K	kbits/s (10^3 bits/s) 	m/M	mbits/s (10^6 bits/s) 	g/G	gbits/s (10^9 bits/s)      Currently implemented options      const,b		constant bw, excluding mac framing     ether,b		constant bw, including ethernet framing 			(20 bytes framing + 4 bytes crc)     real,[scale]	use real time, optionally with a scaling factor
endif|#
directive|endif
end_endif

begin_comment
comment|/* end of comment block */
end_comment

begin_comment
comment|/*  * Configuration options for delay  */
end_comment

begin_comment
comment|/* constant delay, also accepts just a number */
end_comment

begin_function
specifier|static
name|int
name|const_delay_parse
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|dst
parameter_list|,
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
name|uint64_t
name|delay
decl_stmt|;
operator|(
name|void
operator|)
name|q
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"const"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
operator|&&
name|ac
operator|>
literal|1
condition|)
return|return
literal|2
return|;
comment|/* unrecognised */
if|if
condition|(
name|ac
operator|>
literal|2
condition|)
return|return
literal|1
return|;
comment|/* error */
name|delay
operator|=
name|parse_time
argument_list|(
name|av
index|[
name|ac
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|==
name|U_PARSE_ERR
condition|)
return|return
literal|1
return|;
comment|/* error */
name|dst
operator|->
name|d
index|[
literal|0
index|]
operator|=
name|delay
expr_stmt|;
return|return
literal|0
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/* runtime function, store the delay into q->cur_delay */
end_comment

begin_function
specifier|static
name|int
name|const_delay_run
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|arg
parameter_list|)
block|{
name|q
operator|->
name|cur_delay
operator|=
name|arg
operator|->
name|d
index|[
literal|0
index|]
expr_stmt|;
comment|/* the delay */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uniform_delay_parse
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|dst
parameter_list|,
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
name|uint64_t
name|dmin
decl_stmt|,
name|dmax
decl_stmt|;
operator|(
name|void
operator|)
name|q
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"uniform"
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|2
return|;
comment|/* not recognised */
if|if
condition|(
name|ac
operator|!=
literal|3
condition|)
return|return
literal|1
return|;
comment|/* error */
name|dmin
operator|=
name|parse_time
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dmax
operator|=
name|parse_time
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmin
operator|==
name|U_PARSE_ERR
operator|||
name|dmax
operator|==
name|U_PARSE_ERR
operator|||
name|dmin
operator|>
name|dmax
condition|)
return|return
literal|1
return|;
name|D
argument_list|(
literal|"dmin %ld dmax %ld"
argument_list|,
operator|(
name|_P64
operator|)
name|dmin
argument_list|,
operator|(
name|_P64
operator|)
name|dmax
argument_list|)
expr_stmt|;
name|dst
operator|->
name|d
index|[
literal|0
index|]
operator|=
name|dmin
expr_stmt|;
name|dst
operator|->
name|d
index|[
literal|1
index|]
operator|=
name|dmax
expr_stmt|;
name|dst
operator|->
name|d
index|[
literal|2
index|]
operator|=
name|dmax
operator|-
name|dmin
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uniform_delay_run
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|arg
parameter_list|)
block|{
name|uint64_t
name|x
init|=
name|my_random24
argument_list|()
decl_stmt|;
name|q
operator|->
name|cur_delay
operator|=
name|arg
operator|->
name|d
index|[
literal|0
index|]
operator|+
operator|(
operator|(
name|arg
operator|->
name|d
index|[
literal|2
index|]
operator|*
name|x
operator|)
operator|>>
literal|24
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* COMPUTE_STATS */
endif|#
directive|endif
comment|/* COMPUTE_STATS */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * exponential delay: Prob(delay = x) = exp(-x/d_av)  * gives a delay between 0 and infinity with average d_av  * The cumulative function is 1 - d_av exp(-x/d_av)  *  * The inverse function generates a uniform random number p in 0..1  * and generates delay = (d_av-d_min) * -ln(1-p) + d_min  *  * To speed up behaviour at runtime we tabulate the values  */
end_comment

begin_function
specifier|static
name|int
name|exp_delay_parse
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|dst
parameter_list|,
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
define|#
directive|define
name|PTS_D_EXP
value|512
name|uint64_t
name|i
decl_stmt|,
name|d_av
decl_stmt|,
name|d_min
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/*table of values */
operator|(
name|void
operator|)
name|q
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"exp"
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|2
return|;
comment|/* not recognised */
if|if
condition|(
name|ac
operator|!=
literal|3
condition|)
return|return
literal|1
return|;
comment|/* error */
name|d_av
operator|=
name|parse_time
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|d_min
operator|=
name|parse_time
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_av
operator|==
name|U_PARSE_ERR
operator|||
name|d_min
operator|==
name|U_PARSE_ERR
operator|||
name|d_av
operator|<
name|d_min
condition|)
return|return
literal|1
return|;
comment|/* error */
name|d_av
operator|-=
name|d_min
expr_stmt|;
name|dst
operator|->
name|arg_len
operator|=
name|PTS_D_EXP
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|dst
operator|->
name|arg
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|dst
operator|->
name|arg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|arg
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* no memory */
name|t
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|dst
operator|->
name|arg
expr_stmt|;
comment|/* tabulate -ln(1-n)*delay  for n in 0..1 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PTS_D_EXP
condition|;
name|i
operator|++
control|)
block|{
name|double
name|d
init|=
operator|-
name|log2
argument_list|(
call|(
name|double
call|)
argument_list|(
name|PTS_D_EXP
operator|-
name|i
argument_list|)
operator|/
name|PTS_D_EXP
argument_list|)
operator|*
name|d_av
operator|+
name|d_min
decl_stmt|;
name|t
index|[
name|i
index|]
operator|=
operator|(
name|uint64_t
operator|)
name|d
expr_stmt|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"%ld: %le"
argument_list|,
name|i
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|exp_delay_run
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|arg
parameter_list|)
block|{
name|uint64_t
modifier|*
name|t
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|arg
operator|->
name|arg
decl_stmt|;
name|q
operator|->
name|cur_delay
operator|=
name|t
index|[
name|my_random24
argument_list|()
operator|&
operator|(
name|PTS_D_EXP
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|RD
argument_list|(
literal|5
argument_list|,
literal|"delay %lu"
argument_list|,
operator|(
name|_P64
operator|)
name|q
operator|->
name|cur_delay
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* unused arguments in configuration */
end_comment

begin_define
define|#
directive|define
name|_CFG_END
value|NULL, 0, {0}, {0}
end_define

begin_decl_stmt
specifier|static
name|struct
name|_cfg
name|delay_cfg
index|[]
init|=
block|{
block|{
name|const_delay_parse
block|,
name|const_delay_run
block|,
literal|"constant,delay"
block|,
name|_CFG_END
block|}
block|,
block|{
name|uniform_delay_parse
block|,
name|uniform_delay_run
block|,
literal|"uniform,dmin,dmax # dmin<= dmax"
block|,
name|_CFG_END
block|}
block|,
block|{
name|exp_delay_parse
block|,
name|exp_delay_run
block|,
literal|"exp,dmin,davg # dmin<= davg"
block|,
name|_CFG_END
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|_CFG_END
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* standard bandwidth, also accepts just a number */
end_comment

begin_function
specifier|static
name|int
name|const_bw_parse
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|dst
parameter_list|,
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
name|uint64_t
name|bw
decl_stmt|;
operator|(
name|void
operator|)
name|q
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"const"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
operator|&&
name|ac
operator|>
literal|1
condition|)
return|return
literal|2
return|;
comment|/* unrecognised */
if|if
condition|(
name|ac
operator|>
literal|2
condition|)
return|return
literal|1
return|;
comment|/* error */
name|bw
operator|=
name|parse_bw
argument_list|(
name|av
index|[
name|ac
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bw
operator|==
name|U_PARSE_ERR
condition|)
block|{
return|return
operator|(
name|ac
operator|==
literal|2
operator|)
condition|?
literal|1
comment|/* error */
else|:
literal|2
comment|/* unrecognised */
return|;
block|}
name|dst
operator|->
name|d
index|[
literal|0
index|]
operator|=
name|bw
expr_stmt|;
return|return
literal|0
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/* runtime function, store the delay into q->cur_delay */
end_comment

begin_function
specifier|static
name|int
name|const_bw_run
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|arg
parameter_list|)
block|{
name|uint64_t
name|bps
init|=
name|arg
operator|->
name|d
index|[
literal|0
index|]
decl_stmt|;
name|q
operator|->
name|cur_tt
operator|=
name|bps
condition|?
literal|8ULL
operator|*
name|TIME_UNITS
operator|*
name|q
operator|->
name|cur_len
operator|/
name|bps
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ethernet bandwidth, add 672 bits per packet */
end_comment

begin_function
specifier|static
name|int
name|ether_bw_parse
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|dst
parameter_list|,
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
name|uint64_t
name|bw
decl_stmt|;
operator|(
name|void
operator|)
name|q
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"ether"
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|2
return|;
comment|/* unrecognised */
if|if
condition|(
name|ac
operator|!=
literal|2
condition|)
return|return
literal|1
return|;
comment|/* error */
name|bw
operator|=
name|parse_bw
argument_list|(
name|av
index|[
name|ac
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bw
operator|==
name|U_PARSE_ERR
condition|)
return|return
literal|1
return|;
comment|/* error */
name|dst
operator|->
name|d
index|[
literal|0
index|]
operator|=
name|bw
expr_stmt|;
return|return
literal|0
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/* runtime function, add 20 bytes (framing) + 4 bytes (crc) */
end_comment

begin_function
specifier|static
name|int
name|ether_bw_run
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|arg
parameter_list|)
block|{
name|uint64_t
name|bps
init|=
name|arg
operator|->
name|d
index|[
literal|0
index|]
decl_stmt|;
name|q
operator|->
name|cur_tt
operator|=
name|bps
condition|?
literal|8ULL
operator|*
name|TIME_UNITS
operator|*
operator|(
name|q
operator|->
name|cur_len
operator|+
literal|24
operator|)
operator|/
name|bps
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* real bandwidth, plus scaling factor */
end_comment

begin_function
specifier|static
name|int
name|real_bw_parse
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|dst
parameter_list|,
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
name|double
name|scale
decl_stmt|;
operator|(
name|void
operator|)
name|q
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"real"
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|2
return|;
comment|/* unrecognised */
if|if
condition|(
name|ac
operator|>
literal|2
condition|)
block|{
comment|/* second argument is optional */
return|return
literal|1
return|;
comment|/* error */
block|}
elseif|else
if|if
condition|(
name|ac
operator|==
literal|1
condition|)
block|{
name|scale
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|scale
operator|=
name|parse_gen
argument_list|(
name|av
index|[
name|ac
operator|-
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|scale
operator|<=
literal|0
operator|||
name|scale
operator|>
literal|1000
condition|)
return|return
literal|1
return|;
block|}
name|ED
argument_list|(
literal|"real -> scale is %.6f"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|dst
operator|->
name|f
index|[
literal|0
index|]
operator|=
name|scale
expr_stmt|;
return|return
literal|0
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|int
name|real_bw_run
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|arg
parameter_list|)
block|{
name|q
operator|->
name|cur_tt
operator|/=
name|arg
operator|->
name|f
index|[
literal|0
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|_cfg
name|bw_cfg
index|[]
init|=
block|{
block|{
name|const_bw_parse
block|,
name|const_bw_run
block|,
literal|"constant,bps"
block|,
name|_CFG_END
block|}
block|,
block|{
name|ether_bw_parse
block|,
name|ether_bw_run
block|,
literal|"ether,bps"
block|,
name|_CFG_END
block|}
block|,
block|{
name|real_bw_parse
block|,
name|real_bw_run
block|,
literal|"real,scale"
block|,
name|_CFG_END
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|_CFG_END
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * loss patterns  */
end_comment

begin_function
specifier|static
name|int
name|const_plr_parse
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|dst
parameter_list|,
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
name|double
name|plr
decl_stmt|;
name|int
name|err
decl_stmt|;
operator|(
name|void
operator|)
name|q
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"plr"
argument_list|)
operator|!=
literal|0
operator|&&
name|ac
operator|>
literal|1
condition|)
return|return
literal|2
return|;
comment|/* unrecognised */
if|if
condition|(
name|ac
operator|>
literal|2
condition|)
return|return
literal|1
return|;
comment|/* error */
comment|// XXX to be completed
name|plr
operator|=
name|parse_gen
argument_list|(
name|av
index|[
name|ac
operator|-
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|plr
operator|<
literal|0
operator|||
name|plr
operator|>
literal|1
condition|)
return|return
literal|1
return|;
name|dst
operator|->
name|d
index|[
literal|0
index|]
operator|=
name|plr
operator|*
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
comment|/* scale is 16m */
if|if
condition|(
name|plr
operator|!=
literal|0
operator|&&
name|dst
operator|->
name|d
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|ED
argument_list|(
literal|"WWW warning,  rounding %le down to 0"
argument_list|,
name|plr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|int
name|const_plr_run
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|arg
parameter_list|)
block|{
operator|(
name|void
operator|)
name|arg
expr_stmt|;
name|uint64_t
name|r
init|=
name|my_random24
argument_list|()
decl_stmt|;
name|q
operator|->
name|cur_drop
operator|=
name|r
operator|<
name|arg
operator|->
name|d
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
literal|1
comment|/* keep stats */
name|arg
operator|->
name|d
index|[
literal|1
index|]
operator|++
expr_stmt|;
name|arg
operator|->
name|d
index|[
literal|2
index|]
operator|+=
name|q
operator|->
name|cur_drop
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * For BER the loss is 1- (1-ber)**bit_len  * The linear approximation is only good for small values, so we  * tabulate (1-ber)**len for various sizes in bytes  */
end_comment

begin_function
specifier|static
name|int
name|const_ber_parse
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|dst
parameter_list|,
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
name|double
name|ber
decl_stmt|,
name|ber8
decl_stmt|,
name|cur
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|uint32_t
modifier|*
name|plr
decl_stmt|;
specifier|const
name|uint32_t
name|mask
init|=
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|-
literal|1
decl_stmt|;
operator|(
name|void
operator|)
name|q
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"ber"
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|2
return|;
comment|/* unrecognised */
if|if
condition|(
name|ac
operator|!=
literal|2
condition|)
return|return
literal|1
return|;
comment|/* error */
name|ber
operator|=
name|parse_gen
argument_list|(
name|av
index|[
name|ac
operator|-
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|ber
operator|<
literal|0
operator|||
name|ber
operator|>
literal|1
condition|)
return|return
literal|1
return|;
name|dst
operator|->
name|arg_len
operator|=
name|MAX_PKT
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|plr
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|dst
operator|->
name|arg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|plr
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* no memory */
name|dst
operator|->
name|arg
operator|=
name|plr
expr_stmt|;
name|ber8
operator|=
literal|1
operator|-
name|ber
expr_stmt|;
name|ber8
operator|*=
name|ber8
expr_stmt|;
comment|/* **2 */
name|ber8
operator|*=
name|ber8
expr_stmt|;
comment|/* **4 */
name|ber8
operator|*=
name|ber8
expr_stmt|;
comment|/* **8 */
name|cur
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PKT
condition|;
name|i
operator|++
operator|,
name|cur
operator|*=
name|ber8
control|)
block|{
name|plr
index|[
name|i
index|]
operator|=
operator|(
name|mask
operator|+
literal|1
operator|)
operator|*
operator|(
literal|1
operator|-
name|cur
operator|)
expr_stmt|;
if|if
condition|(
name|plr
index|[
name|i
index|]
operator|>
name|mask
condition|)
name|plr
index|[
name|i
index|]
operator|=
name|mask
expr_stmt|;
if|#
directive|if
literal|0
block|if (i>= 60)
comment|//&& plr[i]< mask/2)
block|RD(50,"%4d: %le %ld", i, 1.0 - cur, (_P64)plr[i]);
endif|#
directive|endif
block|}
name|dst
operator|->
name|d
index|[
literal|0
index|]
operator|=
name|ber
operator|*
operator|(
name|mask
operator|+
literal|1
operator|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|int
name|const_ber_run
parameter_list|(
name|struct
name|_qs
modifier|*
name|q
parameter_list|,
name|struct
name|_cfg
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|l
init|=
name|q
operator|->
name|cur_len
decl_stmt|;
name|uint64_t
name|r
init|=
name|my_random24
argument_list|()
decl_stmt|;
name|uint32_t
modifier|*
name|plr
init|=
name|arg
operator|->
name|arg
decl_stmt|;
if|if
condition|(
name|l
operator|>=
name|MAX_PKT
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"pkt len %d too large, trim to %d"
argument_list|,
name|l
argument_list|,
name|MAX_PKT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|l
operator|=
name|MAX_PKT
operator|-
literal|1
expr_stmt|;
block|}
name|q
operator|->
name|cur_drop
operator|=
name|r
operator|<
name|plr
index|[
name|l
index|]
expr_stmt|;
if|#
directive|if
literal|1
comment|/* keep stats */
name|arg
operator|->
name|d
index|[
literal|1
index|]
operator|+=
name|l
operator|*
literal|8
expr_stmt|;
name|arg
operator|->
name|d
index|[
literal|2
index|]
operator|+=
name|q
operator|->
name|cur_drop
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|_cfg
name|loss_cfg
index|[]
init|=
block|{
block|{
name|const_plr_parse
block|,
name|const_plr_run
block|,
literal|"plr,prob # 0<= prob<= 1"
block|,
name|_CFG_END
block|}
block|,
block|{
name|const_ber_parse
block|,
name|const_ber_run
block|,
literal|"ber,prob # 0<= prob<= 1"
block|,
name|_CFG_END
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|_CFG_END
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

