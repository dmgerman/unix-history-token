begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011-2013 Matteo Landi, Luigi Rizzo. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  * $Id: pkt-gen.c 12346 2013-06-12 17:36:25Z luigi $  *  * Example program to show how to build a multithreaded packet  * source/sink using the netmap device.  *  * In this example we create a programmable number of threads  * to take care of all the queues of the interface used to  * send or receive traffic.  *  */
end_comment

begin_include
include|#
directive|include
file|"nm_util.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|// isprint()
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|default_payload
init|=
literal|"netmap pkt-gen DIRECT payload\n"
literal|"http://info.iet.unipi.it/~luigi/netmap/ "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|indirect_payload
init|=
literal|"netmap pkt-gen indirect payload\n"
literal|"http://info.iet.unipi.it/~luigi/netmap/ "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|time_second
decl_stmt|;
end_decl_stmt

begin_comment
comment|// support for RD() debugging macro
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SKIP_PAYLOAD
value|1
end_define

begin_comment
comment|/* do not check payload. */
end_comment

begin_struct
struct|struct
name|pkt
block|{
name|struct
name|ether_header
name|eh
decl_stmt|;
name|struct
name|ip
name|ip
decl_stmt|;
name|struct
name|udphdr
name|udp
decl_stmt|;
name|uint8_t
name|body
index|[
literal|2048
index|]
decl_stmt|;
comment|// XXX hardwired
block|}
name|__attribute__
argument_list|(
operator|(
name|__packed__
operator|)
argument_list|)
struct|;
end_struct

begin_struct
struct|struct
name|ip_range
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|uint32_t
name|start
decl_stmt|,
name|end
decl_stmt|;
comment|/* same as struct in_addr */
name|uint16_t
name|port0
decl_stmt|,
name|port1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mac_range
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|ether_addr
name|start
decl_stmt|,
name|end
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * global arguments for all threads  */
end_comment

begin_struct
struct|struct
name|glob_arg
block|{
name|struct
name|ip_range
name|src_ip
decl_stmt|;
name|struct
name|ip_range
name|dst_ip
decl_stmt|;
name|struct
name|mac_range
name|dst_mac
decl_stmt|;
name|struct
name|mac_range
name|src_mac
decl_stmt|;
name|int
name|pkt_size
decl_stmt|;
name|int
name|burst
decl_stmt|;
name|int
name|forever
decl_stmt|;
name|int
name|npackets
decl_stmt|;
comment|/* total packets to send */
name|int
name|frags
decl_stmt|;
comment|/* fragments per packet */
name|int
name|nthreads
decl_stmt|;
name|int
name|cpus
decl_stmt|;
name|int
name|options
decl_stmt|;
comment|/* testing */
define|#
directive|define
name|OPT_PREFETCH
value|1
define|#
directive|define
name|OPT_ACCESS
value|2
define|#
directive|define
name|OPT_COPY
value|4
define|#
directive|define
name|OPT_MEMCPY
value|8
define|#
directive|define
name|OPT_TS
value|16
comment|/* add a timestamp */
define|#
directive|define
name|OPT_INDIRECT
value|32
comment|/* use indirect buffers, tx only */
define|#
directive|define
name|OPT_DUMP
value|64
comment|/* dump rx/tx traffic */
name|int
name|dev_type
decl_stmt|;
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|int
name|tx_rate
decl_stmt|;
name|struct
name|timespec
name|tx_period
decl_stmt|;
name|int
name|affinity
decl_stmt|;
name|int
name|main_fd
decl_stmt|;
name|int
name|report_interval
decl_stmt|;
name|void
modifier|*
function_decl|(
modifier|*
name|td_body
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|mmap_addr
decl_stmt|;
name|int
name|mmap_size
decl_stmt|;
name|char
modifier|*
name|ifname
decl_stmt|;
name|char
modifier|*
name|nmr_config
decl_stmt|;
name|int
name|dummy_send
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|dev_type
block|{
name|DEV_NONE
block|,
name|DEV_NETMAP
block|,
name|DEV_PCAP
block|,
name|DEV_TAP
block|}
enum|;
end_enum

begin_comment
comment|/*  * Arguments for a new thread. The same structure is used by  * the source and the sink  */
end_comment

begin_struct
struct|struct
name|targ
block|{
name|struct
name|glob_arg
modifier|*
name|g
decl_stmt|;
name|int
name|used
decl_stmt|;
name|int
name|completed
decl_stmt|;
name|int
name|cancel
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|nmreq
name|nmr
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
name|uint16_t
name|qfirst
decl_stmt|,
name|qlast
decl_stmt|;
comment|/* range of queues to scan */
specifier|volatile
name|uint64_t
name|count
decl_stmt|;
name|struct
name|timespec
name|tic
decl_stmt|,
name|toc
decl_stmt|;
name|int
name|me
decl_stmt|;
name|pthread_t
name|thread
decl_stmt|;
name|int
name|affinity
decl_stmt|;
name|struct
name|pkt
name|pkt
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * extract the extremes from a range of ipv4 addresses.  * addr_lo[-addr_hi][:port_lo[-port_hi]]  */
end_comment

begin_function
specifier|static
name|void
name|extract_ip_range
parameter_list|(
name|struct
name|ip_range
modifier|*
name|r
parameter_list|)
block|{
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|struct
name|in_addr
name|a
decl_stmt|;
name|D
argument_list|(
literal|"extract IP range from %s"
argument_list|,
name|r
operator|->
name|name
argument_list|)
expr_stmt|;
name|r
operator|->
name|port0
operator|=
name|r
operator|->
name|port1
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|start
operator|=
name|r
operator|->
name|end
operator|=
literal|0
expr_stmt|;
comment|/* the first - splits start/end of range */
name|ap
operator|=
name|index
argument_list|(
name|r
operator|->
name|name
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
comment|/* do we have ports ? */
if|if
condition|(
name|ap
condition|)
block|{
operator|*
name|ap
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* grab the initial values (mandatory) */
name|pp
operator|=
name|index
argument_list|(
name|r
operator|->
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
condition|)
block|{
operator|*
name|pp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|->
name|port0
operator|=
name|r
operator|->
name|port1
operator|=
name|strtol
argument_list|(
name|pp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|inet_aton
argument_list|(
name|r
operator|->
name|name
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|r
operator|->
name|start
operator|=
name|r
operator|->
name|end
operator|=
name|ntohl
argument_list|(
name|a
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
condition|)
block|{
name|pp
operator|=
name|index
argument_list|(
name|ap
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
condition|)
block|{
operator|*
name|pp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|pp
condition|)
name|r
operator|->
name|port1
operator|=
name|strtol
argument_list|(
name|pp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ap
condition|)
block|{
name|inet_aton
argument_list|(
name|ap
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|r
operator|->
name|end
operator|=
name|ntohl
argument_list|(
name|a
operator|.
name|s_addr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|->
name|port0
operator|>
name|r
operator|->
name|port1
condition|)
block|{
name|uint16_t
name|tmp
init|=
name|r
operator|->
name|port0
decl_stmt|;
name|r
operator|->
name|port0
operator|=
name|r
operator|->
name|port1
expr_stmt|;
name|r
operator|->
name|port1
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|start
operator|>
name|r
operator|->
name|end
condition|)
block|{
name|uint32_t
name|tmp
init|=
name|r
operator|->
name|start
decl_stmt|;
name|r
operator|->
name|start
operator|=
name|r
operator|->
name|end
expr_stmt|;
name|r
operator|->
name|end
operator|=
name|tmp
expr_stmt|;
block|}
block|{
name|struct
name|in_addr
name|a
decl_stmt|;
name|char
name|buf1
index|[
literal|16
index|]
decl_stmt|;
comment|// one ip address
name|a
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|r
operator|->
name|end
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf1
argument_list|,
name|inet_ntoa
argument_list|(
name|a
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|r
operator|->
name|start
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"range is %s:%d to %s:%d"
argument_list|,
name|inet_ntoa
argument_list|(
name|a
argument_list|)
argument_list|,
name|r
operator|->
name|port0
argument_list|,
name|buf1
argument_list|,
name|r
operator|->
name|port1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|extract_mac_range
parameter_list|(
name|struct
name|mac_range
modifier|*
name|r
parameter_list|)
block|{
name|D
argument_list|(
literal|"extract MAC range from %s"
argument_list|,
name|r
operator|->
name|name
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ether_aton
argument_list|(
name|r
operator|->
name|name
argument_list|)
argument_list|,
operator|&
name|r
operator|->
name|start
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ether_aton
argument_list|(
name|r
operator|->
name|name
argument_list|)
argument_list|,
operator|&
name|r
operator|->
name|end
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bcopy(targ->src_mac, eh->ether_shost, 6); 	p = index(targ->g->src_mac, '-'); 	if (p) 		targ->src_mac_range = atoi(p+1);  	bcopy(ether_aton(targ->g->dst_mac), targ->dst_mac, 6); 	bcopy(targ->dst_mac, eh->ether_dhost, 6); 	p = index(targ->g->dst_mac, '-'); 	if (p) 		targ->dst_mac_range = atoi(p+1);
endif|#
directive|endif
name|D
argument_list|(
literal|"%s starts at %s"
argument_list|,
name|r
operator|->
name|name
argument_list|,
name|ether_ntoa
argument_list|(
operator|&
name|r
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|targ
modifier|*
name|targs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|global_nthreads
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* control-C handler */
end_comment

begin_function
specifier|static
name|void
name|sigint_h
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|sig
expr_stmt|;
comment|/* UNUSED */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|global_nthreads
condition|;
name|i
operator|++
control|)
block|{
name|targs
index|[
name|i
index|]
operator|.
name|cancel
operator|=
literal|1
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sysctl wrapper to return the number of active CPUs */
end_comment

begin_function
specifier|static
name|int
name|system_ncpus
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|int
name|mib
index|[
literal|2
index|]
decl_stmt|,
name|ncpus
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_HW
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|HW_NCPU
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|mib
argument_list|)
expr_stmt|;
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
operator|&
name|ncpus
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ncpus
operator|)
return|;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* !__FreeBSD__ */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_define
define|#
directive|define
name|sockaddr_dl
value|sockaddr_ll
end_define

begin_define
define|#
directive|define
name|sdl_family
value|sll_family
end_define

begin_define
define|#
directive|define
name|AF_LINK
value|AF_PACKET
end_define

begin_define
define|#
directive|define
name|LLADDR
parameter_list|(
name|s
parameter_list|)
value|s->sll_addr;
end_define

begin_include
include|#
directive|include
file|<linux/if_tun.h>
end_include

begin_define
define|#
directive|define
name|TAP_CLONEDEV
value|"/dev/net/tun"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __linux__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<net/if_tun.h>
end_include

begin_define
define|#
directive|define
name|TAP_CLONEDEV
value|"/dev/tap"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__APPLE__
end_ifdef

begin_comment
comment|// #warning TAP not supported on apple ?
end_comment

begin_include
include|#
directive|include
file|<net/if_utun.h>
end_include

begin_define
define|#
directive|define
name|TAP_CLONEDEV
value|"/dev/tap"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __APPLE__ */
end_comment

begin_comment
comment|/*  * parse the vale configuration in conf and put it in nmr.  * The configuration may consist of 0 to 4 numbers separated  * by commas: #tx-slots,#rx-slots,#tx-rinzgs,#rx-rings.  * Missing numbers or zeroes stand for default values.  * As an additional convenience, if exactly one number  * is specified, then this is assigned to bot #tx-slots and #rx-slots.  * If there is no 4th number, then the 3rd is assigned to bot #tx-rings   * and #rx-rings.  */
end_comment

begin_function
name|void
name|parse_nmr_config
parameter_list|(
specifier|const
name|char
modifier|*
name|conf
parameter_list|,
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
block|{
name|char
modifier|*
name|w
decl_stmt|,
modifier|*
name|tok
decl_stmt|;
name|int
name|i
decl_stmt|,
name|v
decl_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|nmr
operator|->
name|nr_rx_rings
operator|=
literal|0
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|nmr
operator|->
name|nr_rx_slots
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|conf
operator|==
name|NULL
operator|||
operator|!
operator|*
name|conf
condition|)
return|return;
name|w
operator|=
name|strdup
argument_list|(
name|conf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tok
operator|=
name|strtok
argument_list|(
name|w
argument_list|,
literal|","
argument_list|)
init|;
name|tok
condition|;
name|i
operator|++
operator|,
name|tok
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
control|)
block|{
name|v
operator|=
name|atoi
argument_list|(
name|tok
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|v
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|v
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|v
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|v
expr_stmt|;
break|break;
default|default:
name|D
argument_list|(
literal|"ignored config: %s"
argument_list|,
name|tok
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|D
argument_list|(
literal|"txr %d txd %d rxr %d rxd %d"
argument_list|,
name|nmr
operator|->
name|nr_tx_rings
argument_list|,
name|nmr
operator|->
name|nr_tx_slots
argument_list|,
name|nmr
operator|->
name|nr_rx_rings
argument_list|,
name|nmr
operator|->
name|nr_rx_slots
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * locate the src mac address for our interface, put it  * into the user-supplied buffer. return 0 if ok, -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|source_hwaddr
parameter_list|(
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|ifaddrs
modifier|*
name|ifaphead
decl_stmt|,
modifier|*
name|ifap
decl_stmt|;
name|int
name|l
init|=
sizeof|sizeof
argument_list|(
name|ifap
operator|->
name|ifa_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|getifaddrs
argument_list|(
operator|&
name|ifaphead
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"getifaddrs %s failed"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|ifap
operator|=
name|ifaphead
init|;
name|ifap
condition|;
name|ifap
operator|=
name|ifap
operator|->
name|ifa_next
control|)
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sdl
init|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifap
operator|->
name|ifa_addr
decl_stmt|;
name|uint8_t
modifier|*
name|mac
decl_stmt|;
if|if
condition|(
operator|!
name|sdl
operator|||
name|sdl
operator|->
name|sdl_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|ifap
operator|->
name|ifa_name
argument_list|,
name|ifname
argument_list|,
name|l
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|mac
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|LLADDR
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%02x:%02x:%02x:%02x:%02x:%02x"
argument_list|,
name|mac
index|[
literal|0
index|]
argument_list|,
name|mac
index|[
literal|1
index|]
argument_list|,
name|mac
index|[
literal|2
index|]
argument_list|,
name|mac
index|[
literal|3
index|]
argument_list|,
name|mac
index|[
literal|4
index|]
argument_list|,
name|mac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|D
argument_list|(
literal|"source hwaddr %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
name|freeifaddrs
argument_list|(
name|ifaphead
argument_list|)
expr_stmt|;
return|return
name|ifap
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/* set the thread affinity. */
end_comment

begin_function
specifier|static
name|int
name|setaffinity
parameter_list|(
name|pthread_t
name|me
parameter_list|,
name|int
name|i
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|cpuset_t
name|cpumask
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Set thread affinity affinity.*/
name|CPU_ZERO
argument_list|(
operator|&
name|cpumask
argument_list|)
expr_stmt|;
name|CPU_SET
argument_list|(
name|i
argument_list|,
operator|&
name|cpumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|pthread_setaffinity_np
argument_list|(
name|me
argument_list|,
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
argument_list|,
operator|&
name|cpumask
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"Unable to set affinity"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|me
expr_stmt|;
comment|/* suppress 'unused' warnings */
operator|(
name|void
operator|)
name|i
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD__ */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the checksum of the given ip header. */
end_comment

begin_function
specifier|static
name|uint16_t
name|checksum
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|uint16_t
name|len
parameter_list|,
name|uint32_t
name|sum
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|addr
init|=
name|data
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
comment|/* Checksum all the pairs of bytes first... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|len
operator|&
operator|~
literal|1U
operator|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|sum
operator|+=
operator|(
name|u_int16_t
operator|)
name|ntohs
argument_list|(
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|addr
operator|+
name|i
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum
operator|>
literal|0xFFFF
condition|)
name|sum
operator|-=
literal|0xFFFF
expr_stmt|;
block|}
comment|/* 	 * If there's a single byte left over, checksum it, too. 	 * Network byte order is big-endian, so the remaining byte is 	 * the high byte. 	 */
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|sum
operator|+=
name|addr
index|[
name|i
index|]
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|sum
operator|>
literal|0xFFFF
condition|)
name|sum
operator|-=
literal|0xFFFF
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|wrapsum
parameter_list|(
name|u_int32_t
name|sum
parameter_list|)
block|{
name|sum
operator|=
operator|~
name|sum
operator|&
literal|0xFFFF
expr_stmt|;
return|return
operator|(
name|htons
argument_list|(
name|sum
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check the payload of the packet for errors (use it for debug).  * Look for consecutive ascii representations of the size of the packet.  */
end_comment

begin_function
specifier|static
name|void
name|dump_payload
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|netmap_ring
modifier|*
name|ring
parameter_list|,
name|int
name|cur
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|i0
decl_stmt|;
comment|/* get the length in ASCII of the length of the packet. */
name|printf
argument_list|(
literal|"ring %p cur %5d [buf %6d flags 0x%04x len %5d]\n"
argument_list|,
name|ring
argument_list|,
name|cur
argument_list|,
name|ring
operator|->
name|slot
index|[
name|cur
index|]
operator|.
name|buf_idx
argument_list|,
name|ring
operator|->
name|slot
index|[
name|cur
index|]
operator|.
name|flags
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* hexdump routine */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
control|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%5d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i0
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|sprintf
argument_list|(
name|buf
operator|+
literal|7
operator|+
name|j
operator|*
literal|3
argument_list|,
literal|"%02x "
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|i0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|sprintf
argument_list|(
name|buf
operator|+
literal|7
operator|+
name|j
operator|+
literal|48
argument_list|,
literal|"%c"
argument_list|,
name|isprint
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
condition|?
name|p
index|[
name|i
index|]
else|:
literal|'.'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Fill a packet with some payload.  * We create a UDP packet so the payload starts at  *	14+20+8 = 42 bytes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_define
define|#
directive|define
name|uh_sport
value|source
end_define

begin_define
define|#
directive|define
name|uh_dport
value|dest
end_define

begin_define
define|#
directive|define
name|uh_ulen
value|len
end_define

begin_define
define|#
directive|define
name|uh_sum
value|check
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* linux */
end_comment

begin_comment
comment|/*  * increment the addressed in the packet,  * starting from the least significant field.  *	DST_IP DST_PORT SRC_IP SRC_PORT  */
end_comment

begin_function
specifier|static
name|void
name|update_addresses
parameter_list|(
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|struct
name|glob_arg
modifier|*
name|g
parameter_list|)
block|{
name|uint32_t
name|a
decl_stmt|;
name|uint16_t
name|p
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
operator|&
name|pkt
operator|->
name|ip
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|udp
init|=
operator|&
name|pkt
operator|->
name|udp
decl_stmt|;
name|p
operator|=
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_sport
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
name|g
operator|->
name|src_ip
operator|.
name|port1
condition|)
block|{
comment|/* just inc, no wrap */
name|udp
operator|->
name|uh_sport
operator|=
name|htons
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|udp
operator|->
name|uh_sport
operator|=
name|htons
argument_list|(
name|g
operator|->
name|src_ip
operator|.
name|port0
argument_list|)
expr_stmt|;
name|a
operator|=
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|<
name|g
operator|->
name|src_ip
operator|.
name|end
condition|)
block|{
comment|/* just inc, no wrap */
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|a
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|g
operator|->
name|src_ip
operator|.
name|start
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_sport
operator|=
name|htons
argument_list|(
name|g
operator|->
name|src_ip
operator|.
name|port0
argument_list|)
expr_stmt|;
name|p
operator|=
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_dport
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
name|g
operator|->
name|dst_ip
operator|.
name|port1
condition|)
block|{
comment|/* just inc, no wrap */
name|udp
operator|->
name|uh_dport
operator|=
name|htons
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|udp
operator|->
name|uh_dport
operator|=
name|htons
argument_list|(
name|g
operator|->
name|dst_ip
operator|.
name|port0
argument_list|)
expr_stmt|;
name|a
operator|=
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|<
name|g
operator|->
name|dst_ip
operator|.
name|end
condition|)
block|{
comment|/* just inc, no wrap */
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|a
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|g
operator|->
name|dst_ip
operator|.
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * initialize one packet and prepare for the next one.  * The copy could be done better instead of repeating it each time.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_packet
parameter_list|(
name|struct
name|targ
modifier|*
name|targ
parameter_list|)
block|{
name|struct
name|pkt
modifier|*
name|pkt
init|=
operator|&
name|targ
operator|->
name|pkt
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|udp
decl_stmt|;
name|uint16_t
name|paylen
init|=
name|targ
operator|->
name|g
operator|->
name|pkt_size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|payload
init|=
name|targ
operator|->
name|g
operator|->
name|options
operator|&
name|OPT_INDIRECT
condition|?
name|indirect_payload
else|:
name|default_payload
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|l0
init|=
name|strlen
argument_list|(
name|payload
argument_list|)
decl_stmt|;
comment|/* create a nice NUL-terminated string */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paylen
condition|;
control|)
block|{
name|l
operator|=
name|min
argument_list|(
name|l0
argument_list|,
name|paylen
operator|-
name|i
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|payload
argument_list|,
name|pkt
operator|->
name|body
operator|+
name|i
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|i
operator|+=
name|l
expr_stmt|;
block|}
name|pkt
operator|->
name|body
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ip
operator|=
operator|&
name|pkt
operator|->
name|ip
expr_stmt|;
comment|/* prepare the headers */
name|ip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|=
literal|5
expr_stmt|;
name|ip
operator|->
name|ip_id
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
name|IPTOS_LOWDELAY
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|ntohs
argument_list|(
name|targ
operator|->
name|g
operator|->
name|pkt_size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_id
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|IP_DF
argument_list|)
expr_stmt|;
comment|/* Don't fragment */
name|ip
operator|->
name|ip_ttl
operator|=
name|IPDEFTTL
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|targ
operator|->
name|g
operator|->
name|dst_ip
operator|.
name|start
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|targ
operator|->
name|g
operator|->
name|src_ip
operator|.
name|start
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
name|wrapsum
argument_list|(
name|checksum
argument_list|(
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|udp
operator|=
operator|&
name|pkt
operator|->
name|udp
expr_stmt|;
name|udp
operator|->
name|uh_sport
operator|=
name|htons
argument_list|(
name|targ
operator|->
name|g
operator|->
name|src_ip
operator|.
name|port0
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_dport
operator|=
name|htons
argument_list|(
name|targ
operator|->
name|g
operator|->
name|dst_ip
operator|.
name|port0
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_ulen
operator|=
name|htons
argument_list|(
name|paylen
argument_list|)
expr_stmt|;
comment|/* Magic: taken from sbin/dhclient/packet.c */
name|udp
operator|->
name|uh_sum
operator|=
name|wrapsum
argument_list|(
name|checksum
argument_list|(
name|udp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|udp
argument_list|)
argument_list|,
name|checksum
argument_list|(
name|pkt
operator|->
name|body
argument_list|,
name|paylen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|udp
argument_list|)
argument_list|,
name|checksum
argument_list|(
operator|&
name|ip
operator|->
name|ip_src
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
argument_list|,
name|IPPROTO_UDP
operator|+
operator|(
name|u_int32_t
operator|)
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_ulen
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|&
name|pkt
operator|->
name|eh
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|targ
operator|->
name|g
operator|->
name|src_mac
operator|.
name|start
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|targ
operator|->
name|g
operator|->
name|dst_mac
operator|.
name|start
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
comment|// dump_payload((void *)pkt, targ->g->pkt_size, NULL, 0);
block|}
end_function

begin_comment
comment|/*  * create and enqueue a batch of packets on a ring.  * On the last one set NS_REPORT to tell the driver to generate  * an interrupt when done.  */
end_comment

begin_function
specifier|static
name|int
name|send_packets
parameter_list|(
name|struct
name|netmap_ring
modifier|*
name|ring
parameter_list|,
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|struct
name|glob_arg
modifier|*
name|g
parameter_list|,
name|u_int
name|count
parameter_list|,
name|int
name|options
parameter_list|,
name|u_int
name|nfrags
parameter_list|)
block|{
name|u_int
name|sent
decl_stmt|,
name|cur
init|=
name|ring
operator|->
name|cur
decl_stmt|;
name|int
name|fcnt
decl_stmt|;
name|int
name|size
init|=
name|g
operator|->
name|pkt_size
decl_stmt|;
if|if
condition|(
name|ring
operator|->
name|avail
operator|<
name|count
condition|)
name|count
operator|=
name|ring
operator|->
name|avail
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|nfrags
condition|)
block|{
name|D
argument_list|(
literal|"truncating packet, no room for frags %d %d"
argument_list|,
name|count
argument_list|,
name|nfrags
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (options& (OPT_COPY | OPT_PREFETCH) ) { 		for (sent = 0; sent< count; sent++) { 			struct netmap_slot *slot =&ring->slot[cur]; 			char *p = NETMAP_BUF(ring, slot->buf_idx);  			prefetch(p); 			cur = NETMAP_RING_NEXT(ring, cur); 		} 		cur = ring->cur; 	}
endif|#
directive|endif
for|for
control|(
name|fcnt
operator|=
name|nfrags
operator|,
name|sent
operator|=
literal|0
init|;
name|sent
operator|<
name|count
condition|;
name|sent
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|cur
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|NETMAP_BUF
argument_list|(
name|ring
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
decl_stmt|;
name|slot
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|OPT_INDIRECT
condition|)
block|{
name|slot
operator|->
name|flags
operator||=
name|NS_INDIRECT
expr_stmt|;
name|slot
operator|->
name|ptr
operator|=
operator|(
name|uint64_t
operator|)
name|pkt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|options
operator|&
name|OPT_COPY
condition|)
block|{
name|pkt_copy
argument_list|(
name|pkt
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcnt
operator|==
literal|1
condition|)
name|update_addresses
argument_list|(
name|pkt
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|options
operator|&
name|OPT_MEMCPY
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|pkt
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcnt
operator|==
literal|1
condition|)
name|update_addresses
argument_list|(
name|pkt
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|options
operator|&
name|OPT_PREFETCH
condition|)
block|{
name|prefetch
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|&
name|OPT_DUMP
condition|)
name|dump_payload
argument_list|(
name|p
argument_list|,
name|size
argument_list|,
name|ring
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|slot
operator|->
name|len
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|--
name|fcnt
operator|>
literal|0
condition|)
name|slot
operator|->
name|flags
operator||=
name|NS_MOREFRAG
expr_stmt|;
else|else
name|fcnt
operator|=
name|nfrags
expr_stmt|;
if|if
condition|(
name|sent
operator|==
name|count
operator|-
literal|1
condition|)
block|{
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_MOREFRAG
expr_stmt|;
name|slot
operator|->
name|flags
operator||=
name|NS_REPORT
expr_stmt|;
block|}
name|cur
operator|=
name|NETMAP_RING_NEXT
argument_list|(
name|ring
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
name|ring
operator|->
name|avail
operator|-=
name|sent
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
return|return
operator|(
name|sent
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a packet, and wait for a response.  * The payload (after UDP header, ofs 42) has a 4-byte sequence  * followed by a struct timeval (or bintime?)  */
end_comment

begin_define
define|#
directive|define
name|PAY_OFS
value|42
end_define

begin_comment
comment|/* where in the pkt... */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|pinger_body
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|targ
modifier|*
name|targ
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|pollfd
name|fds
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|targ
operator|->
name|nifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rx
init|=
literal|0
decl_stmt|,
name|n
init|=
name|targ
operator|->
name|g
operator|->
name|npackets
decl_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|targ
operator|->
name|fd
expr_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|events
operator|=
operator|(
name|POLLIN
operator|)
expr_stmt|;
specifier|static
name|uint32_t
name|sent
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|,
name|now
decl_stmt|,
name|last_print
decl_stmt|;
name|uint32_t
name|count
init|=
literal|0
decl_stmt|,
name|min
init|=
literal|1000000000
decl_stmt|,
name|av
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|nthreads
operator|>
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"can only ping with 1 thread"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|last_print
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|==
literal|0
operator|||
operator|(
name|int
operator|)
name|sent
operator|<
name|n
condition|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|NETMAP_TXRING
argument_list|(
name|nifp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|slot
operator|->
name|len
operator|=
name|targ
operator|->
name|g
operator|->
name|pkt_size
expr_stmt|;
name|p
operator|=
name|NETMAP_BUF
argument_list|(
name|ring
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|avail
operator|==
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"-- ouch, cannot send"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkt_copy
argument_list|(
operator|&
name|targ
operator|->
name|pkt
argument_list|,
name|p
argument_list|,
name|targ
operator|->
name|g
operator|->
name|pkt_size
argument_list|)
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sent
argument_list|,
name|p
operator|+
literal|42
argument_list|,
sizeof|sizeof
argument_list|(
name|sent
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ts
argument_list|,
name|p
operator|+
literal|46
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
name|sent
operator|++
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|NETMAP_RING_NEXT
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|ring
operator|->
name|avail
operator|--
expr_stmt|;
block|}
block|}
comment|/* should use a parameter to decide how often to send */
if|if
condition|(
name|poll
argument_list|(
name|fds
argument_list|,
literal|1
argument_list|,
literal|3000
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"poll error/timeout on queue %d"
argument_list|,
name|targ
operator|->
name|me
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* see what we got back */
for|for
control|(
name|i
operator|=
name|targ
operator|->
name|qfirst
init|;
name|i
operator|<
name|targ
operator|->
name|qlast
condition|;
name|i
operator|++
control|)
block|{
name|ring
operator|=
name|NETMAP_RXRING
argument_list|(
name|nifp
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|ring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|seq
decl_stmt|;
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|p
operator|=
name|NETMAP_BUF
argument_list|(
name|ring
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|+
literal|42
argument_list|,
operator|&
name|seq
argument_list|,
sizeof|sizeof
argument_list|(
name|seq
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|+
literal|46
argument_list|,
operator|&
name|ts
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
operator|-
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
name|now
operator|.
name|tv_nsec
operator|-
name|ts
operator|.
name|tv_nsec
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
name|ts
operator|.
name|tv_nsec
operator|+=
literal|1000000000
expr_stmt|;
name|ts
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
if|if
condition|(
literal|1
condition|)
name|D
argument_list|(
literal|"seq %d/%d delta %d.%09d"
argument_list|,
name|seq
argument_list|,
name|sent
argument_list|,
operator|(
name|int
operator|)
name|ts
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|ts
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|tv_nsec
operator|<
operator|(
name|int
operator|)
name|min
condition|)
name|min
operator|=
name|ts
operator|.
name|tv_nsec
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|av
operator|+=
name|ts
operator|.
name|tv_nsec
expr_stmt|;
name|ring
operator|->
name|avail
operator|--
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|NETMAP_RING_NEXT
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|rx
operator|++
expr_stmt|;
block|}
block|}
comment|//D("tx %d rx %d", sent, rx);
comment|//usleep(100000);
name|ts
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
operator|-
name|last_print
operator|.
name|tv_sec
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
name|now
operator|.
name|tv_nsec
operator|-
name|last_print
operator|.
name|tv_nsec
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
name|ts
operator|.
name|tv_nsec
operator|+=
literal|1000000000
expr_stmt|;
name|ts
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ts
operator|.
name|tv_sec
operator|>=
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"count %d min %d av %d"
argument_list|,
name|count
argument_list|,
name|min
argument_list|,
name|av
operator|/
name|count
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|av
operator|=
literal|0
expr_stmt|;
name|min
operator|=
literal|100000000
expr_stmt|;
name|last_print
operator|=
name|now
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * reply to ping requests  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ponger_body
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|targ
modifier|*
name|targ
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|pollfd
name|fds
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|targ
operator|->
name|nifp
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|txring
decl_stmt|,
modifier|*
name|rxring
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rx
init|=
literal|0
decl_stmt|,
name|sent
init|=
literal|0
decl_stmt|,
name|n
init|=
name|targ
operator|->
name|g
operator|->
name|npackets
decl_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|targ
operator|->
name|fd
expr_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|events
operator|=
operator|(
name|POLLIN
operator|)
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|nthreads
operator|>
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"can only reply ping with 1 thread"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|D
argument_list|(
literal|"understood ponger %d but don't know how to do it"
argument_list|,
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|==
literal|0
operator|||
name|sent
operator|<
name|n
condition|)
block|{
name|uint32_t
name|txcur
decl_stmt|,
name|txavail
decl_stmt|;
comment|//#define BUSYWAIT
ifdef|#
directive|ifdef
name|BUSYWAIT
name|ioctl
argument_list|(
name|fds
index|[
literal|0
index|]
operator|.
name|fd
argument_list|,
name|NIOCRXSYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|poll
argument_list|(
name|fds
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"poll error/timeout on queue %d"
argument_list|,
name|targ
operator|->
name|me
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|txring
operator|=
name|NETMAP_TXRING
argument_list|(
name|nifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|txcur
operator|=
name|txring
operator|->
name|cur
expr_stmt|;
name|txavail
operator|=
name|txring
operator|->
name|avail
expr_stmt|;
comment|/* see what we got back */
for|for
control|(
name|i
operator|=
name|targ
operator|->
name|qfirst
init|;
name|i
operator|<
name|targ
operator|->
name|qlast
condition|;
name|i
operator|++
control|)
block|{
name|rxring
operator|=
name|NETMAP_RXRING
argument_list|(
name|nifp
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|rxring
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|uint16_t
modifier|*
name|spkt
decl_stmt|,
modifier|*
name|dpkt
decl_stmt|;
name|uint32_t
name|cur
init|=
name|rxring
operator|->
name|cur
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|rxring
operator|->
name|slot
index|[
name|cur
index|]
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|src
operator|=
name|NETMAP_BUF
argument_list|(
name|rxring
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
expr_stmt|;
comment|//D("got pkt %p of size %d", src, slot->len);
name|rxring
operator|->
name|avail
operator|--
expr_stmt|;
name|rxring
operator|->
name|cur
operator|=
name|NETMAP_RING_NEXT
argument_list|(
name|rxring
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|rx
operator|++
expr_stmt|;
if|if
condition|(
name|txavail
operator|==
literal|0
condition|)
continue|continue;
name|dst
operator|=
name|NETMAP_BUF
argument_list|(
name|txring
argument_list|,
name|txring
operator|->
name|slot
index|[
name|txcur
index|]
operator|.
name|buf_idx
argument_list|)
expr_stmt|;
comment|/* copy... */
name|dpkt
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|dst
expr_stmt|;
name|spkt
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|src
expr_stmt|;
name|pkt_copy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
name|dpkt
index|[
literal|0
index|]
operator|=
name|spkt
index|[
literal|3
index|]
expr_stmt|;
name|dpkt
index|[
literal|1
index|]
operator|=
name|spkt
index|[
literal|4
index|]
expr_stmt|;
name|dpkt
index|[
literal|2
index|]
operator|=
name|spkt
index|[
literal|5
index|]
expr_stmt|;
name|dpkt
index|[
literal|3
index|]
operator|=
name|spkt
index|[
literal|0
index|]
expr_stmt|;
name|dpkt
index|[
literal|4
index|]
operator|=
name|spkt
index|[
literal|1
index|]
expr_stmt|;
name|dpkt
index|[
literal|5
index|]
operator|=
name|spkt
index|[
literal|2
index|]
expr_stmt|;
name|txring
operator|->
name|slot
index|[
name|txcur
index|]
operator|.
name|len
operator|=
name|slot
operator|->
name|len
expr_stmt|;
comment|/* XXX swap src dst mac */
name|txcur
operator|=
name|NETMAP_RING_NEXT
argument_list|(
name|txring
argument_list|,
name|txcur
argument_list|)
expr_stmt|;
name|txavail
operator|--
expr_stmt|;
name|sent
operator|++
expr_stmt|;
block|}
block|}
name|txring
operator|->
name|cur
operator|=
name|txcur
expr_stmt|;
name|txring
operator|->
name|avail
operator|=
name|txavail
expr_stmt|;
name|targ
operator|->
name|count
operator|=
name|sent
expr_stmt|;
ifdef|#
directive|ifdef
name|BUSYWAIT
name|ioctl
argument_list|(
name|fds
index|[
literal|0
index|]
operator|.
name|fd
argument_list|,
name|NIOCTXSYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//D("tx %d rx %d", sent, rx);
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|timespec_ge
parameter_list|(
specifier|const
name|struct
name|timespec
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|tv_sec
operator|>
name|b
operator|->
name|tv_sec
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|tv_sec
operator|<
name|b
operator|->
name|tv_sec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|tv_nsec
operator|>=
name|b
operator|->
name|tv_nsec
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|timespec
name|timeval2spec
argument_list|(
argument|const struct timeval *a
argument_list|)
block|{ 	struct
name|timespec
name|ts
operator|=
block|{
operator|.
name|tv_sec
operator|=
name|a
operator|->
name|tv_sec
block|,
operator|.
name|tv_nsec
operator|=
name|a
operator|->
name|tv_usec
operator|*
literal|1000
block|}
block|;
return|return
name|ts
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|timeval
name|timespec2val
argument_list|(
argument|const struct timespec *a
argument_list|)
block|{ 	struct
name|timeval
name|tv
operator|=
block|{
operator|.
name|tv_sec
operator|=
name|a
operator|->
name|tv_sec
block|,
operator|.
name|tv_usec
operator|=
name|a
operator|->
name|tv_nsec
operator|/
literal|1000
block|}
block|;
return|return
name|tv
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|int
name|wait_time
parameter_list|(
name|struct
name|timespec
name|ts
parameter_list|,
name|struct
name|timespec
modifier|*
name|wakeup_ts
parameter_list|,
name|long
name|long
modifier|*
name|waited
parameter_list|)
block|{
name|struct
name|timespec
name|curtime
decl_stmt|;
name|curtime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|curtime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|curtime
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"clock_gettime: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
while|while
condition|(
name|timespec_ge
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|curtime
argument_list|)
condition|)
block|{
if|if
condition|(
name|waited
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|waited
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|curtime
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"clock_gettime"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|wakeup_ts
operator|!=
name|NULL
condition|)
operator|*
name|wakeup_ts
operator|=
name|curtime
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|timespec_add
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsa
parameter_list|,
name|struct
name|timespec
modifier|*
name|tsb
parameter_list|)
block|{
name|tsa
operator|->
name|tv_sec
operator|+=
name|tsb
operator|->
name|tv_sec
expr_stmt|;
name|tsa
operator|->
name|tv_nsec
operator|+=
name|tsb
operator|->
name|tv_nsec
expr_stmt|;
if|if
condition|(
name|tsa
operator|->
name|tv_nsec
operator|>=
literal|1000000000
condition|)
block|{
name|tsa
operator|->
name|tv_sec
operator|++
expr_stmt|;
name|tsa
operator|->
name|tv_nsec
operator|-=
literal|1000000000
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|sender_body
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|targ
modifier|*
name|targ
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|pollfd
name|fds
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|targ
operator|->
name|nifp
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|txring
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
init|=
name|targ
operator|->
name|g
operator|->
name|npackets
operator|/
name|targ
operator|->
name|g
operator|->
name|nthreads
decl_stmt|,
name|sent
init|=
literal|0
decl_stmt|;
name|int
name|options
init|=
name|targ
operator|->
name|g
operator|->
name|options
operator||
name|OPT_COPY
decl_stmt|;
name|struct
name|timespec
name|tmptime
decl_stmt|,
name|nexttime
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|// XXX silence compiler
name|int
name|rate_limit
init|=
name|targ
operator|->
name|g
operator|->
name|tx_rate
decl_stmt|;
name|long
name|long
name|waited
init|=
literal|0
decl_stmt|;
name|D
argument_list|(
literal|"start"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setaffinity
argument_list|(
name|targ
operator|->
name|thread
argument_list|,
name|targ
operator|->
name|affinity
argument_list|)
condition|)
goto|goto
name|quit
goto|;
comment|/* setup poll(2) mechanism. */
name|memset
argument_list|(
name|fds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fds
argument_list|)
argument_list|)
expr_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|targ
operator|->
name|fd
expr_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|events
operator|=
operator|(
name|POLLOUT
operator|)
expr_stmt|;
comment|/* main loop.*/
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|targ
operator|->
name|tic
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate_limit
condition|)
block|{
name|tmptime
operator|.
name|tv_sec
operator|=
literal|2
expr_stmt|;
name|tmptime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|timespec_add
argument_list|(
operator|&
name|targ
operator|->
name|tic
argument_list|,
operator|&
name|tmptime
argument_list|)
expr_stmt|;
name|targ
operator|->
name|tic
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wait_time
argument_list|(
name|targ
operator|->
name|tic
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"wait_time: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
name|nexttime
operator|=
name|targ
operator|->
name|tic
expr_stmt|;
block|}
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|dev_type
operator|==
name|DEV_PCAP
condition|)
block|{
name|int
name|size
init|=
name|targ
operator|->
name|g
operator|->
name|pkt_size
decl_stmt|;
name|void
modifier|*
name|pkt
init|=
operator|&
name|targ
operator|->
name|pkt
decl_stmt|;
name|pcap_t
modifier|*
name|p
init|=
name|targ
operator|->
name|g
operator|->
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|targ
operator|->
name|cancel
operator|&&
operator|(
name|n
operator|==
literal|0
operator|||
name|sent
operator|<
name|n
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pcap_inject
argument_list|(
name|p
argument_list|,
name|pkt
argument_list|,
name|size
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sent
operator|++
expr_stmt|;
name|update_addresses
argument_list|(
name|pkt
argument_list|,
name|targ
operator|->
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|targ
operator|->
name|count
operator|=
name|sent
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|dev_type
operator|==
name|DEV_TAP
condition|)
block|{
comment|/* tap */
name|int
name|size
init|=
name|targ
operator|->
name|g
operator|->
name|pkt_size
decl_stmt|;
name|void
modifier|*
name|pkt
init|=
operator|&
name|targ
operator|->
name|pkt
decl_stmt|;
name|D
argument_list|(
literal|"writing to file desc %d"
argument_list|,
name|targ
operator|->
name|g
operator|->
name|main_fd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|targ
operator|->
name|cancel
operator|&&
operator|(
name|n
operator|==
literal|0
operator|||
name|sent
operator|<
name|n
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|write
argument_list|(
name|targ
operator|->
name|g
operator|->
name|main_fd
argument_list|,
name|pkt
argument_list|,
name|size
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sent
operator|++
expr_stmt|;
name|update_addresses
argument_list|(
name|pkt
argument_list|,
name|targ
operator|->
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|targ
operator|->
name|count
operator|=
name|sent
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|tosend
init|=
literal|0
decl_stmt|;
name|int
name|frags
init|=
name|targ
operator|->
name|g
operator|->
name|frags
decl_stmt|;
while|while
condition|(
operator|!
name|targ
operator|->
name|cancel
operator|&&
operator|(
name|n
operator|==
literal|0
operator|||
name|sent
operator|<
name|n
operator|)
condition|)
block|{
if|if
condition|(
name|rate_limit
operator|&&
name|tosend
operator|<=
literal|0
condition|)
block|{
name|tosend
operator|=
name|targ
operator|->
name|g
operator|->
name|burst
expr_stmt|;
name|timespec_add
argument_list|(
operator|&
name|nexttime
argument_list|,
operator|&
name|targ
operator|->
name|g
operator|->
name|tx_period
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_time
argument_list|(
name|nexttime
argument_list|,
operator|&
name|tmptime
argument_list|,
operator|&
name|waited
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"wait_time"
argument_list|)
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
block|}
comment|/* 		 * wait for available room in the send queue(s) 		 */
if|if
condition|(
name|poll
argument_list|(
name|fds
argument_list|,
literal|1
argument_list|,
literal|2000
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|targ
operator|->
name|cancel
condition|)
break|break;
name|D
argument_list|(
literal|"poll error/timeout on queue %d"
argument_list|,
name|targ
operator|->
name|me
argument_list|)
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
comment|/* 		 * scan our queues and send on those with room 		 */
if|if
condition|(
name|options
operator|&
name|OPT_COPY
operator|&&
name|sent
operator|>
literal|100000
operator|&&
operator|!
operator|(
name|targ
operator|->
name|g
operator|->
name|options
operator|&
name|OPT_COPY
operator|)
condition|)
block|{
name|D
argument_list|(
literal|"drop copy"
argument_list|)
expr_stmt|;
name|options
operator|&=
operator|~
name|OPT_COPY
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|targ
operator|->
name|qfirst
init|;
name|i
operator|<
name|targ
operator|->
name|qlast
condition|;
name|i
operator|++
control|)
block|{
name|int
name|m
decl_stmt|,
name|limit
init|=
name|rate_limit
condition|?
name|tosend
else|:
name|targ
operator|->
name|g
operator|->
name|burst
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|-
name|sent
operator|<
name|limit
condition|)
name|limit
operator|=
name|n
operator|-
name|sent
expr_stmt|;
name|txring
operator|=
name|NETMAP_TXRING
argument_list|(
name|nifp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|txring
operator|->
name|avail
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|frags
operator|>
literal|1
condition|)
name|limit
operator|=
operator|(
operator|(
name|limit
operator|+
name|frags
operator|-
literal|1
operator|)
operator|/
name|frags
operator|)
operator|*
name|frags
expr_stmt|;
name|m
operator|=
name|send_packets
argument_list|(
name|txring
argument_list|,
operator|&
name|targ
operator|->
name|pkt
argument_list|,
name|targ
operator|->
name|g
argument_list|,
name|limit
argument_list|,
name|options
argument_list|,
name|frags
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"limit %d avail %d frags %d m %d"
argument_list|,
name|limit
argument_list|,
name|txring
operator|->
name|avail
argument_list|,
name|frags
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sent
operator|+=
name|m
expr_stmt|;
name|targ
operator|->
name|count
operator|=
name|sent
expr_stmt|;
if|if
condition|(
name|rate_limit
condition|)
block|{
name|tosend
operator|-=
name|m
expr_stmt|;
if|if
condition|(
name|tosend
operator|<=
literal|0
condition|)
break|break;
block|}
block|}
block|}
comment|/* flush any remaining packets */
name|ioctl
argument_list|(
name|fds
index|[
literal|0
index|]
operator|.
name|fd
argument_list|,
name|NIOCTXSYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* final part: wait all the TX queues to be empty. */
for|for
control|(
name|i
operator|=
name|targ
operator|->
name|qfirst
init|;
name|i
operator|<
name|targ
operator|->
name|qlast
condition|;
name|i
operator|++
control|)
block|{
name|txring
operator|=
name|NETMAP_TXRING
argument_list|(
name|nifp
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|NETMAP_TX_RING_EMPTY
argument_list|(
name|txring
argument_list|)
condition|)
block|{
name|ioctl
argument_list|(
name|fds
index|[
literal|0
index|]
operator|.
name|fd
argument_list|,
name|NIOCTXSYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* wait 1 tick */
block|}
block|}
block|}
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|targ
operator|->
name|toc
argument_list|)
expr_stmt|;
name|targ
operator|->
name|completed
operator|=
literal|1
expr_stmt|;
name|targ
operator|->
name|count
operator|=
name|sent
expr_stmt|;
name|quit
label|:
comment|/* reset the ``used`` flag. */
name|targ
operator|->
name|used
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|receive_pcap
parameter_list|(
name|u_char
modifier|*
name|user
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|const
name|u_char
modifier|*
name|bytes
parameter_list|)
block|{
name|int
modifier|*
name|count
init|=
operator|(
name|int
operator|*
operator|)
name|user
decl_stmt|;
operator|(
name|void
operator|)
name|h
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|bytes
expr_stmt|;
comment|/* UNUSED */
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|receive_packets
parameter_list|(
name|struct
name|netmap_ring
modifier|*
name|ring
parameter_list|,
name|u_int
name|limit
parameter_list|,
name|int
name|dump
parameter_list|)
block|{
name|u_int
name|cur
decl_stmt|,
name|rx
decl_stmt|;
name|cur
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|avail
operator|<
name|limit
condition|)
name|limit
operator|=
name|ring
operator|->
name|avail
expr_stmt|;
for|for
control|(
name|rx
operator|=
literal|0
init|;
name|rx
operator|<
name|limit
condition|;
name|rx
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|cur
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|NETMAP_BUF
argument_list|(
name|ring
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|dump
condition|)
name|dump_payload
argument_list|(
name|p
argument_list|,
name|slot
operator|->
name|len
argument_list|,
name|ring
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|cur
operator|=
name|NETMAP_RING_NEXT
argument_list|(
name|ring
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
name|ring
operator|->
name|avail
operator|-=
name|rx
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
return|return
operator|(
name|rx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|receiver_body
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|targ
modifier|*
name|targ
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|pollfd
name|fds
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|targ
operator|->
name|nifp
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|rxring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|received
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|setaffinity
argument_list|(
name|targ
operator|->
name|thread
argument_list|,
name|targ
operator|->
name|affinity
argument_list|)
condition|)
goto|goto
name|quit
goto|;
comment|/* setup poll(2) mechanism. */
name|memset
argument_list|(
name|fds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fds
argument_list|)
argument_list|)
expr_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|targ
operator|->
name|fd
expr_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|events
operator|=
operator|(
name|POLLIN
operator|)
expr_stmt|;
comment|/* unbounded wait for the first packet. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|poll
argument_list|(
name|fds
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
name|fds
index|[
literal|0
index|]
operator|.
name|revents
operator|&
name|POLLERR
operator|)
condition|)
break|break;
name|D
argument_list|(
literal|"waiting for initial packets, poll returns %d %d"
argument_list|,
name|i
argument_list|,
name|fds
index|[
literal|0
index|]
operator|.
name|revents
argument_list|)
expr_stmt|;
block|}
comment|/* main loop, exit after 1s silence */
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|targ
operator|->
name|tic
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|dev_type
operator|==
name|DEV_PCAP
condition|)
block|{
while|while
condition|(
operator|!
name|targ
operator|->
name|cancel
condition|)
block|{
comment|/* XXX should we poll ? */
name|pcap_dispatch
argument_list|(
name|targ
operator|->
name|g
operator|->
name|p
argument_list|,
name|targ
operator|->
name|g
operator|->
name|burst
argument_list|,
name|receive_pcap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|dev_type
operator|==
name|DEV_TAP
condition|)
block|{
name|D
argument_list|(
literal|"reading from %s fd %d"
argument_list|,
name|targ
operator|->
name|g
operator|->
name|ifname
argument_list|,
name|targ
operator|->
name|g
operator|->
name|main_fd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|targ
operator|->
name|cancel
condition|)
block|{
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
comment|/* XXX should we poll ? */
if|if
condition|(
name|read
argument_list|(
name|targ
operator|->
name|g
operator|->
name|main_fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|targ
operator|->
name|count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|dump
init|=
name|targ
operator|->
name|g
operator|->
name|options
operator|&
name|OPT_DUMP
decl_stmt|;
while|while
condition|(
operator|!
name|targ
operator|->
name|cancel
condition|)
block|{
comment|/* Once we started to receive packets, wait at most 1 seconds 		   before quitting. */
if|if
condition|(
name|poll
argument_list|(
name|fds
argument_list|,
literal|1
argument_list|,
literal|1
operator|*
literal|1000
argument_list|)
operator|<=
literal|0
operator|&&
operator|!
name|targ
operator|->
name|g
operator|->
name|forever
condition|)
block|{
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|targ
operator|->
name|toc
argument_list|)
expr_stmt|;
name|targ
operator|->
name|toc
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
comment|/* Subtract timeout time. */
break|break;
block|}
for|for
control|(
name|i
operator|=
name|targ
operator|->
name|qfirst
init|;
name|i
operator|<
name|targ
operator|->
name|qlast
condition|;
name|i
operator|++
control|)
block|{
name|int
name|m
decl_stmt|;
name|rxring
operator|=
name|NETMAP_RXRING
argument_list|(
name|nifp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxring
operator|->
name|avail
operator|==
literal|0
condition|)
continue|continue;
name|m
operator|=
name|receive_packets
argument_list|(
name|rxring
argument_list|,
name|targ
operator|->
name|g
operator|->
name|burst
argument_list|,
name|dump
argument_list|)
expr_stmt|;
name|received
operator|+=
name|m
expr_stmt|;
block|}
name|targ
operator|->
name|count
operator|=
name|received
expr_stmt|;
comment|// tell the card we have read the data
comment|//ioctl(fds[0].fd, NIOCRXSYNC, NULL);
block|}
block|}
name|targ
operator|->
name|completed
operator|=
literal|1
expr_stmt|;
name|targ
operator|->
name|count
operator|=
name|received
expr_stmt|;
name|quit
label|:
comment|/* reset the ``used`` flag. */
name|targ
operator|->
name|used
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* very crude code to print a number in normalized form.  * Caller has to make sure that the buffer is large enough.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|norm
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|double
name|val
parameter_list|)
block|{
name|char
modifier|*
name|units
index|[]
init|=
block|{
literal|""
block|,
literal|"K"
block|,
literal|"M"
block|,
literal|"G"
block|}
decl_stmt|;
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|val
operator|>=
literal|1000
operator|&&
name|i
operator|<
sizeof|sizeof
argument_list|(
name|units
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|;
name|i
operator|++
control|)
name|val
operator|/=
literal|1000
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.2f %s"
argument_list|,
name|val
argument_list|,
name|units
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tx_output
parameter_list|(
name|uint64_t
name|sent
parameter_list|,
name|int
name|size
parameter_list|,
name|double
name|delta
parameter_list|)
block|{
name|double
name|bw
decl_stmt|,
name|raw_bw
decl_stmt|,
name|pps
decl_stmt|;
name|char
name|b1
index|[
literal|40
index|]
decl_stmt|,
name|b2
index|[
literal|80
index|]
decl_stmt|,
name|b3
index|[
literal|80
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"Sent %"
name|PRIu64
literal|" packets, %d bytes each, in %.2f seconds.\n"
argument_list|,
name|sent
argument_list|,
name|size
argument_list|,
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|delta
operator|=
literal|1e-6
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|60
condition|)
comment|/* correct for min packet size */
name|size
operator|=
literal|60
expr_stmt|;
name|pps
operator|=
name|sent
operator|/
name|delta
expr_stmt|;
name|bw
operator|=
operator|(
literal|8.0
operator|*
name|size
operator|*
name|sent
operator|)
operator|/
name|delta
expr_stmt|;
comment|/* raw packets have4 bytes crc + 20 bytes framing */
name|raw_bw
operator|=
operator|(
literal|8.0
operator|*
operator|(
name|size
operator|+
literal|24
operator|)
operator|*
name|sent
operator|)
operator|/
name|delta
expr_stmt|;
name|printf
argument_list|(
literal|"Speed: %spps Bandwidth: %sbps (raw %sbps)\n"
argument_list|,
name|norm
argument_list|(
name|b1
argument_list|,
name|pps
argument_list|)
argument_list|,
name|norm
argument_list|(
name|b2
argument_list|,
name|bw
argument_list|)
argument_list|,
name|norm
argument_list|(
name|b3
argument_list|,
name|raw_bw
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rx_output
parameter_list|(
name|uint64_t
name|received
parameter_list|,
name|double
name|delta
parameter_list|)
block|{
name|double
name|pps
decl_stmt|;
name|char
name|b1
index|[
literal|40
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"Received %"
name|PRIu64
literal|" packets, in %.2f seconds.\n"
argument_list|,
name|received
argument_list|,
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|delta
operator|=
literal|1e-6
expr_stmt|;
name|pps
operator|=
name|received
operator|/
name|delta
expr_stmt|;
name|printf
argument_list|(
literal|"Speed: %spps\n"
argument_list|,
name|norm
argument_list|(
name|b1
argument_list|,
name|pps
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cmd
init|=
literal|"pkt-gen"
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage:\n"
literal|"%s arguments\n"
literal|"\t-i interface		interface name\n"
literal|"\t-f function		tx rx ping pong\n"
literal|"\t-n count		number of iterations (can be 0)\n"
literal|"\t-t pkts_to_send		also forces tx mode\n"
literal|"\t-r pkts_to_receive	also forces rx mode\n"
literal|"\t-l pkt_size		in bytes excluding CRC\n"
literal|"\t-d dst_ip[:port[-dst_ip:port]]   single or range\n"
literal|"\t-s src_ip[:port[-src_ip:port]]   single or range\n"
literal|"\t-D dst-mac\n"
literal|"\t-S src-mac\n"
literal|"\t-a cpu_id		use setaffinity\n"
literal|"\t-b burst size		testing, mostly\n"
literal|"\t-c cores		cores to use\n"
literal|"\t-p threads		processes/threads to use\n"
literal|"\t-T report_ms		milliseconds between reports\n"
literal|"\t-P			use libpcap instead of netmap\n"
literal|"\t-w wait_for_link_time	in seconds\n"
literal|"\t-R rate		in packets per second\n"
literal|"\t-X			dump payload\n"
literal|""
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_threads
parameter_list|(
name|struct
name|glob_arg
modifier|*
name|g
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|targs
operator|=
name|calloc
argument_list|(
name|g
operator|->
name|nthreads
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|targs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now create the desired number of threads, each one 	 * using a single descriptor.  	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|nthreads
condition|;
name|i
operator|++
control|)
block|{
name|bzero
argument_list|(
operator|&
name|targs
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|targs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|targs
index|[
name|i
index|]
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* default, with pcap */
name|targs
index|[
name|i
index|]
operator|.
name|g
operator|=
name|g
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|dev_type
operator|==
name|DEV_NETMAP
condition|)
block|{
name|struct
name|nmreq
name|tifreq
decl_stmt|;
name|int
name|tfd
decl_stmt|;
comment|/* register interface. */
name|tfd
operator|=
name|open
argument_list|(
literal|"/dev/netmap"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfd
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"Unable to open /dev/netmap"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|targs
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|tfd
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|tifreq
argument_list|,
sizeof|sizeof
argument_list|(
name|tifreq
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tifreq
operator|.
name|nr_name
argument_list|,
name|g
operator|->
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|tifreq
operator|.
name|nr_name
argument_list|)
argument_list|)
expr_stmt|;
name|tifreq
operator|.
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|tifreq
operator|.
name|nr_ringid
operator|=
operator|(
name|g
operator|->
name|nthreads
operator|>
literal|1
operator|)
condition|?
operator|(
name|i
operator||
name|NETMAP_HW_RING
operator|)
else|:
literal|0
expr_stmt|;
name|parse_nmr_config
argument_list|(
name|g
operator|->
name|nmr_config
argument_list|,
operator|&
name|tifreq
argument_list|)
expr_stmt|;
comment|/* 		 * if we are acting as a receiver only, do not touch the transmit ring. 		 * This is not the default because many apps may use the interface 		 * in both directions, but a pure receiver does not. 		 */
if|if
condition|(
name|g
operator|->
name|td_body
operator|==
name|receiver_body
condition|)
block|{
name|tifreq
operator|.
name|nr_ringid
operator||=
name|NETMAP_NO_TX_POLL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|tfd
argument_list|,
name|NIOCREGIF
argument_list|,
operator|&
name|tifreq
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"Unable to register %s"
argument_list|,
name|g
operator|->
name|ifname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|D
argument_list|(
literal|"memsize is %d MB"
argument_list|,
name|tifreq
operator|.
name|nr_memsize
operator|>>
literal|20
argument_list|)
expr_stmt|;
name|targs
index|[
name|i
index|]
operator|.
name|nmr
operator|=
name|tifreq
expr_stmt|;
name|targs
index|[
name|i
index|]
operator|.
name|nifp
operator|=
name|NETMAP_IF
argument_list|(
name|g
operator|->
name|mmap_addr
argument_list|,
name|tifreq
operator|.
name|nr_offset
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"nifp flags 0x%x"
argument_list|,
name|targs
index|[
name|i
index|]
operator|.
name|nifp
operator|->
name|ni_flags
argument_list|)
expr_stmt|;
comment|/* start threads. */
name|targs
index|[
name|i
index|]
operator|.
name|qfirst
operator|=
operator|(
name|g
operator|->
name|nthreads
operator|>
literal|1
operator|)
condition|?
name|i
else|:
literal|0
expr_stmt|;
name|targs
index|[
name|i
index|]
operator|.
name|qlast
operator|=
operator|(
name|g
operator|->
name|nthreads
operator|>
literal|1
operator|)
condition|?
name|i
operator|+
literal|1
else|:
operator|(
name|g
operator|->
name|td_body
operator|==
name|receiver_body
condition|?
name|tifreq
operator|.
name|nr_rx_rings
else|:
name|tifreq
operator|.
name|nr_tx_rings
operator|)
expr_stmt|;
block|}
else|else
block|{
name|targs
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|g
operator|->
name|main_fd
expr_stmt|;
block|}
name|targs
index|[
name|i
index|]
operator|.
name|used
operator|=
literal|1
expr_stmt|;
name|targs
index|[
name|i
index|]
operator|.
name|me
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|affinity
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|affinity
operator|<
name|g
operator|->
name|cpus
condition|)
name|targs
index|[
name|i
index|]
operator|.
name|affinity
operator|=
name|g
operator|->
name|affinity
expr_stmt|;
else|else
name|targs
index|[
name|i
index|]
operator|.
name|affinity
operator|=
name|i
operator|%
name|g
operator|->
name|cpus
expr_stmt|;
block|}
else|else
name|targs
index|[
name|i
index|]
operator|.
name|affinity
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* default, init packets */
name|initialize_packet
argument_list|(
operator|&
name|targs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pthread_create
argument_list|(
operator|&
name|targs
index|[
name|i
index|]
operator|.
name|thread
argument_list|,
name|NULL
argument_list|,
name|g
operator|->
name|td_body
argument_list|,
operator|&
name|targs
index|[
name|i
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"Unable to create thread %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|targs
index|[
name|i
index|]
operator|.
name|used
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|main_thread
parameter_list|(
name|struct
name|glob_arg
modifier|*
name|g
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint64_t
name|prev
init|=
literal|0
decl_stmt|;
name|uint64_t
name|count
init|=
literal|0
decl_stmt|;
name|double
name|delta_t
decl_stmt|;
name|struct
name|timeval
name|tic
decl_stmt|,
name|toc
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|toc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|timeval
name|now
decl_stmt|,
name|delta
decl_stmt|;
name|uint64_t
name|pps
decl_stmt|,
name|usec
decl_stmt|,
name|my_count
decl_stmt|,
name|npkts
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|delta
operator|.
name|tv_sec
operator|=
name|g
operator|->
name|report_interval
operator|/
literal|1000
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|=
operator|(
name|g
operator|->
name|report_interval
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|select
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|time_second
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|toc
argument_list|,
operator|&
name|toc
argument_list|)
expr_stmt|;
name|my_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|nthreads
condition|;
name|i
operator|++
control|)
block|{
name|my_count
operator|+=
name|targs
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
if|if
condition|(
name|targs
index|[
name|i
index|]
operator|.
name|used
operator|==
literal|0
condition|)
name|done
operator|++
expr_stmt|;
block|}
name|usec
operator|=
name|toc
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|toc
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|usec
operator|<
literal|10000
condition|)
continue|continue;
name|npkts
operator|=
name|my_count
operator|-
name|prev
expr_stmt|;
name|pps
operator|=
operator|(
name|npkts
operator|*
literal|1000000
operator|+
name|usec
operator|/
literal|2
operator|)
operator|/
name|usec
expr_stmt|;
name|D
argument_list|(
literal|"%"
name|PRIu64
literal|" pps (%"
name|PRIu64
literal|" pkts in %"
name|PRIu64
literal|" usec)"
argument_list|,
name|pps
argument_list|,
name|npkts
argument_list|,
name|usec
argument_list|)
expr_stmt|;
name|prev
operator|=
name|my_count
expr_stmt|;
name|toc
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|done
operator|==
name|g
operator|->
name|nthreads
condition|)
break|break;
block|}
name|timerclear
argument_list|(
operator|&
name|tic
argument_list|)
expr_stmt|;
name|timerclear
argument_list|(
operator|&
name|toc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|nthreads
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|timespec
name|t_tic
decl_stmt|,
name|t_toc
decl_stmt|;
comment|/* 		 * Join active threads, unregister interfaces and close 		 * file descriptors. 		 */
if|if
condition|(
name|targs
index|[
name|i
index|]
operator|.
name|used
condition|)
name|pthread_join
argument_list|(
name|targs
index|[
name|i
index|]
operator|.
name|thread
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|targs
index|[
name|i
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
index|[
name|i
index|]
operator|.
name|completed
operator|==
literal|0
condition|)
name|D
argument_list|(
literal|"ouch, thread %d exited with error"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * Collect threads output and extract information about 		 * how long it took to send all the packets. 		 */
name|count
operator|+=
name|targs
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
name|t_tic
operator|=
name|timeval2spec
argument_list|(
operator|&
name|tic
argument_list|)
expr_stmt|;
name|t_toc
operator|=
name|timeval2spec
argument_list|(
operator|&
name|toc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|timerisset
argument_list|(
operator|&
name|tic
argument_list|)
operator|||
name|timespec_ge
argument_list|(
operator|&
name|targs
index|[
name|i
index|]
operator|.
name|tic
argument_list|,
operator|&
name|t_tic
argument_list|)
condition|)
name|tic
operator|=
name|timespec2val
argument_list|(
operator|&
name|targs
index|[
name|i
index|]
operator|.
name|tic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|timerisset
argument_list|(
operator|&
name|toc
argument_list|)
operator|||
name|timespec_ge
argument_list|(
operator|&
name|targs
index|[
name|i
index|]
operator|.
name|toc
argument_list|,
operator|&
name|t_toc
argument_list|)
condition|)
name|toc
operator|=
name|timespec2val
argument_list|(
operator|&
name|targs
index|[
name|i
index|]
operator|.
name|toc
argument_list|)
expr_stmt|;
block|}
comment|/* print output. */
name|timersub
argument_list|(
operator|&
name|toc
argument_list|,
operator|&
name|tic
argument_list|,
operator|&
name|toc
argument_list|)
expr_stmt|;
name|delta_t
operator|=
name|toc
operator|.
name|tv_sec
operator|+
literal|1e-6
operator|*
name|toc
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|td_body
operator|==
name|sender_body
condition|)
name|tx_output
argument_list|(
name|count
argument_list|,
name|g
operator|->
name|pkt_size
argument_list|,
name|delta_t
argument_list|)
expr_stmt|;
else|else
name|rx_output
argument_list|(
name|count
argument_list|,
name|delta_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|dev_type
operator|==
name|DEV_NETMAP
condition|)
block|{
name|munmap
argument_list|(
name|g
operator|->
name|mmap_addr
argument_list|,
name|g
operator|->
name|mmap_size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|g
operator|->
name|main_fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|sf
block|{
name|char
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|f
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|sf
name|func
index|[]
init|=
block|{
block|{
literal|"tx"
block|,
name|sender_body
block|}
block|,
block|{
literal|"rx"
block|,
name|receiver_body
block|}
block|,
block|{
literal|"ping"
block|,
name|pinger_body
block|}
block|,
block|{
literal|"pong"
block|,
name|ponger_body
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|tap_alloc
parameter_list|(
name|char
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|err
decl_stmt|;
name|char
modifier|*
name|clonedev
init|=
name|TAP_CLONEDEV
decl_stmt|;
operator|(
name|void
operator|)
name|err
expr_stmt|;
operator|(
name|void
operator|)
name|dev
expr_stmt|;
comment|/* Arguments taken by the function: 	 * 	 * char *dev: the name of an interface (or '\0'). MUST have enough 	 *   space to hold the interface name if '\0' is passed 	 * int flags: interface flags (eg, IFF_TUN etc.) 	 */
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|dev
index|[
literal|3
index|]
condition|)
block|{
comment|/* tapSomething */
specifier|static
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|clonedev
operator|=
name|buf
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* open the device */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|clonedev
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
name|fd
return|;
block|}
name|D
argument_list|(
literal|"%s open successful"
argument_list|,
name|clonedev
argument_list|)
expr_stmt|;
comment|/* preparation of the struct ifr, of type "struct ifreq" */
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|linux
name|ifr
operator|.
name|ifr_flags
operator|=
name|IFF_TAP
operator||
name|IFF_NO_PI
expr_stmt|;
if|if
condition|(
operator|*
name|dev
condition|)
block|{
comment|/* if a device name was specified, put it in the structure; otherwise, 		* the kernel will try to allocate the "next" device of the 		* specified type */
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|dev
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
block|}
comment|/* try to create the device */
if|if
condition|(
operator|(
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TUNSETIFF
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"failed to to a TUNSETIFF"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* if the operation was successful, write back the name of the 	* interface to the variable "dev", so the caller can know 	* it. Note that the caller MUST reserve space in *dev (see calling 	* code below) */
name|strcpy
argument_list|(
name|dev
argument_list|,
name|ifr
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"new name is %s"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* linux */
comment|/* this is the special file descriptor that the caller will use to talk          * with the virtual interface */
return|return
name|fd
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|arc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|glob_arg
name|g
decl_stmt|;
name|struct
name|nmreq
name|nmr
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|wait_link
init|=
literal|2
decl_stmt|;
name|int
name|devqueues
init|=
literal|1
decl_stmt|;
comment|/* how many device queues */
name|bzero
argument_list|(
operator|&
name|g
argument_list|,
sizeof|sizeof
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|.
name|main_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|g
operator|.
name|td_body
operator|=
name|receiver_body
expr_stmt|;
name|g
operator|.
name|report_interval
operator|=
literal|1000
expr_stmt|;
comment|/* report interval */
name|g
operator|.
name|affinity
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* ip addresses can also be a range x.x.x.x-x.x.x.y */
name|g
operator|.
name|src_ip
operator|.
name|name
operator|=
literal|"10.0.0.1"
expr_stmt|;
name|g
operator|.
name|dst_ip
operator|.
name|name
operator|=
literal|"10.1.0.1"
expr_stmt|;
name|g
operator|.
name|dst_mac
operator|.
name|name
operator|=
literal|"ff:ff:ff:ff:ff:ff"
expr_stmt|;
name|g
operator|.
name|src_mac
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|g
operator|.
name|pkt_size
operator|=
literal|60
expr_stmt|;
name|g
operator|.
name|burst
operator|=
literal|512
expr_stmt|;
comment|// default
name|g
operator|.
name|nthreads
operator|=
literal|1
expr_stmt|;
name|g
operator|.
name|cpus
operator|=
literal|1
expr_stmt|;
name|g
operator|.
name|forever
operator|=
literal|1
expr_stmt|;
name|g
operator|.
name|tx_rate
operator|=
literal|0
expr_stmt|;
name|g
operator|.
name|frags
operator|=
literal|1
expr_stmt|;
name|g
operator|.
name|nmr_config
operator|=
literal|""
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|arc
argument_list|,
name|argv
argument_list|,
literal|"a:f:F:n:i:It:r:l:d:s:D:S:b:c:o:p:PT:w:WvR:XC:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|sf
modifier|*
name|fn
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
default|default:
name|D
argument_list|(
literal|"bad option %c %s"
argument_list|,
name|ch
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|g
operator|.
name|npackets
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|i
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
operator|||
name|i
operator|>
literal|63
condition|)
block|{
name|D
argument_list|(
literal|"invalid frags %d [1..63], ignore"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|g
operator|.
name|frags
operator|=
name|i
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
for|for
control|(
name|fn
operator|=
name|func
init|;
name|fn
operator|->
name|key
condition|;
name|fn
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fn
operator|->
name|key
argument_list|,
name|optarg
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|fn
operator|->
name|key
condition|)
name|g
operator|.
name|td_body
operator|=
name|fn
operator|->
name|f
expr_stmt|;
else|else
name|D
argument_list|(
literal|"unrecognised function %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* data generation options */
name|g
operator|.
name|options
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* force affinity */
name|g
operator|.
name|affinity
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* interface */
name|g
operator|.
name|ifname
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"tap"
argument_list|,
literal|3
argument_list|)
condition|)
name|g
operator|.
name|dev_type
operator|=
name|DEV_TAP
expr_stmt|;
else|else
name|g
operator|.
name|dev_type
operator|=
name|DEV_NETMAP
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|g
operator|.
name|ifname
argument_list|,
literal|"null"
argument_list|)
condition|)
name|g
operator|.
name|dummy_send
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|g
operator|.
name|options
operator||=
name|OPT_INDIRECT
expr_stmt|;
comment|/* XXX use indirect buffer */
break|break;
case|case
literal|'t'
case|:
comment|/* send, deprecated */
name|D
argument_list|(
literal|"-t deprecated, please use -f tx -n %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|g
operator|.
name|td_body
operator|=
name|sender_body
expr_stmt|;
name|g
operator|.
name|npackets
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* receive */
name|D
argument_list|(
literal|"-r deprecated, please use -f rx -n %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|g
operator|.
name|td_body
operator|=
name|receiver_body
expr_stmt|;
name|g
operator|.
name|npackets
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* pkt_size */
name|g
operator|.
name|pkt_size
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|g
operator|.
name|dst_ip
operator|.
name|name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|g
operator|.
name|src_ip
operator|.
name|name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* report interval */
name|g
operator|.
name|report_interval
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wait_link
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
comment|/* XXX changed default */
name|g
operator|.
name|forever
operator|=
literal|0
expr_stmt|;
comment|/* do not exit rx even with no traffic */
break|break;
case|case
literal|'b'
case|:
comment|/* burst */
name|g
operator|.
name|burst
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|g
operator|.
name|cpus
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|g
operator|.
name|nthreads
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|g
operator|.
name|dev_type
operator|=
name|DEV_PCAP
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* destination mac */
name|g
operator|.
name|dst_mac
operator|.
name|name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* source mac */
name|g
operator|.
name|src_mac
operator|.
name|name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|g
operator|.
name|tx_rate
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|g
operator|.
name|options
operator||=
name|OPT_DUMP
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|g
operator|.
name|nmr_config
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|g
operator|.
name|ifname
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"missing ifname"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|i
operator|=
name|system_ncpus
argument_list|()
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|cpus
operator|<
literal|0
operator|||
name|g
operator|.
name|cpus
operator|>
name|i
condition|)
block|{
name|D
argument_list|(
literal|"%d cpus is too high, have only %d cpus"
argument_list|,
name|g
operator|.
name|cpus
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|.
name|cpus
operator|==
literal|0
condition|)
name|g
operator|.
name|cpus
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|pkt_size
operator|<
literal|16
operator|||
name|g
operator|.
name|pkt_size
operator|>
literal|1536
condition|)
block|{
name|D
argument_list|(
literal|"bad pktsize %d\n"
argument_list|,
name|g
operator|.
name|pkt_size
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|.
name|src_mac
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
specifier|static
name|char
name|mybuf
index|[
literal|20
index|]
init|=
literal|"00:00:00:00:00:00"
decl_stmt|;
comment|/* retrieve source mac address. */
if|if
condition|(
name|source_hwaddr
argument_list|(
name|g
operator|.
name|ifname
argument_list|,
name|mybuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"Unable to retrieve source mac"
argument_list|)
expr_stmt|;
comment|// continue, fail later
block|}
name|g
operator|.
name|src_mac
operator|.
name|name
operator|=
name|mybuf
expr_stmt|;
block|}
comment|/* extract address ranges */
name|extract_ip_range
argument_list|(
operator|&
name|g
operator|.
name|src_ip
argument_list|)
expr_stmt|;
name|extract_ip_range
argument_list|(
operator|&
name|g
operator|.
name|dst_ip
argument_list|)
expr_stmt|;
name|extract_mac_range
argument_list|(
operator|&
name|g
operator|.
name|src_mac
argument_list|)
expr_stmt|;
name|extract_mac_range
argument_list|(
operator|&
name|g
operator|.
name|dst_mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|dev_type
operator|==
name|DEV_TAP
condition|)
block|{
name|D
argument_list|(
literal|"want to use tap %s"
argument_list|,
name|g
operator|.
name|ifname
argument_list|)
expr_stmt|;
name|g
operator|.
name|main_fd
operator|=
name|tap_alloc
argument_list|(
name|g
operator|.
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|main_fd
operator|<
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"cannot open tap %s"
argument_list|,
name|g
operator|.
name|ifname
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|g
operator|.
name|dev_type
operator|>
name|DEV_NETMAP
condition|)
block|{
name|char
name|pcap_errbuf
index|[
name|PCAP_ERRBUF_SIZE
index|]
decl_stmt|;
name|D
argument_list|(
literal|"using pcap on %s"
argument_list|,
name|g
operator|.
name|ifname
argument_list|)
expr_stmt|;
name|pcap_errbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|// init the buffer
name|g
operator|.
name|p
operator|=
name|pcap_open_live
argument_list|(
name|g
operator|.
name|ifname
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|,
name|pcap_errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|p
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"cannot open pcap on %s"
argument_list|,
name|g
operator|.
name|ifname
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|g
operator|.
name|dummy_send
condition|)
block|{
name|D
argument_list|(
literal|"using a dummy send routine"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
operator|&
name|nmr
argument_list|,
sizeof|sizeof
argument_list|(
name|nmr
argument_list|)
argument_list|)
expr_stmt|;
name|nmr
operator|.
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
comment|/* 	 * Open the netmap device to fetch the number of queues of our 	 * interface. 	 * 	 * The first NIOCREGIF also detaches the card from the 	 * protocol stack and may cause a reset of the card, 	 * which in turn may take some time for the PHY to 	 * reconfigure. 	 */
name|g
operator|.
name|main_fd
operator|=
name|open
argument_list|(
literal|"/dev/netmap"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|main_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"Unable to open /dev/netmap"
argument_list|)
expr_stmt|;
comment|// fail later
block|}
comment|/* 	 * Register the interface on the netmap device: from now on, 	 * we can operate on the network interface without any 	 * interference from the legacy network stack. 	 * 	 * We decide to put the first interface registration here to 	 * give time to cards that take a long time to reset the PHY. 	 */
name|bzero
argument_list|(
operator|&
name|nmr
argument_list|,
sizeof|sizeof
argument_list|(
name|nmr
argument_list|)
argument_list|)
expr_stmt|;
name|nmr
operator|.
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|strncpy
argument_list|(
name|nmr
operator|.
name|nr_name
argument_list|,
name|g
operator|.
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|nmr
operator|.
name|nr_name
argument_list|)
argument_list|)
expr_stmt|;
name|nmr
operator|.
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|parse_nmr_config
argument_list|(
name|g
operator|.
name|nmr_config
argument_list|,
operator|&
name|nmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|g
operator|.
name|main_fd
argument_list|,
name|NIOCREGIF
argument_list|,
operator|&
name|nmr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"Unable to register interface %s"
argument_list|,
name|g
operator|.
name|ifname
argument_list|)
expr_stmt|;
comment|//continue, fail later
block|}
name|ND
argument_list|(
literal|"%s: txr %d txd %d rxr %d rxd %d"
argument_list|,
name|g
operator|.
name|ifname
argument_list|,
name|nmr
operator|.
name|nr_tx_rings
argument_list|,
name|nmr
operator|.
name|nr_tx_slots
argument_list|,
name|nmr
operator|.
name|nr_rx_rings
argument_list|,
name|nmr
operator|.
name|nr_rx_slots
argument_list|)
expr_stmt|;
comment|//if ((ioctl(g.main_fd, NIOCGINFO,&nmr)) == -1) {
comment|//	D("Unable to get if info without name");
comment|//} else {
comment|//	D("map size is %d Kb", nmr.nr_memsize>> 10);
comment|//}
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|g
operator|.
name|main_fd
argument_list|,
name|NIOCGINFO
argument_list|,
operator|&
name|nmr
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"Unable to get if info for %s"
argument_list|,
name|g
operator|.
name|ifname
argument_list|)
expr_stmt|;
block|}
name|devqueues
operator|=
name|nmr
operator|.
name|nr_rx_rings
expr_stmt|;
comment|/* validate provided nthreads. */
if|if
condition|(
name|g
operator|.
name|nthreads
operator|<
literal|1
operator|||
name|g
operator|.
name|nthreads
operator|>
name|devqueues
condition|)
block|{
name|D
argument_list|(
literal|"bad nthreads %d, have %d queues"
argument_list|,
name|g
operator|.
name|nthreads
argument_list|,
name|devqueues
argument_list|)
expr_stmt|;
comment|// continue, fail later
block|}
comment|/* 	 * Map the netmap shared memory: instead of issuing mmap() 	 * inside the body of the threads, we prefer to keep this 	 * operation here to simplify the thread logic. 	 */
name|D
argument_list|(
literal|"mapping %d Kbytes"
argument_list|,
name|nmr
operator|.
name|nr_memsize
operator|>>
literal|10
argument_list|)
expr_stmt|;
name|g
operator|.
name|mmap_size
operator|=
name|nmr
operator|.
name|nr_memsize
expr_stmt|;
name|g
operator|.
name|mmap_addr
operator|=
operator|(
expr|struct
name|netmap_d
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|nmr
operator|.
name|nr_memsize
argument_list|,
name|PROT_WRITE
operator||
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|g
operator|.
name|main_fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|mmap_addr
operator|==
name|MAP_FAILED
condition|)
block|{
name|D
argument_list|(
literal|"Unable to mmap %d KB"
argument_list|,
name|nmr
operator|.
name|nr_memsize
operator|>>
literal|10
argument_list|)
expr_stmt|;
comment|// continue, fail later
block|}
comment|/* Print some debug information. */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s %s: %d queues, %d threads and %d cpus.\n"
argument_list|,
operator|(
name|g
operator|.
name|td_body
operator|==
name|sender_body
operator|)
condition|?
literal|"Sending on"
else|:
literal|"Receiving from"
argument_list|,
name|g
operator|.
name|ifname
argument_list|,
name|devqueues
argument_list|,
name|g
operator|.
name|nthreads
argument_list|,
name|g
operator|.
name|cpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|td_body
operator|==
name|sender_body
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s -> %s (%s -> %s)\n"
argument_list|,
name|g
operator|.
name|src_ip
operator|.
name|name
argument_list|,
name|g
operator|.
name|dst_ip
operator|.
name|name
argument_list|,
name|g
operator|.
name|src_mac
operator|.
name|name
argument_list|,
name|g
operator|.
name|dst_mac
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Exit if something went wrong. */
if|if
condition|(
name|g
operator|.
name|main_fd
operator|<
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"aborting"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|g
operator|.
name|options
condition|)
block|{
name|D
argument_list|(
literal|"--- SPECIAL OPTIONS:%s%s%s%s%s\n"
argument_list|,
name|g
operator|.
name|options
operator|&
name|OPT_PREFETCH
condition|?
literal|" prefetch"
else|:
literal|""
argument_list|,
name|g
operator|.
name|options
operator|&
name|OPT_ACCESS
condition|?
literal|" access"
else|:
literal|""
argument_list|,
name|g
operator|.
name|options
operator|&
name|OPT_MEMCPY
condition|?
literal|" memcpy"
else|:
literal|""
argument_list|,
name|g
operator|.
name|options
operator|&
name|OPT_INDIRECT
condition|?
literal|" indirect"
else|:
literal|""
argument_list|,
name|g
operator|.
name|options
operator|&
name|OPT_COPY
condition|?
literal|" copy"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|g
operator|.
name|tx_period
operator|.
name|tv_sec
operator|=
name|g
operator|.
name|tx_period
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|tx_rate
operator|>
literal|0
condition|)
block|{
comment|/* try to have at least something every second, 		 * reducing the burst size to 0.5s worth of data 		 * (but no less than one full set of fragments) 	 	 */
if|if
condition|(
name|g
operator|.
name|burst
operator|>
name|g
operator|.
name|tx_rate
operator|/
literal|2
condition|)
name|g
operator|.
name|burst
operator|=
name|g
operator|.
name|tx_rate
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|burst
operator|<
name|g
operator|.
name|frags
condition|)
name|g
operator|.
name|burst
operator|=
name|g
operator|.
name|frags
expr_stmt|;
name|g
operator|.
name|tx_period
operator|.
name|tv_nsec
operator|=
operator|(
literal|1e9
operator|/
name|g
operator|.
name|tx_rate
operator|)
operator|*
name|g
operator|.
name|burst
expr_stmt|;
name|g
operator|.
name|tx_period
operator|.
name|tv_sec
operator|=
name|g
operator|.
name|tx_period
operator|.
name|tv_nsec
operator|/
literal|1000000000
expr_stmt|;
name|g
operator|.
name|tx_period
operator|.
name|tv_nsec
operator|=
name|g
operator|.
name|tx_period
operator|.
name|tv_nsec
operator|%
literal|1000000000
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|.
name|td_body
operator|==
name|sender_body
condition|)
name|D
argument_list|(
literal|"Sending %d packets every  %ld.%09ld s"
argument_list|,
name|g
operator|.
name|burst
argument_list|,
name|g
operator|.
name|tx_period
operator|.
name|tv_sec
argument_list|,
name|g
operator|.
name|tx_period
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
comment|/* Wait for PHY reset. */
name|D
argument_list|(
literal|"Wait %d secs for phy reset"
argument_list|,
name|wait_link
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|wait_link
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"Ready..."
argument_list|)
expr_stmt|;
comment|/* Install ^C handler. */
name|global_nthreads
operator|=
name|g
operator|.
name|nthreads
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint_h
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|// XXX this is not needed, i believe
block|if (g.dev_type> DEV_NETMAP) { 		g.p = pcap_open_live(g.ifname, 0, 1, 100, NULL); 		if (g.p == NULL) { 			D("cannot open pcap on %s", g.ifname); 			usage(); 		} else 			D("using pcap %p on %s", g.p, g.ifname); 	}
endif|#
directive|endif
comment|// XXX
name|start_threads
argument_list|(
operator|&
name|g
argument_list|)
expr_stmt|;
name|main_thread
argument_list|(
operator|&
name|g
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* end of file */
end_comment

end_unit

