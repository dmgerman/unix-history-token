begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011-2014 Matteo Landi, Luigi Rizzo. All rights reserved.  * Copyright (C) 2013-2015 Universita` di Pisa. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  * $Id: pkt-gen.c 12346 2013-06-12 17:36:25Z luigi $  *  * Example program to show how to build a multithreaded packet  * source/sink using the netmap device.  *  * In this example we create a programmable number of threads  * to take care of all the queues of the interface used to  * send or receive traffic.  *  */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_comment
comment|/* for CPU_SET() */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|NETMAP_WITH_LIBS
end_define

begin_include
include|#
directive|include
file|<net/netmap_user.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|// isprint()
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|// sysconf()
end_comment

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_comment
comment|/* ntohs */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_comment
comment|/* sysctl */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ifaddrs.h>
end_include

begin_comment
comment|/* getifaddrs */
end_comment

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_PCAP
end_ifndef

begin_include
include|#
directive|include
file|<pcap/pcap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ctrs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_define
define|#
directive|define
name|cpuset_t
value|DWORD_PTR
end_define

begin_comment
comment|//uint64_t
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|CPU_ZERO
parameter_list|(
name|cpuset_t
modifier|*
name|p
parameter_list|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|CPU_SET
parameter_list|(
name|uint32_t
name|i
parameter_list|,
name|cpuset_t
modifier|*
name|p
parameter_list|)
block|{
operator|*
name|p
operator||=
literal|1
operator|<<
operator|(
name|i
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|pthread_setaffinity_np
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|!SetThreadAffinityMask(a, *c)
end_define

begin_comment
comment|//((void)a, 0)
end_comment

begin_define
define|#
directive|define
name|TAP_CLONEDEV
value|"/dev/tap"
end_define

begin_define
define|#
directive|define
name|AF_LINK
value|18
end_define

begin_comment
comment|//defined in winsocks.h
end_comment

begin_define
define|#
directive|define
name|CLOCK_REALTIME_PRECISE
value|CLOCK_REALTIME
end_define

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_comment
comment|/*  * Convert an ASCII representation of an ethernet address to  * binary form.  */
end_comment

begin_function
name|struct
name|ether_addr
modifier|*
name|ether_aton
parameter_list|(
specifier|const
name|char
modifier|*
name|a
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|struct
name|ether_addr
name|o
decl_stmt|;
name|unsigned
name|int
name|o0
decl_stmt|,
name|o1
decl_stmt|,
name|o2
decl_stmt|,
name|o3
decl_stmt|,
name|o4
decl_stmt|,
name|o5
decl_stmt|;
name|i
operator|=
name|sscanf
argument_list|(
name|a
argument_list|,
literal|"%x:%x:%x:%x:%x:%x"
argument_list|,
operator|&
name|o0
argument_list|,
operator|&
name|o1
argument_list|,
operator|&
name|o2
argument_list|,
operator|&
name|o3
argument_list|,
operator|&
name|o4
argument_list|,
operator|&
name|o5
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|6
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|o
operator|.
name|octet
index|[
literal|0
index|]
operator|=
name|o0
expr_stmt|;
name|o
operator|.
name|octet
index|[
literal|1
index|]
operator|=
name|o1
expr_stmt|;
name|o
operator|.
name|octet
index|[
literal|2
index|]
operator|=
name|o2
expr_stmt|;
name|o
operator|.
name|octet
index|[
literal|3
index|]
operator|=
name|o3
expr_stmt|;
name|o
operator|.
name|octet
index|[
literal|4
index|]
operator|=
name|o4
expr_stmt|;
name|o
operator|.
name|octet
index|[
literal|5
index|]
operator|=
name|o5
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|ether_addr
operator|*
operator|)
operator|&
name|o
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a binary representation of an ethernet address to  * an ASCII string.  */
end_comment

begin_function
name|char
modifier|*
name|ether_ntoa
parameter_list|(
specifier|const
name|struct
name|ether_addr
modifier|*
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|a
index|[
literal|18
index|]
decl_stmt|;
name|i
operator|=
name|sprintf
argument_list|(
name|a
argument_list|,
literal|"%02x:%02x:%02x:%02x:%02x:%02x"
argument_list|,
name|n
operator|->
name|octet
index|[
literal|0
index|]
argument_list|,
name|n
operator|->
name|octet
index|[
literal|1
index|]
argument_list|,
name|n
operator|->
name|octet
index|[
literal|2
index|]
argument_list|,
name|n
operator|->
name|octet
index|[
literal|3
index|]
argument_list|,
name|n
operator|->
name|octet
index|[
literal|4
index|]
argument_list|,
name|n
operator|->
name|octet
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|<
literal|17
condition|?
name|NULL
else|:
operator|(
name|char
operator|*
operator|)
operator|&
name|a
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_define
define|#
directive|define
name|cpuset_t
value|cpu_set_t
end_define

begin_define
define|#
directive|define
name|ifr_flagshigh
value|ifr_flags
end_define

begin_comment
comment|/* only the low 16 bits here */
end_comment

begin_define
define|#
directive|define
name|IFF_PPROMISC
value|IFF_PROMISC
end_define

begin_comment
comment|/* IFF_PPROMISC does not exist */
end_comment

begin_include
include|#
directive|include
file|<linux/ethtool.h>
end_include

begin_include
include|#
directive|include
file|<linux/sockios.h>
end_include

begin_define
define|#
directive|define
name|CLOCK_REALTIME_PRECISE
value|CLOCK_REALTIME
end_define

begin_include
include|#
directive|include
file|<netinet/ether.h>
end_include

begin_comment
comment|/* ether_aton */
end_comment

begin_include
include|#
directive|include
file|<linux/if_packet.h>
end_include

begin_comment
comment|/* sockaddr_ll */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* linux */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_comment
comment|/* le64toh */
end_comment

begin_include
include|#
directive|include
file|<machine/param.h>
end_include

begin_include
include|#
directive|include
file|<pthread_np.h>
end_include

begin_comment
comment|/* pthread w/ affinity */
end_comment

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_comment
comment|/* cpu_set */
end_comment

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_comment
comment|/* LLADDR */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__APPLE__
end_ifdef

begin_define
define|#
directive|define
name|cpuset_t
value|uint64_t
end_define

begin_comment
comment|// XXX
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|CPU_ZERO
parameter_list|(
name|cpuset_t
modifier|*
name|p
parameter_list|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|CPU_SET
parameter_list|(
name|uint32_t
name|i
parameter_list|,
name|cpuset_t
modifier|*
name|p
parameter_list|)
block|{
operator|*
name|p
operator||=
literal|1
operator|<<
operator|(
name|i
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|pthread_setaffinity_np
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|((void)a, 0)
end_define

begin_define
define|#
directive|define
name|ifr_flagshigh
value|ifr_flags
end_define

begin_comment
comment|// XXX
end_comment

begin_define
define|#
directive|define
name|IFF_PPROMISC
value|IFF_PROMISC
end_define

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_comment
comment|/* LLADDR */
end_comment

begin_define
define|#
directive|define
name|clock_gettime
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|do {struct timespec t0 = {0,0}; *(b) = t0; } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __APPLE__ */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|default_payload
init|=
literal|"netmap pkt-gen DIRECT payload\n"
literal|"http://info.iet.unipi.it/~luigi/netmap/ "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|indirect_payload
init|=
literal|"netmap pkt-gen indirect payload\n"
literal|"http://info.iet.unipi.it/~luigi/netmap/ "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SKIP_PAYLOAD
value|1
end_define

begin_comment
comment|/* do not check payload. XXX unused */
end_comment

begin_define
define|#
directive|define
name|VIRT_HDR_1
value|10
end_define

begin_comment
comment|/* length of a base vnet-hdr */
end_comment

begin_define
define|#
directive|define
name|VIRT_HDR_2
value|12
end_define

begin_comment
comment|/* length of the extenede vnet-hdr */
end_comment

begin_define
define|#
directive|define
name|VIRT_HDR_MAX
value|VIRT_HDR_2
end_define

begin_struct
struct|struct
name|virt_header
block|{
name|uint8_t
name|fields
index|[
name|VIRT_HDR_MAX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_BODYSIZE
value|16384
end_define

begin_struct
struct|struct
name|pkt
block|{
name|struct
name|virt_header
name|vh
decl_stmt|;
name|struct
name|ether_header
name|eh
decl_stmt|;
name|struct
name|ip
name|ip
decl_stmt|;
name|struct
name|udphdr
name|udp
decl_stmt|;
name|uint8_t
name|body
index|[
name|MAX_BODYSIZE
index|]
decl_stmt|;
comment|// XXX hardwired
block|}
name|__attribute__
argument_list|(
operator|(
name|__packed__
operator|)
argument_list|)
struct|;
end_struct

begin_struct
struct|struct
name|ip_range
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|uint32_t
name|start
decl_stmt|,
name|end
decl_stmt|;
comment|/* same as struct in_addr */
name|uint16_t
name|port0
decl_stmt|,
name|port1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mac_range
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|ether_addr
name|start
decl_stmt|,
name|end
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ifname can be netmap:foo-xxxx */
end_comment

begin_define
define|#
directive|define
name|MAX_IFNAMELEN
value|64
end_define

begin_comment
comment|/* our buffer for ifname */
end_comment

begin_comment
comment|//#define MAX_PKTSIZE	1536
end_comment

begin_define
define|#
directive|define
name|MAX_PKTSIZE
value|MAX_BODYSIZE
end_define

begin_comment
comment|/* XXX: + IP_HDR + ETH_HDR */
end_comment

begin_comment
comment|/* compact timestamp to fit into 60 byte packet. (enough to obtain RTT) */
end_comment

begin_struct
struct|struct
name|tstamp
block|{
name|uint32_t
name|sec
decl_stmt|;
name|uint32_t
name|nsec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * global arguments for all threads  */
end_comment

begin_struct
struct|struct
name|glob_arg
block|{
name|struct
name|ip_range
name|src_ip
decl_stmt|;
name|struct
name|ip_range
name|dst_ip
decl_stmt|;
name|struct
name|mac_range
name|dst_mac
decl_stmt|;
name|struct
name|mac_range
name|src_mac
decl_stmt|;
name|int
name|pkt_size
decl_stmt|;
name|int
name|burst
decl_stmt|;
name|int
name|forever
decl_stmt|;
name|uint64_t
name|npackets
decl_stmt|;
comment|/* total packets to send */
name|int
name|frags
decl_stmt|;
comment|/* fragments per packet */
name|int
name|nthreads
decl_stmt|;
name|int
name|cpus
decl_stmt|;
comment|/* cpus used for running */
name|int
name|system_cpus
decl_stmt|;
comment|/* cpus on the system */
name|int
name|options
decl_stmt|;
comment|/* testing */
define|#
directive|define
name|OPT_PREFETCH
value|1
define|#
directive|define
name|OPT_ACCESS
value|2
define|#
directive|define
name|OPT_COPY
value|4
define|#
directive|define
name|OPT_MEMCPY
value|8
define|#
directive|define
name|OPT_TS
value|16
comment|/* add a timestamp */
define|#
directive|define
name|OPT_INDIRECT
value|32
comment|/* use indirect buffers, tx only */
define|#
directive|define
name|OPT_DUMP
value|64
comment|/* dump rx/tx traffic */
define|#
directive|define
name|OPT_RUBBISH
value|256
comment|/* send wathever the buffers contain */
define|#
directive|define
name|OPT_RANDOM_SRC
value|512
define|#
directive|define
name|OPT_RANDOM_DST
value|1024
define|#
directive|define
name|OPT_PPS_STATS
value|2048
name|int
name|dev_type
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_PCAP
name|pcap_t
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
name|int
name|tx_rate
decl_stmt|;
name|struct
name|timespec
name|tx_period
decl_stmt|;
name|int
name|affinity
decl_stmt|;
name|int
name|main_fd
decl_stmt|;
name|struct
name|nm_desc
modifier|*
name|nmd
decl_stmt|;
name|int
name|report_interval
decl_stmt|;
comment|/* milliseconds between prints */
name|void
modifier|*
function_decl|(
modifier|*
name|td_body
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|int
name|td_type
decl_stmt|;
name|void
modifier|*
name|mmap_addr
decl_stmt|;
name|char
name|ifname
index|[
name|MAX_IFNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|nmr_config
decl_stmt|;
name|int
name|dummy_send
decl_stmt|;
name|int
name|virt_header
decl_stmt|;
comment|/* send also the virt_header */
name|int
name|extra_bufs
decl_stmt|;
comment|/* goes in nr_arg3 */
name|int
name|extra_pipes
decl_stmt|;
comment|/* goes in nr_arg1 */
name|char
modifier|*
name|packet_file
decl_stmt|;
comment|/* -P option */
define|#
directive|define
name|STATS_WIN
value|15
name|int
name|win_idx
decl_stmt|;
name|int64_t
name|win
index|[
name|STATS_WIN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|dev_type
block|{
name|DEV_NONE
block|,
name|DEV_NETMAP
block|,
name|DEV_PCAP
block|,
name|DEV_TAP
block|}
enum|;
end_enum

begin_comment
comment|/*  * Arguments for a new thread. The same structure is used by  * the source and the sink  */
end_comment

begin_struct
struct|struct
name|targ
block|{
name|struct
name|glob_arg
modifier|*
name|g
decl_stmt|;
name|int
name|used
decl_stmt|;
name|int
name|completed
decl_stmt|;
name|int
name|cancel
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|nm_desc
modifier|*
name|nmd
decl_stmt|;
comment|/* these ought to be volatile, but they are 	 * only sampled and errors should not accumulate 	 */
name|struct
name|my_ctrs
name|ctr
decl_stmt|;
name|struct
name|timespec
name|tic
decl_stmt|,
name|toc
decl_stmt|;
name|int
name|me
decl_stmt|;
name|pthread_t
name|thread
decl_stmt|;
name|int
name|affinity
decl_stmt|;
name|struct
name|pkt
name|pkt
decl_stmt|;
name|void
modifier|*
name|frame
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * extract the extremes from a range of ipv4 addresses.  * addr_lo[-addr_hi][:port_lo[-port_hi]]  */
end_comment

begin_function
specifier|static
name|void
name|extract_ip_range
parameter_list|(
name|struct
name|ip_range
modifier|*
name|r
parameter_list|)
block|{
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|struct
name|in_addr
name|a
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|D
argument_list|(
literal|"extract IP range from %s"
argument_list|,
name|r
operator|->
name|name
argument_list|)
expr_stmt|;
name|r
operator|->
name|port0
operator|=
name|r
operator|->
name|port1
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|start
operator|=
name|r
operator|->
name|end
operator|=
literal|0
expr_stmt|;
comment|/* the first - splits start/end of range */
name|ap
operator|=
name|index
argument_list|(
name|r
operator|->
name|name
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
comment|/* do we have ports ? */
if|if
condition|(
name|ap
condition|)
block|{
operator|*
name|ap
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* grab the initial values (mandatory) */
name|pp
operator|=
name|index
argument_list|(
name|r
operator|->
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
condition|)
block|{
operator|*
name|pp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|->
name|port0
operator|=
name|r
operator|->
name|port1
operator|=
name|strtol
argument_list|(
name|pp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|inet_aton
argument_list|(
name|r
operator|->
name|name
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|r
operator|->
name|start
operator|=
name|r
operator|->
name|end
operator|=
name|ntohl
argument_list|(
name|a
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
condition|)
block|{
name|pp
operator|=
name|index
argument_list|(
name|ap
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
condition|)
block|{
operator|*
name|pp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|pp
condition|)
name|r
operator|->
name|port1
operator|=
name|strtol
argument_list|(
name|pp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ap
condition|)
block|{
name|inet_aton
argument_list|(
name|ap
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|r
operator|->
name|end
operator|=
name|ntohl
argument_list|(
name|a
operator|.
name|s_addr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|->
name|port0
operator|>
name|r
operator|->
name|port1
condition|)
block|{
name|uint16_t
name|tmp
init|=
name|r
operator|->
name|port0
decl_stmt|;
name|r
operator|->
name|port0
operator|=
name|r
operator|->
name|port1
expr_stmt|;
name|r
operator|->
name|port1
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|start
operator|>
name|r
operator|->
name|end
condition|)
block|{
name|uint32_t
name|tmp
init|=
name|r
operator|->
name|start
decl_stmt|;
name|r
operator|->
name|start
operator|=
name|r
operator|->
name|end
expr_stmt|;
name|r
operator|->
name|end
operator|=
name|tmp
expr_stmt|;
block|}
block|{
name|struct
name|in_addr
name|a
decl_stmt|;
name|char
name|buf1
index|[
literal|16
index|]
decl_stmt|;
comment|// one ip address
name|a
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|r
operator|->
name|end
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf1
argument_list|,
name|inet_ntoa
argument_list|(
name|a
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|r
operator|->
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
condition|)
name|D
argument_list|(
literal|"range is %s:%d to %s:%d"
argument_list|,
name|inet_ntoa
argument_list|(
name|a
argument_list|)
argument_list|,
name|r
operator|->
name|port0
argument_list|,
name|buf1
argument_list|,
name|r
operator|->
name|port1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|extract_mac_range
parameter_list|(
name|struct
name|mac_range
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
name|verbose
condition|)
name|D
argument_list|(
literal|"extract MAC range from %s"
argument_list|,
name|r
operator|->
name|name
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ether_aton
argument_list|(
name|r
operator|->
name|name
argument_list|)
argument_list|,
operator|&
name|r
operator|->
name|start
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ether_aton
argument_list|(
name|r
operator|->
name|name
argument_list|)
argument_list|,
operator|&
name|r
operator|->
name|end
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bcopy(targ->src_mac, eh->ether_shost, 6); 	p = index(targ->g->src_mac, '-'); 	if (p) 		targ->src_mac_range = atoi(p+1);  	bcopy(ether_aton(targ->g->dst_mac), targ->dst_mac, 6); 	bcopy(targ->dst_mac, eh->ether_dhost, 6); 	p = index(targ->g->dst_mac, '-'); 	if (p) 		targ->dst_mac_range = atoi(p+1);
endif|#
directive|endif
if|if
condition|(
name|verbose
condition|)
name|D
argument_list|(
literal|"%s starts at %s"
argument_list|,
name|r
operator|->
name|name
argument_list|,
name|ether_ntoa
argument_list|(
operator|&
name|r
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|targ
modifier|*
name|targs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|global_nthreads
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* control-C handler */
end_comment

begin_function
specifier|static
name|void
name|sigint_h
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|sig
expr_stmt|;
comment|/* UNUSED */
name|D
argument_list|(
literal|"received control-C on thread %p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pthread_self
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|global_nthreads
condition|;
name|i
operator|++
control|)
block|{
name|targs
index|[
name|i
index|]
operator|.
name|cancel
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* sysctl wrapper to return the number of active CPUs */
end_comment

begin_function
specifier|static
name|int
name|system_ncpus
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ncpus
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|int
name|mib
index|[
literal|2
index|]
init|=
block|{
name|CTL_HW
block|,
name|HW_NCPU
block|}
decl_stmt|;
name|size_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|mib
argument_list|)
decl_stmt|;
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
operator|&
name|ncpus
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|linux
argument_list|)
name|ncpus
operator|=
name|sysconf
argument_list|(
name|_SC_NPROCESSORS_ONLN
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN32
argument_list|)
block|{
name|SYSTEM_INFO
name|sysinfo
decl_stmt|;
name|GetSystemInfo
argument_list|(
operator|&
name|sysinfo
argument_list|)
expr_stmt|;
name|ncpus
operator|=
name|sysinfo
operator|.
name|dwNumberOfProcessors
expr_stmt|;
block|}
else|#
directive|else
comment|/* others */
name|ncpus
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* others */
return|return
operator|(
name|ncpus
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_define
define|#
directive|define
name|sockaddr_dl
value|sockaddr_ll
end_define

begin_define
define|#
directive|define
name|sdl_family
value|sll_family
end_define

begin_define
define|#
directive|define
name|AF_LINK
value|AF_PACKET
end_define

begin_define
define|#
directive|define
name|LLADDR
parameter_list|(
name|s
parameter_list|)
value|s->sll_addr;
end_define

begin_include
include|#
directive|include
file|<linux/if_tun.h>
end_include

begin_define
define|#
directive|define
name|TAP_CLONEDEV
value|"/dev/net/tun"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __linux__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<net/if_tun.h>
end_include

begin_define
define|#
directive|define
name|TAP_CLONEDEV
value|"/dev/tap"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__APPLE__
end_ifdef

begin_comment
comment|// #warning TAP not supported on apple ?
end_comment

begin_include
include|#
directive|include
file|<net/if_utun.h>
end_include

begin_define
define|#
directive|define
name|TAP_CLONEDEV
value|"/dev/tap"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __APPLE__ */
end_comment

begin_comment
comment|/*  * parse the vale configuration in conf and put it in nmr.  * Return the flag set if necessary.  * The configuration may consist of 0 to 4 numbers separated  * by commas: #tx-slots,#rx-slots,#tx-rings,#rx-rings.  * Missing numbers or zeroes stand for default values.  * As an additional convenience, if exactly one number  * is specified, then this is assigned to both #tx-slots and #rx-slots.  * If there is no 4th number, then the 3rd is assigned to both #tx-rings  * and #rx-rings.  */
end_comment

begin_function
name|int
name|parse_nmr_config
parameter_list|(
specifier|const
name|char
modifier|*
name|conf
parameter_list|,
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
block|{
name|char
modifier|*
name|w
decl_stmt|,
modifier|*
name|tok
decl_stmt|;
name|int
name|i
decl_stmt|,
name|v
decl_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|nmr
operator|->
name|nr_rx_rings
operator|=
literal|0
expr_stmt|;
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|nmr
operator|->
name|nr_rx_slots
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|conf
operator|==
name|NULL
operator|||
operator|!
operator|*
name|conf
condition|)
return|return
literal|0
return|;
name|w
operator|=
name|strdup
argument_list|(
name|conf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tok
operator|=
name|strtok
argument_list|(
name|w
argument_list|,
literal|","
argument_list|)
init|;
name|tok
condition|;
name|i
operator|++
operator|,
name|tok
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
control|)
block|{
name|v
operator|=
name|atoi
argument_list|(
name|tok
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|nmr
operator|->
name|nr_tx_slots
operator|=
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|v
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|nmr
operator|->
name|nr_rx_slots
operator|=
name|v
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|v
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|v
expr_stmt|;
break|break;
default|default:
name|D
argument_list|(
literal|"ignored config: %s"
argument_list|,
name|tok
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|D
argument_list|(
literal|"txr %d txd %d rxr %d rxd %d"
argument_list|,
name|nmr
operator|->
name|nr_tx_rings
argument_list|,
name|nmr
operator|->
name|nr_tx_slots
argument_list|,
name|nmr
operator|->
name|nr_rx_rings
argument_list|,
name|nmr
operator|->
name|nr_rx_slots
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
operator|(
name|nmr
operator|->
name|nr_tx_rings
operator|||
name|nmr
operator|->
name|nr_tx_slots
operator|||
name|nmr
operator|->
name|nr_rx_rings
operator|||
name|nmr
operator|->
name|nr_rx_slots
operator|)
condition|?
name|NM_OPEN_RING_CFG
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * locate the src mac address for our interface, put it  * into the user-supplied buffer. return 0 if ok, -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|source_hwaddr
parameter_list|(
specifier|const
name|char
modifier|*
name|ifname
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|ifaddrs
modifier|*
name|ifaphead
decl_stmt|,
modifier|*
name|ifap
decl_stmt|;
name|int
name|l
init|=
sizeof|sizeof
argument_list|(
name|ifap
operator|->
name|ifa_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|getifaddrs
argument_list|(
operator|&
name|ifaphead
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"getifaddrs %s failed"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|ifap
operator|=
name|ifaphead
init|;
name|ifap
condition|;
name|ifap
operator|=
name|ifap
operator|->
name|ifa_next
control|)
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sdl
init|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifap
operator|->
name|ifa_addr
decl_stmt|;
name|uint8_t
modifier|*
name|mac
decl_stmt|;
if|if
condition|(
operator|!
name|sdl
operator|||
name|sdl
operator|->
name|sdl_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|ifap
operator|->
name|ifa_name
argument_list|,
name|ifname
argument_list|,
name|l
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|mac
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|LLADDR
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%02x:%02x:%02x:%02x:%02x:%02x"
argument_list|,
name|mac
index|[
literal|0
index|]
argument_list|,
name|mac
index|[
literal|1
index|]
argument_list|,
name|mac
index|[
literal|2
index|]
argument_list|,
name|mac
index|[
literal|3
index|]
argument_list|,
name|mac
index|[
literal|4
index|]
argument_list|,
name|mac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|D
argument_list|(
literal|"source hwaddr %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
name|freeifaddrs
argument_list|(
name|ifaphead
argument_list|)
expr_stmt|;
return|return
name|ifap
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/* set the thread affinity. */
end_comment

begin_function
specifier|static
name|int
name|setaffinity
parameter_list|(
name|pthread_t
name|me
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|cpuset_t
name|cpumask
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Set thread affinity affinity.*/
name|CPU_ZERO
argument_list|(
operator|&
name|cpumask
argument_list|)
expr_stmt|;
name|CPU_SET
argument_list|(
name|i
argument_list|,
operator|&
name|cpumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|pthread_setaffinity_np
argument_list|(
name|me
argument_list|,
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
argument_list|,
operator|&
name|cpumask
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"Unable to set affinity: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the checksum of the given ip header. */
end_comment

begin_function
specifier|static
name|uint16_t
name|checksum
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|uint16_t
name|len
parameter_list|,
name|uint32_t
name|sum
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|addr
init|=
name|data
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
comment|/* Checksum all the pairs of bytes first... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|len
operator|&
operator|~
literal|1U
operator|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|sum
operator|+=
operator|(
name|u_int16_t
operator|)
name|ntohs
argument_list|(
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|addr
operator|+
name|i
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum
operator|>
literal|0xFFFF
condition|)
name|sum
operator|-=
literal|0xFFFF
expr_stmt|;
block|}
comment|/* 	 * If there's a single byte left over, checksum it, too. 	 * Network byte order is big-endian, so the remaining byte is 	 * the high byte. 	 */
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|sum
operator|+=
name|addr
index|[
name|i
index|]
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|sum
operator|>
literal|0xFFFF
condition|)
name|sum
operator|-=
literal|0xFFFF
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|wrapsum
parameter_list|(
name|u_int32_t
name|sum
parameter_list|)
block|{
name|sum
operator|=
operator|~
name|sum
operator|&
literal|0xFFFF
expr_stmt|;
return|return
operator|(
name|htons
argument_list|(
name|sum
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check the payload of the packet for errors (use it for debug).  * Look for consecutive ascii representations of the size of the packet.  */
end_comment

begin_function
specifier|static
name|void
name|dump_payload
parameter_list|(
specifier|const
name|char
modifier|*
name|_p
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|netmap_ring
modifier|*
name|ring
parameter_list|,
name|int
name|cur
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|i0
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_p
decl_stmt|;
comment|/* get the length in ASCII of the length of the packet. */
name|printf
argument_list|(
literal|"ring %p cur %5d [buf %6d flags 0x%04x len %5d]\n"
argument_list|,
name|ring
argument_list|,
name|cur
argument_list|,
name|ring
operator|->
name|slot
index|[
name|cur
index|]
operator|.
name|buf_idx
argument_list|,
name|ring
operator|->
name|slot
index|[
name|cur
index|]
operator|.
name|flags
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* hexdump routine */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
control|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%5d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i0
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|sprintf
argument_list|(
name|buf
operator|+
literal|7
operator|+
name|j
operator|*
literal|3
argument_list|,
literal|"%02x "
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|i0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|sprintf
argument_list|(
name|buf
operator|+
literal|7
operator|+
name|j
operator|+
literal|48
argument_list|,
literal|"%c"
argument_list|,
name|isprint
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
condition|?
name|p
index|[
name|i
index|]
else|:
literal|'.'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Fill a packet with some payload.  * We create a UDP packet so the payload starts at  *	14+20+8 = 42 bytes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_define
define|#
directive|define
name|uh_sport
value|source
end_define

begin_define
define|#
directive|define
name|uh_dport
value|dest
end_define

begin_define
define|#
directive|define
name|uh_ulen
value|len
end_define

begin_define
define|#
directive|define
name|uh_sum
value|check
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* linux */
end_comment

begin_comment
comment|/*  * increment the addressed in the packet,  * starting from the least significant field.  *	DST_IP DST_PORT SRC_IP SRC_PORT  */
end_comment

begin_function
specifier|static
name|void
name|update_addresses
parameter_list|(
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|struct
name|glob_arg
modifier|*
name|g
parameter_list|)
block|{
name|uint32_t
name|a
decl_stmt|;
name|uint16_t
name|p
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
operator|&
name|pkt
operator|->
name|ip
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|udp
init|=
operator|&
name|pkt
operator|->
name|udp
decl_stmt|;
do|do
block|{
comment|/* XXX for now it doesn't handle non-random src, random dst */
if|if
condition|(
name|g
operator|->
name|options
operator|&
name|OPT_RANDOM_SRC
condition|)
block|{
name|udp
operator|->
name|uh_sport
operator|=
name|random
argument_list|()
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|random
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_sport
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
name|g
operator|->
name|src_ip
operator|.
name|port1
condition|)
block|{
comment|/* just inc, no wrap */
name|udp
operator|->
name|uh_sport
operator|=
name|htons
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|udp
operator|->
name|uh_sport
operator|=
name|htons
argument_list|(
name|g
operator|->
name|src_ip
operator|.
name|port0
argument_list|)
expr_stmt|;
name|a
operator|=
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|<
name|g
operator|->
name|src_ip
operator|.
name|end
condition|)
block|{
comment|/* just inc, no wrap */
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|a
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|g
operator|->
name|src_ip
operator|.
name|start
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_sport
operator|=
name|htons
argument_list|(
name|g
operator|->
name|src_ip
operator|.
name|port0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|->
name|options
operator|&
name|OPT_RANDOM_DST
condition|)
block|{
name|udp
operator|->
name|uh_dport
operator|=
name|random
argument_list|()
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|random
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_dport
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
name|g
operator|->
name|dst_ip
operator|.
name|port1
condition|)
block|{
comment|/* just inc, no wrap */
name|udp
operator|->
name|uh_dport
operator|=
name|htons
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|udp
operator|->
name|uh_dport
operator|=
name|htons
argument_list|(
name|g
operator|->
name|dst_ip
operator|.
name|port0
argument_list|)
expr_stmt|;
name|a
operator|=
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|<
name|g
operator|->
name|dst_ip
operator|.
name|end
condition|)
block|{
comment|/* just inc, no wrap */
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|a
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|g
operator|->
name|dst_ip
operator|.
name|start
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|// update checksum
block|}
end_function

begin_comment
comment|/*  * initialize one packet and prepare for the next one.  * The copy could be done better instead of repeating it each time.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_packet
parameter_list|(
name|struct
name|targ
modifier|*
name|targ
parameter_list|)
block|{
name|struct
name|pkt
modifier|*
name|pkt
init|=
operator|&
name|targ
operator|->
name|pkt
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|udp
decl_stmt|;
name|uint16_t
name|paylen
init|=
name|targ
operator|->
name|g
operator|->
name|pkt_size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|payload
init|=
name|targ
operator|->
name|g
operator|->
name|options
operator|&
name|OPT_INDIRECT
condition|?
name|indirect_payload
else|:
name|default_payload
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l0
init|=
name|strlen
argument_list|(
name|payload
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_PCAP
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
index|]
decl_stmt|;
name|pcap_t
modifier|*
name|file
decl_stmt|;
name|struct
name|pcap_pkthdr
modifier|*
name|header
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|packet
decl_stmt|;
comment|/* Read a packet from a PCAP file if asked. */
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|packet_file
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|file
operator|=
name|pcap_open_offline
argument_list|(
name|targ
operator|->
name|g
operator|->
name|packet_file
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|D
argument_list|(
literal|"failed to open pcap file %s"
argument_list|,
name|targ
operator|->
name|g
operator|->
name|packet_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcap_next_ex
argument_list|(
name|file
argument_list|,
operator|&
name|header
argument_list|,
operator|&
name|packet
argument_list|)
operator|<
literal|0
condition|)
name|D
argument_list|(
literal|"failed to read packet from %s"
argument_list|,
name|targ
operator|->
name|g
operator|->
name|packet_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|targ
operator|->
name|frame
operator|=
name|malloc
argument_list|(
name|header
operator|->
name|caplen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|D
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|packet
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|targ
operator|->
name|frame
argument_list|,
name|header
operator|->
name|caplen
argument_list|)
expr_stmt|;
name|targ
operator|->
name|g
operator|->
name|pkt_size
operator|=
name|header
operator|->
name|caplen
expr_stmt|;
name|pcap_close
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* create a nice NUL-terminated string */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paylen
condition|;
name|i
operator|+=
name|l0
control|)
block|{
if|if
condition|(
name|l0
operator|>
name|paylen
operator|-
name|i
condition|)
name|l0
operator|=
name|paylen
operator|-
name|i
expr_stmt|;
comment|// last round
name|bcopy
argument_list|(
name|payload
argument_list|,
name|pkt
operator|->
name|body
operator|+
name|i
argument_list|,
name|l0
argument_list|)
expr_stmt|;
block|}
name|pkt
operator|->
name|body
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ip
operator|=
operator|&
name|pkt
operator|->
name|ip
expr_stmt|;
comment|/* prepare the headers */
name|ip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|=
literal|5
expr_stmt|;
name|ip
operator|->
name|ip_id
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
name|IPTOS_LOWDELAY
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|ntohs
argument_list|(
name|targ
operator|->
name|g
operator|->
name|pkt_size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_id
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|IP_DF
argument_list|)
expr_stmt|;
comment|/* Don't fragment */
name|ip
operator|->
name|ip_ttl
operator|=
name|IPDEFTTL
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|targ
operator|->
name|g
operator|->
name|dst_ip
operator|.
name|start
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|targ
operator|->
name|g
operator|->
name|src_ip
operator|.
name|start
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
name|wrapsum
argument_list|(
name|checksum
argument_list|(
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|udp
operator|=
operator|&
name|pkt
operator|->
name|udp
expr_stmt|;
name|udp
operator|->
name|uh_sport
operator|=
name|htons
argument_list|(
name|targ
operator|->
name|g
operator|->
name|src_ip
operator|.
name|port0
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_dport
operator|=
name|htons
argument_list|(
name|targ
operator|->
name|g
operator|->
name|dst_ip
operator|.
name|port0
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_ulen
operator|=
name|htons
argument_list|(
name|paylen
argument_list|)
expr_stmt|;
comment|/* Magic: taken from sbin/dhclient/packet.c */
name|udp
operator|->
name|uh_sum
operator|=
name|wrapsum
argument_list|(
name|checksum
argument_list|(
name|udp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|udp
argument_list|)
argument_list|,
name|checksum
argument_list|(
name|pkt
operator|->
name|body
argument_list|,
name|paylen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|udp
argument_list|)
argument_list|,
name|checksum
argument_list|(
operator|&
name|ip
operator|->
name|ip_src
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
argument_list|,
name|IPPROTO_UDP
operator|+
operator|(
name|u_int32_t
operator|)
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_ulen
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|&
name|pkt
operator|->
name|eh
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|targ
operator|->
name|g
operator|->
name|src_mac
operator|.
name|start
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|targ
operator|->
name|g
operator|->
name|dst_mac
operator|.
name|start
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pkt
operator|->
name|vh
argument_list|,
sizeof|sizeof
argument_list|(
name|pkt
operator|->
name|vh
argument_list|)
argument_list|)
expr_stmt|;
comment|// dump_payload((void *)pkt, targ->g->pkt_size, NULL, 0);
block|}
end_function

begin_function
specifier|static
name|void
name|get_vnet_hdr_len
parameter_list|(
name|struct
name|glob_arg
modifier|*
name|g
parameter_list|)
block|{
name|struct
name|nmreq
name|req
decl_stmt|;
name|int
name|err
decl_stmt|;
name|memset
argument_list|(
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|g
operator|->
name|nmd
operator|->
name|req
operator|.
name|nr_name
argument_list|,
name|req
operator|.
name|nr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|.
name|nr_name
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|req
operator|.
name|nr_cmd
operator|=
name|NETMAP_VNET_HDR_GET
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|g
operator|->
name|main_fd
argument_list|,
name|NIOCREGIF
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|D
argument_list|(
literal|"Unable to get virtio-net header length"
argument_list|)
expr_stmt|;
return|return;
block|}
name|g
operator|->
name|virt_header
operator|=
name|req
operator|.
name|nr_arg1
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|virt_header
condition|)
block|{
name|D
argument_list|(
literal|"Port requires virtio-net header, length = %d"
argument_list|,
name|g
operator|->
name|virt_header
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_vnet_hdr_len
parameter_list|(
name|struct
name|glob_arg
modifier|*
name|g
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|l
init|=
name|g
operator|->
name|virt_header
decl_stmt|;
name|struct
name|nmreq
name|req
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|g
operator|->
name|nmd
operator|->
name|req
operator|.
name|nr_name
argument_list|,
name|req
operator|.
name|nr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|.
name|nr_name
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|nr_version
operator|=
name|NETMAP_API
expr_stmt|;
name|req
operator|.
name|nr_cmd
operator|=
name|NETMAP_BDG_VNET_HDR
expr_stmt|;
name|req
operator|.
name|nr_arg1
operator|=
name|l
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|g
operator|->
name|main_fd
argument_list|,
name|NIOCREGIF
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|D
argument_list|(
literal|"Unable to set virtio-net header length %d"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * create and enqueue a batch of packets on a ring.  * On the last one set NS_REPORT to tell the driver to generate  * an interrupt when done.  */
end_comment

begin_function
specifier|static
name|int
name|send_packets
parameter_list|(
name|struct
name|netmap_ring
modifier|*
name|ring
parameter_list|,
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|void
modifier|*
name|frame
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|glob_arg
modifier|*
name|g
parameter_list|,
name|u_int
name|count
parameter_list|,
name|int
name|options
parameter_list|,
name|u_int
name|nfrags
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|,
name|sent
decl_stmt|,
name|cur
init|=
name|ring
operator|->
name|cur
decl_stmt|;
name|u_int
name|fcnt
decl_stmt|;
name|n
operator|=
name|nm_ring_space
argument_list|(
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|count
condition|)
name|count
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|nfrags
condition|)
block|{
name|D
argument_list|(
literal|"truncating packet, no room for frags %d %d"
argument_list|,
name|count
argument_list|,
name|nfrags
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (options& (OPT_COPY | OPT_PREFETCH) ) { 		for (sent = 0; sent< count; sent++) { 			struct netmap_slot *slot =&ring->slot[cur]; 			char *p = NETMAP_BUF(ring, slot->buf_idx);  			__builtin_prefetch(p); 			cur = nm_ring_next(ring, cur); 		} 		cur = ring->cur; 	}
endif|#
directive|endif
for|for
control|(
name|fcnt
operator|=
name|nfrags
operator|,
name|sent
operator|=
literal|0
init|;
name|sent
operator|<
name|count
condition|;
name|sent
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|cur
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|NETMAP_BUF
argument_list|(
name|ring
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
decl_stmt|;
name|int
name|buf_changed
init|=
name|slot
operator|->
name|flags
operator|&
name|NS_BUF_CHANGED
decl_stmt|;
name|slot
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|OPT_RUBBISH
condition|)
block|{
comment|/* do nothing */
block|}
elseif|else
if|if
condition|(
name|options
operator|&
name|OPT_INDIRECT
condition|)
block|{
name|slot
operator|->
name|flags
operator||=
name|NS_INDIRECT
expr_stmt|;
name|slot
operator|->
name|ptr
operator|=
call|(
name|uint64_t
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|frame
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|options
operator|&
name|OPT_COPY
operator|)
operator|||
name|buf_changed
condition|)
block|{
name|nm_pkt_copy
argument_list|(
name|frame
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcnt
operator|==
name|nfrags
condition|)
name|update_addresses
argument_list|(
name|pkt
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|options
operator|&
name|OPT_MEMCPY
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|frame
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcnt
operator|==
name|nfrags
condition|)
name|update_addresses
argument_list|(
name|pkt
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|options
operator|&
name|OPT_PREFETCH
condition|)
block|{
name|__builtin_prefetch
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|&
name|OPT_DUMP
condition|)
name|dump_payload
argument_list|(
name|p
argument_list|,
name|size
argument_list|,
name|ring
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|slot
operator|->
name|len
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|--
name|fcnt
operator|>
literal|0
condition|)
name|slot
operator|->
name|flags
operator||=
name|NS_MOREFRAG
expr_stmt|;
else|else
name|fcnt
operator|=
name|nfrags
expr_stmt|;
if|if
condition|(
name|sent
operator|==
name|count
operator|-
literal|1
condition|)
block|{
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_MOREFRAG
expr_stmt|;
name|slot
operator|->
name|flags
operator||=
name|NS_REPORT
expr_stmt|;
block|}
name|cur
operator|=
name|nm_ring_next
argument_list|(
name|ring
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
name|ring
operator|->
name|head
operator|=
name|ring
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
return|return
operator|(
name|sent
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Index of the highest bit set  */
end_comment

begin_function
name|uint32_t
name|msb64
parameter_list|(
name|uint64_t
name|x
parameter_list|)
block|{
name|uint64_t
name|m
init|=
literal|1ULL
operator|<<
literal|63
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|63
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|m
operator|>>=
literal|1
control|)
if|if
condition|(
name|m
operator|&
name|x
condition|)
return|return
name|i
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Send a packet, and wait for a response.  * The payload (after UDP header, ofs 42) has a 4-byte sequence  * followed by a struct timeval (or bintime?)  */
end_comment

begin_define
define|#
directive|define
name|PAY_OFS
value|42
end_define

begin_comment
comment|/* where in the pkt... */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|pinger_body
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|targ
modifier|*
name|targ
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|pollfd
name|pfd
init|=
block|{
operator|.
name|fd
operator|=
name|targ
operator|->
name|fd
block|,
operator|.
name|events
operator|=
name|POLLIN
block|}
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|targ
operator|->
name|nmd
operator|->
name|nifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rx
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|frame
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|,
name|now
decl_stmt|,
name|last_print
decl_stmt|;
name|uint64_t
name|sent
init|=
literal|0
decl_stmt|,
name|n
init|=
name|targ
operator|->
name|g
operator|->
name|npackets
decl_stmt|;
name|uint64_t
name|count
init|=
literal|0
decl_stmt|,
name|t_cur
decl_stmt|,
name|t_min
init|=
operator|~
literal|0
decl_stmt|,
name|av
init|=
literal|0
decl_stmt|;
name|uint64_t
name|buckets
index|[
literal|64
index|]
decl_stmt|;
comment|/* bins for delays, ns */
name|frame
operator|=
operator|&
name|targ
operator|->
name|pkt
expr_stmt|;
name|frame
operator|+=
sizeof|sizeof
argument_list|(
name|targ
operator|->
name|pkt
operator|.
name|vh
argument_list|)
operator|-
name|targ
operator|->
name|g
operator|->
name|virt_header
expr_stmt|;
name|size
operator|=
name|targ
operator|->
name|g
operator|->
name|pkt_size
operator|+
name|targ
operator|->
name|g
operator|->
name|virt_header
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|nthreads
operator|>
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"can only ping with 1 thread"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|&
name|buckets
argument_list|,
sizeof|sizeof
argument_list|(
name|buckets
argument_list|)
argument_list|)
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|last_print
argument_list|)
expr_stmt|;
name|now
operator|=
name|last_print
expr_stmt|;
while|while
condition|(
operator|!
name|targ
operator|->
name|cancel
operator|&&
operator|(
name|n
operator|==
literal|0
operator|||
name|sent
operator|<
name|n
operator|)
condition|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|NETMAP_TXRING
argument_list|(
name|nifp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|/* XXX why the loop for 1 pkt ? */
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|slot
operator|->
name|len
operator|=
name|size
expr_stmt|;
name|p
operator|=
name|NETMAP_BUF
argument_list|(
name|ring
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_ring_empty
argument_list|(
name|ring
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"-- ouch, cannot send"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|tstamp
modifier|*
name|tp
decl_stmt|;
name|nm_pkt_copy
argument_list|(
name|frame
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sent
argument_list|,
name|p
operator|+
literal|42
argument_list|,
sizeof|sizeof
argument_list|(
name|sent
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
expr|struct
name|tstamp
operator|*
operator|)
operator|(
name|p
operator|+
literal|46
operator|)
expr_stmt|;
name|tp
operator|->
name|sec
operator|=
operator|(
name|uint32_t
operator|)
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|tp
operator|->
name|nsec
operator|=
operator|(
name|uint32_t
operator|)
name|ts
operator|.
name|tv_nsec
expr_stmt|;
name|sent
operator|++
expr_stmt|;
name|ring
operator|->
name|head
operator|=
name|ring
operator|->
name|cur
operator|=
name|nm_ring_next
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* should use a parameter to decide how often to send */
if|if
condition|(
name|poll
argument_list|(
operator|&
name|pfd
argument_list|,
literal|1
argument_list|,
literal|3000
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"poll error/timeout on queue %d: %s"
argument_list|,
name|targ
operator|->
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* see what we got back */
for|for
control|(
name|i
operator|=
name|targ
operator|->
name|nmd
operator|->
name|first_tx_ring
init|;
name|i
operator|<=
name|targ
operator|->
name|nmd
operator|->
name|last_tx_ring
condition|;
name|i
operator|++
control|)
block|{
name|ring
operator|=
name|NETMAP_RXRING
argument_list|(
name|nifp
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|nm_ring_empty
argument_list|(
name|ring
argument_list|)
condition|)
block|{
name|uint32_t
name|seq
decl_stmt|;
name|struct
name|tstamp
modifier|*
name|tp
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|p
operator|=
name|NETMAP_BUF
argument_list|(
name|ring
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|+
literal|42
argument_list|,
operator|&
name|seq
argument_list|,
sizeof|sizeof
argument_list|(
name|seq
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
expr|struct
name|tstamp
operator|*
operator|)
operator|(
name|p
operator|+
literal|46
operator|)
expr_stmt|;
name|ts
operator|.
name|tv_sec
operator|=
operator|(
name|time_t
operator|)
name|tp
operator|->
name|sec
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
operator|(
name|long
operator|)
name|tp
operator|->
name|nsec
expr_stmt|;
name|ts
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
operator|-
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
name|now
operator|.
name|tv_nsec
operator|-
name|ts
operator|.
name|tv_nsec
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
name|ts
operator|.
name|tv_nsec
operator|+=
literal|1000000000
expr_stmt|;
name|ts
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
if|if
condition|(
literal|0
condition|)
name|D
argument_list|(
literal|"seq %d/%lu delta %d.%09d"
argument_list|,
name|seq
argument_list|,
name|sent
argument_list|,
operator|(
name|int
operator|)
name|ts
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|ts
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
name|t_cur
operator|=
name|ts
operator|.
name|tv_sec
operator|*
literal|1000000000UL
operator|+
name|ts
operator|.
name|tv_nsec
expr_stmt|;
if|if
condition|(
name|t_cur
operator|<
name|t_min
condition|)
name|t_min
operator|=
name|t_cur
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|av
operator|+=
name|t_cur
expr_stmt|;
name|pos
operator|=
name|msb64
argument_list|(
name|t_cur
argument_list|)
expr_stmt|;
name|buckets
index|[
name|pos
index|]
operator|++
expr_stmt|;
comment|/* now store it in a bucket */
name|ring
operator|->
name|head
operator|=
name|ring
operator|->
name|cur
operator|=
name|nm_ring_next
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|rx
operator|++
expr_stmt|;
block|}
block|}
comment|//D("tx %d rx %d", sent, rx);
comment|//usleep(100000);
name|ts
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
operator|-
name|last_print
operator|.
name|tv_sec
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
name|now
operator|.
name|tv_nsec
operator|-
name|last_print
operator|.
name|tv_nsec
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
name|ts
operator|.
name|tv_nsec
operator|+=
literal|1000000000
expr_stmt|;
name|ts
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ts
operator|.
name|tv_sec
operator|>=
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"count %d RTT: min %d av %d ns"
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|,
operator|(
name|int
operator|)
name|t_min
argument_list|,
call|(
name|int
call|)
argument_list|(
name|av
operator|/
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|k
decl_stmt|,
name|j
decl_stmt|,
name|kmin
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
for|for
control|(
name|kmin
operator|=
literal|0
init|;
name|kmin
operator|<
literal|64
condition|;
name|kmin
operator|++
control|)
if|if
condition|(
name|buckets
index|[
name|kmin
index|]
condition|)
break|break;
for|for
control|(
name|k
operator|=
literal|63
init|;
name|k
operator|>=
name|kmin
condition|;
name|k
operator|--
control|)
if|if
condition|(
name|buckets
index|[
name|k
index|]
condition|)
break|break;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|j
operator|=
name|kmin
init|;
name|j
operator|<=
name|k
condition|;
name|j
operator|++
control|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %5d"
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|buckets
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"k: %d .. %d\n\t%s"
argument_list|,
literal|1
operator|<<
name|kmin
argument_list|,
literal|1
operator|<<
name|k
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|buckets
argument_list|,
sizeof|sizeof
argument_list|(
name|buckets
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|av
operator|=
literal|0
expr_stmt|;
name|t_min
operator|=
operator|~
literal|0
expr_stmt|;
name|last_print
operator|=
name|now
expr_stmt|;
block|}
block|}
comment|/* reset the ``used`` flag. */
name|targ
operator|->
name|used
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * reply to ping requests  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ponger_body
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|targ
modifier|*
name|targ
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|pollfd
name|pfd
init|=
block|{
operator|.
name|fd
operator|=
name|targ
operator|->
name|fd
block|,
operator|.
name|events
operator|=
name|POLLIN
block|}
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|targ
operator|->
name|nmd
operator|->
name|nifp
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|txring
decl_stmt|,
modifier|*
name|rxring
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rx
init|=
literal|0
decl_stmt|;
name|uint64_t
name|sent
init|=
literal|0
decl_stmt|,
name|n
init|=
name|targ
operator|->
name|g
operator|->
name|npackets
decl_stmt|;
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|nthreads
operator|>
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"can only reply ping with 1 thread"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|D
argument_list|(
literal|"understood ponger %lu but don't know how to do it"
argument_list|,
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|targ
operator|->
name|cancel
operator|&&
operator|(
name|n
operator|==
literal|0
operator|||
name|sent
operator|<
name|n
operator|)
condition|)
block|{
name|uint32_t
name|txcur
decl_stmt|,
name|txavail
decl_stmt|;
comment|//#define BUSYWAIT
ifdef|#
directive|ifdef
name|BUSYWAIT
name|ioctl
argument_list|(
name|pfd
operator|.
name|fd
argument_list|,
name|NIOCRXSYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|poll
argument_list|(
operator|&
name|pfd
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"poll error/timeout on queue %d: %s"
argument_list|,
name|targ
operator|->
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|txring
operator|=
name|NETMAP_TXRING
argument_list|(
name|nifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|txcur
operator|=
name|txring
operator|->
name|cur
expr_stmt|;
name|txavail
operator|=
name|nm_ring_space
argument_list|(
name|txring
argument_list|)
expr_stmt|;
comment|/* see what we got back */
for|for
control|(
name|i
operator|=
name|targ
operator|->
name|nmd
operator|->
name|first_rx_ring
init|;
name|i
operator|<=
name|targ
operator|->
name|nmd
operator|->
name|last_rx_ring
condition|;
name|i
operator|++
control|)
block|{
name|rxring
operator|=
name|NETMAP_RXRING
argument_list|(
name|nifp
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|nm_ring_empty
argument_list|(
name|rxring
argument_list|)
condition|)
block|{
name|uint16_t
modifier|*
name|spkt
decl_stmt|,
modifier|*
name|dpkt
decl_stmt|;
name|uint32_t
name|cur
init|=
name|rxring
operator|->
name|cur
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|rxring
operator|->
name|slot
index|[
name|cur
index|]
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|src
operator|=
name|NETMAP_BUF
argument_list|(
name|rxring
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
expr_stmt|;
comment|//D("got pkt %p of size %d", src, slot->len);
name|rxring
operator|->
name|head
operator|=
name|rxring
operator|->
name|cur
operator|=
name|nm_ring_next
argument_list|(
name|rxring
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|rx
operator|++
expr_stmt|;
if|if
condition|(
name|txavail
operator|==
literal|0
condition|)
continue|continue;
name|dst
operator|=
name|NETMAP_BUF
argument_list|(
name|txring
argument_list|,
name|txring
operator|->
name|slot
index|[
name|txcur
index|]
operator|.
name|buf_idx
argument_list|)
expr_stmt|;
comment|/* copy... */
name|dpkt
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|dst
expr_stmt|;
name|spkt
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|src
expr_stmt|;
name|nm_pkt_copy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
name|dpkt
index|[
literal|0
index|]
operator|=
name|spkt
index|[
literal|3
index|]
expr_stmt|;
name|dpkt
index|[
literal|1
index|]
operator|=
name|spkt
index|[
literal|4
index|]
expr_stmt|;
name|dpkt
index|[
literal|2
index|]
operator|=
name|spkt
index|[
literal|5
index|]
expr_stmt|;
name|dpkt
index|[
literal|3
index|]
operator|=
name|spkt
index|[
literal|0
index|]
expr_stmt|;
name|dpkt
index|[
literal|4
index|]
operator|=
name|spkt
index|[
literal|1
index|]
expr_stmt|;
name|dpkt
index|[
literal|5
index|]
operator|=
name|spkt
index|[
literal|2
index|]
expr_stmt|;
name|txring
operator|->
name|slot
index|[
name|txcur
index|]
operator|.
name|len
operator|=
name|slot
operator|->
name|len
expr_stmt|;
comment|/* XXX swap src dst mac */
name|txcur
operator|=
name|nm_ring_next
argument_list|(
name|txring
argument_list|,
name|txcur
argument_list|)
expr_stmt|;
name|txavail
operator|--
expr_stmt|;
name|sent
operator|++
expr_stmt|;
block|}
block|}
name|txring
operator|->
name|head
operator|=
name|txring
operator|->
name|cur
operator|=
name|txcur
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|pkts
operator|=
name|sent
expr_stmt|;
ifdef|#
directive|ifdef
name|BUSYWAIT
name|ioctl
argument_list|(
name|pfd
operator|.
name|fd
argument_list|,
name|NIOCTXSYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//D("tx %d rx %d", sent, rx);
block|}
comment|/* reset the ``used`` flag. */
name|targ
operator|->
name|used
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * wait until ts, either busy or sleeping if more than 1ms.  * Return wakeup time.  */
end_comment

begin_function
specifier|static
name|struct
name|timespec
name|wait_time
parameter_list|(
name|struct
name|timespec
name|ts
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|timespec
name|w
decl_stmt|,
name|cur
decl_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|cur
argument_list|)
expr_stmt|;
name|w
operator|=
name|timespec_sub
argument_list|(
name|ts
argument_list|,
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|tv_sec
operator|<
literal|0
condition|)
return|return
name|cur
return|;
elseif|else
if|if
condition|(
name|w
operator|.
name|tv_sec
operator|>
literal|0
operator|||
name|w
operator|.
name|tv_nsec
operator|>
literal|1000000
condition|)
name|poll
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|sender_body
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|targ
modifier|*
name|targ
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|pollfd
name|pfd
init|=
block|{
operator|.
name|fd
operator|=
name|targ
operator|->
name|fd
block|,
operator|.
name|events
operator|=
name|POLLOUT
block|}
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|txring
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|n
init|=
name|targ
operator|->
name|g
operator|->
name|npackets
operator|/
name|targ
operator|->
name|g
operator|->
name|nthreads
decl_stmt|;
name|uint64_t
name|sent
init|=
literal|0
decl_stmt|;
name|uint64_t
name|event
init|=
literal|0
decl_stmt|;
name|int
name|options
init|=
name|targ
operator|->
name|g
operator|->
name|options
operator||
name|OPT_COPY
decl_stmt|;
name|struct
name|timespec
name|nexttime
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|// XXX silence compiler
name|int
name|rate_limit
init|=
name|targ
operator|->
name|g
operator|->
name|tx_rate
decl_stmt|;
name|struct
name|pkt
modifier|*
name|pkt
init|=
operator|&
name|targ
operator|->
name|pkt
decl_stmt|;
name|void
modifier|*
name|frame
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|targ
operator|->
name|frame
operator|==
name|NULL
condition|)
block|{
name|frame
operator|=
name|pkt
expr_stmt|;
name|frame
operator|+=
sizeof|sizeof
argument_list|(
name|pkt
operator|->
name|vh
argument_list|)
operator|-
name|targ
operator|->
name|g
operator|->
name|virt_header
expr_stmt|;
name|size
operator|=
name|targ
operator|->
name|g
operator|->
name|pkt_size
operator|+
name|targ
operator|->
name|g
operator|->
name|virt_header
expr_stmt|;
block|}
else|else
block|{
name|frame
operator|=
name|targ
operator|->
name|frame
expr_stmt|;
name|size
operator|=
name|targ
operator|->
name|g
operator|->
name|pkt_size
expr_stmt|;
block|}
name|D
argument_list|(
literal|"start, fd %d main_fd %d"
argument_list|,
name|targ
operator|->
name|fd
argument_list|,
name|targ
operator|->
name|g
operator|->
name|main_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|setaffinity
argument_list|(
name|targ
operator|->
name|thread
argument_list|,
name|targ
operator|->
name|affinity
argument_list|)
condition|)
goto|goto
name|quit
goto|;
comment|/* main loop.*/
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|targ
operator|->
name|tic
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate_limit
condition|)
block|{
name|targ
operator|->
name|tic
operator|=
name|timespec_add
argument_list|(
name|targ
operator|->
name|tic
argument_list|,
operator|(
expr|struct
name|timespec
operator|)
block|{
literal|2
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|targ
operator|->
name|tic
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|wait_time
argument_list|(
name|targ
operator|->
name|tic
argument_list|)
expr_stmt|;
name|nexttime
operator|=
name|targ
operator|->
name|tic
expr_stmt|;
block|}
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|dev_type
operator|==
name|DEV_TAP
condition|)
block|{
name|D
argument_list|(
literal|"writing to file desc %d"
argument_list|,
name|targ
operator|->
name|g
operator|->
name|main_fd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|targ
operator|->
name|cancel
operator|&&
operator|(
name|n
operator|==
literal|0
operator|||
name|sent
operator|<
name|n
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|write
argument_list|(
name|targ
operator|->
name|g
operator|->
name|main_fd
argument_list|,
name|frame
argument_list|,
name|size
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sent
operator|++
expr_stmt|;
name|update_addresses
argument_list|(
name|pkt
argument_list|,
name|targ
operator|->
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|targ
operator|->
name|ctr
operator|.
name|pkts
operator|=
name|sent
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|bytes
operator|=
name|sent
operator|*
name|size
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|events
operator|=
name|sent
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|NO_PCAP
block|}
elseif|else
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|dev_type
operator|==
name|DEV_PCAP
condition|)
block|{
name|pcap_t
modifier|*
name|p
init|=
name|targ
operator|->
name|g
operator|->
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|targ
operator|->
name|cancel
operator|&&
operator|(
name|n
operator|==
literal|0
operator|||
name|sent
operator|<
name|n
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pcap_inject
argument_list|(
name|p
argument_list|,
name|frame
argument_list|,
name|size
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sent
operator|++
expr_stmt|;
name|update_addresses
argument_list|(
name|pkt
argument_list|,
name|targ
operator|->
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|targ
operator|->
name|ctr
operator|.
name|pkts
operator|=
name|sent
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|bytes
operator|=
name|sent
operator|*
name|size
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|events
operator|=
name|sent
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NO_PCAP */
block|}
else|else
block|{
name|int
name|tosend
init|=
literal|0
decl_stmt|;
name|int
name|frags
init|=
name|targ
operator|->
name|g
operator|->
name|frags
decl_stmt|;
name|nifp
operator|=
name|targ
operator|->
name|nmd
operator|->
name|nifp
expr_stmt|;
while|while
condition|(
operator|!
name|targ
operator|->
name|cancel
operator|&&
operator|(
name|n
operator|==
literal|0
operator|||
name|sent
operator|<
name|n
operator|)
condition|)
block|{
if|if
condition|(
name|rate_limit
operator|&&
name|tosend
operator|<=
literal|0
condition|)
block|{
name|tosend
operator|=
name|targ
operator|->
name|g
operator|->
name|burst
expr_stmt|;
name|nexttime
operator|=
name|timespec_add
argument_list|(
name|nexttime
argument_list|,
name|targ
operator|->
name|g
operator|->
name|tx_period
argument_list|)
expr_stmt|;
name|wait_time
argument_list|(
name|nexttime
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * wait for available room in the send queue(s) 		 */
ifdef|#
directive|ifdef
name|BUSYWAIT
if|if
condition|(
name|ioctl
argument_list|(
name|pfd
operator|.
name|fd
argument_list|,
name|NIOCTXSYNC
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"ioctl error on queue %d: %s"
argument_list|,
name|targ
operator|->
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
else|#
directive|else
comment|/* !BUSYWAIT */
if|if
condition|(
name|poll
argument_list|(
operator|&
name|pfd
argument_list|,
literal|1
argument_list|,
literal|2000
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|targ
operator|->
name|cancel
condition|)
break|break;
name|D
argument_list|(
literal|"poll error/timeout on queue %d: %s"
argument_list|,
name|targ
operator|->
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|// goto quit;
block|}
if|if
condition|(
name|pfd
operator|.
name|revents
operator|&
name|POLLERR
condition|)
block|{
name|D
argument_list|(
literal|"poll error on %d ring %d-%d"
argument_list|,
name|pfd
operator|.
name|fd
argument_list|,
name|targ
operator|->
name|nmd
operator|->
name|first_tx_ring
argument_list|,
name|targ
operator|->
name|nmd
operator|->
name|last_tx_ring
argument_list|)
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
endif|#
directive|endif
comment|/* !BUSYWAIT */
comment|/* 		 * scan our queues and send on those with room 		 */
if|if
condition|(
name|options
operator|&
name|OPT_COPY
operator|&&
name|sent
operator|>
literal|100000
operator|&&
operator|!
operator|(
name|targ
operator|->
name|g
operator|->
name|options
operator|&
name|OPT_COPY
operator|)
condition|)
block|{
name|D
argument_list|(
literal|"drop copy"
argument_list|)
expr_stmt|;
name|options
operator|&=
operator|~
name|OPT_COPY
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|targ
operator|->
name|nmd
operator|->
name|first_tx_ring
init|;
name|i
operator|<=
name|targ
operator|->
name|nmd
operator|->
name|last_tx_ring
condition|;
name|i
operator|++
control|)
block|{
name|int
name|m
decl_stmt|;
name|uint64_t
name|limit
init|=
name|rate_limit
condition|?
name|tosend
else|:
name|targ
operator|->
name|g
operator|->
name|burst
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|-
name|sent
operator|<
name|limit
condition|)
name|limit
operator|=
name|n
operator|-
name|sent
expr_stmt|;
name|txring
operator|=
name|NETMAP_TXRING
argument_list|(
name|nifp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_ring_empty
argument_list|(
name|txring
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|frags
operator|>
literal|1
condition|)
name|limit
operator|=
operator|(
operator|(
name|limit
operator|+
name|frags
operator|-
literal|1
operator|)
operator|/
name|frags
operator|)
operator|*
name|frags
expr_stmt|;
name|m
operator|=
name|send_packets
argument_list|(
name|txring
argument_list|,
name|pkt
argument_list|,
name|frame
argument_list|,
name|size
argument_list|,
name|targ
operator|->
name|g
argument_list|,
name|limit
argument_list|,
name|options
argument_list|,
name|frags
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"limit %d tail %d frags %d m %d"
argument_list|,
name|limit
argument_list|,
name|txring
operator|->
name|tail
argument_list|,
name|frags
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sent
operator|+=
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|0
condition|)
comment|//XXX-ste: can m be 0?
name|event
operator|++
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|pkts
operator|=
name|sent
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|bytes
operator|=
name|sent
operator|*
name|size
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|events
operator|=
name|event
expr_stmt|;
if|if
condition|(
name|rate_limit
condition|)
block|{
name|tosend
operator|-=
name|m
expr_stmt|;
if|if
condition|(
name|tosend
operator|<=
literal|0
condition|)
break|break;
block|}
block|}
block|}
comment|/* flush any remaining packets */
name|D
argument_list|(
literal|"flush tail %d head %d on thread %p"
argument_list|,
name|txring
operator|->
name|tail
argument_list|,
name|txring
operator|->
name|head
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pthread_self
argument_list|()
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pfd
operator|.
name|fd
argument_list|,
name|NIOCTXSYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* final part: wait all the TX queues to be empty. */
for|for
control|(
name|i
operator|=
name|targ
operator|->
name|nmd
operator|->
name|first_tx_ring
init|;
name|i
operator|<=
name|targ
operator|->
name|nmd
operator|->
name|last_tx_ring
condition|;
name|i
operator|++
control|)
block|{
name|txring
operator|=
name|NETMAP_TXRING
argument_list|(
name|nifp
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|targ
operator|->
name|cancel
operator|&&
name|nm_tx_pending
argument_list|(
name|txring
argument_list|)
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"pending tx tail %d head %d on ring %d"
argument_list|,
name|txring
operator|->
name|tail
argument_list|,
name|txring
operator|->
name|head
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pfd
operator|.
name|fd
argument_list|,
name|NIOCTXSYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* wait 1 tick */
block|}
block|}
block|}
comment|/* end DEV_NETMAP */
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|targ
operator|->
name|toc
argument_list|)
expr_stmt|;
name|targ
operator|->
name|completed
operator|=
literal|1
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|pkts
operator|=
name|sent
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|bytes
operator|=
name|sent
operator|*
name|size
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|events
operator|=
name|event
expr_stmt|;
name|quit
label|:
comment|/* reset the ``used`` flag. */
name|targ
operator|->
name|used
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_PCAP
end_ifndef

begin_function
specifier|static
name|void
name|receive_pcap
parameter_list|(
name|u_char
modifier|*
name|user
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|const
name|u_char
modifier|*
name|bytes
parameter_list|)
block|{
name|struct
name|my_ctrs
modifier|*
name|ctr
init|=
operator|(
expr|struct
name|my_ctrs
operator|*
operator|)
name|user
decl_stmt|;
operator|(
name|void
operator|)
name|bytes
expr_stmt|;
comment|/* UNUSED */
name|ctr
operator|->
name|bytes
operator|+=
name|h
operator|->
name|len
expr_stmt|;
name|ctr
operator|->
name|pkts
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NO_PCAP */
end_comment

begin_function
specifier|static
name|int
name|receive_packets
parameter_list|(
name|struct
name|netmap_ring
modifier|*
name|ring
parameter_list|,
name|u_int
name|limit
parameter_list|,
name|int
name|dump
parameter_list|,
name|uint64_t
modifier|*
name|bytes
parameter_list|)
block|{
name|u_int
name|cur
decl_stmt|,
name|rx
decl_stmt|,
name|n
decl_stmt|;
name|uint64_t
name|b
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bytes
operator|==
name|NULL
condition|)
name|bytes
operator|=
operator|&
name|b
expr_stmt|;
name|cur
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|n
operator|=
name|nm_ring_space
argument_list|(
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|limit
condition|)
name|limit
operator|=
name|n
expr_stmt|;
for|for
control|(
name|rx
operator|=
literal|0
init|;
name|rx
operator|<
name|limit
condition|;
name|rx
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|cur
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|NETMAP_BUF
argument_list|(
name|ring
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
decl_stmt|;
operator|*
name|bytes
operator|+=
name|slot
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|dump
condition|)
name|dump_payload
argument_list|(
name|p
argument_list|,
name|slot
operator|->
name|len
argument_list|,
name|ring
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|cur
operator|=
name|nm_ring_next
argument_list|(
name|ring
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
name|ring
operator|->
name|head
operator|=
name|ring
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
return|return
operator|(
name|rx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|receiver_body
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|targ
modifier|*
name|targ
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|pollfd
name|pfd
init|=
block|{
operator|.
name|fd
operator|=
name|targ
operator|->
name|fd
block|,
operator|.
name|events
operator|=
name|POLLIN
block|}
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|rxring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|my_ctrs
name|cur
decl_stmt|;
name|cur
operator|.
name|pkts
operator|=
name|cur
operator|.
name|bytes
operator|=
name|cur
operator|.
name|events
operator|=
name|cur
operator|.
name|min_space
operator|=
literal|0
expr_stmt|;
name|cur
operator|.
name|t
operator|.
name|tv_usec
operator|=
name|cur
operator|.
name|t
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
comment|//  unused, just silence the compiler
if|if
condition|(
name|setaffinity
argument_list|(
name|targ
operator|->
name|thread
argument_list|,
name|targ
operator|->
name|affinity
argument_list|)
condition|)
goto|goto
name|quit
goto|;
name|D
argument_list|(
literal|"reading from %s fd %d main_fd %d"
argument_list|,
name|targ
operator|->
name|g
operator|->
name|ifname
argument_list|,
name|targ
operator|->
name|fd
argument_list|,
name|targ
operator|->
name|g
operator|->
name|main_fd
argument_list|)
expr_stmt|;
comment|/* unbounded wait for the first packet. */
for|for
control|(
init|;
operator|!
name|targ
operator|->
name|cancel
condition|;
control|)
block|{
name|i
operator|=
name|poll
argument_list|(
operator|&
name|pfd
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
name|pfd
operator|.
name|revents
operator|&
name|POLLERR
operator|)
condition|)
break|break;
name|RD
argument_list|(
literal|1
argument_list|,
literal|"waiting for initial packets, poll returns %d %d"
argument_list|,
name|i
argument_list|,
name|pfd
operator|.
name|revents
argument_list|)
expr_stmt|;
block|}
comment|/* main loop, exit after 1s silence */
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|targ
operator|->
name|tic
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|dev_type
operator|==
name|DEV_TAP
condition|)
block|{
while|while
condition|(
operator|!
name|targ
operator|->
name|cancel
condition|)
block|{
name|char
name|buf
index|[
name|MAX_BODYSIZE
index|]
decl_stmt|;
comment|/* XXX should we poll ? */
name|i
operator|=
name|read
argument_list|(
name|targ
operator|->
name|g
operator|->
name|main_fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|targ
operator|->
name|ctr
operator|.
name|pkts
operator|++
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|bytes
operator|+=
name|i
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|events
operator|++
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|NO_PCAP
block|}
elseif|else
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|dev_type
operator|==
name|DEV_PCAP
condition|)
block|{
while|while
condition|(
operator|!
name|targ
operator|->
name|cancel
condition|)
block|{
comment|/* XXX should we poll ? */
name|pcap_dispatch
argument_list|(
name|targ
operator|->
name|g
operator|->
name|p
argument_list|,
name|targ
operator|->
name|g
operator|->
name|burst
argument_list|,
name|receive_pcap
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|targ
operator|->
name|ctr
argument_list|)
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|events
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !NO_PCAP */
block|}
else|else
block|{
name|int
name|dump
init|=
name|targ
operator|->
name|g
operator|->
name|options
operator|&
name|OPT_DUMP
decl_stmt|;
name|nifp
operator|=
name|targ
operator|->
name|nmd
operator|->
name|nifp
expr_stmt|;
while|while
condition|(
operator|!
name|targ
operator|->
name|cancel
condition|)
block|{
comment|/* Once we started to receive packets, wait at most 1 seconds 		   before quitting. */
ifdef|#
directive|ifdef
name|BUSYWAIT
if|if
condition|(
name|ioctl
argument_list|(
name|pfd
operator|.
name|fd
argument_list|,
name|NIOCRXSYNC
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"ioctl error on queue %d: %s"
argument_list|,
name|targ
operator|->
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
else|#
directive|else
comment|/* !BUSYWAIT */
if|if
condition|(
name|poll
argument_list|(
operator|&
name|pfd
argument_list|,
literal|1
argument_list|,
literal|1
operator|*
literal|1000
argument_list|)
operator|<=
literal|0
operator|&&
operator|!
name|targ
operator|->
name|g
operator|->
name|forever
condition|)
block|{
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|targ
operator|->
name|toc
argument_list|)
expr_stmt|;
name|targ
operator|->
name|toc
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
comment|/* Subtract timeout time. */
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|pfd
operator|.
name|revents
operator|&
name|POLLERR
condition|)
block|{
name|D
argument_list|(
literal|"poll err"
argument_list|)
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
endif|#
directive|endif
comment|/* !BUSYWAIT */
name|uint64_t
name|cur_space
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|targ
operator|->
name|nmd
operator|->
name|first_rx_ring
init|;
name|i
operator|<=
name|targ
operator|->
name|nmd
operator|->
name|last_rx_ring
condition|;
name|i
operator|++
control|)
block|{
name|int
name|m
decl_stmt|;
name|rxring
operator|=
name|NETMAP_RXRING
argument_list|(
name|nifp
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* compute free space in the ring */
name|m
operator|=
name|rxring
operator|->
name|head
operator|+
name|rxring
operator|->
name|num_slots
operator|-
name|rxring
operator|->
name|tail
expr_stmt|;
if|if
condition|(
name|m
operator|>=
operator|(
name|int
operator|)
name|rxring
operator|->
name|num_slots
condition|)
name|m
operator|-=
name|rxring
operator|->
name|num_slots
expr_stmt|;
name|cur_space
operator|+=
name|m
expr_stmt|;
if|if
condition|(
name|nm_ring_empty
argument_list|(
name|rxring
argument_list|)
condition|)
continue|continue;
name|m
operator|=
name|receive_packets
argument_list|(
name|rxring
argument_list|,
name|targ
operator|->
name|g
operator|->
name|burst
argument_list|,
name|dump
argument_list|,
operator|&
name|cur
operator|.
name|bytes
argument_list|)
expr_stmt|;
name|cur
operator|.
name|pkts
operator|+=
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|0
condition|)
comment|//XXX-ste: can m be 0?
name|cur
operator|.
name|events
operator|++
expr_stmt|;
block|}
name|cur
operator|.
name|min_space
operator|=
name|targ
operator|->
name|ctr
operator|.
name|min_space
expr_stmt|;
if|if
condition|(
name|cur_space
operator|<
name|cur
operator|.
name|min_space
condition|)
name|cur
operator|.
name|min_space
operator|=
name|cur_space
expr_stmt|;
name|targ
operator|->
name|ctr
operator|=
name|cur
expr_stmt|;
block|}
block|}
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|targ
operator|->
name|toc
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BUSYWAIT
argument_list|)
name|out
label|:
endif|#
directive|endif
name|targ
operator|->
name|completed
operator|=
literal|1
expr_stmt|;
name|targ
operator|->
name|ctr
operator|=
name|cur
expr_stmt|;
name|quit
label|:
comment|/* reset the ``used`` flag. */
name|targ
operator|->
name|used
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|txseq_body
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|targ
modifier|*
name|targ
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|pollfd
name|pfd
init|=
block|{
operator|.
name|fd
operator|=
name|targ
operator|->
name|fd
block|,
operator|.
name|events
operator|=
name|POLLOUT
block|}
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
decl_stmt|;
name|int64_t
name|sent
init|=
literal|0
decl_stmt|;
name|uint64_t
name|event
init|=
literal|0
decl_stmt|;
name|int
name|options
init|=
name|targ
operator|->
name|g
operator|->
name|options
operator||
name|OPT_COPY
decl_stmt|;
name|struct
name|timespec
name|nexttime
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|rate_limit
init|=
name|targ
operator|->
name|g
operator|->
name|tx_rate
decl_stmt|;
name|struct
name|pkt
modifier|*
name|pkt
init|=
operator|&
name|targ
operator|->
name|pkt
decl_stmt|;
name|int
name|frags
init|=
name|targ
operator|->
name|g
operator|->
name|frags
decl_stmt|;
name|uint32_t
name|sequence
init|=
literal|0
decl_stmt|;
name|int
name|budget
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|frame
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|nthreads
operator|>
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"can only txseq ping with 1 thread"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|targ
operator|->
name|g
operator|->
name|npackets
operator|>
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"Ignoring -n argument"
argument_list|)
expr_stmt|;
block|}
name|frame
operator|=
name|pkt
expr_stmt|;
name|frame
operator|+=
sizeof|sizeof
argument_list|(
name|pkt
operator|->
name|vh
argument_list|)
operator|-
name|targ
operator|->
name|g
operator|->
name|virt_header
expr_stmt|;
name|size
operator|=
name|targ
operator|->
name|g
operator|->
name|pkt_size
operator|+
name|targ
operator|->
name|g
operator|->
name|virt_header
expr_stmt|;
name|D
argument_list|(
literal|"start, fd %d main_fd %d"
argument_list|,
name|targ
operator|->
name|fd
argument_list|,
name|targ
operator|->
name|g
operator|->
name|main_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|setaffinity
argument_list|(
name|targ
operator|->
name|thread
argument_list|,
name|targ
operator|->
name|affinity
argument_list|)
condition|)
goto|goto
name|quit
goto|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|targ
operator|->
name|tic
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate_limit
condition|)
block|{
name|targ
operator|->
name|tic
operator|=
name|timespec_add
argument_list|(
name|targ
operator|->
name|tic
argument_list|,
operator|(
expr|struct
name|timespec
operator|)
block|{
literal|2
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
name|targ
operator|->
name|tic
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|wait_time
argument_list|(
name|targ
operator|->
name|tic
argument_list|)
expr_stmt|;
name|nexttime
operator|=
name|targ
operator|->
name|tic
expr_stmt|;
block|}
comment|/* Only use the first queue. */
name|ring
operator|=
name|NETMAP_TXRING
argument_list|(
name|targ
operator|->
name|nmd
operator|->
name|nifp
argument_list|,
name|targ
operator|->
name|nmd
operator|->
name|first_tx_ring
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|targ
operator|->
name|cancel
condition|)
block|{
name|int64_t
name|limit
decl_stmt|;
name|unsigned
name|int
name|space
decl_stmt|;
name|unsigned
name|int
name|head
decl_stmt|;
name|int
name|fcnt
decl_stmt|;
if|if
condition|(
operator|!
name|rate_limit
condition|)
block|{
name|budget
operator|=
name|targ
operator|->
name|g
operator|->
name|burst
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|budget
operator|<=
literal|0
condition|)
block|{
name|budget
operator|=
name|targ
operator|->
name|g
operator|->
name|burst
expr_stmt|;
name|nexttime
operator|=
name|timespec_add
argument_list|(
name|nexttime
argument_list|,
name|targ
operator|->
name|g
operator|->
name|tx_period
argument_list|)
expr_stmt|;
name|wait_time
argument_list|(
name|nexttime
argument_list|)
expr_stmt|;
block|}
comment|/* wait for available room in the send queue */
if|if
condition|(
name|poll
argument_list|(
operator|&
name|pfd
argument_list|,
literal|1
argument_list|,
literal|2000
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|targ
operator|->
name|cancel
condition|)
break|break;
name|D
argument_list|(
literal|"poll error/timeout on queue %d: %s"
argument_list|,
name|targ
operator|->
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pfd
operator|.
name|revents
operator|&
name|POLLERR
condition|)
block|{
name|D
argument_list|(
literal|"poll error on %d ring %d-%d"
argument_list|,
name|pfd
operator|.
name|fd
argument_list|,
name|targ
operator|->
name|nmd
operator|->
name|first_tx_ring
argument_list|,
name|targ
operator|->
name|nmd
operator|->
name|last_tx_ring
argument_list|)
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
comment|/* If no room poll() again. */
name|space
operator|=
name|nm_ring_space
argument_list|(
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|space
condition|)
block|{
continue|continue;
block|}
name|limit
operator|=
name|budget
expr_stmt|;
if|if
condition|(
name|space
operator|<
name|limit
condition|)
block|{
name|limit
operator|=
name|space
expr_stmt|;
block|}
comment|/* Cut off ``limit`` to make sure is multiple of ``frags``. */
if|if
condition|(
name|frags
operator|>
literal|1
condition|)
block|{
name|limit
operator|=
operator|(
name|limit
operator|/
name|frags
operator|)
operator|*
name|frags
expr_stmt|;
block|}
name|limit
operator|=
name|sent
operator|+
name|limit
expr_stmt|;
comment|/* Convert to absolute. */
for|for
control|(
name|fcnt
operator|=
name|frags
operator|,
name|head
operator|=
name|ring
operator|->
name|head
init|;
name|sent
operator|<
name|limit
condition|;
name|sent
operator|++
operator|,
name|sequence
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|head
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|NETMAP_BUF
argument_list|(
name|ring
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
decl_stmt|;
name|slot
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|pkt
operator|->
name|body
index|[
literal|0
index|]
operator|=
name|sequence
operator|>>
literal|24
expr_stmt|;
name|pkt
operator|->
name|body
index|[
literal|1
index|]
operator|=
operator|(
name|sequence
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|pkt
operator|->
name|body
index|[
literal|2
index|]
operator|=
operator|(
name|sequence
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|pkt
operator|->
name|body
index|[
literal|3
index|]
operator|=
name|sequence
operator|&
literal|0xff
expr_stmt|;
name|nm_pkt_copy
argument_list|(
name|frame
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcnt
operator|==
name|frags
condition|)
block|{
name|update_addresses
argument_list|(
name|pkt
argument_list|,
name|targ
operator|->
name|g
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|&
name|OPT_DUMP
condition|)
block|{
name|dump_payload
argument_list|(
name|p
argument_list|,
name|size
argument_list|,
name|ring
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|len
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|--
name|fcnt
operator|>
literal|0
condition|)
block|{
name|slot
operator|->
name|flags
operator||=
name|NS_MOREFRAG
expr_stmt|;
block|}
else|else
block|{
name|fcnt
operator|=
name|frags
expr_stmt|;
block|}
if|if
condition|(
name|sent
operator|==
name|limit
operator|-
literal|1
condition|)
block|{
comment|/* Make sure we don't push an incomplete 				 * packet. */
name|assert
argument_list|(
operator|!
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_MOREFRAG
operator|)
argument_list|)
expr_stmt|;
name|slot
operator|->
name|flags
operator||=
name|NS_REPORT
expr_stmt|;
block|}
name|head
operator|=
name|nm_ring_next
argument_list|(
name|ring
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate_limit
condition|)
block|{
name|budget
operator|--
expr_stmt|;
block|}
block|}
name|ring
operator|->
name|cur
operator|=
name|ring
operator|->
name|head
operator|=
name|head
expr_stmt|;
name|event
operator|++
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|pkts
operator|=
name|sent
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|bytes
operator|=
name|sent
operator|*
name|size
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|events
operator|=
name|event
expr_stmt|;
block|}
comment|/* flush any remaining packets */
name|D
argument_list|(
literal|"flush tail %d head %d on thread %p"
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|ring
operator|->
name|head
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pthread_self
argument_list|()
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pfd
operator|.
name|fd
argument_list|,
name|NIOCTXSYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* final part: wait the TX queues to become empty. */
while|while
condition|(
operator|!
name|targ
operator|->
name|cancel
operator|&&
name|nm_tx_pending
argument_list|(
name|ring
argument_list|)
condition|)
block|{
name|RD
argument_list|(
literal|5
argument_list|,
literal|"pending tx tail %d head %d on ring %d"
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|ring
operator|->
name|head
argument_list|,
name|targ
operator|->
name|nmd
operator|->
name|first_tx_ring
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pfd
operator|.
name|fd
argument_list|,
name|NIOCTXSYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* wait 1 tick */
block|}
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|targ
operator|->
name|toc
argument_list|)
expr_stmt|;
name|targ
operator|->
name|completed
operator|=
literal|1
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|pkts
operator|=
name|sent
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|bytes
operator|=
name|sent
operator|*
name|size
expr_stmt|;
name|targ
operator|->
name|ctr
operator|.
name|events
operator|=
name|event
expr_stmt|;
name|quit
label|:
comment|/* reset the ``used`` flag. */
name|targ
operator|->
name|used
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|multi_slot_to_string
parameter_list|(
name|struct
name|netmap_ring
modifier|*
name|ring
parameter_list|,
name|unsigned
name|int
name|head
parameter_list|,
name|unsigned
name|int
name|nfrags
parameter_list|,
name|char
modifier|*
name|strbuf
parameter_list|,
name|size_t
name|strbuflen
parameter_list|)
block|{
name|unsigned
name|int
name|f
decl_stmt|;
name|char
modifier|*
name|ret
init|=
name|strbuf
decl_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|nfrags
condition|;
name|f
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|head
index|]
decl_stmt|;
name|int
name|m
init|=
name|snprintf
argument_list|(
name|strbuf
argument_list|,
name|strbuflen
argument_list|,
literal|"|%u,%x|"
argument_list|,
name|slot
operator|->
name|len
argument_list|,
name|slot
operator|->
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|>=
operator|(
name|int
operator|)
name|strbuflen
condition|)
block|{
break|break;
block|}
name|strbuf
operator|+=
name|m
expr_stmt|;
name|strbuflen
operator|-=
name|m
expr_stmt|;
name|head
operator|=
name|nm_ring_next
argument_list|(
name|ring
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|rxseq_body
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|targ
modifier|*
name|targ
init|=
operator|(
expr|struct
name|targ
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|pollfd
name|pfd
init|=
block|{
operator|.
name|fd
operator|=
name|targ
operator|->
name|fd
block|,
operator|.
name|events
operator|=
name|POLLIN
block|}
decl_stmt|;
name|int
name|dump
init|=
name|targ
operator|->
name|g
operator|->
name|options
operator|&
name|OPT_DUMP
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
decl_stmt|;
name|unsigned
name|int
name|frags_exp
init|=
literal|1
decl_stmt|;
name|uint32_t
name|seq_exp
init|=
literal|0
decl_stmt|;
name|struct
name|my_ctrs
name|cur
decl_stmt|;
name|unsigned
name|int
name|frags
init|=
literal|0
decl_stmt|;
name|int
name|first_packet
init|=
literal|1
decl_stmt|;
name|int
name|first_slot
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cur
operator|.
name|pkts
operator|=
name|cur
operator|.
name|bytes
operator|=
name|cur
operator|.
name|events
operator|=
name|cur
operator|.
name|min_space
operator|=
literal|0
expr_stmt|;
name|cur
operator|.
name|t
operator|.
name|tv_usec
operator|=
name|cur
operator|.
name|t
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
comment|//  unused, just silence the compiler
if|if
condition|(
name|setaffinity
argument_list|(
name|targ
operator|->
name|thread
argument_list|,
name|targ
operator|->
name|affinity
argument_list|)
condition|)
goto|goto
name|quit
goto|;
name|D
argument_list|(
literal|"reading from %s fd %d main_fd %d"
argument_list|,
name|targ
operator|->
name|g
operator|->
name|ifname
argument_list|,
name|targ
operator|->
name|fd
argument_list|,
name|targ
operator|->
name|g
operator|->
name|main_fd
argument_list|)
expr_stmt|;
comment|/* unbounded wait for the first packet. */
for|for
control|(
init|;
operator|!
name|targ
operator|->
name|cancel
condition|;
control|)
block|{
name|i
operator|=
name|poll
argument_list|(
operator|&
name|pfd
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
name|pfd
operator|.
name|revents
operator|&
name|POLLERR
operator|)
condition|)
break|break;
name|RD
argument_list|(
literal|1
argument_list|,
literal|"waiting for initial packets, poll returns %d %d"
argument_list|,
name|i
argument_list|,
name|pfd
operator|.
name|revents
argument_list|)
expr_stmt|;
block|}
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|targ
operator|->
name|tic
argument_list|)
expr_stmt|;
name|ring
operator|=
name|NETMAP_RXRING
argument_list|(
name|targ
operator|->
name|nmd
operator|->
name|nifp
argument_list|,
name|targ
operator|->
name|nmd
operator|->
name|first_rx_ring
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|targ
operator|->
name|cancel
condition|)
block|{
name|unsigned
name|int
name|head
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|int
name|limit
decl_stmt|;
comment|/* Once we started to receive packets, wait at most 1 seconds 		   before quitting. */
if|if
condition|(
name|poll
argument_list|(
operator|&
name|pfd
argument_list|,
literal|1
argument_list|,
literal|1
operator|*
literal|1000
argument_list|)
operator|<=
literal|0
operator|&&
operator|!
name|targ
operator|->
name|g
operator|->
name|forever
condition|)
block|{
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|targ
operator|->
name|toc
argument_list|)
expr_stmt|;
name|targ
operator|->
name|toc
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
comment|/* Subtract timeout time. */
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|pfd
operator|.
name|revents
operator|&
name|POLLERR
condition|)
block|{
name|D
argument_list|(
literal|"poll err"
argument_list|)
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
if|if
condition|(
name|nm_ring_empty
argument_list|(
name|ring
argument_list|)
condition|)
continue|continue;
name|limit
operator|=
name|nm_ring_space
argument_list|(
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|>
name|targ
operator|->
name|g
operator|->
name|burst
condition|)
name|limit
operator|=
name|targ
operator|->
name|g
operator|->
name|burst
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Enable this if 		 *     1) we remove the early-return optimization from 		 *        the netmap poll implementation, or 		 *     2) pipes get NS_MOREFRAG support. 		 * With the current netmap implementation, an experiment like 		 *    pkt-gen -i vale:1{1 -f txseq -F 9 		 *    pkt-gen -i vale:1}1 -f rxseq 		 * would get stuck as soon as we find nm_ring_space(ring)< 9, 		 * since here limit is rounded to 0 and 		 * pipe rxsync is not called anymore by the poll() of this loop. 		 */
block|if (frags_exp> 1) { 			int o = limit;
comment|/* Cut off to the closest smaller multiple. */
block|limit = (limit / frags_exp) * frags_exp; 			RD(2, "LIMIT %d --> %d", o, limit); 		}
endif|#
directive|endif
for|for
control|(
name|head
operator|=
name|ring
operator|->
name|head
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|head
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|NETMAP_BUF
argument_list|(
name|ring
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|slot
operator|->
name|len
decl_stmt|;
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
if|if
condition|(
name|dump
condition|)
block|{
name|dump_payload
argument_list|(
name|p
argument_list|,
name|slot
operator|->
name|len
argument_list|,
name|ring
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
name|frags
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_MOREFRAG
operator|)
condition|)
block|{
if|if
condition|(
name|first_packet
condition|)
block|{
name|first_packet
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frags
operator|!=
name|frags_exp
condition|)
block|{
name|char
name|prbuf
index|[
literal|512
index|]
decl_stmt|;
name|RD
argument_list|(
literal|1
argument_list|,
literal|"Received packets with %u frags, "
literal|"expected %u, '%s'"
argument_list|,
name|frags
argument_list|,
name|frags_exp
argument_list|,
name|multi_slot_to_string
argument_list|(
name|ring
argument_list|,
name|head
operator|-
name|frags
operator|+
literal|1
argument_list|,
name|frags
argument_list|,
name|prbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|prbuf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|first_packet
operator|=
literal|0
expr_stmt|;
name|frags_exp
operator|=
name|frags
expr_stmt|;
name|frags
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|-=
sizeof|sizeof
argument_list|(
name|pkt
operator|->
name|vh
argument_list|)
operator|-
name|targ
operator|->
name|g
operator|->
name|virt_header
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
name|pkt
operator|->
name|vh
argument_list|)
operator|-
name|targ
operator|->
name|g
operator|->
name|virt_header
expr_stmt|;
name|pkt
operator|=
operator|(
expr|struct
name|pkt
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|pkt
operator|+
name|len
operator|<
operator|(
operator|(
name|char
operator|*
operator|)
name|pkt
operator|->
name|body
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|seq
argument_list|)
condition|)
block|{
name|RD
argument_list|(
literal|1
argument_list|,
literal|"%s: packet too small (len=%u)"
argument_list|,
name|__func__
argument_list|,
name|slot
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seq
operator|=
operator|(
name|pkt
operator|->
name|body
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|pkt
operator|->
name|body
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|pkt
operator|->
name|body
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|pkt
operator|->
name|body
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|first_slot
condition|)
block|{
comment|/* Grab the first one, whatever it 					   is. */
name|seq_exp
operator|=
name|seq
expr_stmt|;
name|first_slot
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seq
operator|!=
name|seq_exp
condition|)
block|{
name|uint32_t
name|delta
init|=
name|seq
operator|-
name|seq_exp
decl_stmt|;
if|if
condition|(
name|delta
operator|<
operator|(
literal|0xFFFFFFFF
operator|>>
literal|1
operator|)
condition|)
block|{
name|RD
argument_list|(
literal|2
argument_list|,
literal|"Sequence GAP: exp %u found %u"
argument_list|,
name|seq_exp
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RD
argument_list|(
literal|2
argument_list|,
literal|"Sequence OUT OF ORDER: "
literal|"exp %u found %u"
argument_list|,
name|seq_exp
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
name|seq_exp
operator|=
name|seq
expr_stmt|;
block|}
name|seq_exp
operator|++
expr_stmt|;
block|}
name|cur
operator|.
name|bytes
operator|+=
name|slot
operator|->
name|len
expr_stmt|;
name|head
operator|=
name|nm_ring_next
argument_list|(
name|ring
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|cur
operator|.
name|pkts
operator|++
expr_stmt|;
block|}
name|ring
operator|->
name|cur
operator|=
name|ring
operator|->
name|head
operator|=
name|head
expr_stmt|;
name|cur
operator|.
name|events
operator|++
expr_stmt|;
name|targ
operator|->
name|ctr
operator|=
name|cur
expr_stmt|;
block|}
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME_PRECISE
argument_list|,
operator|&
name|targ
operator|->
name|toc
argument_list|)
expr_stmt|;
name|out
label|:
name|targ
operator|->
name|completed
operator|=
literal|1
expr_stmt|;
name|targ
operator|->
name|ctr
operator|=
name|cur
expr_stmt|;
name|quit
label|:
comment|/* reset the ``used`` flag. */
name|targ
operator|->
name|used
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tx_output
parameter_list|(
name|struct
name|my_ctrs
modifier|*
name|cur
parameter_list|,
name|double
name|delta
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|double
name|bw
decl_stmt|,
name|raw_bw
decl_stmt|,
name|pps
decl_stmt|,
name|abs
decl_stmt|;
name|char
name|b1
index|[
literal|40
index|]
decl_stmt|,
name|b2
index|[
literal|80
index|]
decl_stmt|,
name|b3
index|[
literal|80
index|]
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|cur
operator|->
name|pkts
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s nothing.\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|size
operator|=
call|(
name|int
call|)
argument_list|(
name|cur
operator|->
name|bytes
operator|/
name|cur
operator|->
name|pkts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s %llu packets %llu bytes %llu events %d bytes each in %.2f seconds.\n"
argument_list|,
name|msg
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|cur
operator|->
name|pkts
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|cur
operator|->
name|bytes
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|cur
operator|->
name|events
argument_list|,
name|size
argument_list|,
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|delta
operator|=
literal|1e-6
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|60
condition|)
comment|/* correct for min packet size */
name|size
operator|=
literal|60
expr_stmt|;
name|pps
operator|=
name|cur
operator|->
name|pkts
operator|/
name|delta
expr_stmt|;
name|bw
operator|=
operator|(
literal|8.0
operator|*
name|cur
operator|->
name|bytes
operator|)
operator|/
name|delta
expr_stmt|;
comment|/* raw packets have4 bytes crc + 20 bytes framing */
name|raw_bw
operator|=
operator|(
literal|8.0
operator|*
operator|(
name|cur
operator|->
name|pkts
operator|*
literal|24
operator|+
name|cur
operator|->
name|bytes
operator|)
operator|)
operator|/
name|delta
expr_stmt|;
name|abs
operator|=
name|cur
operator|->
name|pkts
operator|/
call|(
name|double
call|)
argument_list|(
name|cur
operator|->
name|events
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Speed: %spps Bandwidth: %sbps (raw %sbps). Average batch: %.2f pkts\n"
argument_list|,
name|norm
argument_list|(
name|b1
argument_list|,
name|pps
argument_list|)
argument_list|,
name|norm
argument_list|(
name|b2
argument_list|,
name|bw
argument_list|)
argument_list|,
name|norm
argument_list|(
name|b3
argument_list|,
name|raw_bw
argument_list|)
argument_list|,
name|abs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cmd
init|=
literal|"pkt-gen"
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage:\n"
literal|"%s arguments\n"
literal|"\t-i interface		interface name\n"
literal|"\t-f function		tx rx ping pong txseq rxseq\n"
literal|"\t-n count		number of iterations (can be 0)\n"
literal|"\t-t pkts_to_send	also forces tx mode\n"
literal|"\t-r pkts_to_receive	also forces rx mode\n"
literal|"\t-l pkt_size		in bytes excluding CRC\n"
literal|"\t-d dst_ip[:port[-dst_ip:port]]   single or range\n"
literal|"\t-s src_ip[:port[-src_ip:port]]   single or range\n"
literal|"\t-D dst-mac\n"
literal|"\t-S src-mac\n"
literal|"\t-a cpu_id		use setaffinity\n"
literal|"\t-b burst size		testing, mostly\n"
literal|"\t-c cores		cores to use\n"
literal|"\t-p threads		processes/threads to use\n"
literal|"\t-T report_ms		milliseconds between reports\n"
literal|"\t-w wait_for_link_time	in seconds\n"
literal|"\t-R rate		in packets per second\n"
literal|"\t-X			dump payload\n"
literal|"\t-H len		add empty virtio-net-header with size 'len'\n"
literal|"\t-E pipes		allocate extra space for a number of pipes\n"
literal|"\t-r			do not touch the buffers (send rubbish)\n"
literal|"\t-P file		load packet from pcap file\n"
literal|"\t-z			use random IPv4 src address/port\n"
literal|"\t-Z			use random IPv4 dst address/port\n"
literal|"\t-F num_frags		send multi-slot packets\n"
literal|"\t-A			activate pps stats on receiver\n"
literal|""
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_enum
enum|enum
block|{
name|TD_TYPE_SENDER
init|=
literal|1
block|,
name|TD_TYPE_RECEIVER
block|,
name|TD_TYPE_OTHER
block|, }
enum|;
end_enum

begin_function
specifier|static
name|void
name|start_threads
parameter_list|(
name|struct
name|glob_arg
modifier|*
name|g
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|targs
operator|=
name|calloc
argument_list|(
name|g
operator|->
name|nthreads
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|targs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now create the desired number of threads, each one 	 * using a single descriptor.  	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|nthreads
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|targ
modifier|*
name|t
init|=
operator|&
name|targs
index|[
name|i
index|]
decl_stmt|;
name|bzero
argument_list|(
name|t
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* default, with pcap */
name|t
operator|->
name|g
operator|=
name|g
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|dev_type
operator|==
name|DEV_NETMAP
condition|)
block|{
name|struct
name|nm_desc
name|nmd
init|=
operator|*
name|g
operator|->
name|nmd
decl_stmt|;
comment|/* copy, we overwrite ringid */
name|uint64_t
name|nmd_flags
init|=
literal|0
decl_stmt|;
name|nmd
operator|.
name|self
operator|=
operator|&
name|nmd
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* the first thread uses the fd opened by the main 			 * thread, the other threads re-open /dev/netmap 			 */
if|if
condition|(
name|g
operator|->
name|nthreads
operator|>
literal|1
condition|)
block|{
name|nmd
operator|.
name|req
operator|.
name|nr_flags
operator|=
name|g
operator|->
name|nmd
operator|->
name|req
operator|.
name|nr_flags
operator|&
operator|~
name|NR_REG_MASK
expr_stmt|;
name|nmd
operator|.
name|req
operator|.
name|nr_flags
operator||=
name|NR_REG_ONE_NIC
expr_stmt|;
name|nmd
operator|.
name|req
operator|.
name|nr_ringid
operator|=
name|i
expr_stmt|;
block|}
comment|/* Only touch one of the rings (rx is already ok) */
if|if
condition|(
name|g
operator|->
name|td_type
operator|==
name|TD_TYPE_RECEIVER
condition|)
name|nmd_flags
operator||=
name|NETMAP_NO_TX_POLL
expr_stmt|;
comment|/* register interface. Override ifname and ringid etc. */
name|t
operator|->
name|nmd
operator|=
name|nm_open
argument_list|(
name|t
operator|->
name|g
operator|->
name|ifname
argument_list|,
name|NULL
argument_list|,
name|nmd_flags
operator||
name|NM_OPEN_IFNAME
operator||
name|NM_OPEN_NO_MMAP
argument_list|,
operator|&
name|nmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|nmd
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"Unable to open %s: %s"
argument_list|,
name|t
operator|->
name|g
operator|->
name|ifname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|t
operator|->
name|nmd
operator|=
name|g
operator|->
name|nmd
expr_stmt|;
block|}
name|t
operator|->
name|fd
operator|=
name|t
operator|->
name|nmd
operator|->
name|fd
expr_stmt|;
block|}
else|else
block|{
name|targs
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|g
operator|->
name|main_fd
expr_stmt|;
block|}
name|t
operator|->
name|used
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|me
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|affinity
operator|>=
literal|0
condition|)
block|{
name|t
operator|->
name|affinity
operator|=
operator|(
name|g
operator|->
name|affinity
operator|+
name|i
operator|)
operator|%
name|g
operator|->
name|system_cpus
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|affinity
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* default, init packets */
name|initialize_packet
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|pthread_create
argument_list|(
operator|&
name|t
operator|->
name|thread
argument_list|,
name|NULL
argument_list|,
name|g
operator|->
name|td_body
argument_list|,
name|t
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"Unable to create thread %d: %s"
argument_list|,
name|i
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|main_thread
parameter_list|(
name|struct
name|glob_arg
modifier|*
name|g
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|my_ctrs
name|prev
decl_stmt|,
name|cur
decl_stmt|;
name|double
name|delta_t
decl_stmt|;
name|struct
name|timeval
name|tic
decl_stmt|,
name|toc
decl_stmt|;
name|prev
operator|.
name|pkts
operator|=
name|prev
operator|.
name|bytes
operator|=
name|prev
operator|.
name|events
operator|=
literal|0
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|prev
operator|.
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|b1
index|[
literal|40
index|]
decl_stmt|,
name|b2
index|[
literal|40
index|]
decl_stmt|,
name|b3
index|[
literal|40
index|]
decl_stmt|,
name|b4
index|[
literal|70
index|]
decl_stmt|;
name|uint64_t
name|pps
decl_stmt|,
name|usec
decl_stmt|;
name|struct
name|my_ctrs
name|x
decl_stmt|;
name|double
name|abs
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|usec
operator|=
name|wait_for_next_report
argument_list|(
operator|&
name|prev
operator|.
name|t
argument_list|,
operator|&
name|cur
operator|.
name|t
argument_list|,
name|g
operator|->
name|report_interval
argument_list|)
expr_stmt|;
name|cur
operator|.
name|pkts
operator|=
name|cur
operator|.
name|bytes
operator|=
name|cur
operator|.
name|events
operator|=
literal|0
expr_stmt|;
name|cur
operator|.
name|min_space
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|usec
operator|<
literal|10000
condition|)
comment|/* too short to be meaningful */
continue|continue;
comment|/* accumulate counts for all threads */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|nthreads
condition|;
name|i
operator|++
control|)
block|{
name|cur
operator|.
name|pkts
operator|+=
name|targs
index|[
name|i
index|]
operator|.
name|ctr
operator|.
name|pkts
expr_stmt|;
name|cur
operator|.
name|bytes
operator|+=
name|targs
index|[
name|i
index|]
operator|.
name|ctr
operator|.
name|bytes
expr_stmt|;
name|cur
operator|.
name|events
operator|+=
name|targs
index|[
name|i
index|]
operator|.
name|ctr
operator|.
name|events
expr_stmt|;
name|cur
operator|.
name|min_space
operator|+=
name|targs
index|[
name|i
index|]
operator|.
name|ctr
operator|.
name|min_space
expr_stmt|;
name|targs
index|[
name|i
index|]
operator|.
name|ctr
operator|.
name|min_space
operator|=
literal|99999
expr_stmt|;
if|if
condition|(
name|targs
index|[
name|i
index|]
operator|.
name|used
operator|==
literal|0
condition|)
name|done
operator|++
expr_stmt|;
block|}
name|x
operator|.
name|pkts
operator|=
name|cur
operator|.
name|pkts
operator|-
name|prev
operator|.
name|pkts
expr_stmt|;
name|x
operator|.
name|bytes
operator|=
name|cur
operator|.
name|bytes
operator|-
name|prev
operator|.
name|bytes
expr_stmt|;
name|x
operator|.
name|events
operator|=
name|cur
operator|.
name|events
operator|-
name|prev
operator|.
name|events
expr_stmt|;
name|pps
operator|=
operator|(
name|x
operator|.
name|pkts
operator|*
literal|1000000
operator|+
name|usec
operator|/
literal|2
operator|)
operator|/
name|usec
expr_stmt|;
name|abs
operator|=
operator|(
name|x
operator|.
name|events
operator|>
literal|0
operator|)
condition|?
operator|(
name|x
operator|.
name|pkts
operator|/
operator|(
name|double
operator|)
name|x
operator|.
name|events
operator|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|g
operator|->
name|options
operator|&
name|OPT_PPS_STATS
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|b4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Compute some pps stats using a sliding window. */
name|double
name|ppsavg
init|=
literal|0.0
decl_stmt|,
name|ppsdev
init|=
literal|0.0
decl_stmt|;
name|int
name|nsamples
init|=
literal|0
decl_stmt|;
name|g
operator|->
name|win
index|[
name|g
operator|->
name|win_idx
index|]
operator|=
name|pps
expr_stmt|;
name|g
operator|->
name|win_idx
operator|=
operator|(
name|g
operator|->
name|win_idx
operator|+
literal|1
operator|)
operator|%
name|STATS_WIN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STATS_WIN
condition|;
name|i
operator|++
control|)
block|{
name|ppsavg
operator|+=
name|g
operator|->
name|win
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|win
index|[
name|i
index|]
condition|)
block|{
name|nsamples
operator|++
expr_stmt|;
block|}
block|}
name|ppsavg
operator|/=
name|nsamples
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STATS_WIN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|g
operator|->
name|win
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|ppsdev
operator|+=
operator|(
name|g
operator|->
name|win
index|[
name|i
index|]
operator|-
name|ppsavg
operator|)
operator|*
operator|(
name|g
operator|->
name|win
index|[
name|i
index|]
operator|-
name|ppsavg
operator|)
expr_stmt|;
block|}
name|ppsdev
operator|/=
name|nsamples
expr_stmt|;
name|ppsdev
operator|=
name|sqrt
argument_list|(
name|ppsdev
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|b4
argument_list|,
sizeof|sizeof
argument_list|(
name|b4
argument_list|)
argument_list|,
literal|"[avg/std %s/%s pps]"
argument_list|,
name|norm
argument_list|(
name|b1
argument_list|,
name|ppsavg
argument_list|)
argument_list|,
name|norm
argument_list|(
name|b2
argument_list|,
name|ppsdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|D
argument_list|(
literal|"%spps %s(%spkts %sbps in %llu usec) %.2f avg_batch %d min_space"
argument_list|,
name|norm
argument_list|(
name|b1
argument_list|,
name|pps
argument_list|)
argument_list|,
name|b4
argument_list|,
name|norm
argument_list|(
name|b2
argument_list|,
operator|(
name|double
operator|)
name|x
operator|.
name|pkts
argument_list|)
argument_list|,
name|norm
argument_list|(
name|b3
argument_list|,
operator|(
name|double
operator|)
name|x
operator|.
name|bytes
operator|*
literal|8
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|usec
argument_list|,
name|abs
argument_list|,
operator|(
name|int
operator|)
name|cur
operator|.
name|min_space
argument_list|)
expr_stmt|;
name|prev
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|done
operator|==
name|g
operator|->
name|nthreads
condition|)
break|break;
block|}
name|timerclear
argument_list|(
operator|&
name|tic
argument_list|)
expr_stmt|;
name|timerclear
argument_list|(
operator|&
name|toc
argument_list|)
expr_stmt|;
name|cur
operator|.
name|pkts
operator|=
name|cur
operator|.
name|bytes
operator|=
name|cur
operator|.
name|events
operator|=
literal|0
expr_stmt|;
comment|/* final round */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|nthreads
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|timespec
name|t_tic
decl_stmt|,
name|t_toc
decl_stmt|;
comment|/* 		 * Join active threads, unregister interfaces and close 		 * file descriptors. 		 */
if|if
condition|(
name|targs
index|[
name|i
index|]
operator|.
name|used
condition|)
name|pthread_join
argument_list|(
name|targs
index|[
name|i
index|]
operator|.
name|thread
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* blocking */
if|if
condition|(
name|g
operator|->
name|dev_type
operator|==
name|DEV_NETMAP
condition|)
block|{
name|nm_close
argument_list|(
name|targs
index|[
name|i
index|]
operator|.
name|nmd
argument_list|)
expr_stmt|;
name|targs
index|[
name|i
index|]
operator|.
name|nmd
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
name|targs
index|[
name|i
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targs
index|[
name|i
index|]
operator|.
name|completed
operator|==
literal|0
condition|)
name|D
argument_list|(
literal|"ouch, thread %d exited with error"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * Collect threads output and extract information about 		 * how long it took to send all the packets. 		 */
name|cur
operator|.
name|pkts
operator|+=
name|targs
index|[
name|i
index|]
operator|.
name|ctr
operator|.
name|pkts
expr_stmt|;
name|cur
operator|.
name|bytes
operator|+=
name|targs
index|[
name|i
index|]
operator|.
name|ctr
operator|.
name|bytes
expr_stmt|;
name|cur
operator|.
name|events
operator|+=
name|targs
index|[
name|i
index|]
operator|.
name|ctr
operator|.
name|events
expr_stmt|;
comment|/* collect the largest start (tic) and end (toc) times, 		 * XXX maybe we should do the earliest tic, or do a weighted 		 * average ? 		 */
name|t_tic
operator|=
name|timeval2spec
argument_list|(
operator|&
name|tic
argument_list|)
expr_stmt|;
name|t_toc
operator|=
name|timeval2spec
argument_list|(
operator|&
name|toc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|timerisset
argument_list|(
operator|&
name|tic
argument_list|)
operator|||
name|timespec_ge
argument_list|(
operator|&
name|targs
index|[
name|i
index|]
operator|.
name|tic
argument_list|,
operator|&
name|t_tic
argument_list|)
condition|)
name|tic
operator|=
name|timespec2val
argument_list|(
operator|&
name|targs
index|[
name|i
index|]
operator|.
name|tic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|timerisset
argument_list|(
operator|&
name|toc
argument_list|)
operator|||
name|timespec_ge
argument_list|(
operator|&
name|targs
index|[
name|i
index|]
operator|.
name|toc
argument_list|,
operator|&
name|t_toc
argument_list|)
condition|)
name|toc
operator|=
name|timespec2val
argument_list|(
operator|&
name|targs
index|[
name|i
index|]
operator|.
name|toc
argument_list|)
expr_stmt|;
block|}
comment|/* print output. */
name|timersub
argument_list|(
operator|&
name|toc
argument_list|,
operator|&
name|tic
argument_list|,
operator|&
name|toc
argument_list|)
expr_stmt|;
name|delta_t
operator|=
name|toc
operator|.
name|tv_sec
operator|+
literal|1e-6
operator|*
name|toc
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|td_type
operator|==
name|TD_TYPE_SENDER
condition|)
name|tx_output
argument_list|(
operator|&
name|cur
argument_list|,
name|delta_t
argument_list|,
literal|"Sent"
argument_list|)
expr_stmt|;
else|else
name|tx_output
argument_list|(
operator|&
name|cur
argument_list|,
name|delta_t
argument_list|,
literal|"Received"
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|td_desc
block|{
name|int
name|ty
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|f
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|td_desc
name|func
index|[]
init|=
block|{
block|{
name|TD_TYPE_SENDER
block|,
literal|"tx"
block|,
name|sender_body
block|}
block|,
block|{
name|TD_TYPE_RECEIVER
block|,
literal|"rx"
block|,
name|receiver_body
block|}
block|,
block|{
name|TD_TYPE_OTHER
block|,
literal|"ping"
block|,
name|pinger_body
block|}
block|,
block|{
name|TD_TYPE_OTHER
block|,
literal|"pong"
block|,
name|ponger_body
block|}
block|,
block|{
name|TD_TYPE_SENDER
block|,
literal|"txseq"
block|,
name|txseq_body
block|}
block|,
block|{
name|TD_TYPE_RECEIVER
block|,
literal|"rxseq"
block|,
name|rxseq_body
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|tap_alloc
parameter_list|(
name|char
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|err
decl_stmt|;
name|char
modifier|*
name|clonedev
init|=
name|TAP_CLONEDEV
decl_stmt|;
operator|(
name|void
operator|)
name|err
expr_stmt|;
operator|(
name|void
operator|)
name|dev
expr_stmt|;
comment|/* Arguments taken by the function: 	 * 	 * char *dev: the name of an interface (or '\0'). MUST have enough 	 *   space to hold the interface name if '\0' is passed 	 * int flags: interface flags (eg, IFF_TUN etc.) 	 */
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|dev
index|[
literal|3
index|]
condition|)
block|{
comment|/* tapSomething */
specifier|static
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|clonedev
operator|=
name|buf
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* open the device */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|clonedev
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
name|fd
return|;
block|}
name|D
argument_list|(
literal|"%s open successful"
argument_list|,
name|clonedev
argument_list|)
expr_stmt|;
comment|/* preparation of the struct ifr, of type "struct ifreq" */
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|linux
name|ifr
operator|.
name|ifr_flags
operator|=
name|IFF_TAP
operator||
name|IFF_NO_PI
expr_stmt|;
if|if
condition|(
operator|*
name|dev
condition|)
block|{
comment|/* if a device name was specified, put it in the structure; otherwise, 		* the kernel will try to allocate the "next" device of the 		* specified type */
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|dev
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
block|}
comment|/* try to create the device */
if|if
condition|(
operator|(
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TUNSETIFF
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"failed to to a TUNSETIFF: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* if the operation was successful, write back the name of the 	* interface to the variable "dev", so the caller can know 	* it. Note that the caller MUST reserve space in *dev (see calling 	* code below) */
name|strcpy
argument_list|(
name|dev
argument_list|,
name|ifr
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"new name is %s"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* linux */
comment|/* this is the special file descriptor that the caller will use to talk          * with the virtual interface */
return|return
name|fd
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|arc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sigaction
name|sa
decl_stmt|;
name|sigset_t
name|ss
decl_stmt|;
name|struct
name|glob_arg
name|g
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|wait_link
init|=
literal|2
decl_stmt|;
name|int
name|devqueues
init|=
literal|1
decl_stmt|;
comment|/* how many device queues */
name|bzero
argument_list|(
operator|&
name|g
argument_list|,
sizeof|sizeof
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|.
name|main_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|g
operator|.
name|td_body
operator|=
name|receiver_body
expr_stmt|;
name|g
operator|.
name|td_type
operator|=
name|TD_TYPE_RECEIVER
expr_stmt|;
name|g
operator|.
name|report_interval
operator|=
literal|1000
expr_stmt|;
comment|/* report interval */
name|g
operator|.
name|affinity
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* ip addresses can also be a range x.x.x.x-x.x.x.y */
name|g
operator|.
name|src_ip
operator|.
name|name
operator|=
literal|"10.0.0.1"
expr_stmt|;
name|g
operator|.
name|dst_ip
operator|.
name|name
operator|=
literal|"10.1.0.1"
expr_stmt|;
name|g
operator|.
name|dst_mac
operator|.
name|name
operator|=
literal|"ff:ff:ff:ff:ff:ff"
expr_stmt|;
name|g
operator|.
name|src_mac
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|g
operator|.
name|pkt_size
operator|=
literal|60
expr_stmt|;
name|g
operator|.
name|burst
operator|=
literal|512
expr_stmt|;
comment|// default
name|g
operator|.
name|nthreads
operator|=
literal|1
expr_stmt|;
name|g
operator|.
name|cpus
operator|=
literal|1
expr_stmt|;
comment|// default
name|g
operator|.
name|forever
operator|=
literal|1
expr_stmt|;
name|g
operator|.
name|tx_rate
operator|=
literal|0
expr_stmt|;
name|g
operator|.
name|frags
operator|=
literal|1
expr_stmt|;
name|g
operator|.
name|nmr_config
operator|=
literal|""
expr_stmt|;
name|g
operator|.
name|virt_header
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|arc
argument_list|,
name|argv
argument_list|,
literal|"a:f:F:n:i:Il:d:s:D:S:b:c:o:p:T:w:WvR:XC:H:e:E:m:rP:zZA"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|td_desc
modifier|*
name|fn
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
default|default:
name|D
argument_list|(
literal|"bad option %c %s"
argument_list|,
name|ch
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|g
operator|.
name|npackets
operator|=
name|strtoull
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|i
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
operator|||
name|i
operator|>
literal|63
condition|)
block|{
name|D
argument_list|(
literal|"invalid frags %d [1..63], ignore"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|g
operator|.
name|frags
operator|=
name|i
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
for|for
control|(
name|fn
operator|=
name|func
init|;
name|fn
operator|->
name|key
condition|;
name|fn
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fn
operator|->
name|key
argument_list|,
name|optarg
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|fn
operator|->
name|key
condition|)
block|{
name|g
operator|.
name|td_body
operator|=
name|fn
operator|->
name|f
expr_stmt|;
name|g
operator|.
name|td_type
operator|=
name|fn
operator|->
name|ty
expr_stmt|;
block|}
else|else
block|{
name|D
argument_list|(
literal|"unrecognised function %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
comment|/* data generation options */
name|g
operator|.
name|options
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* force affinity */
name|g
operator|.
name|affinity
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* interface */
comment|/* a prefix of tap: netmap: or pcap: forces the mode. 			 * otherwise we guess 			 */
name|D
argument_list|(
literal|"interface is %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|>
name|MAX_IFNAMELEN
operator|-
literal|8
condition|)
block|{
name|D
argument_list|(
literal|"ifname too long %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|g
operator|.
name|ifname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"null"
argument_list|)
condition|)
block|{
name|g
operator|.
name|dev_type
operator|=
name|DEV_NETMAP
expr_stmt|;
name|g
operator|.
name|dummy_send
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"tap:"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|g
operator|.
name|dev_type
operator|=
name|DEV_TAP
expr_stmt|;
name|strcpy
argument_list|(
name|g
operator|.
name|ifname
argument_list|,
name|optarg
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"pcap:"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|g
operator|.
name|dev_type
operator|=
name|DEV_PCAP
expr_stmt|;
name|strcpy
argument_list|(
name|g
operator|.
name|ifname
argument_list|,
name|optarg
operator|+
literal|5
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"netmap:"
argument_list|,
literal|7
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"vale"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|g
operator|.
name|dev_type
operator|=
name|DEV_NETMAP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"tap"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|g
operator|.
name|dev_type
operator|=
name|DEV_TAP
expr_stmt|;
block|}
else|else
block|{
comment|/* prepend netmap: */
name|g
operator|.
name|dev_type
operator|=
name|DEV_NETMAP
expr_stmt|;
name|sprintf
argument_list|(
name|g
operator|.
name|ifname
argument_list|,
literal|"netmap:%s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
name|g
operator|.
name|options
operator||=
name|OPT_INDIRECT
expr_stmt|;
comment|/* XXX use indirect buffer */
break|break;
case|case
literal|'l'
case|:
comment|/* pkt_size */
name|g
operator|.
name|pkt_size
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|g
operator|.
name|dst_ip
operator|.
name|name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|g
operator|.
name|src_ip
operator|.
name|name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* report interval */
name|g
operator|.
name|report_interval
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wait_link
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
comment|/* XXX changed default */
name|g
operator|.
name|forever
operator|=
literal|0
expr_stmt|;
comment|/* do not exit rx even with no traffic */
break|break;
case|case
literal|'b'
case|:
comment|/* burst */
name|g
operator|.
name|burst
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|g
operator|.
name|cpus
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|g
operator|.
name|nthreads
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* destination mac */
name|g
operator|.
name|dst_mac
operator|.
name|name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* source mac */
name|g
operator|.
name|src_mac
operator|.
name|name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|g
operator|.
name|tx_rate
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|g
operator|.
name|options
operator||=
name|OPT_DUMP
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|g
operator|.
name|nmr_config
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|g
operator|.
name|virt_header
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* extra bufs */
name|g
operator|.
name|extra_bufs
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|g
operator|.
name|extra_pipes
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|g
operator|.
name|packet_file
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* ignored */
break|break;
case|case
literal|'r'
case|:
name|g
operator|.
name|options
operator||=
name|OPT_RUBBISH
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|g
operator|.
name|options
operator||=
name|OPT_RANDOM_SRC
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|g
operator|.
name|options
operator||=
name|OPT_RANDOM_DST
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|g
operator|.
name|options
operator||=
name|OPT_PPS_STATS
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|strlen
argument_list|(
name|g
operator|.
name|ifname
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"missing ifname"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|g
operator|.
name|system_cpus
operator|=
name|i
operator|=
name|system_ncpus
argument_list|()
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|cpus
operator|<
literal|0
operator|||
name|g
operator|.
name|cpus
operator|>
name|i
condition|)
block|{
name|D
argument_list|(
literal|"%d cpus is too high, have only %d cpus"
argument_list|,
name|g
operator|.
name|cpus
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|D
argument_list|(
literal|"running on %d cpus (have %d)"
argument_list|,
name|g
operator|.
name|cpus
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|cpus
operator|==
literal|0
condition|)
name|g
operator|.
name|cpus
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|pkt_size
operator|<
literal|16
operator|||
name|g
operator|.
name|pkt_size
operator|>
name|MAX_PKTSIZE
condition|)
block|{
name|D
argument_list|(
literal|"bad pktsize %d [16..%d]\n"
argument_list|,
name|g
operator|.
name|pkt_size
argument_list|,
name|MAX_PKTSIZE
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|.
name|src_mac
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
specifier|static
name|char
name|mybuf
index|[
literal|20
index|]
init|=
literal|"00:00:00:00:00:00"
decl_stmt|;
comment|/* retrieve source mac address. */
if|if
condition|(
name|source_hwaddr
argument_list|(
name|g
operator|.
name|ifname
argument_list|,
name|mybuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"Unable to retrieve source mac"
argument_list|)
expr_stmt|;
comment|// continue, fail later
block|}
name|g
operator|.
name|src_mac
operator|.
name|name
operator|=
name|mybuf
expr_stmt|;
block|}
comment|/* extract address ranges */
name|extract_ip_range
argument_list|(
operator|&
name|g
operator|.
name|src_ip
argument_list|)
expr_stmt|;
name|extract_ip_range
argument_list|(
operator|&
name|g
operator|.
name|dst_ip
argument_list|)
expr_stmt|;
name|extract_mac_range
argument_list|(
operator|&
name|g
operator|.
name|src_mac
argument_list|)
expr_stmt|;
name|extract_mac_range
argument_list|(
operator|&
name|g
operator|.
name|dst_mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|src_ip
operator|.
name|start
operator|!=
name|g
operator|.
name|src_ip
operator|.
name|end
operator|||
name|g
operator|.
name|src_ip
operator|.
name|port0
operator|!=
name|g
operator|.
name|src_ip
operator|.
name|port1
operator|||
name|g
operator|.
name|dst_ip
operator|.
name|start
operator|!=
name|g
operator|.
name|dst_ip
operator|.
name|end
operator|||
name|g
operator|.
name|dst_ip
operator|.
name|port0
operator|!=
name|g
operator|.
name|dst_ip
operator|.
name|port1
condition|)
name|g
operator|.
name|options
operator||=
name|OPT_COPY
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|virt_header
operator|!=
literal|0
operator|&&
name|g
operator|.
name|virt_header
operator|!=
name|VIRT_HDR_1
operator|&&
name|g
operator|.
name|virt_header
operator|!=
name|VIRT_HDR_2
condition|)
block|{
name|D
argument_list|(
literal|"bad virtio-net-header length"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|.
name|dev_type
operator|==
name|DEV_TAP
condition|)
block|{
name|D
argument_list|(
literal|"want to use tap %s"
argument_list|,
name|g
operator|.
name|ifname
argument_list|)
expr_stmt|;
name|g
operator|.
name|main_fd
operator|=
name|tap_alloc
argument_list|(
name|g
operator|.
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|main_fd
operator|<
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"cannot open tap %s"
argument_list|,
name|g
operator|.
name|ifname
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_PCAP
block|}
elseif|else
if|if
condition|(
name|g
operator|.
name|dev_type
operator|==
name|DEV_PCAP
condition|)
block|{
name|char
name|pcap_errbuf
index|[
name|PCAP_ERRBUF_SIZE
index|]
decl_stmt|;
name|pcap_errbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|// init the buffer
name|g
operator|.
name|p
operator|=
name|pcap_open_live
argument_list|(
name|g
operator|.
name|ifname
argument_list|,
literal|256
comment|/* XXX */
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|,
name|pcap_errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|p
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"cannot open pcap on %s"
argument_list|,
name|g
operator|.
name|ifname
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|g
operator|.
name|main_fd
operator|=
name|pcap_fileno
argument_list|(
name|g
operator|.
name|p
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"using pcap on %s fileno %d"
argument_list|,
name|g
operator|.
name|ifname
argument_list|,
name|g
operator|.
name|main_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !NO_PCAP */
block|}
elseif|else
if|if
condition|(
name|g
operator|.
name|dummy_send
condition|)
block|{
comment|/* but DEV_NETMAP */
name|D
argument_list|(
literal|"using a dummy send routine"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|nmreq
name|base_nmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|base_nmd
argument_list|,
sizeof|sizeof
argument_list|(
name|base_nmd
argument_list|)
argument_list|)
expr_stmt|;
name|parse_nmr_config
argument_list|(
name|g
operator|.
name|nmr_config
argument_list|,
operator|&
name|base_nmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|extra_bufs
condition|)
block|{
name|base_nmd
operator|.
name|nr_arg3
operator|=
name|g
operator|.
name|extra_bufs
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|.
name|extra_pipes
condition|)
block|{
name|base_nmd
operator|.
name|nr_arg1
operator|=
name|g
operator|.
name|extra_pipes
expr_stmt|;
block|}
name|base_nmd
operator|.
name|nr_flags
operator||=
name|NR_ACCEPT_VNET_HDR
expr_stmt|;
comment|/* 	 * Open the netmap device using nm_open(). 	 * 	 * protocol stack and may cause a reset of the card, 	 * which in turn may take some time for the PHY to 	 * reconfigure. We do the open here to have time to reset. 	 */
name|g
operator|.
name|nmd
operator|=
name|nm_open
argument_list|(
name|g
operator|.
name|ifname
argument_list|,
operator|&
name|base_nmd
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|nmd
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"Unable to open %s: %s"
argument_list|,
name|g
operator|.
name|ifname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|g
operator|.
name|nthreads
operator|>
literal|1
condition|)
block|{
name|struct
name|nm_desc
name|saved_desc
init|=
operator|*
name|g
operator|.
name|nmd
decl_stmt|;
name|saved_desc
operator|.
name|self
operator|=
operator|&
name|saved_desc
expr_stmt|;
name|saved_desc
operator|.
name|mem
operator|=
name|NULL
expr_stmt|;
name|nm_close
argument_list|(
name|g
operator|.
name|nmd
argument_list|)
expr_stmt|;
name|saved_desc
operator|.
name|req
operator|.
name|nr_flags
operator|&=
operator|~
name|NR_REG_MASK
expr_stmt|;
name|saved_desc
operator|.
name|req
operator|.
name|nr_flags
operator||=
name|NR_REG_ONE_NIC
expr_stmt|;
name|saved_desc
operator|.
name|req
operator|.
name|nr_ringid
operator|=
literal|0
expr_stmt|;
name|g
operator|.
name|nmd
operator|=
name|nm_open
argument_list|(
name|g
operator|.
name|ifname
argument_list|,
operator|&
name|base_nmd
argument_list|,
name|NM_OPEN_IFNAME
argument_list|,
operator|&
name|saved_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|nmd
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"Unable to open %s: %s"
argument_list|,
name|g
operator|.
name|ifname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|g
operator|.
name|main_fd
operator|=
name|g
operator|.
name|nmd
operator|->
name|fd
expr_stmt|;
name|D
argument_list|(
literal|"mapped %dKB at %p"
argument_list|,
name|g
operator|.
name|nmd
operator|->
name|req
operator|.
name|nr_memsize
operator|>>
literal|10
argument_list|,
name|g
operator|.
name|nmd
operator|->
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|virt_header
condition|)
block|{
comment|/* Set the virtio-net header length, since the user asked 		 * for it explicitely. */
name|set_vnet_hdr_len
argument_list|(
operator|&
name|g
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check whether the netmap port we opened requires us to send 		 * and receive frames with virtio-net header. */
name|get_vnet_hdr_len
argument_list|(
operator|&
name|g
argument_list|)
expr_stmt|;
block|}
comment|/* get num of queues in tx or rx */
if|if
condition|(
name|g
operator|.
name|td_type
operator|==
name|TD_TYPE_SENDER
condition|)
name|devqueues
operator|=
name|g
operator|.
name|nmd
operator|->
name|req
operator|.
name|nr_tx_rings
expr_stmt|;
else|else
name|devqueues
operator|=
name|g
operator|.
name|nmd
operator|->
name|req
operator|.
name|nr_rx_rings
expr_stmt|;
comment|/* validate provided nthreads. */
if|if
condition|(
name|g
operator|.
name|nthreads
operator|<
literal|1
operator|||
name|g
operator|.
name|nthreads
operator|>
name|devqueues
condition|)
block|{
name|D
argument_list|(
literal|"bad nthreads %d, have %d queues"
argument_list|,
name|g
operator|.
name|nthreads
argument_list|,
name|devqueues
argument_list|)
expr_stmt|;
comment|// continue, fail later
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|struct
name|netmap_if
modifier|*
name|nifp
init|=
name|g
operator|.
name|nmd
operator|->
name|nifp
decl_stmt|;
name|struct
name|nmreq
modifier|*
name|req
init|=
operator|&
name|g
operator|.
name|nmd
operator|->
name|req
decl_stmt|;
name|D
argument_list|(
literal|"nifp at offset %d, %d tx %d rx region %d"
argument_list|,
name|req
operator|->
name|nr_offset
argument_list|,
name|req
operator|->
name|nr_tx_rings
argument_list|,
name|req
operator|->
name|nr_rx_rings
argument_list|,
name|req
operator|->
name|nr_arg2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|req
operator|->
name|nr_tx_rings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|NETMAP_TXRING
argument_list|(
name|nifp
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|D
argument_list|(
literal|"   TX%d at 0x%p slots %d"
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ring
operator|-
operator|(
name|char
operator|*
operator|)
name|nifp
operator|)
argument_list|,
name|ring
operator|->
name|num_slots
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|req
operator|->
name|nr_rx_rings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|NETMAP_RXRING
argument_list|(
name|nifp
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|D
argument_list|(
literal|"   RX%d at 0x%p slots %d"
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ring
operator|-
operator|(
name|char
operator|*
operator|)
name|nifp
operator|)
argument_list|,
name|ring
operator|->
name|num_slots
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Print some debug information. */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s %s: %d queues, %d threads and %d cpus.\n"
argument_list|,
operator|(
name|g
operator|.
name|td_type
operator|==
name|TD_TYPE_SENDER
operator|)
condition|?
literal|"Sending on"
else|:
operator|(
operator|(
name|g
operator|.
name|td_type
operator|==
name|TD_TYPE_RECEIVER
operator|)
condition|?
literal|"Receiving from"
else|:
literal|"Working on"
operator|)
argument_list|,
name|g
operator|.
name|ifname
argument_list|,
name|devqueues
argument_list|,
name|g
operator|.
name|nthreads
argument_list|,
name|g
operator|.
name|cpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|td_type
operator|==
name|TD_TYPE_SENDER
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s -> %s (%s -> %s)\n"
argument_list|,
name|g
operator|.
name|src_ip
operator|.
name|name
argument_list|,
name|g
operator|.
name|dst_ip
operator|.
name|name
argument_list|,
name|g
operator|.
name|src_mac
operator|.
name|name
argument_list|,
name|g
operator|.
name|dst_mac
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|out
label|:
comment|/* Exit if something went wrong. */
if|if
condition|(
name|g
operator|.
name|main_fd
operator|<
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"aborting"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|g
operator|.
name|options
condition|)
block|{
name|D
argument_list|(
literal|"--- SPECIAL OPTIONS:%s%s%s%s%s%s\n"
argument_list|,
name|g
operator|.
name|options
operator|&
name|OPT_PREFETCH
condition|?
literal|" prefetch"
else|:
literal|""
argument_list|,
name|g
operator|.
name|options
operator|&
name|OPT_ACCESS
condition|?
literal|" access"
else|:
literal|""
argument_list|,
name|g
operator|.
name|options
operator|&
name|OPT_MEMCPY
condition|?
literal|" memcpy"
else|:
literal|""
argument_list|,
name|g
operator|.
name|options
operator|&
name|OPT_INDIRECT
condition|?
literal|" indirect"
else|:
literal|""
argument_list|,
name|g
operator|.
name|options
operator|&
name|OPT_COPY
condition|?
literal|" copy"
else|:
literal|""
argument_list|,
name|g
operator|.
name|options
operator|&
name|OPT_RUBBISH
condition|?
literal|" rubbish "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|g
operator|.
name|tx_period
operator|.
name|tv_sec
operator|=
name|g
operator|.
name|tx_period
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|tx_rate
operator|>
literal|0
condition|)
block|{
comment|/* try to have at least something every second, 		 * reducing the burst size to some 0.01s worth of data 		 * (but no less than one full set of fragments) 	 	 */
name|uint64_t
name|x
decl_stmt|;
name|int
name|lim
init|=
operator|(
name|g
operator|.
name|tx_rate
operator|)
operator|/
literal|300
decl_stmt|;
if|if
condition|(
name|g
operator|.
name|burst
operator|>
name|lim
condition|)
name|g
operator|.
name|burst
operator|=
name|lim
expr_stmt|;
if|if
condition|(
name|g
operator|.
name|burst
operator|<
name|g
operator|.
name|frags
condition|)
name|g
operator|.
name|burst
operator|=
name|g
operator|.
name|frags
expr_stmt|;
name|x
operator|=
operator|(
operator|(
name|uint64_t
operator|)
literal|1000000000
operator|*
operator|(
name|uint64_t
operator|)
name|g
operator|.
name|burst
operator|)
operator|/
operator|(
name|uint64_t
operator|)
name|g
operator|.
name|tx_rate
expr_stmt|;
name|g
operator|.
name|tx_period
operator|.
name|tv_nsec
operator|=
name|x
expr_stmt|;
name|g
operator|.
name|tx_period
operator|.
name|tv_sec
operator|=
name|g
operator|.
name|tx_period
operator|.
name|tv_nsec
operator|/
literal|1000000000
expr_stmt|;
name|g
operator|.
name|tx_period
operator|.
name|tv_nsec
operator|=
name|g
operator|.
name|tx_period
operator|.
name|tv_nsec
operator|%
literal|1000000000
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|.
name|td_type
operator|==
name|TD_TYPE_SENDER
condition|)
name|D
argument_list|(
literal|"Sending %d packets every  %ld.%09ld s"
argument_list|,
name|g
operator|.
name|burst
argument_list|,
name|g
operator|.
name|tx_period
operator|.
name|tv_sec
argument_list|,
name|g
operator|.
name|tx_period
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
comment|/* Wait for PHY reset. */
name|D
argument_list|(
literal|"Wait %d secs for phy reset"
argument_list|,
name|wait_link
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|wait_link
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"Ready..."
argument_list|)
expr_stmt|;
comment|/* Install ^C handler. */
name|global_nthreads
operator|=
name|g
operator|.
name|nthreads
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|ss
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|ss
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
comment|/* block SIGINT now, so that all created threads will inherit the mask */
if|if
condition|(
name|pthread_sigmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|ss
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"failed to block SIGINT: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|start_threads
argument_list|(
operator|&
name|g
argument_list|)
expr_stmt|;
comment|/* Install the handler and re-enable SIGINT for the main thread */
name|sa
operator|.
name|sa_handler
operator|=
name|sigint_h
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"failed to install ^C handler: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pthread_sigmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|ss
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"failed to re-enable SIGINT: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|main_thread
argument_list|(
operator|&
name|g
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|targs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* end of file */
end_comment

end_unit

