begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*  * juggle is a simple IPC/context switch performance test, which works on  * pairs of file descriptors of various types.  In various runs, it considers  * the cost of bouncing a message synchronously across the descriptor pair,  * either in the same thread, two different threads, or two different  * processes.  Timing measurements for each series of I/O's are reported, but  * the first measurement in each series discarded as "warmup" on the IPC  * primitive.  Variations on the test permit for pipelining, or the insertion  * of more than one packet into the stream at a time, intended to permit  * greater parallelism, hopefully allowing performance numbers to reflect  * use of available parallelism, and/or intelligence in context switching to  * avoid premature switching when multiple messages are queued.  */
end_comment

begin_comment
comment|/*  * The UDP test uses UDP over the loopback interface.  Two arbitrary but  * fixed port numbers.  */
end_comment

begin_define
define|#
directive|define
name|UDP_PORT1
value|2020
end_define

begin_define
define|#
directive|define
name|UDP_PORT2
value|2021
end_define

begin_comment
comment|/*  * Size of each message.  Must be smaller than the socket buffer or pipe  * buffer maximum size, as we want to send it atomically without blocking.  * If pipelining is in use, must be able to fit PIPELINE_MAX of these  * messages into the send queue.  */
end_comment

begin_define
define|#
directive|define
name|MESSAGELEN
value|128
end_define

begin_comment
comment|/*  * Number of message cycles -- into fd1, out of fd2, into fd2, and out of  * fd1.  By counting in cycles, we allow the master thread or process to  * perform timing without explicitly synchronizing with the secondary thread  * or process.  */
end_comment

begin_define
define|#
directive|define
name|NUMCYCLES
value|1024
end_define

begin_comment
comment|/*  * Number of times to run each test.  */
end_comment

begin_define
define|#
directive|define
name|LOOPS
value|10
end_define

begin_comment
comment|/*  * Number of in-flight messages per cycle.  I adjusting this value, be  * careful not to exceed the socket/etc buffer depth, or messages may be lost  * or result in blocking.  */
end_comment

begin_define
define|#
directive|define
name|PIPELINE_MAX
value|4
end_define

begin_comment
comment|/*  * As in all programs, steal timespecsub() from time.h.  */
end_comment

begin_define
define|#
directive|define
name|timespecsub
parameter_list|(
name|vvp
parameter_list|,
name|uvp
parameter_list|)
define|\
value|do {                                                            \                 (vvp)->tv_sec -= (uvp)->tv_sec;                         \                 (vvp)->tv_nsec -= (uvp)->tv_nsec;                       \                 if ((vvp)->tv_nsec< 0) {                               \                         (vvp)->tv_sec--;                                \                         (vvp)->tv_nsec += 1000000000;                   \                 }                                                       \         } while (0)
end_define

begin_function
specifier|static
name|int
name|udp_create
parameter_list|(
name|int
modifier|*
name|fd1p
parameter_list|,
name|int
modifier|*
name|fd2p
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|sin1
decl_stmt|,
name|sin2
decl_stmt|;
name|int
name|sock1
decl_stmt|,
name|sock2
decl_stmt|;
name|sock1
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock1
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sock2
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock2
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|sock1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|sin1
argument_list|,
sizeof|sizeof
argument_list|(
name|sin1
argument_list|)
argument_list|)
expr_stmt|;
name|sin1
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin1
argument_list|)
expr_stmt|;
name|sin1
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin1
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
expr_stmt|;
name|sin1
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|UDP_PORT1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sin2
argument_list|,
sizeof|sizeof
argument_list|(
name|sin2
argument_list|)
argument_list|)
expr_stmt|;
name|sin2
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin2
argument_list|)
expr_stmt|;
name|sin2
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin2
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
expr_stmt|;
name|sin2
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|UDP_PORT2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sock1
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin1
argument_list|,
sizeof|sizeof
argument_list|(
name|sin1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|sock1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|sock2
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin2
argument_list|,
sizeof|sizeof
argument_list|(
name|sin2
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|sock1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|sock1
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin2
argument_list|,
sizeof|sizeof
argument_list|(
name|sin2
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|sock1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|sock2
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin1
argument_list|,
sizeof|sizeof
argument_list|(
name|sin1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|sock1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|fd1p
operator|=
name|sock1
expr_stmt|;
operator|*
name|fd2p
operator|=
name|sock2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pipe_create
parameter_list|(
name|int
modifier|*
name|fd1p
parameter_list|,
name|int
modifier|*
name|fd2p
parameter_list|)
block|{
name|int
name|fds
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fds
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|fd1p
operator|=
name|fds
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|fd2p
operator|=
name|fds
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|socketpairdgram_create
parameter_list|(
name|int
modifier|*
name|fd1p
parameter_list|,
name|int
modifier|*
name|fd2p
parameter_list|)
block|{
name|int
name|fds
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|socketpair
argument_list|(
name|PF_LOCAL
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|,
name|fds
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|fd1p
operator|=
name|fds
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|fd2p
operator|=
name|fds
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|socketpairstream_create
parameter_list|(
name|int
modifier|*
name|fd1p
parameter_list|,
name|int
modifier|*
name|fd2p
parameter_list|)
block|{
name|int
name|fds
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|socketpair
argument_list|(
name|PF_LOCAL
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|fds
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|fd1p
operator|=
name|fds
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|fd2p
operator|=
name|fds
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|message_send
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|u_char
name|buffer
index|[
name|MESSAGELEN
index|]
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|bzero
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|write
argument_list|(
name|s
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EMSGSIZE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|message_recv
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|u_char
name|buffer
index|[
name|MESSAGELEN
index|]
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|len
operator|=
name|read
argument_list|(
name|s
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EMSGSIZE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Juggle messages between two file descriptors in a single thread/process,  * so simply a measure of IPC performance.  */
end_comment

begin_function
specifier|static
name|struct
name|timespec
name|juggle
parameter_list|(
name|int
name|fd1
parameter_list|,
name|int
name|fd2
parameter_list|,
name|int
name|pipeline
parameter_list|)
block|{
name|struct
name|timespec
name|tstart
decl_stmt|,
name|tfinish
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|tstart
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"juggle: clock_gettime"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMCYCLES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pipeline
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|message_send
argument_list|(
name|fd1
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"message_send fd1"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pipeline
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|message_recv
argument_list|(
name|fd2
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"message_recv fd2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_send
argument_list|(
name|fd2
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"message_send fd2"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pipeline
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|message_recv
argument_list|(
name|fd1
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"message_recv fd1"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|tfinish
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"juggle: clock_gettime"
argument_list|)
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|tfinish
argument_list|,
operator|&
name|tstart
argument_list|)
expr_stmt|;
return|return
operator|(
name|tfinish
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Juggle messages between two file descriptors in two threads, so measure  * the cost of IPC and the cost of a thread context switch.  *  * In order to avoid measuring thread creation time, we make use of a  * condition variable to decide when both threads are ready to begin  * juggling.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|threaded_child_ready
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|threaded_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pthread_cond_t
name|threaded_cond
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|threaded_pipeline
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|juggling_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|fd2
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|fd2
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|pthread_mutex_lock
argument_list|(
operator|&
name|threaded_mtx
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"juggling_thread: pthread_mutex_lock"
argument_list|)
expr_stmt|;
name|threaded_child_ready
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pthread_cond_signal
argument_list|(
operator|&
name|threaded_cond
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"juggling_thread: pthread_cond_signal"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pthread_mutex_unlock
argument_list|(
operator|&
name|threaded_mtx
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"juggling_thread: pthread_mutex_unlock"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMCYCLES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|threaded_pipeline
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|message_recv
argument_list|(
name|fd2
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"message_recv fd2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_send
argument_list|(
name|fd2
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"message_send fd2"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|timespec
name|thread_juggle
parameter_list|(
name|int
name|fd1
parameter_list|,
name|int
name|fd2
parameter_list|,
name|int
name|pipeline
parameter_list|)
block|{
name|struct
name|timespec
name|tstart
decl_stmt|,
name|tfinish
decl_stmt|;
name|pthread_t
name|thread
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|threaded_pipeline
operator|=
name|pipeline
expr_stmt|;
if|if
condition|(
name|pthread_mutex_init
argument_list|(
operator|&
name|threaded_mtx
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"thread_juggle: pthread_mutex_init"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pthread_create
argument_list|(
operator|&
name|thread
argument_list|,
name|NULL
argument_list|,
name|juggling_thread
argument_list|,
operator|&
name|fd2
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"thread_juggle: pthread_create"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pthread_mutex_lock
argument_list|(
operator|&
name|threaded_mtx
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"thread_juggle: pthread_mutex_lock"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|threaded_child_ready
condition|)
block|{
if|if
condition|(
name|pthread_cond_wait
argument_list|(
operator|&
name|threaded_cond
argument_list|,
operator|&
name|threaded_mtx
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"thread_juggle: pthread_cond_wait"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pthread_mutex_unlock
argument_list|(
operator|&
name|threaded_mtx
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"thread_juggle: pthread_mutex_unlock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|tstart
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"thread_juggle: clock_gettime"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMCYCLES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pipeline
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|message_send
argument_list|(
name|fd1
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"message_send fd1"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pipeline
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|message_recv
argument_list|(
name|fd1
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"message_recv fd1"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|tfinish
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"thread_juggle: clock_gettime"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pthread_join
argument_list|(
name|thread
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"thread_juggle: pthread_join"
argument_list|)
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|tfinish
argument_list|,
operator|&
name|tstart
argument_list|)
expr_stmt|;
return|return
operator|(
name|tfinish
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Juggle messages between two file descriptors in two processes, so measure  * the cost of IPC and the cost of a process context switch.  *  * Since we can't use a mutex between the processes, we simply do an extra  * write on the child to let the parent know that it's ready to start.  */
end_comment

begin_function
specifier|static
name|struct
name|timespec
name|process_juggle
parameter_list|(
name|int
name|fd1
parameter_list|,
name|int
name|fd2
parameter_list|,
name|int
name|pipeline
parameter_list|)
block|{
name|struct
name|timespec
name|tstart
decl_stmt|,
name|tfinish
decl_stmt|;
name|pid_t
name|pid
decl_stmt|,
name|ppid
decl_stmt|,
name|wpid
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ppid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"process_juggle: fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|message_send
argument_list|(
name|fd2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|kill
argument_list|(
name|ppid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|errno
operator|=
name|error
expr_stmt|;
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"process_juggle: child: message_send"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMCYCLES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pipeline
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|message_send
argument_list|(
name|fd2
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"message_send fd2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_recv
argument_list|(
name|fd2
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"message_recv fd2"
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|message_recv
argument_list|(
name|fd1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|errno
operator|=
name|error
expr_stmt|;
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"process_juggle: parent: message_recv"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|tstart
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"process_juggle: clock_gettime"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMCYCLES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pipeline
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|message_send
argument_list|(
name|fd1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|errno
operator|=
name|error
expr_stmt|;
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"message_send fd1"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pipeline
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|message_recv
argument_list|(
name|fd1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|errno
operator|=
name|error
expr_stmt|;
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"message_recv fd1"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|tfinish
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"process_juggle: clock_gettime"
argument_list|)
expr_stmt|;
block|}
name|wpid
operator|=
name|waitpid
argument_list|(
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpid
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"process_juggle: waitpid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpid
operator|!=
name|pid
condition|)
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"process_juggle: waitpid: pid != wpid"
argument_list|)
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|tfinish
argument_list|,
operator|&
name|tstart
argument_list|)
expr_stmt|;
return|return
operator|(
name|tfinish
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When we print out results for larger pipeline sizes, we scale back by the  * depth of the pipeline.  This generally means dividing by the pipeline  * depth.  Except when it means dividing by zero.  */
end_comment

begin_function
specifier|static
name|void
name|scale_timespec
parameter_list|(
name|struct
name|timespec
modifier|*
name|ts
parameter_list|,
name|int
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return;
name|ts
operator|->
name|tv_sec
operator|/=
name|p
expr_stmt|;
name|ts
operator|->
name|tv_nsec
operator|/=
name|p
expr_stmt|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
name|ipctype
block|{
name|int
function_decl|(
modifier|*
name|it_create
function_decl|)
parameter_list|(
name|int
modifier|*
name|fd1p
parameter_list|,
name|int
modifier|*
name|fd2p
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|it_name
decl_stmt|;
block|}
name|ipctypes
index|[]
init|=
block|{
block|{
name|pipe_create
block|,
literal|"pipe"
block|}
block|,
block|{
name|udp_create
block|,
literal|"udp"
block|}
block|,
block|{
name|socketpairdgram_create
block|,
literal|"socketpairdgram"
block|}
block|,
block|{
name|socketpairstream_create
block|,
literal|"socketpairstream"
block|}
block|, }
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|int
name|ipctypes_len
init|=
operator|(
sizeof|sizeof
argument_list|(
name|ipctypes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ipctype
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|timespec
name|juggle_results
index|[
name|LOOPS
index|]
decl_stmt|,
name|process_results
index|[
name|LOOPS
index|]
decl_stmt|;
name|struct
name|timespec
name|thread_results
index|[
name|LOOPS
index|]
decl_stmt|;
name|int
name|fd1
decl_stmt|,
name|fd2
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|p
decl_stmt|;
name|struct
name|utsname
name|uts
decl_stmt|;
name|printf
argument_list|(
literal|"version, juggle.c %s\n"
argument_list|,
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|uname
argument_list|(
operator|&
name|uts
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"utsname"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sysname, %s\n"
argument_list|,
name|uts
operator|.
name|sysname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"nodename, %s\n"
argument_list|,
name|uts
operator|.
name|nodename
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"release, %s\n"
argument_list|,
name|uts
operator|.
name|release
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"version, %s\n"
argument_list|,
name|uts
operator|.
name|version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"machine, %s\n"
argument_list|,
name|uts
operator|.
name|machine
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MESSAGELEN, %d\n"
argument_list|,
name|MESSAGELEN
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"NUMCYCLES, %d\n"
argument_list|,
name|NUMCYCLES
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LOOPS, %d\n"
argument_list|,
name|LOOPS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PIPELINE_MAX, %d\n"
argument_list|,
name|PIPELINE_MAX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ipctype, test, pipeline_depth"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LOOPS
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|", data%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|PIPELINE_MAX
operator|+
literal|1
condition|;
name|p
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ipctypes_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ipctypes
index|[
name|i
index|]
operator|.
name|it_create
argument_list|(
operator|&
name|fd1
argument_list|,
operator|&
name|fd2
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"main: %s"
argument_list|,
name|ipctypes
index|[
name|i
index|]
operator|.
name|it_name
argument_list|)
expr_stmt|;
comment|/* 			 * For each test, do one uncounted warmup, then LOOPS 			 * runs of the actual test. 			 */
name|juggle
argument_list|(
name|fd1
argument_list|,
name|fd2
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LOOPS
condition|;
name|j
operator|++
control|)
name|juggle_results
index|[
name|j
index|]
operator|=
name|juggle
argument_list|(
name|fd1
argument_list|,
name|fd2
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|process_juggle
argument_list|(
name|fd1
argument_list|,
name|fd2
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LOOPS
condition|;
name|j
operator|++
control|)
name|process_results
index|[
name|j
index|]
operator|=
name|process_juggle
argument_list|(
name|fd1
argument_list|,
name|fd2
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|thread_juggle
argument_list|(
name|fd1
argument_list|,
name|fd2
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LOOPS
condition|;
name|j
operator|++
control|)
name|thread_results
index|[
name|j
index|]
operator|=
name|thread_juggle
argument_list|(
name|fd1
argument_list|,
name|fd2
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LOOPS
condition|;
name|j
operator|++
control|)
block|{
name|thread_results
index|[
name|j
index|]
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|thread_results
index|[
name|j
index|]
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * When printing results for the round, normalize the results 		 * with respect to the pipeline depth.  We're doing p times 		 * as much work, and are we taking p times as long? 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ipctypes_len
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%s, juggle, %d, "
argument_list|,
name|ipctypes
index|[
name|i
index|]
operator|.
name|it_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LOOPS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|scale_timespec
argument_list|(
operator|&
name|juggle_results
index|[
name|j
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%jd.%09lu"
argument_list|,
operator|(
name|intmax_t
operator|)
name|juggle_results
index|[
name|j
index|]
operator|.
name|tv_sec
argument_list|,
name|juggle_results
index|[
name|j
index|]
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s, process_juggle, %d, "
argument_list|,
name|ipctypes
index|[
name|i
index|]
operator|.
name|it_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LOOPS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|scale_timespec
argument_list|(
operator|&
name|process_results
index|[
name|j
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%jd.%09lu"
argument_list|,
operator|(
name|intmax_t
operator|)
name|process_results
index|[
name|j
index|]
operator|.
name|tv_sec
argument_list|,
name|process_results
index|[
name|j
index|]
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s, thread_juggle, %d, "
argument_list|,
name|ipctypes
index|[
name|i
index|]
operator|.
name|it_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LOOPS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|scale_timespec
argument_list|(
operator|&
name|thread_results
index|[
name|j
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%jd.%09lu"
argument_list|,
operator|(
name|intmax_t
operator|)
name|thread_results
index|[
name|j
index|]
operator|.
name|tv_sec
argument_list|,
name|thread_results
index|[
name|j
index|]
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

