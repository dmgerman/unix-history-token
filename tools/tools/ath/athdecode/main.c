begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"diag.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_decode.h"
end_include

begin_include
include|#
directive|include
file|"dumpregs.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
name|HAL_REVS
name|revs
decl_stmt|;
name|int
name|chipnum
decl_stmt|;
define|#
directive|define
name|MAXREGS
value|5*1024
name|struct
name|dumpreg
modifier|*
name|regs
index|[
name|MAXREGS
index|]
decl_stmt|;
name|u_int
name|nregs
decl_stmt|;
block|}
name|dumpregs_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|dumpregs_t
name|state
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|opdevice
parameter_list|(
specifier|const
name|struct
name|athregrec
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|opmark
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|struct
name|athregrec
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|oprw
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|int
name|recnum
parameter_list|,
name|struct
name|athregrec
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|nrecs
decl_stmt|,
name|same
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
literal|"/tmp/ath_hal.log"
decl_stmt|;
name|struct
name|athregrec
modifier|*
name|rprev
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|filename
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fstat"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_NOCORE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|MAP_FAILED
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"mmap"
argument_list|)
expr_stmt|;
name|nrecs
operator|=
name|sb
operator|.
name|st_size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|athregrec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%u records"
argument_list|,
name|nrecs
argument_list|)
expr_stmt|;
name|rprev
operator|=
name|NULL
expr_stmt|;
name|same
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|chipnum
operator|=
literal|5210
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrecs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|athregrec
modifier|*
name|r
init|=
operator|&
operator|(
operator|(
expr|struct
name|athregrec
operator|*
operator|)
name|addr
operator|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|rprev
operator|&&
name|bcmp
argument_list|(
name|r
argument_list|,
name|rprev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|same
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|same
condition|)
name|printf
argument_list|(
literal|"\t\t+%u time%s"
argument_list|,
name|same
argument_list|,
name|same
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|op
condition|)
block|{
case|case
name|OP_DEVICE
case|:
name|opdevice
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_READ
case|:
case|case
name|OP_WRITE
case|:
name|oprw
argument_list|(
name|stdout
argument_list|,
name|i
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MARK
case|:
name|opmark
argument_list|(
name|stdout
argument_list|,
name|i
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
name|rprev
operator|=
name|r
expr_stmt|;
name|same
operator|=
literal|0
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|opmark
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|int
name|i
parameter_list|,
specifier|const
name|struct
name|athregrec
modifier|*
name|r
parameter_list|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\n%05d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|reg
condition|)
block|{
case|case
name|AH_MARK_RESET
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uReset %s"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|,
name|r
operator|->
name|val
condition|?
literal|"change channel"
else|:
literal|"no channel change"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AH_MARK_RESET_LINE
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%u_reset.c; line %u"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|,
name|r
operator|->
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|AH_MARK_RESET_DONE
case|:
if|if
condition|(
name|r
operator|->
name|val
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uReset (done), FAIL, error %u"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|,
name|r
operator|->
name|val
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uReset (done), OK"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|AH_MARK_CHIPRESET
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uChipReset, channel %u MHz"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|,
name|r
operator|->
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|AH_MARK_PERCAL
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uPerCalibration, channel %u MHz"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|,
name|r
operator|->
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|AH_MARK_SETCHANNEL
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uSetChannel, channel %u MHz"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|,
name|r
operator|->
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|AH_MARK_ANI_RESET
case|:
switch|switch
condition|(
name|r
operator|->
name|val
condition|)
block|{
case|case
name|HAL_M_STA
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniReset, HAL_M_STA"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_IBSS
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniReset, HAL_M_IBSS"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_HOSTAP
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniReset, HAL_M_HOSTAP"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_MONITOR
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniReset, HAL_M_MONITOR"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniReset, opmode %u"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|,
name|r
operator|->
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|AH_MARK_ANI_POLL
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniPoll, listenTime %u"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|,
name|r
operator|->
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|AH_MARK_ANI_CONTROL
case|:
switch|switch
condition|(
name|r
operator|->
name|val
condition|)
block|{
case|case
name|HAL_ANI_PRESENT
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniControl, PRESENT"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_ANI_NOISE_IMMUNITY_LEVEL
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniControl, NOISE_IMMUNITY"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniControl, OFDM_WEAK_SIGNAL"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_ANI_CCK_WEAK_SIGNAL_THR
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniControl, CCK_WEAK_SIGNAL"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_ANI_FIRSTEP_LEVEL
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniControl, FIRSTEP_LEVEL"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_ANI_SPUR_IMMUNITY_LEVEL
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniControl, SPUR_IMMUNITY"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_ANI_MODE
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniControl, MODE"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_ANI_PHYERR_RESET
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniControl, PHYERR_RESET"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"ar%uAniControl, cmd %u"
argument_list|,
name|state
operator|.
name|chipnum
argument_list|,
name|r
operator|->
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"mark #%u value %u/0x%x"
argument_list|,
name|r
operator|->
name|reg
argument_list|,
name|r
operator|->
name|val
argument_list|,
name|r
operator|->
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_function
specifier|static
name|void
name|opdevice
parameter_list|(
specifier|const
name|struct
name|athregrec
modifier|*
name|r
parameter_list|)
block|{
switch|switch
condition|(
name|r
operator|->
name|val
condition|)
block|{
case|case
name|AR5210_PROD
case|:
case|case
name|AR5210_DEFAULT
case|:
name|state
operator|.
name|chipnum
operator|=
literal|5210
expr_stmt|;
name|state
operator|.
name|revs
operator|.
name|ah_macVersion
operator|=
literal|1
expr_stmt|;
name|state
operator|.
name|revs
operator|.
name|ah_macRev
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AR5211_DEVID
case|:
case|case
name|AR5311_DEVID
case|:
case|case
name|AR5211_DEFAULT
case|:
case|case
name|AR5211_FPGA11B
case|:
name|state
operator|.
name|chipnum
operator|=
literal|5211
expr_stmt|;
name|state
operator|.
name|revs
operator|.
name|ah_macVersion
operator|=
literal|2
expr_stmt|;
name|state
operator|.
name|revs
operator|.
name|ah_macRev
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* AR5212 */
case|case
name|AR5212_DEFAULT
case|:
case|case
name|AR5212_DEVID
case|:
case|case
name|AR5212_FPGA
case|:
case|case
name|AR5212_DEVID_IBM
case|:
case|case
name|AR5212_AR5312_REV2
case|:
case|case
name|AR5212_AR5312_REV7
case|:
case|case
name|AR5212_AR2313_REV8
case|:
case|case
name|AR5212_AR2315_REV6
case|:
case|case
name|AR5212_AR2315_REV7
case|:
case|case
name|AR5212_AR2317_REV1
case|:
case|case
name|AR5212_AR2317_REV2
case|:
comment|/* AR5212 compatible devid's also attach to 5212 */
case|case
name|AR5212_DEVID_0014
case|:
case|case
name|AR5212_DEVID_0015
case|:
case|case
name|AR5212_DEVID_0016
case|:
case|case
name|AR5212_DEVID_0017
case|:
case|case
name|AR5212_DEVID_0018
case|:
case|case
name|AR5212_DEVID_0019
case|:
case|case
name|AR5212_AR2413
case|:
case|case
name|AR5212_AR5413
case|:
case|case
name|AR5212_AR5424
case|:
case|case
name|AR5212_AR2417
case|:
case|case
name|AR5212_DEVID_FF19
case|:
name|state
operator|.
name|chipnum
operator|=
literal|5212
expr_stmt|;
name|state
operator|.
name|revs
operator|.
name|ah_macVersion
operator|=
literal|4
expr_stmt|;
name|state
operator|.
name|revs
operator|.
name|ah_macRev
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* AR5213 */
case|case
name|AR5213_SREV_1_0
case|:
case|case
name|AR5213_SREV_REG
case|:
name|state
operator|.
name|chipnum
operator|=
literal|5213
expr_stmt|;
name|state
operator|.
name|revs
operator|.
name|ah_macVersion
operator|=
literal|5
expr_stmt|;
name|state
operator|.
name|revs
operator|.
name|ah_macRev
operator|=
literal|9
expr_stmt|;
break|break;
comment|/* AR5416 compatible devid's  */
case|case
name|AR5416_DEVID_PCI
case|:
case|case
name|AR5416_DEVID_PCIE
case|:
case|case
name|AR9160_DEVID_PCI
case|:
case|case
name|AR9280_DEVID_PCI
case|:
case|case
name|AR9280_DEVID_PCIE
case|:
case|case
name|AR9285_DEVID_PCIE
case|:
name|state
operator|.
name|chipnum
operator|=
literal|5416
expr_stmt|;
name|state
operator|.
name|revs
operator|.
name|ah_macVersion
operator|=
literal|13
expr_stmt|;
name|state
operator|.
name|revs
operator|.
name|ah_macRev
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown device id 0x%x\n"
argument_list|,
name|r
operator|->
name|val
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|regcompar
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|dumpreg
modifier|*
name|ra
init|=
operator|*
operator|(
specifier|const
expr|struct
name|dumpreg
operator|*
operator|*
operator|)
name|a
decl_stmt|;
specifier|const
name|struct
name|dumpreg
modifier|*
name|rb
init|=
operator|*
operator|(
specifier|const
expr|struct
name|dumpreg
operator|*
operator|*
operator|)
name|b
decl_stmt|;
return|return
name|ra
operator|->
name|addr
operator|-
name|rb
operator|->
name|addr
return|;
block|}
end_function

begin_function
name|void
name|register_regs
parameter_list|(
name|struct
name|dumpreg
modifier|*
name|chipregs
parameter_list|,
name|u_int
name|nchipregs
parameter_list|,
name|int
name|def_srev_min
parameter_list|,
name|int
name|def_srev_max
parameter_list|,
name|int
name|def_phy_min
parameter_list|,
name|int
name|def_phy_max
parameter_list|)
block|{
specifier|const
name|int
name|existing_regs
init|=
name|state
operator|.
name|nregs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchipregs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|dumpreg
modifier|*
name|nr
init|=
operator|&
name|chipregs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|nr
operator|->
name|srevMin
operator|==
literal|0
condition|)
name|nr
operator|->
name|srevMin
operator|=
name|def_srev_min
expr_stmt|;
if|if
condition|(
name|nr
operator|->
name|srevMax
operator|==
literal|0
condition|)
name|nr
operator|->
name|srevMax
operator|=
name|def_srev_max
expr_stmt|;
if|if
condition|(
name|nr
operator|->
name|phyMin
operator|==
literal|0
condition|)
name|nr
operator|->
name|phyMin
operator|=
name|def_phy_min
expr_stmt|;
if|if
condition|(
name|nr
operator|->
name|phyMax
operator|==
literal|0
condition|)
name|nr
operator|->
name|phyMax
operator|=
name|def_phy_max
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|existing_regs
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|dumpreg
modifier|*
name|r
init|=
name|state
operator|.
name|regs
index|[
name|j
index|]
decl_stmt|;
comment|/* 			 * Check if we can just expand the mac+phy 			 * coverage for the existing entry. 			 */
if|if
condition|(
name|nr
operator|->
name|addr
operator|==
name|r
operator|->
name|addr
operator|&&
operator|(
name|nr
operator|->
name|name
operator|==
name|r
operator|->
name|name
operator|||
name|nr
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|nr
operator|->
name|name
argument_list|,
name|r
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|nr
operator|->
name|srevMin
operator|<
name|r
operator|->
name|srevMin
operator|&&
operator|(
name|r
operator|->
name|srevMin
operator|<=
name|nr
operator|->
name|srevMax
operator|&&
name|nr
operator|->
name|srevMax
operator|+
literal|1
operator|<=
name|r
operator|->
name|srevMax
operator|)
condition|)
block|{
name|r
operator|->
name|srevMin
operator|=
name|nr
operator|->
name|srevMin
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|nr
operator|->
name|srevMax
operator|>
name|r
operator|->
name|srevMax
operator|&&
operator|(
name|r
operator|->
name|srevMin
operator|<=
name|nr
operator|->
name|srevMin
operator|&&
name|nr
operator|->
name|srevMin
operator|<=
name|r
operator|->
name|srevMax
operator|)
condition|)
block|{
name|r
operator|->
name|srevMax
operator|=
name|nr
operator|->
name|srevMax
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
block|}
if|if
condition|(
name|r
operator|->
name|addr
operator|>
name|nr
operator|->
name|addr
condition|)
break|break;
block|}
comment|/* 		 * New item, add to the end, it'll be sorted below. 		 */
if|if
condition|(
name|state
operator|.
name|nregs
operator|==
name|MAXREGS
condition|)
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"too many registers; bump MAXREGS"
argument_list|)
expr_stmt|;
name|state
operator|.
name|regs
index|[
name|state
operator|.
name|nregs
operator|++
index|]
operator|=
name|nr
expr_stmt|;
name|skip
label|:
empty_stmt|;
block|}
name|qsort
argument_list|(
name|state
operator|.
name|regs
argument_list|,
name|state
operator|.
name|nregs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dumpreg
operator|*
argument_list|)
argument_list|,
name|regcompar
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|register_keycache
parameter_list|(
name|u_int
name|nslots
parameter_list|,
name|int
name|def_srev_min
parameter_list|,
name|int
name|def_srev_max
parameter_list|,
name|int
name|def_phy_min
parameter_list|,
name|int
name|def_phy_max
parameter_list|)
block|{
comment|/* discard, no use */
block|}
end_function

begin_function
name|void
name|register_range
parameter_list|(
name|u_int
name|brange
parameter_list|,
name|u_int
name|erange
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|def_srev_min
parameter_list|,
name|int
name|def_srev_max
parameter_list|,
name|int
name|def_phy_min
parameter_list|,
name|int
name|def_phy_max
parameter_list|)
block|{
comment|/* discard, no use */
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|dumpreg
modifier|*
name|findreg
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
specifier|const
name|HAL_REVS
modifier|*
name|revs
init|=
operator|&
name|state
operator|.
name|revs
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|.
name|nregs
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|dumpreg
modifier|*
name|dr
init|=
name|state
operator|.
name|regs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|dr
operator|->
name|addr
operator|==
name|reg
operator|&&
name|MAC_MATCH
argument_list|(
name|dr
argument_list|,
name|revs
operator|->
name|ah_macVersion
argument_list|,
name|revs
operator|->
name|ah_macRev
argument_list|)
condition|)
return|return
name|dr
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* XXX cheat, 5212 has a superset of the key table defs */
end_comment

begin_include
include|#
directive|include
file|"ar5212/ar5212reg.h"
end_include

begin_include
include|#
directive|include
file|"ar5212/ar5212phy.h"
end_include

begin_define
define|#
directive|define
name|PWR_TABLE_SIZE
value|64
end_define

begin_function
specifier|static
name|void
name|oprw
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|int
name|recnum
parameter_list|,
name|struct
name|athregrec
modifier|*
name|r
parameter_list|)
block|{
specifier|const
name|struct
name|dumpreg
modifier|*
name|dr
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|bits
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\n%05d: [%d] "
argument_list|,
name|recnum
argument_list|,
name|r
operator|->
name|threadid
argument_list|)
expr_stmt|;
name|dr
operator|=
name|findreg
argument_list|(
name|r
operator|->
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|!=
name|NULL
operator|&&
name|dr
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"AR_%s (0x%x)"
argument_list|,
name|dr
operator|->
name|name
argument_list|,
name|r
operator|->
name|reg
argument_list|)
expr_stmt|;
name|bits
operator|=
name|dr
operator|->
name|bits
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_KEYTABLE
argument_list|(
literal|0
argument_list|)
operator|<=
name|r
operator|->
name|reg
operator|&&
name|r
operator|->
name|reg
operator|<
name|AR_KEYTABLE
argument_list|(
literal|128
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"AR_KEYTABLE%u(%u) (0x%x)"
argument_list|,
operator|(
operator|(
name|r
operator|->
name|reg
operator|-
name|AR_KEYTABLE_0
operator|)
operator|>>
literal|2
operator|)
operator|&
literal|7
argument_list|,
operator|(
name|r
operator|->
name|reg
operator|-
name|AR_KEYTABLE_0
operator|)
operator|>>
literal|5
argument_list|,
name|r
operator|->
name|reg
argument_list|)
expr_stmt|;
name|bits
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
block|} else if (AR_PHY_PCDAC_TX_POWER(0)<= r->reg&& r->reg< AR_PHY_PCDAC_TX_POWER(PWR_TABLE_SIZE/2)) { 		snprintf(buf, sizeof (buf), "AR_PHY_PCDAC_TX_POWER(%u) (0x%x)", 			(r->reg - AR_PHY_PCDAC_TX_POWER_0)>> 2, r->reg); 		bits = NULL;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|AR_RATE_DURATION
argument_list|(
literal|0
argument_list|)
operator|<=
name|r
operator|->
name|reg
operator|&&
name|r
operator|->
name|reg
operator|<
name|AR_RATE_DURATION
argument_list|(
literal|32
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"AR_RATE_DURATION(0x%x) (0x%x)"
argument_list|,
operator|(
name|r
operator|->
name|reg
operator|-
name|AR_RATE_DURATION_0
operator|)
operator|>>
literal|2
argument_list|,
name|r
operator|->
name|reg
argument_list|)
expr_stmt|;
name|bits
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_PHY_BASE
operator|<=
name|r
operator|->
name|reg
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"AR_PHY(%u) (0x%x)"
argument_list|,
operator|(
name|r
operator|->
name|reg
operator|-
name|AR_PHY_BASE
operator|)
operator|>>
literal|2
argument_list|,
name|r
operator|->
name|reg
argument_list|)
expr_stmt|;
name|bits
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"0x%x"
argument_list|,
name|r
operator|->
name|reg
argument_list|)
expr_stmt|;
name|bits
operator|=
name|NULL
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%-30s %s 0x%x"
argument_list|,
name|buf
argument_list|,
name|r
operator|->
name|op
condition|?
literal|"<="
else|:
literal|"=>"
argument_list|,
name|r
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|bits
decl_stmt|;
name|int
name|tmp
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|tmp
operator|=
literal|0
operator|,
name|p
operator|++
init|;
operator|*
name|p
condition|;
control|)
block|{
name|n
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|n
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|putc
argument_list|(
name|tmp
condition|?
literal|','
else|:
literal|'<'
argument_list|,
name|fd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|n
operator|=
operator|*
name|p
operator|)
operator|>
literal|' '
condition|;
operator|++
name|p
control|)
name|putc
argument_list|(
name|n
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|1
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
operator|*
name|p
operator|>
literal|' '
condition|;
operator|++
name|p
control|)
continue|continue;
block|}
if|if
condition|(
name|tmp
condition|)
name|putc
argument_list|(
literal|'>'
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

