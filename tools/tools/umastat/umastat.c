begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma_int.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<memstat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|nlist
name|namelist
index|[]
init|=
block|{
define|#
directive|define
name|X_UMA_KEGS
value|0
block|{
operator|.
name|n_name
operator|=
literal|"_uma_kegs"
block|}
block|,
define|#
directive|define
name|X_MP_MAXCPUS
value|1
block|{
operator|.
name|n_name
operator|=
literal|"_mp_maxcpus"
block|}
block|,
define|#
directive|define
name|X_MP_MAXID
value|2
block|{
operator|.
name|n_name
operator|=
literal|"_mp_maxid"
block|}
block|,
define|#
directive|define
name|X_ALLCPU
value|3
block|{
operator|.
name|n_name
operator|=
literal|"_all_cpus"
block|}
block|,
block|{
operator|.
name|n_name
operator|=
literal|""
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"umastat [-M core [-N system]]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|kread
parameter_list|(
name|kvm_t
modifier|*
name|kvm
parameter_list|,
name|void
modifier|*
name|kvm_pointer
parameter_list|,
name|void
modifier|*
name|address
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|offset
parameter_list|)
block|{
name|ssize_t
name|ret
decl_stmt|;
name|ret
operator|=
name|kvm_read
argument_list|(
name|kvm
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|kvm_pointer
operator|+
name|offset
argument_list|,
name|address
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|MEMSTAT_ERROR_KVM
operator|)
return|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|ret
operator|!=
name|size
condition|)
return|return
operator|(
name|MEMSTAT_ERROR_KVM_SHORTREAD
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kread_string
parameter_list|(
name|kvm_t
modifier|*
name|kvm
parameter_list|,
specifier|const
name|void
modifier|*
name|kvm_pointer
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|ssize_t
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buflen
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|kvm_read
argument_list|(
name|kvm
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|kvm_pointer
operator|+
name|i
argument_list|,
operator|&
operator|(
name|buffer
index|[
name|i
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|MEMSTAT_ERROR_KVM
operator|)
return|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|ret
operator|!=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
return|return
operator|(
name|MEMSTAT_ERROR_KVM_SHORTREAD
operator|)
return|;
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Truncate. */
name|buffer
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kread_symbol
parameter_list|(
name|kvm_t
modifier|*
name|kvm
parameter_list|,
name|int
name|index
parameter_list|,
name|void
modifier|*
name|address
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|offset
parameter_list|)
block|{
name|ssize_t
name|ret
decl_stmt|;
name|ret
operator|=
name|kvm_read
argument_list|(
name|kvm
argument_list|,
name|namelist
index|[
name|index
index|]
operator|.
name|n_value
operator|+
name|offset
argument_list|,
name|address
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|MEMSTAT_ERROR_KVM
operator|)
return|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|ret
operator|!=
name|size
condition|)
return|return
operator|(
name|MEMSTAT_ERROR_KVM_SHORTREAD
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
name|flaginfo
block|{
name|u_int32_t
name|fi_flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|fi_name
decl_stmt|;
block|}
name|flaginfo
index|[]
init|=
block|{
block|{
name|UMA_ZFLAG_MULTI
block|,
literal|"multi"
block|}
block|,
block|{
name|UMA_ZFLAG_DRAINING
block|,
literal|"draining"
block|}
block|,
block|{
name|UMA_ZFLAG_BUCKET
block|,
literal|"bucket"
block|}
block|,
block|{
name|UMA_ZFLAG_INTERNAL
block|,
literal|"internal"
block|}
block|,
block|{
name|UMA_ZFLAG_FULL
block|,
literal|"full"
block|}
block|,
block|{
name|UMA_ZFLAG_CACHEONLY
block|,
literal|"cacheonly"
block|}
block|,
block|{
name|UMA_ZONE_PAGEABLE
block|,
literal|"pageable"
block|}
block|,
block|{
name|UMA_ZONE_ZINIT
block|,
literal|"zinit"
block|}
block|,
block|{
name|UMA_ZONE_STATIC
block|,
literal|"static"
block|}
block|,
block|{
name|UMA_ZONE_OFFPAGE
block|,
literal|"offpage"
block|}
block|,
block|{
name|UMA_ZONE_MALLOC
block|,
literal|"malloc"
block|}
block|,
block|{
name|UMA_ZONE_NOFREE
block|,
literal|"nofree"
block|}
block|,
block|{
name|UMA_ZONE_MTXCLASS
block|,
literal|"mtxclass"
block|}
block|,
block|{
name|UMA_ZONE_VM
block|,
literal|"vm"
block|}
block|,
block|{
name|UMA_ZONE_HASH
block|,
literal|"hash"
block|}
block|,
block|{
name|UMA_ZONE_SECONDARY
block|,
literal|"secondary"
block|}
block|,
block|{
name|UMA_ZONE_REFCNT
block|,
literal|"refcnt"
block|}
block|,
block|{
name|UMA_ZONE_MAXBUCKET
block|,
literal|"maxbucket"
block|}
block|,
block|{
name|UMA_ZONE_CACHESPREAD
block|,
literal|"cachespread"
block|}
block|,
block|{
name|UMA_ZONE_VTOSLAB
block|,
literal|"vtoslab"
block|}
block|,
block|{
name|UMA_ZONE_NODUMP
block|,
literal|"nodump"
block|}
block|,
block|{
name|UMA_ZONE_PCPU
block|,
literal|"pcpu"
block|}
block|, }
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|int
name|flaginfo_count
init|=
sizeof|sizeof
argument_list|(
name|flaginfo
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|flaginfo
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|uma_print_keg_flags
parameter_list|(
name|struct
name|uma_keg
modifier|*
name|ukp
parameter_list|,
specifier|const
name|char
modifier|*
name|spaces
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ukp
operator|->
name|uk_flags
condition|)
block|{
name|printf
argument_list|(
literal|"%suk_flags = 0;\n"
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%suk_flags = "
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
init|;
name|i
operator|<
name|flaginfo_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ukp
operator|->
name|uk_flags
operator|&
name|flaginfo
index|[
name|i
index|]
operator|.
name|fi_flag
condition|)
block|{
if|if
condition|(
name|count
operator|++
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|flaginfo
index|[
name|i
index|]
operator|.
name|fi_name
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uma_print_keg_align
parameter_list|(
name|struct
name|uma_keg
modifier|*
name|ukp
parameter_list|,
specifier|const
name|char
modifier|*
name|spaces
parameter_list|)
block|{
switch|switch
condition|(
name|ukp
operator|->
name|uk_align
condition|)
block|{
case|case
name|UMA_ALIGN_PTR
case|:
name|printf
argument_list|(
literal|"%suk_align = UMA_ALIGN_PTR;\n"
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case UMA_ALIGN_LONG: 		printf("%suk_align = UMA_ALIGN_LONG;\n", spaces); 		break;  	case UMA_ALIGN_INT: 		printf("%suk_align = UMA_ALIGN_INT;\n", spaces); 		break;
endif|#
directive|endif
case|case
name|UMA_ALIGN_SHORT
case|:
name|printf
argument_list|(
literal|"%suk_align = UMA_ALIGN_SHORT;\n"
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMA_ALIGN_CHAR
case|:
name|printf
argument_list|(
literal|"%suk_align = UMA_ALIGN_CHAR;\n"
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMA_ALIGN_CACHE
case|:
name|printf
argument_list|(
literal|"%suk_align = UMA_ALIGN_CACHE;\n"
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%suk_align = %d\n"
argument_list|,
name|spaces
argument_list|,
name|ukp
operator|->
name|uk_align
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|bucketlist
argument_list|,
name|uma_bucket
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|uma_print_bucket
parameter_list|(
name|struct
name|uma_bucket
modifier|*
name|ubp
parameter_list|,
specifier|const
name|char
modifier|*
name|spaces
name|__unused
parameter_list|)
block|{
name|printf
argument_list|(
literal|"{ ub_cnt = %d, ub_entries = %d }"
argument_list|,
name|ubp
operator|->
name|ub_cnt
argument_list|,
name|ubp
operator|->
name|ub_entries
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uma_print_bucketlist
parameter_list|(
name|kvm_t
modifier|*
name|kvm
parameter_list|,
name|struct
name|bucketlist
modifier|*
name|bucketlist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|spaces
parameter_list|)
block|{
name|struct
name|uma_bucket
modifier|*
name|ubp
decl_stmt|,
name|ub
decl_stmt|;
name|uint64_t
name|total_entries
decl_stmt|,
name|total_cnt
decl_stmt|;
name|int
name|count
decl_stmt|,
name|ret
decl_stmt|;
name|printf
argument_list|(
literal|"%s%s {"
argument_list|,
name|spaces
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|total_entries
operator|=
name|total_cnt
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ubp
operator|=
name|LIST_FIRST
argument_list|(
name|bucketlist
argument_list|)
init|;
name|ubp
operator|!=
name|NULL
condition|;
name|ubp
operator|=
name|LIST_NEXT
argument_list|(
operator|&
name|ub
argument_list|,
name|ub_link
argument_list|)
control|)
block|{
name|ret
operator|=
name|kread
argument_list|(
name|kvm
argument_list|,
name|ubp
argument_list|,
operator|&
name|ub
argument_list|,
sizeof|sizeof
argument_list|(
name|ub
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"uma_print_bucketlist: %s"
argument_list|,
name|kvm_geterr
argument_list|(
name|kvm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|%
literal|2
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n%s  "
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
name|uma_print_bucket
argument_list|(
operator|&
name|ub
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|total_entries
operator|+=
name|ub
operator|.
name|ub_entries
expr_stmt|;
name|total_cnt
operator|+=
name|ub
operator|.
name|ub_cnt
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s};  // total cnt %ju, total entries %ju\n"
argument_list|,
name|spaces
argument_list|,
name|total_cnt
argument_list|,
name|total_entries
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uma_print_cache
parameter_list|(
name|kvm_t
modifier|*
name|kvm
parameter_list|,
name|struct
name|uma_cache
modifier|*
name|cache
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|cpu
parameter_list|,
specifier|const
name|char
modifier|*
name|spaces
parameter_list|,
name|int
modifier|*
name|ub_cnt_add
parameter_list|,
name|int
modifier|*
name|ub_entries_add
parameter_list|)
block|{
name|struct
name|uma_bucket
name|ub
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|printf
argument_list|(
literal|"%s%s[%d] = {\n"
argument_list|,
name|spaces
argument_list|,
name|name
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s  uc_frees = %ju;\n"
argument_list|,
name|spaces
argument_list|,
name|cache
operator|->
name|uc_frees
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s  uc_allocs = %ju;\n"
argument_list|,
name|spaces
argument_list|,
name|cache
operator|->
name|uc_allocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_freebucket
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|kread
argument_list|(
name|kvm
argument_list|,
name|cache
operator|->
name|uc_freebucket
argument_list|,
operator|&
name|ub
argument_list|,
sizeof|sizeof
argument_list|(
name|ub
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"uma_print_cache: %s"
argument_list|,
name|kvm_geterr
argument_list|(
name|kvm
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s  uc_freebucket "
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
name|uma_print_bucket
argument_list|(
operator|&
name|ub
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ub_cnt_add
operator|!=
name|NULL
condition|)
operator|*
name|ub_cnt_add
operator|+=
name|ub
operator|.
name|ub_cnt
expr_stmt|;
if|if
condition|(
name|ub_entries_add
operator|!=
name|NULL
condition|)
operator|*
name|ub_entries_add
operator|+=
name|ub
operator|.
name|ub_entries
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s  uc_freebucket = NULL;\n"
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|uc_allocbucket
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|kread
argument_list|(
name|kvm
argument_list|,
name|cache
operator|->
name|uc_allocbucket
argument_list|,
operator|&
name|ub
argument_list|,
sizeof|sizeof
argument_list|(
name|ub
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"uma_print_cache: %s"
argument_list|,
name|kvm_geterr
argument_list|(
name|kvm
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s  uc_allocbucket "
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
name|uma_print_bucket
argument_list|(
operator|&
name|ub
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ub_cnt_add
operator|!=
name|NULL
condition|)
operator|*
name|ub_cnt_add
operator|+=
name|ub
operator|.
name|ub_cnt
expr_stmt|;
if|if
condition|(
name|ub_entries_add
operator|!=
name|NULL
condition|)
operator|*
name|ub_entries_add
operator|+=
name|ub
operator|.
name|ub_entries
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s  uc_allocbucket = NULL;\n"
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s};\n"
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|LIST_HEAD
argument_list|(
argument_list|,
argument|uma_keg
argument_list|)
name|uma_kegs
expr_stmt|;
name|char
name|name
index|[
name|MEMTYPE_MAXNAME
index|]
decl_stmt|;
name|struct
name|uma_keg
modifier|*
name|kzp
decl_stmt|,
name|kz
decl_stmt|;
name|struct
name|uma_zone
modifier|*
name|uzp
decl_stmt|,
modifier|*
name|uzp_userspace
decl_stmt|;
name|kvm_t
modifier|*
name|kvm
decl_stmt|;
name|int
name|all_cpus
decl_stmt|,
name|cpu
decl_stmt|,
name|mp_maxcpus
decl_stmt|,
name|mp_maxid
decl_stmt|,
name|ret
decl_stmt|,
name|ub_cnt
decl_stmt|,
name|ub_entries
decl_stmt|;
name|size_t
name|uzp_userspace_len
decl_stmt|;
name|char
modifier|*
name|memf
decl_stmt|,
modifier|*
name|nlistf
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|char
name|errbuf
index|[
name|_POSIX2_LINE_MAX
index|]
decl_stmt|;
name|memf
operator|=
name|nlistf
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"M:N:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'M'
case|:
name|memf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|nlistf
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|nlistf
operator|!=
name|NULL
operator|&&
name|memf
operator|==
name|NULL
condition|)
name|usage
argument_list|()
expr_stmt|;
name|kvm
operator|=
name|kvm_openfiles
argument_list|(
name|nlistf
argument_list|,
name|memf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvm
operator|==
name|NULL
condition|)
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"kvm_openfiles: %s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvm_nlist
argument_list|(
name|kvm
argument_list|,
name|namelist
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"kvm_nlist"
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelist
index|[
name|X_UMA_KEGS
index|]
operator|.
name|n_type
operator|==
literal|0
operator|||
name|namelist
index|[
name|X_UMA_KEGS
index|]
operator|.
name|n_value
operator|==
literal|0
condition|)
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"kvm_nlist return"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|kread_symbol
argument_list|(
name|kvm
argument_list|,
name|X_MP_MAXCPUS
argument_list|,
operator|&
name|mp_maxcpus
argument_list|,
sizeof|sizeof
argument_list|(
name|mp_maxcpus
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"kread_symbol: %s"
argument_list|,
name|kvm_geterr
argument_list|(
name|kvm
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mp_maxcpus = %d\n"
argument_list|,
name|mp_maxcpus
argument_list|)
expr_stmt|;
name|ret
operator|=
name|kread_symbol
argument_list|(
name|kvm
argument_list|,
name|X_MP_MAXID
argument_list|,
operator|&
name|mp_maxid
argument_list|,
sizeof|sizeof
argument_list|(
name|mp_maxid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"kread_symbol: %s"
argument_list|,
name|kvm_geterr
argument_list|(
name|kvm
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mp_maxid = %d\n"
argument_list|,
name|mp_maxid
argument_list|)
expr_stmt|;
name|ret
operator|=
name|kread_symbol
argument_list|(
name|kvm
argument_list|,
name|X_ALLCPU
argument_list|,
operator|&
name|all_cpus
argument_list|,
sizeof|sizeof
argument_list|(
name|all_cpus
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"kread_symbol: %s"
argument_list|,
name|kvm_geterr
argument_list|(
name|kvm
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"all_cpus = %x\n"
argument_list|,
name|all_cpus
argument_list|)
expr_stmt|;
name|ret
operator|=
name|kread_symbol
argument_list|(
name|kvm
argument_list|,
name|X_UMA_KEGS
argument_list|,
operator|&
name|uma_kegs
argument_list|,
sizeof|sizeof
argument_list|(
name|uma_kegs
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"kread_symbol: %s"
argument_list|,
name|kvm_geterr
argument_list|(
name|kvm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * uma_zone_t ends in an array of mp_maxid cache entries.  However, 	 * it is statically declared as an array of size 1, so we need to 	 * provide additional space. 	 */
name|uzp_userspace_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uma_zone
argument_list|)
operator|+
name|mp_maxid
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|uma_cache
argument_list|)
expr_stmt|;
name|uzp_userspace
operator|=
name|malloc
argument_list|(
name|uzp_userspace_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|uzp_userspace
operator|==
name|NULL
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
for|for
control|(
name|kzp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|uma_kegs
argument_list|)
init|;
name|kzp
operator|!=
name|NULL
condition|;
name|kzp
operator|=
name|LIST_NEXT
argument_list|(
operator|&
name|kz
argument_list|,
name|uk_link
argument_list|)
control|)
block|{
name|ret
operator|=
name|kread
argument_list|(
name|kvm
argument_list|,
name|kzp
argument_list|,
operator|&
name|kz
argument_list|,
sizeof|sizeof
argument_list|(
name|kz
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|uzp_userspace
argument_list|)
expr_stmt|;
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"kread: %s"
argument_list|,
name|kvm_geterr
argument_list|(
name|kvm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Keg {\n"
argument_list|)
expr_stmt|;
name|uma_print_keg_align
argument_list|(
operator|&
name|kz
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  uk_pages = %d\n"
argument_list|,
name|kz
operator|.
name|uk_pages
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  uk_free = %d\n"
argument_list|,
name|kz
operator|.
name|uk_free
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  uk_reserve = %d\n"
argument_list|,
name|kz
operator|.
name|uk_reserve
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  uk_size = %d\n"
argument_list|,
name|kz
operator|.
name|uk_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  uk_rsize = %d\n"
argument_list|,
name|kz
operator|.
name|uk_rsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  uk_maxpages = %d\n"
argument_list|,
name|kz
operator|.
name|uk_maxpages
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  uk_slabsize = %d\n"
argument_list|,
name|kz
operator|.
name|uk_slabsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  uk_pgoff = %d\n"
argument_list|,
name|kz
operator|.
name|uk_pgoff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  uk_ppera = %d\n"
argument_list|,
name|kz
operator|.
name|uk_ppera
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  uk_ipers = %d\n"
argument_list|,
name|kz
operator|.
name|uk_ipers
argument_list|)
expr_stmt|;
name|uma_print_keg_flags
argument_list|(
operator|&
name|kz
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|kz
operator|.
name|uk_zones
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"; No zones.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"};\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|uzp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|kz
operator|.
name|uk_zones
argument_list|)
init|;
name|uzp
operator|!=
name|NULL
condition|;
name|uzp
operator|=
name|LIST_NEXT
argument_list|(
name|uzp_userspace
argument_list|,
name|uz_link
argument_list|)
control|)
block|{
comment|/* 			 * We actually copy in twice: once with the base 			 * structure, so that we can then decide if we also 			 * need to copy in the caches.  This prevents us 			 * from reading past the end of the base UMA zones, 			 * which is unlikely to cause problems but could. 			 */
name|ret
operator|=
name|kread
argument_list|(
name|kvm
argument_list|,
name|uzp
argument_list|,
name|uzp_userspace
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uma_zone
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|uzp_userspace
argument_list|)
expr_stmt|;
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"kread: %s"
argument_list|,
name|kvm_geterr
argument_list|(
name|kvm
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|kz
operator|.
name|uk_flags
operator|&
name|UMA_ZFLAG_INTERNAL
operator|)
condition|)
block|{
name|ret
operator|=
name|kread
argument_list|(
name|kvm
argument_list|,
name|uzp
argument_list|,
name|uzp_userspace
argument_list|,
name|uzp_userspace_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|uzp_userspace
argument_list|)
expr_stmt|;
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"kread: %s"
argument_list|,
name|kvm_geterr
argument_list|(
name|kvm
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|kread_string
argument_list|(
name|kvm
argument_list|,
name|uzp_userspace
operator|->
name|uz_name
argument_list|,
name|name
argument_list|,
name|MEMTYPE_MAXNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|uzp_userspace
argument_list|)
expr_stmt|;
name|errx
argument_list|(
operator|-
literal|1
argument_list|,
literal|"kread_string: %s"
argument_list|,
name|kvm_geterr
argument_list|(
name|kvm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  Zone {\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    uz_name = \"%s\";\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    uz_allocs = %lu;\n"
argument_list|,
name|uzp_userspace
operator|->
name|uz_allocs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    uz_frees = %lu;\n"
argument_list|,
name|uzp_userspace
operator|->
name|uz_frees
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    uz_fails = %lu;\n"
argument_list|,
name|uzp_userspace
operator|->
name|uz_fails
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    uz_sleeps = %ju;\n"
argument_list|,
name|uzp_userspace
operator|->
name|uz_sleeps
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    uz_count = %u;\n"
argument_list|,
name|uzp_userspace
operator|->
name|uz_count
argument_list|)
expr_stmt|;
name|uma_print_bucketlist
argument_list|(
name|kvm
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|uzp_userspace
operator|->
name|uz_buckets
argument_list|,
literal|"uz_buckets"
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kz
operator|.
name|uk_flags
operator|&
name|UMA_ZFLAG_INTERNAL
operator|)
condition|)
block|{
name|ub_cnt
operator|=
name|ub_entries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<=
name|mp_maxid
condition|;
name|cpu
operator|++
control|)
block|{
comment|/* if (CPU_ABSENT(cpu)) */
if|if
condition|(
operator|(
name|all_cpus
operator|&
operator|(
literal|1
operator|<<
name|cpu
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|uma_print_cache
argument_list|(
name|kvm
argument_list|,
operator|&
name|uzp_userspace
operator|->
name|uz_cpu
index|[
name|cpu
index|]
argument_list|,
literal|"uc_cache"
argument_list|,
name|cpu
argument_list|,
literal|"    "
argument_list|,
operator|&
name|ub_cnt
argument_list|,
operator|&
name|ub_entries
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"    // %d cache total cnt, %d total "
literal|"entries\n"
argument_list|,
name|ub_cnt
argument_list|,
name|ub_entries
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|uzp_userspace
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

