begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* utility to create the register check tables  * this includes inlined list.h safe for userspace.  *  * Copyright 2009 Jerome Glisse  * Copyright 2009 Red Hat Inc.  *  * Authors:  * 	Jerome Glisse  * 	Dave Airlie  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|TYPE
parameter_list|,
name|MEMBER
parameter_list|)
value|((size_t)&((TYPE *)0)->MEMBER)
end_define

begin_comment
comment|/**  * container_of - cast a member of a structure out to the containing structure  * @ptr:    the pointer to the member.  * @type:   the type of the container struct this is embedded in.  * @member: the name of the member within the struct.  *  */
end_comment

begin_define
define|#
directive|define
name|container_of
parameter_list|(
name|ptr
parameter_list|,
name|type
parameter_list|,
name|member
parameter_list|)
value|({          \ 	const typeof(((type *)0)->member)*__mptr = (ptr);    \ 		     (type *)((char *)__mptr - offsetof(type, member)); })
end_define

begin_comment
comment|/*  * Simple doubly linked list implementation.  *  * Some of the internal functions ("__xxx") are useful when  * manipulating whole lists rather than single entries, as  * sometimes we already know the next/prev entries and we can  * generate better code by using them directly rather than  * using the generic single-entry routines.  */
end_comment

begin_struct
struct|struct
name|list_head
block|{
name|struct
name|list_head
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LIST_HEAD_INIT
parameter_list|(
name|name
parameter_list|)
value|{&(name),&(name) }
end_define

begin_define
define|#
directive|define
name|LIST_HEAD
parameter_list|(
name|name
parameter_list|)
define|\
value|struct list_head name = LIST_HEAD_INIT(name)
end_define

begin_function
specifier|static
specifier|inline
name|void
name|INIT_LIST_HEAD
parameter_list|(
name|struct
name|list_head
modifier|*
name|list
parameter_list|)
block|{
name|list
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|->
name|prev
operator|=
name|list
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert a new entry between two known consecutive entries.  *  * This is only for internal list manipulation where we know  * the prev/next entries already!  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CONFIG_DEBUG_LIST
end_ifndef

begin_function
specifier|static
specifier|inline
name|void
name|__list_add
parameter_list|(
name|struct
name|list_head
modifier|*
name|new
parameter_list|,
name|struct
name|list_head
modifier|*
name|prev
parameter_list|,
name|struct
name|list_head
modifier|*
name|next
parameter_list|)
block|{
name|next
operator|->
name|prev
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|void
name|__list_add
parameter_list|(
name|struct
name|list_head
modifier|*
name|new
parameter_list|,
name|struct
name|list_head
modifier|*
name|prev
parameter_list|,
name|struct
name|list_head
modifier|*
name|next
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * list_add - add a new entry  * @new: new entry to be added  * @head: list head to add it after  *  * Insert a new entry after the specified head.  * This is good for implementing stacks.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|list_add
parameter_list|(
name|struct
name|list_head
modifier|*
name|new
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
name|__list_add
argument_list|(
name|new
argument_list|,
name|head
argument_list|,
name|head
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * list_add_tail - add a new entry  * @new: new entry to be added  * @head: list head to add it before  *  * Insert a new entry before the specified head.  * This is useful for implementing queues.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|list_add_tail
parameter_list|(
name|struct
name|list_head
modifier|*
name|new
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
name|__list_add
argument_list|(
name|new
argument_list|,
name|head
operator|->
name|prev
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete a list entry by making the prev/next entries  * point to each other.  *  * This is only for internal list manipulation where we know  * the prev/next entries already!  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__list_del
parameter_list|(
name|struct
name|list_head
modifier|*
name|prev
parameter_list|,
name|struct
name|list_head
modifier|*
name|next
parameter_list|)
block|{
name|next
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * list_del - deletes entry from list.  * @entry: the element to delete from the list.  * Note: list_empty() on entry does not return true after this, the entry is  * in an undefined state.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CONFIG_DEBUG_LIST
end_ifndef

begin_function
specifier|static
specifier|inline
name|void
name|list_del
parameter_list|(
name|struct
name|list_head
modifier|*
name|entry
parameter_list|)
block|{
name|__list_del
argument_list|(
name|entry
operator|->
name|prev
argument_list|,
name|entry
operator|->
name|next
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
operator|(
name|void
operator|*
operator|)
literal|0xDEADBEEF
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
operator|(
name|void
operator|*
operator|)
literal|0xBEEFDEAD
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|void
name|list_del
parameter_list|(
name|struct
name|list_head
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * list_replace - replace old entry by new one  * @old : the element to be replaced  * @new : the new element to insert  *  * If @old was empty, it will be overwritten.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|list_replace
parameter_list|(
name|struct
name|list_head
modifier|*
name|old
parameter_list|,
name|struct
name|list_head
modifier|*
name|new
parameter_list|)
block|{
name|new
operator|->
name|next
operator|=
name|old
operator|->
name|next
expr_stmt|;
name|new
operator|->
name|next
operator|->
name|prev
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|old
operator|->
name|prev
expr_stmt|;
name|new
operator|->
name|prev
operator|->
name|next
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|list_replace_init
parameter_list|(
name|struct
name|list_head
modifier|*
name|old
parameter_list|,
name|struct
name|list_head
modifier|*
name|new
parameter_list|)
block|{
name|list_replace
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * list_del_init - deletes entry from list and reinitialize it.  * @entry: the element to delete from the list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|list_del_init
parameter_list|(
name|struct
name|list_head
modifier|*
name|entry
parameter_list|)
block|{
name|__list_del
argument_list|(
name|entry
operator|->
name|prev
argument_list|,
name|entry
operator|->
name|next
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * list_move - delete from one list and add as another's head  * @list: the entry to move  * @head: the head that will precede our entry  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|list_move
parameter_list|(
name|struct
name|list_head
modifier|*
name|list
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
name|__list_del
argument_list|(
name|list
operator|->
name|prev
argument_list|,
name|list
operator|->
name|next
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
name|list
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * list_move_tail - delete from one list and add as another's tail  * @list: the entry to move  * @head: the head that will follow our entry  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|list_move_tail
parameter_list|(
name|struct
name|list_head
modifier|*
name|list
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
name|__list_del
argument_list|(
name|list
operator|->
name|prev
argument_list|,
name|list
operator|->
name|next
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
name|list
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * list_is_last - tests whether @list is the last entry in list @head  * @list: the entry to test  * @head: the head of the list  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|list_is_last
parameter_list|(
specifier|const
name|struct
name|list_head
modifier|*
name|list
parameter_list|,
specifier|const
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
return|return
name|list
operator|->
name|next
operator|==
name|head
return|;
block|}
end_function

begin_comment
comment|/**  * list_empty - tests whether a list is empty  * @head: the list to test.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|list_empty
parameter_list|(
specifier|const
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
return|return
name|head
operator|->
name|next
operator|==
name|head
return|;
block|}
end_function

begin_comment
comment|/**  * list_empty_careful - tests whether a list is empty and not being modified  * @head: the list to test  *  * Description:  * tests whether a list is empty _and_ checks that no other CPU might be  * in the process of modifying either member (next or prev)  *  * NOTE: using list_empty_careful() without synchronization  * can only be safe if the only activity that can happen  * to the list entry is list_del_init(). Eg. it cannot be used  * if another CPU could re-list_add() it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|list_empty_careful
parameter_list|(
specifier|const
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|list_head
modifier|*
name|next
init|=
name|head
operator|->
name|next
decl_stmt|;
return|return
operator|(
name|next
operator|==
name|head
operator|)
operator|&&
operator|(
name|next
operator|==
name|head
operator|->
name|prev
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * list_is_singular - tests whether a list has just one entry.  * @head: the list to test.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|list_is_singular
parameter_list|(
specifier|const
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
return|return
operator|!
name|list_empty
argument_list|(
name|head
argument_list|)
operator|&&
operator|(
name|head
operator|->
name|next
operator|==
name|head
operator|->
name|prev
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|__list_cut_position
parameter_list|(
name|struct
name|list_head
modifier|*
name|list
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|,
name|struct
name|list_head
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|list_head
modifier|*
name|new_first
init|=
name|entry
operator|->
name|next
decl_stmt|;
name|list
operator|->
name|next
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|list
operator|->
name|next
operator|->
name|prev
operator|=
name|list
expr_stmt|;
name|list
operator|->
name|prev
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|new_first
expr_stmt|;
name|new_first
operator|->
name|prev
operator|=
name|head
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * list_cut_position - cut a list into two  * @list: a new list to add all removed entries  * @head: a list with entries  * @entry: an entry within head, could be the head itself  *	and if so we won't cut the list  *  * This helper moves the initial part of @head, up to and  * including @entry, from @head to @list. You should  * pass on @entry an element you know is on @head. @list  * should be an empty list or a list you do not care about  * losing its data.  *  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|list_cut_position
parameter_list|(
name|struct
name|list_head
modifier|*
name|list
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|,
name|struct
name|list_head
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|list_empty
argument_list|(
name|head
argument_list|)
condition|)
return|return;
if|if
condition|(
name|list_is_singular
argument_list|(
name|head
argument_list|)
operator|&&
operator|(
name|head
operator|->
name|next
operator|!=
name|entry
operator|&&
name|head
operator|!=
name|entry
operator|)
condition|)
return|return;
if|if
condition|(
name|entry
operator|==
name|head
condition|)
name|INIT_LIST_HEAD
argument_list|(
name|list
argument_list|)
expr_stmt|;
else|else
name|__list_cut_position
argument_list|(
name|list
argument_list|,
name|head
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|__list_splice
parameter_list|(
specifier|const
name|struct
name|list_head
modifier|*
name|list
parameter_list|,
name|struct
name|list_head
modifier|*
name|prev
parameter_list|,
name|struct
name|list_head
modifier|*
name|next
parameter_list|)
block|{
name|struct
name|list_head
modifier|*
name|first
init|=
name|list
operator|->
name|next
decl_stmt|;
name|struct
name|list_head
modifier|*
name|last
init|=
name|list
operator|->
name|prev
decl_stmt|;
name|first
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|first
expr_stmt|;
name|last
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|next
operator|->
name|prev
operator|=
name|last
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * list_splice - join two lists, this is designed for stacks  * @list: the new list to add.  * @head: the place to add it in the first list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|list_splice
parameter_list|(
specifier|const
name|struct
name|list_head
modifier|*
name|list
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
if|if
condition|(
operator|!
name|list_empty
argument_list|(
name|list
argument_list|)
condition|)
name|__list_splice
argument_list|(
name|list
argument_list|,
name|head
argument_list|,
name|head
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * list_splice_tail - join two lists, each list being a queue  * @list: the new list to add.  * @head: the place to add it in the first list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|list_splice_tail
parameter_list|(
name|struct
name|list_head
modifier|*
name|list
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
if|if
condition|(
operator|!
name|list_empty
argument_list|(
name|list
argument_list|)
condition|)
name|__list_splice
argument_list|(
name|list
argument_list|,
name|head
operator|->
name|prev
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * list_splice_init - join two lists and reinitialise the emptied list.  * @list: the new list to add.  * @head: the place to add it in the first list.  *  * The list at @list is reinitialised  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|list_splice_init
parameter_list|(
name|struct
name|list_head
modifier|*
name|list
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
if|if
condition|(
operator|!
name|list_empty
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|__list_splice
argument_list|(
name|list
argument_list|,
name|head
argument_list|,
name|head
operator|->
name|next
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * list_splice_tail_init - join two lists and reinitialise the emptied list  * @list: the new list to add.  * @head: the place to add it in the first list.  *  * Each of the lists is a queue.  * The list at @list is reinitialised  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|list_splice_tail_init
parameter_list|(
name|struct
name|list_head
modifier|*
name|list
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
if|if
condition|(
operator|!
name|list_empty
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|__list_splice
argument_list|(
name|list
argument_list|,
name|head
operator|->
name|prev
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * list_entry - get the struct for this entry  * @ptr:	the&struct list_head pointer.  * @type:	the type of the struct this is embedded in.  * @member:	the name of the list_struct within the struct.  */
end_comment

begin_define
define|#
directive|define
name|list_entry
parameter_list|(
name|ptr
parameter_list|,
name|type
parameter_list|,
name|member
parameter_list|)
define|\
value|container_of(ptr, type, member)
end_define

begin_comment
comment|/**  * list_first_entry - get the first element from a list  * @ptr:	the list head to take the element from.  * @type:	the type of the struct this is embedded in.  * @member:	the name of the list_struct within the struct.  *  * Note, that list is expected to be not empty.  */
end_comment

begin_define
define|#
directive|define
name|list_first_entry
parameter_list|(
name|ptr
parameter_list|,
name|type
parameter_list|,
name|member
parameter_list|)
define|\
value|list_entry((ptr)->next, type, member)
end_define

begin_comment
comment|/**  * list_for_each	-	iterate over a list  * @pos:	the&struct list_head to use as a loop cursor.  * @head:	the head for your list.  */
end_comment

begin_define
define|#
directive|define
name|list_for_each
parameter_list|(
name|pos
parameter_list|,
name|head
parameter_list|)
define|\
value|for (pos = (head)->next; prefetch(pos->next), pos != (head); \ 		pos = pos->next)
end_define

begin_comment
comment|/**  * __list_for_each	-	iterate over a list  * @pos:	the&struct list_head to use as a loop cursor.  * @head:	the head for your list.  *  * This variant differs from list_for_each() in that it's the  * simplest possible list iteration code, no prefetching is done.  * Use this for code that knows the list to be very short (empty  * or 1 entry) most of the time.  */
end_comment

begin_define
define|#
directive|define
name|__list_for_each
parameter_list|(
name|pos
parameter_list|,
name|head
parameter_list|)
define|\
value|for (pos = (head)->next; pos != (head); pos = pos->next)
end_define

begin_comment
comment|/**  * list_for_each_prev	-	iterate over a list backwards  * @pos:	the&struct list_head to use as a loop cursor.  * @head:	the head for your list.  */
end_comment

begin_define
define|#
directive|define
name|list_for_each_prev
parameter_list|(
name|pos
parameter_list|,
name|head
parameter_list|)
define|\
value|for (pos = (head)->prev; prefetch(pos->prev), pos != (head); \ 		pos = pos->prev)
end_define

begin_comment
comment|/**  * list_for_each_safe - iterate over a list safe against removal of list entry  * @pos:	the&struct list_head to use as a loop cursor.  * @n:		another&struct list_head to use as temporary storage  * @head:	the head for your list.  */
end_comment

begin_define
define|#
directive|define
name|list_for_each_safe
parameter_list|(
name|pos
parameter_list|,
name|n
parameter_list|,
name|head
parameter_list|)
define|\
value|for (pos = (head)->next, n = pos->next; pos != (head); \ 		pos = n, n = pos->next)
end_define

begin_comment
comment|/**  * list_for_each_prev_safe - iterate over a list backwards safe against removal of list entry  * @pos:	the&struct list_head to use as a loop cursor.  * @n:		another&struct list_head to use as temporary storage  * @head:	the head for your list.  */
end_comment

begin_define
define|#
directive|define
name|list_for_each_prev_safe
parameter_list|(
name|pos
parameter_list|,
name|n
parameter_list|,
name|head
parameter_list|)
define|\
value|for (pos = (head)->prev, n = pos->prev; \ 	     prefetch(pos->prev), pos != (head); \ 	     pos = n, n = pos->prev)
end_define

begin_comment
comment|/**  * list_for_each_entry	-	iterate over list of given type  * @pos:	the type * to use as a loop cursor.  * @head:	the head for your list.  * @member:	the name of the list_struct within the struct.  */
end_comment

begin_define
define|#
directive|define
name|list_for_each_entry
parameter_list|(
name|pos
parameter_list|,
name|head
parameter_list|,
name|member
parameter_list|)
define|\
value|for (pos = list_entry((head)->next, typeof(*pos), member);	\&pos->member != (head); 	\ 	     pos = list_entry(pos->member.next, typeof(*pos), member))
end_define

begin_comment
comment|/**  * list_for_each_entry_reverse - iterate backwards over list of given type.  * @pos:	the type * to use as a loop cursor.  * @head:	the head for your list.  * @member:	the name of the list_struct within the struct.  */
end_comment

begin_define
define|#
directive|define
name|list_for_each_entry_reverse
parameter_list|(
name|pos
parameter_list|,
name|head
parameter_list|,
name|member
parameter_list|)
define|\
value|for (pos = list_entry((head)->prev, typeof(*pos), member);	\ 	     prefetch(pos->member.prev),&pos->member != (head); 	\ 	     pos = list_entry(pos->member.prev, typeof(*pos), member))
end_define

begin_comment
comment|/**  * list_prepare_entry - prepare a pos entry for use in list_for_each_entry_continue()  * @pos:	the type * to use as a start point  * @head:	the head of the list  * @member:	the name of the list_struct within the struct.  *  * Prepares a pos entry for use as a start point in list_for_each_entry_continue().  */
end_comment

begin_define
define|#
directive|define
name|list_prepare_entry
parameter_list|(
name|pos
parameter_list|,
name|head
parameter_list|,
name|member
parameter_list|)
define|\
value|((pos) ? : list_entry(head, typeof(*pos), member))
end_define

begin_comment
comment|/**  * list_for_each_entry_continue - continue iteration over list of given type  * @pos:	the type * to use as a loop cursor.  * @head:	the head for your list.  * @member:	the name of the list_struct within the struct.  *  * Continue to iterate over list of given type, continuing after  * the current position.  */
end_comment

begin_define
define|#
directive|define
name|list_for_each_entry_continue
parameter_list|(
name|pos
parameter_list|,
name|head
parameter_list|,
name|member
parameter_list|)
define|\
value|for (pos = list_entry(pos->member.next, typeof(*pos), member);	\ 	     prefetch(pos->member.next),&pos->member != (head);	\ 	     pos = list_entry(pos->member.next, typeof(*pos), member))
end_define

begin_comment
comment|/**  * list_for_each_entry_continue_reverse - iterate backwards from the given point  * @pos:	the type * to use as a loop cursor.  * @head:	the head for your list.  * @member:	the name of the list_struct within the struct.  *  * Start to iterate over list of given type backwards, continuing after  * the current position.  */
end_comment

begin_define
define|#
directive|define
name|list_for_each_entry_continue_reverse
parameter_list|(
name|pos
parameter_list|,
name|head
parameter_list|,
name|member
parameter_list|)
define|\
value|for (pos = list_entry(pos->member.prev, typeof(*pos), member);	\ 	     prefetch(pos->member.prev),&pos->member != (head);	\ 	     pos = list_entry(pos->member.prev, typeof(*pos), member))
end_define

begin_comment
comment|/**  * list_for_each_entry_from - iterate over list of given type from the current point  * @pos:	the type * to use as a loop cursor.  * @head:	the head for your list.  * @member:	the name of the list_struct within the struct.  *  * Iterate over list of given type, continuing from current position.  */
end_comment

begin_define
define|#
directive|define
name|list_for_each_entry_from
parameter_list|(
name|pos
parameter_list|,
name|head
parameter_list|,
name|member
parameter_list|)
define|\
value|for (; prefetch(pos->member.next),&pos->member != (head);	\ 	     pos = list_entry(pos->member.next, typeof(*pos), member))
end_define

begin_comment
comment|/**  * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry  * @pos:	the type * to use as a loop cursor.  * @n:		another type * to use as temporary storage  * @head:	the head for your list.  * @member:	the name of the list_struct within the struct.  */
end_comment

begin_define
define|#
directive|define
name|list_for_each_entry_safe
parameter_list|(
name|pos
parameter_list|,
name|n
parameter_list|,
name|head
parameter_list|,
name|member
parameter_list|)
define|\
value|for (pos = list_entry((head)->next, typeof(*pos), member),	\ 		n = list_entry(pos->member.next, typeof(*pos), member);	\&pos->member != (head); 					\ 	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
end_define

begin_comment
comment|/**  * list_for_each_entry_safe_continue  * @pos:	the type * to use as a loop cursor.  * @n:		another type * to use as temporary storage  * @head:	the head for your list.  * @member:	the name of the list_struct within the struct.  *  * Iterate over list of given type, continuing after current point,  * safe against removal of list entry.  */
end_comment

begin_define
define|#
directive|define
name|list_for_each_entry_safe_continue
parameter_list|(
name|pos
parameter_list|,
name|n
parameter_list|,
name|head
parameter_list|,
name|member
parameter_list|)
define|\
value|for (pos = list_entry(pos->member.next, typeof(*pos), member), 		\ 		n = list_entry(pos->member.next, typeof(*pos), member);		\&pos->member != (head);						\ 	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
end_define

begin_comment
comment|/**  * list_for_each_entry_safe_from  * @pos:	the type * to use as a loop cursor.  * @n:		another type * to use as temporary storage  * @head:	the head for your list.  * @member:	the name of the list_struct within the struct.  *  * Iterate over list of given type from current point, safe against  * removal of list entry.  */
end_comment

begin_define
define|#
directive|define
name|list_for_each_entry_safe_from
parameter_list|(
name|pos
parameter_list|,
name|n
parameter_list|,
name|head
parameter_list|,
name|member
parameter_list|)
define|\
value|for (n = list_entry(pos->member.next, typeof(*pos), member);		\&pos->member != (head);						\ 	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
end_define

begin_comment
comment|/**  * list_for_each_entry_safe_reverse  * @pos:	the type * to use as a loop cursor.  * @n:		another type * to use as temporary storage  * @head:	the head for your list.  * @member:	the name of the list_struct within the struct.  *  * Iterate backwards over list of given type, safe against removal  * of list entry.  */
end_comment

begin_define
define|#
directive|define
name|list_for_each_entry_safe_reverse
parameter_list|(
name|pos
parameter_list|,
name|n
parameter_list|,
name|head
parameter_list|,
name|member
parameter_list|)
define|\
value|for (pos = list_entry((head)->prev, typeof(*pos), member),	\ 		n = list_entry(pos->member.prev, typeof(*pos), member);	\&pos->member != (head); 					\ 	     pos = n, n = list_entry(n->member.prev, typeof(*n), member))
end_define

begin_struct
struct|struct
name|offset
block|{
name|struct
name|list_head
name|list
decl_stmt|;
name|unsigned
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|table
block|{
name|struct
name|list_head
name|offsets
decl_stmt|;
name|unsigned
name|offset_max
decl_stmt|;
name|unsigned
name|nentry
decl_stmt|;
name|unsigned
modifier|*
name|table
decl_stmt|;
name|char
modifier|*
name|gpu_prefix
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|offset
modifier|*
name|offset_new
parameter_list|(
name|unsigned
name|o
parameter_list|)
block|{
name|struct
name|offset
modifier|*
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
expr|struct
name|offset
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|offset
operator|->
name|list
argument_list|)
expr_stmt|;
name|offset
operator|->
name|offset
operator|=
name|o
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|table_offset_add
parameter_list|(
name|struct
name|table
modifier|*
name|t
parameter_list|,
name|struct
name|offset
modifier|*
name|offset
parameter_list|)
block|{
name|list_add_tail
argument_list|(
operator|&
name|offset
operator|->
name|list
argument_list|,
operator|&
name|t
operator|->
name|offsets
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|table_init
parameter_list|(
name|struct
name|table
modifier|*
name|t
parameter_list|)
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|t
operator|->
name|offsets
argument_list|)
expr_stmt|;
name|t
operator|->
name|offset_max
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|nentry
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|table
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|table_print
parameter_list|(
name|struct
name|table
modifier|*
name|t
parameter_list|)
block|{
name|unsigned
name|nlloop
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|,
name|c
decl_stmt|,
name|id
decl_stmt|;
name|nlloop
operator|=
operator|(
name|t
operator|->
name|nentry
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|c
operator|=
name|t
operator|->
name|nentry
expr_stmt|;
name|printf
argument_list|(
literal|"#include<sys/cdefs.h>\n"
literal|"__FBSDID(\"$"
literal|"FreeBSD"
literal|"$\");\n"
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"static const unsigned %s_reg_safe_bm[%d] = {\n"
argument_list|,
name|t
operator|->
name|gpu_prefix
argument_list|,
name|t
operator|->
name|nentry
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|id
operator|=
literal|0
init|;
name|i
operator|<
name|nlloop
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|c
condition|)
name|n
operator|=
name|c
expr_stmt|;
name|c
operator|-=
name|n
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%08X,"
argument_list|,
name|t
operator|->
name|table
index|[
name|id
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|table_build
parameter_list|(
name|struct
name|table
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|offset
modifier|*
name|offset
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|m
decl_stmt|;
name|t
operator|->
name|nentry
operator|=
operator|(
operator|(
name|t
operator|->
name|offset_max
operator|>>
literal|2
operator|)
operator|+
literal|31
operator|)
operator|/
literal|32
expr_stmt|;
name|t
operator|->
name|table
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
name|t
operator|->
name|nentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|table
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|t
operator|->
name|table
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
name|t
operator|->
name|nentry
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|offset
argument_list|,
argument|&t->offsets
argument_list|,
argument|list
argument_list|)
block|{
name|i
operator|=
operator|(
name|offset
operator|->
name|offset
operator|>>
literal|2
operator|)
operator|/
literal|32
expr_stmt|;
name|m
operator|=
operator|(
name|offset
operator|->
name|offset
operator|>>
literal|2
operator|)
operator|&
literal|31
expr_stmt|;
name|m
operator|=
literal|1
operator|<<
name|m
expr_stmt|;
name|t
operator|->
name|table
index|[
name|i
index|]
operator|^=
name|m
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|gpu_name
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|parser_auth
parameter_list|(
name|struct
name|table
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|regex_t
name|mask_rex
decl_stmt|;
name|regmatch_t
name|match
index|[
literal|4
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|size_t
name|end
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
name|unsigned
name|o
decl_stmt|;
name|struct
name|offset
modifier|*
name|offset
decl_stmt|;
name|char
name|last_reg_s
index|[
literal|10
index|]
decl_stmt|;
name|int
name|last_reg
decl_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
operator|&
name|mask_rex
argument_list|,
literal|"(0x[0-9a-fA-F]*) *([_a-zA-Z0-9]*)"
argument_list|,
name|REG_EXTENDED
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to compile regular expression\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to open: %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fseek
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|end
operator|=
name|ftell
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* get header */
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
literal|1024
argument_list|,
name|file
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* first line will contain the last register 	 * and gpu name */
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|gpu_name
argument_list|,
name|last_reg_s
argument_list|)
expr_stmt|;
name|t
operator|->
name|gpu_prefix
operator|=
name|gpu_name
expr_stmt|;
name|last_reg
operator|=
name|strtol
argument_list|(
name|last_reg_s
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
literal|1024
argument_list|,
name|file
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftell
argument_list|(
name|file
argument_list|)
operator|==
name|end
condition|)
name|done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|r
operator|=
name|regexec
argument_list|(
operator|&
name|mask_rex
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|,
name|match
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|REG_NOMATCH
condition|)
block|{ 			}
elseif|else
if|if
condition|(
name|r
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error matching regular expression %d in %s\n"
argument_list|,
name|r
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|buf
index|[
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
name|match
index|[
literal|1
index|]
operator|.
name|rm_eo
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
name|match
index|[
literal|2
index|]
operator|.
name|rm_eo
index|]
operator|=
literal|0
expr_stmt|;
name|o
operator|=
name|strtol
argument_list|(
operator|&
name|buf
index|[
name|match
index|[
literal|1
index|]
operator|.
name|rm_so
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|offset
operator|=
name|offset_new
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|table_offset_add
argument_list|(
name|t
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|>
name|t
operator|->
name|offset_max
condition|)
name|t
operator|->
name|offset_max
operator|=
name|o
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|offset_max
operator|<
name|last_reg
condition|)
name|t
operator|->
name|offset_max
operator|=
name|last_reg
expr_stmt|;
return|return
name|table_build
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|table
name|t
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s<authfile>\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|table_init
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser_auth
argument_list|(
operator|&
name|t
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to parse file %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|table_print
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

