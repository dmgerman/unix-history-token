begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* -*- coding: utf-8 -*- //                     The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. */
end_comment

begin_comment
comment|/**  * This file implements a shared library. This library can be pre-loaded by  * the dynamic linker of the Operating System (OS). It implements a few function  * related to process creation. By pre-load this library the executed process  * uses these functions instead of those from the standard library.  *  * The idea here is to inject a logic before call the real methods. The logic is  * to dump the call into a file. To call the real method this library is doing  * the job of the dynamic linker.  *  * The only input for the log writing is about the destination directory.  * This is passed as environment variable.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_if
if|#
directive|if
name|defined
name|HAVE_POSIX_SPAWN
operator|||
name|defined
name|HAVE_POSIX_SPAWNP
end_if

begin_include
include|#
directive|include
file|<spawn.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|HAVE_NSGETENVIRON
end_if

begin_include
include|#
directive|include
file|<crt_externs.h>
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ENV_OUTPUT
value|"INTERCEPT_BUILD_TARGET_DIR"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|APPLE
end_ifdef

begin_define
define|#
directive|define
name|ENV_FLAT
value|"DYLD_FORCE_FLAT_NAMESPACE"
end_define

begin_define
define|#
directive|define
name|ENV_PRELOAD
value|"DYLD_INSERT_LIBRARIES"
end_define

begin_define
define|#
directive|define
name|ENV_SIZE
value|3
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ENV_PRELOAD
value|"LD_PRELOAD"
end_define

begin_define
define|#
directive|define
name|ENV_SIZE
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DLSYM
parameter_list|(
name|TYPE_
parameter_list|,
name|VAR_
parameter_list|,
name|SYMBOL_
parameter_list|)
define|\
value|union {                                                                    \         void *from;                                                            \         TYPE_ to;                                                              \     } cast;                                                                    \     if (0 == (cast.from = dlsym(RTLD_NEXT, SYMBOL_))) {                        \         perror("bear: dlsym");                                                 \         exit(EXIT_FAILURE);                                                    \     }                                                                          \     TYPE_ const VAR_ = cast.to;
end_define

begin_typedef
typedef|typedef
name|char
specifier|const
modifier|*
name|bear_env_t
index|[
name|ENV_SIZE
index|]
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|bear_capture_env_t
parameter_list|(
name|bear_env_t
modifier|*
name|env
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bear_reset_env_t
parameter_list|(
name|bear_env_t
modifier|*
name|env
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bear_release_env_t
parameter_list|(
name|bear_env_t
modifier|*
name|env
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|bear_update_environment
parameter_list|(
name|char
modifier|*
specifier|const
name|envp
index|[]
parameter_list|,
name|bear_env_t
modifier|*
name|env
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|bear_update_environ
parameter_list|(
name|char
specifier|const
modifier|*
modifier|*
name|in
parameter_list|,
name|char
specifier|const
modifier|*
name|key
parameter_list|,
name|char
specifier|const
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
modifier|*
name|bear_get_environment
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bear_report_call
parameter_list|(
name|char
specifier|const
modifier|*
name|fun
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|bear_strings_build
parameter_list|(
name|char
specifier|const
modifier|*
name|arg
parameter_list|,
name|va_list
modifier|*
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|bear_strings_copy
parameter_list|(
name|char
specifier|const
modifier|*
modifier|*
specifier|const
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|bear_strings_append
parameter_list|(
name|char
specifier|const
modifier|*
modifier|*
name|in
parameter_list|,
name|char
specifier|const
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|bear_strings_length
parameter_list|(
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bear_strings_release
parameter_list|(
name|char
specifier|const
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|bear_env_t
name|env_names
init|=
block|{
name|ENV_OUTPUT
block|,
name|ENV_PRELOAD
ifdef|#
directive|ifdef
name|ENV_FLAT
block|,
name|ENV_FLAT
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bear_env_t
name|initial_env
init|=
block|{
literal|0
block|,
literal|0
ifdef|#
directive|ifdef
name|ENV_FLAT
block|,
literal|0
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|mutex
init|=
name|PTHREAD_MUTEX_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|on_load
parameter_list|(
name|void
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(constructor
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|on_unload
parameter_list|(
name|void
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(destructor
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVE
end_ifdef

begin_function_decl
specifier|static
name|int
name|call_execve
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVP
end_ifdef

begin_function_decl
specifier|static
name|int
name|call_execvp
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVPE
end_ifdef

begin_function_decl
specifier|static
name|int
name|call_execvpe
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVP2
end_ifdef

begin_function_decl
specifier|static
name|int
name|call_execvP
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|search_path
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECT
end_ifdef

begin_function_decl
specifier|static
name|int
name|call_exect
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POSIX_SPAWN
end_ifdef

begin_function_decl
specifier|static
name|int
name|call_posix_spawn
parameter_list|(
name|pid_t
modifier|*
specifier|restrict
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
specifier|restrict
name|path
parameter_list|,
specifier|const
name|posix_spawn_file_actions_t
modifier|*
name|file_actions
parameter_list|,
specifier|const
name|posix_spawnattr_t
modifier|*
specifier|restrict
name|attrp
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[
specifier|restrict
index|]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[
specifier|restrict
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POSIX_SPAWNP
end_ifdef

begin_function_decl
specifier|static
name|int
name|call_posix_spawnp
parameter_list|(
name|pid_t
modifier|*
specifier|restrict
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
specifier|restrict
name|file
parameter_list|,
specifier|const
name|posix_spawn_file_actions_t
modifier|*
name|file_actions
parameter_list|,
specifier|const
name|posix_spawnattr_t
modifier|*
specifier|restrict
name|attrp
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[
specifier|restrict
index|]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[
specifier|restrict
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialization method to Captures the relevant environment variables.  */
end_comment

begin_function
specifier|static
name|void
name|on_load
parameter_list|(
name|void
parameter_list|)
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
name|initialized
operator|=
name|bear_capture_env_t
argument_list|(
operator|&
name|initial_env
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|on_unload
parameter_list|(
name|void
parameter_list|)
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|bear_release_env_t
argument_list|(
operator|&
name|initial_env
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These are the methods we are try to hijack.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVE
end_ifdef

begin_function
name|int
name|execve
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[]
parameter_list|)
block|{
name|bear_report_call
argument_list|(
name|__func__
argument_list|,
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|call_execve
argument_list|(
name|path
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECV
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_EXECVE
end_ifndef

begin_error
error|#
directive|error
error|can not implement execv without execve
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|execv
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|)
block|{
name|bear_report_call
argument_list|(
name|__func__
argument_list|,
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|envp
init|=
name|bear_get_environment
argument_list|()
decl_stmt|;
return|return
name|call_execve
argument_list|(
name|path
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVPE
end_ifdef

begin_function
name|int
name|execvpe
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[]
parameter_list|)
block|{
name|bear_report_call
argument_list|(
name|__func__
argument_list|,
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|call_execvpe
argument_list|(
name|file
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVP
end_ifdef

begin_function
name|int
name|execvp
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|)
block|{
name|bear_report_call
argument_list|(
name|__func__
argument_list|,
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|call_execvp
argument_list|(
name|file
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVP2
end_ifdef

begin_function
name|int
name|execvP
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|search_path
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|)
block|{
name|bear_report_call
argument_list|(
name|__func__
argument_list|,
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|call_execvP
argument_list|(
name|file
argument_list|,
name|search_path
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECT
end_ifdef

begin_function
name|int
name|exect
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[]
parameter_list|)
block|{
name|bear_report_call
argument_list|(
name|__func__
argument_list|,
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|call_exect
argument_list|(
name|path
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECL
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_EXECVE
end_ifndef

begin_error
error|#
directive|error
error|can not implement execl without execve
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|execl
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|argv
init|=
name|bear_strings_build
argument_list|(
name|arg
argument_list|,
operator|&
name|args
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|bear_report_call
argument_list|(
name|__func__
argument_list|,
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|envp
init|=
name|bear_get_environment
argument_list|()
decl_stmt|;
name|int
specifier|const
name|result
init|=
name|call_execve
argument_list|(
name|path
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|,
name|envp
argument_list|)
decl_stmt|;
name|bear_strings_release
argument_list|(
name|argv
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECLP
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_EXECVP
end_ifndef

begin_error
error|#
directive|error
error|can not implement execlp without execvp
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|execlp
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|argv
init|=
name|bear_strings_build
argument_list|(
name|arg
argument_list|,
operator|&
name|args
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|bear_report_call
argument_list|(
name|__func__
argument_list|,
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
name|int
specifier|const
name|result
init|=
name|call_execvp
argument_list|(
name|file
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|)
decl_stmt|;
name|bear_strings_release
argument_list|(
name|argv
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECLE
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_EXECVE
end_ifndef

begin_error
error|#
directive|error
error|can not implement execle without execve
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// int execle(const char *path, const char *arg, ..., char * const envp[]);
end_comment

begin_function
name|int
name|execle
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|argv
init|=
name|bear_strings_build
argument_list|(
name|arg
argument_list|,
operator|&
name|args
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|envp
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
specifier|const
operator|*
operator|*
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|bear_report_call
argument_list|(
name|__func__
argument_list|,
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
name|int
specifier|const
name|result
init|=
name|call_execve
argument_list|(
name|path
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|envp
argument_list|)
decl_stmt|;
name|bear_strings_release
argument_list|(
name|argv
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POSIX_SPAWN
end_ifdef

begin_function
name|int
name|posix_spawn
parameter_list|(
name|pid_t
modifier|*
specifier|restrict
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
specifier|restrict
name|path
parameter_list|,
specifier|const
name|posix_spawn_file_actions_t
modifier|*
name|file_actions
parameter_list|,
specifier|const
name|posix_spawnattr_t
modifier|*
specifier|restrict
name|attrp
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[
specifier|restrict
index|]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[
specifier|restrict
index|]
parameter_list|)
block|{
name|bear_report_call
argument_list|(
name|__func__
argument_list|,
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|call_posix_spawn
argument_list|(
name|pid
argument_list|,
name|path
argument_list|,
name|file_actions
argument_list|,
name|attrp
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POSIX_SPAWNP
end_ifdef

begin_function
name|int
name|posix_spawnp
parameter_list|(
name|pid_t
modifier|*
specifier|restrict
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
specifier|restrict
name|file
parameter_list|,
specifier|const
name|posix_spawn_file_actions_t
modifier|*
name|file_actions
parameter_list|,
specifier|const
name|posix_spawnattr_t
modifier|*
specifier|restrict
name|attrp
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[
specifier|restrict
index|]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[
specifier|restrict
index|]
parameter_list|)
block|{
name|bear_report_call
argument_list|(
name|__func__
argument_list|,
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
return|return
name|call_posix_spawnp
argument_list|(
name|pid
argument_list|,
name|file
argument_list|,
name|file_actions
argument_list|,
name|attrp
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These are the methods which forward the call to the standard implementation.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVE
end_ifdef

begin_function
specifier|static
name|int
name|call_execve
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[]
parameter_list|)
block|{
typedef|typedef
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
name|DLSYM
argument_list|(
name|func
argument_list|,
name|fp
argument_list|,
literal|"execve"
argument_list|)
expr_stmt|;
name|char
specifier|const
modifier|*
modifier|*
specifier|const
name|menvp
init|=
name|bear_update_environment
argument_list|(
name|envp
argument_list|,
operator|&
name|initial_env
argument_list|)
decl_stmt|;
name|int
specifier|const
name|result
init|=
call|(
modifier|*
name|fp
call|)
argument_list|(
name|path
argument_list|,
name|argv
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|menvp
argument_list|)
decl_stmt|;
name|bear_strings_release
argument_list|(
name|menvp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVPE
end_ifdef

begin_function
specifier|static
name|int
name|call_execvpe
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[]
parameter_list|)
block|{
typedef|typedef
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
name|DLSYM
argument_list|(
name|func
argument_list|,
name|fp
argument_list|,
literal|"execvpe"
argument_list|)
expr_stmt|;
name|char
specifier|const
modifier|*
modifier|*
specifier|const
name|menvp
init|=
name|bear_update_environment
argument_list|(
name|envp
argument_list|,
operator|&
name|initial_env
argument_list|)
decl_stmt|;
name|int
specifier|const
name|result
init|=
call|(
modifier|*
name|fp
call|)
argument_list|(
name|file
argument_list|,
name|argv
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|menvp
argument_list|)
decl_stmt|;
name|bear_strings_release
argument_list|(
name|menvp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVP
end_ifdef

begin_function
specifier|static
name|int
name|call_execvp
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|)
block|{
typedef|typedef
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|)
function_decl|;
name|DLSYM
argument_list|(
name|func
argument_list|,
name|fp
argument_list|,
literal|"execvp"
argument_list|)
expr_stmt|;
name|bear_env_t
name|current_env
decl_stmt|;
name|bear_capture_env_t
argument_list|(
operator|&
name|current_env
argument_list|)
expr_stmt|;
name|bear_reset_env_t
argument_list|(
operator|&
name|initial_env
argument_list|)
expr_stmt|;
name|int
specifier|const
name|result
init|=
call|(
modifier|*
name|fp
call|)
argument_list|(
name|file
argument_list|,
name|argv
argument_list|)
decl_stmt|;
name|bear_reset_env_t
argument_list|(
operator|&
name|current_env
argument_list|)
expr_stmt|;
name|bear_release_env_t
argument_list|(
operator|&
name|current_env
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVP2
end_ifdef

begin_function
specifier|static
name|int
name|call_execvP
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|search_path
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|)
block|{
typedef|typedef
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
name|DLSYM
argument_list|(
name|func
argument_list|,
name|fp
argument_list|,
literal|"execvP"
argument_list|)
expr_stmt|;
name|bear_env_t
name|current_env
decl_stmt|;
name|bear_capture_env_t
argument_list|(
operator|&
name|current_env
argument_list|)
expr_stmt|;
name|bear_reset_env_t
argument_list|(
operator|&
name|initial_env
argument_list|)
expr_stmt|;
name|int
specifier|const
name|result
init|=
call|(
modifier|*
name|fp
call|)
argument_list|(
name|file
argument_list|,
name|search_path
argument_list|,
name|argv
argument_list|)
decl_stmt|;
name|bear_reset_env_t
argument_list|(
operator|&
name|current_env
argument_list|)
expr_stmt|;
name|bear_release_env_t
argument_list|(
operator|&
name|current_env
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECT
end_ifdef

begin_function
specifier|static
name|int
name|call_exect
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[]
parameter_list|)
block|{
typedef|typedef
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
name|DLSYM
argument_list|(
name|func
argument_list|,
name|fp
argument_list|,
literal|"exect"
argument_list|)
expr_stmt|;
name|char
specifier|const
modifier|*
modifier|*
specifier|const
name|menvp
init|=
name|bear_update_environment
argument_list|(
name|envp
argument_list|,
operator|&
name|initial_env
argument_list|)
decl_stmt|;
name|int
specifier|const
name|result
init|=
call|(
modifier|*
name|fp
call|)
argument_list|(
name|path
argument_list|,
name|argv
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|menvp
argument_list|)
decl_stmt|;
name|bear_strings_release
argument_list|(
name|menvp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POSIX_SPAWN
end_ifdef

begin_function
specifier|static
name|int
name|call_posix_spawn
parameter_list|(
name|pid_t
modifier|*
specifier|restrict
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
specifier|restrict
name|path
parameter_list|,
specifier|const
name|posix_spawn_file_actions_t
modifier|*
name|file_actions
parameter_list|,
specifier|const
name|posix_spawnattr_t
modifier|*
specifier|restrict
name|attrp
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[
specifier|restrict
index|]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[
specifier|restrict
index|]
parameter_list|)
block|{
typedef|typedef
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|pid_t
modifier|*
specifier|restrict
parameter_list|,
specifier|const
name|char
modifier|*
specifier|restrict
parameter_list|,
specifier|const
name|posix_spawn_file_actions_t
modifier|*
parameter_list|,
specifier|const
name|posix_spawnattr_t
modifier|*
specifier|restrict
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
specifier|restrict
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
specifier|restrict
parameter_list|)
function_decl|;
name|DLSYM
argument_list|(
name|func
argument_list|,
name|fp
argument_list|,
literal|"posix_spawn"
argument_list|)
expr_stmt|;
name|char
specifier|const
modifier|*
modifier|*
specifier|const
name|menvp
init|=
name|bear_update_environment
argument_list|(
name|envp
argument_list|,
operator|&
name|initial_env
argument_list|)
decl_stmt|;
name|int
specifier|const
name|result
init|=
call|(
modifier|*
name|fp
call|)
argument_list|(
name|pid
argument_list|,
name|path
argument_list|,
name|file_actions
argument_list|,
name|attrp
argument_list|,
name|argv
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
specifier|restrict
operator|)
name|menvp
argument_list|)
decl_stmt|;
name|bear_strings_release
argument_list|(
name|menvp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POSIX_SPAWNP
end_ifdef

begin_function
specifier|static
name|int
name|call_posix_spawnp
parameter_list|(
name|pid_t
modifier|*
specifier|restrict
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
specifier|restrict
name|file
parameter_list|,
specifier|const
name|posix_spawn_file_actions_t
modifier|*
name|file_actions
parameter_list|,
specifier|const
name|posix_spawnattr_t
modifier|*
specifier|restrict
name|attrp
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[
specifier|restrict
index|]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[
specifier|restrict
index|]
parameter_list|)
block|{
typedef|typedef
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|pid_t
modifier|*
specifier|restrict
parameter_list|,
specifier|const
name|char
modifier|*
specifier|restrict
parameter_list|,
specifier|const
name|posix_spawn_file_actions_t
modifier|*
parameter_list|,
specifier|const
name|posix_spawnattr_t
modifier|*
specifier|restrict
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
specifier|restrict
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
specifier|restrict
parameter_list|)
function_decl|;
name|DLSYM
argument_list|(
name|func
argument_list|,
name|fp
argument_list|,
literal|"posix_spawnp"
argument_list|)
expr_stmt|;
name|char
specifier|const
modifier|*
modifier|*
specifier|const
name|menvp
init|=
name|bear_update_environment
argument_list|(
name|envp
argument_list|,
operator|&
name|initial_env
argument_list|)
decl_stmt|;
name|int
specifier|const
name|result
init|=
call|(
modifier|*
name|fp
call|)
argument_list|(
name|pid
argument_list|,
name|file
argument_list|,
name|file_actions
argument_list|,
name|attrp
argument_list|,
name|argv
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
specifier|restrict
operator|)
name|menvp
argument_list|)
decl_stmt|;
name|bear_strings_release
argument_list|(
name|menvp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* this method is to write log about the process creation. */
end_comment

begin_function
specifier|static
name|void
name|bear_report_call
parameter_list|(
name|char
specifier|const
modifier|*
name|fun
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|argv
index|[]
parameter_list|)
block|{
specifier|static
name|int
specifier|const
name|GS
init|=
literal|0x1d
decl_stmt|;
specifier|static
name|int
specifier|const
name|RS
init|=
literal|0x1e
decl_stmt|;
specifier|static
name|int
specifier|const
name|US
init|=
literal|0x1f
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
return|return;
name|pthread_mutex_lock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|cwd
init|=
name|getcwd
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|cwd
condition|)
block|{
name|perror
argument_list|(
literal|"bear: getcwd"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|char
specifier|const
modifier|*
specifier|const
name|out_dir
init|=
name|initial_env
index|[
literal|0
index|]
decl_stmt|;
name|size_t
specifier|const
name|path_max_length
init|=
name|strlen
argument_list|(
name|out_dir
argument_list|)
operator|+
literal|32
decl_stmt|;
name|char
name|filename
index|[
name|path_max_length
index|]
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|snprintf
argument_list|(
name|filename
argument_list|,
name|path_max_length
argument_list|,
literal|"%s/%d.cmd"
argument_list|,
name|out_dir
argument_list|,
name|getpid
argument_list|()
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"bear: snprintf"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|FILE
modifier|*
name|fd
init|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"a+"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|fd
condition|)
block|{
name|perror
argument_list|(
literal|"bear: fopen"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%d%c"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|RS
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%d%c"
argument_list|,
name|getppid
argument_list|()
argument_list|,
name|RS
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s%c"
argument_list|,
name|fun
argument_list|,
name|RS
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s%c"
argument_list|,
name|cwd
argument_list|,
name|RS
argument_list|)
expr_stmt|;
name|size_t
specifier|const
name|argc
init|=
name|bear_strings_length
argument_list|(
name|argv
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|it
init|=
literal|0
init|;
name|it
operator|<
name|argc
condition|;
operator|++
name|it
control|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s%c"
argument_list|,
name|argv
index|[
name|it
index|]
argument_list|,
name|US
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%c"
argument_list|,
name|GS
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"bear: fclose"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|cwd
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* update environment assure that chilren processes will copy the desired  * behaviour */
end_comment

begin_function
specifier|static
name|int
name|bear_capture_env_t
parameter_list|(
name|bear_env_t
modifier|*
name|env
parameter_list|)
block|{
name|int
name|status
init|=
literal|1
decl_stmt|;
for|for
control|(
name|size_t
name|it
init|=
literal|0
init|;
name|it
operator|<
name|ENV_SIZE
condition|;
operator|++
name|it
control|)
block|{
name|char
specifier|const
modifier|*
specifier|const
name|env_value
init|=
name|getenv
argument_list|(
name|env_names
index|[
name|it
index|]
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
name|env_copy
init|=
operator|(
name|env_value
operator|)
condition|?
name|strdup
argument_list|(
name|env_value
argument_list|)
else|:
name|env_value
decl_stmt|;
operator|(
operator|*
name|env
operator|)
index|[
name|it
index|]
operator|=
name|env_copy
expr_stmt|;
name|status
operator|&=
operator|(
name|env_copy
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bear_reset_env_t
parameter_list|(
name|bear_env_t
modifier|*
name|env
parameter_list|)
block|{
name|int
name|status
init|=
literal|1
decl_stmt|;
for|for
control|(
name|size_t
name|it
init|=
literal|0
init|;
name|it
operator|<
name|ENV_SIZE
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|env
operator|)
index|[
name|it
index|]
condition|)
block|{
name|setenv
argument_list|(
name|env_names
index|[
name|it
index|]
argument_list|,
operator|(
operator|*
name|env
operator|)
index|[
name|it
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsetenv
argument_list|(
name|env_names
index|[
name|it
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bear_release_env_t
parameter_list|(
name|bear_env_t
modifier|*
name|env
parameter_list|)
block|{
for|for
control|(
name|size_t
name|it
init|=
literal|0
init|;
name|it
operator|<
name|ENV_SIZE
condition|;
operator|++
name|it
control|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|*
name|env
operator|)
index|[
name|it
index|]
argument_list|)
expr_stmt|;
operator|(
operator|*
name|env
operator|)
index|[
name|it
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|bear_update_environment
parameter_list|(
name|char
modifier|*
specifier|const
name|envp
index|[]
parameter_list|,
name|bear_env_t
modifier|*
name|env
parameter_list|)
block|{
name|char
specifier|const
modifier|*
modifier|*
name|result
init|=
name|bear_strings_copy
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|*
operator|)
name|envp
argument_list|)
decl_stmt|;
for|for
control|(
name|size_t
name|it
init|=
literal|0
init|;
name|it
operator|<
name|ENV_SIZE
operator|&&
operator|(
operator|*
name|env
operator|)
index|[
name|it
index|]
condition|;
operator|++
name|it
control|)
name|result
operator|=
name|bear_update_environ
argument_list|(
name|result
argument_list|,
name|env_names
index|[
name|it
index|]
argument_list|,
operator|(
operator|*
name|env
operator|)
index|[
name|it
index|]
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|bear_update_environ
parameter_list|(
name|char
specifier|const
modifier|*
name|envs
index|[]
parameter_list|,
name|char
specifier|const
modifier|*
name|key
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|value
parameter_list|)
block|{
comment|// find the key if it's there
name|size_t
specifier|const
name|key_length
init|=
name|strlen
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|it
init|=
name|envs
decl_stmt|;
for|for
control|(
init|;
operator|(
name|it
operator|)
operator|&&
operator|(
operator|*
name|it
operator|)
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
operator|*
name|it
argument_list|,
name|key
argument_list|,
name|key_length
argument_list|)
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
operator|*
name|it
argument_list|)
operator|>
name|key_length
operator|)
operator|&&
operator|(
literal|'='
operator|==
operator|(
operator|*
name|it
operator|)
index|[
name|key_length
index|]
operator|)
condition|)
break|break;
block|}
comment|// allocate a environment entry
name|size_t
specifier|const
name|value_length
init|=
name|strlen
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|env_length
init|=
name|key_length
operator|+
name|value_length
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|env
init|=
name|malloc
argument_list|(
name|env_length
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|env
condition|)
block|{
name|perror
argument_list|(
literal|"bear: malloc [in env_update]"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|snprintf
argument_list|(
name|env
argument_list|,
name|env_length
argument_list|,
literal|"%s=%s"
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"bear: snprintf"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|// replace or append the environment entry
if|if
condition|(
name|it
operator|&&
operator|*
name|it
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|*
name|it
argument_list|)
expr_stmt|;
operator|*
name|it
operator|=
name|env
expr_stmt|;
return|return
name|envs
return|;
block|}
return|return
name|bear_strings_append
argument_list|(
name|envs
argument_list|,
name|env
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|bear_get_environment
parameter_list|()
block|{
if|#
directive|if
name|defined
name|HAVE_NSGETENVIRON
return|return
operator|*
name|_NSGetEnviron
argument_list|()
return|;
else|#
directive|else
return|return
name|environ
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* util methods to deal with string arrays. environment and process arguments  * are both represented as string arrays. */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|bear_strings_build
parameter_list|(
name|char
specifier|const
modifier|*
specifier|const
name|arg
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|char
specifier|const
modifier|*
modifier|*
name|result
init|=
literal|0
decl_stmt|;
name|size_t
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|char
specifier|const
modifier|*
name|it
init|=
name|arg
init|;
name|it
condition|;
name|it
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|char
specifier|const
operator|*
argument_list|)
control|)
block|{
name|result
operator|=
name|realloc
argument_list|(
name|result
argument_list|,
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
specifier|const
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|result
condition|)
block|{
name|perror
argument_list|(
literal|"bear: realloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|char
specifier|const
modifier|*
name|copy
init|=
name|strdup
argument_list|(
name|it
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|copy
condition|)
block|{
name|perror
argument_list|(
literal|"bear: strdup"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|size
operator|++
index|]
operator|=
name|copy
expr_stmt|;
block|}
name|result
operator|=
name|realloc
argument_list|(
name|result
argument_list|,
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
specifier|const
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|result
condition|)
block|{
name|perror
argument_list|(
literal|"bear: realloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|size
operator|++
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|bear_strings_copy
parameter_list|(
name|char
specifier|const
modifier|*
modifier|*
specifier|const
name|in
parameter_list|)
block|{
name|size_t
specifier|const
name|size
init|=
name|bear_strings_length
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
specifier|const
name|result
init|=
name|malloc
argument_list|(
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
specifier|const
operator|*
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|result
condition|)
block|{
name|perror
argument_list|(
literal|"bear: malloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|char
specifier|const
modifier|*
modifier|*
name|out_it
init|=
name|result
decl_stmt|;
for|for
control|(
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|in_it
init|=
name|in
init|;
operator|(
name|in_it
operator|)
operator|&&
operator|(
operator|*
name|in_it
operator|)
condition|;
operator|++
name|in_it
operator|,
operator|++
name|out_it
control|)
block|{
operator|*
name|out_it
operator|=
name|strdup
argument_list|(
operator|*
name|in_it
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|*
name|out_it
condition|)
block|{
name|perror
argument_list|(
literal|"bear: strdup"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|out_it
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|bear_strings_append
parameter_list|(
name|char
specifier|const
modifier|*
modifier|*
specifier|const
name|in
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|e
parameter_list|)
block|{
name|size_t
name|size
init|=
name|bear_strings_length
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|result
init|=
name|realloc
argument_list|(
name|in
argument_list|,
operator|(
name|size
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
specifier|const
operator|*
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|result
condition|)
block|{
name|perror
argument_list|(
literal|"bear: realloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|size
operator|++
index|]
operator|=
name|e
expr_stmt|;
name|result
index|[
name|size
operator|++
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|bear_strings_length
parameter_list|(
name|char
specifier|const
modifier|*
specifier|const
modifier|*
specifier|const
name|in
parameter_list|)
block|{
name|size_t
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|it
init|=
name|in
init|;
operator|(
name|it
operator|)
operator|&&
operator|(
operator|*
name|it
operator|)
condition|;
operator|++
name|it
control|)
operator|++
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bear_strings_release
parameter_list|(
name|char
specifier|const
modifier|*
modifier|*
name|in
parameter_list|)
block|{
for|for
control|(
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|it
init|=
name|in
init|;
operator|(
name|it
operator|)
operator|&&
operator|(
operator|*
name|it
operator|)
condition|;
operator|++
name|it
control|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|*
name|it
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|in
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

