begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* -*- coding: utf-8 -*- //                     The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_if
if|#
directive|if
name|defined
name|HAVE_POSIX_SPAWN
operator|||
name|defined
name|HAVE_POSIX_SPAWNP
end_if

begin_include
include|#
directive|include
file|<spawn.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// ..:: environment access fixer - begin ::..
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NSGETENVIRON
end_ifdef

begin_include
include|#
directive|include
file|<crt_externs.h>
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
modifier|*
name|get_environ
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|HAVE_NSGETENVIRON
return|return
operator|*
name|_NSGetEnviron
argument_list|()
return|;
else|#
directive|else
return|return
name|environ
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|// ..:: environment access fixer - end ::..
end_comment

begin_comment
comment|// ..:: test fixtures - begin ::..
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|cwd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|expected_out_open
parameter_list|(
specifier|const
name|char
modifier|*
name|expected
parameter_list|)
block|{
name|cwd
operator|=
name|getcwd
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|expected
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fd
condition|)
block|{
name|perror
argument_list|(
literal|"fopen"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"[\n"
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expected_out_close
parameter_list|()
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|cwd
argument_list|)
expr_stmt|;
name|cwd
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expected_out
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|need_comma
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
else|else
name|need_comma
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  \"directory\": \"%s\",\n"
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  \"command\": \"cc -c %s\",\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  \"file\": \"%s/%s\"\n"
argument_list|,
name|cwd
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|create_source
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
block|{
name|FILE
modifier|*
name|fd
init|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fd
condition|)
block|{
name|perror
argument_list|(
literal|"fopen"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"typedef int score;\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|exec_fun
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_function
name|void
name|wait_for
parameter_list|(
name|pid_t
name|child
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"wait"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|?
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
else|:
name|EXIT_FAILURE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"children process has non zero exit code\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|FORK
parameter_list|(
name|FUNC
parameter_list|)
define|\
value|{                                                                          \         pid_t child = fork();                                                  \         if (-1 == child) {                                                     \             perror("fork");                                                    \             exit(EXIT_FAILURE);                                                \         } else if (0 == child) {                                               \             FUNC fprintf(stderr, "children process failed to exec\n");         \             exit(EXIT_FAILURE);                                                \         } else {                                                               \             wait_for(child);                                                   \         }                                                                      \     }
end_define

begin_comment
comment|// ..:: test fixtures - end ::..
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECV
end_ifdef

begin_function
name|void
name|call_execv
parameter_list|()
block|{
name|char
modifier|*
specifier|const
name|file
init|=
literal|"execv.c"
decl_stmt|;
name|char
modifier|*
specifier|const
name|compiler
init|=
literal|"/usr/bin/cc"
decl_stmt|;
name|char
modifier|*
specifier|const
name|argv
index|[]
init|=
block|{
literal|"cc"
block|,
literal|"-c"
block|,
name|file
block|,
literal|0
block|}
decl_stmt|;
name|expected_out
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|create_source
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|FORK
argument_list|(
argument|execv(compiler, argv);
argument_list|)
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVE
end_ifdef

begin_function
name|void
name|call_execve
parameter_list|()
block|{
name|char
modifier|*
specifier|const
name|file
init|=
literal|"execve.c"
decl_stmt|;
name|char
modifier|*
specifier|const
name|compiler
init|=
literal|"/usr/bin/cc"
decl_stmt|;
name|char
modifier|*
specifier|const
name|argv
index|[]
init|=
block|{
name|compiler
block|,
literal|"-c"
block|,
name|file
block|,
literal|0
block|}
decl_stmt|;
name|char
modifier|*
specifier|const
name|envp
index|[]
init|=
block|{
literal|"THIS=THAT"
block|,
literal|0
block|}
decl_stmt|;
name|expected_out
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|create_source
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|FORK
argument_list|(
argument|execve(compiler, argv, envp);
argument_list|)
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVP
end_ifdef

begin_function
name|void
name|call_execvp
parameter_list|()
block|{
name|char
modifier|*
specifier|const
name|file
init|=
literal|"execvp.c"
decl_stmt|;
name|char
modifier|*
specifier|const
name|compiler
init|=
literal|"cc"
decl_stmt|;
name|char
modifier|*
specifier|const
name|argv
index|[]
init|=
block|{
name|compiler
block|,
literal|"-c"
block|,
name|file
block|,
literal|0
block|}
decl_stmt|;
name|expected_out
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|create_source
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|FORK
argument_list|(
argument|execvp(compiler, argv);
argument_list|)
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVP2
end_ifdef

begin_function
name|void
name|call_execvP
parameter_list|()
block|{
name|char
modifier|*
specifier|const
name|file
init|=
literal|"execv_p.c"
decl_stmt|;
name|char
modifier|*
specifier|const
name|compiler
init|=
literal|"cc"
decl_stmt|;
name|char
modifier|*
specifier|const
name|argv
index|[]
init|=
block|{
name|compiler
block|,
literal|"-c"
block|,
name|file
block|,
literal|0
block|}
decl_stmt|;
name|expected_out
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|create_source
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|FORK
argument_list|(
argument|execvP(compiler, _PATH_DEFPATH, argv);
argument_list|)
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECVPE
end_ifdef

begin_function
name|void
name|call_execvpe
parameter_list|()
block|{
name|char
modifier|*
specifier|const
name|file
init|=
literal|"execvpe.c"
decl_stmt|;
name|char
modifier|*
specifier|const
name|compiler
init|=
literal|"cc"
decl_stmt|;
name|char
modifier|*
specifier|const
name|argv
index|[]
init|=
block|{
literal|"/usr/bin/cc"
block|,
literal|"-c"
block|,
name|file
block|,
literal|0
block|}
decl_stmt|;
name|char
modifier|*
specifier|const
name|envp
index|[]
init|=
block|{
literal|"THIS=THAT"
block|,
literal|0
block|}
decl_stmt|;
name|expected_out
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|create_source
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|FORK
argument_list|(
argument|execvpe(compiler, argv, envp);
argument_list|)
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECT
end_ifdef

begin_function
name|void
name|call_exect
parameter_list|()
block|{
name|char
modifier|*
specifier|const
name|file
init|=
literal|"exect.c"
decl_stmt|;
name|char
modifier|*
specifier|const
name|compiler
init|=
literal|"/usr/bin/cc"
decl_stmt|;
name|char
modifier|*
specifier|const
name|argv
index|[]
init|=
block|{
name|compiler
block|,
literal|"-c"
block|,
name|file
block|,
literal|0
block|}
decl_stmt|;
name|char
modifier|*
specifier|const
name|envp
index|[]
init|=
block|{
literal|"THIS=THAT"
block|,
literal|0
block|}
decl_stmt|;
name|expected_out
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|create_source
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|FORK
argument_list|(
argument|exect(compiler, argv, envp);
argument_list|)
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECL
end_ifdef

begin_function
name|void
name|call_execl
parameter_list|()
block|{
name|char
modifier|*
specifier|const
name|file
init|=
literal|"execl.c"
decl_stmt|;
name|char
modifier|*
specifier|const
name|compiler
init|=
literal|"/usr/bin/cc"
decl_stmt|;
name|expected_out
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|create_source
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|FORK
argument_list|(
argument|execl(compiler,
literal|"cc"
argument|,
literal|"-c"
argument|, file, (char *)
literal|0
argument|);
argument_list|)
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECLP
end_ifdef

begin_function
name|void
name|call_execlp
parameter_list|()
block|{
name|char
modifier|*
specifier|const
name|file
init|=
literal|"execlp.c"
decl_stmt|;
name|char
modifier|*
specifier|const
name|compiler
init|=
literal|"cc"
decl_stmt|;
name|expected_out
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|create_source
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|FORK
argument_list|(
argument|execlp(compiler, compiler,
literal|"-c"
argument|, file, (char *)
literal|0
argument|);
argument_list|)
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXECLE
end_ifdef

begin_function
name|void
name|call_execle
parameter_list|()
block|{
name|char
modifier|*
specifier|const
name|file
init|=
literal|"execle.c"
decl_stmt|;
name|char
modifier|*
specifier|const
name|compiler
init|=
literal|"/usr/bin/cc"
decl_stmt|;
name|char
modifier|*
specifier|const
name|envp
index|[]
init|=
block|{
literal|"THIS=THAT"
block|,
literal|0
block|}
decl_stmt|;
name|expected_out
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|create_source
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|FORK
argument_list|(
argument|execle(compiler, compiler,
literal|"-c"
argument|, file, (char *)
literal|0
argument|, envp);
argument_list|)
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POSIX_SPAWN
end_ifdef

begin_function
name|void
name|call_posix_spawn
parameter_list|()
block|{
name|char
modifier|*
specifier|const
name|file
init|=
literal|"posix_spawn.c"
decl_stmt|;
name|char
modifier|*
specifier|const
name|compiler
init|=
literal|"cc"
decl_stmt|;
name|char
modifier|*
specifier|const
name|argv
index|[]
init|=
block|{
name|compiler
block|,
literal|"-c"
block|,
name|file
block|,
literal|0
block|}
decl_stmt|;
name|expected_out
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|create_source
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|pid_t
name|child
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
name|posix_spawn
argument_list|(
operator|&
name|child
argument_list|,
literal|"/usr/bin/cc"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|argv
argument_list|,
name|get_environ
argument_list|()
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"posix_spawn"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|wait_for
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POSIX_SPAWNP
end_ifdef

begin_function
name|void
name|call_posix_spawnp
parameter_list|()
block|{
name|char
modifier|*
specifier|const
name|file
init|=
literal|"posix_spawnp.c"
decl_stmt|;
name|char
modifier|*
specifier|const
name|compiler
init|=
literal|"cc"
decl_stmt|;
name|char
modifier|*
specifier|const
name|argv
index|[]
init|=
block|{
name|compiler
block|,
literal|"-c"
block|,
name|file
block|,
literal|0
block|}
decl_stmt|;
name|expected_out
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|create_source
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|pid_t
name|child
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
name|posix_spawnp
argument_list|(
operator|&
name|child
argument_list|,
literal|"cc"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|argv
argument_list|,
name|get_environ
argument_list|()
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"posix_spawnp"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|wait_for
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|expected_out_open
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_EXECV
name|call_execv
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EXECVE
name|call_execve
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EXECVP
name|call_execvp
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EXECVP2
name|call_execvP
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EXECVPE
name|call_execvpe
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EXECT
name|call_exect
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EXECL
name|call_execl
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EXECLP
name|call_execlp
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EXECLE
name|call_execle
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POSIX_SPAWN
name|call_posix_spawn
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POSIX_SPAWNP
name|call_posix_spawnp
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|expected_out_close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

