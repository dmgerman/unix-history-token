begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*===- llvm-stub.c - Stub executable to run llvm bitcode files ------------===// // //                     The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// // // This tool is used by the gccld program to enable transparent execution of // bitcode files by the user.  Specifically, gccld outputs two files when asked // to compile a<program> file: //    1. It outputs the LLVM bitcode file to<program>.bc //    2. It outputs a stub executable that runs lli on<program>.bc // // This allows the end user to just say ./<program> and have the JIT executed // automatically.  On unix, the stub executable emitted is actually a bourne // shell script that does the forwarding.  Windows does not like #!/bin/sh // programs in .exe files, so we make it an actual program, defined here. // //===----------------------------------------------------------------------===*/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"llvm/Config/config.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|Interp
init|=
name|getenv
argument_list|(
literal|"LLVMINTERP"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|Args
decl_stmt|;
if|if
condition|(
name|Interp
operator|==
literal|0
condition|)
name|Interp
operator|=
literal|"lli"
expr_stmt|;
comment|/* Set up the command line options to pass to the JIT. */
name|Args
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|argc
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/* argv[0] is the JIT */
name|Args
index|[
literal|0
index|]
operator|=
name|Interp
expr_stmt|;
ifdef|#
directive|ifdef
name|LLVM_ON_WIN32
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|4
operator|||
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
operator|+
name|len
operator|-
literal|4
argument_list|,
literal|".exe"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* .exe suffix is stripped off of argv[0] if the executable was run on the        * command line without one. Put it back on.        */
name|argv
index|[
literal|0
index|]
operator|=
name|strcat
argument_list|(
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|5
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|".exe"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* argv[1] is argv[0] + ".bc". */
name|Args
index|[
literal|1
index|]
operator|=
name|strcat
argument_list|(
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
literal|4
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|".bc"
argument_list|)
expr_stmt|;
comment|/* The rest of the args are as before. */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|Args
operator|+
literal|2
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|argc
argument_list|)
expr_stmt|;
comment|/* Run the JIT. */
ifndef|#
directive|ifndef
name|_WIN32
name|execvp
argument_list|(
name|Interp
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|Args
argument_list|)
expr_stmt|;
comment|/* POSIX execvp takes a char *const[]. */
else|#
directive|else
name|execvp
argument_list|(
name|Interp
argument_list|,
name|Args
argument_list|)
expr_stmt|;
comment|/* windows execvp takes a const char *const *. */
endif|#
directive|endif
comment|/* if _execv returns, the JIT could not be started. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not execute the LLVM JIT.  Either add 'lli' to your"
literal|" path, or set the\ninterpreter you want to use in the LLVMINTERP "
literal|"environment variable.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

