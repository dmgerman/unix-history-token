begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: ahdecode - Operator/Opcode decoding for acpihelp utility  *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2011, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|"acpihelp.h"
end_include

begin_define
define|#
directive|define
name|ACPI_CREATE_PREDEFINED_TABLE
end_define

begin_include
include|#
directive|include
file|"acpredef.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|Gbl_Buffer
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|AcpiRtypeNames
index|[]
init|=
block|{
literal|"/Integer"
block|,
literal|"/String"
block|,
literal|"/Buffer"
block|,
literal|"/Package"
block|,
literal|"/Reference"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|BOOLEAN
name|AhDisplayPredefinedName
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|,
name|UINT32
name|Length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AhDisplayPredefinedInfo
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AhGetExpectedTypes
parameter_list|(
name|char
modifier|*
name|Buffer
parameter_list|,
name|UINT32
name|ExpectedBtypes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AhDisplayAmlOpcode
parameter_list|(
specifier|const
name|AH_AML_OPCODE
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AhDisplayAslOperator
parameter_list|(
specifier|const
name|AH_ASL_OPERATOR
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AhDisplayAslKeyword
parameter_list|(
specifier|const
name|AH_ASL_KEYWORD
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AhPrintOneField
parameter_list|(
name|UINT32
name|Indent
parameter_list|,
name|UINT32
name|CurrentPosition
parameter_list|,
name|UINT32
name|MaxPosition
parameter_list|,
specifier|const
name|char
modifier|*
name|Field
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhFindPredefinedNames (entry point for predefined name search)  *  * PARAMETERS:  NamePrefix          - Name or prefix to find. Must start with  *                                    an underscore. NULL means "find all"  *  * RETURN:      None  *  * DESCRIPTION: Find and display all ACPI predefined names that match the  *              input name or prefix. Includes the required number of arguments  *              and the expected return type, if any.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AhFindPredefinedNames
parameter_list|(
name|char
modifier|*
name|NamePrefix
parameter_list|)
block|{
name|UINT32
name|Length
decl_stmt|;
name|BOOLEAN
name|Found
decl_stmt|;
name|char
name|Name
index|[
literal|9
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|NamePrefix
condition|)
block|{
name|Found
operator|=
name|AhDisplayPredefinedName
argument_list|(
name|Name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Contruct a local name or name prefix */
name|AhStrupr
argument_list|(
name|NamePrefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|NamePrefix
operator|==
literal|'_'
condition|)
block|{
name|NamePrefix
operator|++
expr_stmt|;
block|}
name|Name
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|Name
index|[
literal|1
index|]
argument_list|,
name|NamePrefix
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|Length
operator|=
name|strlen
argument_list|(
name|Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Length
operator|>
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"%.8s: Predefined name must be 4 characters maximum\n"
argument_list|,
name|Name
argument_list|)
expr_stmt|;
return|return;
block|}
name|Found
operator|=
name|AhDisplayPredefinedName
argument_list|(
name|Name
argument_list|,
name|Length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Found
condition|)
block|{
name|printf
argument_list|(
literal|"%s, no matching predefined names\n"
argument_list|,
name|Name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDisplayPredefinedName  *  * PARAMETERS:  Name                - Name or name prefix  *  * RETURN:      TRUE if any names matched, FALSE otherwise  *  * DESCRIPTION: Display information about ACPI predefined names that match  *              the input name or name prefix.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|BOOLEAN
name|AhDisplayPredefinedName
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|,
name|UINT32
name|Length
parameter_list|)
block|{
specifier|const
name|AH_PREDEFINED_NAME
modifier|*
name|Info
decl_stmt|;
name|BOOLEAN
name|Found
init|=
name|FALSE
decl_stmt|;
name|BOOLEAN
name|Matched
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
comment|/* Find/display all names that match the input name prefix */
for|for
control|(
name|Info
operator|=
name|AslPredefinedInfo
init|;
name|Info
operator|->
name|Name
condition|;
name|Info
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Name
condition|)
block|{
name|Found
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"%s:<%s>\n"
argument_list|,
name|Info
operator|->
name|Name
argument_list|,
name|Info
operator|->
name|Description
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%s\n"
argument_list|,
literal|6
argument_list|,
literal|" "
argument_list|,
name|Info
operator|->
name|Action
argument_list|)
expr_stmt|;
name|AhDisplayPredefinedInfo
argument_list|(
name|Info
operator|->
name|Name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Matched
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Info
operator|->
name|Name
index|[
name|i
index|]
operator|!=
name|Name
index|[
name|i
index|]
condition|)
block|{
name|Matched
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|Matched
condition|)
block|{
name|Found
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"%s:<%s>\n"
argument_list|,
name|Info
operator|->
name|Name
argument_list|,
name|Info
operator|->
name|Description
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%s\n"
argument_list|,
literal|6
argument_list|,
literal|" "
argument_list|,
name|Info
operator|->
name|Action
argument_list|)
expr_stmt|;
name|AhDisplayPredefinedInfo
argument_list|(
name|Info
operator|->
name|Name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|Found
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDisplayPredefinedInfo  *  * PARAMETERS:  Name                - Exact 4-character ACPI name.  *  * RETURN:      None  *  * DESCRIPTION: Find the name in the main ACPICA predefined info table and  *              display the # of arguments and the return value type.  *  *              Note: Resource Descriptor field names do not appear in this  *              table -- thus, nothing will be displayed for them.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AhDisplayPredefinedInfo
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|)
block|{
specifier|const
name|ACPI_PREDEFINED_INFO
modifier|*
name|ThisName
decl_stmt|;
name|BOOLEAN
name|Matched
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
comment|/* Find/display only the exact input name */
for|for
control|(
name|ThisName
operator|=
name|PredefinedNames
init|;
name|ThisName
operator|->
name|Info
operator|.
name|Name
index|[
literal|0
index|]
condition|;
name|ThisName
operator|++
control|)
block|{
name|Matched
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ACPI_NAME_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ThisName
operator|->
name|Info
operator|.
name|Name
index|[
name|i
index|]
operator|!=
name|Name
index|[
name|i
index|]
condition|)
block|{
name|Matched
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|Matched
condition|)
block|{
name|AhGetExpectedTypes
argument_list|(
name|Gbl_Buffer
argument_list|,
name|ThisName
operator|->
name|Info
operator|.
name|ExpectedBtypes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%4.4s has %u arguments, returns: %s\n"
argument_list|,
literal|6
argument_list|,
literal|" "
argument_list|,
name|ThisName
operator|->
name|Info
operator|.
name|Name
argument_list|,
name|ThisName
operator|->
name|Info
operator|.
name|ParamCount
argument_list|,
name|ThisName
operator|->
name|Info
operator|.
name|ExpectedBtypes
condition|?
name|Gbl_Buffer
else|:
literal|"-Nothing-"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ThisName
operator|->
name|Info
operator|.
name|ExpectedBtypes
operator|&
name|ACPI_RTYPE_PACKAGE
condition|)
block|{
name|ThisName
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhGetExpectedTypes  *  * PARAMETERS:  Buffer              - Where the formatted string is returned  *              ExpectedBTypes      - Bitfield of expected data types  *  * RETURN:      Formatted string in Buffer.  *  * DESCRIPTION: Format the expected object types into a printable string.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AhGetExpectedTypes
parameter_list|(
name|char
modifier|*
name|Buffer
parameter_list|,
name|UINT32
name|ExpectedBtypes
parameter_list|)
block|{
name|UINT32
name|ThisRtype
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
name|UINT32
name|j
decl_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
name|Buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ThisRtype
operator|=
name|ACPI_RTYPE_INTEGER
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ACPI_NUM_RTYPES
condition|;
name|i
operator|++
control|)
block|{
comment|/* If one of the expected types, concatenate the name of this type */
if|if
condition|(
name|ExpectedBtypes
operator|&
name|ThisRtype
condition|)
block|{
name|strcat
argument_list|(
name|Buffer
argument_list|,
operator|&
name|AcpiRtypeNames
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
comment|/* Use name separator from now on */
block|}
name|ThisRtype
operator|<<=
literal|1
expr_stmt|;
comment|/* Next Rtype */
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhFindAmlOpcode (entry point for AML opcode name search)  *  * PARAMETERS:  Name                - Name or prefix for an AML opcode.  *                                    NULL means "find all"  *  * RETURN:      None  *  * DESCRIPTION: Find all AML opcodes that match the input Name or name  *              prefix.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AhFindAmlOpcode
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|)
block|{
specifier|const
name|AH_AML_OPCODE
modifier|*
name|Op
decl_stmt|;
name|BOOLEAN
name|Found
init|=
name|FALSE
decl_stmt|;
name|AhStrupr
argument_list|(
name|Name
argument_list|)
expr_stmt|;
comment|/* Find/display all opcode names that match the input name prefix */
for|for
control|(
name|Op
operator|=
name|AmlOpcodeInfo
init|;
name|Op
operator|->
name|OpcodeString
condition|;
name|Op
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Op
operator|->
name|OpcodeName
condition|)
comment|/* Unused opcodes */
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|Name
condition|)
block|{
name|AhDisplayAmlOpcode
argument_list|(
name|Op
argument_list|)
expr_stmt|;
name|Found
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* Upper case the opcode name before substring compare */
name|strcpy
argument_list|(
name|Gbl_Buffer
argument_list|,
name|Op
operator|->
name|OpcodeName
argument_list|)
expr_stmt|;
name|AhStrupr
argument_list|(
name|Gbl_Buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|Gbl_Buffer
argument_list|,
name|Name
argument_list|)
operator|==
name|Gbl_Buffer
condition|)
block|{
name|AhDisplayAmlOpcode
argument_list|(
name|Op
argument_list|)
expr_stmt|;
name|Found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|Found
condition|)
block|{
name|printf
argument_list|(
literal|"%s, no matching AML operators\n"
argument_list|,
name|Name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDecodeAmlOpcode (entry point for AML opcode search)  *  * PARAMETERS:  OpcodeString        - String version of AML opcode  *  * RETURN:      None  *  * DESCRIPTION: Display information about the input AML opcode  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AhDecodeAmlOpcode
parameter_list|(
name|char
modifier|*
name|OpcodeString
parameter_list|)
block|{
specifier|const
name|AH_AML_OPCODE
modifier|*
name|Op
decl_stmt|;
name|UINT32
name|Opcode
decl_stmt|;
name|BOOLEAN
name|Found
init|=
name|FALSE
decl_stmt|;
name|UINT8
name|Prefix
decl_stmt|;
if|if
condition|(
operator|!
name|OpcodeString
condition|)
block|{
name|AhFindAmlOpcode
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|Opcode
operator|=
name|ACPI_STRTOUL
argument_list|(
name|OpcodeString
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|Opcode
operator|>
name|ACPI_UINT16_MAX
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid opcode (more than 16 bits)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Only valid opcode extension is 0x5B */
name|Prefix
operator|=
operator|(
name|Opcode
operator|&
literal|0x0000FF00
operator|)
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|Prefix
operator|&&
operator|(
name|Prefix
operator|!=
literal|0x5B
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid opcode (invalid extension prefix 0x%X)\n"
argument_list|,
name|Prefix
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find/Display the opcode. May fall within an opcode range */
for|for
control|(
name|Op
operator|=
name|AmlOpcodeInfo
init|;
name|Op
operator|->
name|OpcodeString
condition|;
name|Op
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|Opcode
operator|>=
name|Op
operator|->
name|OpcodeRangeStart
operator|)
operator|&&
operator|(
name|Opcode
operator|<=
name|Op
operator|->
name|OpcodeRangeEnd
operator|)
condition|)
block|{
name|AhDisplayAmlOpcode
argument_list|(
name|Op
argument_list|)
expr_stmt|;
name|Found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDisplayAmlOpcode  *  * PARAMETERS:  Op                  - An opcode info struct  *  * RETURN:      None  *  * DESCRIPTION: Display the contents of an AML opcode information struct  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AhDisplayAmlOpcode
parameter_list|(
specifier|const
name|AH_AML_OPCODE
modifier|*
name|Op
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Op
operator|->
name|OpcodeName
condition|)
block|{
name|printf
argument_list|(
literal|"%18s: Opcode=%-9s\n"
argument_list|,
literal|"Reserved opcode"
argument_list|,
name|Op
operator|->
name|OpcodeString
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Opcode name and value(s) */
name|printf
argument_list|(
literal|"%18s: Opcode=%-9s Type (%s)"
argument_list|,
name|Op
operator|->
name|OpcodeName
argument_list|,
name|Op
operator|->
name|OpcodeString
argument_list|,
name|Op
operator|->
name|Type
argument_list|)
expr_stmt|;
comment|/* Optional fixed/static arguments */
if|if
condition|(
name|Op
operator|->
name|FixedArguments
condition|)
block|{
name|printf
argument_list|(
literal|" FixedArgs ("
argument_list|)
expr_stmt|;
name|AhPrintOneField
argument_list|(
literal|37
argument_list|,
literal|36
operator|+
literal|7
operator|+
name|strlen
argument_list|(
name|Op
operator|->
name|Type
argument_list|)
operator|+
literal|12
argument_list|,
name|AH_MAX_AML_LINE_LENGTH
argument_list|,
name|Op
operator|->
name|FixedArguments
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/* Optional variable-length argument list */
if|if
condition|(
name|Op
operator|->
name|VariableArguments
condition|)
block|{
if|if
condition|(
name|Op
operator|->
name|FixedArguments
condition|)
block|{
name|printf
argument_list|(
literal|"\n%*s"
argument_list|,
literal|36
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" VariableArgs ("
argument_list|)
expr_stmt|;
name|AhPrintOneField
argument_list|(
literal|37
argument_list|,
literal|15
argument_list|,
name|AH_MAX_AML_LINE_LENGTH
argument_list|,
name|Op
operator|->
name|VariableArguments
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Grammar specification */
if|if
condition|(
name|Op
operator|->
name|Grammar
condition|)
block|{
name|AhPrintOneField
argument_list|(
literal|37
argument_list|,
literal|0
argument_list|,
name|AH_MAX_AML_LINE_LENGTH
argument_list|,
name|Op
operator|->
name|Grammar
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhFindAslKeywords (entry point for ASL keyword search)  *  * PARAMETERS:  Name                - Name or prefix for an ASL keyword.  *                                    NULL means "find all"  *  * RETURN:      None  *  * DESCRIPTION: Find all ASL keywords that match the input Name or name  *              prefix.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AhFindAslKeywords
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|)
block|{
specifier|const
name|AH_ASL_KEYWORD
modifier|*
name|Keyword
decl_stmt|;
name|BOOLEAN
name|Found
init|=
name|FALSE
decl_stmt|;
name|AhStrupr
argument_list|(
name|Name
argument_list|)
expr_stmt|;
for|for
control|(
name|Keyword
operator|=
name|AslKeywordInfo
init|;
name|Keyword
operator|->
name|Name
condition|;
name|Keyword
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Name
condition|)
block|{
name|AhDisplayAslKeyword
argument_list|(
name|Keyword
argument_list|)
expr_stmt|;
name|Found
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* Upper case the operator name before substring compare */
name|strcpy
argument_list|(
name|Gbl_Buffer
argument_list|,
name|Keyword
operator|->
name|Name
argument_list|)
expr_stmt|;
name|AhStrupr
argument_list|(
name|Gbl_Buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|Gbl_Buffer
argument_list|,
name|Name
argument_list|)
operator|==
name|Gbl_Buffer
condition|)
block|{
name|AhDisplayAslKeyword
argument_list|(
name|Keyword
argument_list|)
expr_stmt|;
name|Found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|Found
condition|)
block|{
name|printf
argument_list|(
literal|"%s, no matching ASL keywords\n"
argument_list|,
name|Name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDisplayAslKeyword  *  * PARAMETERS:  Op                  - Pointer to ASL keyword with syntax info  *  * RETURN:      None  *  * DESCRIPTION: Format and display syntax info for an ASL keyword. Splits  *              long lines appropriately for reading.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AhDisplayAslKeyword
parameter_list|(
specifier|const
name|AH_ASL_KEYWORD
modifier|*
name|Op
parameter_list|)
block|{
comment|/* ASL keyword name and description */
name|printf
argument_list|(
literal|"%20s: %s\n"
argument_list|,
name|Op
operator|->
name|Name
argument_list|,
name|Op
operator|->
name|Description
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Op
operator|->
name|KeywordList
condition|)
block|{
return|return;
block|}
comment|/* List of actual keywords */
name|AhPrintOneField
argument_list|(
literal|22
argument_list|,
literal|0
argument_list|,
name|AH_MAX_ASL_LINE_LENGTH
argument_list|,
name|Op
operator|->
name|KeywordList
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhFindAslOperators (entry point for ASL operator search)  *  * PARAMETERS:  Name                - Name or prefix for an ASL operator.  *                                    NULL means "find all"  *  * RETURN:      None  *  * DESCRIPTION: Find all ASL operators that match the input Name or name  *              prefix.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AhFindAslOperators
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|)
block|{
specifier|const
name|AH_ASL_OPERATOR
modifier|*
name|Operator
decl_stmt|;
name|BOOLEAN
name|Found
init|=
name|FALSE
decl_stmt|;
name|AhStrupr
argument_list|(
name|Name
argument_list|)
expr_stmt|;
comment|/* Find/display all names that match the input name prefix */
for|for
control|(
name|Operator
operator|=
name|AslOperatorInfo
init|;
name|Operator
operator|->
name|Name
condition|;
name|Operator
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Name
condition|)
block|{
name|AhDisplayAslOperator
argument_list|(
name|Operator
argument_list|)
expr_stmt|;
name|Found
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* Upper case the operator name before substring compare */
name|strcpy
argument_list|(
name|Gbl_Buffer
argument_list|,
name|Operator
operator|->
name|Name
argument_list|)
expr_stmt|;
name|AhStrupr
argument_list|(
name|Gbl_Buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|Gbl_Buffer
argument_list|,
name|Name
argument_list|)
operator|==
name|Gbl_Buffer
condition|)
block|{
name|AhDisplayAslOperator
argument_list|(
name|Operator
argument_list|)
expr_stmt|;
name|Found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|Found
condition|)
block|{
name|printf
argument_list|(
literal|"%s, no matching ASL operators\n"
argument_list|,
name|Name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhDisplayAslOperator  *  * PARAMETERS:  Op                  - Pointer to ASL operator with syntax info  *  * RETURN:      None  *  * DESCRIPTION: Format and display syntax info for an ASL operator. Splits  *              long lines appropriately for reading.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AhDisplayAslOperator
parameter_list|(
specifier|const
name|AH_ASL_OPERATOR
modifier|*
name|Op
parameter_list|)
block|{
comment|/* ASL operator name and description */
name|printf
argument_list|(
literal|"%16s: %s\n"
argument_list|,
name|Op
operator|->
name|Name
argument_list|,
name|Op
operator|->
name|Description
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Op
operator|->
name|Syntax
condition|)
block|{
return|return;
block|}
comment|/* Syntax for the operator */
name|AhPrintOneField
argument_list|(
literal|18
argument_list|,
literal|0
argument_list|,
name|AH_MAX_ASL_LINE_LENGTH
argument_list|,
name|Op
operator|->
name|Syntax
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AhPrintOneField  *  * PARAMETERS:  Indent              - Indent length for new line(s)  *              CurrentPosition     - Position on current line  *              MaxPosition         - Max allowed line length  *              Field               - Data to output  *  * RETURN:      Line position after field is written  *  * DESCRIPTION: Split long lines appropriately for ease of reading.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AhPrintOneField
parameter_list|(
name|UINT32
name|Indent
parameter_list|,
name|UINT32
name|CurrentPosition
parameter_list|,
name|UINT32
name|MaxPosition
parameter_list|,
specifier|const
name|char
modifier|*
name|Field
parameter_list|)
block|{
name|UINT32
name|Position
decl_stmt|;
name|UINT32
name|TokenLength
decl_stmt|;
specifier|const
name|char
modifier|*
name|This
decl_stmt|;
specifier|const
name|char
modifier|*
name|Next
decl_stmt|;
specifier|const
name|char
modifier|*
name|Last
decl_stmt|;
name|This
operator|=
name|Field
expr_stmt|;
name|Position
operator|=
name|CurrentPosition
expr_stmt|;
if|if
condition|(
name|Position
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%*s"
argument_list|,
operator|(
name|int
operator|)
name|Indent
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|Position
operator|=
name|Indent
expr_stmt|;
block|}
name|Last
operator|=
name|This
operator|+
name|strlen
argument_list|(
name|This
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|Next
operator|=
name|strpbrk
argument_list|(
name|This
argument_list|,
literal|" "
argument_list|)
operator|)
condition|)
block|{
name|TokenLength
operator|=
name|Next
operator|-
name|This
expr_stmt|;
name|Position
operator|+=
name|TokenLength
expr_stmt|;
comment|/* Split long lines */
if|if
condition|(
name|Position
operator|>
name|MaxPosition
condition|)
block|{
name|printf
argument_list|(
literal|"\n%*s"
argument_list|,
operator|(
name|int
operator|)
name|Indent
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|Position
operator|=
name|TokenLength
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%.*s "
argument_list|,
operator|(
name|int
operator|)
name|TokenLength
argument_list|,
name|This
argument_list|)
expr_stmt|;
name|This
operator|=
name|Next
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Handle last token on the input line */
name|TokenLength
operator|=
name|Last
operator|-
name|This
expr_stmt|;
if|if
condition|(
name|TokenLength
operator|>
literal|0
condition|)
block|{
name|Position
operator|+=
name|TokenLength
expr_stmt|;
if|if
condition|(
name|Position
operator|>
name|MaxPosition
condition|)
block|{
name|printf
argument_list|(
literal|"\n%*s"
argument_list|,
operator|(
name|int
operator|)
name|Indent
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|This
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

