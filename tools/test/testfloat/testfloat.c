begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ===============================================================================  This C source file is part of TestFloat, Release 2a, a package of programs for testing the correctness of floating-point arithmetic complying to the IEC/IEEE Standard for Floating-Point.  Written by John R. Hauser.  More information is available through the Web page `http://HTTP.CS.Berkeley.EDU/~jhauser/arithmetic/TestFloat.html'.  THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.  Derivative works are acceptable, even for commercial purposes, so long as (1) they include prominent notice that the work is derivative, and (2) they include prominent notice akin to these four paragraphs for those parts of this code that are retained.  =============================================================================== */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"milieu.h"
end_include

begin_include
include|#
directive|include
file|"fail.h"
end_include

begin_include
include|#
directive|include
file|"softfloat.h"
end_include

begin_include
include|#
directive|include
file|"testCases.h"
end_include

begin_include
include|#
directive|include
file|"testLoops.h"
end_include

begin_include
include|#
directive|include
file|"systflags.h"
end_include

begin_include
include|#
directive|include
file|"testFunction.h"
end_include

begin_function
specifier|static
name|void
name|catchSIGINT
parameter_list|(
name|int
name|signalCode
parameter_list|)
block|{
if|if
condition|(
name|stop
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|stop
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|argPtr
decl_stmt|;
name|flag
name|functionArgument
decl_stmt|;
name|uint8
name|functionCode
decl_stmt|;
name|int8
name|operands
decl_stmt|,
name|roundingPrecision
decl_stmt|,
name|roundingMode
decl_stmt|;
name|fail_programName
operator|=
literal|"testfloat"
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
goto|goto
name|writeHelpMessage
goto|;
name|testCases_setLevel
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|trueName
operator|=
literal|"soft"
expr_stmt|;
name|testName
operator|=
literal|"syst"
expr_stmt|;
name|errorStop
operator|=
name|FALSE
expr_stmt|;
name|forever
operator|=
name|FALSE
expr_stmt|;
name|maxErrorCount
operator|=
literal|20
expr_stmt|;
name|trueFlagsPtr
operator|=
operator|&
name|float_exception_flags
expr_stmt|;
name|testFlagsFunctionPtr
operator|=
name|syst_float_flags_clear
expr_stmt|;
name|tininessModeName
operator|=
literal|0
expr_stmt|;
name|functionArgument
operator|=
name|FALSE
expr_stmt|;
name|functionCode
operator|=
literal|0
expr_stmt|;
name|operands
operator|=
literal|0
expr_stmt|;
name|roundingPrecision
operator|=
literal|0
expr_stmt|;
name|roundingMode
operator|=
literal|0
expr_stmt|;
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
while|while
condition|(
name|argc
operator|&&
operator|(
name|argPtr
operator|=
name|argv
index|[
literal|0
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|argPtr
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
operator|++
name|argPtr
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|writeHelpMessage
label|:
name|fputs
argument_list|(
literal|"testfloat [<option>...]<function>\n"
literal|"<option>:  (* is default)\n"
literal|"    -help            --Write this message and exit.\n"
literal|"    -list            --List all testable functions and exit.\n"
literal|"    -level<num>     --Testing level<num> (1 or 2).\n"
literal|" *  -level 1\n"
literal|"    -errors<num>    --Stop each function test after<num> errors.\n"
literal|" *  -errors 20\n"
literal|"    -errorstop       --Exit after first function with any error.\n"
literal|"    -forever         --Test one function repeatedly (implies `-level 2').\n"
literal|"    -checkNaNs       --Check for bitwise correctness of NaN results.\n"
ifdef|#
directive|ifdef
name|FLOATX80
literal|"    -precision32     --Only test rounding precision equivalent to float32.\n"
literal|"    -precision64     --Only test rounding precision equivalent to float64.\n"
literal|"    -precision80     --Only test maximum rounding precision.\n"
endif|#
directive|endif
literal|"    -nearesteven     --Only test rounding to nearest/even.\n"
literal|"    -tozero          --Only test rounding to zero.\n"
literal|"    -down            --Only test rounding down.\n"
literal|"    -up              --Only test rounding up.\n"
literal|"    -tininessbefore  --Underflow tininess detected before rounding.\n"
literal|"    -tininessafter   --Underflow tininess detected after rounding.\n"
literal|"<function>:\n"
literal|"    int32_to_<float><float>_add<float>_eq\n"
literal|"<float>_to_int32<float>_sub<float>_le\n"
literal|"<float>_to_int32_round_to_zero<float>_mul<float>_lt\n"
ifdef|#
directive|ifdef
name|BITS64
literal|"    int64_to_<float><float>_div<float>_eq_signaling\n"
literal|"<float>_to_int64<float>_rem<float>_le_quiet\n"
literal|"<float>_to_int64_round_to_zero<float>_lt_quiet\n"
literal|"<float>_to_<float>\n"
literal|"<float>_round_to_int\n"
literal|"<float>_sqrt\n"
else|#
directive|else
literal|"<float>_to_<float><float>_div<float>_eq_signaling\n"
literal|"<float>_round_to_int<float>_rem<float>_le_quiet\n"
literal|"<float>_sqrt<float>_lt_quiet\n"
endif|#
directive|endif
literal|"    -all1            --All 1-operand functions.\n"
literal|"    -all2            --All 2-operand functions.\n"
literal|"    -all             --All functions.\n"
literal|"<float>:\n"
literal|"    float32          --Single precision.\n"
literal|"    float64          --Double precision.\n"
ifdef|#
directive|ifdef
name|FLOATX80
literal|"    floatx80         --Extended double precision.\n"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLOAT128
literal|"    float128         --Quadruple precision.\n"
endif|#
directive|endif
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|functionCode
operator|=
literal|1
init|;
name|functionCode
operator|<
name|NUM_FUNCTIONS
condition|;
operator|++
name|functionCode
control|)
block|{
if|if
condition|(
name|functionExists
index|[
name|functionCode
index|]
condition|)
block|{
name|puts
argument_list|(
name|functions
index|[
name|functionCode
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"level"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
goto|goto
name|optionError
goto|;
name|testCases_setLevel
argument_list|(
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"level1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|testCases_setLevel
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"level2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|testCases_setLevel
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"errors"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|optionError
label|:
name|fail
argument_list|(
literal|"`%s' option requires numeric argument"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|maxErrorCount
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"errorstop"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errorStop
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"forever"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|testCases_setLevel
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|forever
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"checkNaNs"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"checknans"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|checkNaNs
operator|=
name|TRUE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FLOATX80
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"precision32"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|roundingPrecision
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"precision64"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|roundingPrecision
operator|=
literal|64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"precision80"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|roundingPrecision
operator|=
literal|80
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"nearesteven"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"nearest_even"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|roundingMode
operator|=
name|ROUND_NEAREST_EVEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"tozero"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"to_zero"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|roundingMode
operator|=
name|ROUND_TO_ZERO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"down"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|roundingMode
operator|=
name|ROUND_DOWN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"up"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|roundingMode
operator|=
name|ROUND_UP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"tininessbefore"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|float_detect_tininess
operator|=
name|float_tininess_before_rounding
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"tininessafter"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|float_detect_tininess
operator|=
name|float_tininess_after_rounding
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"all1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|functionArgument
operator|=
name|TRUE
expr_stmt|;
name|functionCode
operator|=
literal|0
expr_stmt|;
name|operands
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"all2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|functionArgument
operator|=
name|TRUE
expr_stmt|;
name|functionCode
operator|=
literal|0
expr_stmt|;
name|operands
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|functionArgument
operator|=
name|TRUE
expr_stmt|;
name|functionCode
operator|=
literal|0
expr_stmt|;
name|operands
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|functionCode
operator|=
literal|1
init|;
name|functionCode
operator|<
name|NUM_FUNCTIONS
condition|;
operator|++
name|functionCode
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argPtr
argument_list|,
name|functions
index|[
name|functionCode
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|functionCode
operator|==
name|NUM_FUNCTIONS
condition|)
block|{
name|fail
argument_list|(
literal|"Invalid option or function `%s'"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|functionExists
index|[
name|functionCode
index|]
condition|)
block|{
name|fail
argument_list|(
literal|"Function `%s' is not supported or cannot be tested"
argument_list|,
name|argPtr
argument_list|)
expr_stmt|;
block|}
name|functionArgument
operator|=
name|TRUE
expr_stmt|;
block|}
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|functionArgument
condition|)
name|fail
argument_list|(
literal|"Function argument required"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catchSIGINT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|catchSIGINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|functionCode
condition|)
block|{
if|if
condition|(
name|forever
condition|)
block|{
if|if
condition|(
operator|!
name|roundingPrecision
condition|)
name|roundingPrecision
operator|=
literal|80
expr_stmt|;
if|if
condition|(
operator|!
name|roundingMode
condition|)
name|roundingMode
operator|=
name|ROUND_NEAREST_EVEN
expr_stmt|;
block|}
name|testFunction
argument_list|(
name|functionCode
argument_list|,
name|roundingPrecision
argument_list|,
name|roundingMode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|forever
condition|)
block|{
name|fail
argument_list|(
literal|"Can only test one function with `-forever' option"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operands
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|functionCode
operator|=
literal|1
init|;
name|functionCode
operator|<
name|NUM_FUNCTIONS
condition|;
operator|++
name|functionCode
control|)
block|{
if|if
condition|(
name|functionExists
index|[
name|functionCode
index|]
operator|&&
operator|(
name|functions
index|[
name|functionCode
index|]
operator|.
name|numInputs
operator|==
literal|1
operator|)
condition|)
block|{
name|testFunction
argument_list|(
name|functionCode
argument_list|,
name|roundingPrecision
argument_list|,
name|roundingMode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|operands
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|functionCode
operator|=
literal|1
init|;
name|functionCode
operator|<
name|NUM_FUNCTIONS
condition|;
operator|++
name|functionCode
control|)
block|{
if|if
condition|(
name|functionExists
index|[
name|functionCode
index|]
operator|&&
operator|(
name|functions
index|[
name|functionCode
index|]
operator|.
name|numInputs
operator|==
literal|2
operator|)
condition|)
block|{
name|testFunction
argument_list|(
name|functionCode
argument_list|,
name|roundingPrecision
argument_list|,
name|roundingMode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|functionCode
operator|=
literal|1
init|;
name|functionCode
operator|<
name|NUM_FUNCTIONS
condition|;
operator|++
name|functionCode
control|)
block|{
if|if
condition|(
name|functionExists
index|[
name|functionCode
index|]
condition|)
block|{
name|testFunction
argument_list|(
name|functionCode
argument_list|,
name|roundingPrecision
argument_list|,
name|roundingMode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|exitWithStatus
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

