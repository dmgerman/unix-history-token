begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $FreeBSD$  */
end_comment

begin_define
define|#
directive|define
name|_KERNEL
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/kse.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_comment
comment|/*#define DEBUG*/
end_comment

begin_comment
comment|/*************************************************************  * These should probably be in a .h file  **************************************************************/
end_comment

begin_typedef
typedef|typedef
name|void
name|thread_fn
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|user_thread
block|{
name|struct
name|thread_mailbox
name|mbox
decl_stmt|;
name|char
modifier|*
name|stack
decl_stmt|;
name|int
name|stack_size
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|user_thread
argument_list|)
name|runq_next
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|per_kse
block|{
name|struct
name|kse_mailbox
name|mbox
decl_stmt|;
name|struct
name|user_thread
modifier|*
name|curthread
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*************************************************************  * Debug stuff  **************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|jmp_buf
name|jb3
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DUMPREGS
parameter_list|(
name|desc
parameter_list|)
value|do {_setjmp(jb3); printjb(jb3, desc); } while (0)
end_define

begin_decl_stmt
name|char
modifier|*
name|regname
index|[]
init|=
block|{
literal|"%eip"
block|,
literal|"%ebx"
block|,
literal|"%esp"
block|,
literal|"%ebp"
block|,
literal|"%esi"
block|,
literal|"%edi"
block|,
literal|"fpcr"
block|,
literal|"MSK0"
block|,
literal|"MSK1"
block|,
literal|"MSK2"
block|,
literal|"MSK3"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|printjb
argument_list|(
argument|struct _jmp_buf *jb
argument_list|,
argument|char *desc
argument_list|)
block|{
name|int
name|i
block|;
name|printf
argument_list|(
literal|"jb (%s) is at 0x%x\n"
argument_list|,
name|desc
argument_list|,
name|jb
argument_list|)
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_JBLEN
operator|-
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"jb[%d] (%s) = 0x%x\n"
argument_list|,
name|i
argument_list|,
name|regname
index|[
name|i
index|]
argument_list|,
name|jb
index|[
literal|0
index|]
operator|.
name|_jb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
unit|}
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DUMPREGS
parameter_list|(
name|desc
parameter_list|)
value|do {} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*************************************************************  * Globals  **************************************************************/
end_comment

begin_decl_stmt
unit|struct
name|per_kse
name|first_kse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for NOW cheat and make it global */
end_comment

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|user_thread
argument_list|)
end_macro

begin_expr_stmt
name|runqueue
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|runqueue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*************************************************************  * Implementation parameters  **************************************************************/
end_comment

begin_define
define|#
directive|define
name|T_STACKSIZE
value|(16*4096)
end_define

begin_comment
comment|/* thread stacksize */
end_comment

begin_define
define|#
directive|define
name|K_STACKSIZE
value|(1*4096)
end_define

begin_comment
comment|/* KSE (UTS) stacksize */
end_comment

begin_comment
comment|/*************************************************************  * UTS funcions.  * Simple round_robin for now.  **************************************************************/
end_comment

begin_function
specifier|static
name|void
name|runq_insert
parameter_list|(
name|struct
name|user_thread
modifier|*
name|thread
parameter_list|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|runqueue
argument_list|,
name|thread
argument_list|,
name|runq_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|user_thread
modifier|*
name|select_thread
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|user_thread
modifier|*
name|thread
decl_stmt|;
if|if
condition|(
operator|(
name|thread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|runqueue
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|runqueue
argument_list|,
name|thread
argument_list|,
name|runq_next
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|thread
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************  * The UTS upcall entrypoint  * Called once on startup (and left by longjump)  * and there-after, returned to by the upcall many times.  **************************************************************/
end_comment

begin_function
name|void
name|UTS
parameter_list|(
name|struct
name|kse_mailbox
modifier|*
name|ke_mbox
parameter_list|)
block|{
name|struct
name|user_thread
modifier|*
name|thread
decl_stmt|;
name|struct
name|thread_mailbox
modifier|*
name|completed
decl_stmt|;
name|struct
name|per_kse
modifier|*
name|ksedata
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
comment|/**********************************/
comment|/* UTS upcall starts running here. */
comment|/**********************************/
comment|/**********************************/
name|ksedata
operator|=
name|ke_mbox
operator|->
name|kmbx_UTS_handle
expr_stmt|;
comment|/* If there are returned syscall threads, put them on the run queue */
if|if
condition|(
operator|(
name|completed
operator|=
name|ke_mbox
operator|->
name|kmbx_completed_threads
operator|)
condition|)
block|{
name|ke_mbox
operator|->
name|kmbx_completed_threads
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|completed
condition|)
block|{
name|thread
operator|=
name|completed
operator|->
name|UTS_handle
expr_stmt|;
name|completed
operator|=
name|completed
operator|->
name|next_completed
expr_stmt|;
name|runq_insert
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* find highest priority thread and load it */
if|if
condition|(
operator|(
name|thread
operator|=
name|select_thread
argument_list|()
operator|)
condition|)
block|{
name|ksedata
operator|->
name|curthread
operator|=
name|thread
expr_stmt|;
name|ke_mbox
operator|->
name|kmbx_current_thread
operator|=
operator|&
name|thread
operator|->
name|mbox
expr_stmt|;
comment|/* loads context similar to longjmp() */
name|loadthread
argument_list|(
operator|&
name|thread
operator|->
name|mbox
operator|.
name|ctx
operator|.
name|tfrm
operator|.
name|tf_tf
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|kse_yield
argument_list|()
expr_stmt|;
comment|/* in the kernel it does a thread_exit() */
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*************************************************************  * Startup mechanism functions  **************************************************************/
end_comment

begin_function
specifier|static
name|int
name|kickkse
parameter_list|(
name|struct
name|per_kse
modifier|*
name|ksedata
parameter_list|,
name|int
name|newgroup
parameter_list|)
block|{
name|char
modifier|*
name|newstack
decl_stmt|;
name|jmp_buf
name|jb1
decl_stmt|;
name|jmp_buf
name|jb2
decl_stmt|;
name|struct
name|kse_mailbox
modifier|*
name|mboxaddr
decl_stmt|;
name|struct
name|per_kse
modifier|*
name|user_UTS_info
decl_stmt|;
name|int
name|err
decl_stmt|;
name|newstack
operator|=
name|malloc
argument_list|(
name|K_STACKSIZE
argument_list|)
expr_stmt|;
name|mboxaddr
operator|=
operator|&
name|ksedata
operator|->
name|mbox
expr_stmt|;
name|mboxaddr
operator|->
name|kmbx_stackbase
operator|=
name|newstack
expr_stmt|;
name|mboxaddr
operator|->
name|kmbx_stacksize
operator|=
name|K_STACKSIZE
expr_stmt|;
name|mboxaddr
operator|->
name|kmbx_upcall
operator|=
operator|&
name|UTS
expr_stmt|;
name|mboxaddr
operator|->
name|kmbx_UTS_handle
operator|=
name|ksedata
expr_stmt|;
name|err
operator|=
name|kse_new
argument_list|(
name|mboxaddr
argument_list|,
name|newgroup
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|startkse
parameter_list|(
name|struct
name|per_kse
modifier|*
name|ksedata
parameter_list|)
block|{
return|return
operator|(
name|kickkse
argument_list|(
name|ksedata
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|startksegrp
parameter_list|(
name|struct
name|per_kse
modifier|*
name|ksedata
parameter_list|)
block|{
return|return
operator|(
name|kickkse
argument_list|(
name|ksedata
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|badreturn
parameter_list|()
block|{
name|printf
argument_list|(
literal|"thread returned when shouldn't\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|__inline__
name|void
name|pushontostack
parameter_list|(
name|struct
name|user_thread
modifier|*
name|tcb
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|int
modifier|*
name|SP
decl_stmt|;
name|SP
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|tcb
operator|->
name|mbox
operator|.
name|ctx
operator|.
name|tfrm
operator|.
name|tf_tf
operator|.
name|tf_isp
operator|)
expr_stmt|;
operator|*
operator|--
name|SP
operator|=
name|value
expr_stmt|;
name|tcb
operator|->
name|mbox
operator|.
name|ctx
operator|.
name|tfrm
operator|.
name|tf_tf
operator|.
name|tf_isp
operator|=
operator|(
name|int
operator|)
name|SP
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|user_thread
modifier|*
name|makethread
parameter_list|(
name|thread_fn
modifier|*
name|fn
parameter_list|,
name|int
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|user_thread
modifier|*
name|tcb
decl_stmt|;
comment|/* We could combine these mallocs */
name|tcb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|tcb
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|tcb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tcb
argument_list|)
argument_list|)
expr_stmt|;
name|tcb
operator|->
name|mbox
operator|.
name|UTS_handle
operator|=
name|tcb
expr_stmt|;
comment|/* back pointer */
comment|/* malloc the thread's stack */
comment|/* We COULD mmap it with STACK characteristics */
comment|/* Then we could add a guard page. */
name|tcb
operator|->
name|stack_size
operator|=
name|T_STACKSIZE
expr_stmt|;
comment|/* set the size we want */
name|tcb
operator|->
name|stack
operator|=
name|malloc
argument_list|(
name|tcb
operator|->
name|stack_size
argument_list|)
expr_stmt|;
comment|/* Make sure there are good defaults */
name|savethread
argument_list|(
operator|&
name|tcb
operator|->
name|mbox
operator|.
name|ctx
operator|.
name|tfrm
operator|.
name|tf_tf
argument_list|)
expr_stmt|;
comment|/* set the PC to the fn */
name|tcb
operator|->
name|mbox
operator|.
name|ctx
operator|.
name|tfrm
operator|.
name|tf_tf
operator|.
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|fn
expr_stmt|;
comment|/* Set the stack and push on the args and a dummy return address */
name|tcb
operator|->
name|mbox
operator|.
name|ctx
operator|.
name|tfrm
operator|.
name|tf_tf
operator|.
name|tf_ebp
operator|=
name|tcb
operator|->
name|mbox
operator|.
name|ctx
operator|.
name|tfrm
operator|.
name|tf_tf
operator|.
name|tf_isp
operator|=
name|tcb
operator|->
name|mbox
operator|.
name|ctx
operator|.
name|tfrm
operator|.
name|tf_tf
operator|.
name|tf_esp
operator|=
call|(
name|int
call|)
argument_list|(
operator|&
name|tcb
operator|->
name|stack
index|[
name|tcb
operator|->
name|stack_size
operator|-
literal|16
index|]
argument_list|)
expr_stmt|;
name|pushontostack
argument_list|(
name|tcb
argument_list|,
operator|(
name|int
operator|)
name|arg2
argument_list|)
expr_stmt|;
name|pushontostack
argument_list|(
name|tcb
argument_list|,
operator|(
name|int
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|pushontostack
argument_list|(
name|tcb
argument_list|,
operator|(
name|int
operator|)
operator|&
name|badreturn
argument_list|)
expr_stmt|;
comment|/* safety return address */
return|return
operator|(
name|tcb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************  * code for three separate threads. (so we can see if it works)  *************************************************************/
end_comment

begin_function
specifier|static
name|void
name|thread1_code
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|thread2_code
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|thread3_code
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
literal|"="
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|()
block|{
comment|/* set up global structures */
name|TAILQ_INIT
argument_list|(
operator|&
name|runqueue
argument_list|)
expr_stmt|;
comment|/* define two threads to run, they are runnable but not yet running */
name|runq_insert
argument_list|(
name|makethread
argument_list|(
operator|&
name|thread1_code
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|runq_insert
argument_list|(
name|makethread
argument_list|(
operator|&
name|thread2_code
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and one which we will run ourself */
name|first_kse
operator|.
name|curthread
operator|=
name|makethread
argument_list|(
operator|&
name|thread3_code
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* start two KSEs in different KSEGRPs */
if|if
condition|(
name|startkse
argument_list|(
operator|&
name|first_kse
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"failed to start KSE"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* startksegrp(&second_kse); */
comment|/* we can't do 2 KSEs yet */
comment|/* One will be sufficient */
comment|/* we are a thread, start the ball rolling */
comment|/* let the kernel know we are it */
name|first_kse
operator|.
name|mbox
operator|.
name|kmbx_current_thread
operator|=
operator|&
name|first_kse
operator|.
name|curthread
operator|->
name|mbox
expr_stmt|;
name|thread3_code
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

