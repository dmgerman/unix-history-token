begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.  */
end_comment

begin_comment
comment|/*  * This file is a sewer.  */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<uts/common/sys/ctf.h>
end_include

begin_include
include|#
directive|include
file|"ctftools.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"list.h"
end_include

begin_define
define|#
directive|define
name|HASH
parameter_list|(
name|NUM
parameter_list|)
value|((int)(NUM& (BUCKETS - 1)))
end_define

begin_define
define|#
directive|define
name|BUCKETS
value|128
end_define

begin_define
define|#
directive|define
name|TYPEPAIRMULT
value|10000
end_define

begin_define
define|#
directive|define
name|MAKETYPEID
parameter_list|(
name|file
parameter_list|,
name|num
parameter_list|)
value|((file) * TYPEPAIRMULT + num)
end_define

begin_define
define|#
directive|define
name|TYPEFILE
parameter_list|(
name|tid
parameter_list|)
value|((tid) / TYPEPAIRMULT)
end_define

begin_define
define|#
directive|define
name|TYPENUM
parameter_list|(
name|tid
parameter_list|)
value|((tid) % TYPEPAIRMULT)
end_define

begin_define
define|#
directive|define
name|expected
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|_expected(a, b, c, __LINE__)
end_define

begin_decl_stmt
specifier|static
name|int
name|faketypenumber
init|=
literal|100000000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tdesc_t
modifier|*
name|hash_table
index|[
name|BUCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tdesc_t
modifier|*
name|name_table
index|[
name|BUCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|list_t
modifier|*
name|typedbitfldmems
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|reset
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|jmp_buf
name|resetbuf
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|soudef
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|stabtype_t
name|type
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|rtdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|enumdef
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|rtdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compute_sum
parameter_list|(
specifier|const
name|char
modifier|*
name|w
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|number
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|int
modifier|*
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|name
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|char
modifier|*
modifier|*
name|w
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|id
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|int
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|whitesp
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|addhash
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tagadd
parameter_list|(
name|char
modifier|*
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|tdefdecl
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|h
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|rtdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|intrinsic
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|rtdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|arraydef
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|rtdp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|debug_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug_parse
init|=
name|DEBUG_PARSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*PRINTFLIKE3*/
end_comment

begin_function
specifier|static
name|void
name|parse_debug
parameter_list|(
name|int
name|level
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|tmp
index|[
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|level
operator|>
name|debug_level
operator|||
operator|!
name|debug_parse
condition|)
return|return;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cp
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|!
name|iscntrl
argument_list|(
name|cp
index|[
name|i
index|]
argument_list|)
condition|)
name|tmp
index|[
name|i
index|]
operator|=
name|cp
index|[
name|i
index|]
expr_stmt|;
block|}
name|tmp
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s [cp='%s']\n"
argument_list|,
name|fmt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vadebug
argument_list|(
name|level
argument_list|,
name|buf
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report unexpected syntax in stabs. */
end_comment

begin_function
specifier|static
name|void
name|_expected
parameter_list|(
name|char
modifier|*
name|who
parameter_list|,
comment|/* what function, or part thereof, is reporting */
name|char
modifier|*
name|what
parameter_list|,
comment|/* what was expected */
name|char
modifier|*
name|where
parameter_list|,
comment|/* where we were in the line of input */
name|int
name|line
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, expecting \"%s\" at \"%s\"\n"
argument_list|,
name|who
argument_list|,
name|what
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"code line: %d, file %s\n"
argument_list|,
name|line
argument_list|,
operator|(
name|curhdr
condition|?
name|curhdr
else|:
literal|"NO FILE"
operator|)
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|parse_init
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUCKETS
condition|;
name|i
operator|++
control|)
block|{
name|hash_table
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|name_table
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|typedbitfldmems
operator|!=
name|NULL
condition|)
block|{
name|list_free
argument_list|(
name|typedbitfldmems
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|typedbitfldmems
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|parse_finish
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|)
block|{
name|td
operator|->
name|td_nextid
operator|=
operator|++
name|faketypenumber
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|unres_new
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp
decl_stmt|;
name|tdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tdp
argument_list|)
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_type
operator|=
name|TYPEDEF_UNRES
expr_stmt|;
name|tdp
operator|->
name|t_id
operator|=
name|tid
expr_stmt|;
return|return
operator|(
name|tdp
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|read_tid
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|tdpp
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp
decl_stmt|;
name|int
name|tid
decl_stmt|;
name|cp
operator|=
name|id
argument_list|(
name|cp
argument_list|,
operator|&
name|tid
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tid
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|tdefdecl
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|tid
argument_list|,
operator|&
name|tdp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|tdp
operator|->
name|t_id
operator|&&
name|tdp
operator|->
name|t_id
operator|!=
name|tid
condition|)
block|{
name|tdesc_t
modifier|*
name|ntdp
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ntdp
argument_list|)
argument_list|)
decl_stmt|;
name|ntdp
operator|->
name|t_type
operator|=
name|TYPEDEF
expr_stmt|;
name|ntdp
operator|->
name|t_tdesc
operator|=
name|tdp
expr_stmt|;
name|tdp
operator|=
name|ntdp
expr_stmt|;
block|}
name|addhash
argument_list|(
name|tdp
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tdp
operator|=
name|lookup
argument_list|(
name|tid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tdp
operator|=
name|unres_new
argument_list|(
name|tid
argument_list|)
expr_stmt|;
operator|*
name|tdpp
operator|=
name|tdp
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|iitype_t
name|parse_fun
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|iidesc_t
modifier|*
name|ii
parameter_list|)
block|{
name|iitype_t
name|iitype
decl_stmt|;
name|tdesc_t
modifier|*
name|tdp
decl_stmt|;
name|tdesc_t
modifier|*
modifier|*
name|args
init|=
name|NULL
decl_stmt|;
name|int
name|nargs
init|=
literal|0
decl_stmt|;
name|int
name|va
init|=
literal|0
decl_stmt|;
comment|/* 	 * name:P		prototype 	 * name:F		global function 	 * name:f		static function 	 */
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|'P'
case|:
name|iitype
operator|=
name|II_NOT
expr_stmt|;
comment|/* not interesting */
break|break;
case|case
literal|'F'
case|:
name|iitype
operator|=
name|II_GFUN
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|iitype
operator|=
name|II_SFUN
expr_stmt|;
break|break;
default|default:
name|expected
argument_list|(
literal|"parse_nfun"
argument_list|,
literal|"[PfF]"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|read_tid
argument_list|(
name|cp
argument_list|,
operator|&
name|tdp
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|cp
condition|)
name|args
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
operator|*
argument_list|)
operator|*
name|FUNCARG_DEF
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
operator|++
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'0'
condition|)
block|{
name|va
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|nargs
operator|++
expr_stmt|;
if|if
condition|(
name|nargs
operator|>
name|FUNCARG_DEF
condition|)
name|args
operator|=
name|xrealloc
argument_list|(
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|tdesc_t
operator|*
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|read_tid
argument_list|(
name|cp
argument_list|,
operator|&
name|args
index|[
name|nargs
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ii
operator|->
name|ii_type
operator|=
name|iitype
expr_stmt|;
name|ii
operator|->
name|ii_dtype
operator|=
name|tdp
expr_stmt|;
name|ii
operator|->
name|ii_nargs
operator|=
name|nargs
expr_stmt|;
name|ii
operator|->
name|ii_args
operator|=
name|args
expr_stmt|;
name|ii
operator|->
name|ii_vargs
operator|=
name|va
expr_stmt|;
return|return
operator|(
name|iitype
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|iitype_t
name|parse_sym
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|iidesc_t
modifier|*
name|ii
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp
decl_stmt|;
name|iitype_t
name|iitype
decl_stmt|;
comment|/* 	 * name:G		global variable 	 * name:S		static variable 	 */
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|'G'
case|:
name|iitype
operator|=
name|II_GVAR
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|iitype
operator|=
name|II_SVAR
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|iitype
operator|=
name|II_PSYM
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|cp
operator|--
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|'r'
case|:
case|case
literal|'V'
case|:
name|iitype
operator|=
name|II_NOT
expr_stmt|;
comment|/* not interesting */
break|break;
default|default:
name|expected
argument_list|(
literal|"parse_sym"
argument_list|,
literal|"[GprSV(]"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|read_tid
argument_list|(
name|cp
argument_list|,
operator|&
name|tdp
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ii
operator|->
name|ii_type
operator|=
name|iitype
expr_stmt|;
name|ii
operator|->
name|ii_dtype
operator|=
name|tdp
expr_stmt|;
return|return
operator|(
name|iitype
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|iitype_t
name|parse_type
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|iidesc_t
modifier|*
name|ii
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp
decl_stmt|,
modifier|*
name|ntdp
decl_stmt|;
name|int
name|tid
decl_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'t'
condition|)
name|expected
argument_list|(
literal|"parse_type"
argument_list|,
literal|"t (type)"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|id
argument_list|(
name|cp
argument_list|,
operator|&
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tdp
operator|=
name|lookup
argument_list|(
name|tid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'='
condition|)
name|expected
argument_list|(
literal|"parse_type"
argument_list|,
literal|"= (definition)"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tdefdecl
argument_list|(
name|cp
argument_list|,
name|tid
argument_list|,
operator|&
name|tdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_id
operator|==
name|tid
condition|)
block|{
name|assert
argument_list|(
name|tdp
operator|->
name|t_type
operator|!=
name|TYPEDEF
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|lookup
argument_list|(
name|tdp
operator|->
name|t_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|streq
argument_list|(
name|tdp
operator|->
name|t_name
argument_list|,
name|ii
operator|->
name|ii_name
argument_list|)
condition|)
block|{
name|ntdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ntdp
argument_list|)
argument_list|)
expr_stmt|;
name|ntdp
operator|->
name|t_name
operator|=
name|xstrdup
argument_list|(
name|ii
operator|->
name|ii_name
argument_list|)
expr_stmt|;
name|ntdp
operator|->
name|t_type
operator|=
name|TYPEDEF
expr_stmt|;
name|ntdp
operator|->
name|t_tdesc
operator|=
name|tdp
expr_stmt|;
name|tdp
operator|->
name|t_id
operator|=
name|faketypenumber
operator|++
expr_stmt|;
name|tdp
operator|=
name|ntdp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tdp
operator|->
name|t_id
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|tdp
operator|->
name|t_type
operator|==
name|FORWARD
operator|||
name|tdp
operator|->
name|t_type
operator|==
name|INTRINSIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_name
operator|&&
operator|!
name|streq
argument_list|(
name|tdp
operator|->
name|t_name
argument_list|,
name|ii
operator|->
name|ii_name
argument_list|)
condition|)
block|{
name|ntdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ntdp
argument_list|)
argument_list|)
expr_stmt|;
name|ntdp
operator|->
name|t_name
operator|=
name|xstrdup
argument_list|(
name|ii
operator|->
name|ii_name
argument_list|)
expr_stmt|;
name|ntdp
operator|->
name|t_type
operator|=
name|TYPEDEF
expr_stmt|;
name|ntdp
operator|->
name|t_tdesc
operator|=
name|tdp
expr_stmt|;
name|tdp
operator|->
name|t_id
operator|=
name|faketypenumber
operator|++
expr_stmt|;
name|tdp
operator|=
name|ntdp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tdp
operator|->
name|t_id
operator|!=
name|tid
condition|)
block|{
name|ntdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ntdp
argument_list|)
argument_list|)
expr_stmt|;
name|ntdp
operator|->
name|t_name
operator|=
name|xstrdup
argument_list|(
name|ii
operator|->
name|ii_name
argument_list|)
expr_stmt|;
name|ntdp
operator|->
name|t_type
operator|=
name|TYPEDEF
expr_stmt|;
name|ntdp
operator|->
name|t_tdesc
operator|=
name|tdp
expr_stmt|;
name|tdp
operator|=
name|ntdp
expr_stmt|;
block|}
if|if
condition|(
name|tagadd
argument_list|(
name|ii
operator|->
name|ii_name
argument_list|,
name|tid
argument_list|,
name|tdp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ii
operator|->
name|ii_type
operator|=
name|II_TYPE
expr_stmt|;
name|ii
operator|->
name|ii_dtype
operator|=
name|tdp
expr_stmt|;
return|return
operator|(
name|II_TYPE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|iitype_t
name|parse_sou
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|iidesc_t
modifier|*
name|idp
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|rtdp
decl_stmt|;
name|int
name|tid
decl_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'T'
condition|)
name|expected
argument_list|(
literal|"parse_sou"
argument_list|,
literal|"T (sou)"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|id
argument_list|(
name|cp
argument_list|,
operator|&
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'='
condition|)
name|expected
argument_list|(
literal|"parse_sou"
argument_list|,
literal|"= (definition)"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|parse_debug
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"parse_sou: declaring '%s'"
argument_list|,
name|idp
operator|->
name|ii_name
condition|?
name|idp
operator|->
name|ii_name
else|:
literal|"(anon)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rtdp
operator|=
name|lookup
argument_list|(
name|tid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|idp
operator|->
name|ii_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rtdp
operator|->
name|t_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|rtdp
operator|->
name|t_name
argument_list|,
name|idp
operator|->
name|ii_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tdesc_t
modifier|*
name|tdp
decl_stmt|;
name|tdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tdp
argument_list|)
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_name
operator|=
name|xstrdup
argument_list|(
name|idp
operator|->
name|ii_name
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_type
operator|=
name|TYPEDEF
expr_stmt|;
name|tdp
operator|->
name|t_tdesc
operator|=
name|rtdp
expr_stmt|;
name|addhash
argument_list|(
name|tdp
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* for *(x,y) types */
name|parse_debug
argument_list|(
literal|3
argument_list|,
name|NULL
argument_list|,
literal|"    %s defined as %s(%d)"
argument_list|,
name|idp
operator|->
name|ii_name
argument_list|,
name|tdesc_name
argument_list|(
name|rtdp
argument_list|)
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtdp
operator|->
name|t_name
operator|==
name|NULL
condition|)
block|{
name|rtdp
operator|->
name|t_name
operator|=
name|xstrdup
argument_list|(
name|idp
operator|->
name|ii_name
argument_list|)
expr_stmt|;
name|addhash
argument_list|(
name|rtdp
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|rtdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rtdp
argument_list|)
argument_list|)
expr_stmt|;
name|rtdp
operator|->
name|t_name
operator|=
name|idp
operator|->
name|ii_name
condition|?
name|xstrdup
argument_list|(
name|idp
operator|->
name|ii_name
argument_list|)
else|:
name|NULL
expr_stmt|;
name|addhash
argument_list|(
name|rtdp
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|'s'
case|:
operator|(
name|void
operator|)
name|soudef
argument_list|(
name|cp
argument_list|,
name|STRUCT
argument_list|,
operator|&
name|rtdp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
operator|(
name|void
operator|)
name|soudef
argument_list|(
name|cp
argument_list|,
name|UNION
argument_list|,
operator|&
name|rtdp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|enumdef
argument_list|(
name|cp
argument_list|,
operator|&
name|rtdp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|expected
argument_list|(
literal|"parse_sou"
argument_list|,
literal|"<tag type s/u/e>"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|idp
operator|->
name|ii_type
operator|=
name|II_SOU
expr_stmt|;
name|idp
operator|->
name|ii_dtype
operator|=
name|rtdp
expr_stmt|;
return|return
operator|(
name|II_SOU
operator|)
return|;
block|}
end_function

begin_function
name|int
name|parse_stab
parameter_list|(
name|stab_t
modifier|*
name|stab
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|,
name|iidesc_t
modifier|*
modifier|*
name|iidescp
parameter_list|)
block|{
name|iidesc_t
modifier|*
name|ii
init|=
name|NULL
decl_stmt|;
name|iitype_t
function_decl|(
modifier|*
name|parse
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|iidesc_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|rc
decl_stmt|;
comment|/* 	 * set up for reset() 	 */
if|if
condition|(
name|setjmp
argument_list|(
name|resetbuf
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|whitesp
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ii
operator|=
name|iidesc_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|cp
operator|=
name|name
argument_list|(
name|cp
argument_list|,
operator|&
name|ii
operator|->
name|ii_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|stab
operator|->
name|n_type
condition|)
block|{
case|case
name|N_FUN
case|:
name|parse
operator|=
name|parse_fun
expr_stmt|;
break|break;
case|case
name|N_LSYM
case|:
if|if
condition|(
operator|*
name|cp
operator|==
literal|'t'
condition|)
name|parse
operator|=
name|parse_type
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'T'
condition|)
name|parse
operator|=
name|parse_sou
expr_stmt|;
else|else
name|parse
operator|=
name|parse_sym
expr_stmt|;
break|break;
case|case
name|N_GSYM
case|:
case|case
name|N_LCSYM
case|:
case|case
name|N_PSYM
case|:
case|case
name|N_ROSYM
case|:
case|case
name|N_RSYM
case|:
case|case
name|N_STSYM
case|:
name|parse
operator|=
name|parse_sym
expr_stmt|;
break|break;
default|default:
name|parse_debug
argument_list|(
literal|1
argument_list|,
name|cp
argument_list|,
literal|"Unknown stab type %#x"
argument_list|,
name|stab
operator|->
name|n_type
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|resetbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|resetbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rc
operator|=
name|parse
argument_list|(
name|cp
argument_list|,
name|ii
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|resetbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|resetbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
operator|||
name|ii
operator|->
name|ii_type
operator|==
name|II_NOT
condition|)
block|{
name|iidesc_free
argument_list|(
name|ii
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
operator|*
name|iidescp
operator|=
name|ii
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if we have this node in the hash table already  */
end_comment

begin_function
name|tdesc_t
modifier|*
name|lookup
parameter_list|(
name|int
name|h
parameter_list|)
block|{
name|int
name|bucket
init|=
name|HASH
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|tdesc_t
modifier|*
name|tdp
init|=
name|hash_table
index|[
name|bucket
index|]
decl_stmt|;
while|while
condition|(
name|tdp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tdp
operator|->
name|t_id
operator|==
name|h
condition|)
return|return
operator|(
name|tdp
operator|)
return|;
name|tdp
operator|=
name|tdp
operator|->
name|t_hash
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|whitesp
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|cp
operator|++
init|;
name|isspace
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
operator|*
name|cp
operator|++
control|)
empty_stmt|;
operator|--
name|cp
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|name
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|char
modifier|*
modifier|*
name|w
parameter_list|)
block|{
name|char
modifier|*
name|new
decl_stmt|,
modifier|*
name|orig
decl_stmt|,
name|c
decl_stmt|;
name|int
name|len
decl_stmt|;
name|orig
operator|=
name|cp
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
operator|*
name|w
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"_.$#"
argument_list|,
name|c
argument_list|)
condition|)
block|{
for|for
control|(
name|c
operator|=
operator|*
name|cp
operator|++
init|;
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|strchr
argument_list|(
literal|" _.$#"
argument_list|,
name|c
argument_list|)
condition|;
name|c
operator|=
operator|*
name|cp
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
name|reset
argument_list|()
expr_stmt|;
name|len
operator|=
name|cp
operator|-
name|orig
expr_stmt|;
name|new
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|orig
operator|<
name|cp
operator|-
literal|1
condition|)
operator|*
name|new
operator|++
operator|=
operator|*
name|orig
operator|++
expr_stmt|;
operator|*
name|new
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|w
operator|=
name|new
operator|-
operator|(
name|len
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
name|reset
argument_list|()
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|number
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|int
modifier|*
name|n
parameter_list|)
block|{
name|char
modifier|*
name|next
decl_stmt|;
operator|*
name|n
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|next
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|cp
condition|)
name|expected
argument_list|(
literal|"number"
argument_list|,
literal|"<number>"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|id
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|int
modifier|*
name|h
parameter_list|)
block|{
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
condition|)
block|{
comment|/* SunPro style */
name|cp
operator|++
expr_stmt|;
name|cp
operator|=
name|number
argument_list|(
name|cp
argument_list|,
operator|&
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|','
condition|)
name|expected
argument_list|(
literal|"id"
argument_list|,
literal|","
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|number
argument_list|(
name|cp
argument_list|,
operator|&
name|n2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|')'
condition|)
name|expected
argument_list|(
literal|"id"
argument_list|,
literal|")"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|h
operator|=
name|MAKETYPEID
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
comment|/* gcc style */
name|cp
operator|=
name|number
argument_list|(
name|cp
argument_list|,
operator|&
name|n1
argument_list|)
expr_stmt|;
operator|*
name|h
operator|=
name|n1
expr_stmt|;
block|}
else|else
block|{
name|expected
argument_list|(
literal|"id"
argument_list|,
literal|"(/0-9"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tagadd
parameter_list|(
name|char
modifier|*
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|otdp
decl_stmt|;
name|tdp
operator|->
name|t_name
operator|=
name|w
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|otdp
operator|=
name|lookup
argument_list|(
name|h
argument_list|)
operator|)
condition|)
name|addhash
argument_list|(
name|tdp
argument_list|,
name|h
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|otdp
operator|!=
name|tdp
condition|)
block|{
name|warning
argument_list|(
literal|"duplicate entry\n"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  old: %s %d (%d,%d)\n"
argument_list|,
name|tdesc_name
argument_list|(
name|otdp
argument_list|)
argument_list|,
name|otdp
operator|->
name|t_type
argument_list|,
name|TYPEFILE
argument_list|(
name|otdp
operator|->
name|t_id
argument_list|)
argument_list|,
name|TYPENUM
argument_list|(
name|otdp
operator|->
name|t_id
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  new: %s %d (%d,%d)\n"
argument_list|,
name|tdesc_name
argument_list|(
name|tdp
argument_list|)
argument_list|,
name|tdp
operator|->
name|t_type
argument_list|,
name|TYPEFILE
argument_list|(
name|tdp
operator|->
name|t_id
argument_list|)
argument_list|,
name|TYPENUM
argument_list|(
name|tdp
operator|->
name|t_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|tdefdecl
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|h
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|rtdp
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|ntdp
decl_stmt|;
name|char
modifier|*
name|w
decl_stmt|;
name|int
name|c
decl_stmt|,
name|h2
decl_stmt|;
name|char
name|type
decl_stmt|;
name|parse_debug
argument_list|(
literal|3
argument_list|,
name|cp
argument_list|,
literal|"tdefdecl h=%d"
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Type codes */
switch|switch
condition|(
name|type
operator|=
operator|*
name|cp
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* integer */
case|case
literal|'R'
case|:
comment|/* fp */
name|cp
operator|=
name|intrinsic
argument_list|(
name|cp
argument_list|,
name|rtdp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
comment|/* equiv to another type */
name|cp
operator|=
name|id
argument_list|(
name|cp
argument_list|,
operator|&
name|h2
argument_list|)
expr_stmt|;
name|ntdp
operator|=
name|lookup
argument_list|(
name|h2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntdp
operator|!=
name|NULL
operator|&&
operator|*
name|cp
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|ntdp
operator|->
name|t_type
operator|==
name|FORWARD
operator|&&
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|==
literal|'x'
condition|)
block|{
comment|/* 				 * The 6.2 compiler, and possibly others, will 				 * sometimes emit the same stab for a forward 				 * declaration twice.  That is, "(1,2)=xsfoo:" 				 * will sometimes show up in two different 				 * places.  This is, of course, quite fun.  We 				 * want CTF to work in spite of the compiler, 				 * so we'll let this one through. 				 */
name|char
modifier|*
name|c2
init|=
name|cp
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
literal|"sue"
argument_list|,
operator|*
name|c2
operator|++
argument_list|)
condition|)
block|{
name|expected
argument_list|(
literal|"tdefdecl/x-redefine"
argument_list|,
literal|"[sue]"
argument_list|,
name|c2
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|c2
operator|=
name|name
argument_list|(
name|c2
argument_list|,
operator|&
name|nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nm
argument_list|,
name|ntdp
operator|->
name|t_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|terminate
argument_list|(
literal|"Stabs error: Attempt to "
literal|"redefine type (%d,%d) as "
literal|"something else: %s\n"
argument_list|,
name|TYPEFILE
argument_list|(
name|h2
argument_list|)
argument_list|,
name|TYPENUM
argument_list|(
name|h2
argument_list|)
argument_list|,
name|c2
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|h2
operator|=
name|faketypenumber
operator|++
expr_stmt|;
name|ntdp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|terminate
argument_list|(
literal|"Stabs error: Attempting to "
literal|"redefine type (%d,%d)\n"
argument_list|,
name|TYPEFILE
argument_list|(
name|h2
argument_list|)
argument_list|,
name|TYPENUM
argument_list|(
name|h2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ntdp
operator|==
name|NULL
condition|)
block|{
comment|/* if that type isn't defined yet */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'='
condition|)
block|{
comment|/* record it as unresolved */
name|parse_debug
argument_list|(
literal|3
argument_list|,
name|NULL
argument_list|,
literal|"tdefdecl unres type %d"
argument_list|,
name|h2
argument_list|)
expr_stmt|;
operator|*
name|rtdp
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|rtdp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_type
operator|=
name|TYPEDEF_UNRES
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_id
operator|=
name|h2
expr_stmt|;
break|break;
block|}
else|else
name|cp
operator|++
expr_stmt|;
comment|/* define a new type */
name|cp
operator|=
name|tdefdecl
argument_list|(
name|cp
argument_list|,
name|h2
argument_list|,
name|rtdp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_id
operator|&&
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_id
operator|!=
name|h2
condition|)
block|{
name|ntdp
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ntdp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ntdp
operator|->
name|t_type
operator|=
name|TYPEDEF
expr_stmt|;
name|ntdp
operator|->
name|t_tdesc
operator|=
operator|*
name|rtdp
expr_stmt|;
operator|*
name|rtdp
operator|=
name|ntdp
expr_stmt|;
block|}
name|addhash
argument_list|(
operator|*
name|rtdp
argument_list|,
name|h2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* that type is already defined */
if|if
condition|(
name|ntdp
operator|->
name|t_type
operator|!=
name|TYPEDEF
operator|||
name|ntdp
operator|->
name|t_name
operator|!=
name|NULL
condition|)
block|{
operator|*
name|rtdp
operator|=
name|ntdp
expr_stmt|;
block|}
else|else
block|{
name|parse_debug
argument_list|(
literal|3
argument_list|,
name|NULL
argument_list|,
literal|"No duplicate typedef anon for ref"
argument_list|)
expr_stmt|;
operator|*
name|rtdp
operator|=
name|ntdp
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'*'
case|:
name|ntdp
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|tdefdecl
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|h
argument_list|,
operator|&
name|ntdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntdp
operator|==
name|NULL
condition|)
name|expected
argument_list|(
literal|"tdefdecl/*"
argument_list|,
literal|"id"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ntdp
operator|->
name|t_id
condition|)
name|ntdp
operator|->
name|t_id
operator|=
name|faketypenumber
operator|++
expr_stmt|;
operator|*
name|rtdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|rtdp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_type
operator|=
name|POINTER
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_size
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_id
operator|=
name|h
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_tdesc
operator|=
name|ntdp
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|cp
operator|=
name|tdefdecl
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|h
argument_list|,
operator|&
name|ntdp
argument_list|)
expr_stmt|;
operator|*
name|rtdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|rtdp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_type
operator|=
name|FUNCTION
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_size
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_id
operator|=
name|h
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_fndef
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fndef_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * The 6.1 compiler will sometimes generate incorrect stabs for 		 * function pointers (it'll get the return type wrong).  This 		 * causes merges to fail.  We therefore treat function pointers 		 * as if they all point to functions that return int.  When 		 * 4432549 is fixed, the lookupname() call below should be 		 * replaced with `ntdp'. 		 */
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_fndef
operator|->
name|fn_ret
operator|=
name|lookupname
argument_list|(
literal|"int"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
case|case
literal|'z'
case|:
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'r'
condition|)
name|expected
argument_list|(
literal|"tdefdecl/[az]"
argument_list|,
literal|"r"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|rtdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|rtdp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_type
operator|=
name|ARRAY
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_id
operator|=
name|h
expr_stmt|;
name|cp
operator|=
name|arraydef
argument_list|(
name|cp
argument_list|,
name|rtdp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|c
operator|=
operator|*
operator|++
name|cp
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'s'
operator|&&
name|c
operator|!=
literal|'u'
operator|&&
name|c
operator|!=
literal|'e'
condition|)
name|expected
argument_list|(
literal|"tdefdecl/x"
argument_list|,
literal|"[sue]"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|name
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
name|ntdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ntdp
argument_list|)
argument_list|)
expr_stmt|;
name|ntdp
operator|->
name|t_type
operator|=
name|FORWARD
expr_stmt|;
name|ntdp
operator|->
name|t_name
operator|=
name|w
expr_stmt|;
comment|/* 		 * We explicitly don't set t_id here - the caller will do it. 		 * The caller may want to use a real type ID, or they may 		 * choose to make one up. 		 */
operator|*
name|rtdp
operator|=
name|ntdp
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* volatile */
name|cp
operator|=
name|tdefdecl
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|h
argument_list|,
operator|&
name|ntdp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ntdp
operator|->
name|t_id
condition|)
name|ntdp
operator|->
name|t_id
operator|=
name|faketypenumber
operator|++
expr_stmt|;
operator|*
name|rtdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|rtdp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_type
operator|=
name|VOLATILE
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_size
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_tdesc
operator|=
name|ntdp
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_id
operator|=
name|h
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* const */
name|cp
operator|=
name|tdefdecl
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|h
argument_list|,
operator|&
name|ntdp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ntdp
operator|->
name|t_id
condition|)
name|ntdp
operator|->
name|t_id
operator|=
name|faketypenumber
operator|++
expr_stmt|;
operator|*
name|rtdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|rtdp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_type
operator|=
name|CONST
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_size
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_tdesc
operator|=
name|ntdp
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_id
operator|=
name|h
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
comment|/* restricted */
name|cp
operator|=
name|tdefdecl
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|h
argument_list|,
operator|&
name|ntdp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ntdp
operator|->
name|t_id
condition|)
name|ntdp
operator|->
name|t_id
operator|=
name|faketypenumber
operator|++
expr_stmt|;
operator|*
name|rtdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|rtdp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_type
operator|=
name|RESTRICT
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_size
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_tdesc
operator|=
name|ntdp
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_id
operator|=
name|h
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'s'
case|:
name|cp
operator|++
expr_stmt|;
operator|*
name|rtdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|rtdp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_name
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|soudef
argument_list|(
name|cp
argument_list|,
operator|(
name|type
operator|==
literal|'u'
operator|)
condition|?
name|UNION
else|:
name|STRUCT
argument_list|,
name|rtdp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|expected
argument_list|(
literal|"tdefdecl"
argument_list|,
literal|"<type code>"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|intrinsic
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|rtdp
parameter_list|)
block|{
name|intr_t
modifier|*
name|intr
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|intr_t
argument_list|)
argument_list|)
decl_stmt|;
name|tdesc_t
modifier|*
name|tdp
decl_stmt|;
name|int
name|width
decl_stmt|,
name|fmt
decl_stmt|,
name|i
decl_stmt|;
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|'b'
case|:
name|intr
operator|->
name|intr_type
operator|=
name|INTR_INT
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'s'
condition|)
name|intr
operator|->
name|intr_signed
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'u'
condition|)
name|expected
argument_list|(
literal|"intrinsic/b"
argument_list|,
literal|"[su]"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"cbv"
argument_list|,
operator|*
name|cp
argument_list|)
condition|)
name|intr
operator|->
name|intr_iformat
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|cp
operator|=
name|number
argument_list|(
name|cp
argument_list|,
operator|&
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|';'
condition|)
name|expected
argument_list|(
literal|"intrinsic/b"
argument_list|,
literal|"; (post-width)"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|number
argument_list|(
name|cp
argument_list|,
operator|&
name|intr
operator|->
name|intr_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|';'
condition|)
name|expected
argument_list|(
literal|"intrinsic/b"
argument_list|,
literal|"; (post-offset)"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|number
argument_list|(
name|cp
argument_list|,
operator|&
name|intr
operator|->
name|intr_nbits
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|intr
operator|->
name|intr_type
operator|=
name|INTR_REAL
expr_stmt|;
for|for
control|(
name|fmt
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
operator|(
name|cp
operator|+
name|i
operator|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|fmt
operator|=
name|fmt
operator|*
literal|10
operator|+
operator|(
operator|*
operator|(
name|cp
operator|+
name|i
operator|)
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|<
literal|1
operator|||
name|fmt
operator|>
name|CTF_FP_MAX
condition|)
name|expected
argument_list|(
literal|"intrinsic/R"
argument_list|,
literal|"number<= CTF_FP_MAX"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|intr
operator|->
name|intr_fformat
operator|=
name|fmt
expr_stmt|;
name|cp
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|';'
condition|)
name|expected
argument_list|(
literal|"intrinsic/R"
argument_list|,
literal|";"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|number
argument_list|(
name|cp
argument_list|,
operator|&
name|width
argument_list|)
expr_stmt|;
name|intr
operator|->
name|intr_nbits
operator|=
name|width
operator|*
literal|8
expr_stmt|;
break|break;
block|}
name|tdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tdp
argument_list|)
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_type
operator|=
name|INTRINSIC
expr_stmt|;
name|tdp
operator|->
name|t_size
operator|=
name|width
expr_stmt|;
name|tdp
operator|->
name|t_name
operator|=
name|NULL
expr_stmt|;
name|tdp
operator|->
name|t_intr
operator|=
name|intr
expr_stmt|;
name|parse_debug
argument_list|(
literal|3
argument_list|,
name|NULL
argument_list|,
literal|"intrinsic: size=%d"
argument_list|,
name|width
argument_list|)
expr_stmt|;
operator|*
name|rtdp
operator|=
name|tdp
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|bitintrinsic
parameter_list|(
name|tdesc_t
modifier|*
name|template
parameter_list|,
name|int
name|nbits
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|newtdp
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
argument_list|)
argument_list|)
decl_stmt|;
name|newtdp
operator|->
name|t_name
operator|=
name|xstrdup
argument_list|(
name|template
operator|->
name|t_name
argument_list|)
expr_stmt|;
name|newtdp
operator|->
name|t_id
operator|=
name|faketypenumber
operator|++
expr_stmt|;
name|newtdp
operator|->
name|t_type
operator|=
name|INTRINSIC
expr_stmt|;
name|newtdp
operator|->
name|t_size
operator|=
name|template
operator|->
name|t_size
expr_stmt|;
name|newtdp
operator|->
name|t_intr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|intr_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|template
operator|->
name|t_intr
argument_list|,
name|newtdp
operator|->
name|t_intr
argument_list|,
sizeof|sizeof
argument_list|(
name|intr_t
argument_list|)
argument_list|)
expr_stmt|;
name|newtdp
operator|->
name|t_intr
operator|->
name|intr_nbits
operator|=
name|nbits
expr_stmt|;
return|return
operator|(
name|newtdp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|offsize
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|mlist_t
modifier|*
name|mlp
parameter_list|)
block|{
name|int
name|offset
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|','
condition|)
name|cp
operator|++
expr_stmt|;
name|cp
operator|=
name|number
argument_list|(
name|cp
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|','
condition|)
name|expected
argument_list|(
literal|"offsize/2"
argument_list|,
literal|","
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|number
argument_list|(
name|cp
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|';'
condition|)
name|expected
argument_list|(
literal|"offsize/3"
argument_list|,
literal|";"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mlp
operator|->
name|ml_offset
operator|=
name|offset
expr_stmt|;
name|mlp
operator|->
name|ml_size
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|find_intrinsic
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|tdp
operator|->
name|t_type
condition|)
block|{
case|case
name|TYPEDEF
case|:
case|case
name|VOLATILE
case|:
case|case
name|CONST
case|:
case|case
name|RESTRICT
case|:
name|tdp
operator|=
name|tdp
operator|->
name|t_tdesc
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|tdp
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|soudef
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|stabtype_t
name|type
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|rtdp
parameter_list|)
block|{
name|mlist_t
modifier|*
name|mlp
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|char
modifier|*
name|w
decl_stmt|;
name|int
name|h
decl_stmt|;
name|int
name|size
decl_stmt|;
name|tdesc_t
modifier|*
name|tdp
decl_stmt|,
modifier|*
name|itdp
decl_stmt|;
name|cp
operator|=
name|number
argument_list|(
name|cp
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_size
operator|=
name|size
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_type
operator|=
name|type
expr_stmt|;
comment|/* s or u */
comment|/* 	 * An '@' here indicates a bitmask follows.   This is so the 	 * compiler can pass information to debuggers about how structures 	 * are passed in the v9 world.  We don't need this information 	 * so we skip over it. 	 */
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
name|cp
operator|+=
literal|3
expr_stmt|;
block|}
name|parse_debug
argument_list|(
literal|3
argument_list|,
name|cp
argument_list|,
literal|"soudef: %s size=%d"
argument_list|,
name|tdesc_name
argument_list|(
operator|*
name|rtdp
argument_list|)
argument_list|,
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_size
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|&
operator|(
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_members
operator|)
expr_stmt|;
comment|/* now fill up the fields */
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|';'
operator|)
condition|)
block|{
comment|/* signifies end of fields */
name|mlp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mlp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|mlp
expr_stmt|;
name|cp
operator|=
name|name
argument_list|(
name|cp
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
name|mlp
operator|->
name|ml_name
operator|=
name|w
expr_stmt|;
name|cp
operator|=
name|id
argument_list|(
name|cp
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
comment|/* 		 * find the tdesc struct in the hash table for this type 		 * and stick a ptr in here 		 */
name|tdp
operator|=
name|lookup
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdp
operator|==
name|NULL
condition|)
block|{
comment|/* not in hash list */
name|parse_debug
argument_list|(
literal|3
argument_list|,
name|NULL
argument_list|,
literal|"      defines %s (%d)"
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'='
condition|)
block|{
name|tdp
operator|=
name|unres_new
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|parse_debug
argument_list|(
literal|3
argument_list|,
name|NULL
argument_list|,
literal|"      refers to %s (unresolved %d)"
argument_list|,
operator|(
name|w
condition|?
name|w
else|:
literal|"anon"
operator|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|tdefdecl
argument_list|(
name|cp
argument_list|,
name|h
argument_list|,
operator|&
name|tdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_id
operator|&&
name|tdp
operator|->
name|t_id
operator|!=
name|h
condition|)
block|{
name|tdesc_t
modifier|*
name|ntdp
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ntdp
argument_list|)
argument_list|)
decl_stmt|;
name|ntdp
operator|->
name|t_type
operator|=
name|TYPEDEF
expr_stmt|;
name|ntdp
operator|->
name|t_tdesc
operator|=
name|tdp
expr_stmt|;
name|tdp
operator|=
name|ntdp
expr_stmt|;
block|}
name|addhash
argument_list|(
name|tdp
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|parse_debug
argument_list|(
literal|4
argument_list|,
name|cp
argument_list|,
literal|"     soudef now looking at    "
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|parse_debug
argument_list|(
literal|3
argument_list|,
name|NULL
argument_list|,
literal|"      refers to %s (%d, %s)"
argument_list|,
name|w
condition|?
name|w
else|:
literal|"anon"
argument_list|,
name|h
argument_list|,
name|tdesc_name
argument_list|(
name|tdp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|offsize
argument_list|(
name|cp
argument_list|,
name|mlp
argument_list|)
expr_stmt|;
name|itdp
operator|=
name|find_intrinsic
argument_list|(
name|tdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|itdp
operator|->
name|t_type
operator|==
name|INTRINSIC
condition|)
block|{
if|if
condition|(
name|mlp
operator|->
name|ml_size
operator|!=
name|itdp
operator|->
name|t_intr
operator|->
name|intr_nbits
condition|)
block|{
name|parse_debug
argument_list|(
literal|4
argument_list|,
name|cp
argument_list|,
literal|"making %d bit intrinsic "
literal|"from %s"
argument_list|,
name|mlp
operator|->
name|ml_size
argument_list|,
name|tdesc_name
argument_list|(
name|itdp
argument_list|)
argument_list|)
expr_stmt|;
name|mlp
operator|->
name|ml_type
operator|=
name|bitintrinsic
argument_list|(
name|itdp
argument_list|,
name|mlp
operator|->
name|ml_size
argument_list|)
expr_stmt|;
block|}
else|else
name|mlp
operator|->
name|ml_type
operator|=
name|tdp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|itdp
operator|->
name|t_type
operator|==
name|TYPEDEF_UNRES
condition|)
block|{
name|list_add
argument_list|(
operator|&
name|typedbitfldmems
argument_list|,
name|mlp
argument_list|)
expr_stmt|;
name|mlp
operator|->
name|ml_type
operator|=
name|tdp
expr_stmt|;
block|}
else|else
block|{
name|mlp
operator|->
name|ml_type
operator|=
name|tdp
expr_stmt|;
block|}
comment|/* cp is now pointing to next field */
name|prev
operator|=
operator|&
name|mlp
operator|->
name|ml_next
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|arraydef
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|rtdp
parameter_list|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|h
decl_stmt|;
name|cp
operator|=
name|id
argument_list|(
name|cp
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|';'
condition|)
name|expected
argument_list|(
literal|"arraydef/1"
argument_list|,
literal|";"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_ardef
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ardef_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_ardef
operator|->
name|ad_idxtype
operator|=
name|lookup
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|cp
operator|=
name|number
argument_list|(
name|cp
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
comment|/* lower */
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|';'
condition|)
name|expected
argument_list|(
literal|"arraydef/2"
argument_list|,
literal|";"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'S'
condition|)
block|{
comment|/* 		 * variable length array - treat as null dimensioned 		 * 		 * For VLA variables on sparc, SS12 generated stab entry 		 * looks as follows: 		 * .stabs "buf:(0,28)=zr(0,4);0;S-12;(0,1)", 0x80, 0, 0, -16 		 * Whereas SS12u1 generated stab entry looks like this: 		 * .stabs "buf:(0,28)=zr(0,4);0;S0;(0,1)", 0x80, 0, 0, 0 		 * On x86, both versions generate the first type of entry. 		 * We should be able to parse both. 		 */
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|cp
operator|++
expr_stmt|;
name|cp
operator|=
name|number
argument_list|(
name|cp
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|end
operator|=
name|start
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * normal fixed-dimension array 		 * Stab entry for this looks as follows : 		 * .stabs "x:(0,28)=ar(0,4);0;9;(0,3)", 0x80, 0, 40, 0 		 */
name|cp
operator|=
name|number
argument_list|(
name|cp
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
comment|/* upper */
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|';'
condition|)
name|expected
argument_list|(
literal|"arraydef/3"
argument_list|,
literal|";"
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_ardef
operator|->
name|ad_nelems
operator|=
name|end
operator|-
name|start
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|tdefdecl
argument_list|(
name|cp
argument_list|,
name|h
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_ardef
operator|->
name|ad_contents
operator|)
argument_list|)
expr_stmt|;
name|parse_debug
argument_list|(
literal|3
argument_list|,
name|cp
argument_list|,
literal|"defined array idx type %d %d-%d next "
argument_list|,
name|h
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|enumdef
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|rtdp
parameter_list|)
block|{
name|elist_t
modifier|*
name|elp
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|char
modifier|*
name|w
decl_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_type
operator|=
name|ENUM
expr_stmt|;
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_emem
operator|=
name|NULL
expr_stmt|;
name|prev
operator|=
operator|&
operator|(
operator|(
operator|*
name|rtdp
operator|)
operator|->
name|t_emem
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|';'
condition|)
block|{
name|elp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|elp
argument_list|)
argument_list|)
expr_stmt|;
name|elp
operator|->
name|el_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|prev
operator|=
name|elp
expr_stmt|;
name|cp
operator|=
name|name
argument_list|(
name|cp
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
name|elp
operator|->
name|el_name
operator|=
name|w
expr_stmt|;
name|cp
operator|=
name|number
argument_list|(
name|cp
argument_list|,
operator|&
name|elp
operator|->
name|el_number
argument_list|)
expr_stmt|;
name|parse_debug
argument_list|(
literal|3
argument_list|,
name|NULL
argument_list|,
literal|"enum %s: %s=%d"
argument_list|,
name|tdesc_name
argument_list|(
operator|*
name|rtdp
argument_list|)
argument_list|,
name|elp
operator|->
name|el_name
argument_list|,
name|elp
operator|->
name|el_number
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|&
name|elp
operator|->
name|el_next
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|','
condition|)
name|expected
argument_list|(
literal|"enumdef"
argument_list|,
literal|","
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tdesc_t
modifier|*
name|lookup_name
parameter_list|(
name|tdesc_t
modifier|*
modifier|*
name|hash
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|bucket
init|=
name|compute_sum
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tdesc_t
modifier|*
name|tdp
decl_stmt|,
modifier|*
name|ttdp
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|tdp
operator|=
name|hash
index|[
name|bucket
index|]
init|;
name|tdp
operator|!=
name|NULL
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|t_next
control|)
block|{
if|if
condition|(
name|tdp
operator|->
name|t_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|tdp
operator|->
name|t_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tdp
operator|->
name|t_type
operator|==
name|STRUCT
operator|||
name|tdp
operator|->
name|t_type
operator|==
name|UNION
operator|||
name|tdp
operator|->
name|t_type
operator|==
name|ENUM
operator|||
name|tdp
operator|->
name|t_type
operator|==
name|INTRINSIC
condition|)
return|return
operator|(
name|tdp
operator|)
return|;
if|if
condition|(
name|tdp
operator|->
name|t_type
operator|==
name|TYPEDEF
condition|)
name|ttdp
operator|=
name|tdp
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ttdp
operator|)
return|;
block|}
end_function

begin_function
name|tdesc_t
modifier|*
name|lookupname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|lookup_name
argument_list|(
name|name_table
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a node to the hash queues.  */
end_comment

begin_function
specifier|static
name|void
name|addhash
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|hash
init|=
name|HASH
argument_list|(
name|num
argument_list|)
decl_stmt|;
name|tdesc_t
modifier|*
name|ttdp
decl_stmt|;
name|char
name|added_num
init|=
literal|0
decl_stmt|,
name|added_name
init|=
literal|0
decl_stmt|;
comment|/* 	 * If it already exists in the hash table don't add it again 	 * (but still check to see if the name should be hashed). 	 */
name|ttdp
operator|=
name|lookup
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttdp
operator|==
name|NULL
condition|)
block|{
name|tdp
operator|->
name|t_id
operator|=
name|num
expr_stmt|;
name|tdp
operator|->
name|t_hash
operator|=
name|hash_table
index|[
name|hash
index|]
expr_stmt|;
name|hash_table
index|[
name|hash
index|]
operator|=
name|tdp
expr_stmt|;
name|added_num
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tdp
operator|->
name|t_name
operator|!=
name|NULL
condition|)
block|{
name|ttdp
operator|=
name|lookupname
argument_list|(
name|tdp
operator|->
name|t_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttdp
operator|==
name|NULL
condition|)
block|{
name|hash
operator|=
name|compute_sum
argument_list|(
name|tdp
operator|->
name|t_name
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_next
operator|=
name|name_table
index|[
name|hash
index|]
expr_stmt|;
name|name_table
index|[
name|hash
index|]
operator|=
name|tdp
expr_stmt|;
name|added_name
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|added_num
operator|&&
operator|!
name|added_name
condition|)
block|{
name|terminate
argument_list|(
literal|"stabs: broken hash\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|compute_sum
parameter_list|(
specifier|const
name|char
modifier|*
name|w
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|sum
decl_stmt|;
for|for
control|(
name|sum
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
name|w
operator|)
operator|!=
literal|'\0'
condition|;
name|sum
operator|+=
name|c
operator|,
name|w
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|HASH
argument_list|(
name|sum
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|reset
parameter_list|(
name|void
parameter_list|)
block|{
name|longjmp
argument_list|(
name|resetbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|check_hash
parameter_list|(
name|void
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"checking hash\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUCKETS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hash_table
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|tdp
operator|=
name|hash_table
index|[
name|i
index|]
operator|->
name|t_hash
init|;
name|tdp
operator|&&
name|tdp
operator|!=
name|hash_table
index|[
name|i
index|]
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|t_hash
control|)
continue|continue;
if|if
condition|(
name|tdp
condition|)
block|{
name|terminate
argument_list|(
literal|"cycle in hash bucket %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|name_table
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|tdp
operator|=
name|name_table
index|[
name|i
index|]
operator|->
name|t_next
init|;
name|tdp
operator|&&
name|tdp
operator|!=
name|name_table
index|[
name|i
index|]
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|t_next
control|)
continue|continue;
if|if
condition|(
name|tdp
condition|)
block|{
name|terminate
argument_list|(
literal|"cycle in name bucket %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
specifier|static
name|int
name|resolve_typed_bitfields_cb
parameter_list|(
name|mlist_t
modifier|*
name|ml
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp
init|=
name|ml
operator|->
name|ml_type
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Resolving typed bitfields (member %s)\n"
argument_list|,
operator|(
name|ml
operator|->
name|ml_name
condition|?
name|ml
operator|->
name|ml_name
else|:
literal|"(anon)"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|tdp
condition|)
block|{
switch|switch
condition|(
name|tdp
operator|->
name|t_type
condition|)
block|{
case|case
name|INTRINSIC
case|:
if|if
condition|(
name|ml
operator|->
name|ml_size
operator|!=
name|tdp
operator|->
name|t_intr
operator|->
name|intr_nbits
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"making %d bit intrinsic from %s"
argument_list|,
name|ml
operator|->
name|ml_size
argument_list|,
name|tdesc_name
argument_list|(
name|tdp
argument_list|)
argument_list|)
expr_stmt|;
name|ml
operator|->
name|ml_type
operator|=
name|bitintrinsic
argument_list|(
name|tdp
argument_list|,
name|ml
operator|->
name|ml_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"using existing %d bit %s intrinsic"
argument_list|,
name|ml
operator|->
name|ml_size
argument_list|,
name|tdesc_name
argument_list|(
name|tdp
argument_list|)
argument_list|)
expr_stmt|;
name|ml
operator|->
name|ml_type
operator|=
name|tdp
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|POINTER
case|:
case|case
name|TYPEDEF
case|:
case|case
name|VOLATILE
case|:
case|case
name|CONST
case|:
case|case
name|RESTRICT
case|:
name|tdp
operator|=
name|tdp
operator|->
name|t_tdesc
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|terminate
argument_list|(
literal|"type chain for bitfield member %s has a NULL"
argument_list|,
name|ml
operator|->
name|ml_name
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|resolve_typed_bitfields
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|list_iter
argument_list|(
name|typedbitfldmems
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|resolve_typed_bitfields_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

