begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * Routines used to read stabs data from a file, and to build a tdata structure  * based on the interesting parts of that data.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|"ctftools.h"
end_include

begin_include
include|#
directive|include
file|"list.h"
end_include

begin_include
include|#
directive|include
file|"stack.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"traverse.h"
end_include

begin_decl_stmt
specifier|const
name|char
modifier|*
name|curhdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The stabs generator will sometimes reference types before they've been  * defined.  If this is the case, a TYPEDEF_UNRES tdesc will be generated.  * Note that this is different from a forward declaration, in which the  * stab is defined, but is defined as something that doesn't exist yet.  * When we have read all of the stabs from the file, we can go back and  * fix up all of the unresolved types.  We should be able to fix all of them.  */
end_comment

begin_comment
comment|/*ARGSUSED2*/
end_comment

begin_function
specifier|static
name|int
name|resolve_tou_node
parameter_list|(
name|tdesc_t
modifier|*
name|node
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|new
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Trying to resolve %s (%d)\n"
argument_list|,
name|tdesc_name
argument_list|(
name|node
argument_list|)
argument_list|,
name|node
operator|->
name|t_id
argument_list|)
expr_stmt|;
name|new
operator|=
name|lookup
argument_list|(
name|node
operator|->
name|t_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|terminate
argument_list|(
literal|"Couldn't resolve type %d\n"
argument_list|,
name|node
operator|->
name|t_id
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|" Resolving to %d\n"
argument_list|,
name|new
operator|->
name|t_id
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|resolve_fwd_node
parameter_list|(
name|tdesc_t
modifier|*
name|node
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|new
init|=
name|lookupname
argument_list|(
name|node
operator|->
name|t_name
argument_list|)
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Trying to unforward %s (%d)\n"
argument_list|,
name|tdesc_name
argument_list|(
name|node
argument_list|)
argument_list|,
name|node
operator|->
name|t_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
operator|||
operator|(
name|new
operator|->
name|t_type
operator|!=
name|STRUCT
operator|&&
name|new
operator|->
name|t_type
operator|!=
name|UNION
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|" Unforwarded to %d\n"
argument_list|,
name|new
operator|->
name|t_id
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|tdtrav_cb_f
name|resolve_cbs
index|[]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
comment|/* intrinsic */
name|NULL
block|,
comment|/* pointer */
name|NULL
block|,
comment|/* array */
name|NULL
block|,
comment|/* function */
name|NULL
block|,
comment|/* struct */
name|NULL
block|,
comment|/* union */
name|NULL
block|,
comment|/* enum */
name|resolve_fwd_node
block|,
comment|/* forward */
name|NULL
block|,
comment|/* typedef */
name|resolve_tou_node
block|,
comment|/* typedef unres */
name|NULL
block|,
comment|/* volatile */
name|NULL
block|,
comment|/* const */
name|NULL
block|,
comment|/* restrict */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|resolve_nodes
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"Resolving unresolved stabs\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|iitraverse_hash
argument_list|(
name|td
operator|->
name|td_iihash
argument_list|,
operator|&
name|td
operator|->
name|td_curvgen
argument_list|,
name|resolve_cbs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|concat
parameter_list|(
name|char
modifier|*
name|s1
parameter_list|,
name|char
modifier|*
name|s2
parameter_list|,
name|int
name|s2strip
parameter_list|)
block|{
name|int
name|savelen
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
operator|-
name|s2strip
decl_stmt|;
name|int
name|newlen
init|=
operator|(
name|s1
condition|?
name|strlen
argument_list|(
name|s1
argument_list|)
else|:
literal|0
operator|)
operator|+
name|savelen
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
name|out
operator|=
name|xrealloc
argument_list|(
name|s1
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
condition|)
name|strncpy
argument_list|(
name|out
operator|+
name|strlen
argument_list|(
name|out
argument_list|)
argument_list|,
name|s2
argument_list|,
name|savelen
argument_list|)
expr_stmt|;
else|else
name|strncpy
argument_list|(
name|out
argument_list|,
name|s2
argument_list|,
name|savelen
argument_list|)
expr_stmt|;
name|out
index|[
name|newlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * N_FUN stabs come with their arguments in promoted form.  In order to get the  * actual arguments, we need to wait for the N_PSYM stabs that will come towards  * the end of the function.  These routines free the arguments (fnarg_free) we  * got from the N_FUN stab and add (fnarg_add) the ones from the N_PSYM stabs.  */
end_comment

begin_function
specifier|static
name|void
name|fnarg_add
parameter_list|(
name|iidesc_t
modifier|*
name|curfun
parameter_list|,
name|iidesc_t
modifier|*
name|arg
parameter_list|)
block|{
name|curfun
operator|->
name|ii_nargs
operator|++
expr_stmt|;
if|if
condition|(
name|curfun
operator|->
name|ii_nargs
operator|==
literal|1
condition|)
name|curfun
operator|->
name|ii_args
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
operator|*
argument_list|)
operator|*
name|FUNCARG_DEF
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|curfun
operator|->
name|ii_nargs
operator|>
name|FUNCARG_DEF
condition|)
block|{
name|curfun
operator|->
name|ii_args
operator|=
name|xrealloc
argument_list|(
name|curfun
operator|->
name|ii_args
argument_list|,
sizeof|sizeof
argument_list|(
name|tdesc_t
operator|*
argument_list|)
operator|*
name|curfun
operator|->
name|ii_nargs
argument_list|)
expr_stmt|;
block|}
name|curfun
operator|->
name|ii_args
index|[
name|curfun
operator|->
name|ii_nargs
operator|-
literal|1
index|]
operator|=
name|arg
operator|->
name|ii_dtype
expr_stmt|;
name|arg
operator|->
name|ii_dtype
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fnarg_free
parameter_list|(
name|iidesc_t
modifier|*
name|ii
parameter_list|)
block|{
name|ii
operator|->
name|ii_nargs
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|ii
operator|->
name|ii_args
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_args
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the stabs from the stab ELF section, and turn them into a tdesc tree,  * assembled under an iidesc list.  */
end_comment

begin_function
name|int
name|stabs_read
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|Elf
modifier|*
name|elf
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Scn
modifier|*
name|scn
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|stab_t
modifier|*
name|stab
decl_stmt|;
name|stk_t
modifier|*
name|file_stack
decl_stmt|;
name|iidesc_t
modifier|*
name|iidescp
decl_stmt|;
name|iidesc_t
modifier|*
name|curfun
init|=
name|NULL
decl_stmt|;
name|char
name|curpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|curfile
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|fstr
init|=
name|NULL
decl_stmt|,
modifier|*
name|ofstr
init|=
name|NULL
decl_stmt|;
name|int
name|stabidx
decl_stmt|,
name|stabstridx
decl_stmt|;
name|int
name|nstabs
decl_stmt|,
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|int
name|scope
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|stabidx
operator|=
name|findelfsecidx
argument_list|(
name|elf
argument_list|,
name|file
argument_list|,
literal|".stab.excl"
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|stabstridx
operator|=
name|findelfsecidx
argument_list|(
name|elf
argument_list|,
name|file
argument_list|,
literal|".stab.exclstr"
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|&&
operator|!
operator|(
operator|(
name|stabidx
operator|=
name|findelfsecidx
argument_list|(
name|elf
argument_list|,
name|file
argument_list|,
literal|".stab"
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|stabstridx
operator|=
name|findelfsecidx
argument_list|(
name|elf
argument_list|,
name|file
argument_list|,
literal|".stabstr"
argument_list|)
operator|)
operator|>=
literal|0
operator|)
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|file_stack
operator|=
name|stack_new
argument_list|(
name|free
argument_list|)
expr_stmt|;
name|stack_push
argument_list|(
name|file_stack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|file
argument_list|)
expr_stmt|;
name|curhdr
operator|=
name|file
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Found stabs in %d, strings in %d\n"
argument_list|,
name|stabidx
argument_list|,
name|stabstridx
argument_list|)
expr_stmt|;
name|scn
operator|=
name|elf_getscn
argument_list|(
name|elf
argument_list|,
name|stabidx
argument_list|)
expr_stmt|;
name|data
operator|=
name|elf_rawdata
argument_list|(
name|scn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nstabs
operator|=
name|data
operator|->
name|d_size
operator|/
sizeof|sizeof
argument_list|(
name|stab_t
argument_list|)
expr_stmt|;
name|parse_init
argument_list|(
name|td
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstabs
condition|;
name|i
operator|++
control|)
block|{
name|stab
operator|=
operator|&
operator|(
operator|(
name|stab_t
operator|*
operator|)
name|data
operator|->
name|d_buf
operator|)
index|[
name|i
index|]
expr_stmt|;
comment|/* We don't want any local definitions */
if|if
condition|(
name|stab
operator|->
name|n_type
operator|==
name|N_LBRAC
condition|)
block|{
name|scope
operator|++
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"stab %d: opening scope (%d)\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|scope
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|stab
operator|->
name|n_type
operator|==
name|N_RBRAC
condition|)
block|{
name|scope
operator|--
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"stab %d: closing scope (%d)\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|scope
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|stab
operator|->
name|n_type
operator|==
name|N_EINCL
condition|)
block|{
comment|/* 			 * There's a bug in the 5.2 (Taz) compilers that causes 			 * them to emit an extra N_EINCL if there's no actual 			 * text in the file being compiled.  To work around this 			 * bug, we explicitly check to make sure we're not 			 * trying to pop a stack that only has the outer scope 			 * on it. 			 */
if|if
condition|(
name|stack_level
argument_list|(
name|file_stack
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|stack_pop
argument_list|(
name|file_stack
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|curhdr
operator|=
operator|(
name|char
operator|*
operator|)
name|stack_peek
argument_list|(
name|file_stack
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We only care about a subset of the stabs */
if|if
condition|(
operator|!
operator|(
name|stab
operator|->
name|n_type
operator|==
name|N_FUN
operator|||
name|stab
operator|->
name|n_type
operator|==
name|N_GSYM
operator|||
name|stab
operator|->
name|n_type
operator|==
name|N_LCSYM
operator|||
name|stab
operator|->
name|n_type
operator|==
name|N_LSYM
operator|||
name|stab
operator|->
name|n_type
operator|==
name|N_PSYM
operator|||
name|stab
operator|->
name|n_type
operator|==
name|N_ROSYM
operator|||
name|stab
operator|->
name|n_type
operator|==
name|N_RSYM
operator|||
name|stab
operator|->
name|n_type
operator|==
name|N_STSYM
operator|||
name|stab
operator|->
name|n_type
operator|==
name|N_BINCL
operator|||
name|stab
operator|->
name|n_type
operator|==
name|N_SO
operator|||
name|stab
operator|->
name|n_type
operator|==
name|N_OPT
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|str
operator|=
name|elf_strptr
argument_list|(
name|elf
argument_list|,
name|stabstridx
argument_list|,
operator|(
name|size_t
operator|)
name|stab
operator|->
name|n_strx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|terminate
argument_list|(
literal|"%s: Can't find string at %u for stab %d\n"
argument_list|,
name|file
argument_list|,
name|stab
operator|->
name|n_strx
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stab
operator|->
name|n_type
operator|==
name|N_BINCL
condition|)
block|{
name|curhdr
operator|=
name|xstrdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|stack_push
argument_list|(
name|file_stack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|curhdr
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|stab
operator|->
name|n_type
operator|==
name|N_SO
condition|)
block|{
if|if
condition|(
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|curpath
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|curfile
operator|=
name|basename
argument_list|(
name|curpath
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|stab
operator|->
name|n_type
operator|==
name|N_OPT
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"gcc2_compiled."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|terminate
argument_list|(
literal|"%s: GCC-generated stabs are "
literal|"unsupported. Use DWARF instead.\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
name|int
name|offset
init|=
literal|1
decl_stmt|;
comment|/* 			 * There's a bug in the compilers that causes them to 			 * generate \ for continuations with just -g (this is 			 * ok), and \\ for continuations with -g -O (this is 			 * broken).  This bug is "fixed" in the 6.2 compilers 			 * via the elimination of continuation stabs. 			 */
if|if
condition|(
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|'\\'
condition|)
name|offset
operator|=
literal|2
expr_stmt|;
name|fstr
operator|=
name|concat
argument_list|(
name|fstr
argument_list|,
name|str
argument_list|,
name|offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|fstr
operator|=
name|concat
argument_list|(
name|fstr
argument_list|,
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"%4d: .stabs \"%s\", %#x, %d, %hd, %d (from %s)\n"
argument_list|,
name|i
argument_list|,
name|fstr
argument_list|,
name|stab
operator|->
name|n_type
argument_list|,
literal|0
argument_list|,
name|stab
operator|->
name|n_desc
argument_list|,
name|stab
operator|->
name|n_value
argument_list|,
name|curhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>=
literal|3
condition|)
name|check_hash
argument_list|()
expr_stmt|;
comment|/* 		 * Sometimes the compiler stutters, and emits the same stab 		 * twice.  This is bad for the parser, which will attempt to 		 * redefine the type IDs indicated in the stabs.  This is 		 * compiler bug 4433511. 		 */
if|if
condition|(
name|ofstr
operator|&&
name|strcmp
argument_list|(
name|fstr
argument_list|,
name|ofstr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Stutter stab\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fstr
argument_list|)
expr_stmt|;
name|fstr
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ofstr
condition|)
name|free
argument_list|(
name|ofstr
argument_list|)
expr_stmt|;
name|ofstr
operator|=
name|fstr
expr_stmt|;
name|iidescp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|parse_stab
argument_list|(
name|stab
argument_list|,
name|fstr
argument_list|,
operator|&
name|iidescp
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|terminate
argument_list|(
literal|"%s: Couldn't parse stab \"%s\" "
literal|"(source file %s)\n"
argument_list|,
name|file
argument_list|,
name|str
argument_list|,
name|curhdr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
goto|goto
name|parse_loop_end
goto|;
comment|/* Make sure the scope tracking is working correctly */
name|assert
argument_list|(
name|stab
operator|->
name|n_type
operator|!=
name|N_FUN
operator|||
operator|(
name|iidescp
operator|->
name|ii_type
operator|!=
name|II_GFUN
operator|&&
name|iidescp
operator|->
name|ii_type
operator|!=
name|II_SFUN
operator|)
operator|||
name|scope
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * The only things we care about that are in local scope are 		 * the N_PSYM stabs. 		 */
if|if
condition|(
name|scope
operator|&&
name|stab
operator|->
name|n_type
operator|!=
name|N_PSYM
condition|)
block|{
if|if
condition|(
name|iidescp
condition|)
name|iidesc_free
argument_list|(
name|iidescp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|parse_loop_end
goto|;
block|}
switch|switch
condition|(
name|iidescp
operator|->
name|ii_type
condition|)
block|{
case|case
name|II_SFUN
case|:
name|iidescp
operator|->
name|ii_owner
operator|=
name|xstrdup
argument_list|(
name|curfile
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|II_GFUN
case|:
name|curfun
operator|=
name|iidescp
expr_stmt|;
name|fnarg_free
argument_list|(
name|iidescp
argument_list|)
expr_stmt|;
name|iidesc_add
argument_list|(
name|td
operator|->
name|td_iihash
argument_list|,
name|iidescp
argument_list|)
expr_stmt|;
break|break;
case|case
name|II_SVAR
case|:
name|iidescp
operator|->
name|ii_owner
operator|=
name|xstrdup
argument_list|(
name|curfile
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|II_GVAR
case|:
case|case
name|II_TYPE
case|:
case|case
name|II_SOU
case|:
name|iidesc_add
argument_list|(
name|td
operator|->
name|td_iihash
argument_list|,
name|iidescp
argument_list|)
expr_stmt|;
break|break;
case|case
name|II_PSYM
case|:
name|fnarg_add
argument_list|(
name|curfun
argument_list|,
name|iidescp
argument_list|)
expr_stmt|;
name|iidesc_free
argument_list|(
name|iidescp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|aborterr
argument_list|(
literal|"invalid ii_type %d for stab type %d"
argument_list|,
name|iidescp
operator|->
name|ii_type
argument_list|,
name|stab
operator|->
name|n_type
argument_list|)
expr_stmt|;
block|}
name|parse_loop_end
label|:
name|fstr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ofstr
condition|)
name|free
argument_list|(
name|ofstr
argument_list|)
expr_stmt|;
name|resolve_nodes
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|resolve_typed_bitfields
argument_list|()
expr_stmt|;
name|parse_finish
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|cvt_fixstabs
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|cvt_fixups
argument_list|(
name|td
argument_list|,
name|elf_ptrsz
argument_list|(
name|elf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

