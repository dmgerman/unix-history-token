begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- StreamWriter.h ----------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_TOOLS_LLVM_READOBJ_STREAMWRITER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_TOOLS_LLVM_READOBJ_STREAMWRITER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/DataTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Endian.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_decl_stmt
name|using
name|namespace
name|llvm
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|using
name|namespace
name|llvm
operator|::
name|support
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|namespace
name|llvm
block|{
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|EnumEntry
block|{
name|StringRef
name|Name
block|;
name|T
name|Value
block|; }
expr_stmt|;
struct|struct
name|HexNumber
block|{
comment|// To avoid sign-extension we have to explicitly cast to the appropriate
comment|// unsigned type. The overloads are here so that every type that is implicitly
comment|// convertible to an integer (including enums and endian helpers) can be used
comment|// without requiring type traits or call-site changes.
name|HexNumber
argument_list|(
argument|int8_t   Value
argument_list|)
block|:
name|Value
argument_list|(
argument|static_cast<uint8_t>(Value)
argument_list|)
block|{ }
name|HexNumber
argument_list|(
argument|int16_t  Value
argument_list|)
block|:
name|Value
argument_list|(
argument|static_cast<uint16_t>(Value)
argument_list|)
block|{ }
name|HexNumber
argument_list|(
argument|int32_t  Value
argument_list|)
block|:
name|Value
argument_list|(
argument|static_cast<uint32_t>(Value)
argument_list|)
block|{ }
name|HexNumber
argument_list|(
argument|int64_t  Value
argument_list|)
block|:
name|Value
argument_list|(
argument|static_cast<uint64_t>(Value)
argument_list|)
block|{ }
name|HexNumber
argument_list|(
argument|uint8_t  Value
argument_list|)
block|:
name|Value
argument_list|(
argument|Value
argument_list|)
block|{ }
name|HexNumber
argument_list|(
argument|uint16_t Value
argument_list|)
block|:
name|Value
argument_list|(
argument|Value
argument_list|)
block|{ }
name|HexNumber
argument_list|(
argument|uint32_t Value
argument_list|)
block|:
name|Value
argument_list|(
argument|Value
argument_list|)
block|{ }
name|HexNumber
argument_list|(
argument|uint64_t Value
argument_list|)
block|:
name|Value
argument_list|(
argument|Value
argument_list|)
block|{ }
name|uint64_t
name|Value
decl_stmt|;
block|}
struct|;
name|raw_ostream
operator|&
name|operator
operator|<<
operator|(
name|raw_ostream
operator|&
name|OS
operator|,
specifier|const
name|HexNumber
operator|&
name|Value
operator|)
expr_stmt|;
name|class
name|StreamWriter
block|{
name|public
label|:
name|StreamWriter
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
operator|:
name|OS
argument_list|(
name|OS
argument_list|)
operator|,
name|IndentLevel
argument_list|(
literal|0
argument_list|)
block|{   }
name|void
name|flush
argument_list|()
block|{
name|OS
operator|.
name|flush
argument_list|()
block|;   }
name|void
name|indent
argument_list|(
argument|int Levels =
literal|1
argument_list|)
block|{
name|IndentLevel
operator|+=
name|Levels
block|;   }
name|void
name|unindent
argument_list|(
argument|int Levels =
literal|1
argument_list|)
block|{
name|IndentLevel
operator|=
name|std
operator|::
name|max
argument_list|(
literal|0
argument_list|,
name|IndentLevel
operator|-
name|Levels
argument_list|)
block|;   }
name|void
name|printIndent
argument_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IndentLevel
condition|;
operator|++
name|i
control|)
name|OS
operator|<<
literal|"  "
expr_stmt|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|HexNumber
name|hex
argument_list|(
argument|T Value
argument_list|)
block|{
return|return
name|HexNumber
argument_list|(
name|Value
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|TEnum
operator|>
name|void
name|printEnum
argument_list|(
argument|StringRef Label
argument_list|,
argument|T Value
argument_list|,
argument|ArrayRef<EnumEntry<TEnum>> EnumValues
argument_list|)
block|{
name|StringRef
name|Name
block|;
name|bool
name|Found
operator|=
name|false
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|EnumItem
range|:
name|EnumValues
control|)
block|{
if|if
condition|(
name|EnumItem
operator|.
name|Value
operator|==
name|Value
condition|)
block|{
name|Name
operator|=
name|EnumItem
operator|.
name|Name
expr_stmt|;
name|Found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|Found
condition|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Name
operator|<<
literal|" ("
operator|<<
name|hex
argument_list|(
name|Value
argument_list|)
operator|<<
literal|")\n"
expr_stmt|;
block|}
else|else
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|hex
argument_list|(
name|Value
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
block|}
block|}
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|TFlag
operator|>
name|void
name|printFlags
argument_list|(
argument|StringRef Label
argument_list|,
argument|T Value
argument_list|,
argument|ArrayRef<EnumEntry<TFlag>> Flags
argument_list|,
argument|TFlag EnumMask1 = {}
argument_list|,
argument|TFlag EnumMask2 = {}
argument_list|,
argument|TFlag EnumMask3 = {}
argument_list|)
block|{
typedef|typedef
name|EnumEntry
operator|<
name|TFlag
operator|>
name|FlagEntry
expr_stmt|;
typedef|typedef
name|SmallVector
operator|<
name|FlagEntry
operator|,
literal|10
operator|>
name|FlagVector
expr_stmt|;
name|FlagVector
name|SetFlags
decl_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|Flag
range|:
name|Flags
control|)
block|{
if|if
condition|(
name|Flag
operator|.
name|Value
operator|==
literal|0
condition|)
continue|continue;
name|TFlag
name|EnumMask
block|{}
empty_stmt|;
if|if
condition|(
name|Flag
operator|.
name|Value
operator|&
name|EnumMask1
condition|)
name|EnumMask
operator|=
name|EnumMask1
expr_stmt|;
elseif|else
if|if
condition|(
name|Flag
operator|.
name|Value
operator|&
name|EnumMask2
condition|)
name|EnumMask
operator|=
name|EnumMask2
expr_stmt|;
elseif|else
if|if
condition|(
name|Flag
operator|.
name|Value
operator|&
name|EnumMask3
condition|)
name|EnumMask
operator|=
name|EnumMask3
expr_stmt|;
name|bool
name|IsEnum
init|=
operator|(
name|Flag
operator|.
name|Value
operator|&
name|EnumMask
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|IsEnum
operator|&&
operator|(
name|Value
operator|&
name|Flag
operator|.
name|Value
operator|)
operator|==
name|Flag
operator|.
name|Value
operator|)
operator|||
operator|(
name|IsEnum
operator|&&
operator|(
name|Value
operator|&
name|EnumMask
operator|)
operator|==
name|Flag
operator|.
name|Value
operator|)
condition|)
block|{
name|SetFlags
operator|.
name|push_back
argument_list|(
name|Flag
argument_list|)
expr_stmt|;
block|}
block|}
name|std
operator|::
name|sort
argument_list|(
name|SetFlags
operator|.
name|begin
argument_list|()
argument_list|,
name|SetFlags
operator|.
name|end
argument_list|()
argument_list|,
operator|&
name|flagName
operator|<
name|TFlag
operator|>
argument_list|)
expr_stmt|;
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|" [ ("
operator|<<
name|hex
argument_list|(
name|Value
argument_list|)
operator|<<
literal|")\n"
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|Flag
range|:
name|SetFlags
control|)
block|{
name|startLine
argument_list|()
operator|<<
literal|"  "
operator|<<
name|Flag
operator|.
name|Name
operator|<<
literal|" ("
operator|<<
name|hex
argument_list|(
name|Flag
operator|.
name|Value
argument_list|)
operator|<<
literal|")\n"
expr_stmt|;
block|}
name|startLine
argument_list|()
operator|<<
literal|"]\n"
expr_stmt|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|printFlags
argument_list|(
argument|StringRef Label
argument_list|,
argument|T Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|" [ ("
operator|<<
name|hex
argument_list|(
name|Value
argument_list|)
operator|<<
literal|")\n"
block|;
name|uint64_t
name|Flag
operator|=
literal|1
block|;
name|uint64_t
name|Curr
operator|=
name|Value
block|;
while|while
condition|(
name|Curr
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|Curr
operator|&
literal|1
condition|)
name|startLine
argument_list|()
operator|<<
literal|"  "
operator|<<
name|hex
argument_list|(
name|Flag
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
name|Curr
operator|>>=
literal|1
expr_stmt|;
name|Flag
operator|<<=
literal|1
expr_stmt|;
block|}
name|startLine
argument_list|()
operator|<<
literal|"]\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|uint64_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|uint32_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|uint16_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|uint8_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|unsigned
argument_list|(
name|Value
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|int64_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|int32_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|int16_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printNumber
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|int8_t
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|int
argument_list|(
name|Value
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
block|}
name|void
name|printBoolean
parameter_list|(
name|StringRef
name|Label
parameter_list|,
name|bool
name|Value
parameter_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
operator|(
name|Value
condition|?
literal|"Yes"
else|:
literal|"No"
operator|)
operator|<<
literal|'\n'
expr_stmt|;
block|}
name|template
operator|<
name|typename
name|T_
operator|>
name|void
name|printList
argument_list|(
argument|StringRef Label
argument_list|,
argument|const SmallVectorImpl<T_>&List
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": ["
block|;
name|bool
name|Comma
operator|=
name|false
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|Item
range|:
name|List
control|)
block|{
if|if
condition|(
name|Comma
condition|)
name|OS
operator|<<
literal|", "
expr_stmt|;
name|OS
operator|<<
name|Item
expr_stmt|;
name|Comma
operator|=
name|true
expr_stmt|;
block|}
name|OS
operator|<<
literal|"]\n"
expr_stmt|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|printHex
argument_list|(
argument|StringRef Label
argument_list|,
argument|T Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|hex
argument_list|(
name|Value
argument_list|)
operator|<<
literal|"\n"
block|;   }
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|printHex
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Str
argument_list|,
argument|T Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Str
operator|<<
literal|" ("
operator|<<
name|hex
argument_list|(
name|Value
argument_list|)
operator|<<
literal|")\n"
block|;   }
name|void
name|printString
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
block|;   }
name|void
name|printString
argument_list|(
argument|StringRef Label
argument_list|,
argument|const std::string&Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Value
operator|<<
literal|"\n"
block|;   }
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|printNumber
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Str
argument_list|,
argument|T Value
argument_list|)
block|{
name|startLine
argument_list|()
operator|<<
name|Label
operator|<<
literal|": "
operator|<<
name|Str
operator|<<
literal|" ("
operator|<<
name|Value
operator|<<
literal|")\n"
block|;   }
name|void
name|printBinary
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Str
argument_list|,
argument|ArrayRef<uint8_t> Value
argument_list|)
block|{
name|printBinaryImpl
argument_list|(
name|Label
argument_list|,
name|Str
argument_list|,
name|Value
argument_list|,
name|false
argument_list|)
block|;   }
name|void
name|printBinary
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Str
argument_list|,
argument|ArrayRef<char> Value
argument_list|)
block|{
name|auto
name|V
operator|=
name|makeArrayRef
argument_list|(
name|reinterpret_cast
operator|<
specifier|const
name|uint8_t
operator|*
operator|>
operator|(
name|Value
operator|.
name|data
argument_list|()
operator|)
argument_list|,
name|Value
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|printBinaryImpl
argument_list|(
name|Label
argument_list|,
name|Str
argument_list|,
name|V
argument_list|,
name|false
argument_list|)
block|;   }
name|void
name|printBinary
argument_list|(
argument|StringRef Label
argument_list|,
argument|ArrayRef<uint8_t> Value
argument_list|)
block|{
name|printBinaryImpl
argument_list|(
name|Label
argument_list|,
name|StringRef
argument_list|()
argument_list|,
name|Value
argument_list|,
name|false
argument_list|)
block|;   }
name|void
name|printBinary
argument_list|(
argument|StringRef Label
argument_list|,
argument|ArrayRef<char> Value
argument_list|)
block|{
name|auto
name|V
operator|=
name|makeArrayRef
argument_list|(
name|reinterpret_cast
operator|<
specifier|const
name|uint8_t
operator|*
operator|>
operator|(
name|Value
operator|.
name|data
argument_list|()
operator|)
argument_list|,
name|Value
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|printBinaryImpl
argument_list|(
name|Label
argument_list|,
name|StringRef
argument_list|()
argument_list|,
name|V
argument_list|,
name|false
argument_list|)
block|;   }
name|void
name|printBinary
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Value
argument_list|)
block|{
name|auto
name|V
operator|=
name|makeArrayRef
argument_list|(
name|reinterpret_cast
operator|<
specifier|const
name|uint8_t
operator|*
operator|>
operator|(
name|Value
operator|.
name|data
argument_list|()
operator|)
argument_list|,
name|Value
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|printBinaryImpl
argument_list|(
name|Label
argument_list|,
name|StringRef
argument_list|()
argument_list|,
name|V
argument_list|,
name|false
argument_list|)
block|;   }
name|void
name|printBinaryBlock
argument_list|(
argument|StringRef Label
argument_list|,
argument|StringRef Value
argument_list|)
block|{
name|auto
name|V
operator|=
name|makeArrayRef
argument_list|(
name|reinterpret_cast
operator|<
specifier|const
name|uint8_t
operator|*
operator|>
operator|(
name|Value
operator|.
name|data
argument_list|()
operator|)
argument_list|,
name|Value
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|printBinaryImpl
argument_list|(
name|Label
argument_list|,
name|StringRef
argument_list|()
argument_list|,
name|V
argument_list|,
name|true
argument_list|)
block|;   }
name|raw_ostream
operator|&
name|startLine
argument_list|()
block|{
name|printIndent
argument_list|()
block|;
return|return
name|OS
return|;
block|}
name|raw_ostream
modifier|&
name|getOStream
parameter_list|()
block|{
return|return
name|OS
return|;
block|}
name|private
label|:
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|bool
name|flagName
argument_list|(
argument|const EnumEntry<T>& lhs
argument_list|,
argument|const EnumEntry<T>& rhs
argument_list|)
block|{
return|return
name|lhs
operator|.
name|Name
operator|<
name|rhs
operator|.
name|Name
return|;
block|}
name|void
name|printBinaryImpl
argument_list|(
name|StringRef
name|Label
argument_list|,
name|StringRef
name|Str
argument_list|,
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|Value
argument_list|,
name|bool
name|Block
argument_list|)
decl_stmt|;
name|raw_ostream
modifier|&
name|OS
decl_stmt|;
name|int
name|IndentLevel
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|DictScope
block|{
name|DictScope
argument_list|(
argument|StreamWriter& W
argument_list|,
argument|StringRef N
argument_list|)
block|:
name|W
argument_list|(
argument|W
argument_list|)
block|{
name|W
operator|.
name|startLine
argument_list|()
operator|<<
name|N
operator|<<
literal|" {\n"
expr_stmt|;
name|W
operator|.
name|indent
argument_list|()
expr_stmt|;
block|}
operator|~
name|DictScope
argument_list|()
block|{
name|W
operator|.
name|unindent
argument_list|()
block|;
name|W
operator|.
name|startLine
argument_list|()
operator|<<
literal|"}\n"
block|;   }
name|StreamWriter
operator|&
name|W
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ListScope
block|{
name|ListScope
argument_list|(
argument|StreamWriter& W
argument_list|,
argument|StringRef N
argument_list|)
block|:
name|W
argument_list|(
argument|W
argument_list|)
block|{
name|W
operator|.
name|startLine
argument_list|()
operator|<<
name|N
operator|<<
literal|" [\n"
expr_stmt|;
name|W
operator|.
name|indent
argument_list|()
expr_stmt|;
block|}
operator|~
name|ListScope
argument_list|()
block|{
name|W
operator|.
name|unindent
argument_list|()
block|;
name|W
operator|.
name|startLine
argument_list|()
operator|<<
literal|"]\n"
block|;   }
name|StreamWriter
operator|&
name|W
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
unit|}
comment|// namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

