begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<mach-o/loader.h>
end_include

begin_include
include|#
directive|include
file|<mach-o/compact_unwind_encoding.h>
end_include

begin_include
include|#
directive|include
file|<mach/machine.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<mach-o/nlist.h>
end_include

begin_define
define|#
directive|define
name|EXTRACT_BITS
parameter_list|(
name|value
parameter_list|,
name|mask
parameter_list|)
define|\
value|( (value>> __builtin_ctz(mask))& (((1<< __builtin_popcount(mask)))-1) )
end_define

begin_comment
comment|// A quick sketch of a program which can parse the compact unwind info
end_comment

begin_comment
comment|// used on Darwin systems for exception handling.  The output of
end_comment

begin_comment
comment|// unwinddump will be more authoritative/reliable but this program
end_comment

begin_comment
comment|// can dump at least the UNWIND_X86_64_MODE_RBP_FRAME format entries
end_comment

begin_comment
comment|// correctly.
end_comment

begin_struct
struct|struct
name|symbol
block|{
name|uint64_t
name|file_address
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|symbol_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|a
argument_list|)
operator|->
name|file_address
operator|-
operator|(
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|b
operator|)
operator|->
name|file_address
return|;
block|}
end_function

begin_struct
struct|struct
name|baton
block|{
name|cpu_type_t
name|cputype
decl_stmt|;
name|uint8_t
modifier|*
name|mach_header_start
decl_stmt|;
comment|// pointer into this program's address space
name|uint8_t
modifier|*
name|compact_unwind_start
decl_stmt|;
comment|// pointer into this program's address space
name|int
name|addr_size
decl_stmt|;
comment|// 4 or 8 bytes, the size of addresses in this file
name|uint64_t
name|text_segment_vmaddr
decl_stmt|;
comment|// __TEXT segment vmaddr
name|uint64_t
name|text_segment_file_offset
decl_stmt|;
name|uint64_t
name|text_section_vmaddr
decl_stmt|;
comment|// __TEXT,__text section vmaddr
name|uint64_t
name|text_section_file_offset
decl_stmt|;
name|uint64_t
name|eh_section_file_address
decl_stmt|;
comment|// the file address of the __TEXT,__eh_frame section
name|uint8_t
modifier|*
name|lsda_array_start
decl_stmt|;
comment|// for the currently-being-processed first-level index
name|uint8_t
modifier|*
name|lsda_array_end
decl_stmt|;
comment|// the lsda_array_start for the NEXT first-level index
name|struct
name|symbol
modifier|*
name|symbols
decl_stmt|;
name|int
name|symbols_count
decl_stmt|;
name|uint64_t
modifier|*
name|function_start_addresses
decl_stmt|;
name|int
name|function_start_addresses_count
decl_stmt|;
name|int
name|current_index_table_number
decl_stmt|;
name|struct
name|unwind_info_section_header
name|unwind_header
decl_stmt|;
name|struct
name|unwind_info_section_header_index_entry
name|first_level_index_entry
decl_stmt|;
name|struct
name|unwind_info_compressed_second_level_page_header
name|compressed_second_level_page_header
decl_stmt|;
name|struct
name|unwind_info_regular_second_level_page_header
name|regular_second_level_page_header
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|uint64_t
name|read_leb128
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|offset
parameter_list|)
block|{
name|uint64_t
name|result
init|=
literal|0
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|uint8_t
name|byte
init|=
operator|*
operator|*
name|offset
decl_stmt|;
operator|*
name|offset
operator|=
operator|*
name|offset
operator|+
literal|1
expr_stmt|;
name|result
operator||=
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
break|break;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|// step through the load commands in a thin mach-o binary,
end_comment

begin_comment
comment|// find the cputype and the start of the __TEXT,__unwind_info
end_comment

begin_comment
comment|// section, return a pointer to that section or NULL if not found.
end_comment

begin_function
specifier|static
name|void
name|scan_macho_load_commands
parameter_list|(
name|struct
name|baton
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|symtab_command
name|symtab_cmd
decl_stmt|;
name|uint64_t
name|linkedit_segment_vmaddr
decl_stmt|;
name|uint64_t
name|linkedit_segment_file_offset
decl_stmt|;
name|baton
operator|->
name|compact_unwind_start
operator|=
literal|0
expr_stmt|;
name|uint32_t
modifier|*
name|magic
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|baton
operator|->
name|mach_header_start
decl_stmt|;
if|if
condition|(
operator|*
name|magic
operator|!=
name|MH_MAGIC
operator|&&
operator|*
name|magic
operator|!=
name|MH_MAGIC_64
condition|)
block|{
name|printf
argument_list|(
literal|"Unexpected magic number 0x%x in header, exiting."
argument_list|,
operator|*
name|magic
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bool
name|is_64bit
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|*
name|magic
operator|==
name|MH_MAGIC_64
condition|)
name|is_64bit
operator|=
name|true
expr_stmt|;
name|uint8_t
modifier|*
name|offset
init|=
name|baton
operator|->
name|mach_header_start
decl_stmt|;
name|struct
name|mach_header
name|mh
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|mh
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mach_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_64bit
condition|)
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mach_header_64
argument_list|)
expr_stmt|;
else|else
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mach_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_64bit
condition|)
name|baton
operator|->
name|addr_size
operator|=
literal|8
expr_stmt|;
else|else
name|baton
operator|->
name|addr_size
operator|=
literal|4
expr_stmt|;
name|baton
operator|->
name|cputype
operator|=
name|mh
operator|.
name|cputype
expr_stmt|;
name|uint8_t
modifier|*
name|start_of_load_commands
init|=
name|offset
decl_stmt|;
name|uint32_t
name|cur_cmd
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cur_cmd
operator|<
name|mh
operator|.
name|ncmds
operator|&&
operator|(
name|offset
operator|-
name|start_of_load_commands
operator|)
operator|<
name|mh
operator|.
name|sizeofcmds
condition|)
block|{
name|struct
name|load_command
name|lc
decl_stmt|;
name|uint32_t
modifier|*
name|lc_cmd
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|offset
decl_stmt|;
name|uint32_t
modifier|*
name|lc_cmdsize
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|offset
operator|+
literal|1
decl_stmt|;
name|uint8_t
modifier|*
name|start_of_this_load_cmd
init|=
name|offset
decl_stmt|;
if|if
condition|(
operator|*
name|lc_cmd
operator|==
name|LC_SEGMENT
operator|||
operator|*
name|lc_cmd
operator|==
name|LC_SEGMENT_64
condition|)
block|{
name|char
name|segment_name
index|[
literal|17
index|]
decl_stmt|;
name|segment_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|uint32_t
name|nsects
init|=
literal|0
decl_stmt|;
name|uint64_t
name|segment_offset
init|=
literal|0
decl_stmt|;
name|uint64_t
name|segment_vmaddr
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|lc_cmd
operator|==
name|LC_SEGMENT_64
condition|)
block|{
name|struct
name|segment_command_64
name|seg
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|seg
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|segment_command_64
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|segment_name
argument_list|,
operator|&
name|seg
operator|.
name|segname
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|segment_name
index|[
literal|16
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nsects
operator|=
name|seg
operator|.
name|nsects
expr_stmt|;
name|segment_offset
operator|=
name|seg
operator|.
name|fileoff
expr_stmt|;
name|segment_vmaddr
operator|=
name|seg
operator|.
name|vmaddr
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|segment_command_64
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|seg
operator|.
name|flags
operator|&
name|SG_PROTECTED_VERSION_1
operator|)
operator|==
name|SG_PROTECTED_VERSION_1
condition|)
block|{
name|printf
argument_list|(
literal|"Segment '%s' is encrypted.\n"
argument_list|,
name|segment_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|lc_cmd
operator|==
name|LC_SEGMENT
condition|)
block|{
name|struct
name|segment_command
name|seg
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|seg
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|segment_command
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|segment_name
argument_list|,
operator|&
name|seg
operator|.
name|segname
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|segment_name
index|[
literal|16
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nsects
operator|=
name|seg
operator|.
name|nsects
expr_stmt|;
name|segment_offset
operator|=
name|seg
operator|.
name|fileoff
expr_stmt|;
name|segment_vmaddr
operator|=
name|seg
operator|.
name|vmaddr
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|segment_command
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|seg
operator|.
name|flags
operator|&
name|SG_PROTECTED_VERSION_1
operator|)
operator|==
name|SG_PROTECTED_VERSION_1
condition|)
block|{
name|printf
argument_list|(
literal|"Segment '%s' is encrypted.\n"
argument_list|,
name|segment_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nsects
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|,
literal|"__TEXT"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|baton
operator|->
name|text_segment_vmaddr
operator|=
name|segment_vmaddr
expr_stmt|;
name|baton
operator|->
name|text_segment_file_offset
operator|=
name|segment_offset
expr_stmt|;
name|uint32_t
name|current_sect
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|current_sect
operator|<
name|nsects
operator|&&
operator|(
name|offset
operator|-
name|start_of_this_load_cmd
operator|)
operator|<
operator|*
name|lc_cmdsize
condition|)
block|{
name|char
name|sect_name
index|[
literal|17
index|]
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|sect_name
argument_list|,
name|offset
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|sect_name
index|[
literal|16
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sect_name
argument_list|,
literal|"__unwind_info"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_64bit
condition|)
block|{
name|struct
name|section_64
name|sect
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|sect
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_64
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|compact_unwind_start
operator|=
name|baton
operator|->
name|mach_header_start
operator|+
name|sect
operator|.
name|offset
expr_stmt|;
block|}
else|else
block|{
name|struct
name|section
name|sect
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|sect
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|compact_unwind_start
operator|=
name|baton
operator|->
name|mach_header_start
operator|+
name|sect
operator|.
name|offset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|sect_name
argument_list|,
literal|"__eh_frame"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_64bit
condition|)
block|{
name|struct
name|section_64
name|sect
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|sect
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_64
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|eh_section_file_address
operator|=
name|sect
operator|.
name|addr
expr_stmt|;
block|}
else|else
block|{
name|struct
name|section
name|sect
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|sect
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|eh_section_file_address
operator|=
name|sect
operator|.
name|addr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|sect_name
argument_list|,
literal|"__text"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_64bit
condition|)
block|{
name|struct
name|section_64
name|sect
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|sect
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_64
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|text_section_vmaddr
operator|=
name|sect
operator|.
name|addr
expr_stmt|;
name|baton
operator|->
name|text_section_file_offset
operator|=
name|sect
operator|.
name|offset
expr_stmt|;
block|}
else|else
block|{
name|struct
name|section
name|sect
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|sect
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|text_section_vmaddr
operator|=
name|sect
operator|.
name|addr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_64bit
condition|)
block|{
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|section_64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|section
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|segment_name
argument_list|,
literal|"__LINKEDIT"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|linkedit_segment_vmaddr
operator|=
name|segment_vmaddr
expr_stmt|;
name|linkedit_segment_file_offset
operator|=
name|segment_offset
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|lc_cmd
operator|==
name|LC_SYMTAB
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|symtab_cmd
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_command
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|lc_cmd
operator|==
name|LC_DYSYMTAB
condition|)
block|{
name|struct
name|dysymtab_command
name|dysymtab_cmd
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|dysymtab_cmd
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dysymtab_command
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|nlist_size
init|=
literal|12
decl_stmt|;
if|if
condition|(
name|is_64bit
condition|)
name|nlist_size
operator|=
literal|16
expr_stmt|;
name|char
modifier|*
name|string_table
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|baton
operator|->
name|mach_header_start
operator|+
name|symtab_cmd
operator|.
name|stroff
operator|)
decl_stmt|;
name|uint8_t
modifier|*
name|local_syms
init|=
name|baton
operator|->
name|mach_header_start
operator|+
name|symtab_cmd
operator|.
name|symoff
operator|+
operator|(
name|dysymtab_cmd
operator|.
name|ilocalsym
operator|*
name|nlist_size
operator|)
decl_stmt|;
name|int
name|local_syms_count
init|=
name|dysymtab_cmd
operator|.
name|nlocalsym
decl_stmt|;
name|uint8_t
modifier|*
name|exported_syms
init|=
name|baton
operator|->
name|mach_header_start
operator|+
name|symtab_cmd
operator|.
name|symoff
operator|+
operator|(
name|dysymtab_cmd
operator|.
name|iextdefsym
operator|*
name|nlist_size
operator|)
decl_stmt|;
name|int
name|exported_syms_count
init|=
name|dysymtab_cmd
operator|.
name|nextdefsym
decl_stmt|;
comment|// We're only going to create records for a small number of these symbols but to
comment|// simplify the memory management I'll allocate enough space to store all of them.
name|baton
operator|->
name|symbols
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
operator|*
operator|(
name|local_syms_count
operator|+
name|exported_syms_count
operator|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|symbols_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|local_syms_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nlist_64
name|nlist
decl_stmt|;
if|if
condition|(
name|is_64bit
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|nlist
argument_list|,
name|local_syms
operator|+
operator|(
name|i
operator|*
name|nlist_size
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist_64
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|nlist
name|nlist_32
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|nlist_32
argument_list|,
name|local_syms
operator|+
operator|(
name|i
operator|*
name|nlist_size
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
name|nlist
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|nlist_32
operator|.
name|n_un
operator|.
name|n_strx
expr_stmt|;
name|nlist
operator|.
name|n_type
operator|=
name|nlist_32
operator|.
name|n_type
expr_stmt|;
name|nlist
operator|.
name|n_sect
operator|=
name|nlist_32
operator|.
name|n_sect
expr_stmt|;
name|nlist
operator|.
name|n_desc
operator|=
name|nlist_32
operator|.
name|n_desc
expr_stmt|;
name|nlist
operator|.
name|n_value
operator|=
name|nlist_32
operator|.
name|n_value
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nlist
operator|.
name|n_type
operator|&
name|N_STAB
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|nlist
operator|.
name|n_type
operator|&
name|N_EXT
operator|)
operator|==
literal|1
operator|||
operator|(
operator|(
name|nlist
operator|.
name|n_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_TYPE
operator|&&
name|nlist
operator|.
name|n_sect
operator|!=
name|NO_SECT
operator|)
operator|)
operator|&&
name|nlist
operator|.
name|n_value
operator|!=
literal|0
operator|&&
name|nlist
operator|.
name|n_value
operator|!=
name|baton
operator|->
name|text_segment_vmaddr
condition|)
block|{
name|baton
operator|->
name|symbols
index|[
name|baton
operator|->
name|symbols_count
index|]
operator|.
name|file_address
operator|=
name|nlist
operator|.
name|n_value
expr_stmt|;
name|baton
operator|->
name|symbols
index|[
name|baton
operator|->
name|symbols_count
index|]
operator|.
name|name
operator|=
name|string_table
operator|+
name|nlist
operator|.
name|n_un
operator|.
name|n_strx
expr_stmt|;
name|baton
operator|->
name|symbols_count
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exported_syms_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nlist_64
name|nlist
decl_stmt|;
if|if
condition|(
name|is_64bit
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|nlist
argument_list|,
name|exported_syms
operator|+
operator|(
name|i
operator|*
name|nlist_size
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist_64
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|nlist
name|nlist_32
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|nlist_32
argument_list|,
name|exported_syms
operator|+
operator|(
name|i
operator|*
name|nlist_size
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
name|nlist
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|nlist_32
operator|.
name|n_un
operator|.
name|n_strx
expr_stmt|;
name|nlist
operator|.
name|n_type
operator|=
name|nlist_32
operator|.
name|n_type
expr_stmt|;
name|nlist
operator|.
name|n_sect
operator|=
name|nlist_32
operator|.
name|n_sect
expr_stmt|;
name|nlist
operator|.
name|n_desc
operator|=
name|nlist_32
operator|.
name|n_desc
expr_stmt|;
name|nlist
operator|.
name|n_value
operator|=
name|nlist_32
operator|.
name|n_value
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nlist
operator|.
name|n_type
operator|&
name|N_STAB
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|nlist
operator|.
name|n_type
operator|&
name|N_EXT
operator|)
operator|==
literal|1
operator|||
operator|(
operator|(
name|nlist
operator|.
name|n_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_TYPE
operator|&&
name|nlist
operator|.
name|n_sect
operator|!=
name|NO_SECT
operator|)
operator|)
operator|&&
name|nlist
operator|.
name|n_value
operator|!=
literal|0
operator|&&
name|nlist
operator|.
name|n_value
operator|!=
name|baton
operator|->
name|text_segment_vmaddr
condition|)
block|{
name|baton
operator|->
name|symbols
index|[
name|baton
operator|->
name|symbols_count
index|]
operator|.
name|file_address
operator|=
name|nlist
operator|.
name|n_value
expr_stmt|;
name|baton
operator|->
name|symbols
index|[
name|baton
operator|->
name|symbols_count
index|]
operator|.
name|name
operator|=
name|string_table
operator|+
name|nlist
operator|.
name|n_un
operator|.
name|n_strx
expr_stmt|;
name|baton
operator|->
name|symbols_count
operator|++
expr_stmt|;
block|}
block|}
name|qsort
argument_list|(
name|baton
operator|->
name|symbols
argument_list|,
name|baton
operator|->
name|symbols_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|,
name|symbol_compare
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|lc_cmd
operator|==
name|LC_FUNCTION_STARTS
condition|)
block|{
name|struct
name|linkedit_data_command
name|function_starts_cmd
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|function_starts_cmd
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linkedit_data_command
argument_list|)
argument_list|)
expr_stmt|;
name|uint8_t
modifier|*
name|funcstarts_offset
init|=
name|baton
operator|->
name|mach_header_start
operator|+
name|function_starts_cmd
operator|.
name|dataoff
decl_stmt|;
name|uint8_t
modifier|*
name|function_end
init|=
name|funcstarts_offset
operator|+
name|function_starts_cmd
operator|.
name|datasize
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|funcstarts_offset
operator|<
name|function_end
condition|)
block|{
if|if
condition|(
name|read_leb128
argument_list|(
operator|&
name|funcstarts_offset
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
name|baton
operator|->
name|function_start_addresses
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|baton
operator|->
name|function_start_addresses_count
operator|=
name|count
expr_stmt|;
name|funcstarts_offset
operator|=
name|baton
operator|->
name|mach_header_start
operator|+
name|function_starts_cmd
operator|.
name|dataoff
expr_stmt|;
name|uint64_t
name|current_pc
init|=
name|baton
operator|->
name|text_segment_vmaddr
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|funcstarts_offset
operator|<
name|function_end
condition|)
block|{
name|uint64_t
name|func_start
init|=
name|read_leb128
argument_list|(
operator|&
name|funcstarts_offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|func_start
operator|!=
literal|0
condition|)
block|{
name|current_pc
operator|+=
name|func_start
expr_stmt|;
name|baton
operator|->
name|function_start_addresses
index|[
name|i
operator|++
index|]
operator|=
name|current_pc
expr_stmt|;
block|}
block|}
block|}
name|offset
operator|=
name|start_of_this_load_cmd
operator|+
operator|*
name|lc_cmdsize
expr_stmt|;
name|cur_cmd
operator|++
expr_stmt|;
block|}
comment|// Augment the symbol table with the function starts table -- adding symbol entries
comment|// for functions that were stripped.
name|int
name|unnamed_functions_to_add
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|baton
operator|->
name|function_start_addresses_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|symbol
name|search_key
decl_stmt|;
name|search_key
operator|.
name|file_address
operator|=
name|baton
operator|->
name|function_start_addresses
index|[
name|i
index|]
expr_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
name|bsearch
argument_list|(
operator|&
name|search_key
argument_list|,
name|baton
operator|->
name|symbols
argument_list|,
name|baton
operator|->
name|symbols_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|,
name|symbol_compare
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|unnamed_functions_to_add
operator|++
expr_stmt|;
block|}
name|baton
operator|->
name|symbols
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|realloc
argument_list|(
name|baton
operator|->
name|symbols
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
operator|*
operator|(
name|baton
operator|->
name|symbols_count
operator|+
name|unnamed_functions_to_add
operator|)
argument_list|)
expr_stmt|;
name|int
name|current_unnamed_symbol
init|=
literal|1
decl_stmt|;
name|int
name|number_symbols_added
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|baton
operator|->
name|function_start_addresses_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|symbol
name|search_key
decl_stmt|;
name|search_key
operator|.
name|file_address
operator|=
name|baton
operator|->
name|function_start_addresses
index|[
name|i
index|]
expr_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
name|bsearch
argument_list|(
operator|&
name|search_key
argument_list|,
name|baton
operator|->
name|symbols
argument_list|,
name|baton
operator|->
name|symbols_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|,
name|symbol_compare
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|asprintf
argument_list|(
operator|&
name|name
argument_list|,
literal|"unnamed function #%d"
argument_list|,
name|current_unnamed_symbol
operator|++
argument_list|)
expr_stmt|;
name|baton
operator|->
name|symbols
index|[
name|baton
operator|->
name|symbols_count
operator|+
name|number_symbols_added
index|]
operator|.
name|file_address
operator|=
name|baton
operator|->
name|function_start_addresses
index|[
name|i
index|]
expr_stmt|;
name|baton
operator|->
name|symbols
index|[
name|baton
operator|->
name|symbols_count
operator|+
name|number_symbols_added
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|number_symbols_added
operator|++
expr_stmt|;
block|}
block|}
name|baton
operator|->
name|symbols_count
operator|+=
name|number_symbols_added
expr_stmt|;
name|qsort
argument_list|(
name|baton
operator|->
name|symbols
argument_list|,
name|baton
operator|->
name|symbols_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|,
name|symbol_compare
argument_list|)
expr_stmt|;
comment|//    printf ("function start addresses\n");
comment|//    for (int i = 0; i< baton->function_start_addresses_count; i++)
comment|//    {
comment|//        printf ("0x%012llx\n", baton->function_start_addresses[i]);
comment|//    }
comment|//    printf ("symbol table names& addresses\n");
comment|//    for (int i = 0; i< baton->symbols_count; i++)
comment|//    {
comment|//        printf ("0x%012llx %s\n", baton->symbols[i].file_address, baton->symbols[i].name);
comment|//    }
block|}
end_function

begin_function
name|void
name|print_encoding_x86_64
parameter_list|(
name|struct
name|baton
name|baton
parameter_list|,
name|uint8_t
modifier|*
name|function_start
parameter_list|,
name|uint32_t
name|encoding
parameter_list|)
block|{
name|int
name|mode
init|=
name|encoding
operator|&
name|UNWIND_X86_64_MODE_MASK
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|UNWIND_X86_64_MODE_RBP_FRAME
case|:
block|{
name|printf
argument_list|(
literal|"frame func: CFA is rbp+%d "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" rip=[CFA-8] rbp=[CFA-16]"
argument_list|)
expr_stmt|;
name|uint32_t
name|saved_registers_offset
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_X86_64_RBP_FRAME_OFFSET
argument_list|)
decl_stmt|;
name|uint32_t
name|saved_registers_locations
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_X86_64_RBP_FRAME_REGISTERS
argument_list|)
decl_stmt|;
name|saved_registers_offset
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|saved_registers_locations
operator|&
literal|0x7
condition|)
block|{
case|case
name|UNWIND_X86_64_REG_NONE
case|:
break|break;
case|case
name|UNWIND_X86_64_REG_RBX
case|:
name|printf
argument_list|(
literal|" rbx=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_64_REG_R12
case|:
name|printf
argument_list|(
literal|" r12=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_64_REG_R13
case|:
name|printf
argument_list|(
literal|" r13=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_64_REG_R14
case|:
name|printf
argument_list|(
literal|" r14=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_64_REG_R15
case|:
name|printf
argument_list|(
literal|" r15=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|8
argument_list|)
expr_stmt|;
break|break;
block|}
name|saved_registers_offset
operator|--
expr_stmt|;
name|saved_registers_locations
operator|>>=
literal|3
expr_stmt|;
block|}
block|}
break|break;
case|case
name|UNWIND_X86_64_MODE_STACK_IND
case|:
case|case
name|UNWIND_X86_64_MODE_STACK_IMMD
case|:
block|{
name|uint32_t
name|stack_size
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_X86_64_FRAMELESS_STACK_SIZE
argument_list|)
decl_stmt|;
name|uint32_t
name|register_count
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_X86_64_FRAMELESS_STACK_REG_COUNT
argument_list|)
decl_stmt|;
name|uint32_t
name|permutation
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_X86_64_FRAMELESS_STACK_REG_PERMUTATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|UNWIND_X86_64_MODE_STACK_IND
operator|&&
name|function_start
condition|)
block|{
name|uint32_t
name|stack_adjust
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_X86_64_FRAMELESS_STACK_ADJUST
argument_list|)
decl_stmt|;
comment|// offset into the function instructions; 0 == beginning of first instruction
name|uint32_t
name|offset_to_subl_insn
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_X86_64_FRAMELESS_STACK_SIZE
argument_list|)
decl_stmt|;
name|stack_size
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|function_start
operator|+
name|offset_to_subl_insn
operator|)
operator|)
expr_stmt|;
name|stack_size
operator|+=
name|stack_adjust
operator|*
literal|8
expr_stmt|;
name|printf
argument_list|(
literal|"large stack "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|UNWIND_X86_64_MODE_STACK_IND
condition|)
block|{
name|printf
argument_list|(
literal|"frameless function: stack size %d, register count %d "
argument_list|,
name|stack_size
operator|*
literal|8
argument_list|,
name|register_count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"frameless function: stack size %d, register count %d "
argument_list|,
name|stack_size
argument_list|,
name|register_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|register_count
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" no registers saved"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We need to include (up to) 6 registers in 10 bits.
comment|// That would be 18 bits if we just used 3 bits per reg to indicate
comment|// the order they're saved on the stack.
comment|//
comment|// This is done with Lehmer code permutation, e.g. see
comment|// http://stackoverflow.com/questions/1506078/fast-permutation-number-permutation-mapping-algorithms
name|int
name|permunreg
index|[
literal|6
index|]
decl_stmt|;
comment|// This decodes the variable-base number in the 10 bits
comment|// and gives us the Lehmer code sequence which can then
comment|// be decoded.
switch|switch
condition|(
name|register_count
condition|)
block|{
case|case
literal|6
case|:
name|permunreg
index|[
literal|0
index|]
operator|=
name|permutation
operator|/
literal|120
expr_stmt|;
comment|// 120 == 5!
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|0
index|]
operator|*
literal|120
operator|)
expr_stmt|;
name|permunreg
index|[
literal|1
index|]
operator|=
name|permutation
operator|/
literal|24
expr_stmt|;
comment|// 24 == 4!
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|1
index|]
operator|*
literal|24
operator|)
expr_stmt|;
name|permunreg
index|[
literal|2
index|]
operator|=
name|permutation
operator|/
literal|6
expr_stmt|;
comment|// 6 == 3!
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|2
index|]
operator|*
literal|6
operator|)
expr_stmt|;
name|permunreg
index|[
literal|3
index|]
operator|=
name|permutation
operator|/
literal|2
expr_stmt|;
comment|// 2 == 2!
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|3
index|]
operator|*
literal|2
operator|)
expr_stmt|;
name|permunreg
index|[
literal|4
index|]
operator|=
name|permutation
expr_stmt|;
comment|// 1 == 1!
name|permunreg
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|permunreg
index|[
literal|0
index|]
operator|=
name|permutation
operator|/
literal|120
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|0
index|]
operator|*
literal|120
operator|)
expr_stmt|;
name|permunreg
index|[
literal|1
index|]
operator|=
name|permutation
operator|/
literal|24
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|1
index|]
operator|*
literal|24
operator|)
expr_stmt|;
name|permunreg
index|[
literal|2
index|]
operator|=
name|permutation
operator|/
literal|6
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|2
index|]
operator|*
literal|6
operator|)
expr_stmt|;
name|permunreg
index|[
literal|3
index|]
operator|=
name|permutation
operator|/
literal|2
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|3
index|]
operator|*
literal|2
operator|)
expr_stmt|;
name|permunreg
index|[
literal|4
index|]
operator|=
name|permutation
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|permunreg
index|[
literal|0
index|]
operator|=
name|permutation
operator|/
literal|60
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|0
index|]
operator|*
literal|60
operator|)
expr_stmt|;
name|permunreg
index|[
literal|1
index|]
operator|=
name|permutation
operator|/
literal|12
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|1
index|]
operator|*
literal|12
operator|)
expr_stmt|;
name|permunreg
index|[
literal|2
index|]
operator|=
name|permutation
operator|/
literal|3
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|2
index|]
operator|*
literal|3
operator|)
expr_stmt|;
name|permunreg
index|[
literal|3
index|]
operator|=
name|permutation
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|permunreg
index|[
literal|0
index|]
operator|=
name|permutation
operator|/
literal|20
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|0
index|]
operator|*
literal|20
operator|)
expr_stmt|;
name|permunreg
index|[
literal|1
index|]
operator|=
name|permutation
operator|/
literal|4
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|1
index|]
operator|*
literal|4
operator|)
expr_stmt|;
name|permunreg
index|[
literal|2
index|]
operator|=
name|permutation
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|permunreg
index|[
literal|0
index|]
operator|=
name|permutation
operator|/
literal|5
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|0
index|]
operator|*
literal|5
operator|)
expr_stmt|;
name|permunreg
index|[
literal|1
index|]
operator|=
name|permutation
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|permunreg
index|[
literal|0
index|]
operator|=
name|permutation
expr_stmt|;
break|break;
block|}
comment|// Decode the Lehmer code for this permutation of
comment|// the registers v. http://en.wikipedia.org/wiki/Lehmer_code
name|int
name|registers
index|[
literal|6
index|]
decl_stmt|;
name|bool
name|used
index|[
literal|7
index|]
init|=
block|{
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|register_count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|renum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
literal|7
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|used
index|[
name|j
index|]
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|renum
operator|==
name|permunreg
index|[
name|i
index|]
condition|)
block|{
name|registers
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|used
index|[
name|j
index|]
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|renum
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|UNWIND_X86_64_MODE_STACK_IND
condition|)
block|{
name|printf
argument_list|(
literal|" CFA is rsp+%d "
argument_list|,
name|stack_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" CFA is rsp+%d "
argument_list|,
name|stack_size
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
name|uint32_t
name|saved_registers_offset
init|=
literal|1
decl_stmt|;
name|printf
argument_list|(
literal|" rip=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|8
argument_list|)
expr_stmt|;
name|saved_registers_offset
operator|++
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
operator|(
sizeof|sizeof
argument_list|(
name|registers
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|registers
index|[
name|i
index|]
condition|)
block|{
case|case
name|UNWIND_X86_64_REG_NONE
case|:
break|break;
case|case
name|UNWIND_X86_64_REG_RBX
case|:
name|printf
argument_list|(
literal|" rbx=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|8
argument_list|)
expr_stmt|;
name|saved_registers_offset
operator|++
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_64_REG_R12
case|:
name|printf
argument_list|(
literal|" r12=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|8
argument_list|)
expr_stmt|;
name|saved_registers_offset
operator|++
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_64_REG_R13
case|:
name|printf
argument_list|(
literal|" r13=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|8
argument_list|)
expr_stmt|;
name|saved_registers_offset
operator|++
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_64_REG_R14
case|:
name|printf
argument_list|(
literal|" r14=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|8
argument_list|)
expr_stmt|;
name|saved_registers_offset
operator|++
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_64_REG_R15
case|:
name|printf
argument_list|(
literal|" r15=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|8
argument_list|)
expr_stmt|;
name|saved_registers_offset
operator|++
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_64_REG_RBP
case|:
name|printf
argument_list|(
literal|" rbp=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|8
argument_list|)
expr_stmt|;
name|saved_registers_offset
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
break|break;
case|case
name|UNWIND_X86_64_MODE_DWARF
case|:
block|{
name|uint32_t
name|dwarf_offset
init|=
name|encoding
operator|&
name|UNWIND_X86_DWARF_SECTION_OFFSET
decl_stmt|;
name|printf
argument_list|(
literal|"DWARF unwind instructions: FDE at offset %d (file address 0x%"
name|PRIx64
literal|")"
argument_list|,
name|dwarf_offset
argument_list|,
name|dwarf_offset
operator|+
name|baton
operator|.
name|eh_section_file_address
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
block|{
name|printf
argument_list|(
literal|" no unwind information"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|void
name|print_encoding_i386
parameter_list|(
name|struct
name|baton
name|baton
parameter_list|,
name|uint8_t
modifier|*
name|function_start
parameter_list|,
name|uint32_t
name|encoding
parameter_list|)
block|{
name|int
name|mode
init|=
name|encoding
operator|&
name|UNWIND_X86_MODE_MASK
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|UNWIND_X86_MODE_EBP_FRAME
case|:
block|{
name|printf
argument_list|(
literal|"frame func: CFA is ebp+%d "
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" eip=[CFA-4] ebp=[CFA-8]"
argument_list|)
expr_stmt|;
name|uint32_t
name|saved_registers_offset
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_X86_EBP_FRAME_OFFSET
argument_list|)
decl_stmt|;
name|uint32_t
name|saved_registers_locations
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_X86_EBP_FRAME_REGISTERS
argument_list|)
decl_stmt|;
name|saved_registers_offset
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|saved_registers_locations
operator|&
literal|0x7
condition|)
block|{
case|case
name|UNWIND_X86_REG_NONE
case|:
break|break;
case|case
name|UNWIND_X86_REG_EBX
case|:
name|printf
argument_list|(
literal|" ebx=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_REG_ECX
case|:
name|printf
argument_list|(
literal|" ecx=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_REG_EDX
case|:
name|printf
argument_list|(
literal|" edx=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_REG_EDI
case|:
name|printf
argument_list|(
literal|" edi=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_REG_ESI
case|:
name|printf
argument_list|(
literal|" esi=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
name|saved_registers_offset
operator|--
expr_stmt|;
name|saved_registers_locations
operator|>>=
literal|3
expr_stmt|;
block|}
block|}
break|break;
case|case
name|UNWIND_X86_MODE_STACK_IND
case|:
case|case
name|UNWIND_X86_MODE_STACK_IMMD
case|:
block|{
name|uint32_t
name|stack_size
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_X86_FRAMELESS_STACK_SIZE
argument_list|)
decl_stmt|;
name|uint32_t
name|register_count
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_X86_FRAMELESS_STACK_REG_COUNT
argument_list|)
decl_stmt|;
name|uint32_t
name|permutation
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_X86_FRAMELESS_STACK_REG_PERMUTATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|UNWIND_X86_MODE_STACK_IND
operator|&&
name|function_start
condition|)
block|{
name|uint32_t
name|stack_adjust
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_X86_FRAMELESS_STACK_ADJUST
argument_list|)
decl_stmt|;
comment|// offset into the function instructions; 0 == beginning of first instruction
name|uint32_t
name|offset_to_subl_insn
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_X86_FRAMELESS_STACK_SIZE
argument_list|)
decl_stmt|;
name|stack_size
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|function_start
operator|+
name|offset_to_subl_insn
operator|)
operator|)
expr_stmt|;
name|stack_size
operator|+=
name|stack_adjust
operator|*
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|"large stack "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|UNWIND_X86_MODE_STACK_IND
condition|)
block|{
name|printf
argument_list|(
literal|"frameless function: stack size %d, register count %d "
argument_list|,
name|stack_size
argument_list|,
name|register_count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"frameless function: stack size %d, register count %d "
argument_list|,
name|stack_size
operator|*
literal|4
argument_list|,
name|register_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|register_count
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" no registers saved"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We need to include (up to) 6 registers in 10 bits.
comment|// That would be 18 bits if we just used 3 bits per reg to indicate
comment|// the order they're saved on the stack.
comment|//
comment|// This is done with Lehmer code permutation, e.g. see
comment|// http://stackoverflow.com/questions/1506078/fast-permutation-number-permutation-mapping-algorithms
name|int
name|permunreg
index|[
literal|6
index|]
decl_stmt|;
comment|// This decodes the variable-base number in the 10 bits
comment|// and gives us the Lehmer code sequence which can then
comment|// be decoded.
switch|switch
condition|(
name|register_count
condition|)
block|{
case|case
literal|6
case|:
name|permunreg
index|[
literal|0
index|]
operator|=
name|permutation
operator|/
literal|120
expr_stmt|;
comment|// 120 == 5!
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|0
index|]
operator|*
literal|120
operator|)
expr_stmt|;
name|permunreg
index|[
literal|1
index|]
operator|=
name|permutation
operator|/
literal|24
expr_stmt|;
comment|// 24 == 4!
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|1
index|]
operator|*
literal|24
operator|)
expr_stmt|;
name|permunreg
index|[
literal|2
index|]
operator|=
name|permutation
operator|/
literal|6
expr_stmt|;
comment|// 6 == 3!
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|2
index|]
operator|*
literal|6
operator|)
expr_stmt|;
name|permunreg
index|[
literal|3
index|]
operator|=
name|permutation
operator|/
literal|2
expr_stmt|;
comment|// 2 == 2!
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|3
index|]
operator|*
literal|2
operator|)
expr_stmt|;
name|permunreg
index|[
literal|4
index|]
operator|=
name|permutation
expr_stmt|;
comment|// 1 == 1!
name|permunreg
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|permunreg
index|[
literal|0
index|]
operator|=
name|permutation
operator|/
literal|120
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|0
index|]
operator|*
literal|120
operator|)
expr_stmt|;
name|permunreg
index|[
literal|1
index|]
operator|=
name|permutation
operator|/
literal|24
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|1
index|]
operator|*
literal|24
operator|)
expr_stmt|;
name|permunreg
index|[
literal|2
index|]
operator|=
name|permutation
operator|/
literal|6
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|2
index|]
operator|*
literal|6
operator|)
expr_stmt|;
name|permunreg
index|[
literal|3
index|]
operator|=
name|permutation
operator|/
literal|2
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|3
index|]
operator|*
literal|2
operator|)
expr_stmt|;
name|permunreg
index|[
literal|4
index|]
operator|=
name|permutation
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|permunreg
index|[
literal|0
index|]
operator|=
name|permutation
operator|/
literal|60
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|0
index|]
operator|*
literal|60
operator|)
expr_stmt|;
name|permunreg
index|[
literal|1
index|]
operator|=
name|permutation
operator|/
literal|12
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|1
index|]
operator|*
literal|12
operator|)
expr_stmt|;
name|permunreg
index|[
literal|2
index|]
operator|=
name|permutation
operator|/
literal|3
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|2
index|]
operator|*
literal|3
operator|)
expr_stmt|;
name|permunreg
index|[
literal|3
index|]
operator|=
name|permutation
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|permunreg
index|[
literal|0
index|]
operator|=
name|permutation
operator|/
literal|20
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|0
index|]
operator|*
literal|20
operator|)
expr_stmt|;
name|permunreg
index|[
literal|1
index|]
operator|=
name|permutation
operator|/
literal|4
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|1
index|]
operator|*
literal|4
operator|)
expr_stmt|;
name|permunreg
index|[
literal|2
index|]
operator|=
name|permutation
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|permunreg
index|[
literal|0
index|]
operator|=
name|permutation
operator|/
literal|5
expr_stmt|;
name|permutation
operator|-=
operator|(
name|permunreg
index|[
literal|0
index|]
operator|*
literal|5
operator|)
expr_stmt|;
name|permunreg
index|[
literal|1
index|]
operator|=
name|permutation
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|permunreg
index|[
literal|0
index|]
operator|=
name|permutation
expr_stmt|;
break|break;
block|}
comment|// Decode the Lehmer code for this permutation of
comment|// the registers v. http://en.wikipedia.org/wiki/Lehmer_code
name|int
name|registers
index|[
literal|6
index|]
decl_stmt|;
name|bool
name|used
index|[
literal|7
index|]
init|=
block|{
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|false
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|register_count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|renum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
literal|7
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|used
index|[
name|j
index|]
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|renum
operator|==
name|permunreg
index|[
name|i
index|]
condition|)
block|{
name|registers
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|used
index|[
name|j
index|]
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|renum
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|UNWIND_X86_MODE_STACK_IND
condition|)
block|{
name|printf
argument_list|(
literal|" CFA is esp+%d "
argument_list|,
name|stack_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" CFA is esp+%d "
argument_list|,
name|stack_size
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
name|uint32_t
name|saved_registers_offset
init|=
literal|1
decl_stmt|;
name|printf
argument_list|(
literal|" eip=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|4
argument_list|)
expr_stmt|;
name|saved_registers_offset
operator|++
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
operator|(
sizeof|sizeof
argument_list|(
name|registers
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|registers
index|[
name|i
index|]
condition|)
block|{
case|case
name|UNWIND_X86_REG_NONE
case|:
break|break;
case|case
name|UNWIND_X86_REG_EBX
case|:
name|printf
argument_list|(
literal|" ebx=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|4
argument_list|)
expr_stmt|;
name|saved_registers_offset
operator|++
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_REG_ECX
case|:
name|printf
argument_list|(
literal|" ecx=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|4
argument_list|)
expr_stmt|;
name|saved_registers_offset
operator|++
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_REG_EDX
case|:
name|printf
argument_list|(
literal|" edx=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|4
argument_list|)
expr_stmt|;
name|saved_registers_offset
operator|++
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_REG_EDI
case|:
name|printf
argument_list|(
literal|" edi=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|4
argument_list|)
expr_stmt|;
name|saved_registers_offset
operator|++
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_REG_ESI
case|:
name|printf
argument_list|(
literal|" esi=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|4
argument_list|)
expr_stmt|;
name|saved_registers_offset
operator|++
expr_stmt|;
break|break;
case|case
name|UNWIND_X86_REG_EBP
case|:
name|printf
argument_list|(
literal|" ebp=[CFA-%d]"
argument_list|,
name|saved_registers_offset
operator|*
literal|4
argument_list|)
expr_stmt|;
name|saved_registers_offset
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
break|break;
case|case
name|UNWIND_X86_MODE_DWARF
case|:
block|{
name|uint32_t
name|dwarf_offset
init|=
name|encoding
operator|&
name|UNWIND_X86_DWARF_SECTION_OFFSET
decl_stmt|;
name|printf
argument_list|(
literal|"DWARF unwind instructions: FDE at offset %d (file address 0x%"
name|PRIx64
literal|")"
argument_list|,
name|dwarf_offset
argument_list|,
name|dwarf_offset
operator|+
name|baton
operator|.
name|eh_section_file_address
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
block|{
name|printf
argument_list|(
literal|" no unwind information"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|void
name|print_encoding
parameter_list|(
name|struct
name|baton
name|baton
parameter_list|,
name|uint8_t
modifier|*
name|function_start
parameter_list|,
name|uint32_t
name|encoding
parameter_list|)
block|{
if|if
condition|(
name|baton
operator|.
name|cputype
operator|==
name|CPU_TYPE_X86_64
condition|)
block|{
name|print_encoding_x86_64
argument_list|(
name|baton
argument_list|,
name|function_start
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baton
operator|.
name|cputype
operator|==
name|CPU_TYPE_I386
condition|)
block|{
name|print_encoding_i386
argument_list|(
name|baton
argument_list|,
name|function_start
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" -- unsupported encoding arch -- "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_function_encoding
parameter_list|(
name|struct
name|baton
name|baton
parameter_list|,
name|uint32_t
name|idx
parameter_list|,
name|uint32_t
name|encoding
parameter_list|,
name|uint32_t
name|entry_encoding_index
parameter_list|,
name|uint32_t
name|entry_func_offset
parameter_list|)
block|{
name|char
modifier|*
name|entry_encoding_index_str
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|entry_encoding_index
operator|!=
operator|(
name|uint32_t
operator|)
operator|-
literal|1
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|entry_encoding_index_str
argument_list|,
literal|", encoding #%d"
argument_list|,
name|entry_encoding_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asprintf
argument_list|(
operator|&
name|entry_encoding_index_str
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|uint64_t
name|file_address
init|=
name|baton
operator|.
name|first_level_index_entry
operator|.
name|functionOffset
operator|+
name|entry_func_offset
operator|+
name|baton
operator|.
name|text_segment_vmaddr
decl_stmt|;
name|printf
argument_list|(
literal|"    func [%d] offset %d (file addr 0x%"
name|PRIx64
literal|")%s, encoding is 0x%x"
argument_list|,
name|idx
argument_list|,
name|entry_func_offset
argument_list|,
name|file_address
argument_list|,
name|entry_encoding_index_str
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|struct
name|symbol
modifier|*
name|symbol
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|baton
operator|.
name|symbols_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|baton
operator|.
name|symbols_count
operator|-
literal|1
operator|&&
name|baton
operator|.
name|symbols
index|[
name|i
index|]
operator|.
name|file_address
operator|<=
name|file_address
condition|)
block|{
name|symbol
operator|=
operator|&
operator|(
name|baton
operator|.
name|symbols
index|[
name|i
index|]
operator|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|baton
operator|.
name|symbols
index|[
name|i
index|]
operator|.
name|file_address
operator|<=
name|file_address
operator|&&
name|baton
operator|.
name|symbols
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|file_address
operator|>
name|file_address
condition|)
block|{
name|symbol
operator|=
operator|&
operator|(
name|baton
operator|.
name|symbols
index|[
name|i
index|]
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"\n         "
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
condition|)
block|{
name|int
name|offset
init|=
name|file_address
operator|-
name|symbol
operator|->
name|file_address
decl_stmt|;
comment|// FIXME this is a poor heuristic - if we're greater than 16 bytes past the
comment|// start of the function, this is the unwind info for a stripped function.
comment|// In reality the compact unwind entry may not line up exactly with the
comment|// function bounds.
if|if
condition|(
name|offset
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"name: %s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" + %d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n         "
argument_list|)
expr_stmt|;
block|}
name|print_encoding
argument_list|(
name|baton
argument_list|,
name|baton
operator|.
name|mach_header_start
operator|+
name|baton
operator|.
name|first_level_index_entry
operator|.
name|functionOffset
operator|+
name|baton
operator|.
name|text_section_file_offset
operator|+
name|entry_func_offset
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|bool
name|has_lsda
init|=
name|encoding
operator|&
name|UNWIND_HAS_LSDA
decl_stmt|;
if|if
condition|(
name|has_lsda
condition|)
block|{
name|uint32_t
name|func_offset
init|=
name|entry_func_offset
operator|+
name|baton
operator|.
name|first_level_index_entry
operator|.
name|functionOffset
decl_stmt|;
name|int
name|lsda_entry_number
init|=
operator|-
literal|1
decl_stmt|;
name|uint32_t
name|low
init|=
literal|0
decl_stmt|;
name|uint32_t
name|high
init|=
operator|(
name|baton
operator|.
name|lsda_array_end
operator|-
name|baton
operator|.
name|lsda_array_start
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|unwind_info_section_header_lsda_index_entry
argument_list|)
decl_stmt|;
while|while
condition|(
name|low
operator|<
name|high
condition|)
block|{
name|uint32_t
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
decl_stmt|;
name|uint8_t
modifier|*
name|mid_lsda_entry_addr
init|=
operator|(
name|baton
operator|.
name|lsda_array_start
operator|+
operator|(
name|mid
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|unwind_info_section_header_lsda_index_entry
argument_list|)
operator|)
operator|)
decl_stmt|;
name|struct
name|unwind_info_section_header_lsda_index_entry
name|mid_lsda_entry
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|mid_lsda_entry
argument_list|,
name|mid_lsda_entry_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unwind_info_section_header_lsda_index_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid_lsda_entry
operator|.
name|functionOffset
operator|==
name|func_offset
condition|)
block|{
name|lsda_entry_number
operator|=
operator|(
name|mid_lsda_entry_addr
operator|-
name|baton
operator|.
name|lsda_array_start
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|unwind_info_section_header_lsda_index_entry
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|mid_lsda_entry
operator|.
name|functionOffset
operator|<
name|func_offset
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|high
operator|=
name|mid
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lsda_entry_number
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|", LSDA entry #%d"
argument_list|,
name|lsda_entry_number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|", LSDA entry not found"
argument_list|)
expr_stmt|;
block|}
block|}
name|uint32_t
name|pers_idx
init|=
name|EXTRACT_BITS
argument_list|(
name|encoding
argument_list|,
name|UNWIND_PERSONALITY_MASK
argument_list|)
decl_stmt|;
if|if
condition|(
name|pers_idx
operator|!=
literal|0
condition|)
block|{
name|pers_idx
operator|--
expr_stmt|;
comment|// Change 1-based to 0-based index
name|printf
argument_list|(
literal|", personality entry #%d"
argument_list|,
name|pers_idx
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_second_level_index_regular
parameter_list|(
name|struct
name|baton
name|baton
parameter_list|)
block|{
name|uint8_t
modifier|*
name|page_entries
init|=
name|baton
operator|.
name|compact_unwind_start
operator|+
name|baton
operator|.
name|first_level_index_entry
operator|.
name|secondLevelPagesSectionOffset
operator|+
name|baton
operator|.
name|regular_second_level_page_header
operator|.
name|entryPageOffset
decl_stmt|;
name|uint32_t
name|entries_count
init|=
name|baton
operator|.
name|regular_second_level_page_header
operator|.
name|entryCount
decl_stmt|;
name|uint8_t
modifier|*
name|offset
init|=
name|page_entries
decl_stmt|;
name|uint32_t
name|idx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|entries_count
condition|)
block|{
name|uint32_t
name|func_offset
init|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|offset
operator|)
operator|)
decl_stmt|;
name|uint32_t
name|encoding
init|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|offset
operator|+
literal|4
operator|)
operator|)
decl_stmt|;
comment|// UNWIND_SECOND_LEVEL_REGULAR entries have a funcOffset which includes the
comment|// functionOffset from the containing index table already.  UNWIND_SECOND_LEVEL_COMPRESSED
comment|// entries only have the offset from the containing index table functionOffset.
comment|// So strip off the contianing index table functionOffset value here so they can
comment|// be treated the same at the lower layers.
name|print_function_encoding
argument_list|(
name|baton
argument_list|,
name|idx
argument_list|,
name|encoding
argument_list|,
operator|(
name|uint32_t
operator|)
operator|-
literal|1
argument_list|,
name|func_offset
operator|-
name|baton
operator|.
name|first_level_index_entry
operator|.
name|functionOffset
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_second_level_index_compressed
parameter_list|(
name|struct
name|baton
name|baton
parameter_list|)
block|{
name|uint8_t
modifier|*
name|this_index
init|=
name|baton
operator|.
name|compact_unwind_start
operator|+
name|baton
operator|.
name|first_level_index_entry
operator|.
name|secondLevelPagesSectionOffset
decl_stmt|;
name|uint8_t
modifier|*
name|start_of_entries
init|=
name|this_index
operator|+
name|baton
operator|.
name|compressed_second_level_page_header
operator|.
name|entryPageOffset
decl_stmt|;
name|uint8_t
modifier|*
name|offset
init|=
name|start_of_entries
decl_stmt|;
for|for
control|(
name|uint16_t
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|baton
operator|.
name|compressed_second_level_page_header
operator|.
name|entryCount
condition|;
name|idx
operator|++
control|)
block|{
name|uint32_t
name|entry
init|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|offset
operator|)
decl_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|uint32_t
name|encoding
decl_stmt|;
name|uint32_t
name|entry_encoding_index
init|=
name|UNWIND_INFO_COMPRESSED_ENTRY_ENCODING_INDEX
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|uint32_t
name|entry_func_offset
init|=
name|UNWIND_INFO_COMPRESSED_ENTRY_FUNC_OFFSET
argument_list|(
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry_encoding_index
operator|<
name|baton
operator|.
name|unwind_header
operator|.
name|commonEncodingsArrayCount
condition|)
block|{
comment|// encoding is in common table in section header
name|encoding
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|baton
operator|.
name|compact_unwind_start
operator|+
name|baton
operator|.
name|unwind_header
operator|.
name|commonEncodingsArraySectionOffset
operator|+
operator|(
name|entry_encoding_index
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// encoding is in page specific table
name|uint32_t
name|page_encoding_index
init|=
name|entry_encoding_index
operator|-
name|baton
operator|.
name|unwind_header
operator|.
name|commonEncodingsArrayCount
decl_stmt|;
name|encoding
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|this_index
operator|+
name|baton
operator|.
name|compressed_second_level_page_header
operator|.
name|encodingsPageOffset
operator|+
operator|(
name|page_encoding_index
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|)
operator|)
expr_stmt|;
block|}
name|print_function_encoding
argument_list|(
name|baton
argument_list|,
name|idx
argument_list|,
name|encoding
argument_list|,
name|entry_encoding_index
argument_list|,
name|entry_func_offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_second_level_index
parameter_list|(
name|struct
name|baton
name|baton
parameter_list|)
block|{
name|uint8_t
modifier|*
name|index_start
init|=
name|baton
operator|.
name|compact_unwind_start
operator|+
name|baton
operator|.
name|first_level_index_entry
operator|.
name|secondLevelPagesSectionOffset
decl_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|index_start
operator|)
operator|==
name|UNWIND_SECOND_LEVEL_REGULAR
condition|)
block|{
name|struct
name|unwind_info_regular_second_level_page_header
name|header
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|header
argument_list|,
name|index_start
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unwind_info_regular_second_level_page_header
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  UNWIND_SECOND_LEVEL_REGULAR #%d entryPageOffset %d, entryCount %d\n"
argument_list|,
name|baton
operator|.
name|current_index_table_number
argument_list|,
name|header
operator|.
name|entryPageOffset
argument_list|,
name|header
operator|.
name|entryCount
argument_list|)
expr_stmt|;
name|baton
operator|.
name|regular_second_level_page_header
operator|=
name|header
expr_stmt|;
name|print_second_level_index_regular
argument_list|(
name|baton
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|index_start
operator|)
operator|==
name|UNWIND_SECOND_LEVEL_COMPRESSED
condition|)
block|{
name|struct
name|unwind_info_compressed_second_level_page_header
name|header
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|header
argument_list|,
name|index_start
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unwind_info_compressed_second_level_page_header
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  UNWIND_SECOND_LEVEL_COMPRESSED #%d entryPageOffset %d, entryCount %d, encodingsPageOffset %d, encodingsCount %d\n"
argument_list|,
name|baton
operator|.
name|current_index_table_number
argument_list|,
name|header
operator|.
name|entryPageOffset
argument_list|,
name|header
operator|.
name|entryCount
argument_list|,
name|header
operator|.
name|encodingsPageOffset
argument_list|,
name|header
operator|.
name|encodingsCount
argument_list|)
expr_stmt|;
name|baton
operator|.
name|compressed_second_level_page_header
operator|=
name|header
expr_stmt|;
name|print_second_level_index_compressed
argument_list|(
name|baton
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_index_sections
parameter_list|(
name|struct
name|baton
name|baton
parameter_list|)
block|{
name|uint8_t
modifier|*
name|index_section_offset
init|=
name|baton
operator|.
name|compact_unwind_start
operator|+
name|baton
operator|.
name|unwind_header
operator|.
name|indexSectionOffset
decl_stmt|;
name|uint32_t
name|index_count
init|=
name|baton
operator|.
name|unwind_header
operator|.
name|indexCount
decl_stmt|;
name|uint32_t
name|cur_idx
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|offset
init|=
name|index_section_offset
decl_stmt|;
while|while
condition|(
name|cur_idx
operator|<
name|index_count
condition|)
block|{
name|baton
operator|.
name|current_index_table_number
operator|=
name|cur_idx
expr_stmt|;
name|struct
name|unwind_info_section_header_index_entry
name|index_entry
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|index_entry
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unwind_info_section_header_index_entry
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"index section #%d: functionOffset %d, secondLevelPagesSectionOffset %d, lsdaIndexArraySectionOffset %d\n"
argument_list|,
name|cur_idx
argument_list|,
name|index_entry
operator|.
name|functionOffset
argument_list|,
name|index_entry
operator|.
name|secondLevelPagesSectionOffset
argument_list|,
name|index_entry
operator|.
name|lsdaIndexArraySectionOffset
argument_list|)
expr_stmt|;
comment|// secondLevelPagesSectionOffset == 0 means this is a sentinel entry
if|if
condition|(
name|index_entry
operator|.
name|secondLevelPagesSectionOffset
operator|!=
literal|0
condition|)
block|{
name|struct
name|unwind_info_section_header_index_entry
name|next_index_entry
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|next_index_entry
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|unwind_info_section_header_index_entry
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unwind_info_section_header_index_entry
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|.
name|lsda_array_start
operator|=
name|baton
operator|.
name|compact_unwind_start
operator|+
name|index_entry
operator|.
name|lsdaIndexArraySectionOffset
expr_stmt|;
name|baton
operator|.
name|lsda_array_end
operator|=
name|baton
operator|.
name|compact_unwind_start
operator|+
name|next_index_entry
operator|.
name|lsdaIndexArraySectionOffset
expr_stmt|;
name|uint8_t
modifier|*
name|lsda_entry_offset
init|=
name|baton
operator|.
name|lsda_array_start
decl_stmt|;
name|uint32_t
name|lsda_count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|lsda_entry_offset
operator|<
name|baton
operator|.
name|lsda_array_end
condition|)
block|{
name|struct
name|unwind_info_section_header_lsda_index_entry
name|lsda_entry
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|lsda_entry
argument_list|,
name|lsda_entry_offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unwind_info_section_header_lsda_index_entry
argument_list|)
argument_list|)
expr_stmt|;
name|uint64_t
name|function_file_address
init|=
name|baton
operator|.
name|first_level_index_entry
operator|.
name|functionOffset
operator|+
name|lsda_entry
operator|.
name|functionOffset
operator|+
name|baton
operator|.
name|text_segment_vmaddr
decl_stmt|;
name|uint64_t
name|lsda_file_address
init|=
name|lsda_entry
operator|.
name|lsdaOffset
operator|+
name|baton
operator|.
name|text_segment_vmaddr
decl_stmt|;
name|printf
argument_list|(
literal|"    LSDA [%d] functionOffset %d (%d) (file address 0x%"
name|PRIx64
literal|"), lsdaOffset %d (file address 0x%"
name|PRIx64
literal|")\n"
argument_list|,
name|lsda_count
argument_list|,
name|lsda_entry
operator|.
name|functionOffset
argument_list|,
name|lsda_entry
operator|.
name|functionOffset
operator|-
name|index_entry
operator|.
name|functionOffset
argument_list|,
name|function_file_address
argument_list|,
name|lsda_entry
operator|.
name|lsdaOffset
argument_list|,
name|lsda_file_address
argument_list|)
expr_stmt|;
name|lsda_count
operator|++
expr_stmt|;
name|lsda_entry_offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|unwind_info_section_header_lsda_index_entry
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|baton
operator|.
name|first_level_index_entry
operator|=
name|index_entry
expr_stmt|;
name|print_second_level_index
argument_list|(
name|baton
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cur_idx
operator|++
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|unwind_info_section_header_index_entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|file
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|int
name|fd
init|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to open '%s'\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|uint8_t
modifier|*
name|file_mem
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|st
operator|.
name|st_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_FILE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|file_mem
operator|==
name|MAP_FAILED
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to mmap() '%s'\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
literal|"a.out"
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|struct
name|baton
name|baton
decl_stmt|;
name|baton
operator|.
name|mach_header_start
operator|=
name|file_mem
expr_stmt|;
name|baton
operator|.
name|symbols
operator|=
name|NULL
expr_stmt|;
name|baton
operator|.
name|symbols_count
operator|=
literal|0
expr_stmt|;
name|baton
operator|.
name|function_start_addresses
operator|=
name|NULL
expr_stmt|;
name|baton
operator|.
name|function_start_addresses_count
operator|=
literal|0
expr_stmt|;
name|scan_macho_load_commands
argument_list|(
operator|&
name|baton
argument_list|)
expr_stmt|;
if|if
condition|(
name|baton
operator|.
name|compact_unwind_start
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"could not find __TEXT,__unwind_info section\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|struct
name|unwind_info_section_header
name|header
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|header
argument_list|,
name|baton
operator|.
name|compact_unwind_start
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unwind_info_section_header
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Header:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  version %u\n"
argument_list|,
name|header
operator|.
name|version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  commonEncodingsArraySectionOffset is %d\n"
argument_list|,
name|header
operator|.
name|commonEncodingsArraySectionOffset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  commonEncodingsArrayCount is %d\n"
argument_list|,
name|header
operator|.
name|commonEncodingsArrayCount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  personalityArraySectionOffset is %d\n"
argument_list|,
name|header
operator|.
name|personalityArraySectionOffset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  personalityArrayCount is %d\n"
argument_list|,
name|header
operator|.
name|personalityArrayCount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  indexSectionOffset is %d\n"
argument_list|,
name|header
operator|.
name|indexSectionOffset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  indexCount is %d\n"
argument_list|,
name|header
operator|.
name|indexCount
argument_list|)
expr_stmt|;
name|uint8_t
modifier|*
name|common_encodings
init|=
name|baton
operator|.
name|compact_unwind_start
operator|+
name|header
operator|.
name|commonEncodingsArraySectionOffset
decl_stmt|;
name|uint32_t
name|encoding_idx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|encoding_idx
operator|<
name|header
operator|.
name|commonEncodingsArrayCount
condition|)
block|{
name|uint32_t
name|encoding
init|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|common_encodings
operator|)
decl_stmt|;
name|printf
argument_list|(
literal|"    Common Encoding [%d]: 0x%x "
argument_list|,
name|encoding_idx
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|print_encoding
argument_list|(
name|baton
argument_list|,
name|NULL
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|common_encodings
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|encoding_idx
operator|++
expr_stmt|;
block|}
name|uint8_t
modifier|*
name|pers_arr
init|=
name|baton
operator|.
name|compact_unwind_start
operator|+
name|header
operator|.
name|personalityArraySectionOffset
decl_stmt|;
name|uint32_t
name|pers_idx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pers_idx
operator|<
name|header
operator|.
name|personalityArrayCount
condition|)
block|{
name|int32_t
name|pers_delta
init|=
operator|*
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|baton
operator|.
name|compact_unwind_start
operator|+
name|header
operator|.
name|personalityArraySectionOffset
operator|+
operator|(
name|pers_idx
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|)
operator|)
decl_stmt|;
name|printf
argument_list|(
literal|"    Personality [%d]: personality function ptr @ offset %d (file address 0x%"
name|PRIx64
literal|")\n"
argument_list|,
name|pers_idx
argument_list|,
name|pers_delta
argument_list|,
name|baton
operator|.
name|text_segment_vmaddr
operator|+
name|pers_delta
argument_list|)
expr_stmt|;
name|pers_idx
operator|++
expr_stmt|;
name|pers_arr
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|baton
operator|.
name|unwind_header
operator|=
name|header
expr_stmt|;
name|print_index_sections
argument_list|(
name|baton
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

