begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * This regression test attempts to confirm that the flags used at open-time  * for a file descriptor properly limit system calls that should be affected  * by those flags.  Currently:  *  * System call                    Policy                      Tested  * __acl_aclcheck_fd(2)           any                         no  * __acl_delete_fd(2)             any                         no  * __acl_get_fd(2)                any                         no  * __acl_set_fd(2)                any                         no  * aio_fsync(2)                   any                         no  * aio_read(2)                    O_RDONLY or O_RDWR          yes  * aio_write(2)                   O_WRONLY or O_RDWR          yes  * dup(2)                         any                         yes  * dup2(2)                        any                         yes  * extattr_delete_fd(2)           O_WRONLY or O_RDWR          no  * extattr_get_fd(2)              O_RDONLY or O_RDWR          no  * extattr_list_fd(2)             O_RDONLY or O_RDWR          no  * extattr_set_fd(2)              O_WRONLY or O_RDWR          no  * fchdir(2)                      any directory               yes  * fchflags(2)                    any                         yes  * fchmod(2)                      any                         yes  * fchown(2)                      any                         yes  * flock(2)                       any                         yes  * fpathconf(2)                   any                         yes  * fstat(2)                       any                         yes  * fstatfs(2)                     any                         yes  * fsync(2)                       any                         yes  * ftruncate(2)                   O_WRONLY or O_RDWR          yes  * futimes(2)                     any                         yes  * getdents(2)                    O_RDONLY directory          yes  * lseek(2)                       any                         yes  * mmap(2) PROT_READ              O_RDONLY or O_RDWR          yes  * mmap(2) PROT_WRITE             O_WRONLY or O_RDWR          yes  * mmap(2) PROT_WRITE + MAP_PRIV  O_RDONLY or O_RDWR          yes  * mmap(2) PROT_EXEC              O_RDONLY or O_RDWR          yes  * pread(2)                       O_RDONLY or O_RDWR          yes  * preadv(2)                      O_RDONLY or O_RDWR          yes  * pwrite(2)                      O_WRONLY or O_RDWR          yes  * pwritev(2)                     O_WRONLY or O_RDWR          yes  * read(2)                        O_RDONLY or O_RDWR          yes  * readv(2)                       O_RDONLY or O_RDWR          yes  * sendfile(2)                    O_RDONLY or O_RDWR on file  yes  * write(2)                       O_WRONLY or O_RDWR          yes  * writev(2)                      O_WRONLY or O_RDWR          yes  *   * These checks do not verify that original permissions would allow the  * operation or that open is properly impacted by permissions, just that once  * a file descriptor is held, open-time limitations are implemented.  *  * We do, however, test that directories cannot be opened as writable.  *  * XXXRW: Arguably we should also test combinations of bits to mmap(2).  *  * XXXRW: Should verify mprotect() remapping limits.  *  * XXXRW: kqueue(2)/kevent(2), poll(2), select(2)  *  * XXXRW: oaio_read(2), oaio_write(2), freebsd6_*(2).  *  * XXXRW: __mac*(2)  *  * XXXRW: message queue and shared memory fds?  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<aio.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
define|#
directive|define
name|PERM_FILE
value|0644
end_define

begin_comment
comment|/* Allow read, write.  Someday exec? */
end_comment

begin_define
define|#
directive|define
name|PERM_DIR
value|0755
end_define

begin_comment
comment|/* Allow read, write, exec. */
end_comment

begin_comment
comment|/*  * Modes to try all tests with.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|file_modes
index|[]
init|=
block|{
name|O_RDONLY
block|,
name|O_WRONLY
block|,
name|O_RDWR
block|,
name|O_RDONLY
operator||
name|O_TRUNC
block|,
name|O_WRONLY
operator||
name|O_TRUNC
block|,
name|O_RDWR
operator||
name|O_TRUNC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|file_modes_count
init|=
sizeof|sizeof
argument_list|(
name|file_modes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|dir_modes
index|[]
init|=
block|{
name|O_RDONLY
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|dir_modes_count
init|=
sizeof|sizeof
argument_list|(
name|dir_modes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|testnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aio_present
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ok_mode
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|testnum
operator|++
expr_stmt|;
if|if
condition|(
name|comment
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"ok %d - %s # mode 0x%x\n"
argument_list|,
name|testnum
argument_list|,
name|testname
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ok %d - %s # mode 0x%x - %s\n"
argument_list|,
name|testnum
argument_list|,
name|testname
argument_list|,
name|mode
argument_list|,
name|comment
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notok_mode
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|testnum
operator|++
expr_stmt|;
if|if
condition|(
name|comment
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"not ok %d - %s # mode 0x%x\n"
argument_list|,
name|testnum
argument_list|,
name|testname
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"not ok %d - %s # mode 0x%x - %s\n"
argument_list|,
name|testnum
argument_list|,
name|testname
argument_list|,
name|mode
argument_list|,
name|comment
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Before we get started, confirm that we can't open directories writable.  */
end_comment

begin_function
specifier|static
name|void
name|try_directory_open
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|directory
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|expected_errno
parameter_list|)
block|{
name|int
name|dfd
decl_stmt|;
name|dfd
operator|=
name|open
argument_list|(
name|directory
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|expected_errno
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"opened"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|expected_errno
operator|&&
name|expected_errno
operator|==
name|errno
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|expected_errno
operator|!=
literal|0
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"wrong errno"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_directory_open_modes
parameter_list|(
specifier|const
name|char
modifier|*
name|directory
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|expected_errno
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* 	 * Directories should only open with O_RDONLY.  Notice that we use 	 * file_modes and not dirmodes. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|O_RDONLY
condition|)
name|expected_errno
operator|=
literal|0
expr_stmt|;
else|else
name|expected_errno
operator|=
name|EISDIR
expr_stmt|;
name|try_directory_open
argument_list|(
name|__func__
argument_list|,
name|directory
argument_list|,
name|mode
argument_list|,
name|expected_errno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_dup
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|dfd
decl_stmt|,
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* 	 * dup() should work regardless of open mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dfd
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfd
operator|>=
literal|0
condition|)
block|{
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dfd
argument_list|)
expr_stmt|;
block|}
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_dup2
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|dfd
decl_stmt|,
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* 	 * dup2() should work regardless of open mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dfd
operator|=
name|dup2
argument_list|(
name|fd
argument_list|,
literal|500
argument_list|)
expr_stmt|;
comment|/* Arbitrary but high number. */
if|if
condition|(
name|dfd
operator|>=
literal|0
condition|)
block|{
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dfd
argument_list|)
expr_stmt|;
block|}
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_fchdir
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* 	 * fchdir() should work regardless of open mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fchdir
argument_list|(
name|fd
argument_list|)
operator|==
literal|0
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_fchflags
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* 	 * fchflags() should work regardless of open mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fchflags
argument_list|(
name|fd
argument_list|,
name|UF_NODUMP
argument_list|)
operator|==
literal|0
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_fchmod
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|setmode
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* 	 * fchmod() should work regardless of open mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fchmod
argument_list|(
name|fd
argument_list|,
name|setmode
argument_list|)
operator|==
literal|0
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_fchown
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* 	 * fchown() should work regardless of open mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fchown
argument_list|(
name|fd
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_flock
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* 	 * flock() should work regardless of open mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
argument_list|)
operator|==
literal|0
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_fpathconf
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
name|long
name|l
decl_stmt|;
comment|/* 	 * fpathconf() should work regardless of open mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|l
operator|=
name|fpathconf
argument_list|(
name|fd
argument_list|,
name|_PC_FILESIZEBITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>=
literal|0
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_fstat
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* 	 * fstat() should work regardless of open mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_fstatfs
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|struct
name|statfs
name|statfs
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* 	 * fstatfs() should work regardless of open mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fstatfs
argument_list|(
name|fd
argument_list|,
operator|&
name|statfs
argument_list|)
operator|==
literal|0
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_fsync
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* 	 * fstatfs() should work regardless of open mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fsync
argument_list|(
name|fd
argument_list|)
operator|==
literal|0
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_ftruncate
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* 	 * ftruncate() should work as long as long as (mode& O_ACCMODE) is 	 * O_RDWR or O_WRONLY. 	 * 	 * Directories should never be writable, so this test should always 	 * pass for directories... 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate1 skipped"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate2 skipped"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate3 skipped"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"fstat"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate1 skipped"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate2 skipped"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate3 skipped"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"setup"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Truncate to grow file. */
if|if
condition|(
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|st_size
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
operator|)
operator|||
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
operator|)
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate1 succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate1 succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate2 skipped"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate3 skipped"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
operator|)
operator|||
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
operator|)
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate1 failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate2 skipped"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate3 skipped"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate1 failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Truncate to same size. */
if|if
condition|(
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|st_size
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
operator|)
operator|||
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
operator|)
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate2 succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate2 succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate3 skipped"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
operator|)
operator|||
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
operator|)
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate2 failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate3 skipped"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate2 failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Truncate to shrink. */
if|if
condition|(
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|st_size
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
operator|)
operator|||
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
operator|)
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate3 succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate3 succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
operator|)
operator|||
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
operator|)
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate3 failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"truncate3 failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_futimes
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* 	 * futimes() should work regardless of open mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|futimes
argument_list|(
name|fd
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_lseek
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* 	 * lseek() should work regardless of open mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|100
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
literal|100
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_getdents
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|isdir
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
comment|/* 	 * getdents() should always work on directories and never on files, 	 * assuming directories are always opened for read (which they are). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|getdents
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|isdir
operator|&&
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
operator|)
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"directory succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdir
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"directory succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"file succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isdir
operator|&&
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
operator|)
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"directory failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdir
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"directory failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"file failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_sendfile
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|isdir
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|,
name|sv
index|[
literal|2
index|]
decl_stmt|;
name|off_t
name|sent
decl_stmt|;
comment|/* 	 * sendfile() should work only on files, and only when the access mode 	 * is O_RDONLY or O_RDWR. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|socketpair
argument_list|(
name|PF_LOCAL
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"socketpair"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sendfile
argument_list|(
name|fd
argument_list|,
name|sv
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|sent
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isdir
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"directory succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
operator|)
operator|||
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
operator|)
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isdir
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"directory failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
operator|)
operator|||
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
operator|)
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|sv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Various functions write, so just make write-like wrappers for them.  */
end_comment

begin_typedef
typedef|typedef
name|ssize_t
function_decl|(
modifier|*
name|write_fn
function_decl|)
parameter_list|(
name|int
name|d
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
function_decl|;
end_typedef

begin_function
specifier|static
name|ssize_t
name|writev_wrapper
parameter_list|(
name|int
name|d
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|nbytes
expr_stmt|;
return|return
operator|(
name|writev
argument_list|(
name|d
argument_list|,
operator|&
name|iov
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|pwrite_wrapper
parameter_list|(
name|int
name|d
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
return|return
operator|(
name|pwrite
argument_list|(
name|d
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|pwritev_wrapper
parameter_list|(
name|int
name|d
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|nbytes
expr_stmt|;
return|return
operator|(
name|pwritev
argument_list|(
name|d
argument_list|,
operator|&
name|iov
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|aio_write_wrapper
parameter_list|(
name|int
name|d
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|struct
name|aiocb
name|aiocb
decl_stmt|;
name|struct
name|aiocb
specifier|const
modifier|*
name|aiocb_array
index|[]
init|=
block|{
operator|&
name|aiocb
block|}
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|aiocb
argument_list|,
sizeof|sizeof
argument_list|(
name|aiocb
argument_list|)
argument_list|)
expr_stmt|;
name|aiocb
operator|.
name|aio_fildes
operator|=
name|d
expr_stmt|;
name|aiocb
operator|.
name|aio_buf
operator|=
operator|(
name|void
operator|*
operator|)
name|buf
expr_stmt|;
name|aiocb
operator|.
name|aio_nbytes
operator|=
name|nbytes
expr_stmt|;
if|if
condition|(
name|aio_write
argument_list|(
operator|&
name|aiocb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|aiocb_array
index|[
literal|0
index|]
operator|=
operator|&
name|aiocb
expr_stmt|;
if|if
condition|(
name|aio_suspend
argument_list|(
name|aiocb_array
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|aio_return
argument_list|(
operator|&
name|aiocb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_write
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
name|write_fn
name|fn
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
name|char
name|ch
decl_stmt|;
comment|/* 	 * write() should never succeed for directories, but especially 	 * because they can only be opened read-only.  write() on files 	 * should succeed for O_WRONLY and O_RDWR descriptors. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fn
argument_list|(
name|fd
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
operator|||
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"write failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"write failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
operator|||
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
operator|)
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"write succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"write succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Various functions read, so just make read-like wrappers for them.  */
end_comment

begin_typedef
typedef|typedef
name|ssize_t
function_decl|(
modifier|*
name|read_fn
function_decl|)
parameter_list|(
name|int
name|d
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
function_decl|;
end_typedef

begin_function
specifier|static
name|ssize_t
name|readv_wrapper
parameter_list|(
name|int
name|d
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|nbytes
expr_stmt|;
return|return
operator|(
name|readv
argument_list|(
name|d
argument_list|,
operator|&
name|iov
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|pread_wrapper
parameter_list|(
name|int
name|d
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
return|return
operator|(
name|pread
argument_list|(
name|d
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|preadv_wrapper
parameter_list|(
name|int
name|d
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|nbytes
expr_stmt|;
return|return
operator|(
name|preadv
argument_list|(
name|d
argument_list|,
operator|&
name|iov
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|aio_read_wrapper
parameter_list|(
name|int
name|d
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|struct
name|aiocb
name|aiocb
decl_stmt|;
name|struct
name|aiocb
specifier|const
modifier|*
name|aiocb_array
index|[]
init|=
block|{
operator|&
name|aiocb
block|}
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|aiocb
argument_list|,
sizeof|sizeof
argument_list|(
name|aiocb
argument_list|)
argument_list|)
expr_stmt|;
name|aiocb
operator|.
name|aio_fildes
operator|=
name|d
expr_stmt|;
name|aiocb
operator|.
name|aio_buf
operator|=
name|buf
expr_stmt|;
name|aiocb
operator|.
name|aio_nbytes
operator|=
name|nbytes
expr_stmt|;
if|if
condition|(
name|aio_read
argument_list|(
operator|&
name|aiocb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|aio_suspend
argument_list|(
name|aiocb_array
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|aio_return
argument_list|(
operator|&
name|aiocb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_read
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
name|read_fn
name|fn
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
name|char
name|ch
decl_stmt|;
comment|/* 	 * read() should (generally) succeeded on directories.  read() on 	 * files should succeed for O_RDONLY and O_RDWR descriptors. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fn
argument_list|(
name|fd
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
operator|||
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"read failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"read failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
operator|||
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
operator|)
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"read succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"read succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_mmap_read
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|isdir
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
comment|/* 	 * mmap() read should fail for directories (ideally?) but succeed for 	 * O_RDONLY and O_RDWR file descriptors. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|addr
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|getpagesize
argument_list|()
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|MAP_FAILED
condition|)
block|{
if|if
condition|(
name|isdir
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap dir failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
operator|||
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap file failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap file failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isdir
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap dir succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
operator|||
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap file succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap file succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|addr
argument_list|,
name|getpagesize
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_mmap_write
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
comment|/* 	 * mmap() will always fail for directories (ideally) as they are 	 * always open O_RDONLY.  Check for O_WRONLY or O_RDWR to permit a 	 * write mapping.  This variant does a MAP_SHARED mapping, but we 	 * are also interested in MAP_PRIVATE. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|addr
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|getpagesize
argument_list|()
argument_list|,
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|MAP_FAILED
condition|)
block|{
if|if
condition|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
operator|||
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
operator|||
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|addr
argument_list|,
name|getpagesize
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_mmap_exec
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|isdir
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
comment|/* 	 * mmap() exec should fail for directories (ideally?) but succeed for 	 * O_RDONLY and O_RDWR file descriptors. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|addr
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|getpagesize
argument_list|()
argument_list|,
name|PROT_EXEC
argument_list|,
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|MAP_FAILED
condition|)
block|{
if|if
condition|(
name|isdir
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap dir failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
operator|||
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap file failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap file failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isdir
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap dir succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap file succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|addr
argument_list|,
name|getpagesize
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_mmap_write_private
parameter_list|(
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|isdir
parameter_list|,
specifier|const
name|int
modifier|*
name|modes
parameter_list|,
name|int
name|modes_count
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|mode
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
comment|/* 	 * mmap() write private should succeed for readable descriptors 	 * except for directories. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes_count
condition|;
name|i
operator|++
control|)
block|{
name|mode
operator|=
name|modes
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"open"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|addr
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|getpagesize
argument_list|()
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|MAP_FAILED
condition|)
block|{
if|if
condition|(
name|isdir
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap dir failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
operator|||
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap file failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap file failed"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isdir
condition|)
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap dir succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
operator|||
operator|(
name|mode
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDWR
condition|)
name|ok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap file succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|notok_mode
argument_list|(
name|testname
argument_list|,
literal|"mmap file succeeded"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|addr
argument_list|,
name|getpagesize
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|dir_path
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|file_path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|dummy
decl_stmt|,
name|fd
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|aio_present
operator|=
literal|0
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"vfs.aio"
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EISDIR
condition|)
name|aio_present
operator|=
literal|1
expr_stmt|;
block|}
name|strlcpy
argument_list|(
name|dir_path
argument_list|,
literal|"/tmp/open-dir.XXXXXXXXXXX"
argument_list|,
sizeof|sizeof
argument_list|(
name|dir_path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdtemp
argument_list|(
name|dir_path
argument_list|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"mkdtemp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|dir_path
argument_list|,
name|PERM_DIR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"chmod %s"
argument_list|,
name|dir_path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rmdir
argument_list|(
name|dir_path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strlcpy
argument_list|(
name|file_path
argument_list|,
literal|"/tmp/open-file.XXXXXXXXXXX"
argument_list|,
sizeof|sizeof
argument_list|(
name|file_path
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|mkstemp
argument_list|(
name|file_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"mkstemp"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rmdir
argument_list|(
name|dir_path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|file_path
argument_list|,
name|PERM_FILE
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"chmod %s"
argument_list|,
name|file_path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|file_path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rmdir
argument_list|(
name|dir_path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|check_directory_open_modes
argument_list|(
name|dir_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_dup
argument_list|(
literal|"check_dup_dir"
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_dup
argument_list|(
literal|"check_dup_file"
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_dup2
argument_list|(
literal|"check_dup2_dir"
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_dup2
argument_list|(
literal|"check_dup2_file"
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_fchdir
argument_list|(
literal|"check_fchdir"
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_fchflags
argument_list|(
literal|"check_fchflags_dir"
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_fchflags
argument_list|(
literal|"check_fchflags_file"
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_fchmod
argument_list|(
literal|"check_fchmod_dir"
argument_list|,
name|dir_path
argument_list|,
name|PERM_DIR
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_fchmod
argument_list|(
literal|"check_fchmod_file"
argument_list|,
name|file_path
argument_list|,
name|PERM_FILE
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_fchown
argument_list|(
literal|"check_fchown_dir"
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_fchown
argument_list|(
literal|"check_fchown_file"
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_flock
argument_list|(
literal|"check_flock_dir"
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_flock
argument_list|(
literal|"check_flock_file"
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_fpathconf
argument_list|(
literal|"check_fpathconf_dir"
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_fpathconf
argument_list|(
literal|"check_fpathconf_file"
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_fstat
argument_list|(
literal|"check_fstat_dir"
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_fstat
argument_list|(
literal|"check_fstat_file"
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_fstatfs
argument_list|(
literal|"check_fstatfs_dir"
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_fstatfs
argument_list|(
literal|"check_fstatfs_file"
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_fsync
argument_list|(
literal|"check_fsync_dir"
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_fsync
argument_list|(
literal|"check_fsync_file"
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_ftruncate
argument_list|(
literal|"check_ftruncate_dir"
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_ftruncate
argument_list|(
literal|"check_ftruncate_file"
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_futimes
argument_list|(
literal|"check_futimes_dir"
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_futimes
argument_list|(
literal|"check_futimes_file"
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_lseek
argument_list|(
literal|"check_lseek_dir"
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_lseek
argument_list|(
literal|"check_lseek_file"
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_getdents
argument_list|(
literal|"check_getdents_dir"
argument_list|,
name|dir_path
argument_list|,
literal|1
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_getdents
argument_list|(
literal|"check_getdents_file"
argument_list|,
name|file_path
argument_list|,
literal|0
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_sendfile
argument_list|(
literal|"check_sendfile_dir"
argument_list|,
name|dir_path
argument_list|,
literal|1
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_sendfile
argument_list|(
literal|"check_sendfile_file"
argument_list|,
name|file_path
argument_list|,
literal|0
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_write
argument_list|(
literal|"check_write_dir"
argument_list|,
name|write
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_write
argument_list|(
literal|"check_write_file"
argument_list|,
name|write
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_write
argument_list|(
literal|"check_writev_dir"
argument_list|,
name|writev_wrapper
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_write
argument_list|(
literal|"check_writev_file"
argument_list|,
name|writev_wrapper
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_write
argument_list|(
literal|"check_pwrite_dir"
argument_list|,
name|pwrite_wrapper
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_write
argument_list|(
literal|"check_pwrite_file"
argument_list|,
name|pwrite_wrapper
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_write
argument_list|(
literal|"check_pwritev_dir"
argument_list|,
name|pwritev_wrapper
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_write
argument_list|(
literal|"check_pwritev_file"
argument_list|,
name|pwritev_wrapper
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio_present
condition|)
block|{
name|check_write
argument_list|(
literal|"check_aio_write_dir"
argument_list|,
name|aio_write_wrapper
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_write
argument_list|(
literal|"check_aio_write_file"
argument_list|,
name|aio_write_wrapper
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
block|}
name|check_read
argument_list|(
literal|"check_read_dir"
argument_list|,
name|read
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_read
argument_list|(
literal|"check_read_file"
argument_list|,
name|read
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_read
argument_list|(
literal|"check_readv_dir"
argument_list|,
name|readv_wrapper
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_read
argument_list|(
literal|"check_readv_file"
argument_list|,
name|readv_wrapper
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_read
argument_list|(
literal|"check_pread_dir"
argument_list|,
name|pread_wrapper
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_read
argument_list|(
literal|"check_pread_file"
argument_list|,
name|pread_wrapper
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_read
argument_list|(
literal|"check_preadv_dir"
argument_list|,
name|preadv_wrapper
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_read
argument_list|(
literal|"check_preadv_file"
argument_list|,
name|preadv_wrapper
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio_present
condition|)
block|{
name|check_read
argument_list|(
literal|"check_aio_read_dir"
argument_list|,
name|aio_read_wrapper
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_read
argument_list|(
literal|"check_aio_read_file"
argument_list|,
name|aio_read_wrapper
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
block|}
name|check_mmap_read
argument_list|(
literal|"check_mmap_read_dir"
argument_list|,
name|dir_path
argument_list|,
literal|1
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_mmap_read
argument_list|(
literal|"check_mmap_read_file"
argument_list|,
name|file_path
argument_list|,
literal|0
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_mmap_write
argument_list|(
literal|"check_mmap_write_dir"
argument_list|,
name|dir_path
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_mmap_write
argument_list|(
literal|"check_mmap_write_file"
argument_list|,
name|file_path
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_mmap_exec
argument_list|(
literal|"check_mmap_exec_dir"
argument_list|,
name|dir_path
argument_list|,
literal|1
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_mmap_exec
argument_list|(
literal|"check_mmap_exec_file"
argument_list|,
name|file_path
argument_list|,
literal|0
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
name|check_mmap_write_private
argument_list|(
literal|"check_mmap_write_private_dir"
argument_list|,
name|dir_path
argument_list|,
literal|1
argument_list|,
name|dir_modes
argument_list|,
name|dir_modes_count
argument_list|)
expr_stmt|;
name|check_mmap_write_private
argument_list|(
literal|"check_mmap_write_private_file"
argument_list|,
name|file_path
argument_list|,
literal|0
argument_list|,
name|file_modes
argument_list|,
name|file_modes_count
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|file_path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rmdir
argument_list|(
name|dir_path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

