begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-3-Clause  *  * Copyright (c) 2008 Yahoo!, Inc.  * All rights reserved.  * Written by: John Baldwin<jhb@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/_semaphore.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<semaphore.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"test.h"
end_include

begin_comment
comment|/* Cut and pasted from kernel header, bah! */
end_comment

begin_comment
comment|/* Operations on timespecs */
end_comment

begin_define
define|#
directive|define
name|timespecclear
parameter_list|(
name|tvp
parameter_list|)
value|((tvp)->tv_sec = (tvp)->tv_nsec = 0)
end_define

begin_define
define|#
directive|define
name|timespecisset
parameter_list|(
name|tvp
parameter_list|)
value|((tvp)->tv_sec || (tvp)->tv_nsec)
end_define

begin_define
define|#
directive|define
name|timespeccmp
parameter_list|(
name|tvp
parameter_list|,
name|uvp
parameter_list|,
name|cmp
parameter_list|)
define|\
value|(((tvp)->tv_sec == (uvp)->tv_sec) ?				\ 	    ((tvp)->tv_nsec cmp (uvp)->tv_nsec) :			\ 	    ((tvp)->tv_sec cmp (uvp)->tv_sec))
end_define

begin_define
define|#
directive|define
name|timespecadd
parameter_list|(
name|vvp
parameter_list|,
name|uvp
parameter_list|)
define|\
value|do {								\ 		(vvp)->tv_sec += (uvp)->tv_sec;				\ 		(vvp)->tv_nsec += (uvp)->tv_nsec;			\ 		if ((vvp)->tv_nsec>= 1000000000) {			\ 			(vvp)->tv_sec++;				\ 			(vvp)->tv_nsec -= 1000000000;			\ 		}							\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|timespecsub
parameter_list|(
name|vvp
parameter_list|,
name|uvp
parameter_list|)
define|\
value|do {								\ 		(vvp)->tv_sec -= (uvp)->tv_sec;				\ 		(vvp)->tv_nsec -= (uvp)->tv_nsec;			\ 		if ((vvp)->tv_nsec< 0) {				\ 			(vvp)->tv_sec--;				\ 			(vvp)->tv_nsec += 1000000000;			\ 		}							\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|TEST_PATH
value|"/tmp/posixsem_regression_test"
end_define

begin_define
define|#
directive|define
name|ELAPSED
parameter_list|(
name|elapsed
parameter_list|,
name|limit
parameter_list|)
value|(abs((elapsed) - (limit))< 100)
end_define

begin_comment
comment|/* Macros for passing child status to parent over a pipe. */
end_comment

begin_define
define|#
directive|define
name|CSTAT
parameter_list|(
name|class
parameter_list|,
name|error
parameter_list|)
value|((class)<< 16 | (error))
end_define

begin_define
define|#
directive|define
name|CSTAT_CLASS
parameter_list|(
name|stat
parameter_list|)
value|((stat)>> 16)
end_define

begin_define
define|#
directive|define
name|CSTAT_ERROR
parameter_list|(
name|stat
parameter_list|)
value|((stat)& 0xffff)
end_define

begin_comment
comment|/*  * Helper routine for tests that use a child process.  This routine  * creates a pipe and forks a child process.  The child process runs  * the 'func' routine which returns a status integer.  The status  * integer gets written over the pipe to the parent and returned in  * '*stat'.  If there is an error in pipe(), fork(), or wait() this  * returns -1 and fails the test.  */
end_comment

begin_function
specifier|static
name|int
name|child_worker
parameter_list|(
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
modifier|*
name|stat
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|int
name|pfd
index|[
literal|2
index|]
decl_stmt|,
name|cstat
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pfd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|pid
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Error. */
name|fail_errno
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|0
case|:
comment|/* Child. */
name|cstat
operator|=
name|func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|,
operator|&
name|cstat
argument_list|,
sizeof|sizeof
argument_list|(
name|cstat
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|,
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stat
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"read(pipe)"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"wait"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|close
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt a ksem_open() that should fail with an expected error of  * 'error'.  */
end_comment

begin_function
specifier|static
name|void
name|ksem_open_should_fail
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
if|if
condition|(
name|ksem_open
argument_list|(
operator|&
name|id
argument_list|,
name|path
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|value
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_open() didn't fail"
argument_list|)
expr_stmt|;
name|ksem_close
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|errno
operator|!=
name|error
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_open"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt a ksem_unlink() that should fail with an expected error of  * 'error'.  */
end_comment

begin_function
specifier|static
name|void
name|ksem_unlink_should_fail
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|ksem_unlink
argument_list|(
name|path
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_unlink() didn't fail"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|errno
operator|!=
name|error
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_unlink"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt a ksem_close() that should fail with an expected error of  * 'error'.  */
end_comment

begin_function
specifier|static
name|void
name|ksem_close_should_fail
parameter_list|(
name|semid_t
name|id
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|ksem_close
argument_list|(
name|id
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_close() didn't fail"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|errno
operator|!=
name|error
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_close"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt a ksem_init() that should fail with an expected error of  * 'error'.  */
end_comment

begin_function
specifier|static
name|void
name|ksem_init_should_fail
parameter_list|(
name|unsigned
name|int
name|value
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
name|value
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_init() didn't fail"
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|errno
operator|!=
name|error
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt a ksem_destroy() that should fail with an expected error of  * 'error'.  */
end_comment

begin_function
specifier|static
name|void
name|ksem_destroy_should_fail
parameter_list|(
name|semid_t
name|id
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|ksem_destroy
argument_list|(
name|id
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_destroy() didn't fail"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|errno
operator|!=
name|error
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_destroy"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt a ksem_post() that should fail with an expected error of  * 'error'.  */
end_comment

begin_function
specifier|static
name|void
name|ksem_post_should_fail
parameter_list|(
name|semid_t
name|id
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|ksem_post
argument_list|(
name|id
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_post() didn't fail"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|errno
operator|!=
name|error
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_post"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|open_after_unlink
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
if|if
condition|(
name|ksem_open
argument_list|(
operator|&
name|id
argument_list|,
name|TEST_PATH
argument_list|,
name|O_CREAT
argument_list|,
literal|0777
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_open(1)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ksem_close
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ksem_unlink
argument_list|(
name|TEST_PATH
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_unlink"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ksem_open_should_fail
argument_list|(
name|TEST_PATH
argument_list|,
name|O_RDONLY
argument_list|,
literal|0777
argument_list|,
literal|1
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|open_after_unlink
argument_list|,
literal|"open after unlink"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|open_invalid_path
parameter_list|(
name|void
parameter_list|)
block|{
name|ksem_open_should_fail
argument_list|(
literal|"blah"
argument_list|,
literal|0
argument_list|,
literal|0777
argument_list|,
literal|1
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|open_invalid_path
argument_list|,
literal|"open invalid path"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|open_extra_flags
parameter_list|(
name|void
parameter_list|)
block|{
name|ksem_open_should_fail
argument_list|(
name|TEST_PATH
argument_list|,
name|O_RDONLY
operator||
name|O_DIRECT
argument_list|,
literal|0777
argument_list|,
literal|1
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|open_extra_flags
argument_list|,
literal|"open with extra flags"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|open_bad_value
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ksem_unlink
argument_list|(
name|TEST_PATH
argument_list|)
expr_stmt|;
name|ksem_open_should_fail
argument_list|(
name|TEST_PATH
argument_list|,
name|O_CREAT
argument_list|,
literal|0777
argument_list|,
name|UINT_MAX
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|open_bad_value
argument_list|,
literal|"open with invalid initial value"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|open_bad_path_pointer
parameter_list|(
name|void
parameter_list|)
block|{
name|ksem_open_should_fail
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|1024
argument_list|,
name|O_RDONLY
argument_list|,
literal|0777
argument_list|,
literal|1
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|open_bad_path_pointer
argument_list|,
literal|"open bad path pointer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|open_path_too_long
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|page
decl_stmt|;
name|page
operator|=
name|malloc
argument_list|(
name|MAXPATHLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|page
argument_list|,
literal|'a'
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|page
index|[
name|MAXPATHLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ksem_open_should_fail
argument_list|(
name|page
argument_list|,
name|O_RDONLY
argument_list|,
literal|0777
argument_list|,
literal|1
argument_list|,
name|ENAMETOOLONG
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|open_path_too_long
argument_list|,
literal|"open pathname too long"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|open_nonexisting_semaphore
parameter_list|(
name|void
parameter_list|)
block|{
name|ksem_open_should_fail
argument_list|(
literal|"/notreallythere"
argument_list|,
literal|0
argument_list|,
literal|0777
argument_list|,
literal|1
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|open_nonexisting_semaphore
argument_list|,
literal|"open nonexistent semaphore"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|exclusive_create_existing_semaphore
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
if|if
condition|(
name|ksem_open
argument_list|(
operator|&
name|id
argument_list|,
name|TEST_PATH
argument_list|,
name|O_CREAT
argument_list|,
literal|0777
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_open(O_CREAT)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ksem_close
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|ksem_open_should_fail
argument_list|(
name|TEST_PATH
argument_list|,
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0777
argument_list|,
literal|1
argument_list|,
name|EEXIST
argument_list|)
expr_stmt|;
name|ksem_unlink
argument_list|(
name|TEST_PATH
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|exclusive_create_existing_semaphore
argument_list|,
literal|"O_EXCL of existing semaphore"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|init_bad_value
parameter_list|(
name|void
parameter_list|)
block|{
name|ksem_init_should_fail
argument_list|(
name|UINT_MAX
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|init_bad_value
argument_list|,
literal|"init with invalid initial value"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|unlink_bad_path_pointer
parameter_list|(
name|void
parameter_list|)
block|{
name|ksem_unlink_should_fail
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|1024
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|unlink_bad_path_pointer
argument_list|,
literal|"unlink bad path pointer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|unlink_path_too_long
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|page
decl_stmt|;
name|page
operator|=
name|malloc
argument_list|(
name|MAXPATHLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|page
argument_list|,
literal|'a'
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|page
index|[
name|MAXPATHLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ksem_unlink_should_fail
argument_list|(
name|page
argument_list|,
name|ENAMETOOLONG
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|unlink_path_too_long
argument_list|,
literal|"unlink pathname too long"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|destroy_named_semaphore
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
if|if
condition|(
name|ksem_open
argument_list|(
operator|&
name|id
argument_list|,
name|TEST_PATH
argument_list|,
name|O_CREAT
argument_list|,
literal|0777
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_open(O_CREAT)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ksem_destroy_should_fail
argument_list|(
name|id
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|ksem_close
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|ksem_unlink
argument_list|(
name|TEST_PATH
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|destroy_named_semaphore
argument_list|,
literal|"destroy named semaphore"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|close_unnamed_semaphore
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ksem_close_should_fail
argument_list|(
name|id
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|close_unnamed_semaphore
argument_list|,
literal|"close unnamed semaphore"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|destroy_invalid_fd
parameter_list|(
name|void
parameter_list|)
block|{
name|ksem_destroy_should_fail
argument_list|(
name|STDERR_FILENO
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|destroy_invalid_fd
argument_list|,
literal|"destroy non-semaphore file descriptor"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|close_invalid_fd
parameter_list|(
name|void
parameter_list|)
block|{
name|ksem_close_should_fail
argument_list|(
name|STDERR_FILENO
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|close_invalid_fd
argument_list|,
literal|"close non-semaphore file descriptor"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|create_unnamed_semaphore
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_destroy
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_destroy"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|create_unnamed_semaphore
argument_list|,
literal|"create unnamed semaphore"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|open_named_semaphore
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
if|if
condition|(
name|ksem_open
argument_list|(
operator|&
name|id
argument_list|,
name|TEST_PATH
argument_list|,
name|O_CREAT
argument_list|,
literal|0777
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_open(O_CREAT)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_close
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_close"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_unlink
argument_list|(
name|TEST_PATH
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_unlink"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|open_named_semaphore
argument_list|,
literal|"create named semaphore"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|getvalue_invalid_semaphore
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|ksem_getvalue
argument_list|(
name|STDERR_FILENO
argument_list|,
operator|&
name|val
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_getvalue() didn't fail"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_getvalue"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|getvalue_invalid_semaphore
argument_list|,
literal|"get value of invalid semaphore"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|post_invalid_semaphore
parameter_list|(
name|void
parameter_list|)
block|{
name|ksem_post_should_fail
argument_list|(
name|STDERR_FILENO
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|post_invalid_semaphore
argument_list|,
literal|"post of invalid semaphore"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|wait_invalid_semaphore
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ksem_wait
argument_list|(
name|STDERR_FILENO
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_wait() didn't fail"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_wait"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|wait_invalid_semaphore
argument_list|,
literal|"wait for invalid semaphore"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|trywait_invalid_semaphore
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ksem_trywait
argument_list|(
name|STDERR_FILENO
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_trywait() didn't fail"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_trywait"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|trywait_invalid_semaphore
argument_list|,
literal|"try wait for invalid semaphore"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|timedwait_invalid_semaphore
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ksem_timedwait
argument_list|(
name|STDERR_FILENO
argument_list|,
name|NULL
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_timedwait() didn't fail"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_timedwait"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|timedwait_invalid_semaphore
argument_list|,
literal|"timed wait for invalid semaphore"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|checkvalue
parameter_list|(
name|semid_t
name|id
parameter_list|,
name|int
name|expected
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|ksem_getvalue
argument_list|(
name|id
argument_list|,
operator|&
name|val
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_getvalue"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|val
operator|!=
name|expected
condition|)
block|{
name|fail_err
argument_list|(
literal|"sem value should be %d instead of %d"
argument_list|,
name|expected
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_test
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|checkvalue
argument_list|(
name|id
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_post
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_post"
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|checkvalue
argument_list|(
name|id
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_destroy
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_destroy"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|post_test
argument_list|,
literal|"simple post"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|use_after_unlink_test
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
comment|/* 	 * Create named semaphore with value of 1 and then unlink it 	 * while still retaining the initial reference. 	 */
if|if
condition|(
name|ksem_open
argument_list|(
operator|&
name|id
argument_list|,
name|TEST_PATH
argument_list|,
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0777
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_open(O_CREAT | O_EXCL)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_unlink
argument_list|(
name|TEST_PATH
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_unlink"
argument_list|)
expr_stmt|;
name|ksem_close
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|checkvalue
argument_list|(
name|id
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_close
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Post the semaphore to set its value to 2. */
if|if
condition|(
name|ksem_post
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_post"
argument_list|)
expr_stmt|;
name|ksem_close
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|checkvalue
argument_list|(
name|id
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_close
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Wait on the semaphore which should set its value to 1. */
if|if
condition|(
name|ksem_wait
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_wait"
argument_list|)
expr_stmt|;
name|ksem_close
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|checkvalue
argument_list|(
name|id
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_close
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_close
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_close"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|use_after_unlink_test
argument_list|,
literal|"use named semaphore after unlink"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|unlocked_trywait
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This should succeed and decrement the value to 0. */
if|if
condition|(
name|ksem_trywait
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_trywait()"
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|checkvalue
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_destroy
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_destroy"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|unlocked_trywait
argument_list|,
literal|"unlocked trywait"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|locked_trywait
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This should fail with EAGAIN and leave the value at 0. */
if|if
condition|(
name|ksem_trywait
argument_list|(
name|id
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_trywait() didn't fail"
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
condition|)
block|{
name|fail_errno
argument_list|(
literal|"wrong error from ksem_trywait()"
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|checkvalue
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_destroy
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_destroy"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|locked_trywait
argument_list|,
literal|"locked trywait"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Use a timer to post a specific semaphore after a timeout.  A timer  * is scheduled via schedule_post().  check_alarm() must be called  * afterwards to clean up and check for errors.  */
end_comment

begin_decl_stmt
specifier|static
name|semid_t
name|alarm_id
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alarm_errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alarm_handler_installed
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|alarm_handler
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
if|if
condition|(
name|ksem_post
argument_list|(
name|alarm_id
argument_list|)
operator|<
literal|0
condition|)
name|alarm_errno
operator|=
name|errno
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_alarm
parameter_list|(
name|int
name|just_clear
parameter_list|)
block|{
name|struct
name|itimerval
name|it
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|it
argument_list|,
sizeof|sizeof
argument_list|(
name|it
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|just_clear
condition|)
block|{
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|it
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|alarm_errno
operator|=
literal|0
expr_stmt|;
name|alarm_id
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|it
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"setitimer"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|alarm_errno
operator|!=
literal|0
operator|&&
operator|!
name|just_clear
condition|)
block|{
name|errno
operator|=
name|alarm_errno
expr_stmt|;
name|fail_errno
argument_list|(
literal|"ksem_post() (via timeout)"
argument_list|)
expr_stmt|;
name|alarm_errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|alarm_id
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|schedule_post
parameter_list|(
name|semid_t
name|id
parameter_list|,
name|u_int
name|msec
parameter_list|)
block|{
name|struct
name|itimerval
name|it
decl_stmt|;
if|if
condition|(
operator|!
name|alarm_handler_installed
condition|)
block|{
if|if
condition|(
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarm_handler
argument_list|)
operator|==
name|SIG_ERR
condition|)
block|{
name|fail_errno
argument_list|(
literal|"signal(SIGALRM)"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|alarm_handler_installed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|alarm_id
operator|!=
operator|-
literal|1
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_post() already scheduled"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|alarm_id
operator|=
name|id
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|it
argument_list|,
sizeof|sizeof
argument_list|(
name|it
argument_list|)
argument_list|)
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|msec
operator|/
literal|1000
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
operator|(
name|msec
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|it
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"setitimer"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|timedwait
parameter_list|(
name|semid_t
name|id
parameter_list|,
name|u_int
name|msec
parameter_list|,
name|u_int
modifier|*
name|delta
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|timespec
name|start
decl_stmt|,
name|end
decl_stmt|;
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|start
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"clock_gettime(CLOCK_REALTIME)"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|end
operator|.
name|tv_sec
operator|=
name|msec
operator|/
literal|1000
expr_stmt|;
name|end
operator|.
name|tv_nsec
operator|=
name|msec
operator|%
literal|1000
operator|*
literal|1000000
expr_stmt|;
name|timespecadd
argument_list|(
operator|&
name|end
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|ksem_timedwait
argument_list|(
name|id
argument_list|,
operator|&
name|end
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|error
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_timedwait"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_timedwait() didn't fail"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|end
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"clock_gettime(CLOCK_REALTIME)"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|timespecsub
argument_list|(
operator|&
name|end
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
operator|*
name|delta
operator|=
name|end
operator|.
name|tv_nsec
operator|/
literal|1000000
expr_stmt|;
operator|*
name|delta
operator|+=
name|end
operator|.
name|tv_sec
operator|*
literal|1000
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unlocked_timedwait
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
name|u_int
name|elapsed
decl_stmt|;
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This should succeed right away and set the value to 0. */
if|if
condition|(
name|timedwait
argument_list|(
name|id
argument_list|,
literal|5000
argument_list|,
operator|&
name|elapsed
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ELAPSED
argument_list|(
name|elapsed
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_timedwait() of unlocked sem took %ums"
argument_list|,
name|elapsed
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|checkvalue
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_destroy
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_destroy"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|unlocked_timedwait
argument_list|,
literal|"unlocked timedwait"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|expired_timedwait
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
name|u_int
name|elapsed
decl_stmt|;
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This should fail with a timeout and leave the value at 0. */
if|if
condition|(
name|timedwait
argument_list|(
name|id
argument_list|,
literal|2500
argument_list|,
operator|&
name|elapsed
argument_list|,
name|ETIMEDOUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ELAPSED
argument_list|(
name|elapsed
argument_list|,
literal|2500
argument_list|)
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_timedwait() of locked sem took %ums instead of 2500ms"
argument_list|,
name|elapsed
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|checkvalue
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_destroy
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_destroy"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|expired_timedwait
argument_list|,
literal|"locked timedwait timeout"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|locked_timedwait
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
name|u_int
name|elapsed
decl_stmt|;
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Schedule a post to trigger after 1000 ms.  The subsequent 	 * timedwait should succeed after 1000 ms as a result w/o 	 * timing out. 	 */
if|if
condition|(
name|schedule_post
argument_list|(
name|id
argument_list|,
literal|1000
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|timedwait
argument_list|(
name|id
argument_list|,
literal|2000
argument_list|,
operator|&
name|elapsed
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|check_alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ELAPSED
argument_list|(
name|elapsed
argument_list|,
literal|1000
argument_list|)
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_timedwait() with delayed post took %ums instead of 1000ms"
argument_list|,
name|elapsed
argument_list|)
expr_stmt|;
name|check_alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|check_alarm
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_destroy
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_destroy"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|locked_timedwait
argument_list|,
literal|"locked timedwait"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|testwait
parameter_list|(
name|semid_t
name|id
parameter_list|,
name|u_int
modifier|*
name|delta
parameter_list|)
block|{
name|struct
name|timespec
name|start
decl_stmt|,
name|end
decl_stmt|;
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|start
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"clock_gettime(CLOCK_REALTIME)"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ksem_wait
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_wait"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|end
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"clock_gettime(CLOCK_REALTIME)"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|timespecsub
argument_list|(
operator|&
name|end
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
operator|*
name|delta
operator|=
name|end
operator|.
name|tv_nsec
operator|/
literal|1000000
expr_stmt|;
operator|*
name|delta
operator|+=
name|end
operator|.
name|tv_sec
operator|*
literal|1000
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unlocked_wait
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
name|u_int
name|elapsed
decl_stmt|;
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This should succeed right away and set the value to 0. */
if|if
condition|(
name|testwait
argument_list|(
name|id
argument_list|,
operator|&
name|elapsed
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ELAPSED
argument_list|(
name|elapsed
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_wait() of unlocked sem took %ums"
argument_list|,
name|elapsed
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|checkvalue
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_destroy
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_destroy"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|unlocked_wait
argument_list|,
literal|"unlocked wait"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|locked_wait
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
name|u_int
name|elapsed
decl_stmt|;
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Schedule a post to trigger after 1000 ms.  The subsequent 	 * wait should succeed after 1000 ms as a result. 	 */
if|if
condition|(
name|schedule_post
argument_list|(
name|id
argument_list|,
literal|1000
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|testwait
argument_list|(
name|id
argument_list|,
operator|&
name|elapsed
argument_list|)
operator|<
literal|0
condition|)
block|{
name|check_alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ELAPSED
argument_list|(
name|elapsed
argument_list|,
literal|1000
argument_list|)
condition|)
block|{
name|fail_err
argument_list|(
literal|"ksem_wait() with delayed post took %ums instead of 1000ms"
argument_list|,
name|elapsed
argument_list|)
expr_stmt|;
name|check_alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|check_alarm
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_destroy
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_destroy"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|locked_wait
argument_list|,
literal|"locked wait"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Fork off a child process.  The child will open the semaphore via  * the same name.  The child will then block on the semaphore waiting  * for the parent to post it.  */
end_comment

begin_function
specifier|static
name|int
name|wait_twoproc_child
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
if|if
condition|(
name|ksem_open
argument_list|(
operator|&
name|id
argument_list|,
name|TEST_PATH
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|CSTAT
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
name|ksem_wait
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|CSTAT
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
name|ksem_close
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|CSTAT
argument_list|(
literal|3
argument_list|,
name|errno
argument_list|)
operator|)
return|;
return|return
operator|(
name|CSTAT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wait_twoproc_test
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
name|int
name|stat
decl_stmt|;
if|if
condition|(
name|ksem_open
argument_list|(
operator|&
name|id
argument_list|,
name|TEST_PATH
argument_list|,
name|O_CREAT
argument_list|,
literal|0777
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_open"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|schedule_post
argument_list|(
name|id
argument_list|,
literal|500
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ksem_close
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|ksem_unlink
argument_list|(
name|TEST_PATH
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|child_worker
argument_list|(
name|wait_twoproc_child
argument_list|,
name|NULL
argument_list|,
operator|&
name|stat
argument_list|)
operator|<
literal|0
condition|)
block|{
name|check_alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ksem_close
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|ksem_unlink
argument_list|(
name|TEST_PATH
argument_list|)
expr_stmt|;
return|return;
block|}
name|errno
operator|=
name|CSTAT_ERROR
argument_list|(
name|stat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CSTAT_CLASS
argument_list|(
name|stat
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|pass
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fail_errno
argument_list|(
literal|"child ksem_open()"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fail_errno
argument_list|(
literal|"child ksem_wait()"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fail_errno
argument_list|(
literal|"child ksem_close()"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fail_err
argument_list|(
literal|"bad child state %#x"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
break|break;
block|}
name|check_alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ksem_close
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|ksem_unlink
argument_list|(
name|TEST_PATH
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|wait_twoproc_test
argument_list|,
literal|"two proc wait"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|maxvalue_test
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
name|SEM_VALUE_MAX
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_getvalue
argument_list|(
name|id
argument_list|,
operator|&
name|val
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_getvalue"
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|val
operator|!=
name|SEM_VALUE_MAX
condition|)
block|{
name|fail_err
argument_list|(
literal|"value %d != SEM_VALUE_MAX"
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|fail_err
argument_list|(
literal|"value< 0"
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_destroy
argument_list|(
name|id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_destroy"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|maxvalue_test
argument_list|,
literal|"get value of SEM_VALUE_MAX semaphore"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|maxvalue_post_test
parameter_list|(
name|void
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
name|SEM_VALUE_MAX
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ksem_post_should_fail
argument_list|(
name|id
argument_list|,
name|EOVERFLOW
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|maxvalue_post_test
argument_list|,
literal|"post SEM_VALUE_MAX semaphore"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|busy_destroy_test
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|errbuf
index|[
name|_POSIX2_LINE_MAX
index|]
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|kp
decl_stmt|;
name|semid_t
name|id
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|kvm_t
modifier|*
name|kd
decl_stmt|;
name|int
name|count
decl_stmt|;
name|kd
operator|=
name|kvm_openfiles
argument_list|(
name|NULL
argument_list|,
literal|"/dev/null"
argument_list|,
name|NULL
argument_list|,
name|O_RDONLY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|kd
operator|==
name|NULL
condition|)
block|{
name|fail_err
argument_list|(
literal|"kvm_openfiles: %s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
name|kvm_close
argument_list|(
name|kd
argument_list|)
expr_stmt|;
return|return;
block|}
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|pid
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Error. */
name|fail_errno
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|kvm_close
argument_list|(
name|kd
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
comment|/* Child. */
name|ksem_wait
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for the child process to block on the semaphore.  This 	 * is a bit gross. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|kp
operator|=
name|kvm_getprocs
argument_list|(
name|kd
argument_list|,
name|KERN_PROC_PID
argument_list|,
name|pid
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|kp
operator|==
name|NULL
condition|)
block|{
name|fail_err
argument_list|(
literal|"kvm_getprocs: %s"
argument_list|,
name|kvm_geterr
argument_list|(
name|kd
argument_list|)
argument_list|)
expr_stmt|;
name|kvm_close
argument_list|(
name|kd
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|kp
operator|->
name|ki_stat
operator|==
name|SSLEEP
operator|&&
operator|(
name|strcmp
argument_list|(
name|kp
operator|->
name|ki_wmesg
argument_list|,
literal|"sem"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|kp
operator|->
name|ki_wmesg
argument_list|,
literal|"ksem"
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
name|usleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|kvm_close
argument_list|(
name|kd
argument_list|)
expr_stmt|;
name|ksem_destroy_should_fail
argument_list|(
name|id
argument_list|,
name|EBUSY
argument_list|)
expr_stmt|;
comment|/* Cleanup. */
name|ksem_post
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|waitpid
argument_list|(
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ksem_destroy
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|busy_destroy_test
argument_list|,
literal|"destroy unnamed semaphore with waiter"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|exhaust_unnamed_child
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|semid_t
name|id
decl_stmt|;
name|int
name|i
decl_stmt|,
name|max
decl_stmt|;
name|max
operator|=
operator|(
name|intptr_t
operator|)
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ksem_init
argument_list|(
operator|&
name|id
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOSPC
condition|)
return|return
operator|(
name|CSTAT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
return|return
operator|(
name|CSTAT
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|CSTAT
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|exhaust_unnamed_sems
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|nsems_max
decl_stmt|,
name|stat
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|nsems_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"p1003_1b.sem_nsems_max"
argument_list|,
operator|&
name|nsems_max
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"sysctl(p1003_1b.sem_nsems_max)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|child_worker
argument_list|(
name|exhaust_unnamed_child
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nsems_max
argument_list|,
operator|&
name|stat
argument_list|)
condition|)
return|return;
name|errno
operator|=
name|CSTAT_ERROR
argument_list|(
name|stat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CSTAT_CLASS
argument_list|(
name|stat
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|pass
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fail_err
argument_list|(
literal|"Limit of %d semaphores not enforced"
argument_list|,
name|nsems_max
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fail_err
argument_list|(
literal|"bad child state %#x"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|exhaust_unnamed_sems
argument_list|,
literal|"exhaust unnamed semaphores (1)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|exhaust_named_child
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|64
index|]
decl_stmt|;
name|semid_t
name|id
decl_stmt|;
name|int
name|i
decl_stmt|,
name|max
decl_stmt|;
name|max
operator|=
operator|(
name|intptr_t
operator|)
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|TEST_PATH
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ksem_open
argument_list|(
operator|&
name|id
argument_list|,
name|buffer
argument_list|,
name|O_CREAT
argument_list|,
literal|0777
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOSPC
operator|||
name|errno
operator|==
name|EMFILE
operator|||
name|errno
operator|==
name|ENFILE
condition|)
return|return
operator|(
name|CSTAT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
return|return
operator|(
name|CSTAT
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|CSTAT
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|exhaust_named_sems
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|64
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nsems_max
decl_stmt|,
name|stat
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|nsems_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"p1003_1b.sem_nsems_max"
argument_list|,
operator|&
name|nsems_max
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fail_errno
argument_list|(
literal|"sysctl(p1003_1b.sem_nsems_max)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|child_worker
argument_list|(
name|exhaust_named_child
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nsems_max
argument_list|,
operator|&
name|stat
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|errno
operator|=
name|CSTAT_ERROR
argument_list|(
name|stat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CSTAT_CLASS
argument_list|(
name|stat
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|pass
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fail_errno
argument_list|(
literal|"ksem_open"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fail_err
argument_list|(
literal|"Limit of %d semaphores not enforced"
argument_list|,
name|nsems_max
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fail_err
argument_list|(
literal|"bad child state %#x"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Cleanup any semaphores created by the child. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsems_max
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|TEST_PATH
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ksem_unlink
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|exhaust_named_sems
argument_list|,
literal|"exhaust named semaphores (1)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|fdlimit_set
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
name|int
name|max
decl_stmt|;
name|max
operator|=
operator|(
name|intptr_t
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|rlim
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|CSTAT
argument_list|(
literal|3
argument_list|,
name|errno
argument_list|)
operator|)
return|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|max
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|rlim
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|CSTAT
argument_list|(
literal|4
argument_list|,
name|errno
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdlimit_unnamed_child
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|stat
decl_stmt|;
name|stat
operator|=
name|fdlimit_set
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
name|stat
operator|=
name|exhaust_unnamed_child
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fdlimit_unnamed_sems
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nsems_max
decl_stmt|,
name|stat
decl_stmt|;
name|nsems_max
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|child_worker
argument_list|(
name|fdlimit_unnamed_child
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nsems_max
argument_list|,
operator|&
name|stat
argument_list|)
condition|)
return|return;
name|errno
operator|=
name|CSTAT_ERROR
argument_list|(
name|stat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CSTAT_CLASS
argument_list|(
name|stat
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|pass
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fail_errno
argument_list|(
literal|"ksem_init"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fail_err
argument_list|(
literal|"Limit of %d semaphores not enforced"
argument_list|,
name|nsems_max
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fail_errno
argument_list|(
literal|"getrlimit"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|fail_errno
argument_list|(
literal|"getrlimit"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fail_err
argument_list|(
literal|"bad child state %#x"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|fdlimit_unnamed_sems
argument_list|,
literal|"exhaust unnamed semaphores (2)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|fdlimit_named_child
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|stat
decl_stmt|;
name|stat
operator|=
name|fdlimit_set
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
name|stat
operator|=
name|exhaust_named_child
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fdlimit_named_sems
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nsems_max
decl_stmt|,
name|stat
decl_stmt|;
name|nsems_max
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|child_worker
argument_list|(
name|fdlimit_named_child
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nsems_max
argument_list|,
operator|&
name|stat
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|errno
operator|=
name|CSTAT_ERROR
argument_list|(
name|stat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CSTAT_CLASS
argument_list|(
name|stat
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|pass
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fail_errno
argument_list|(
literal|"ksem_open"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fail_err
argument_list|(
literal|"Limit of %d semaphores not enforced"
argument_list|,
name|nsems_max
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fail_errno
argument_list|(
literal|"getrlimit"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|fail_errno
argument_list|(
literal|"getrlimit"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fail_err
argument_list|(
literal|"bad child state %#x"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Cleanup any semaphores created by the child. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsems_max
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|TEST_PATH
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ksem_unlink
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|TEST
argument_list|(
name|fdlimit_named_sems
argument_list|,
literal|"exhaust named semaphores (2)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|run_tests
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

