begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * TKIP test module.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_comment
comment|/* Key	12 34 56 78 90 12 34 56 78 90 12 34 56 78 90 12 	34 56 78 90 12 34 56 78 90 12 34 56 78 90 12 34 PN	0x000000000001 IV	00 20 01 20 00 00 00 00 Phase1	bb 58 07 1f 9e 93 b4 38 25 4b Phase2	00 20 01 4c fe 67 be d2 7c 86 7b 1b f8 02 8b 1c  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_int8_t
name|test1_key
index|[]
init|=
block|{
literal|0x12
block|,
literal|0x34
block|,
literal|0x56
block|,
literal|0x78
block|,
literal|0x90
block|,
literal|0x12
block|,
literal|0x34
block|,
literal|0x56
block|,
literal|0x78
block|,
literal|0x90
block|,
literal|0x12
block|,
literal|0x34
block|,
literal|0x56
block|,
literal|0x78
block|,
literal|0x90
block|,
literal|0x12
block|,
literal|0x34
block|,
literal|0x56
block|,
literal|0x78
block|,
literal|0x90
block|,
literal|0x12
block|,
literal|0x34
block|,
literal|0x56
block|,
literal|0x78
block|,
comment|/* TX MIC */
comment|/* 	 * NB: 11i test vector specifies a RX MIC key different 	 *     from the TX key.  But this doesn't work to enmic, 	 *     encrypt, then decrypt, demic.  So instead we use 	 *     the same key for doing the MIC in each direction. 	 * 	 * XXX need additional vectors to test alternate MIC keys 	 */
if|#
directive|if
literal|0
block|0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34,
comment|/* 11i RX MIC */
else|#
directive|else
literal|0x34
block|,
literal|0x56
block|,
literal|0x78
block|,
literal|0x90
block|,
literal|0x12
block|,
literal|0x34
block|,
literal|0x56
block|,
literal|0x78
block|,
comment|/* TX copy */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int8_t
name|test1_phase1
index|[]
init|=
block|{
literal|0xbb
block|,
literal|0x58
block|,
literal|0x07
block|,
literal|0x1f
block|,
literal|0x9e
block|,
literal|0x93
block|,
literal|0xb4
block|,
literal|0x38
block|,
literal|0x25
block|,
literal|0x4b
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int8_t
name|test1_phase2
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x20
block|,
literal|0x01
block|,
literal|0x4c
block|,
literal|0xfe
block|,
literal|0x67
block|,
literal|0xbe
block|,
literal|0xd2
block|,
literal|0x7c
block|,
literal|0x86
block|,
literal|0x7b
block|,
literal|0x1b
block|,
literal|0xf8
block|,
literal|0x02
block|,
literal|0x8b
block|,
literal|0x1c
block|,  }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Plaintext MPDU with MIC */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_int8_t
name|test1_plaintext
index|[]
init|=
block|{
literal|0x08
block|,
literal|0x42
block|,
literal|0x2c
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x08
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x07
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x07
block|,
literal|0xd0
block|,
literal|0x02
block|,
literal|0xaa
block|,
literal|0xaa
block|,
literal|0x03
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x45
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x54
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|0x40
block|,
literal|0x01
block|,
literal|0xa5
block|,
literal|0x55
block|,
literal|0xc0
block|,
literal|0xa8
block|,
literal|0x0a
block|,
literal|0x02
block|,
literal|0xc0
block|,
literal|0xa8
block|,
literal|0x0a
block|,
literal|0x01
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x3a
block|,
literal|0xb0
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xcd
block|,
literal|0x4c
block|,
literal|0x05
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x08
block|,
literal|0x09
block|,
literal|0x0a
block|,
literal|0x0b
block|,
literal|0x0c
block|,
literal|0x0d
block|,
literal|0x0e
block|,
literal|0x0f
block|,
literal|0x10
block|,
literal|0x11
block|,
literal|0x12
block|,
literal|0x13
block|,
literal|0x14
block|,
literal|0x15
block|,
literal|0x16
block|,
literal|0x17
block|,
literal|0x18
block|,
literal|0x19
block|,
literal|0x1a
block|,
literal|0x1b
block|,
literal|0x1c
block|,
literal|0x1d
block|,
literal|0x1e
block|,
literal|0x1f
block|,
literal|0x20
block|,
literal|0x21
block|,
literal|0x22
block|,
literal|0x23
block|,
literal|0x24
block|,
literal|0x25
block|,
literal|0x26
block|,
literal|0x27
block|,
literal|0x28
block|,
literal|0x29
block|,
literal|0x2a
block|,
literal|0x2b
block|,
literal|0x2c
block|,
literal|0x2d
block|,
literal|0x2e
block|,
literal|0x2f
block|,
literal|0x30
block|,
literal|0x31
block|,
literal|0x32
block|,
literal|0x33
block|,
literal|0x34
block|,
literal|0x35
block|,
literal|0x36
block|,
literal|0x37
block|,
comment|/* MIC */
literal|0x68
block|,
literal|0x81
block|,
literal|0xa3
block|,
literal|0xf3
block|,
literal|0xd6
block|,
literal|0x48
block|,
literal|0xd0
block|,
literal|0x3c
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Encrypted MPDU with MIC and ICV */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_int8_t
name|test1_encrypted
index|[]
init|=
block|{
literal|0x08
block|,
literal|0x42
block|,
literal|0x2c
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x08
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x07
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x07
block|,
literal|0xd0
block|,
literal|0x02
block|,
literal|0x00
block|,
literal|0x20
block|,
literal|0x01
block|,
literal|0x20
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xc0
block|,
literal|0x0e
block|,
literal|0x14
block|,
literal|0xfc
block|,
literal|0xe7
block|,
literal|0xcf
block|,
literal|0xab
block|,
literal|0xc7
block|,
literal|0x75
block|,
literal|0x47
block|,
literal|0xe6
block|,
literal|0x66
block|,
literal|0xe5
block|,
literal|0x7c
block|,
literal|0x0d
block|,
literal|0xac
block|,
literal|0x70
block|,
literal|0x4a
block|,
literal|0x1e
block|,
literal|0x35
block|,
literal|0x8a
block|,
literal|0x88
block|,
literal|0xc1
block|,
literal|0x1c
block|,
literal|0x8e
block|,
literal|0x2e
block|,
literal|0x28
block|,
literal|0x2e
block|,
literal|0x38
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x7a
block|,
literal|0x46
block|,
literal|0x56
block|,
literal|0x05
block|,
literal|0x5e
block|,
literal|0xe9
block|,
literal|0x3e
block|,
literal|0x9c
block|,
literal|0x25
block|,
literal|0x47
block|,
literal|0x02
block|,
literal|0xe9
block|,
literal|0x73
block|,
literal|0x58
block|,
literal|0x05
block|,
literal|0xdd
block|,
literal|0xb5
block|,
literal|0x76
block|,
literal|0x9b
block|,
literal|0xa7
block|,
literal|0x3f
block|,
literal|0x1e
block|,
literal|0xbb
block|,
literal|0x56
block|,
literal|0xe8
block|,
literal|0x44
block|,
literal|0xef
block|,
literal|0x91
block|,
literal|0x22
block|,
literal|0x85
block|,
literal|0xd3
block|,
literal|0xdd
block|,
literal|0x6e
block|,
literal|0x54
block|,
literal|0x1e
block|,
literal|0x82
block|,
literal|0x38
block|,
literal|0x73
block|,
literal|0x55
block|,
literal|0x8a
block|,
literal|0xdb
block|,
literal|0xa0
block|,
literal|0x79
block|,
literal|0x06
block|,
literal|0x8a
block|,
literal|0xbd
block|,
literal|0x7f
block|,
literal|0x7f
block|,
literal|0x50
block|,
literal|0x95
block|,
literal|0x96
block|,
literal|0x75
block|,
literal|0xac
block|,
literal|0xc4
block|,
literal|0xb4
block|,
literal|0xde
block|,
literal|0x9a
block|,
literal|0xa9
block|,
literal|0x9c
block|,
literal|0x05
block|,
literal|0xf2
block|,
literal|0x89
block|,
literal|0xa7
block|,
literal|0xc5
block|,
literal|0x2f
block|,
literal|0xee
block|,
literal|0x5b
block|,
literal|0xfc
block|,
literal|0x14
block|,
literal|0xf6
block|,
literal|0xf8
block|,
literal|0xe5
block|,
literal|0xf8
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TEST
parameter_list|(
name|n
parameter_list|,
name|name
parameter_list|,
name|cipher
parameter_list|,
name|keyix
parameter_list|,
name|pn
parameter_list|)
value|{ \ 	name, IEEE80211_CIPHER_##cipher,keyix, pn##LL, \ 	test##n##_key,   sizeof(test##n##_key), \ 	test##n##_phase1,   sizeof(test##n##_phase1), \ 	test##n##_phase2,   sizeof(test##n##_phase2), \ 	test##n##_plaintext, sizeof(test##n##_plaintext), \ 	test##n##_encrypted, sizeof(test##n##_encrypted) \ }
end_define

begin_struct
struct|struct
name|ciphertest
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|cipher
decl_stmt|;
name|int
name|keyix
decl_stmt|;
name|u_int64_t
name|pn
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|key
decl_stmt|;
name|size_t
name|key_len
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|phase1
decl_stmt|;
name|size_t
name|phase1_len
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|phase2
decl_stmt|;
name|size_t
name|phase2_len
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|plaintext
decl_stmt|;
name|size_t
name|plaintext_len
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|encrypted
decl_stmt|;
name|size_t
name|encrypted_len
decl_stmt|;
block|}
name|tkiptests
index|[]
init|=
block|{
name|TEST
argument_list|(
literal|1
argument_list|,
literal|"TKIP test mpdu 1"
argument_list|,
name|TKIP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|, }
struct|;
end_struct

begin_struct
struct|struct
name|tkip_ctx
block|{
name|struct
name|ieee80211com
modifier|*
name|tc_ic
decl_stmt|;
comment|/* for diagnostics */
name|uint16_t
name|tx_ttak
index|[
literal|5
index|]
decl_stmt|;
name|uint8_t
name|tx_rc4key
index|[
literal|16
index|]
decl_stmt|;
name|uint16_t
name|rx_ttak
index|[
literal|5
index|]
decl_stmt|;
name|int
name|rx_phase1_done
decl_stmt|;
name|uint8_t
name|rx_rc4key
index|[
literal|16
index|]
decl_stmt|;
name|uint64_t
name|rx_rsc
decl_stmt|;
comment|/* held until MIC verified */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|dumpdata
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
specifier|const
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"%s: 0x%p len %u"
argument_list|,
name|tag
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n%03d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|(
operator|(
specifier|const
name|u_int8_t
operator|*
operator|)
name|p
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cmpfail
parameter_list|(
specifier|const
name|void
modifier|*
name|gen
parameter_list|,
name|size_t
name|genlen
parameter_list|,
specifier|const
name|void
modifier|*
name|ref
parameter_list|,
name|size_t
name|reflen
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|genlen
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
specifier|const
name|u_int8_t
operator|*
operator|)
name|gen
operator|)
index|[
name|i
index|]
operator|!=
operator|(
operator|(
specifier|const
name|u_int8_t
operator|*
operator|)
name|ref
operator|)
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"first difference at byte %u\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|dumpdata
argument_list|(
literal|"Generated"
argument_list|,
name|gen
argument_list|,
name|genlen
argument_list|)
expr_stmt|;
name|dumpdata
argument_list|(
literal|"Reference"
argument_list|,
name|ref
argument_list|,
name|reflen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|runtest
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ciphertest
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|tkip_ctx
modifier|*
name|ctx
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|key
init|=
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
name|t
operator|->
name|keyix
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Setup key. 	 */
name|memset
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|->
name|wk_flags
operator|=
name|IEEE80211_KEY_XMIT
operator||
name|IEEE80211_KEY_RECV
expr_stmt|;
name|key
operator|->
name|wk_cipher
operator|=
operator|&
name|ieee80211_cipher_none
expr_stmt|;
if|if
condition|(
operator|!
name|ieee80211_crypto_newkey
argument_list|(
name|vap
argument_list|,
name|t
operator|->
name|cipher
argument_list|,
name|IEEE80211_KEY_XMIT
operator||
name|IEEE80211_KEY_RECV
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: ieee80211_crypto_newkey failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|memcpy
argument_list|(
name|key
operator|->
name|wk_key
argument_list|,
name|t
operator|->
name|key
argument_list|,
name|t
operator|->
name|key_len
argument_list|)
expr_stmt|;
name|key
operator|->
name|wk_keylen
operator|=
literal|128
operator|/
name|NBBY
expr_stmt|;
name|memset
argument_list|(
name|key
operator|->
name|wk_keyrsc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
operator|->
name|wk_keyrsc
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|->
name|wk_keytsc
operator|=
name|t
operator|->
name|pn
expr_stmt|;
if|if
condition|(
operator|!
name|ieee80211_crypto_setkey
argument_list|(
name|vap
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: ieee80211_crypto_setkey failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Craft frame from plaintext data. 	 */
name|cip
operator|=
name|key
operator|->
name|wk_cipher
expr_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_HEADER
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|cip
operator|->
name|ic_header
expr_stmt|;
name|len
operator|=
name|t
operator|->
name|plaintext_len
operator|-
name|IEEE80211_WEP_MICLEN
expr_stmt|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|t
operator|->
name|plaintext
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Add MIC. 	 */
if|if
condition|(
operator|!
name|ieee80211_crypto_enmic
argument_list|(
name|vap
argument_list|,
name|key
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: tkip enmic failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Verify: frame length, frame contents. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|!=
name|t
operator|->
name|plaintext_len
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: enmic botch; length mismatch\n"
argument_list|)
expr_stmt|;
name|cmpfail
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|t
operator|->
name|plaintext
argument_list|,
name|t
operator|->
name|plaintext_len
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
argument_list|,
name|t
operator|->
name|plaintext
argument_list|,
name|t
operator|->
name|plaintext_len
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: enmic botch\n"
argument_list|)
expr_stmt|;
name|cmpfail
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|t
operator|->
name|plaintext
argument_list|,
name|t
operator|->
name|plaintext_len
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Encrypt frame w/ MIC. 	 */
if|if
condition|(
operator|!
name|cip
operator|->
name|ic_encap
argument_list|(
name|key
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: tkip encap failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Verify: phase1, phase2, frame length, frame contents. 	 */
name|ctx
operator|=
name|key
operator|->
name|wk_private
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|ctx
operator|->
name|tx_ttak
argument_list|,
name|t
operator|->
name|phase1
argument_list|,
name|t
operator|->
name|phase1_len
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: encrypt phase1 botch\n"
argument_list|)
expr_stmt|;
name|cmpfail
argument_list|(
name|ctx
operator|->
name|tx_ttak
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|tx_ttak
argument_list|)
argument_list|,
name|t
operator|->
name|phase1
argument_list|,
name|t
operator|->
name|phase1_len
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|ctx
operator|->
name|tx_rc4key
argument_list|,
name|t
operator|->
name|phase2
argument_list|,
name|t
operator|->
name|phase2_len
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: encrypt phase2 botch\n"
argument_list|)
expr_stmt|;
name|cmpfail
argument_list|(
name|ctx
operator|->
name|tx_rc4key
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|tx_rc4key
argument_list|)
argument_list|,
name|t
operator|->
name|phase2
argument_list|,
name|t
operator|->
name|phase2_len
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|!=
name|t
operator|->
name|encrypted_len
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: encrypt data length mismatch\n"
argument_list|)
expr_stmt|;
name|cmpfail
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|t
operator|->
name|encrypted
argument_list|,
name|t
operator|->
name|encrypted_len
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
argument_list|,
name|t
operator|->
name|encrypted
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: encrypt data does not compare\n"
argument_list|)
expr_stmt|;
name|cmpfail
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|t
operator|->
name|encrypted
argument_list|,
name|t
operator|->
name|encrypted_len
argument_list|)
expr_stmt|;
name|dumpdata
argument_list|(
literal|"Plaintext"
argument_list|,
name|t
operator|->
name|plaintext
argument_list|,
name|t
operator|->
name|plaintext_len
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Decrypt frame. 	 */
if|if
condition|(
operator|!
name|cip
operator|->
name|ic_decap
argument_list|(
name|key
argument_list|,
name|m
argument_list|,
name|hdrlen
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"tkip decap failed\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Check reason for failure: phase1, phase2, frame data (ICV). 		 */
if|if
condition|(
name|memcmp
argument_list|(
name|ctx
operator|->
name|rx_ttak
argument_list|,
name|t
operator|->
name|phase1
argument_list|,
name|t
operator|->
name|phase1_len
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: decrypt phase1 botch\n"
argument_list|)
expr_stmt|;
name|cmpfail
argument_list|(
name|ctx
operator|->
name|rx_ttak
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|rx_ttak
argument_list|)
argument_list|,
name|t
operator|->
name|phase1
argument_list|,
name|t
operator|->
name|phase1_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|ctx
operator|->
name|rx_rc4key
argument_list|,
name|t
operator|->
name|phase2
argument_list|,
name|t
operator|->
name|phase2_len
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: decrypt phase2 botch\n"
argument_list|)
expr_stmt|;
name|cmpfail
argument_list|(
name|ctx
operator|->
name|rx_rc4key
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|rx_rc4key
argument_list|)
argument_list|,
name|t
operator|->
name|phase2
argument_list|,
name|t
operator|->
name|phase2_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"FAIL: decrypt data does not compare\n"
argument_list|)
expr_stmt|;
name|cmpfail
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|t
operator|->
name|plaintext
argument_list|,
name|t
operator|->
name|plaintext_len
argument_list|)
expr_stmt|;
block|}
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Verify: frame length, frame contents. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|!=
name|t
operator|->
name|plaintext_len
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: decap botch; length mismatch\n"
argument_list|)
expr_stmt|;
name|cmpfail
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|t
operator|->
name|plaintext
argument_list|,
name|t
operator|->
name|plaintext_len
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
argument_list|,
name|t
operator|->
name|plaintext
argument_list|,
name|t
operator|->
name|plaintext_len
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: decap botch; data does not compare\n"
argument_list|)
expr_stmt|;
name|cmpfail
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|t
operator|->
name|plaintext
argument_list|,
name|t
operator|->
name|plaintext_len
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * De-MIC decrypted frame. 	 */
if|if
condition|(
operator|!
name|ieee80211_crypto_demic
argument_list|(
name|vap
argument_list|,
name|key
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL: tkip demic failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* XXX check frame length and contents... */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ieee80211_crypto_delkey
argument_list|(
name|vap
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PASS\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|bad
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ieee80211_crypto_delkey
argument_list|(
name|vap
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Module glue.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tests
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|init_crypto_tkip_test
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ieee80211com
name|ic
decl_stmt|;
name|struct
name|ieee80211vap
name|vap
decl_stmt|;
name|struct
name|ifnet
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pass
decl_stmt|,
name|total
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ic
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ic
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|vap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vap
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ifp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|ieee80211_crypto_attach
argument_list|(
operator|&
name|ic
argument_list|)
expr_stmt|;
comment|/* some minimal initialization */
name|strncpy
argument_list|(
name|ifp
operator|.
name|if_xname
argument_list|,
literal|"test_ccmp"
argument_list|,
sizeof|sizeof
argument_list|(
name|ifp
operator|.
name|if_xname
argument_list|)
argument_list|)
expr_stmt|;
name|vap
operator|.
name|iv_ic
operator|=
operator|&
name|ic
expr_stmt|;
name|vap
operator|.
name|iv_ifp
operator|=
operator|&
name|ifp
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|vap
operator|.
name|iv_debug
operator|=
name|IEEE80211_MSG_CRYPTO
expr_stmt|;
name|ieee80211_crypto_vattach
argument_list|(
operator|&
name|vap
argument_list|)
expr_stmt|;
name|pass
operator|=
literal|0
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|tkiptests
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tests
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|total
operator|++
expr_stmt|;
name|pass
operator|+=
name|runtest
argument_list|(
operator|&
name|vap
argument_list|,
operator|&
name|tkiptests
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%u of %u 802.11i TKIP test vectors passed\n"
argument_list|,
name|pass
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|ieee80211_crypto_vdetach
argument_list|(
operator|&
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_crypto_detach
argument_list|(
operator|&
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
name|pass
operator|==
name|total
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|test_tkip_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
operator|(
name|void
operator|)
name|init_crypto_tkip_test
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
case|case
name|MOD_UNLOAD
case|:
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|test_tkip_mod
init|=
block|{
literal|"test_tkip"
block|,
name|test_tkip_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|test_tkip
argument_list|,
name|test_tkip_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|test_tkip
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|test_tkip
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

