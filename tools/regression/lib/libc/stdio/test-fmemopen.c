begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*- Copyright (C) 2013 Pietro Cerutti<gahr@FreeBSD.org>  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.  THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
end_comment

begin_comment
comment|/*  * Test basic FILE * functions (fread, fwrite, fseek, fclose) against  * a FILE * retrieved using fmemopen()  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_function
name|void
name|test_preexisting
parameter_list|()
block|{
comment|/*  	 * Use a pre-existing buffer. 	 */
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|char
name|buf2
index|[
literal|512
index|]
decl_stmt|;
name|char
name|str
index|[]
init|=
literal|"Test writing some stuff"
decl_stmt|;
name|char
name|str2
index|[]
init|=
literal|"AAAAAAAAA"
decl_stmt|;
name|char
name|str3
index|[]
init|=
literal|"AAAA writing some stuff"
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|size_t
name|nofw
decl_stmt|,
name|nofr
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Open a FILE * using fmemopen. */
name|fp
operator|=
name|fmemopen
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Write to the buffer. */
name|nofw
operator|=
name|fwrite
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nofw
operator|==
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Close the FILE *. */
name|rc
operator|=
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rc
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Re-open the FILE * to read back the data. */
name|fp
operator|=
name|fmemopen
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Read from the buffer. */
name|bzero
argument_list|(
name|buf2
argument_list|,
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
name|nofr
operator|=
name|fread
argument_list|(
name|buf2
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nofr
operator|==
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  	 * Since a write on a FILE * retrieved by fmemopen 	 * will add a '\0' (if there's space), we can check 	 * the strings for equality. 	 */
name|assert
argument_list|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|buf2
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Close the FILE *. */
name|rc
operator|=
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rc
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Now open a FILE * on the first 4 bytes of the string. */
name|fp
operator|=
name|fmemopen
argument_list|(
name|str
argument_list|,
literal|4
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Try to write more bytes than we shoud, we'll get a short count (4). 	 */
name|nofw
operator|=
name|fwrite
argument_list|(
name|str2
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|str2
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nofw
operator|==
literal|4
argument_list|)
expr_stmt|;
comment|/* Close the FILE *. */
name|rc
operator|=
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Check that the string was not modified after the first 4 bytes. */
name|assert
argument_list|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|str3
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|test_autoalloc
parameter_list|()
block|{
comment|/*  	 * Let fmemopen allocate the buffer. 	 */
name|char
name|str
index|[]
init|=
literal|"A quick test"
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|size_t
name|nofw
decl_stmt|,
name|nofr
decl_stmt|,
name|i
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Open a FILE * using fmemopen. */
name|fp
operator|=
name|fmemopen
argument_list|(
name|NULL
argument_list|,
literal|512
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* fill the buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|512
condition|;
name|i
operator|++
control|)
block|{
name|nofw
operator|=
name|fwrite
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nofw
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Get the current position into the stream. */
name|pos
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pos
operator|==
literal|512
argument_list|)
expr_stmt|;
comment|/*  	 * Try to write past the end, we should get a short object count (0) 	 */
name|nofw
operator|=
name|fwrite
argument_list|(
literal|"a"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nofw
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Close the FILE *. */
name|rc
operator|=
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rc
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Open a FILE * using a wrong mode */
name|fp
operator|=
name|fmemopen
argument_list|(
name|NULL
argument_list|,
literal|512
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
name|NULL
argument_list|,
literal|512
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fp
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|test_data_length
parameter_list|()
block|{
comment|/* 	 * Here we test that a read operation doesn't go past the end of the 	 * data actually written, and that a SEEK_END seeks from the end of the 	 * data, not of the whole buffer. 	 */
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
name|char
name|str
index|[]
init|=
literal|"Test data length. "
decl_stmt|;
name|char
name|str2
index|[]
init|=
literal|"Do we have two sentences?"
decl_stmt|;
name|char
name|str3
index|[
sizeof|sizeof
argument_list|(
name|str
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|str2
argument_list|)
operator|-
literal|1
index|]
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|size_t
name|nofw
decl_stmt|,
name|nofr
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Open a FILE * for updating our buffer. */
name|fp
operator|=
name|fmemopen
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Write our string into the buffer. */
name|nofw
operator|=
name|fwrite
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nofw
operator|==
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  	 * Now seek to the end and check that ftell 	 * gives us sizeof(str). 	 */
name|rc
operator|=
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rc
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pos
operator|==
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Close the FILE *. */
name|rc
operator|=
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rc
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Reopen the buffer for appending. */
name|fp
operator|=
name|fmemopen
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"a+"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We should now be writing after the first string. */
name|nofw
operator|=
name|fwrite
argument_list|(
name|str2
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|str2
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nofw
operator|==
sizeof|sizeof
argument_list|(
name|str2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Rewind the FILE *. */
name|rc
operator|=
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rc
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure we're at the beginning. */
name|pos
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pos
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Read the whole buffer. */
name|nofr
operator|=
name|fread
argument_list|(
name|str3
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nofr
operator|==
sizeof|sizeof
argument_list|(
name|str3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure the two strings are there. */
name|assert
argument_list|(
name|strncmp
argument_list|(
name|str3
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strncmp
argument_list|(
name|str3
operator|+
sizeof|sizeof
argument_list|(
name|str
argument_list|)
operator|-
literal|1
argument_list|,
name|str2
argument_list|,
sizeof|sizeof
argument_list|(
name|str2
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Close the FILE *. */
name|rc
operator|=
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rc
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|test_binary
parameter_list|()
block|{
comment|/* 	 * Make sure that NULL bytes are never appended when opening a buffer 	 * in binary mode. 	 */
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|char
name|str
index|[]
init|=
literal|"Test"
decl_stmt|;
name|size_t
name|nofw
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
comment|/* Pre-fill the buffer. */
name|memset
argument_list|(
name|buf
argument_list|,
literal|'A'
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open a FILE * in binary mode. */
name|fp
operator|=
name|fmemopen
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"w+b"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Write some data into it. */
name|nofw
operator|=
name|fwrite
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nofw
operator|==
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure that the buffer doesn't contain any NULL bytes. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|;
name|i
operator|++
control|)
name|assert
argument_list|(
name|buf
index|[
name|i
index|]
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* Close the FILE *. */
name|rc
operator|=
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rc
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|test_append_binary_pos
parameter_list|()
block|{
comment|/* 	 * For compatibility with other implementations (glibc), we set the 	 * position to 0 when opening an automatically allocated binary stream 	 * for appending. 	 */
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
name|NULL
argument_list|,
literal|16
argument_list|,
literal|"ab+"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ftell
argument_list|(
name|fp
argument_list|)
operator|==
literal|0L
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that a pre-allocated buffer behaves correctly. 	 */
name|char
name|buf
index|[]
init|=
literal|"Hello"
decl_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"ab+"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ftell
argument_list|(
name|fp
argument_list|)
operator|==
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|test_size_0
parameter_list|()
block|{
comment|/* 	 * POSIX mandates that we return EINVAL if size is 0. 	 */
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|fmemopen
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|errno
operator|==
name|EINVAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|test_autoalloc
argument_list|()
expr_stmt|;
name|test_preexisting
argument_list|()
expr_stmt|;
name|test_data_length
argument_list|()
expr_stmt|;
name|test_binary
argument_list|()
expr_stmt|;
name|test_append_binary_pos
argument_list|()
expr_stmt|;
name|test_size_0
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

