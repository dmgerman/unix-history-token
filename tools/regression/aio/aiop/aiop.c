begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * SPDX-License-Identifier: BSD-3-Clause  *  * Copyright (c) 2002 Adrian Chadd<adrian@FreeBSD.org>.  * All rights reserved.  *  * This software was developed for the FreeBSD Project by Marshall  * Kirk McKusick and Network Associates Laboratories, the Security  * Research Division of Network Associates, Inc. under DARPA/SPAWAR  * contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA CHATS  * research program.  *  * Copyright (c) 1980, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<aio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*  * This is a bit of a quick hack to do parallel IO testing through POSIX AIO.  * Its specifically designed to work under FreeBSD and its derivatives;  * note how I cheat by using aio_waitcomplete().  *  * TODO:  *  * + Add write support; so we can make sure we're not hitting throughput issues  *   with read/modify/write of entire tracks of the disk  * + Add in per-op stats - time and offset - so one could start mapping out  *   the speed hotspots of the disk  * + Add in different distributions - random, normal, left/right skewed normal,  *   zipf, etc - and perhaps add the ability to run concurrent distributions  *   (so a normal and a zipf; and also a random read; zipf write, etc.)  *  * Adrian Chadd<adrian@creative.net.au>  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|IOT_NONE
init|=
literal|0x00
block|,
name|IOT_READ
init|=
literal|0x01
block|,
name|IOT_WRITE
init|=
literal|0x02
block|}
name|iot_t
typedef|;
end_typedef

begin_function
specifier|static
name|size_t
name|disk_getsize
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|off_t
name|mediasize
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|DIOCGMEDIASIZE
argument_list|,
operator|&
name|mediasize
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl(DIOCGMEDIASIZE)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|mediasize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|iot_t
name|choose_aio
parameter_list|(
name|iot_t
name|iomask
parameter_list|)
block|{
comment|/* choose a random read or write event, limited by the mask */
if|if
condition|(
name|iomask
operator|==
name|IOT_READ
condition|)
return|return
name|IOT_READ
return|;
elseif|else
if|if
condition|(
name|iomask
operator|==
name|IOT_WRITE
condition|)
return|return
name|IOT_WRITE
return|;
return|return
operator|(
name|random
argument_list|()
operator|&
literal|0x01
condition|?
name|IOT_READ
else|:
name|IOT_WRITE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_aio
parameter_list|(
name|struct
name|aiocb
modifier|*
name|a
parameter_list|,
name|iot_t
name|iot
parameter_list|,
name|int
name|fd
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|bzero
argument_list|(
name|a
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|aio_fildes
operator|=
name|fd
expr_stmt|;
name|a
operator|->
name|aio_nbytes
operator|=
name|size
expr_stmt|;
name|a
operator|->
name|aio_offset
operator|=
name|offset
expr_stmt|;
name|a
operator|->
name|aio_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|iot
operator|==
name|IOT_READ
condition|)
name|r
operator|=
name|aio_read
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|aio_write
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"set_aio call failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|aiocb
modifier|*
name|aio
decl_stmt|;
name|char
modifier|*
modifier|*
name|abuf
decl_stmt|;
specifier|const
name|char
modifier|*
name|fn
decl_stmt|;
name|int
name|aio_len
decl_stmt|;
name|int
name|io_size
decl_stmt|,
name|nrun
decl_stmt|;
name|off_t
name|file_size
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|aiocb
modifier|*
name|a
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|timeval
name|st
decl_stmt|,
name|et
decl_stmt|,
name|rt
decl_stmt|;
name|float
name|f_rt
decl_stmt|;
name|iot_t
name|iowhat
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|6
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: %s<file><io size><number of runs><concurrency><ro|wo|rw>\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fn
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|io_size
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_size
operator|<=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"the I/O size must be>0"
argument_list|)
expr_stmt|;
name|nrun
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrun
operator|<=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"the number of runs must be>0"
argument_list|)
expr_stmt|;
name|aio_len
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio_len
operator|<=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"AIO concurrency must be>0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|,
literal|"ro"
argument_list|)
operator|==
literal|0
condition|)
name|iowhat
operator|=
name|IOT_READ
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|,
literal|"rw"
argument_list|)
operator|==
literal|0
condition|)
name|iowhat
operator|=
name|IOT_READ
operator||
name|IOT_WRITE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|,
literal|"wo"
argument_list|)
operator|==
literal|0
condition|)
name|iowhat
operator|=
name|IOT_WRITE
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"the I/O type needs to be \"ro\", \"rw\", or \"wo\"!\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Random returns values between 0 and (2^32)-1; only good for 4 gig. 	 * Lets instead treat random() as returning a block offset w/ block size 	 * being "io_size", so we can handle> 4 gig files. 	 */
if|if
condition|(
name|iowhat
operator|==
name|IOT_READ
condition|)
name|fd
operator|=
name|open
argument_list|(
name|fn
argument_list|,
name|O_RDONLY
operator||
name|O_DIRECT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|iowhat
operator|==
name|IOT_WRITE
condition|)
name|fd
operator|=
name|open
argument_list|(
name|fn
argument_list|,
name|O_WRONLY
operator||
name|O_DIRECT
argument_list|)
expr_stmt|;
else|else
name|fd
operator|=
name|open
argument_list|(
name|fn
argument_list|,
name|O_RDWR
operator||
name|O_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"open failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fstat failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|file_size
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISBLK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISCHR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|file_size
operator|=
name|disk_getsize
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown file type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_size
operator|<=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"path provided too small"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"File: %s; File size %jd bytes\n"
argument_list|,
name|fn
argument_list|,
operator|(
name|intmax_t
operator|)
name|file_size
argument_list|)
expr_stmt|;
name|aio
operator|=
name|calloc
argument_list|(
name|aio_len
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aiocb
argument_list|)
argument_list|)
expr_stmt|;
name|abuf
operator|=
name|calloc
argument_list|(
name|aio_len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aio_len
condition|;
name|i
operator|++
control|)
name|abuf
index|[
name|i
index|]
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|io_size
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill with the initial contents */
name|gettimeofday
argument_list|(
operator|&
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aio_len
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|=
name|random
argument_list|()
operator|%
operator|(
name|file_size
operator|/
name|io_size
operator|)
expr_stmt|;
name|offset
operator|*=
name|io_size
expr_stmt|;
name|set_aio
argument_list|(
name|aio
operator|+
name|i
argument_list|,
name|choose_aio
argument_list|(
name|iowhat
argument_list|)
argument_list|,
name|fd
argument_list|,
name|offset
argument_list|,
name|io_size
argument_list|,
name|abuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrun
condition|;
name|i
operator|++
control|)
block|{
name|aio_waitcomplete
argument_list|(
operator|&
name|a
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|=
name|a
operator|-
name|aio
expr_stmt|;
name|assert
argument_list|(
name|n
operator|<
name|aio_len
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|random
argument_list|()
operator|%
operator|(
name|file_size
operator|/
name|io_size
operator|)
expr_stmt|;
name|offset
operator|*=
name|io_size
expr_stmt|;
name|set_aio
argument_list|(
name|aio
operator|+
name|n
argument_list|,
name|choose_aio
argument_list|(
name|iowhat
argument_list|)
argument_list|,
name|fd
argument_list|,
name|offset
argument_list|,
name|io_size
argument_list|,
name|abuf
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
name|gettimeofday
argument_list|(
operator|&
name|et
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|et
argument_list|,
operator|&
name|st
argument_list|,
operator|&
name|rt
argument_list|)
expr_stmt|;
name|f_rt
operator|=
operator|(
call|(
name|float
call|)
argument_list|(
name|rt
operator|.
name|tv_usec
argument_list|)
operator|)
operator|/
literal|1000000.0
expr_stmt|;
name|f_rt
operator|+=
call|(
name|float
call|)
argument_list|(
name|rt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Runtime: %.2f seconds, "
argument_list|,
name|f_rt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Op rate: %.2f ops/sec, "
argument_list|,
operator|(
call|(
name|float
call|)
argument_list|(
name|nrun
argument_list|)
operator|)
operator|/
name|f_rt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Avg transfer rate: %.2f bytes/sec\n"
argument_list|,
operator|(
call|(
name|float
call|)
argument_list|(
name|nrun
argument_list|)
operator|)
operator|*
operator|(
operator|(
name|float
operator|)
name|io_size
operator|)
operator|/
name|f_rt
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

