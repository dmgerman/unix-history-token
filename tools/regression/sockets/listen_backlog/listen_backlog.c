begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*  * This regression test is intended to validate that the backlog parameter  * set by listen() is properly set, can be retrieved using SO_LISTENQLIMIT,  * and that it can be updated by later calls to listen().  We also check that  * SO_LISTENQLIMIT cannot be set.  *  * Future things to test:  *  * - That if we change the value of kern.ipc.somaxconn, the limits really  *   do change.  *  * - That limits are, approximately, enforced and implemented.  *  * - All this on multiple socket types -- i.e., PF_LOCAL.  *  * - That we also test SO_LISTENQLEN and SO_LISTENINCQLEN.  */
end_comment

begin_comment
comment|/*  * We retrieve kern.ipc.somaxconn before running the tests in order to use a  * run-time set value of SOMAXCONN, rather than compile-time set.  We assume  * that no other process will be simultaneously frobbing it, and these tests  * may fail if that assumption is not held.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|somaxconn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Retrieve the current socket listen queue limit using SO_LISTENQLIMIT.  */
end_comment

begin_function
specifier|static
name|int
name|socket_get_backlog
parameter_list|(
name|int
name|sock
parameter_list|,
name|int
modifier|*
name|backlogp
parameter_list|,
specifier|const
name|char
modifier|*
name|testclass
parameter_list|,
specifier|const
name|char
modifier|*
name|test
parameter_list|,
specifier|const
name|char
modifier|*
name|testfunc
parameter_list|)
block|{
name|socklen_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_LISTENQLIMIT
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: %s: %s: socket_get_backlog: getsockopt("
literal|"SOL_SOCKET, SO_LISTENQLIMIT)"
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
name|testfunc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s: %s: socket_get_backlog: getsockopt("
literal|"SOL_SOCKET, SO_LISTENQLIMIT): returned size %d"
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
name|testfunc
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|backlogp
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a socket, check the queue limit on creation, perform a listen(),  * and make sure that the limit was set as expected by listen().  */
end_comment

begin_function
specifier|static
name|int
name|socket_listen
parameter_list|(
name|int
name|domain
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|protocol
parameter_list|,
name|int
name|backlog
parameter_list|,
name|int
name|create_backlog_assertion
parameter_list|,
name|int
name|listen_backlog_assertion
parameter_list|,
name|int
modifier|*
name|sockp
parameter_list|,
specifier|const
name|char
modifier|*
name|domainstring
parameter_list|,
specifier|const
name|char
modifier|*
name|typestring
parameter_list|,
specifier|const
name|char
modifier|*
name|testclass
parameter_list|,
specifier|const
name|char
modifier|*
name|test
parameter_list|)
block|{
name|int
name|backlog_retrieved
decl_stmt|,
name|sock
decl_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: %s: socket_listen: socket(%s, %s)"
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
name|domainstring
argument_list|,
name|typestring
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|socket_get_backlog
argument_list|(
name|sock
argument_list|,
operator|&
name|backlog_retrieved
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
literal|"socket_listen"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|backlog_retrieved
operator|!=
name|create_backlog_assertion
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s: socket_listen: create backlog is %d not %d"
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
name|backlog_retrieved
argument_list|,
name|create_backlog_assertion
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
name|backlog
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: %s: socket_listen: listen(, %d)"
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|socket_get_backlog
argument_list|(
name|sock
argument_list|,
operator|&
name|backlog_retrieved
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
literal|"socket_listen"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|backlog_retrieved
operator|!=
name|listen_backlog_assertion
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s: socket_listen: listen backlog is %d not %d"
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
name|backlog_retrieved
argument_list|,
name|listen_backlog_assertion
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|sockp
operator|=
name|sock
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This test creates sockets and tests default states before and after  * listen().  Specifically, we expect a queue limit of 0 before listen, and  * then various settings for after listen().  If the passed backlog was  * either< 0 or> somaxconn, it should be set to somaxconn; otherwise, the  * passed queue depth.  */
end_comment

begin_function
specifier|static
name|void
name|test_defaults
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|sock
decl_stmt|;
comment|/* 	 * First pass.  Confirm the default is 0.  Listen with a backlog of 	 * 0 and confirm it gets set that way. 	 */
if|if
condition|(
name|socket_listen
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|sock
argument_list|,
literal|"PF_INET"
argument_list|,
literal|"SOCK_STREAM"
argument_list|,
literal|"test_defaults"
argument_list|,
literal|"default_0_listen_0"
argument_list|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * Second pass.  Listen with a backlog of -1 and make sure it is set 	 * to somaxconn. 	 */
if|if
condition|(
name|socket_listen
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|somaxconn
argument_list|,
operator|&
name|sock
argument_list|,
literal|"PF_INET"
argument_list|,
literal|"SOCK_STREAM"
argument_list|,
literal|"test_defaults"
argument_list|,
literal|"default_0_listen_-1"
argument_list|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * Third pass.  Listen with a backlog of 1 and make sure it is set to 	 * 1. 	 */
if|if
condition|(
name|socket_listen
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|sock
argument_list|,
literal|"PF_INET"
argument_list|,
literal|"SOCK_STREAM"
argument_list|,
literal|"test_defaults"
argument_list|,
literal|"default_0_listen_1"
argument_list|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * Fourth pass.  Listen with a backlog of somaxconn and make sure it 	 * is set to somaxconn. 	 */
if|if
condition|(
name|socket_listen
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|somaxconn
argument_list|,
literal|0
argument_list|,
name|somaxconn
argument_list|,
operator|&
name|sock
argument_list|,
literal|"PF_INET"
argument_list|,
literal|"SOCK_STREAM"
argument_list|,
literal|"test_defaults"
argument_list|,
literal|"default_0_listen_somaxconn"
argument_list|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * Fifth pass.  Listen with a backlog of somaxconn+1 and make sure it 	 * is set to somaxconn. 	 */
if|if
condition|(
name|socket_listen
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|somaxconn
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|somaxconn
argument_list|,
operator|&
name|sock
argument_list|,
literal|"PF_INET"
argument_list|,
literal|"SOCK_STREAM"
argument_list|,
literal|"test_defaults"
argument_list|,
literal|"default_0_listen_somaxconn+1"
argument_list|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a socket, set the initial listen() state, then update the queue  * depth using listen().  Check that the backlog is as expected after both  * the first and second listen().  */
end_comment

begin_function
specifier|static
name|int
name|socket_listen_update
parameter_list|(
name|int
name|domain
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|protocol
parameter_list|,
name|int
name|backlog
parameter_list|,
name|int
name|update_backlog
parameter_list|,
name|int
name|listen_backlog_assertion
parameter_list|,
name|int
name|update_backlog_assertion
parameter_list|,
name|int
modifier|*
name|sockp
parameter_list|,
specifier|const
name|char
modifier|*
name|domainstring
parameter_list|,
specifier|const
name|char
modifier|*
name|typestring
parameter_list|,
specifier|const
name|char
modifier|*
name|testclass
parameter_list|,
specifier|const
name|char
modifier|*
name|test
parameter_list|)
block|{
name|int
name|backlog_retrieved
decl_stmt|,
name|sock
decl_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: %s: socket_listen_update: socket(%s, %s)"
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
name|domainstring
argument_list|,
name|typestring
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
name|backlog
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: %s: socket_listen_update: initial listen(, %d)"
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|socket_get_backlog
argument_list|(
name|sock
argument_list|,
operator|&
name|backlog_retrieved
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
literal|"socket_listen_update"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|backlog_retrieved
operator|!=
name|listen_backlog_assertion
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s: socket_listen_update: initial backlog is %d "
literal|"not %d"
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
name|backlog_retrieved
argument_list|,
name|listen_backlog_assertion
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
name|update_backlog
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: %s: socket_listen_update: update listen(, %d)"
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
name|update_backlog
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|socket_get_backlog
argument_list|(
name|sock
argument_list|,
operator|&
name|backlog_retrieved
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
literal|"socket_listen_update"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|backlog_retrieved
operator|!=
name|update_backlog_assertion
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s: socket_listen_update: updated backlog is %d "
literal|"not %d"
argument_list|,
name|testclass
argument_list|,
name|test
argument_list|,
name|backlog_retrieved
argument_list|,
name|update_backlog_assertion
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|sockp
operator|=
name|sock
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This test tests using listen() to update the queue depth after a socket  * has already been marked as listening.  We test several cases: setting the  * socket< 0, 0, 1, somaxconn, and somaxconn + 1.  */
end_comment

begin_function
specifier|static
name|void
name|test_listen_update
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|sock
decl_stmt|;
comment|/* 	 * Set to 5, update to -1, which should give somaxconn. 	 */
if|if
condition|(
name|socket_listen_update
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
operator|-
literal|1
argument_list|,
literal|5
argument_list|,
name|somaxconn
argument_list|,
operator|&
name|sock
argument_list|,
literal|"PF_INET"
argument_list|,
literal|"SOCK_STREAM"
argument_list|,
literal|"test_listen_update"
argument_list|,
literal|"update_5,-1"
argument_list|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * Set to 5, update to 0, which should give 0. 	 */
if|if
condition|(
name|socket_listen_update
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
operator|&
name|sock
argument_list|,
literal|"PF_INET"
argument_list|,
literal|"SOCK_STREAM"
argument_list|,
literal|"test_listen_update"
argument_list|,
literal|"update_5,0"
argument_list|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * Set to 5, update to 1, which should give 1. 	 */
if|if
condition|(
name|socket_listen_update
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
operator|&
name|sock
argument_list|,
literal|"PF_INET"
argument_list|,
literal|"SOCK_STREAM"
argument_list|,
literal|"test_listen_update"
argument_list|,
literal|"update_5,1"
argument_list|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * Set to 5, update to somaxconn, which should give somaxconn. 	 */
if|if
condition|(
name|socket_listen_update
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
name|somaxconn
argument_list|,
literal|5
argument_list|,
name|somaxconn
argument_list|,
operator|&
name|sock
argument_list|,
literal|"PF_INET"
argument_list|,
literal|"SOCK_STREAM"
argument_list|,
literal|"test_listen_update"
argument_list|,
literal|"update_5,somaxconn"
argument_list|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * Set to 5, update to somaxconn+1, which should give somaxconn. 	 */
if|if
condition|(
name|socket_listen_update
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
name|somaxconn
operator|+
literal|1
argument_list|,
literal|5
argument_list|,
name|somaxconn
argument_list|,
operator|&
name|sock
argument_list|,
literal|"PF_INET"
argument_list|,
literal|"SOCK_STREAM"
argument_list|,
literal|"test_listen_update"
argument_list|,
literal|"update_5,somaxconn+1"
argument_list|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SO_LISTENQLIMIT is a read-only socket option, so make sure we get an error  * if we try to write it.  */
end_comment

begin_function
specifier|static
name|void
name|test_set_qlimit
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|,
name|sock
decl_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"test_set_qlimit: socket(PF_INET, SOCK_STREAM)"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_LISTENQLIMIT
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOPROTOOPT
condition|)
block|{
name|warn
argument_list|(
literal|"test_set_qlimit: setsockopt(SOL_SOCKET, "
literal|"SO_LISTENQLIMIT, 0): unexpected error"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"test_set_qlimit: setsockopt(SOL_SOCKET, "
literal|"SO_LISTENQLIMIT, 0) succeeded"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|somaxconn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"kern.ipc.somaxconn"
argument_list|,
operator|&
name|somaxconn
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"sysctlbyname(kern.ipc.somaxconn)"
argument_list|)
expr_stmt|;
name|test_defaults
argument_list|()
expr_stmt|;
name|test_listen_update
argument_list|()
expr_stmt|;
name|test_set_qlimit
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

