begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2001 Apple Computer, Inc. All rights reserved.  *  * @APPLE_LICENSE_HEADER_START@  *  * The contents of this file constitute Original Code as defined in and  * are subject to the Apple Public Source License Version 2.0 (the  * "License").  You may not use this file except in compliance with the  * License.  Please obtain a copy of the License at  * http://www.opensource.apple.com/apsl/ and read it before using this file.  *  * This Original Code and all software distributed under the License are  * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER  * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,  * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the  * License for the specific language governing rights and limitations  * under the License.  *  * @APPLE_LICENSE_HEADER_END@  *  *	File:	fsx.c  *	Author:	Avadis Tevanian, Jr.  *  *	File system exerciser.   *  *	Rewrite and enhancements 1998-2001 Conrad Minshall -- conrad@mac.com  *  *	Various features from Joe Sokol, Pat Dirks, and Clark Warner.  *  *	Small changes to work under Linux -- davej@suse.de  *  *	Sundry porting patches from Guy Harris 12/2001  *  *	Checks for mmap last-page zero fill.  *  *	Updated license to APSL 2.0, 2004/7/27 - Jordan Hubbard  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_UWIN
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FILE
end_ifndef

begin_define
define|#
directive|define
name|MAP_FILE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|NUMPRINTCOLUMNS
value|32
end_define

begin_comment
comment|/* # columns of data to print on each line */
end_comment

begin_comment
comment|/*  *	A log entry is an operation and a bunch of arguments.  */
end_comment

begin_struct
struct|struct
name|log_entry
block|{
name|int
name|operation
decl_stmt|;
name|int
name|args
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LOGSIZE
value|1000
end_define

begin_decl_stmt
name|struct
name|log_entry
name|oplog
index|[
name|LOGSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the log */
end_comment

begin_decl_stmt
name|int
name|logptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current position in log */
end_comment

begin_decl_stmt
name|int
name|logcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total ops */
end_comment

begin_comment
comment|/*  *	Define operations  */
end_comment

begin_define
define|#
directive|define
name|OP_READ
value|1
end_define

begin_define
define|#
directive|define
name|OP_WRITE
value|2
end_define

begin_define
define|#
directive|define
name|OP_TRUNCATE
value|3
end_define

begin_define
define|#
directive|define
name|OP_CLOSEOPEN
value|4
end_define

begin_define
define|#
directive|define
name|OP_MAPREAD
value|5
end_define

begin_define
define|#
directive|define
name|OP_MAPWRITE
value|6
end_define

begin_define
define|#
directive|define
name|OP_SKIPPED
value|7
end_define

begin_decl_stmt
name|int
name|page_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|page_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|original_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a pointer to the original data */
end_comment

begin_decl_stmt
name|char
modifier|*
name|good_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a pointer to the correct data */
end_comment

begin_decl_stmt
name|char
modifier|*
name|temp_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a pointer to the current data */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of our test file */
end_comment

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fd for our test file */
end_comment

begin_decl_stmt
name|off_t
name|file_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|off_t
name|biggest
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|state
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|testcalls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to function "test" */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|simulatedopcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -b flag */
end_comment

begin_decl_stmt
name|int
name|closeprob
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -c flag */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -d flag */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|debugstart
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -D flag */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|maxfilelen
init|=
literal|256
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -l flag */
end_comment

begin_decl_stmt
name|int
name|sizechecks
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -n flag disables them */
end_comment

begin_decl_stmt
name|int
name|maxoplen
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -o flag */
end_comment

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -q flag */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|progressinterval
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -p flag */
end_comment

begin_decl_stmt
name|int
name|readbdy
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -r flag */
end_comment

begin_decl_stmt
name|int
name|style
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -s flag */
end_comment

begin_decl_stmt
name|int
name|truncbdy
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -t flag */
end_comment

begin_decl_stmt
name|int
name|writebdy
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -w flag */
end_comment

begin_decl_stmt
name|long
name|monitorstart
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -m flag */
end_comment

begin_decl_stmt
name|long
name|monitorend
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -m flag */
end_comment

begin_decl_stmt
name|int
name|lite
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -L flag */
end_comment

begin_decl_stmt
name|long
name|numops
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -N flag */
end_comment

begin_decl_stmt
name|int
name|randomoplen
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -O flag disables it */
end_comment

begin_decl_stmt
name|int
name|seed
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -S flag */
end_comment

begin_decl_stmt
name|int
name|mapped_writes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -W flag disables */
end_comment

begin_decl_stmt
name|int
name|mapped_reads
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -R flag disables it */
end_comment

begin_decl_stmt
name|int
name|fsxgoodfd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fsxlogf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|badoff
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|closeopen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|vwarnc
parameter_list|(
name|code
parameter_list|,
name|fmt
parameter_list|,
name|ap
parameter_list|)
name|int
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fsx: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|!=
name|NULL
condition|)
block|{
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strerror
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|warn
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vwarnc
argument_list|(
name|errno
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prt
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stdout
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsxlogf
condition|)
block|{
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|fsxlogf
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|prterr
parameter_list|(
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|prt
argument_list|(
literal|"%s%s%s\n"
argument_list|,
name|prefix
argument_list|,
name|prefix
condition|?
literal|": "
else|:
literal|""
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|log4
parameter_list|(
name|int
name|operation
parameter_list|,
name|int
name|arg0
parameter_list|,
name|int
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
name|struct
name|log_entry
modifier|*
name|le
decl_stmt|;
name|le
operator|=
operator|&
name|oplog
index|[
name|logptr
index|]
expr_stmt|;
name|le
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
if|if
condition|(
name|closeopen
condition|)
name|le
operator|->
name|operation
operator|=
operator|~
name|le
operator|->
name|operation
expr_stmt|;
name|le
operator|->
name|args
index|[
literal|0
index|]
operator|=
name|arg0
expr_stmt|;
name|le
operator|->
name|args
index|[
literal|1
index|]
operator|=
name|arg1
expr_stmt|;
name|le
operator|->
name|args
index|[
literal|2
index|]
operator|=
name|arg2
expr_stmt|;
name|logptr
operator|++
expr_stmt|;
name|logcount
operator|++
expr_stmt|;
if|if
condition|(
name|logptr
operator|>=
name|LOGSIZE
condition|)
name|logptr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|logdump
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|down
decl_stmt|;
name|struct
name|log_entry
modifier|*
name|lp
decl_stmt|;
name|prt
argument_list|(
literal|"LOG DUMP (%d total operations):\n"
argument_list|,
name|logcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|logcount
operator|<
name|LOGSIZE
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|logcount
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|logptr
expr_stmt|;
name|count
operator|=
name|LOGSIZE
expr_stmt|;
block|}
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|int
name|opnum
decl_stmt|;
name|opnum
operator|=
name|i
operator|+
literal|1
operator|+
operator|(
name|logcount
operator|/
name|LOGSIZE
operator|)
operator|*
name|LOGSIZE
expr_stmt|;
name|prt
argument_list|(
literal|"%d(%d mod 256): "
argument_list|,
name|opnum
argument_list|,
name|opnum
operator|%
literal|256
argument_list|)
expr_stmt|;
name|lp
operator|=
operator|&
name|oplog
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|closeopen
operator|=
name|lp
operator|->
name|operation
operator|<
literal|0
operator|)
condition|)
name|lp
operator|->
name|operation
operator|=
operator|~
name|lp
operator|->
name|operation
expr_stmt|;
switch|switch
condition|(
name|lp
operator|->
name|operation
condition|)
block|{
case|case
name|OP_MAPREAD
case|:
name|prt
argument_list|(
literal|"MAPREAD\t0x%x thru 0x%x\t(0x%x bytes)"
argument_list|,
name|lp
operator|->
name|args
index|[
literal|0
index|]
argument_list|,
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|+
name|lp
operator|->
name|args
index|[
literal|1
index|]
operator|-
literal|1
argument_list|,
name|lp
operator|->
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|badoff
operator|>=
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|&&
name|badoff
operator|<
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|+
name|lp
operator|->
name|args
index|[
literal|1
index|]
condition|)
name|prt
argument_list|(
literal|"\t***RRRR***"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MAPWRITE
case|:
name|prt
argument_list|(
literal|"MAPWRITE 0x%x thru 0x%x\t(0x%x bytes)"
argument_list|,
name|lp
operator|->
name|args
index|[
literal|0
index|]
argument_list|,
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|+
name|lp
operator|->
name|args
index|[
literal|1
index|]
operator|-
literal|1
argument_list|,
name|lp
operator|->
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|badoff
operator|>=
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|&&
name|badoff
operator|<
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|+
name|lp
operator|->
name|args
index|[
literal|1
index|]
condition|)
name|prt
argument_list|(
literal|"\t******WWWW"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_READ
case|:
name|prt
argument_list|(
literal|"READ\t0x%x thru 0x%x\t(0x%x bytes)"
argument_list|,
name|lp
operator|->
name|args
index|[
literal|0
index|]
argument_list|,
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|+
name|lp
operator|->
name|args
index|[
literal|1
index|]
operator|-
literal|1
argument_list|,
name|lp
operator|->
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|badoff
operator|>=
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|&&
name|badoff
operator|<
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|+
name|lp
operator|->
name|args
index|[
literal|1
index|]
condition|)
name|prt
argument_list|(
literal|"\t***RRRR***"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_WRITE
case|:
name|prt
argument_list|(
literal|"WRITE\t0x%x thru 0x%x\t(0x%x bytes)"
argument_list|,
name|lp
operator|->
name|args
index|[
literal|0
index|]
argument_list|,
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|+
name|lp
operator|->
name|args
index|[
literal|1
index|]
operator|-
literal|1
argument_list|,
name|lp
operator|->
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|>
name|lp
operator|->
name|args
index|[
literal|2
index|]
condition|)
name|prt
argument_list|(
literal|" HOLE"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|+
name|lp
operator|->
name|args
index|[
literal|1
index|]
operator|>
name|lp
operator|->
name|args
index|[
literal|2
index|]
condition|)
name|prt
argument_list|(
literal|" EXTEND"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|badoff
operator|>=
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|||
name|badoff
operator|>=
name|lp
operator|->
name|args
index|[
literal|2
index|]
operator|)
operator|&&
name|badoff
operator|<
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|+
name|lp
operator|->
name|args
index|[
literal|1
index|]
condition|)
name|prt
argument_list|(
literal|"\t***WWWW"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_TRUNCATE
case|:
name|down
operator|=
name|lp
operator|->
name|args
index|[
literal|0
index|]
operator|<
name|lp
operator|->
name|args
index|[
literal|1
index|]
expr_stmt|;
name|prt
argument_list|(
literal|"TRUNCATE %s\tfrom 0x%x to 0x%x"
argument_list|,
name|down
condition|?
literal|"DOWN"
else|:
literal|"UP"
argument_list|,
name|lp
operator|->
name|args
index|[
literal|1
index|]
argument_list|,
name|lp
operator|->
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|badoff
operator|>=
name|lp
operator|->
name|args
index|[
operator|!
name|down
index|]
operator|&&
name|badoff
operator|<
name|lp
operator|->
name|args
index|[
operator|!
operator|!
name|down
index|]
condition|)
name|prt
argument_list|(
literal|"\t******WWWW"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SKIPPED
case|:
name|prt
argument_list|(
literal|"SKIPPED (no operation)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|prt
argument_list|(
literal|"BOGUS LOG ENTRY (operation code = %d)!"
argument_list|,
name|lp
operator|->
name|operation
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closeopen
condition|)
name|prt
argument_list|(
literal|"\n\t\tCLOSE/OPEN"
argument_list|)
expr_stmt|;
name|prt
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|LOGSIZE
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|save_buffer
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|off_t
name|bufferlength
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|off_t
name|ret
decl_stmt|;
name|ssize_t
name|byteswritten
decl_stmt|;
if|if
condition|(
name|fd
operator|<=
literal|0
operator|||
name|bufferlength
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|bufferlength
operator|>
name|SSIZE_MAX
condition|)
block|{
name|prt
argument_list|(
literal|"fsx flaw: overflow in save_buffer\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|67
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lite
condition|)
block|{
name|off_t
name|size_by_seek
init|=
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
decl_stmt|;
if|if
condition|(
name|size_by_seek
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
name|prterr
argument_list|(
literal|"save_buffer: lseek eof"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bufferlength
operator|>
name|size_by_seek
condition|)
block|{
name|warn
argument_list|(
literal|"save_buffer: .fsxgood file too short... will save 0x%llx bytes instead of 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|size_by_seek
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|bufferlength
argument_list|)
expr_stmt|;
name|bufferlength
operator|=
name|size_by_seek
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
name|prterr
argument_list|(
literal|"save_buffer: lseek 0"
argument_list|)
expr_stmt|;
name|byteswritten
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
operator|(
name|size_t
operator|)
name|bufferlength
argument_list|)
expr_stmt|;
if|if
condition|(
name|byteswritten
operator|!=
name|bufferlength
condition|)
block|{
if|if
condition|(
name|byteswritten
operator|==
operator|-
literal|1
condition|)
name|prterr
argument_list|(
literal|"save_buffer write"
argument_list|)
expr_stmt|;
else|else
name|warn
argument_list|(
literal|"save_buffer: short write, 0x%x bytes instead of 0x%llx\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|byteswritten
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|bufferlength
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|report_failure
parameter_list|(
name|int
name|status
parameter_list|)
block|{
name|logdump
argument_list|()
expr_stmt|;
if|if
condition|(
name|fsxgoodfd
condition|)
block|{
if|if
condition|(
name|good_buf
condition|)
block|{
name|save_buffer
argument_list|(
name|good_buf
argument_list|,
name|file_size
argument_list|,
name|fsxgoodfd
argument_list|)
expr_stmt|;
name|prt
argument_list|(
literal|"Correct content saved for comparison\n"
argument_list|)
expr_stmt|;
name|prt
argument_list|(
literal|"(maybe hexdump \"%s\" vs \"%s.fsxgood\")\n"
argument_list|,
name|fname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fsxgoodfd
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|short_at
parameter_list|(
name|cp
parameter_list|)
value|((unsigned short)((*((unsigned char *)(cp))<< 8) | \ 					*(((unsigned char *)(cp)) + 1)))
end_define

begin_function
name|void
name|check_buffers
parameter_list|(
name|unsigned
name|offset
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|unsigned
name|char
name|c
decl_stmt|,
name|t
decl_stmt|;
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|n
init|=
literal|0
decl_stmt|;
name|unsigned
name|op
init|=
literal|0
decl_stmt|;
name|unsigned
name|bad
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|good_buf
operator|+
name|offset
argument_list|,
name|temp_buf
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|prt
argument_list|(
literal|"READ BAD DATA: offset = 0x%x, size = 0x%x\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|prt
argument_list|(
literal|"OFFSET\tGOOD\tBAD\tRANGE\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|c
operator|=
name|good_buf
index|[
name|offset
index|]
expr_stmt|;
name|t
operator|=
name|temp_buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|t
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|bad
operator|=
name|short_at
argument_list|(
operator|&
name|temp_buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|prt
argument_list|(
literal|"0x%5x\t0x%04x\t0x%04x"
argument_list|,
name|offset
argument_list|,
name|short_at
argument_list|(
operator|&
name|good_buf
index|[
name|offset
index|]
argument_list|)
argument_list|,
name|bad
argument_list|)
expr_stmt|;
name|op
operator|=
name|temp_buf
index|[
name|offset
operator|&
literal|1
condition|?
name|i
operator|+
literal|1
else|:
name|i
index|]
expr_stmt|;
block|}
name|n
operator|++
expr_stmt|;
name|badoff
operator|=
name|offset
expr_stmt|;
block|}
name|offset
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|size
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
block|{
name|prt
argument_list|(
literal|"\t0x%5x\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
condition|)
name|prt
argument_list|(
literal|"operation# (mod 256) for the bad data may be %u\n"
argument_list|,
operator|(
operator|(
name|unsigned
operator|)
name|op
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
else|else
name|prt
argument_list|(
literal|"operation# (mod 256) for the bad data unknown, check HOLE and EXTEND ops\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|prt
argument_list|(
literal|"????????????????\n"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|110
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|check_size
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|off_t
name|size_by_seek
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
name|prterr
argument_list|(
literal|"check_size: fstat"
argument_list|)
expr_stmt|;
name|statbuf
operator|.
name|st_size
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|size_by_seek
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_size
operator|!=
name|statbuf
operator|.
name|st_size
operator|||
name|file_size
operator|!=
name|size_by_seek
condition|)
block|{
name|prt
argument_list|(
literal|"Size error: expected 0x%llx stat 0x%llx seek 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|file_size
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|statbuf
operator|.
name|st_size
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|size_by_seek
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|120
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|check_trunc_hack
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|ftruncate
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|ftruncate
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|100000
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|statbuf
operator|.
name|st_size
operator|!=
operator|(
name|off_t
operator|)
literal|100000
condition|)
block|{
name|prt
argument_list|(
literal|"no extend on truncate! not posix!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|130
argument_list|)
expr_stmt|;
block|}
name|ftruncate
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|doread
parameter_list|(
name|unsigned
name|offset
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|off_t
name|ret
decl_stmt|;
name|unsigned
name|iret
decl_stmt|;
name|offset
operator|-=
name|offset
operator|%
name|readbdy
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
operator|&&
name|testcalls
operator|>
name|simulatedopcount
condition|)
name|prt
argument_list|(
literal|"skipping zero size read\n"
argument_list|)
expr_stmt|;
name|log4
argument_list|(
name|OP_SKIPPED
argument_list|,
name|OP_READ
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|+
name|offset
operator|>
name|file_size
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
operator|&&
name|testcalls
operator|>
name|simulatedopcount
condition|)
name|prt
argument_list|(
literal|"skipping seek/read past end of file\n"
argument_list|)
expr_stmt|;
name|log4
argument_list|(
name|OP_SKIPPED
argument_list|,
name|OP_READ
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|log4
argument_list|(
name|OP_READ
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|testcalls
operator|<=
name|simulatedopcount
condition|)
return|return;
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|(
operator|(
name|progressinterval
operator|&&
name|testcalls
operator|%
name|progressinterval
operator|==
literal|0
operator|)
operator|||
operator|(
name|debug
operator|&&
operator|(
name|monitorstart
operator|==
operator|-
literal|1
operator|||
operator|(
name|offset
operator|+
name|size
operator|>
name|monitorstart
operator|&&
operator|(
name|monitorend
operator|==
operator|-
literal|1
operator|||
name|offset
operator|<=
name|monitorend
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|prt
argument_list|(
literal|"%lu read\t0x%x thru\t0x%x\t(0x%x bytes)\n"
argument_list|,
name|testcalls
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|size
operator|-
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
block|{
name|prterr
argument_list|(
literal|"doread: lseek"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|140
argument_list|)
expr_stmt|;
block|}
name|iret
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|temp_buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|size
condition|)
block|{
if|if
condition|(
name|iret
operator|==
operator|-
literal|1
condition|)
name|prterr
argument_list|(
literal|"doread: read"
argument_list|)
expr_stmt|;
else|else
name|prt
argument_list|(
literal|"short read: 0x%x bytes instead of 0x%x\n"
argument_list|,
name|iret
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|141
argument_list|)
expr_stmt|;
block|}
name|check_buffers
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|check_eofpage
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|offset
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|uintptr_t
name|last_page
decl_stmt|,
name|should_be_zero
decl_stmt|;
if|if
condition|(
name|offset
operator|+
name|size
operator|<=
operator|(
name|file_size
operator|&
operator|~
name|page_mask
operator|)
condition|)
return|return;
comment|/* 	 * we landed in the last page of the file 	 * test to make sure the VM system provided 0's  	 * beyond the true end of the file mapping 	 * (as required by mmap def in 1996 posix 1003.1) 	 */
name|last_page
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|p
operator|+
operator|(
name|offset
operator|&
name|page_mask
operator|)
operator|+
name|size
operator|)
operator|&
operator|~
name|page_mask
expr_stmt|;
for|for
control|(
name|should_be_zero
operator|=
name|last_page
operator|+
operator|(
name|file_size
operator|&
name|page_mask
operator|)
init|;
name|should_be_zero
operator|<
name|last_page
operator|+
name|page_size
condition|;
name|should_be_zero
operator|++
control|)
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|)
name|should_be_zero
condition|)
block|{
name|prt
argument_list|(
literal|"Mapped %s: non-zero data past EOF (0x%llx) page offset 0x%x is 0x%04x\n"
argument_list|,
name|s
argument_list|,
name|file_size
operator|-
literal|1
argument_list|,
name|should_be_zero
operator|&
name|page_mask
argument_list|,
name|short_at
argument_list|(
name|should_be_zero
argument_list|)
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|205
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|domapread
parameter_list|(
name|unsigned
name|offset
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|unsigned
name|pg_offset
decl_stmt|;
name|unsigned
name|map_size
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|offset
operator|-=
name|offset
operator|%
name|readbdy
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
operator|&&
name|testcalls
operator|>
name|simulatedopcount
condition|)
name|prt
argument_list|(
literal|"skipping zero size read\n"
argument_list|)
expr_stmt|;
name|log4
argument_list|(
name|OP_SKIPPED
argument_list|,
name|OP_MAPREAD
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|+
name|offset
operator|>
name|file_size
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
operator|&&
name|testcalls
operator|>
name|simulatedopcount
condition|)
name|prt
argument_list|(
literal|"skipping seek/read past end of file\n"
argument_list|)
expr_stmt|;
name|log4
argument_list|(
name|OP_SKIPPED
argument_list|,
name|OP_MAPREAD
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|log4
argument_list|(
name|OP_MAPREAD
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|testcalls
operator|<=
name|simulatedopcount
condition|)
return|return;
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|(
operator|(
name|progressinterval
operator|&&
name|testcalls
operator|%
name|progressinterval
operator|==
literal|0
operator|)
operator|||
operator|(
name|debug
operator|&&
operator|(
name|monitorstart
operator|==
operator|-
literal|1
operator|||
operator|(
name|offset
operator|+
name|size
operator|>
name|monitorstart
operator|&&
operator|(
name|monitorend
operator|==
operator|-
literal|1
operator|||
name|offset
operator|<=
name|monitorend
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|prt
argument_list|(
literal|"%lu mapread\t0x%x thru\t0x%x\t(0x%x bytes)\n"
argument_list|,
name|testcalls
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|size
operator|-
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pg_offset
operator|=
name|offset
operator|&
name|page_mask
expr_stmt|;
name|map_size
operator|=
name|pg_offset
operator|+
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|map_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_FILE
operator||
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|offset
operator|-
name|pg_offset
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|prterr
argument_list|(
literal|"domapread: mmap"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|190
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|temp_buf
argument_list|,
name|p
operator|+
name|pg_offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|check_eofpage
argument_list|(
literal|"Read"
argument_list|,
name|offset
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|munmap
argument_list|(
name|p
argument_list|,
name|map_size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|prterr
argument_list|(
literal|"domapread: munmap"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|191
argument_list|)
expr_stmt|;
block|}
name|check_buffers
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gendata
parameter_list|(
name|char
modifier|*
name|original_buf
parameter_list|,
name|char
modifier|*
name|good_buf
parameter_list|,
name|unsigned
name|offset
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
while|while
condition|(
name|size
operator|--
condition|)
block|{
name|good_buf
index|[
name|offset
index|]
operator|=
name|testcalls
operator|%
literal|256
expr_stmt|;
if|if
condition|(
name|offset
operator|%
literal|2
condition|)
name|good_buf
index|[
name|offset
index|]
operator|+=
name|original_buf
index|[
name|offset
index|]
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dowrite
parameter_list|(
name|unsigned
name|offset
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|off_t
name|ret
decl_stmt|;
name|unsigned
name|iret
decl_stmt|;
name|offset
operator|-=
name|offset
operator|%
name|writebdy
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
operator|&&
name|testcalls
operator|>
name|simulatedopcount
condition|)
name|prt
argument_list|(
literal|"skipping zero size write\n"
argument_list|)
expr_stmt|;
name|log4
argument_list|(
name|OP_SKIPPED
argument_list|,
name|OP_WRITE
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|log4
argument_list|(
name|OP_WRITE
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|file_size
argument_list|)
expr_stmt|;
name|gendata
argument_list|(
name|original_buf
argument_list|,
name|good_buf
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_size
operator|<
name|offset
operator|+
name|size
condition|)
block|{
if|if
condition|(
name|file_size
operator|<
name|offset
condition|)
name|memset
argument_list|(
name|good_buf
operator|+
name|file_size
argument_list|,
literal|'\0'
argument_list|,
name|offset
operator|-
name|file_size
argument_list|)
expr_stmt|;
name|file_size
operator|=
name|offset
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|lite
condition|)
block|{
name|warn
argument_list|(
literal|"Lite file size bug in fsx!"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|149
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|testcalls
operator|<=
name|simulatedopcount
condition|)
return|return;
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|(
operator|(
name|progressinterval
operator|&&
name|testcalls
operator|%
name|progressinterval
operator|==
literal|0
operator|)
operator|||
operator|(
name|debug
operator|&&
operator|(
name|monitorstart
operator|==
operator|-
literal|1
operator|||
operator|(
name|offset
operator|+
name|size
operator|>
name|monitorstart
operator|&&
operator|(
name|monitorend
operator|==
operator|-
literal|1
operator|||
name|offset
operator|<=
name|monitorend
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|prt
argument_list|(
literal|"%lu write\t0x%x thru\t0x%x\t(0x%x bytes)\n"
argument_list|,
name|testcalls
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|size
operator|-
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
block|{
name|prterr
argument_list|(
literal|"dowrite: lseek"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|150
argument_list|)
expr_stmt|;
block|}
name|iret
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|good_buf
operator|+
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|!=
name|size
condition|)
block|{
if|if
condition|(
name|iret
operator|==
operator|-
literal|1
condition|)
name|prterr
argument_list|(
literal|"dowrite: write"
argument_list|)
expr_stmt|;
else|else
name|prt
argument_list|(
literal|"short write: 0x%x bytes instead of 0x%x\n"
argument_list|,
name|iret
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|151
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|domapwrite
parameter_list|(
name|unsigned
name|offset
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|unsigned
name|pg_offset
decl_stmt|;
name|unsigned
name|map_size
decl_stmt|;
name|off_t
name|cur_filesize
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|offset
operator|-=
name|offset
operator|%
name|writebdy
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
operator|&&
name|testcalls
operator|>
name|simulatedopcount
condition|)
name|prt
argument_list|(
literal|"skipping zero size write\n"
argument_list|)
expr_stmt|;
name|log4
argument_list|(
name|OP_SKIPPED
argument_list|,
name|OP_MAPWRITE
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|cur_filesize
operator|=
name|file_size
expr_stmt|;
name|log4
argument_list|(
name|OP_MAPWRITE
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gendata
argument_list|(
name|original_buf
argument_list|,
name|good_buf
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_size
operator|<
name|offset
operator|+
name|size
condition|)
block|{
if|if
condition|(
name|file_size
operator|<
name|offset
condition|)
name|memset
argument_list|(
name|good_buf
operator|+
name|file_size
argument_list|,
literal|'\0'
argument_list|,
name|offset
operator|-
name|file_size
argument_list|)
expr_stmt|;
name|file_size
operator|=
name|offset
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|lite
condition|)
block|{
name|warn
argument_list|(
literal|"Lite file size bug in fsx!"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|testcalls
operator|<=
name|simulatedopcount
condition|)
return|return;
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|(
operator|(
name|progressinterval
operator|&&
name|testcalls
operator|%
name|progressinterval
operator|==
literal|0
operator|)
operator|||
operator|(
name|debug
operator|&&
operator|(
name|monitorstart
operator|==
operator|-
literal|1
operator|||
operator|(
name|offset
operator|+
name|size
operator|>
name|monitorstart
operator|&&
operator|(
name|monitorend
operator|==
operator|-
literal|1
operator|||
name|offset
operator|<=
name|monitorend
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|prt
argument_list|(
literal|"%lu mapwrite\t0x%x thru\t0x%x\t(0x%x bytes)\n"
argument_list|,
name|testcalls
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|size
operator|-
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_size
operator|>
name|cur_filesize
condition|)
block|{
if|if
condition|(
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|file_size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|prterr
argument_list|(
literal|"domapwrite: ftruncate"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|201
argument_list|)
expr_stmt|;
block|}
block|}
name|pg_offset
operator|=
name|offset
operator|&
name|page_mask
expr_stmt|;
name|map_size
operator|=
name|pg_offset
operator|+
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|map_size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_FILE
operator||
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|offset
operator|-
name|pg_offset
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|prterr
argument_list|(
literal|"domapwrite: mmap"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|202
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
operator|+
name|pg_offset
argument_list|,
name|good_buf
operator|+
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|msync
argument_list|(
name|p
argument_list|,
name|map_size
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|prterr
argument_list|(
literal|"domapwrite: msync"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|203
argument_list|)
expr_stmt|;
block|}
name|check_eofpage
argument_list|(
literal|"Write"
argument_list|,
name|offset
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|munmap
argument_list|(
name|p
argument_list|,
name|map_size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|prterr
argument_list|(
literal|"domapwrite: munmap"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|204
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dotruncate
parameter_list|(
name|unsigned
name|size
parameter_list|)
block|{
name|int
name|oldsize
init|=
name|file_size
decl_stmt|;
name|size
operator|-=
name|size
operator|%
name|truncbdy
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|biggest
condition|)
block|{
name|biggest
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|&&
name|testcalls
operator|>
name|simulatedopcount
condition|)
name|prt
argument_list|(
literal|"truncating to largest ever: 0x%x\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|log4
argument_list|(
name|OP_TRUNCATE
argument_list|,
name|size
argument_list|,
operator|(
name|unsigned
operator|)
name|file_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|file_size
condition|)
name|memset
argument_list|(
name|good_buf
operator|+
name|file_size
argument_list|,
literal|'\0'
argument_list|,
name|size
operator|-
name|file_size
argument_list|)
expr_stmt|;
name|file_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|testcalls
operator|<=
name|simulatedopcount
condition|)
return|return;
if|if
condition|(
operator|(
name|progressinterval
operator|&&
name|testcalls
operator|%
name|progressinterval
operator|==
literal|0
operator|)
operator|||
operator|(
name|debug
operator|&&
operator|(
name|monitorstart
operator|==
operator|-
literal|1
operator|||
name|monitorend
operator|==
operator|-
literal|1
operator|||
name|size
operator|<=
name|monitorend
operator|)
operator|)
condition|)
name|prt
argument_list|(
literal|"%lu trunc\tfrom 0x%x to 0x%x\n"
argument_list|,
name|testcalls
argument_list|,
name|oldsize
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftruncate
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|prt
argument_list|(
literal|"ftruncate1: %x\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|prterr
argument_list|(
literal|"dotruncate: ftruncate"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|160
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|writefileimage
parameter_list|()
block|{
name|ssize_t
name|iret
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
block|{
name|prterr
argument_list|(
literal|"writefileimage: lseek"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|171
argument_list|)
expr_stmt|;
block|}
name|iret
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|good_buf
argument_list|,
name|file_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off_t
operator|)
name|iret
operator|!=
name|file_size
condition|)
block|{
if|if
condition|(
name|iret
operator|==
operator|-
literal|1
condition|)
name|prterr
argument_list|(
literal|"writefileimage: write"
argument_list|)
expr_stmt|;
else|else
name|prt
argument_list|(
literal|"short write: 0x%x bytes instead of 0x%llx\n"
argument_list|,
name|iret
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|file_size
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|172
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lite
condition|?
literal|0
else|:
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|file_size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|prt
argument_list|(
literal|"ftruncate2: %llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|file_size
argument_list|)
expr_stmt|;
name|prterr
argument_list|(
literal|"writefileimage: ftruncate"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|173
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|docloseopen
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|testcalls
operator|<=
name|simulatedopcount
condition|)
return|return;
if|if
condition|(
name|debug
condition|)
name|prt
argument_list|(
literal|"%lu close/open\n"
argument_list|,
name|testcalls
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|prterr
argument_list|(
literal|"docloseopen: close"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|180
argument_list|)
expr_stmt|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|prterr
argument_list|(
literal|"docloseopen: open"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|181
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|test
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|size
init|=
name|maxoplen
decl_stmt|;
name|unsigned
name|long
name|rv
init|=
name|random
argument_list|()
decl_stmt|;
name|unsigned
name|long
name|op
init|=
name|rv
operator|%
operator|(
literal|3
operator|+
operator|!
name|lite
operator|+
name|mapped_writes
operator|)
decl_stmt|;
comment|/* turn off the map read if necessary */
if|if
condition|(
name|op
operator|==
literal|2
operator|&&
operator|!
name|mapped_reads
condition|)
name|op
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|simulatedopcount
operator|>
literal|0
operator|&&
name|testcalls
operator|==
name|simulatedopcount
condition|)
name|writefileimage
argument_list|()
expr_stmt|;
name|testcalls
operator|++
expr_stmt|;
if|if
condition|(
name|closeprob
condition|)
name|closeopen
operator|=
operator|(
name|rv
operator|>>
literal|3
operator|)
operator|<
operator|(
literal|1
operator|<<
literal|28
operator|)
operator|/
name|closeprob
expr_stmt|;
if|if
condition|(
name|debugstart
operator|>
literal|0
operator|&&
name|testcalls
operator|>=
name|debugstart
condition|)
name|debug
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|&&
name|testcalls
operator|<
name|simulatedopcount
operator|&&
name|testcalls
operator|%
literal|100000
operator|==
literal|0
condition|)
name|prt
argument_list|(
literal|"%lu...\n"
argument_list|,
name|testcalls
argument_list|)
expr_stmt|;
comment|/* 	 * READ:	op = 0 	 * WRITE:	op = 1 	 * MAPREAD:     op = 2 	 * TRUNCATE:	op = 3 	 * MAPWRITE:    op = 3 or 4 	 */
if|if
condition|(
name|lite
condition|?
literal|0
else|:
name|op
operator|==
literal|3
operator|&&
name|style
operator|==
literal|0
condition|)
comment|/* vanilla truncate? */
name|dotruncate
argument_list|(
name|random
argument_list|()
operator|%
name|maxfilelen
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|randomoplen
condition|)
name|size
operator|=
name|random
argument_list|()
operator|%
operator|(
name|maxoplen
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|lite
condition|?
literal|0
else|:
name|op
operator|==
literal|3
condition|)
name|dotruncate
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
block|{
name|offset
operator|=
name|random
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|1
operator|||
name|op
operator|==
operator|(
name|lite
condition|?
literal|3
else|:
literal|4
operator|)
condition|)
block|{
name|offset
operator|%=
name|maxfilelen
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|size
operator|>
name|maxfilelen
condition|)
name|size
operator|=
name|maxfilelen
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|op
operator|!=
literal|1
condition|)
name|domapwrite
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|dowrite
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|file_size
condition|)
name|offset
operator|%=
name|file_size
expr_stmt|;
else|else
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|size
operator|>
name|file_size
condition|)
name|size
operator|=
name|file_size
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|op
operator|!=
literal|0
condition|)
name|domapread
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|doread
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|sizechecks
operator|&&
name|testcalls
operator|>
name|simulatedopcount
condition|)
name|check_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|closeopen
condition|)
name|docloseopen
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cleanup
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|sig
condition|)
name|prt
argument_list|(
literal|"signal %d\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|prt
argument_list|(
literal|"testcalls = %lu\n"
argument_list|,
name|testcalls
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"usage: %s"
argument_list|,
literal|"fsx [-dnqLOW] [-b opnum] [-c Prob] [-l flen] [-m start:end] [-o oplen] [-p progressinterval] [-r readbdy] [-s style] [-t truncbdy] [-w writebdy] [-D startingop] [-N numops] [-P dirpath] [-S seed] fname\n\ 	-b opnum: beginning operation number (default 1)\n\ 	-c P: 1 in P chance of file close+open at each op (default infinity)\n\ 	-d: debug output for all operations\n\ 	-l flen: the upper bound on file size (default 262144)\n\ 	-m startop:endop: monitor (print debug output) specified byte range (default 0:infinity)\n\ 	-n: no verifications of file size\n\ 	-o oplen: the upper bound on operation size (default 65536)\n\ 	-p progressinterval: debug output at specified operation interval\n\ 	-q: quieter operation\n\ 	-r readbdy: 4096 would make reads page aligned (default 1)\n\ 	-s style: 1 gives smaller truncates (default 0)\n\ 	-t truncbdy: 4096 would make truncates page aligned (default 1)\n\ 	-w writebdy: 4096 would make writes page aligned (default 1)\n\ 	-D startingop: debug output starting at specified operation\n\ 	-L: fsxLite - no file creations& no file size changes\n\ 	-N numops: total # operations to do (default infinity)\n\ 	-O: use oplen (see -o flag) for every op (default random)\n\ 	-P dirpath: save .fsxlog and .fsxgood files in dirpath (default ./)\n\ 	-S seed: for random # generator (default 1) 0 gets timestamp\n\ 	-W: mapped write operations DISabled\n\ 	-R: mapped read operations DISabled)\n\ 	fname: this filename is REQUIRED (no default)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|90
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|getnum
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|e
parameter_list|)
block|{
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
operator|*
name|e
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|ret
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|e
condition|)
switch|switch
condition|(
operator|*
operator|*
name|e
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|ret
operator|*=
literal|512
expr_stmt|;
operator|*
name|e
operator|=
operator|*
name|e
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
name|ret
operator|*=
literal|1024
expr_stmt|;
operator|*
name|e
operator|=
operator|*
name|e
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|ret
operator|*=
literal|1024
operator|*
literal|1024
expr_stmt|;
operator|*
name|e
operator|=
operator|*
name|e
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|ret
operator|*=
literal|4
expr_stmt|;
operator|*
name|e
operator|=
operator|*
name|e
operator|+
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ch
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|char
name|goodfile
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|logfile
index|[
literal|1024
index|]
decl_stmt|;
name|goodfile
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|logfile
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|page_size
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
name|page_mask
operator|=
name|page_size
operator|-
literal|1
expr_stmt|;
name|setvbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* line buffered stdout */
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"b:c:dl:m:no:p:qr:s:t:w:D:LN:OP:RS:W"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'b'
case|:
name|simulatedopcount
operator|=
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Will begin at operation %ld\n"
argument_list|,
name|simulatedopcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|simulatedopcount
operator|==
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
name|simulatedopcount
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|closeprob
operator|=
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Chance of close/open is 1 in %d\n"
argument_list|,
name|closeprob
argument_list|)
expr_stmt|;
if|if
condition|(
name|closeprob
operator|<=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|maxfilelen
operator|=
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxfilelen
operator|<=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|monitorstart
operator|=
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitorstart
operator|<
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|endp
operator|||
operator|*
name|endp
operator|++
operator|!=
literal|':'
condition|)
name|usage
argument_list|()
expr_stmt|;
name|monitorend
operator|=
name|getnum
argument_list|(
name|endp
argument_list|,
operator|&
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitorend
operator|<
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|monitorend
operator|==
literal|0
condition|)
name|monitorend
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* aka infinity */
name|debug
operator|=
literal|1
expr_stmt|;
case|case
literal|'n'
case|:
name|sizechecks
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|maxoplen
operator|=
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxoplen
operator|<=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|progressinterval
operator|=
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
name|progressinterval
operator|<
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|readbdy
operator|=
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
name|readbdy
operator|<=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|style
operator|=
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|<
literal|0
operator|||
name|style
operator|>
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|truncbdy
operator|=
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
name|truncbdy
operator|<=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|writebdy
operator|=
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
name|writebdy
operator|<=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|debugstart
operator|=
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugstart
operator|<
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|lite
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|numops
operator|=
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
name|numops
operator|<
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|randomoplen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|strncpy
argument_list|(
name|goodfile
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|goodfile
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|goodfile
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|logfile
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|logfile
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|logfile
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|mapped_reads
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|seed
operator|=
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
name|seed
operator|==
literal|0
condition|)
name|seed
operator|=
name|time
argument_list|(
literal|0
argument_list|)
operator|%
literal|10000
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Seed set to %d\n"
argument_list|,
name|seed
argument_list|)
expr_stmt|;
if|if
condition|(
name|seed
operator|<
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|mapped_writes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"mapped writes DISABLED\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|fname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGXCPU
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGVTALRM
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|initstate
argument_list|(
name|seed
argument_list|,
name|state
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|setstate
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDWR
operator||
operator|(
name|lite
condition|?
literal|0
else|:
name|O_CREAT
operator||
name|O_TRUNC
operator|)
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|prterr
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|91
argument_list|)
expr_stmt|;
block|}
name|strncat
argument_list|(
name|goodfile
argument_list|,
name|fname
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|goodfile
argument_list|,
literal|".fsxgood"
argument_list|)
expr_stmt|;
name|fsxgoodfd
operator|=
name|open
argument_list|(
name|goodfile
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsxgoodfd
operator|<
literal|0
condition|)
block|{
name|prterr
argument_list|(
name|goodfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|92
argument_list|)
expr_stmt|;
block|}
name|strncat
argument_list|(
name|logfile
argument_list|,
name|fname
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|logfile
argument_list|,
literal|".fsxlog"
argument_list|)
expr_stmt|;
name|fsxlogf
operator|=
name|fopen
argument_list|(
name|logfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsxlogf
operator|==
name|NULL
condition|)
block|{
name|prterr
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|93
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lite
condition|)
block|{
name|off_t
name|ret
decl_stmt|;
name|file_size
operator|=
name|maxfilelen
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_size
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
block|{
name|prterr
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"main: lseek eof"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|94
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
block|{
name|prterr
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"main: lseek 0"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|95
argument_list|)
expr_stmt|;
block|}
block|}
name|original_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|maxfilelen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxfilelen
condition|;
name|i
operator|++
control|)
name|original_buf
index|[
name|i
index|]
operator|=
name|random
argument_list|()
operator|%
literal|256
expr_stmt|;
name|good_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|maxfilelen
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|good_buf
argument_list|,
literal|'\0'
argument_list|,
name|maxfilelen
argument_list|)
expr_stmt|;
name|temp_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|maxoplen
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|temp_buf
argument_list|,
literal|'\0'
argument_list|,
name|maxoplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|lite
condition|)
block|{
comment|/* zero entire existing file */
name|ssize_t
name|written
decl_stmt|;
name|written
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|good_buf
argument_list|,
operator|(
name|size_t
operator|)
name|maxfilelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|!=
name|maxfilelen
condition|)
block|{
if|if
condition|(
name|written
operator|==
operator|-
literal|1
condition|)
block|{
name|prterr
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"main: error on write"
argument_list|)
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"main: short write, 0x%x bytes instead of 0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|written
argument_list|,
name|maxfilelen
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|98
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|check_trunc_hack
argument_list|()
expr_stmt|;
while|while
condition|(
name|numops
operator|==
operator|-
literal|1
operator|||
name|numops
operator|--
condition|)
name|test
argument_list|()
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|prterr
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
name|report_failure
argument_list|(
literal|99
argument_list|)
expr_stmt|;
block|}
name|prt
argument_list|(
literal|"All operations completed A-OK!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

