begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 2004 Michiel Boland.  All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:  1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.  2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/*  * The following code sets up two connected TCP sockets that send data to each  * other until the window is closed. Then one of the sockets is closed, which  * will generate a RST once the TCP at the other socket does a window probe.  *  * All versions of FreeBSD prior to 11/26/2004 will ignore this RST into a 0  * window, causing the connection (and application) to hang indefinitely.  * On patched versions of FreeBSD (and other operating systems), the RST  * will be accepted and the program will exit in a few seconds.  */
end_comment

begin_comment
comment|/*  * If the alarm fired then we've hung and the test failed.  */
end_comment

begin_function
name|void
name|do_alrm
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|printf
argument_list|(
literal|"not ok 1 - tcpfullwindowrst\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|o
decl_stmt|,
name|s
decl_stmt|,
name|t
decl_stmt|,
name|u
decl_stmt|,
name|do_t
decl_stmt|,
name|do_u
decl_stmt|;
name|struct
name|pollfd
name|pfd
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|sa
decl_stmt|;
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"1..1\n"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|do_alrm
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|o
operator|=
literal|1
expr_stmt|;
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|&
name|o
argument_list|,
sizeof|sizeof
name|o
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sa
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|3737
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|listen
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|t
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|connect
argument_list|(
name|t
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|u
operator|=
name|accept
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|t
argument_list|,
name|F_SETFL
argument_list|,
name|fcntl
argument_list|(
name|t
argument_list|,
name|F_GETFL
argument_list|)
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|u
argument_list|,
name|F_SETFL
argument_list|,
name|fcntl
argument_list|(
name|t
argument_list|,
name|F_GETFL
argument_list|)
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
name|do_t
operator|=
literal|1
expr_stmt|;
name|do_u
operator|=
literal|1
expr_stmt|;
name|pfd
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|t
expr_stmt|;
name|pfd
index|[
literal|0
index|]
operator|.
name|events
operator|=
name|POLLOUT
expr_stmt|;
name|pfd
index|[
literal|1
index|]
operator|.
name|fd
operator|=
name|u
expr_stmt|;
name|pfd
index|[
literal|1
index|]
operator|.
name|events
operator|=
name|POLLOUT
expr_stmt|;
while|while
condition|(
name|do_t
operator|||
name|do_u
condition|)
block|{
if|if
condition|(
name|poll
argument_list|(
name|pfd
argument_list|,
literal|2
argument_list|,
literal|1000
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_t
condition|)
block|{
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|pfd
index|[
literal|0
index|]
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|do_t
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|pfd
index|[
literal|0
index|]
operator|.
name|revents
operator|&
name|POLLOUT
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|t
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|pfd
index|[
literal|0
index|]
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|do_t
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pfd
index|[
literal|1
index|]
operator|.
name|revents
operator|&
name|POLLOUT
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|u
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|pfd
index|[
literal|1
index|]
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|do_u
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"ok 1 - tcpfullwindowrst\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

