begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006-2007 Pawel Jakub Dawidek<pjd@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_TRUNCATE64
end_ifndef

begin_define
define|#
directive|define
name|truncate64
value|truncate
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_STAT64
end_ifndef

begin_define
define|#
directive|define
name|stat64
value|stat
end_define

begin_define
define|#
directive|define
name|lstat64
value|lstat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ALLPERMS
end_ifndef

begin_define
define|#
directive|define
name|ALLPERMS
value|(S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|action
block|{
name|ACTION_OPEN
block|,
name|ACTION_CREATE
block|,
name|ACTION_UNLINK
block|,
name|ACTION_MKDIR
block|,
name|ACTION_RMDIR
block|,
name|ACTION_LINK
block|,
name|ACTION_SYMLINK
block|,
name|ACTION_RENAME
block|,
name|ACTION_MKFIFO
block|,
name|ACTION_CHMOD
block|,
ifdef|#
directive|ifdef
name|HAS_LCHMOD
name|ACTION_LCHMOD
block|,
endif|#
directive|endif
name|ACTION_CHOWN
block|,
name|ACTION_LCHOWN
block|,
ifdef|#
directive|ifdef
name|HAS_CHFLAGS
name|ACTION_CHFLAGS
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_LCHFLAGS
name|ACTION_LCHFLAGS
block|,
endif|#
directive|endif
name|ACTION_TRUNCATE
block|,
name|ACTION_STAT
block|,
name|ACTION_LSTAT
block|,
name|ACTION_PATHCONF
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|TYPE_NONE
value|0x0000
end_define

begin_define
define|#
directive|define
name|TYPE_STRING
value|0x0001
end_define

begin_define
define|#
directive|define
name|TYPE_NUMBER
value|0x0002
end_define

begin_define
define|#
directive|define
name|TYPE_OPTIONAL
value|0x0100
end_define

begin_define
define|#
directive|define
name|MAX_ARGS
value|8
end_define

begin_struct
struct|struct
name|syscall_desc
block|{
name|char
modifier|*
name|sd_name
decl_stmt|;
name|enum
name|action
name|sd_action
decl_stmt|;
name|int
name|sd_args
index|[
name|MAX_ARGS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|syscall_desc
name|syscalls
index|[]
init|=
block|{
block|{
literal|"open"
block|,
name|ACTION_OPEN
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_STRING
block|,
name|TYPE_NUMBER
operator||
name|TYPE_OPTIONAL
block|,
name|TYPE_NONE
block|}
block|}
block|,
block|{
literal|"create"
block|,
name|ACTION_CREATE
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_NUMBER
block|,
name|TYPE_NONE
block|}
block|}
block|,
block|{
literal|"unlink"
block|,
name|ACTION_UNLINK
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_NONE
block|}
block|}
block|,
block|{
literal|"mkdir"
block|,
name|ACTION_MKDIR
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_NUMBER
block|,
name|TYPE_NONE
block|}
block|}
block|,
block|{
literal|"rmdir"
block|,
name|ACTION_RMDIR
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_NONE
block|}
block|}
block|,
block|{
literal|"link"
block|,
name|ACTION_LINK
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_STRING
block|,
name|TYPE_NONE
block|}
block|}
block|,
block|{
literal|"symlink"
block|,
name|ACTION_SYMLINK
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_STRING
block|,
name|TYPE_NONE
block|}
block|}
block|,
block|{
literal|"rename"
block|,
name|ACTION_RENAME
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_STRING
block|,
name|TYPE_NONE
block|}
block|}
block|,
block|{
literal|"mkfifo"
block|,
name|ACTION_MKFIFO
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_NUMBER
block|,
name|TYPE_NONE
block|}
block|}
block|,
block|{
literal|"chmod"
block|,
name|ACTION_CHMOD
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_NUMBER
block|,
name|TYPE_NONE
block|}
block|}
block|,
ifdef|#
directive|ifdef
name|HAS_LCHMOD
block|{
literal|"lchmod"
block|,
name|ACTION_LCHMOD
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_NUMBER
block|,
name|TYPE_NONE
block|}
block|}
block|,
endif|#
directive|endif
block|{
literal|"chown"
block|,
name|ACTION_CHOWN
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_NUMBER
block|,
name|TYPE_NUMBER
block|,
name|TYPE_NONE
block|}
block|}
block|,
block|{
literal|"lchown"
block|,
name|ACTION_LCHOWN
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_NUMBER
block|,
name|TYPE_NUMBER
block|,
name|TYPE_NONE
block|}
block|}
block|,
ifdef|#
directive|ifdef
name|HAS_CHFLAGS
block|{
literal|"chflags"
block|,
name|ACTION_CHFLAGS
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_STRING
block|,
name|TYPE_NONE
block|}
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_LCHFLAGS
block|{
literal|"lchflags"
block|,
name|ACTION_LCHFLAGS
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_STRING
block|,
name|TYPE_NONE
block|}
block|}
block|,
endif|#
directive|endif
block|{
literal|"truncate"
block|,
name|ACTION_TRUNCATE
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_NUMBER
block|,
name|TYPE_NONE
block|}
block|}
block|,
block|{
literal|"stat"
block|,
name|ACTION_STAT
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_STRING
block|,
name|TYPE_NONE
block|}
block|}
block|,
block|{
literal|"lstat"
block|,
name|ACTION_LSTAT
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_STRING
block|,
name|TYPE_NONE
block|}
block|}
block|,
block|{
literal|"pathconf"
block|,
name|ACTION_PATHCONF
block|,
block|{
name|TYPE_STRING
block|,
name|TYPE_STRING
block|,
name|TYPE_NONE
block|}
block|}
block|,
block|{
name|NULL
block|,
operator|-
literal|1
block|,
block|{
name|TYPE_NONE
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|flag
block|{
name|long
name|long
name|f_flag
decl_stmt|;
name|char
modifier|*
name|f_str
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|flag
name|open_flags
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|O_RDONLY
block|{
name|O_RDONLY
block|,
literal|"O_RDONLY"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_WRONLY
block|{
name|O_WRONLY
block|,
literal|"O_WRONLY"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_RDWR
block|{
name|O_RDWR
block|,
literal|"O_RDWR"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_NONBLOCK
block|{
name|O_NONBLOCK
block|,
literal|"O_NONBLOCK"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_APPEND
block|{
name|O_APPEND
block|,
literal|"O_APPEND"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_CREAT
block|{
name|O_CREAT
block|,
literal|"O_CREAT"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_TRUNC
block|{
name|O_TRUNC
block|,
literal|"O_TRUNC"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_EXCL
block|{
name|O_EXCL
block|,
literal|"O_EXCL"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_SHLOCK
block|{
name|O_SHLOCK
block|,
literal|"O_SHLOCK"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_EXLOCK
block|{
name|O_EXLOCK
block|,
literal|"O_EXLOCK"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_DIRECT
block|{
name|O_DIRECT
block|,
literal|"O_DIRECT"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_FSYNC
block|{
name|O_FSYNC
block|,
literal|"O_FSYNC"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_SYNC
block|{
name|O_SYNC
block|,
literal|"O_SYNC"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_NOFOLLOW
block|{
name|O_NOFOLLOW
block|,
literal|"O_NOFOLLOW"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_NOCTTY
block|{
name|O_NOCTTY
block|,
literal|"O_NOCTTY"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_CHFLAGS
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|flag
name|chflags_flags
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|UF_NODUMP
block|{
name|UF_NODUMP
block|,
literal|"UF_NODUMP"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UF_IMMUTABLE
block|{
name|UF_IMMUTABLE
block|,
literal|"UF_IMMUTABLE"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UF_APPEND
block|{
name|UF_APPEND
block|,
literal|"UF_APPEND"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UF_NOUNLINK
block|{
name|UF_NOUNLINK
block|,
literal|"UF_NOUNLINK"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UF_OPAQUE
block|{
name|UF_OPAQUE
block|,
literal|"UF_OPAQUE"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SF_ARCHIVED
block|{
name|SF_ARCHIVED
block|,
literal|"SF_ARCHIVED"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SF_IMMUTABLE
block|{
name|SF_IMMUTABLE
block|,
literal|"SF_IMMUTABLE"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SF_APPEND
block|{
name|SF_APPEND
block|,
literal|"SF_APPEND"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SF_NOUNLINK
block|{
name|SF_NOUNLINK
block|,
literal|"SF_NOUNLINK"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SF_SNAPSHOT
block|{
name|SF_SNAPSHOT
block|,
literal|"SF_SNAPSHOT"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|name
block|{
name|int
name|n_name
decl_stmt|;
name|char
modifier|*
name|n_str
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|name
name|pathconf_names
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|_PC_LINK_MAX
block|{
name|_PC_LINK_MAX
block|,
literal|"_PC_LINK_MAX"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PC_NAME_MAX
block|{
name|_PC_NAME_MAX
block|,
literal|"_PC_NAME_MAX"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PC_PATH_MAX
block|{
name|_PC_PATH_MAX
block|,
literal|"_PC_PATH_MAX"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PC_SYMLINK_MAX
block|{
name|_PC_SYMLINK_MAX
block|,
literal|"_PC_SYMLINK_MAX"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|err2str
parameter_list|(
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: fstest [-u uid] [-g gid1[,gid2[...]]] syscall args ...\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|long
name|str2flags
parameter_list|(
name|struct
name|flag
modifier|*
name|tflags
parameter_list|,
name|char
modifier|*
name|sflags
parameter_list|)
block|{
name|long
name|long
name|flags
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|strtok
argument_list|(
name|sflags
argument_list|,
literal|","
argument_list|)
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
control|)
block|{
comment|/* Support magic 'none' flag which just reset all flags. */
if|if
condition|(
name|strcmp
argument_list|(
name|f
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tflags
index|[
name|i
index|]
operator|.
name|f_str
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tflags
index|[
name|i
index|]
operator|.
name|f_str
argument_list|,
name|f
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|tflags
index|[
name|i
index|]
operator|.
name|f_str
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown flag '%s'\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|flags
operator||=
name|tflags
index|[
name|i
index|]
operator|.
name|f_flag
expr_stmt|;
block|}
return|return
operator|(
name|flags
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_CHFLAGS
end_ifdef

begin_function
specifier|static
name|char
modifier|*
name|flags2str
parameter_list|(
name|struct
name|flag
modifier|*
name|tflags
parameter_list|,
name|long
name|long
name|flags
parameter_list|)
block|{
specifier|static
name|char
name|sflags
index|[
literal|1024
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|sflags
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tflags
index|[
name|i
index|]
operator|.
name|f_str
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|flags
operator|&
name|tflags
index|[
name|i
index|]
operator|.
name|f_flag
condition|)
block|{
if|if
condition|(
name|sflags
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|strlcat
argument_list|(
name|sflags
argument_list|,
literal|","
argument_list|,
sizeof|sizeof
argument_list|(
name|sflags
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|sflags
argument_list|,
name|tflags
index|[
name|i
index|]
operator|.
name|f_str
argument_list|,
sizeof|sizeof
argument_list|(
name|sflags
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sflags
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strlcpy
argument_list|(
name|sflags
argument_list|,
literal|"none"
argument_list|,
sizeof|sizeof
argument_list|(
name|sflags
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sflags
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|str2name
parameter_list|(
name|struct
name|name
modifier|*
name|names
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|names
index|[
name|i
index|]
operator|.
name|n_str
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|names
index|[
name|i
index|]
operator|.
name|n_str
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|names
index|[
name|i
index|]
operator|.
name|n_name
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|syscall_desc
modifier|*
name|find_syscall
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|syscalls
index|[
name|i
index|]
operator|.
name|sd_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|syscalls
index|[
name|i
index|]
operator|.
name|sd_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|&
name|syscalls
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_stat
parameter_list|(
name|struct
name|stat64
modifier|*
name|sp
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|what
argument_list|,
literal|"mode"
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"0%o"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|sp
operator|->
name|st_mode
operator|&
name|ALLPERMS
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|what
argument_list|,
literal|"inode"
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%lld"
argument_list|,
operator|(
name|long
name|long
operator|)
name|sp
operator|->
name|st_ino
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|what
argument_list|,
literal|"nlink"
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%lld"
argument_list|,
operator|(
name|long
name|long
operator|)
name|sp
operator|->
name|st_nlink
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|what
argument_list|,
literal|"uid"
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|sp
operator|->
name|st_uid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|what
argument_list|,
literal|"gid"
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|sp
operator|->
name|st_gid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|what
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%lld"
argument_list|,
operator|(
name|long
name|long
operator|)
name|sp
operator|->
name|st_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|what
argument_list|,
literal|"blocks"
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%lld"
argument_list|,
operator|(
name|long
name|long
operator|)
name|sp
operator|->
name|st_blocks
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|what
argument_list|,
literal|"atime"
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%lld"
argument_list|,
operator|(
name|long
name|long
operator|)
name|sp
operator|->
name|st_atime
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|what
argument_list|,
literal|"mtime"
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%lld"
argument_list|,
operator|(
name|long
name|long
operator|)
name|sp
operator|->
name|st_mtime
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|what
argument_list|,
literal|"ctime"
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%lld"
argument_list|,
operator|(
name|long
name|long
operator|)
name|sp
operator|->
name|st_ctime
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_CHFLAGS
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|what
argument_list|,
literal|"flags"
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|flags2str
argument_list|(
name|chflags_flags
argument_list|,
operator|(
name|long
name|long
operator|)
name|sp
operator|->
name|st_flags
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|what
argument_list|,
literal|"type"
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|sp
operator|->
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFIFO
case|:
name|printf
argument_list|(
literal|"fifo"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFCHR
case|:
name|printf
argument_list|(
literal|"char"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFDIR
case|:
name|printf
argument_list|(
literal|"dir"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|printf
argument_list|(
literal|"block"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFREG
case|:
name|printf
argument_list|(
literal|"regular"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFLNK
case|:
name|printf
argument_list|(
literal|"symlink"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFSOCK
case|:
name|printf
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|show_stats
parameter_list|(
name|struct
name|stat64
modifier|*
name|sp
parameter_list|,
name|char
modifier|*
name|what
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
literal|""
decl_stmt|;
name|char
modifier|*
name|w
decl_stmt|;
for|for
control|(
name|w
operator|=
name|strtok
argument_list|(
name|what
argument_list|,
literal|","
argument_list|)
init|;
name|w
operator|!=
name|NULL
condition|;
name|w
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
control|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|show_stat
argument_list|(
name|sp
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|s
operator|=
literal|","
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|call_syscall
parameter_list|(
name|struct
name|syscall_desc
modifier|*
name|scall
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|stat64
name|sb
decl_stmt|;
name|long
name|long
name|flags
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|int
name|name
decl_stmt|,
name|rval
decl_stmt|;
union|union
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|long
name|long
name|num
decl_stmt|;
block|}
name|args
index|[
name|MAX_ARGS
index|]
union|;
comment|/* 	 * Verify correctness of the arguments. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|scall
operator|->
name|sd_args
index|[
name|i
index|]
operator|==
name|TYPE_NONE
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|":"
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many arguments [%s]\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|":"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|scall
operator|->
name|sd_args
index|[
name|i
index|]
operator|&
name|TYPE_OPTIONAL
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too few arguments\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scall
operator|->
name|sd_args
index|[
name|i
index|]
operator|&
name|TYPE_STRING
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"NULL"
argument_list|)
operator|==
literal|0
condition|)
name|args
index|[
name|i
index|]
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"DEADCODE"
argument_list|)
operator|==
literal|0
condition|)
name|args
index|[
name|i
index|]
operator|.
name|str
operator|=
operator|(
name|void
operator|*
operator|)
literal|0xdeadc0de
expr_stmt|;
else|else
name|args
index|[
name|i
index|]
operator|.
name|str
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scall
operator|->
name|sd_args
index|[
name|i
index|]
operator|&
name|TYPE_NUMBER
condition|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|num
operator|=
name|strtoll
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|endp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|endp
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid argument %u, number expected [%s]\n"
argument_list|,
name|i
argument_list|,
name|endp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Call the given syscall. 	 */
define|#
directive|define
name|NUM
parameter_list|(
name|n
parameter_list|)
value|(args[(n)].num)
define|#
directive|define
name|STR
parameter_list|(
name|n
parameter_list|)
value|(args[(n)].str)
switch|switch
condition|(
name|scall
operator|->
name|sd_action
condition|)
block|{
case|case
name|ACTION_OPEN
case|:
name|flags
operator|=
name|str2flags
argument_list|(
name|open_flags
argument_list|,
name|STR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|O_CREAT
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too few arguments\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
name|open
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|flags
argument_list|,
operator|(
name|mode_t
operator|)
name|NUM
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|==
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many arguments\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
name|open
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|flags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACTION_CREATE
case|:
name|rval
operator|=
name|open
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
operator|(
name|mode_t
operator|)
name|NUM
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|rval
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_UNLINK
case|:
name|rval
operator|=
name|unlink
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_MKDIR
case|:
name|rval
operator|=
name|mkdir
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|mode_t
operator|)
name|NUM
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_RMDIR
case|:
name|rval
operator|=
name|rmdir
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_LINK
case|:
name|rval
operator|=
name|link
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_SYMLINK
case|:
name|rval
operator|=
name|symlink
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_RENAME
case|:
name|rval
operator|=
name|rename
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|STR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_MKFIFO
case|:
name|rval
operator|=
name|mkfifo
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|mode_t
operator|)
name|NUM
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_CHMOD
case|:
name|rval
operator|=
name|chmod
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|mode_t
operator|)
name|NUM
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAS_LCHMOD
case|case
name|ACTION_LCHMOD
case|:
name|rval
operator|=
name|lchmod
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|mode_t
operator|)
name|NUM
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|ACTION_CHOWN
case|:
name|rval
operator|=
name|chown
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|uid_t
operator|)
name|NUM
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|(
name|gid_t
operator|)
name|NUM
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_LCHOWN
case|:
name|rval
operator|=
name|lchown
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|uid_t
operator|)
name|NUM
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|(
name|gid_t
operator|)
name|NUM
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAS_CHFLAGS
case|case
name|ACTION_CHFLAGS
case|:
name|rval
operator|=
name|chflags
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|str2flags
argument_list|(
name|chflags_flags
argument_list|,
name|STR
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_LCHFLAGS
case|case
name|ACTION_LCHFLAGS
case|:
name|rval
operator|=
name|lchflags
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|str2flags
argument_list|(
name|chflags_flags
argument_list|,
name|STR
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|ACTION_TRUNCATE
case|:
name|rval
operator|=
name|truncate64
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|NUM
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_STAT
case|:
name|rval
operator|=
name|stat64
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
block|{
name|show_stats
argument_list|(
operator|&
name|sb
argument_list|,
name|STR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
break|break;
case|case
name|ACTION_LSTAT
case|:
name|rval
operator|=
name|lstat64
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
block|{
name|show_stats
argument_list|(
operator|&
name|sb
argument_list|,
name|STR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
break|break;
case|case
name|ACTION_PATHCONF
case|:
block|{
name|long
name|lrval
decl_stmt|;
name|name
operator|=
name|str2name
argument_list|(
name|pathconf_names
argument_list|,
name|STR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown name %s"
argument_list|,
name|STR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|lrval
operator|=
name|pathconf
argument_list|(
name|STR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lrval
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"unlimited\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|lrval
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%ld\n"
argument_list|,
name|lrval
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unsupported syscall\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|STR
undef|#
directive|undef
name|NUM
if|if
condition|(
name|rval
operator|<
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|serrno
decl_stmt|;
name|serrno
operator|=
name|err2str
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s returned %d\n"
argument_list|,
name|scall
operator|->
name|sd_name
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|serrno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_gids
parameter_list|(
name|char
modifier|*
name|gids
parameter_list|)
block|{
name|gid_t
modifier|*
name|gidset
decl_stmt|;
name|long
name|ngroups
decl_stmt|;
name|char
modifier|*
name|g
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|ngroups
operator|=
name|sysconf
argument_list|(
name|_SC_NGROUPS_MAX
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ngroups
operator|>
literal|0
argument_list|)
expr_stmt|;
name|gidset
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|gidset
argument_list|)
operator|*
name|ngroups
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|gidset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|g
operator|=
name|strtok
argument_list|(
name|gids
argument_list|,
literal|","
argument_list|)
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|ngroups
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many gids\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|gidset
index|[
name|i
index|]
operator|=
name|strtol
argument_list|(
name|g
argument_list|,
operator|&
name|endp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|endp
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid gid '%s' - number expected\n"
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|setgroups
argument_list|(
name|i
argument_list|,
name|gidset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot change groups: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setegid
argument_list|(
name|gidset
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot change effective gid: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|gidset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|syscall_desc
modifier|*
name|scall
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|gids
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|int
name|uid
decl_stmt|,
name|umsk
decl_stmt|,
name|ch
decl_stmt|;
name|uid
operator|=
operator|-
literal|1
expr_stmt|;
name|gids
operator|=
name|NULL
expr_stmt|;
name|umsk
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"g:u:U:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'g'
case|:
name|gids
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|uid
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|endp
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid uid '%s' - number "
literal|"expected\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'U'
case|:
name|umsk
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|endp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|endp
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid umask '%s' - number "
literal|"expected\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too few arguments\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|gids
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"changing groups to %s\n"
argument_list|,
name|gids
argument_list|)
expr_stmt|;
name|set_gids
argument_list|(
name|gids
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uid
operator|!=
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"changing uid to %d\n"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|uid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot change uid: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Change umask to requested value or to 0, if not requested. */
name|umask
argument_list|(
name|umsk
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|scall
operator|=
name|find_syscall
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scall
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"syscall '%s' not supported\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|++
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|n
operator|=
name|call_syscall
argument_list|(
name|scall
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|+=
name|n
expr_stmt|;
name|argv
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
break|break;
name|argc
operator|++
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|err2str
parameter_list|(
name|int
name|error
parameter_list|)
block|{
specifier|static
name|char
name|errnum
index|[
literal|8
index|]
decl_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|EPERM
case|case
name|EPERM
case|:
return|return
operator|(
literal|"EPERM"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOENT
case|case
name|ENOENT
case|:
return|return
operator|(
literal|"ENOENT"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ESRCH
case|case
name|ESRCH
case|:
return|return
operator|(
literal|"ESRCH"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EINTR
case|case
name|EINTR
case|:
return|return
operator|(
literal|"EINTR"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EIO
case|case
name|EIO
case|:
return|return
operator|(
literal|"EIO"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENXIO
case|case
name|ENXIO
case|:
return|return
operator|(
literal|"ENXIO"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|E2BIG
case|case
name|E2BIG
case|:
return|return
operator|(
literal|"E2BIG"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOEXEC
case|case
name|ENOEXEC
case|:
return|return
operator|(
literal|"ENOEXEC"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EBADF
case|case
name|EBADF
case|:
return|return
operator|(
literal|"EBADF"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ECHILD
case|case
name|ECHILD
case|:
return|return
operator|(
literal|"ECHILD"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EDEADLK
case|case
name|EDEADLK
case|:
return|return
operator|(
literal|"EDEADLK"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOMEM
case|case
name|ENOMEM
case|:
return|return
operator|(
literal|"ENOMEM"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EACCES
case|case
name|EACCES
case|:
return|return
operator|(
literal|"EACCES"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EFAULT
case|case
name|EFAULT
case|:
return|return
operator|(
literal|"EFAULT"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOTBLK
case|case
name|ENOTBLK
case|:
return|return
operator|(
literal|"ENOTBLK"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EBUSY
case|case
name|EBUSY
case|:
return|return
operator|(
literal|"EBUSY"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EEXIST
case|case
name|EEXIST
case|:
return|return
operator|(
literal|"EEXIST"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXDEV
case|case
name|EXDEV
case|:
return|return
operator|(
literal|"EXDEV"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENODEV
case|case
name|ENODEV
case|:
return|return
operator|(
literal|"ENODEV"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOTDIR
case|case
name|ENOTDIR
case|:
return|return
operator|(
literal|"ENOTDIR"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EISDIR
case|case
name|EISDIR
case|:
return|return
operator|(
literal|"EISDIR"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EINVAL
case|case
name|EINVAL
case|:
return|return
operator|(
literal|"EINVAL"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENFILE
case|case
name|ENFILE
case|:
return|return
operator|(
literal|"ENFILE"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EMFILE
case|case
name|EMFILE
case|:
return|return
operator|(
literal|"EMFILE"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOTTY
case|case
name|ENOTTY
case|:
return|return
operator|(
literal|"ENOTTY"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ETXTBSY
case|case
name|ETXTBSY
case|:
return|return
operator|(
literal|"ETXTBSY"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EFBIG
case|case
name|EFBIG
case|:
return|return
operator|(
literal|"EFBIG"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOSPC
case|case
name|ENOSPC
case|:
return|return
operator|(
literal|"ENOSPC"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ESPIPE
case|case
name|ESPIPE
case|:
return|return
operator|(
literal|"ESPIPE"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EROFS
case|case
name|EROFS
case|:
return|return
operator|(
literal|"EROFS"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EMLINK
case|case
name|EMLINK
case|:
return|return
operator|(
literal|"EMLINK"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EPIPE
case|case
name|EPIPE
case|:
return|return
operator|(
literal|"EPIPE"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EDOM
case|case
name|EDOM
case|:
return|return
operator|(
literal|"EDOM"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ERANGE
case|case
name|ERANGE
case|:
return|return
operator|(
literal|"ERANGE"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAGAIN
case|case
name|EAGAIN
case|:
return|return
operator|(
literal|"EAGAIN"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EINPROGRESS
case|case
name|EINPROGRESS
case|:
return|return
operator|(
literal|"EINPROGRESS"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EALREADY
case|case
name|EALREADY
case|:
return|return
operator|(
literal|"EALREADY"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOTSOCK
case|case
name|ENOTSOCK
case|:
return|return
operator|(
literal|"ENOTSOCK"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EDESTADDRREQ
case|case
name|EDESTADDRREQ
case|:
return|return
operator|(
literal|"EDESTADDRREQ"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EMSGSIZE
case|case
name|EMSGSIZE
case|:
return|return
operator|(
literal|"EMSGSIZE"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EPROTOTYPE
case|case
name|EPROTOTYPE
case|:
return|return
operator|(
literal|"EPROTOTYPE"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOPROTOOPT
case|case
name|ENOPROTOOPT
case|:
return|return
operator|(
literal|"ENOPROTOOPT"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EPROTONOSUPPORT
case|case
name|EPROTONOSUPPORT
case|:
return|return
operator|(
literal|"EPROTONOSUPPORT"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ESOCKTNOSUPPORT
case|case
name|ESOCKTNOSUPPORT
case|:
return|return
operator|(
literal|"ESOCKTNOSUPPORT"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EOPNOTSUPP
case|case
name|EOPNOTSUPP
case|:
return|return
operator|(
literal|"EOPNOTSUPP"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EPFNOSUPPORT
case|case
name|EPFNOSUPPORT
case|:
return|return
operator|(
literal|"EPFNOSUPPORT"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAFNOSUPPORT
case|case
name|EAFNOSUPPORT
case|:
return|return
operator|(
literal|"EAFNOSUPPORT"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EADDRINUSE
case|case
name|EADDRINUSE
case|:
return|return
operator|(
literal|"EADDRINUSE"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EADDRNOTAVAIL
case|case
name|EADDRNOTAVAIL
case|:
return|return
operator|(
literal|"EADDRNOTAVAIL"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENETDOWN
case|case
name|ENETDOWN
case|:
return|return
operator|(
literal|"ENETDOWN"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENETUNREACH
case|case
name|ENETUNREACH
case|:
return|return
operator|(
literal|"ENETUNREACH"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENETRESET
case|case
name|ENETRESET
case|:
return|return
operator|(
literal|"ENETRESET"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ECONNABORTED
case|case
name|ECONNABORTED
case|:
return|return
operator|(
literal|"ECONNABORTED"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ECONNRESET
case|case
name|ECONNRESET
case|:
return|return
operator|(
literal|"ECONNRESET"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOBUFS
case|case
name|ENOBUFS
case|:
return|return
operator|(
literal|"ENOBUFS"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EISCONN
case|case
name|EISCONN
case|:
return|return
operator|(
literal|"EISCONN"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOTCONN
case|case
name|ENOTCONN
case|:
return|return
operator|(
literal|"ENOTCONN"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ESHUTDOWN
case|case
name|ESHUTDOWN
case|:
return|return
operator|(
literal|"ESHUTDOWN"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ETOOMANYREFS
case|case
name|ETOOMANYREFS
case|:
return|return
operator|(
literal|"ETOOMANYREFS"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ETIMEDOUT
case|case
name|ETIMEDOUT
case|:
return|return
operator|(
literal|"ETIMEDOUT"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ECONNREFUSED
case|case
name|ECONNREFUSED
case|:
return|return
operator|(
literal|"ECONNREFUSED"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ELOOP
case|case
name|ELOOP
case|:
return|return
operator|(
literal|"ELOOP"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENAMETOOLONG
case|case
name|ENAMETOOLONG
case|:
return|return
operator|(
literal|"ENAMETOOLONG"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EHOSTDOWN
case|case
name|EHOSTDOWN
case|:
return|return
operator|(
literal|"EHOSTDOWN"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EHOSTUNREACH
case|case
name|EHOSTUNREACH
case|:
return|return
operator|(
literal|"EHOSTUNREACH"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOTEMPTY
case|case
name|ENOTEMPTY
case|:
return|return
operator|(
literal|"ENOTEMPTY"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EPROCLIM
case|case
name|EPROCLIM
case|:
return|return
operator|(
literal|"EPROCLIM"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EUSERS
case|case
name|EUSERS
case|:
return|return
operator|(
literal|"EUSERS"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EDQUOT
case|case
name|EDQUOT
case|:
return|return
operator|(
literal|"EDQUOT"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ESTALE
case|case
name|ESTALE
case|:
return|return
operator|(
literal|"ESTALE"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EREMOTE
case|case
name|EREMOTE
case|:
return|return
operator|(
literal|"EREMOTE"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EBADRPC
case|case
name|EBADRPC
case|:
return|return
operator|(
literal|"EBADRPC"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ERPCMISMATCH
case|case
name|ERPCMISMATCH
case|:
return|return
operator|(
literal|"ERPCMISMATCH"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EPROGUNAVAIL
case|case
name|EPROGUNAVAIL
case|:
return|return
operator|(
literal|"EPROGUNAVAIL"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EPROGMISMATCH
case|case
name|EPROGMISMATCH
case|:
return|return
operator|(
literal|"EPROGMISMATCH"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EPROCUNAVAIL
case|case
name|EPROCUNAVAIL
case|:
return|return
operator|(
literal|"EPROCUNAVAIL"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOLCK
case|case
name|ENOLCK
case|:
return|return
operator|(
literal|"ENOLCK"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOSYS
case|case
name|ENOSYS
case|:
return|return
operator|(
literal|"ENOSYS"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EFTYPE
case|case
name|EFTYPE
case|:
return|return
operator|(
literal|"EFTYPE"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EAUTH
case|case
name|EAUTH
case|:
return|return
operator|(
literal|"EAUTH"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENEEDAUTH
case|case
name|ENEEDAUTH
case|:
return|return
operator|(
literal|"ENEEDAUTH"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EIDRM
case|case
name|EIDRM
case|:
return|return
operator|(
literal|"EIDRM"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOMSG
case|case
name|ENOMSG
case|:
return|return
operator|(
literal|"ENOMSG"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EOVERFLOW
case|case
name|EOVERFLOW
case|:
return|return
operator|(
literal|"EOVERFLOW"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ECANCELED
case|case
name|ECANCELED
case|:
return|return
operator|(
literal|"ECANCELED"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EILSEQ
case|case
name|EILSEQ
case|:
return|return
operator|(
literal|"EILSEQ"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOATTR
case|case
name|ENOATTR
case|:
return|return
operator|(
literal|"ENOATTR"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EDOOFUS
case|case
name|EDOOFUS
case|:
return|return
operator|(
literal|"EDOOFUS"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EBADMSG
case|case
name|EBADMSG
case|:
return|return
operator|(
literal|"EBADMSG"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EMULTIHOP
case|case
name|EMULTIHOP
case|:
return|return
operator|(
literal|"EMULTIHOP"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENOLINK
case|case
name|ENOLINK
case|:
return|return
operator|(
literal|"ENOLINK"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EPROTO
case|case
name|EPROTO
case|:
return|return
operator|(
literal|"EPROTO"
operator|)
return|;
endif|#
directive|endif
default|default:
name|snprintf
argument_list|(
name|errnum
argument_list|,
sizeof|sizeof
argument_list|(
name|errnum
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnum
operator|)
return|;
block|}
block|}
end_function

end_unit

