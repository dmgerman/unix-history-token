begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dispatch/dispatch.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libproc.h>
end_include

begin_include
include|#
directive|include
file|<mach/mach.h>
end_include

begin_include
include|#
directive|include
file|<mach/task_info.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|// from System.framework/Versions/B/PrivateHeaders/sys/codesign.h
end_comment

begin_define
define|#
directive|define
name|CS_OPS_STATUS
value|0
end_define

begin_comment
comment|/* return status */
end_comment

begin_define
define|#
directive|define
name|CS_RESTRICT
value|0x0000800
end_define

begin_comment
comment|/* tell dyld to treat restricted */
end_comment

begin_function_decl
name|int
name|csops
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|unsigned
name|int
name|ops
parameter_list|,
name|void
modifier|*
name|useraddr
parameter_list|,
name|size_t
name|usersize
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Step through the process table, find a matching process name, return    the pid of that matched process.    If there are multiple processes with that name, issue a warning on stdout    and return the highest numbered process.    The proc_pidpath() call is used which gets the full process name including    directories to the executable and the full (longer than 16 character)    executable name. */
end_comment

begin_function
name|pid_t
name|get_pid_for_process_name
parameter_list|(
specifier|const
name|char
modifier|*
name|procname
parameter_list|)
block|{
name|int
name|process_count
init|=
name|proc_listpids
argument_list|(
name|PROC_ALL_PIDS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|process_count
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Only found %d processes running!\n"
argument_list|,
name|process_count
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Allocate a few extra slots in case new processes are spawned
name|int
name|all_pids_size
init|=
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
operator|*
operator|(
name|process_count
operator|+
literal|3
operator|)
decl_stmt|;
name|pid_t
modifier|*
name|all_pids
init|=
operator|(
name|pid_t
operator|*
operator|)
name|malloc
argument_list|(
name|all_pids_size
argument_list|)
decl_stmt|;
comment|// re-set process_count in case the number of processes changed (got smaller;
comment|// we won't do bigger)
name|process_count
operator|=
name|proc_listpids
argument_list|(
name|PROC_ALL_PIDS
argument_list|,
literal|0
argument_list|,
name|all_pids
argument_list|,
name|all_pids_size
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
expr_stmt|;
name|int
name|i
decl_stmt|;
name|pid_t
name|highest_pid
init|=
literal|0
decl_stmt|;
name|int
name|match_count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|process_count
condition|;
name|i
operator|++
control|)
block|{
name|char
name|pidpath
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|pidpath_len
init|=
name|proc_pidpath
argument_list|(
name|all_pids
index|[
name|i
index|]
argument_list|,
name|pidpath
argument_list|,
sizeof|sizeof
argument_list|(
name|pidpath
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pidpath_len
operator|==
literal|0
condition|)
continue|continue;
name|char
modifier|*
name|j
init|=
name|strrchr
argument_list|(
name|pidpath
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|j
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|procname
argument_list|,
name|pidpath
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|j
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|procname
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|match_count
operator|++
expr_stmt|;
if|if
condition|(
name|all_pids
index|[
name|i
index|]
operator|>
name|highest_pid
condition|)
name|highest_pid
operator|=
name|all_pids
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|all_pids
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_count
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Did not find process '%s'.\n"
argument_list|,
name|procname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|match_count
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Warning:  More than one process '%s'!\n"
argument_list|,
name|procname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"          defaulting to the highest-pid one, %d\n"
argument_list|,
name|highest_pid
argument_list|)
expr_stmt|;
block|}
return|return
name|highest_pid
return|;
block|}
end_function

begin_comment
comment|/* Given a pid, get the full executable name (including directory    paths and the longer-than-16-chars executable name) and return    the basename of that (i.e. do not include the directory components).    This function mallocs the memory for the string it returns;    the caller must free this memory. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_process_name_for_pid
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
name|char
name|tmp_name
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
name|proc_pidpath
argument_list|(
name|pid
argument_list|,
name|tmp_name
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Could not find process with pid of %d\n"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strrchr
argument_list|(
name|tmp_name
argument_list|,
literal|'/'
argument_list|)
condition|)
return|return
name|strdup
argument_list|(
name|strrchr
argument_list|(
name|tmp_name
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
return|;
else|else
return|return
name|strdup
argument_list|(
name|tmp_name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get a struct kinfo_proc structure for a given pid.    Process name is required for error printing.    Gives you the current state of the process and whether it is being debugged    by anyone.    memory is malloc()'ed for the returned struct kinfo_proc    and must be freed by the caller.  */
end_comment

begin_function
name|struct
name|kinfo_proc
modifier|*
name|get_kinfo_proc_for_pid
parameter_list|(
name|pid_t
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
name|process_name
parameter_list|)
block|{
name|struct
name|kinfo_proc
modifier|*
name|kinfo
init|=
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|mib
index|[]
init|=
block|{
name|CTL_KERN
block|,
name|KERN_PROC
block|,
name|KERN_PROC_PID
block|,
name|pid
block|}
decl_stmt|;
name|size_t
name|len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
argument_list|)
decl_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
sizeof|sizeof
argument_list|(
name|mib
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mib
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|kinfo
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|kinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Could not get kinfo_proc for pid %d\n"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|kinfo
return|;
block|}
end_function

begin_comment
comment|/* Get the basic information (thread_basic_info_t) about a given    thread.    Gives you the suspend count; thread state; user time; system time; sleep    time; etc.    The return value is a pointer to malloc'ed memory - it is the caller's    responsibility to free it.  */
end_comment

begin_function
name|thread_basic_info_t
name|get_thread_basic_info
parameter_list|(
name|thread_t
name|thread
parameter_list|)
block|{
name|kern_return_t
name|kr
decl_stmt|;
name|integer_t
modifier|*
name|thinfo
init|=
operator|(
name|integer_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|integer_t
argument_list|)
operator|*
name|THREAD_INFO_MAX
argument_list|)
decl_stmt|;
name|mach_msg_type_number_t
name|thread_info_count
init|=
name|THREAD_INFO_MAX
decl_stmt|;
name|kr
operator|=
name|thread_info
argument_list|(
name|thread
argument_list|,
name|THREAD_BASIC_INFO
argument_list|,
operator|(
name|thread_info_t
operator|)
name|thinfo
argument_list|,
operator|&
name|thread_info_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Error - unable to get basic thread info for a thread\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|thread_basic_info_t
operator|)
name|thinfo
return|;
block|}
end_function

begin_comment
comment|/* Get the thread identifier info (thread_identifier_info_data_t)    about a given thread.    Gives you the system-wide unique thread number; the pthread identifier number */
end_comment

begin_function
name|thread_identifier_info_data_t
name|get_thread_identifier_info
parameter_list|(
name|thread_t
name|thread
parameter_list|)
block|{
name|kern_return_t
name|kr
decl_stmt|;
name|thread_identifier_info_data_t
name|tident
decl_stmt|;
name|mach_msg_type_number_t
name|tident_count
init|=
name|THREAD_IDENTIFIER_INFO_COUNT
decl_stmt|;
name|kr
operator|=
name|thread_info
argument_list|(
name|thread
argument_list|,
name|THREAD_IDENTIFIER_INFO
argument_list|,
operator|(
name|thread_info_t
operator|)
operator|&
name|tident
argument_list|,
operator|&
name|tident_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Error - unable to get thread ident for a thread\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|tident
return|;
block|}
end_function

begin_comment
comment|/* Given a mach port # (in the examine-threads mach port namespace) for a    thread,    find the mach port # in the inferior program's port namespace.    Sets inferior_port if successful.    Returns true if successful, false if unable to find the port number.  */
end_comment

begin_function
name|bool
name|inferior_namespace_mach_port_num
parameter_list|(
name|task_t
name|task
parameter_list|,
name|thread_t
name|examine_threads_port
parameter_list|,
name|thread_t
modifier|*
name|inferior_port
parameter_list|)
block|{
name|kern_return_t
name|retval
decl_stmt|;
name|mach_port_name_array_t
name|names
decl_stmt|;
name|mach_msg_type_number_t
name|nameslen
decl_stmt|;
name|mach_port_type_array_t
name|types
decl_stmt|;
name|mach_msg_type_number_t
name|typeslen
decl_stmt|;
if|if
condition|(
name|inferior_port
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|retval
operator|=
name|mach_port_names
argument_list|(
name|task
argument_list|,
operator|&
name|names
argument_list|,
operator|&
name|nameslen
argument_list|,
operator|&
name|types
argument_list|,
operator|&
name|typeslen
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Error - unable to get mach port names for inferior.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nameslen
condition|;
name|i
operator|++
control|)
block|{
name|mach_port_t
name|local_name
decl_stmt|;
name|mach_msg_type_name_t
name|local_type
decl_stmt|;
name|retval
operator|=
name|mach_port_extract_right
argument_list|(
name|task
argument_list|,
name|names
index|[
name|i
index|]
argument_list|,
name|MACH_MSG_TYPE_COPY_SEND
argument_list|,
operator|&
name|local_name
argument_list|,
operator|&
name|local_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|mach_port_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|local_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_name
operator|==
name|examine_threads_port
condition|)
block|{
operator|*
name|inferior_port
operator|=
name|names
index|[
name|i
index|]
expr_stmt|;
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|names
argument_list|,
name|nameslen
operator|*
sizeof|sizeof
argument_list|(
name|mach_port_t
argument_list|)
argument_list|)
expr_stmt|;
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|types
argument_list|,
name|typeslen
operator|*
sizeof|sizeof
argument_list|(
name|mach_port_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
block|}
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|names
argument_list|,
name|nameslen
operator|*
sizeof|sizeof
argument_list|(
name|mach_port_t
argument_list|)
argument_list|)
expr_stmt|;
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|types
argument_list|,
name|typeslen
operator|*
sizeof|sizeof
argument_list|(
name|mach_port_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Get the current pc value for a given thread.  */
end_comment

begin_function
name|uint64_t
name|get_current_pc
parameter_list|(
name|thread_t
name|thread
parameter_list|,
name|int
modifier|*
name|wordsize
parameter_list|)
block|{
name|kern_return_t
name|kr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
name|x86_thread_state_t
name|gp_regs
decl_stmt|;
name|mach_msg_type_number_t
name|gp_count
init|=
name|x86_THREAD_STATE_COUNT
decl_stmt|;
name|kr
operator|=
name|thread_get_state
argument_list|(
name|thread
argument_list|,
name|x86_THREAD_STATE
argument_list|,
operator|(
name|thread_state_t
operator|)
operator|&
name|gp_regs
argument_list|,
operator|&
name|gp_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Error - unable to get registers for a thread\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gp_regs
operator|.
name|tsh
operator|.
name|flavor
operator|==
name|x86_THREAD_STATE64
condition|)
block|{
operator|*
name|wordsize
operator|=
literal|8
expr_stmt|;
return|return
name|gp_regs
operator|.
name|uts
operator|.
name|ts64
operator|.
name|__rip
return|;
block|}
else|else
block|{
operator|*
name|wordsize
operator|=
literal|4
expr_stmt|;
return|return
name|gp_regs
operator|.
name|uts
operator|.
name|ts32
operator|.
name|__eip
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
name|arm_thread_state_t
name|gp_regs
decl_stmt|;
name|mach_msg_type_number_t
name|gp_count
init|=
name|ARM_THREAD_STATE_COUNT
decl_stmt|;
name|kr
operator|=
name|thread_get_state
argument_list|(
name|thread
argument_list|,
name|ARM_THREAD_STATE
argument_list|,
operator|(
name|thread_state_t
operator|)
operator|&
name|gp_regs
argument_list|,
operator|&
name|gp_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Error - unable to get registers for a thread\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|wordsize
operator|=
literal|4
expr_stmt|;
return|return
name|gp_regs
operator|.
name|__pc
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__arm64__
argument_list|)
name|arm_thread_state64_t
name|gp_regs
decl_stmt|;
name|mach_msg_type_number_t
name|gp_count
init|=
name|ARM_THREAD_STATE64_COUNT
decl_stmt|;
name|kr
operator|=
name|thread_get_state
argument_list|(
name|thread
argument_list|,
name|ARM_THREAD_STATE64
argument_list|,
operator|(
name|thread_state_t
operator|)
operator|&
name|gp_regs
argument_list|,
operator|&
name|gp_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Error - unable to get registers for a thread\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|wordsize
operator|=
literal|8
expr_stmt|;
return|return
name|gp_regs
operator|.
name|__pc
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Get the proc_threadinfo for a given thread.    Gives you the thread name, if set; current and max priorities.    Returns 1 if successful    Returns 0 if proc_pidinfo() failed */
end_comment

begin_function
name|int
name|get_proc_threadinfo
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|uint64_t
name|thread_handle
parameter_list|,
name|struct
name|proc_threadinfo
modifier|*
name|pth
parameter_list|)
block|{
name|pth
operator|->
name|pth_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|int
name|ret
init|=
name|proc_pidinfo
argument_list|(
name|pid
argument_list|,
name|PROC_PIDTHREADINFO
argument_list|,
name|thread_handle
argument_list|,
name|pth
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc_threadinfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|kern_return_t
name|kr
decl_stmt|;
name|task_t
name|task
decl_stmt|;
name|pid_t
name|pid
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|procname
init|=
name|NULL
decl_stmt|;
name|int
name|arg_is_procname
init|=
literal|0
decl_stmt|;
name|int
name|do_loop
init|=
literal|0
decl_stmt|;
name|int
name|verbose
init|=
literal|0
decl_stmt|;
name|int
name|resume_when_done
init|=
literal|0
decl_stmt|;
name|mach_port_t
name|mytask
init|=
name|mach_task_self
argument_list|()
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
operator|&&
name|argc
operator|!=
literal|3
operator|&&
name|argc
operator|!=
literal|4
operator|&&
name|argc
operator|!=
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: tdump [-l] [-v] [-r] pid/procname\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|3
operator|||
name|argc
operator|==
literal|4
condition|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-l"
argument_list|)
operator|==
literal|0
condition|)
name|do_loop
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-v"
argument_list|)
operator|==
literal|0
condition|)
name|verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-r"
argument_list|)
operator|==
literal|0
condition|)
name|resume_when_done
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|char
modifier|*
name|c
init|=
name|argv
index|[
name|argc
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|c
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: tdump [-l] [-v] pid/procname\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|c
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|c
argument_list|)
condition|)
block|{
name|arg_is_procname
operator|=
literal|1
expr_stmt|;
name|procname
operator|=
name|argv
index|[
name|argc
operator|-
literal|1
index|]
expr_stmt|;
break|break;
block|}
name|c
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|arg_is_procname
operator|&&
name|procname
condition|)
block|{
name|pid
operator|=
name|get_pid_for_process_name
argument_list|(
name|procname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|pid
operator|=
operator|(
name|pid_t
operator|)
name|strtol
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: tdump [-l] [-v] pid/procname\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
specifier|const
name|char
modifier|*
name|process_name
init|=
name|get_process_name_for_pid
argument_list|(
name|pid
argument_list|)
decl_stmt|;
comment|// At this point "pid" is the process id and "process_name" is the process
comment|// name
comment|// Now we have to get the process list from the kernel (which only has the
comment|// truncated
comment|// 16 char names)
name|struct
name|kinfo_proc
modifier|*
name|kinfo
init|=
name|get_kinfo_proc_for_pid
argument_list|(
name|pid
argument_list|,
name|process_name
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"pid %d (%s) is currently "
argument_list|,
name|pid
argument_list|,
name|process_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kinfo
operator|->
name|kp_proc
operator|.
name|p_stat
condition|)
block|{
case|case
name|SIDL
case|:
name|printf
argument_list|(
literal|"being created by fork"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SRUN
case|:
name|printf
argument_list|(
literal|"runnable"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSLEEP
case|:
name|printf
argument_list|(
literal|"sleeping on an address"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSTOP
case|:
name|printf
argument_list|(
literal|"suspended"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SZOMB
case|:
name|printf
argument_list|(
literal|"zombie state - awaiting collection by parent"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kinfo
operator|->
name|kp_proc
operator|.
name|p_flag
operator|&
name|P_TRACED
condition|)
name|printf
argument_list|(
literal|" and is being debugged."
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|kinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|int
name|csops_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|csops
argument_list|(
name|pid
argument_list|,
name|CS_OPS_STATUS
argument_list|,
operator|&
name|csops_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|csops_flags
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|csops_flags
operator|&
name|CS_RESTRICT
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pid %d (%s) is restricted so nothing can attach to it.\n"
argument_list|,
name|pid
argument_list|,
name|process_name
argument_list|)
expr_stmt|;
block|}
name|kr
operator|=
name|task_for_pid
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|pid
argument_list|,
operator|&
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Error - unable to task_for_pid()\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|struct
name|task_basic_info
name|info
decl_stmt|;
name|unsigned
name|int
name|info_count
init|=
name|TASK_BASIC_INFO_COUNT
decl_stmt|;
name|kr
operator|=
name|task_info
argument_list|(
name|task
argument_list|,
name|TASK_BASIC_INFO
argument_list|,
operator|(
name|task_info_t
operator|)
operator|&
name|info
argument_list|,
operator|&
name|info_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Error - unable to call task_info.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Task suspend count: %d.\n"
argument_list|,
name|info
operator|.
name|suspend_count
argument_list|)
expr_stmt|;
name|struct
name|timespec
modifier|*
name|rqtp
init|=
operator|(
expr|struct
name|timespec
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timespec
argument_list|)
argument_list|)
decl_stmt|;
name|rqtp
operator|->
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|rqtp
operator|->
name|tv_nsec
operator|=
literal|150000000
expr_stmt|;
name|int
name|loop_cnt
init|=
literal|1
decl_stmt|;
do|do
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|do_loop
condition|)
name|printf
argument_list|(
literal|"Iteration %d:\n"
argument_list|,
name|loop_cnt
operator|++
argument_list|)
expr_stmt|;
name|thread_array_t
name|thread_list
decl_stmt|;
name|mach_msg_type_number_t
name|thread_count
decl_stmt|;
name|kr
operator|=
name|task_threads
argument_list|(
name|task
argument_list|,
operator|&
name|thread_list
argument_list|,
operator|&
name|thread_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Error - unable to get thread list\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"pid %d has %d threads\n"
argument_list|,
name|pid
argument_list|,
name|thread_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|thread_count
condition|;
name|i
operator|++
control|)
block|{
name|thread_basic_info_t
name|basic_info
init|=
name|get_thread_basic_info
argument_list|(
name|thread_list
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|thread_identifier_info_data_t
name|identifier_info
init|=
name|get_thread_identifier_info
argument_list|(
name|thread_list
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|wordsize
decl_stmt|;
name|uint64_t
name|pc
init|=
name|get_current_pc
argument_list|(
name|thread_list
index|[
name|i
index|]
argument_list|,
operator|&
name|wordsize
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"thread #%d, system-wide-unique-tid %lld, suspend count is %d, "
argument_list|,
name|i
argument_list|,
name|identifier_info
operator|.
name|thread_id
argument_list|,
name|basic_info
operator|->
name|suspend_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordsize
operator|==
literal|8
condition|)
name|printf
argument_list|(
literal|"pc 0x%016llx, "
argument_list|,
name|pc
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"pc 0x%08llx, "
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"run state is "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|basic_info
operator|->
name|run_state
condition|)
block|{
case|case
name|TH_STATE_RUNNING
case|:
name|puts
argument_list|(
literal|"running"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TH_STATE_STOPPED
case|:
name|puts
argument_list|(
literal|"stopped"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TH_STATE_WAITING
case|:
name|puts
argument_list|(
literal|"waiting"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TH_STATE_UNINTERRUPTIBLE
case|:
name|puts
argument_list|(
literal|"uninterruptible"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TH_STATE_HALTED
case|:
name|puts
argument_list|(
literal|"halted"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"           pthread handle id 0x%llx (not the same value as "
literal|"pthread_self() returns)\n"
argument_list|,
operator|(
name|uint64_t
operator|)
name|identifier_info
operator|.
name|thread_handle
argument_list|)
expr_stmt|;
name|struct
name|proc_threadinfo
name|pth
decl_stmt|;
name|int
name|proc_threadinfo_succeeded
init|=
name|get_proc_threadinfo
argument_list|(
name|pid
argument_list|,
name|identifier_info
operator|.
name|thread_handle
argument_list|,
operator|&
name|pth
argument_list|)
decl_stmt|;
if|if
condition|(
name|proc_threadinfo_succeeded
operator|&&
name|pth
operator|.
name|pth_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"           thread name '%s'\n"
argument_list|,
name|pth
operator|.
name|pth_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"           libdispatch qaddr 0x%llx (not the same as the "
literal|"dispatch_queue_t token)\n"
argument_list|,
operator|(
name|uint64_t
operator|)
name|identifier_info
operator|.
name|dispatch_qaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"           (examine-threads port namespace) mach port # 0x%4.4x\n"
argument_list|,
operator|(
name|int
operator|)
name|thread_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|thread_t
name|mach_port_inferior_namespace
decl_stmt|;
if|if
condition|(
name|inferior_namespace_mach_port_num
argument_list|(
name|task
argument_list|,
name|thread_list
index|[
name|i
index|]
argument_list|,
operator|&
name|mach_port_inferior_namespace
argument_list|)
condition|)
name|printf
argument_list|(
literal|"           (inferior port namepsace) mach port # 0x%4.4x\n"
argument_list|,
operator|(
name|int
operator|)
name|mach_port_inferior_namespace
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"           user %d.%06ds, system %d.%06ds"
argument_list|,
name|basic_info
operator|->
name|user_time
operator|.
name|seconds
argument_list|,
name|basic_info
operator|->
name|user_time
operator|.
name|microseconds
argument_list|,
name|basic_info
operator|->
name|system_time
operator|.
name|seconds
argument_list|,
name|basic_info
operator|->
name|system_time
operator|.
name|microseconds
argument_list|)
expr_stmt|;
if|if
condition|(
name|basic_info
operator|->
name|cpu_usage
operator|>
literal|0
condition|)
block|{
name|float
name|cpu_percentage
init|=
name|basic_info
operator|->
name|cpu_usage
operator|/
literal|10.0
decl_stmt|;
name|printf
argument_list|(
literal|", using %.1f%% cpu currently"
argument_list|,
name|cpu_percentage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basic_info
operator|->
name|sleep_time
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|", this thread has slept for %d seconds"
argument_list|,
name|basic_info
operator|->
name|sleep_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n           "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"scheduling policy %d"
argument_list|,
name|basic_info
operator|->
name|policy
argument_list|)
expr_stmt|;
if|if
condition|(
name|basic_info
operator|->
name|flags
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|", flags %d"
argument_list|,
name|basic_info
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|basic_info
operator|->
name|flags
operator||
name|TH_FLAGS_SWAPPED
operator|)
operator|==
name|TH_FLAGS_SWAPPED
condition|)
name|printf
argument_list|(
literal|" (thread is swapped out)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|basic_info
operator|->
name|flags
operator||
name|TH_FLAGS_IDLE
operator|)
operator|==
name|TH_FLAGS_IDLE
condition|)
name|printf
argument_list|(
literal|" (thread is idle)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proc_threadinfo_succeeded
condition|)
name|printf
argument_list|(
literal|", current pri %d, max pri %d"
argument_list|,
name|pth
operator|.
name|pth_curpri
argument_list|,
name|pth
operator|.
name|pth_maxpriority
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|basic_info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_loop
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|vm_deallocate
argument_list|(
name|mytask
argument_list|,
operator|(
name|vm_address_t
operator|)
name|thread_list
argument_list|,
name|thread_count
operator|*
sizeof|sizeof
argument_list|(
name|thread_act_t
argument_list|)
argument_list|)
expr_stmt|;
name|nanosleep
argument_list|(
name|rqtp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|do_loop
condition|)
do|;
while|while
condition|(
name|resume_when_done
operator|>
literal|0
condition|)
block|{
name|kern_return_t
name|err
init|=
name|task_resume
argument_list|(
name|task
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|KERN_SUCCESS
condition|)
name|printf
argument_list|(
literal|"Error resuming task: %d."
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|resume_when_done
operator|--
expr_stmt|;
block|}
name|vm_deallocate
argument_list|(
name|mytask
argument_list|,
operator|(
name|vm_address_t
operator|)
name|task
argument_list|,
sizeof|sizeof
argument_list|(
name|task_t
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|process_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

