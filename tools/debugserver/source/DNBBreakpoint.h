begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- DNBBreakpoint.h -----------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Created by Greg Clayton on 6/29/07.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__DNBBreakpoint_h__
end_ifndef

begin_define
define|#
directive|define
name|__DNBBreakpoint_h__
end_define

begin_include
include|#
directive|include
file|<mach/mach.h>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|"DNBDefs.h"
end_include

begin_decl_stmt
name|class
name|MachProcess
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|DNBBreakpoint
block|{
name|public
label|:
name|DNBBreakpoint
argument_list|(
argument|nub_addr_t m_addr
argument_list|,
argument|nub_size_t byte_size
argument_list|,
argument|bool hardware
argument_list|)
empty_stmt|;
operator|~
name|DNBBreakpoint
argument_list|()
expr_stmt|;
name|nub_size_t
name|ByteSize
argument_list|()
specifier|const
block|{
return|return
name|m_byte_size
return|;
block|}
name|uint8_t
modifier|*
name|SavedOpcodeBytes
parameter_list|()
block|{
return|return
operator|&
name|m_opcode
index|[
literal|0
index|]
return|;
block|}
specifier|const
name|uint8_t
operator|*
name|SavedOpcodeBytes
argument_list|()
specifier|const
block|{
return|return
operator|&
name|m_opcode
index|[
literal|0
index|]
return|;
block|}
name|nub_addr_t
name|Address
argument_list|()
specifier|const
block|{
return|return
name|m_addr
return|;
block|}
comment|//    nub_thread_t ThreadID() const { return m_tid; }
name|bool
name|IsEnabled
argument_list|()
specifier|const
block|{
return|return
name|m_enabled
return|;
block|}
name|bool
name|IntersectsRange
argument_list|(
name|nub_addr_t
name|addr
argument_list|,
name|nub_size_t
name|size
argument_list|,
name|nub_addr_t
operator|*
name|intersect_addr
argument_list|,
name|nub_size_t
operator|*
name|intersect_size
argument_list|,
name|nub_size_t
operator|*
name|opcode_offset
argument_list|)
decl|const
block|{
comment|// We only use software traps for software breakpoints
if|if
condition|(
name|IsBreakpoint
argument_list|()
operator|&&
name|IsEnabled
argument_list|()
operator|&&
operator|!
name|IsHardware
argument_list|()
condition|)
block|{
if|if
condition|(
name|m_byte_size
operator|>
literal|0
condition|)
block|{
specifier|const
name|nub_addr_t
name|bp_end_addr
init|=
name|m_addr
operator|+
name|m_byte_size
decl_stmt|;
specifier|const
name|nub_addr_t
name|end_addr
init|=
name|addr
operator|+
name|size
decl_stmt|;
comment|// Is the breakpoint end address before the passed in start address?
if|if
condition|(
name|bp_end_addr
operator|<=
name|addr
condition|)
return|return
name|false
return|;
comment|// Is the breakpoint start address after passed in end address?
if|if
condition|(
name|end_addr
operator|<=
name|m_addr
condition|)
return|return
name|false
return|;
if|if
condition|(
name|intersect_addr
operator|||
name|intersect_size
operator|||
name|opcode_offset
condition|)
block|{
if|if
condition|(
name|m_addr
operator|<
name|addr
condition|)
block|{
if|if
condition|(
name|intersect_addr
condition|)
operator|*
name|intersect_addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|intersect_size
condition|)
operator|*
name|intersect_size
operator|=
name|std
operator|::
name|min
operator|<
name|nub_addr_t
operator|>
operator|(
name|bp_end_addr
operator|,
name|end_addr
operator|)
operator|-
name|addr
expr_stmt|;
if|if
condition|(
name|opcode_offset
condition|)
operator|*
name|opcode_offset
operator|=
name|addr
operator|-
name|m_addr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|intersect_addr
condition|)
operator|*
name|intersect_addr
operator|=
name|m_addr
expr_stmt|;
if|if
condition|(
name|intersect_size
condition|)
operator|*
name|intersect_size
operator|=
name|std
operator|::
name|min
operator|<
name|nub_addr_t
operator|>
operator|(
name|bp_end_addr
operator|,
name|end_addr
operator|)
operator|-
name|m_addr
expr_stmt|;
if|if
condition|(
name|opcode_offset
condition|)
operator|*
name|opcode_offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
name|void
name|SetEnabled
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
operator|!
name|enabled
condition|)
name|SetHardwareIndex
argument_list|(
name|INVALID_NUB_HW_INDEX
argument_list|)
expr_stmt|;
name|m_enabled
operator|=
name|enabled
expr_stmt|;
block|}
name|void
name|SetIsWatchpoint
parameter_list|(
name|uint32_t
name|type
parameter_list|)
block|{
name|m_is_watchpoint
operator|=
literal|1
expr_stmt|;
name|m_watch_read
operator|=
operator|(
name|type
operator|&
name|WATCH_TYPE_READ
operator|)
operator|!=
literal|0
expr_stmt|;
name|m_watch_write
operator|=
operator|(
name|type
operator|&
name|WATCH_TYPE_WRITE
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
name|bool
name|IsBreakpoint
argument_list|()
specifier|const
block|{
return|return
name|m_is_watchpoint
operator|==
literal|0
return|;
block|}
name|bool
name|IsWatchpoint
argument_list|()
specifier|const
block|{
return|return
name|m_is_watchpoint
operator|==
literal|1
return|;
block|}
name|bool
name|WatchpointRead
argument_list|()
specifier|const
block|{
return|return
name|m_watch_read
operator|!=
literal|0
return|;
block|}
name|bool
name|WatchpointWrite
argument_list|()
specifier|const
block|{
return|return
name|m_watch_write
operator|!=
literal|0
return|;
block|}
name|bool
name|HardwarePreferred
argument_list|()
specifier|const
block|{
return|return
name|m_hw_preferred
return|;
block|}
name|bool
name|IsHardware
argument_list|()
specifier|const
block|{
return|return
name|m_hw_index
operator|!=
name|INVALID_NUB_HW_INDEX
return|;
block|}
name|uint32_t
name|GetHardwareIndex
argument_list|()
specifier|const
block|{
return|return
name|m_hw_index
return|;
block|}
name|void
name|SetHardwareIndex
parameter_list|(
name|uint32_t
name|hw_index
parameter_list|)
block|{
name|m_hw_index
operator|=
name|hw_index
expr_stmt|;
block|}
name|void
name|Dump
argument_list|()
specifier|const
expr_stmt|;
name|uint32_t
name|Retain
parameter_list|()
block|{
return|return
operator|++
name|m_retain_count
return|;
block|}
name|uint32_t
name|Release
parameter_list|()
block|{
if|if
condition|(
name|m_retain_count
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|--
name|m_retain_count
return|;
block|}
name|private
label|:
name|uint32_t
name|m_retain_count
decl_stmt|;
comment|// Each breakpoint is maintained by address and is ref counted in case multiple people set a breakpoint at the same address
name|uint32_t
name|m_byte_size
decl_stmt|;
comment|// Length in bytes of the breakpoint if set in memory
name|uint8_t
name|m_opcode
index|[
literal|8
index|]
decl_stmt|;
comment|// Saved opcode bytes
name|nub_addr_t
name|m_addr
decl_stmt|;
comment|// Address of this breakpoint
name|uint32_t
name|m_enabled
range|:
literal|1
decl_stmt|,
comment|// Flags for this breakpoint
name|m_hw_preferred
range|:
literal|1
decl_stmt|,
comment|// 1 if this point has been requested to be set using hardware (which may fail due to lack of resources)
name|m_is_watchpoint
range|:
literal|1
decl_stmt|,
comment|// 1 if this is a watchpoint
name|m_watch_read
range|:
literal|1
decl_stmt|,
comment|// 1 if we stop when the watched data is read from
name|m_watch_write
range|:
literal|1
decl_stmt|;
comment|// 1 if we stop when the watched data is written to
name|uint32_t
name|m_hw_index
decl_stmt|;
comment|// The hardware resource index for this breakpoint/watchpoint
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|DNBBreakpointList
block|{
name|public
label|:
name|DNBBreakpointList
argument_list|()
expr_stmt|;
operator|~
name|DNBBreakpointList
argument_list|()
expr_stmt|;
name|DNBBreakpoint
modifier|*
name|Add
parameter_list|(
name|nub_addr_t
name|addr
parameter_list|,
name|nub_size_t
name|length
parameter_list|,
name|bool
name|hardware
parameter_list|)
function_decl|;
name|bool
name|Remove
parameter_list|(
name|nub_addr_t
name|addr
parameter_list|)
function_decl|;
name|DNBBreakpoint
modifier|*
name|FindByAddress
parameter_list|(
name|nub_addr_t
name|addr
parameter_list|)
function_decl|;
specifier|const
name|DNBBreakpoint
modifier|*
name|FindByAddress
argument_list|(
name|nub_addr_t
name|addr
argument_list|)
decl|const
decl_stmt|;
name|size_t
name|FindBreakpointsThatOverlapRange
argument_list|(
name|nub_addr_t
name|addr
argument_list|,
name|nub_addr_t
name|size
argument_list|,
name|std
operator|::
name|vector
operator|<
name|DNBBreakpoint
operator|*
operator|>
operator|&
name|bps
argument_list|)
decl_stmt|;
name|void
name|Dump
argument_list|()
specifier|const
expr_stmt|;
name|size_t
name|Size
argument_list|()
specifier|const
block|{
return|return
name|m_breakpoints
operator|.
name|size
argument_list|()
return|;
block|}
name|void
name|DisableAll
parameter_list|()
function_decl|;
name|void
name|RemoveTrapsFromBuffer
argument_list|(
name|nub_addr_t
name|addr
argument_list|,
name|nub_size_t
name|size
argument_list|,
name|void
operator|*
name|buf
argument_list|)
decl|const
decl_stmt|;
name|void
name|DisableAllBreakpoints
parameter_list|(
name|MachProcess
modifier|*
name|process
parameter_list|)
function_decl|;
name|void
name|DisableAllWatchpoints
parameter_list|(
name|MachProcess
modifier|*
name|process
parameter_list|)
function_decl|;
name|void
name|RemoveDisabled
parameter_list|()
function_decl|;
name|protected
label|:
typedef|typedef
name|std
operator|::
name|map
operator|<
name|nub_addr_t
operator|,
name|DNBBreakpoint
operator|>
name|collection
expr_stmt|;
typedef|typedef
name|collection
operator|::
name|iterator
name|iterator
expr_stmt|;
typedef|typedef
name|collection
operator|::
name|const_iterator
name|const_iterator
expr_stmt|;
name|collection
name|m_breakpoints
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

