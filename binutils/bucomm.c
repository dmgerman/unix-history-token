begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* bucomm.c -- Bin Utils COMmon code.    Copyright 1991, 1992, 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002,    2003, 2006, 2007    Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* We might put this in a library someday so it could be dynamically    loaded, but for now it's not necessary.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* ctime, maybe time_t */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_TIME_T_IN_TIME_H
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_TIME_T_IN_TYPES_H
end_ifndef

begin_typedef
typedef|typedef
name|long
name|time_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|endian_string
parameter_list|(
name|enum
name|bfd_endian
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|display_target_list
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|display_info_table
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|display_target_tables
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Error reporting.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|bfd_nonfatal
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|string
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|string
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_fatal
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|bfd_nonfatal
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|report
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|fatal
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|report
argument_list|(
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|non_fatal
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|report
argument_list|(
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Set the default BFD target based on the configured target.  Doing    this permits the binutils to be configured for a particular target,    and linked against a shared BFD library which was configured for a    different target.  */
end_comment

begin_function
name|void
name|set_default_bfd_target
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* The macro TARGET is defined by Makefile.  */
specifier|const
name|char
modifier|*
name|target
init|=
name|TARGET
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_set_default_target
argument_list|(
name|target
argument_list|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"can't set BFD default target to `%s': %s"
argument_list|)
argument_list|,
name|target
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After a FALSE return from bfd_check_format_matches with    bfd_get_error () == bfd_error_file_ambiguously_recognized, print    the possible matching targets.  */
end_comment

begin_function
name|void
name|list_matching_formats
parameter_list|(
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Matching formats:"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* List the supported targets.  */
end_comment

begin_function
name|void
name|list_supported_targets
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|targ_names
init|=
name|bfd_target_list
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"Supported targets:"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"%s: supported targets:"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|targ_names
index|[
name|t
index|]
operator|!=
name|NULL
condition|;
name|t
operator|++
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %s"
argument_list|,
name|targ_names
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|targ_names
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* List the supported architectures.  */
end_comment

begin_function
name|void
name|list_supported_architectures
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|arch
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"Supported architectures:"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"%s: supported architectures:"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|arch
operator|=
name|bfd_arch_list
argument_list|()
init|;
operator|*
name|arch
condition|;
name|arch
operator|++
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|arch
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The length of the longest architecture name + 1.  */
end_comment

begin_define
define|#
directive|define
name|LONGEST_ARCH
value|sizeof ("powerpc:common")
end_define

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|endian_string
parameter_list|(
name|enum
name|bfd_endian
name|endian
parameter_list|)
block|{
switch|switch
condition|(
name|endian
condition|)
block|{
case|case
name|BFD_ENDIAN_BIG
case|:
return|return
literal|"big endian"
return|;
case|case
name|BFD_ENDIAN_LITTLE
case|:
return|return
literal|"little endian"
return|;
default|default:
return|return
literal|"endianness unknown"
return|;
block|}
block|}
end_function

begin_comment
comment|/* List the targets that BFD is configured to support, each followed    by its endianness and the architectures it supports.  */
end_comment

begin_function
specifier|static
name|int
name|display_target_list
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|dummy_name
decl_stmt|;
name|int
name|t
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|dummy_name
operator|=
name|make_temp_file
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|bfd_target_vector
index|[
name|t
index|]
condition|;
name|t
operator|++
control|)
block|{
specifier|const
name|bfd_target
modifier|*
name|p
init|=
name|bfd_target_vector
index|[
name|t
index|]
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|bfd_openw
argument_list|(
name|dummy_name
argument_list|,
name|p
operator|->
name|name
argument_list|)
decl_stmt|;
name|enum
name|bfd_architecture
name|a
decl_stmt|;
name|printf
argument_list|(
literal|"%s\n (header %s, data %s)\n"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|endian_string
argument_list|(
name|p
operator|->
name|header_byteorder
argument_list|)
argument_list|,
name|endian_string
argument_list|(
name|p
operator|->
name|byteorder
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|dummy_name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_invalid_operation
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|bfd_close_all_done
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|a
operator|=
name|bfd_arch_obscure
operator|+
literal|1
init|;
name|a
operator|<
name|bfd_arch_last
condition|;
name|a
operator|++
control|)
if|if
condition|(
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
operator|(
expr|enum
name|bfd_architecture
operator|)
name|a
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
operator|(
expr|enum
name|bfd_architecture
operator|)
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_close_all_done
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|dummy_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dummy_name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Print a table showing which architectures are supported for entries    FIRST through LAST-1 of bfd_target_vector (targets across,    architectures down).  */
end_comment

begin_function
specifier|static
name|int
name|display_info_table
parameter_list|(
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|dummy_name
decl_stmt|;
name|enum
name|bfd_architecture
name|a
decl_stmt|;
comment|/* Print heading of target names.  */
name|printf
argument_list|(
literal|"\n%*s"
argument_list|,
operator|(
name|int
operator|)
name|LONGEST_ARCH
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|first
init|;
name|t
operator|<
name|last
operator|&&
name|bfd_target_vector
index|[
name|t
index|]
condition|;
name|t
operator|++
control|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|bfd_target_vector
index|[
name|t
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|dummy_name
operator|=
name|make_temp_file
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|bfd_arch_obscure
operator|+
literal|1
init|;
name|a
operator|<
name|bfd_arch_last
condition|;
name|a
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_printable_arch_mach
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"UNKNOWN!"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%*s "
argument_list|,
operator|(
name|int
operator|)
name|LONGEST_ARCH
operator|-
literal|1
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|first
init|;
name|t
operator|<
name|last
operator|&&
name|bfd_target_vector
index|[
name|t
index|]
condition|;
name|t
operator|++
control|)
block|{
specifier|const
name|bfd_target
modifier|*
name|p
init|=
name|bfd_target_vector
index|[
name|t
index|]
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|bfd_openw
argument_list|(
name|dummy_name
argument_list|,
name|p
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_invalid_operation
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|a
argument_list|,
literal|0
argument_list|)
condition|)
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
decl_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abfd
operator|!=
name|NULL
condition|)
name|bfd_close_all_done
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|dummy_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dummy_name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Print tables of all the target-architecture combinations that    BFD has been configured to support.  */
end_comment

begin_function
specifier|static
name|int
name|display_target_tables
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|int
name|columns
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|colum
decl_stmt|;
name|columns
operator|=
literal|0
expr_stmt|;
name|colum
operator|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|colum
operator|!=
name|NULL
condition|)
name|columns
operator|=
name|atoi
argument_list|(
name|colum
argument_list|)
expr_stmt|;
if|if
condition|(
name|columns
operator|==
literal|0
condition|)
name|columns
operator|=
literal|80
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bfd_target_vector
index|[
name|t
index|]
operator|!=
name|NULL
condition|)
block|{
name|int
name|oldt
init|=
name|t
decl_stmt|,
name|wid
decl_stmt|;
name|wid
operator|=
name|LONGEST_ARCH
operator|+
name|strlen
argument_list|(
name|bfd_target_vector
index|[
name|t
index|]
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|++
name|t
expr_stmt|;
while|while
condition|(
name|wid
operator|<
name|columns
operator|&&
name|bfd_target_vector
index|[
name|t
index|]
operator|!=
name|NULL
condition|)
block|{
name|int
name|newwid
decl_stmt|;
name|newwid
operator|=
name|wid
operator|+
name|strlen
argument_list|(
name|bfd_target_vector
index|[
name|t
index|]
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|newwid
operator|>=
name|columns
condition|)
break|break;
name|wid
operator|=
name|newwid
expr_stmt|;
operator|++
name|t
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|display_info_table
argument_list|(
name|oldt
argument_list|,
name|t
argument_list|)
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|display_info
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"BFD header file version %s\n"
argument_list|)
argument_list|,
name|BFD_VERSION_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|display_target_list
argument_list|()
operator|||
operator|!
name|display_target_tables
argument_list|()
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Display the archive header for an element as if it were an ls -l listing:     Mode       User\tGroup\tSize\tDate               Name */
end_comment

begin_function
name|void
name|print_arelt_descr
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|verbose
parameter_list|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|bfd_stat_arch_elt
argument_list|(
name|abfd
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|modebuf
index|[
literal|11
index|]
decl_stmt|;
name|char
name|timebuf
index|[
literal|40
index|]
decl_stmt|;
name|time_t
name|when
init|=
name|buf
operator|.
name|st_mtime
decl_stmt|;
specifier|const
name|char
modifier|*
name|ctime_result
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|ctime
argument_list|(
operator|&
name|when
argument_list|)
decl_stmt|;
comment|/* POSIX format:  skip weekday and seconds from ctime output.  */
name|sprintf
argument_list|(
name|timebuf
argument_list|,
literal|"%.12s %.4s"
argument_list|,
name|ctime_result
operator|+
literal|4
argument_list|,
name|ctime_result
operator|+
literal|20
argument_list|)
expr_stmt|;
name|mode_string
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|,
name|modebuf
argument_list|)
expr_stmt|;
name|modebuf
index|[
literal|10
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* POSIX 1003.2/D11 says to skip first character (entry type).  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s %ld/%ld %6ld %s "
argument_list|,
name|modebuf
operator|+
literal|1
argument_list|,
operator|(
name|long
operator|)
name|buf
operator|.
name|st_uid
argument_list|,
operator|(
name|long
operator|)
name|buf
operator|.
name|st_gid
argument_list|,
operator|(
name|long
operator|)
name|buf
operator|.
name|st_size
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a path for a new temporary file in the same directory    as file PATH.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|template_in_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
define|#
directive|define
name|template
value|"stXXXXXX"
specifier|const
name|char
modifier|*
name|slash
init|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tmpname
decl_stmt|;
name|size_t
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
block|{
comment|/* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
name|char
modifier|*
name|bslash
init|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'\\'
argument_list|)
decl_stmt|;
if|if
condition|(
name|slash
operator|==
name|NULL
operator|||
operator|(
name|bslash
operator|!=
name|NULL
operator|&&
name|bslash
operator|>
name|slash
operator|)
condition|)
name|slash
operator|=
name|bslash
expr_stmt|;
if|if
condition|(
name|slash
operator|==
name|NULL
operator|&&
name|path
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|path
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|slash
operator|=
name|path
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|slash
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|len
operator|=
name|slash
operator|-
name|path
expr_stmt|;
name|tmpname
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
name|template
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmpname
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
comment|/* If tmpname is "X:", appending a slash will make it a root 	 directory on drive X, which is NOT the same as the current 	 directory on drive X.  */
if|if
condition|(
name|len
operator|==
literal|2
operator|&&
name|tmpname
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|tmpname
index|[
name|len
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
endif|#
directive|endif
name|tmpname
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|tmpname
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|tmpname
operator|+
name|len
argument_list|,
name|template
argument_list|,
sizeof|sizeof
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tmpname
return|;
undef|#
directive|undef
name|template
block|}
end_function

begin_comment
comment|/* Return the name of a created temporary file in the same directory    as FILENAME.  */
end_comment

begin_function
name|char
modifier|*
name|make_tempname
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
modifier|*
name|tmpname
init|=
name|template_in_dir
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|int
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MKSTEMP
name|fd
operator|=
name|mkstemp
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
else|#
directive|else
name|tmpname
operator|=
name|mktemp
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpname
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|fd
operator|=
name|open
argument_list|(
name|tmpname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|tmpname
return|;
block|}
end_function

begin_comment
comment|/* Return the name of a created temporary directory inside the    directory containing FILENAME.  */
end_comment

begin_function
name|char
modifier|*
name|make_tempdir
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
modifier|*
name|tmpname
init|=
name|template_in_dir
argument_list|(
name|filename
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MKDTEMP
return|return
name|mkdtemp
argument_list|(
name|tmpname
argument_list|)
return|;
else|#
directive|else
name|tmpname
operator|=
name|mktemp
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpname
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
if|if
condition|(
name|mkdir
argument_list|(
name|tmpname
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
else|#
directive|else
if|if
condition|(
name|mkdir
argument_list|(
name|tmpname
argument_list|,
literal|0700
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
endif|#
directive|endif
return|return
name|tmpname
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Parse a string into a VMA, with a fatal error if it can't be    parsed.  */
end_comment

begin_function
name|bfd_vma
name|parse_vma
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|bfd_vma
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|ret
operator|=
name|bfd_scan_vma
argument_list|(
name|s
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: bad number: %s"
argument_list|)
argument_list|,
name|arg
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Returns the size of the named file.  If the file does not    exist, or if it is not a real file, then a suitable non-fatal    error message is printed and zero is returned.  */
end_comment

begin_function
name|off_t
name|get_file_size
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file_name
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"'%s': No such file"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
else|else
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Warning: could not locate '%s'.  reason: %s"
argument_list|)
argument_list|,
name|file_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Warning: '%s' is not an ordinary file"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
else|else
return|return
name|statbuf
operator|.
name|st_size
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the filename in a static buffer.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bfd_get_archive_filename
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
specifier|static
name|size_t
name|curr
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|needed
decl_stmt|;
name|assert
argument_list|(
name|abfd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
operator|->
name|my_archive
condition|)
return|return
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
return|;
name|needed
operator|=
operator|(
name|strlen
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
operator|->
name|my_archive
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|+
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|needed
operator|>
name|curr
condition|)
block|{
if|if
condition|(
name|curr
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|curr
operator|=
name|needed
operator|+
operator|(
name|needed
operator|>>
literal|1
operator|)
expr_stmt|;
name|buf
operator|=
name|bfd_malloc
argument_list|(
name|curr
argument_list|)
expr_stmt|;
comment|/* If we can't malloc, fail safe by returning just the file name. 	 This function is only used when building error messages.  */
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|curr
operator|=
literal|0
expr_stmt|;
return|return
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
return|;
block|}
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s(%s)"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
operator|->
name|my_archive
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

end_unit

