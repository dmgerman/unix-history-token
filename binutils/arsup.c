begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* arsup.c - Archive support for MRI compatibility    Copyright 1992, 1994, 1995, 1996, 1997, 1999, 2000, 2001, 2002, 2003,    2004, 2007 Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Contributed by Steve Chamberlain    sac@cygnus.com     This file looks after requests from arparse.y, to provide the MRI    style librarian command syntax + 1 word LIST.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"arsup.h"
end_include

begin_function_decl
specifier|static
name|void
name|map_over_list
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar_directory_doer
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar_addlib_doer
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|obfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|real_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|map_over_list
parameter_list|(
name|bfd
modifier|*
name|arch
parameter_list|,
name|void
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|list
modifier|*
name|list
parameter_list|)
block|{
name|bfd
modifier|*
name|head
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
block|{
name|bfd
modifier|*
name|next
decl_stmt|;
name|head
operator|=
name|arch
operator|->
name|archive_next
expr_stmt|;
while|while
condition|(
name|head
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|head
operator|->
name|archive_next
expr_stmt|;
name|function
argument_list|(
name|head
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|head
operator|=
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|list
modifier|*
name|ptr
decl_stmt|;
comment|/* This may appear to be a baroque way of accomplishing what we 	 want.  however we have to iterate over the filenames in order 	 to notice where a filename is requested but does not exist in 	 the archive.  Ditto mapping over each file each time -- we 	 want to hack multiple references.  */
for|for
control|(
name|ptr
operator|=
name|list
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|bfd_boolean
name|found
init|=
name|FALSE
decl_stmt|;
name|bfd
modifier|*
name|prev
init|=
name|arch
decl_stmt|;
for|for
control|(
name|head
operator|=
name|arch
operator|->
name|archive_next
init|;
name|head
condition|;
name|head
operator|=
name|head
operator|->
name|archive_next
control|)
block|{
if|if
condition|(
name|head
operator|->
name|filename
operator|!=
name|NULL
operator|&&
name|FILENAME_CMP
argument_list|(
name|ptr
operator|->
name|name
argument_list|,
name|head
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
name|TRUE
expr_stmt|;
name|function
argument_list|(
name|head
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|head
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"No entry %s in archive.\n"
argument_list|)
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ar_directory_doer
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|print_arelt_descr
argument_list|(
name|outfile
argument_list|,
name|abfd
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar_directory
parameter_list|(
name|char
modifier|*
name|ar_name
parameter_list|,
name|struct
name|list
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|output
parameter_list|)
block|{
name|bfd
modifier|*
name|arch
decl_stmt|;
name|arch
operator|=
name|open_inarch
argument_list|(
name|ar_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
condition|)
block|{
name|outfile
operator|=
name|fopen
argument_list|(
name|output
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
literal|0
condition|)
block|{
name|outfile
operator|=
name|stdout
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Can't open file %s\n"
argument_list|)
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|output
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|outfile
operator|=
name|stdout
expr_stmt|;
name|map_over_list
argument_list|(
name|arch
argument_list|,
name|ar_directory_doer
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|arch
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
condition|)
name|fclose
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prompt
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|int
name|interactive
decl_stmt|;
if|if
condition|(
name|interactive
condition|)
block|{
name|printf
argument_list|(
literal|"AR>"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|maybequit
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|interactive
condition|)
name|xexit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|t
parameter_list|)
block|{
name|char
modifier|*
name|tname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|10
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|bname
init|=
name|lbasename
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|real_name
operator|=
name|name
expr_stmt|;
comment|/* Prepend tmp- to the beginning, to avoid file-name clashes after      truncation on filesystems with limited namespaces (DOS).  */
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"%.*stmp-%s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|bname
operator|-
name|name
argument_list|)
argument_list|,
name|name
argument_list|,
name|bname
argument_list|)
expr_stmt|;
name|obfd
operator|=
name|bfd_openw
argument_list|(
name|tname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Can't open output archive %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|bfd
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|bfd
modifier|*
name|element
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|ibfd
operator|=
name|bfd_openr
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ibfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Can't open input archive %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|ibfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: file %s is not an archive\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
operator|&
operator|(
name|obfd
operator|->
name|archive_head
operator|)
expr_stmt|;
name|element
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|ibfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|element
condition|)
block|{
operator|*
name|ptr
operator|=
name|element
expr_stmt|;
name|ptr
operator|=
operator|&
name|element
operator|->
name|archive_next
expr_stmt|;
name|element
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|ibfd
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
block|}
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_archive
argument_list|)
expr_stmt|;
name|obfd
operator|->
name|has_armap
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ar_addlib_doer
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|prev
parameter_list|)
block|{
comment|/* Add this module to the output bfd.  */
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|archive_next
operator|=
name|abfd
operator|->
name|archive_next
expr_stmt|;
name|abfd
operator|->
name|archive_next
operator|=
name|obfd
operator|->
name|archive_head
expr_stmt|;
name|obfd
operator|->
name|archive_head
operator|=
name|abfd
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar_addlib
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|list
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|obfd
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: no output archive specified yet\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|bfd
modifier|*
name|arch
decl_stmt|;
name|arch
operator|=
name|open_inarch
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|!=
name|NULL
condition|)
name|map_over_list
argument_list|(
name|arch
argument_list|,
name|ar_addlib_doer
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* Don't close the bfd, since it will make the elements disappear.  */
block|}
block|}
end_function

begin_function
name|void
name|ar_addmod
parameter_list|(
name|struct
name|list
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
operator|!
name|obfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: no open output archive\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|list
condition|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|bfd_openr
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: can't open file %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|abfd
operator|->
name|archive_next
operator|=
name|obfd
operator|->
name|archive_head
expr_stmt|;
name|obfd
operator|->
name|archive_head
operator|=
name|abfd
expr_stmt|;
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ar_clear
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|obfd
condition|)
name|obfd
operator|->
name|archive_head
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar_delete
parameter_list|(
name|struct
name|list
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
operator|!
name|obfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: no open output archive\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|list
condition|)
block|{
comment|/* Find this name in the archive.  */
name|bfd
modifier|*
name|member
init|=
name|obfd
operator|->
name|archive_head
decl_stmt|;
name|bfd
modifier|*
modifier|*
name|prev
init|=
operator|&
operator|(
name|obfd
operator|->
name|archive_head
operator|)
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|member
condition|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|member
operator|->
name|filename
argument_list|,
name|list
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|prev
operator|=
name|member
operator|->
name|archive_next
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|prev
operator|=
operator|&
operator|(
name|member
operator|->
name|archive_next
operator|)
expr_stmt|;
name|member
operator|=
name|member
operator|->
name|archive_next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: can't find module file %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ar_save
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|obfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: no open output archive\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|ofilename
init|=
name|xstrdup
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
decl_stmt|;
name|bfd_close
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
name|smart_rename
argument_list|(
name|ofilename
argument_list|,
name|real_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obfd
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|ofilename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ar_replace
parameter_list|(
name|struct
name|list
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
operator|!
name|obfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: no open output archive\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|list
condition|)
block|{
comment|/* Find this name in the archive.  */
name|bfd
modifier|*
name|member
init|=
name|obfd
operator|->
name|archive_head
decl_stmt|;
name|bfd
modifier|*
modifier|*
name|prev
init|=
operator|&
operator|(
name|obfd
operator|->
name|archive_head
operator|)
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|member
condition|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|member
operator|->
name|filename
argument_list|,
name|list
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found the one to replace.  */
name|bfd
modifier|*
name|abfd
init|=
name|bfd_openr
argument_list|(
name|list
operator|->
name|name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: can't open file %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|*
name|prev
operator|=
name|abfd
expr_stmt|;
name|abfd
operator|->
name|archive_next
operator|=
name|member
operator|->
name|archive_next
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|prev
operator|=
operator|&
operator|(
name|member
operator|->
name|archive_next
operator|)
expr_stmt|;
block|}
name|member
operator|=
name|member
operator|->
name|archive_next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|bfd_openr
argument_list|(
name|list
operator|->
name|name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: can't find module file %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: can't open file %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
operator|*
name|prev
operator|=
name|abfd
expr_stmt|;
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* And I added this one.  */
end_comment

begin_function
name|void
name|ar_list
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|obfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: no open output archive\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|outfile
operator|=
name|stdout
expr_stmt|;
name|verbose
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Current open archive is %s\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|abfd
operator|=
name|obfd
operator|->
name|archive_head
init|;
name|abfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|archive_next
control|)
name|ar_directory_doer
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ar_end
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|obfd
condition|)
block|{
name|bfd_cache_close
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ar_extract
parameter_list|(
name|struct
name|list
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
operator|!
name|obfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: no open archive\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|list
condition|)
block|{
comment|/* Find this name in the archive.  */
name|bfd
modifier|*
name|member
init|=
name|obfd
operator|->
name|archive_head
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|member
operator|&&
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|member
operator|->
name|filename
argument_list|,
name|list
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|extract_file
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
name|member
operator|=
name|member
operator|->
name|archive_next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|bfd_openr
argument_list|(
name|list
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: can't find module file %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

