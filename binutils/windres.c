begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* windres.c -- a program to manipulate Windows resources    Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007    Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support.    Rewritten by Kai Tietz, Onevision.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* This program can read and write Windows resources in various    formats.  In particular, it can act like the rc resource compiler    program, and it can act like the cvtres res to COFF conversion    program.     It is based on information taken from the following sources:     * Microsoft documentation.     * The rcl program, written by Gunther Ebert<gunther.ebert@ixos-leipzig.de>.     * The res2coff program, written by Pedro A. Aranda<paag@tid.es>.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"windres.h"
end_include

begin_comment
comment|/* Defined in bfd/binary.c.  Used to set architecture and machine of input    binary files.  */
end_comment

begin_decl_stmt
specifier|extern
name|enum
name|bfd_architecture
name|bfd_external_binary_architecture
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|bfd_external_machine
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used by resrc.c at least.  */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|target_is_bigendian
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|def_target_arch
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|set_endianess
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* An enumeration of format types.  */
end_comment

begin_enum
enum|enum
name|res_format
block|{
comment|/* Unknown format.  */
name|RES_FORMAT_UNKNOWN
block|,
comment|/* Textual RC file.  */
name|RES_FORMAT_RC
block|,
comment|/* Binary RES file.  */
name|RES_FORMAT_RES
block|,
comment|/* COFF file.  */
name|RES_FORMAT_COFF
block|}
enum|;
end_enum

begin_comment
comment|/* A structure used to map between format types and strings.  */
end_comment

begin_struct
struct|struct
name|format_map
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|res_format
name|format
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A mapping between names and format types.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|format_map
name|format_names
index|[]
init|=
block|{
block|{
literal|"rc"
block|,
name|RES_FORMAT_RC
block|}
block|,
block|{
literal|"res"
block|,
name|RES_FORMAT_RES
block|}
block|,
block|{
literal|"coff"
block|,
name|RES_FORMAT_COFF
block|}
block|,
block|{
name|NULL
block|,
name|RES_FORMAT_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A mapping from file extensions to format types.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|format_map
name|format_fileexts
index|[]
init|=
block|{
block|{
literal|"rc"
block|,
name|RES_FORMAT_RC
block|}
block|,
block|{
literal|"res"
block|,
name|RES_FORMAT_RES
block|}
block|,
block|{
literal|"exe"
block|,
name|RES_FORMAT_COFF
block|}
block|,
block|{
literal|"obj"
block|,
name|RES_FORMAT_COFF
block|}
block|,
block|{
literal|"o"
block|,
name|RES_FORMAT_COFF
block|}
block|,
block|{
name|NULL
block|,
name|RES_FORMAT_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of include directories.  */
end_comment

begin_struct
struct|struct
name|include_dir
block|{
name|struct
name|include_dir
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|include_dir
modifier|*
name|include_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|res_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|extended_menuitems
parameter_list|(
specifier|const
name|rc_menuitem
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|res_format
name|format_from_name
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|res_format
name|format_from_filename
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_res_entry
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rc_res_directory
modifier|*
name|sort_resources
parameter_list|(
name|rc_res_directory
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reswr_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|quot
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function_decl
specifier|static
name|rc_uint_type
name|target_get_8
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|target_put_8
parameter_list|(
name|void
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rc_uint_type
name|target_get_16
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|target_put_16
parameter_list|(
name|void
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rc_uint_type
name|target_get_32
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|target_put_32
parameter_list|(
name|void
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* When we are building a resource tree, we allocate everything onto    an obstack, so that we can free it all at once if we want.  */
end_comment

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* The resource building obstack.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|res_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the resource building obstack.  */
end_comment

begin_function
specifier|static
name|void
name|res_init
parameter_list|(
name|void
parameter_list|)
block|{
name|obstack_init
argument_list|(
operator|&
name|res_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate space on the resource building obstack.  */
end_comment

begin_function
name|void
modifier|*
name|res_alloc
parameter_list|(
name|rc_uint_type
name|bytes
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|res_obstack
argument_list|,
operator|(
name|size_t
operator|)
name|bytes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We also use an obstack to save memory used while writing out a set    of resources.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|reswr_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the resource writing obstack.  */
end_comment

begin_function
specifier|static
name|void
name|reswr_init
parameter_list|(
name|void
parameter_list|)
block|{
name|obstack_init
argument_list|(
operator|&
name|reswr_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate space on the resource writing obstack.  */
end_comment

begin_function
name|void
modifier|*
name|reswr_alloc
parameter_list|(
name|rc_uint_type
name|bytes
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reswr_obstack
argument_list|,
operator|(
name|size_t
operator|)
name|bytes
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open a file using the include directory search list.  */
end_comment

begin_function
name|FILE
modifier|*
name|open_file_search
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|errmsg
parameter_list|,
name|char
modifier|*
modifier|*
name|real_filename
parameter_list|)
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|struct
name|include_dir
modifier|*
name|d
decl_stmt|;
name|e
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
operator|*
name|real_filename
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
for|for
control|(
name|d
operator|=
name|include_dirs
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|d
operator|->
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|n
argument_list|,
literal|"%s/%s"
argument_list|,
name|d
operator|->
name|dir
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
name|n
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
operator|*
name|real_filename
operator|=
name|n
expr_stmt|;
return|return
name|e
return|;
block|}
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
break|break;
block|}
block|}
name|fatal
argument_list|(
name|_
argument_list|(
literal|"can't open %s `%s': %s"
argument_list|)
argument_list|,
name|errmsg
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return a value to avoid a compiler warning.  */
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two resource ID's.  We consider name entries to come before    numeric entries, because that is how they appear in the COFF .rsrc    section.  */
end_comment

begin_function
name|int
name|res_id_cmp
parameter_list|(
name|rc_res_id
name|a
parameter_list|,
name|rc_res_id
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
operator|.
name|named
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|named
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|.
name|u
operator|.
name|id
operator|>
name|b
operator|.
name|u
operator|.
name|id
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|.
name|u
operator|.
name|id
operator|<
name|b
operator|.
name|u
operator|.
name|id
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
name|unichar
modifier|*
name|as
decl_stmt|,
modifier|*
name|ase
decl_stmt|,
modifier|*
name|bs
decl_stmt|,
modifier|*
name|bse
decl_stmt|;
if|if
condition|(
operator|!
name|b
operator|.
name|named
condition|)
return|return
operator|-
literal|1
return|;
name|as
operator|=
name|a
operator|.
name|u
operator|.
name|n
operator|.
name|name
expr_stmt|;
name|ase
operator|=
name|as
operator|+
name|a
operator|.
name|u
operator|.
name|n
operator|.
name|length
expr_stmt|;
name|bs
operator|=
name|b
operator|.
name|u
operator|.
name|n
operator|.
name|name
expr_stmt|;
name|bse
operator|=
name|bs
operator|+
name|b
operator|.
name|u
operator|.
name|n
operator|.
name|length
expr_stmt|;
while|while
condition|(
name|as
operator|<
name|ase
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bs
operator|>=
name|bse
condition|)
return|return
literal|1
return|;
name|i
operator|=
operator|(
name|int
operator|)
operator|*
name|as
operator|-
operator|(
name|int
operator|)
operator|*
name|bs
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|i
return|;
operator|++
name|as
expr_stmt|;
operator|++
name|bs
expr_stmt|;
block|}
if|if
condition|(
name|bs
operator|<
name|bse
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Print a resource ID.  */
end_comment

begin_function
name|void
name|res_id_print
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|rc_res_id
name|id
parameter_list|,
name|int
name|quote
parameter_list|)
block|{
if|if
condition|(
operator|!
name|id
operator|.
name|named
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|int
operator|)
name|id
operator|.
name|u
operator|.
name|id
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|quote
condition|)
name|unicode_print_quoted
argument_list|(
name|stream
argument_list|,
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|name
argument_list|,
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|length
argument_list|)
expr_stmt|;
else|else
name|unicode_print
argument_list|(
name|stream
argument_list|,
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|name
argument_list|,
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a list of resource ID's.  */
end_comment

begin_function
name|void
name|res_ids_print
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|cids
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
name|ids
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cids
condition|;
name|i
operator|++
control|)
block|{
name|res_id_print
argument_list|(
name|stream
argument_list|,
name|ids
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|cids
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert an ASCII string to a resource ID.  */
end_comment

begin_function
name|void
name|res_string_to_id
parameter_list|(
name|rc_res_id
modifier|*
name|res_id
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|res_id
operator|->
name|named
operator|=
literal|1
expr_stmt|;
name|unicode_from_ascii
argument_list|(
operator|&
name|res_id
operator|->
name|u
operator|.
name|n
operator|.
name|length
argument_list|,
operator|&
name|res_id
operator|->
name|u
operator|.
name|n
operator|.
name|name
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert an unicode string to a resource ID.  */
end_comment

begin_function
name|void
name|res_unistring_to_id
parameter_list|(
name|rc_res_id
modifier|*
name|res_id
parameter_list|,
specifier|const
name|unichar
modifier|*
name|u
parameter_list|)
block|{
name|res_id
operator|->
name|named
operator|=
literal|1
expr_stmt|;
name|res_id
operator|->
name|u
operator|.
name|n
operator|.
name|length
operator|=
name|unichar_len
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|res_id
operator|->
name|u
operator|.
name|n
operator|.
name|name
operator|=
name|unichar_dup_uppercase
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a resource.  The arguments are the resource tree, RESOURCES,    and the location at which to put it in the tree, CIDS and IDS.    This returns a newly allocated rc_res_resource structure, which the    caller is expected to initialize.  If DUPOK is non-zero, then if a    resource with this ID exists, it is returned.  Otherwise, a warning    is issued, and a new resource is created replacing the existing    one.  */
end_comment

begin_function
name|rc_res_resource
modifier|*
name|define_resource
parameter_list|(
name|rc_res_directory
modifier|*
modifier|*
name|resources
parameter_list|,
name|int
name|cids
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
name|ids
parameter_list|,
name|int
name|dupok
parameter_list|)
block|{
name|rc_res_entry
modifier|*
name|re
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|cids
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cids
condition|;
name|i
operator|++
control|)
block|{
name|rc_res_entry
modifier|*
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
operator|*
name|resources
operator|==
name|NULL
condition|)
block|{
specifier|static
name|unsigned
name|int
name|timeval
decl_stmt|;
comment|/* Use the same timestamp for every resource created in a              single run.  */
if|if
condition|(
name|timeval
operator|==
literal|0
condition|)
name|timeval
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|resources
operator|=
operator|(
operator|(
name|rc_res_directory
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rc_res_directory
argument_list|)
argument_list|)
operator|)
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|characteristics
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|time
operator|=
name|timeval
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|major
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|minor
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|entries
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|pp
operator|=
operator|&
operator|(
operator|*
name|resources
operator|)
operator|->
name|entries
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
if|if
condition|(
name|res_id_cmp
argument_list|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|id
argument_list|,
name|ids
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|pp
operator|!=
name|NULL
condition|)
name|re
operator|=
operator|*
name|pp
expr_stmt|;
else|else
block|{
name|re
operator|=
operator|(
name|rc_res_entry
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rc_res_entry
argument_list|)
argument_list|)
expr_stmt|;
name|re
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|re
operator|->
name|id
operator|=
name|ids
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|cids
condition|)
block|{
name|re
operator|->
name|subdir
operator|=
literal|1
expr_stmt|;
name|re
operator|->
name|u
operator|.
name|dir
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|re
operator|->
name|subdir
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|u
operator|.
name|res
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|re
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|cids
condition|)
block|{
if|if
condition|(
operator|!
name|re
operator|->
name|subdir
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|res_ids_print
argument_list|(
name|stderr
argument_list|,
name|i
argument_list|,
name|ids
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|": expected to be a directory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|resources
operator|=
operator|&
name|re
operator|->
name|u
operator|.
name|dir
expr_stmt|;
block|}
block|}
if|if
condition|(
name|re
operator|->
name|subdir
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|res_ids_print
argument_list|(
name|stderr
argument_list|,
name|cids
argument_list|,
name|ids
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|": expected to be a leaf\n"
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|re
operator|->
name|u
operator|.
name|res
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dupok
condition|)
return|return
name|re
operator|->
name|u
operator|.
name|res
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: warning: "
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|res_ids_print
argument_list|(
name|stderr
argument_list|,
name|cids
argument_list|,
name|ids
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|": duplicate value\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|re
operator|->
name|u
operator|.
name|res
operator|=
operator|(
operator|(
name|rc_res_resource
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rc_res_resource
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|re
operator|->
name|u
operator|.
name|res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rc_res_resource
argument_list|)
argument_list|)
expr_stmt|;
name|re
operator|->
name|u
operator|.
name|res
operator|->
name|type
operator|=
name|RES_TYPE_UNINITIALIZED
expr_stmt|;
return|return
name|re
operator|->
name|u
operator|.
name|res
return|;
block|}
end_function

begin_comment
comment|/* Define a standard resource.  This is a version of define_resource    that just takes type, name, and language arguments.  */
end_comment

begin_function
name|rc_res_resource
modifier|*
name|define_standard_resource
parameter_list|(
name|rc_res_directory
modifier|*
modifier|*
name|resources
parameter_list|,
name|int
name|type
parameter_list|,
name|rc_res_id
name|name
parameter_list|,
name|rc_uint_type
name|language
parameter_list|,
name|int
name|dupok
parameter_list|)
block|{
name|rc_res_id
name|a
index|[
literal|3
index|]
decl_stmt|;
name|a
index|[
literal|0
index|]
operator|.
name|named
operator|=
literal|0
expr_stmt|;
name|a
index|[
literal|0
index|]
operator|.
name|u
operator|.
name|id
operator|=
name|type
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|=
name|name
expr_stmt|;
name|a
index|[
literal|2
index|]
operator|.
name|named
operator|=
literal|0
expr_stmt|;
name|a
index|[
literal|2
index|]
operator|.
name|u
operator|.
name|id
operator|=
name|language
expr_stmt|;
return|return
name|define_resource
argument_list|(
name|resources
argument_list|,
literal|3
argument_list|,
name|a
argument_list|,
name|dupok
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Comparison routine for resource sorting.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_res_entry
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|rc_res_entry
modifier|*
modifier|*
name|re1
decl_stmt|,
modifier|*
modifier|*
name|re2
decl_stmt|;
name|re1
operator|=
operator|(
specifier|const
name|rc_res_entry
operator|*
operator|*
operator|)
name|p1
expr_stmt|;
name|re2
operator|=
operator|(
specifier|const
name|rc_res_entry
operator|*
operator|*
operator|)
name|p2
expr_stmt|;
return|return
name|res_id_cmp
argument_list|(
operator|(
operator|*
name|re1
operator|)
operator|->
name|id
argument_list|,
operator|(
operator|*
name|re2
operator|)
operator|->
name|id
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sort the resources.  */
end_comment

begin_function
specifier|static
name|rc_res_directory
modifier|*
name|sort_resources
parameter_list|(
name|rc_res_directory
modifier|*
name|resdir
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|rc_res_entry
modifier|*
name|re
decl_stmt|;
name|rc_res_entry
modifier|*
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|resdir
operator|->
name|entries
operator|==
name|NULL
condition|)
return|return
name|resdir
return|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|re
operator|=
name|resdir
operator|->
name|entries
init|;
name|re
operator|!=
name|NULL
condition|;
name|re
operator|=
name|re
operator|->
name|next
control|)
operator|++
name|c
expr_stmt|;
comment|/* This is a recursive routine, so using xmalloc is probably better      than alloca.  */
name|a
operator|=
operator|(
name|rc_res_entry
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|c
operator|*
sizeof|sizeof
argument_list|(
name|rc_res_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|re
operator|=
name|resdir
operator|->
name|entries
init|;
name|re
operator|!=
name|NULL
condition|;
name|re
operator|=
name|re
operator|->
name|next
operator|,
name|i
operator|++
control|)
name|a
index|[
name|i
index|]
operator|=
name|re
expr_stmt|;
name|qsort
argument_list|(
name|a
argument_list|,
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|rc_res_entry
operator|*
argument_list|)
argument_list|,
name|cmp_res_entry
argument_list|)
expr_stmt|;
name|resdir
operator|->
name|entries
operator|=
name|a
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|a
index|[
name|i
index|]
operator|->
name|next
operator|=
name|a
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|a
index|[
name|i
index|]
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* Now sort the subdirectories.  */
for|for
control|(
name|re
operator|=
name|resdir
operator|->
name|entries
init|;
name|re
operator|!=
name|NULL
condition|;
name|re
operator|=
name|re
operator|->
name|next
control|)
if|if
condition|(
name|re
operator|->
name|subdir
condition|)
name|re
operator|->
name|u
operator|.
name|dir
operator|=
name|sort_resources
argument_list|(
name|re
operator|->
name|u
operator|.
name|dir
argument_list|)
expr_stmt|;
return|return
name|resdir
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return whether the dialog resource DIALOG is a DIALOG or a    DIALOGEX.  */
end_comment

begin_function
name|int
name|extended_dialog
parameter_list|(
specifier|const
name|rc_dialog
modifier|*
name|dialog
parameter_list|)
block|{
specifier|const
name|rc_dialog_control
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|dialog
operator|->
name|ex
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
for|for
control|(
name|c
operator|=
name|dialog
operator|->
name|controls
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
name|c
operator|->
name|data
operator|!=
name|NULL
operator|||
name|c
operator|->
name|help
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return whether MENUITEMS are a MENU or a MENUEX.  */
end_comment

begin_function
name|int
name|extended_menu
parameter_list|(
specifier|const
name|rc_menu
modifier|*
name|menu
parameter_list|)
block|{
return|return
name|extended_menuitems
argument_list|(
name|menu
operator|->
name|items
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|extended_menuitems
parameter_list|(
specifier|const
name|rc_menuitem
modifier|*
name|menuitems
parameter_list|)
block|{
specifier|const
name|rc_menuitem
modifier|*
name|mi
decl_stmt|;
for|for
control|(
name|mi
operator|=
name|menuitems
init|;
name|mi
operator|!=
name|NULL
condition|;
name|mi
operator|=
name|mi
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mi
operator|->
name|help
operator|!=
literal|0
operator|||
name|mi
operator|->
name|state
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|mi
operator|->
name|popup
operator|!=
name|NULL
operator|&&
name|mi
operator|->
name|id
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|mi
operator|->
name|type
operator|&
operator|~
operator|(
name|MENUITEM_CHECKED
operator||
name|MENUITEM_GRAYED
operator||
name|MENUITEM_HELP
operator||
name|MENUITEM_INACTIVE
operator||
name|MENUITEM_MENUBARBREAK
operator||
name|MENUITEM_MENUBREAK
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|mi
operator|->
name|popup
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|extended_menuitems
argument_list|(
name|mi
operator|->
name|popup
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert a string to a format type, or exit if it can't be done.  */
end_comment

begin_function
specifier|static
name|enum
name|res_format
name|format_from_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|exit_on_error
parameter_list|)
block|{
specifier|const
name|struct
name|format_map
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|format_names
init|;
name|m
operator|->
name|name
operator|!=
name|NULL
condition|;
name|m
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|m
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|m
operator|->
name|name
operator|==
name|NULL
operator|&&
name|exit_on_error
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"unknown format type `%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: supported formats:"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|format_names
init|;
name|m
operator|->
name|name
operator|!=
name|NULL
condition|;
name|m
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|m
operator|->
name|format
return|;
block|}
end_function

begin_comment
comment|/* Work out a format type given a file name.  If INPUT is non-zero,    it's OK to look at the file itself.  */
end_comment

begin_function
specifier|static
name|enum
name|res_format
name|format_from_filename
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|input
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ext
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|bfd_byte
name|b1
decl_stmt|,
name|b2
decl_stmt|,
name|b3
decl_stmt|,
name|b4
decl_stmt|,
name|b5
decl_stmt|;
name|int
name|magic
decl_stmt|;
comment|/* If we have an extension, see if we recognize it as implying a      particular format.  */
name|ext
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|format_map
modifier|*
name|m
decl_stmt|;
operator|++
name|ext
expr_stmt|;
for|for
control|(
name|m
operator|=
name|format_fileexts
init|;
name|m
operator|->
name|name
operator|!=
name|NULL
condition|;
name|m
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|m
operator|->
name|name
argument_list|,
name|ext
argument_list|)
operator|==
literal|0
condition|)
return|return
name|m
operator|->
name|format
return|;
block|}
comment|/* If we don't recognize the name of an output file, assume it's a      COFF file.  */
if|if
condition|(
operator|!
name|input
condition|)
return|return
name|RES_FORMAT_COFF
return|;
comment|/* Read the first few bytes of the file to see if we can guess what      it is.  */
name|e
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|b1
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|b2
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|b3
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|b4
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|b5
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* A PE executable starts with 0x4d 0x5a.  */
if|if
condition|(
name|b1
operator|==
literal|0x4d
operator|&&
name|b2
operator|==
literal|0x5a
condition|)
return|return
name|RES_FORMAT_COFF
return|;
comment|/* A COFF .o file starts with a COFF magic number.  */
name|magic
operator|=
operator|(
name|b2
operator|<<
literal|8
operator|)
operator||
name|b1
expr_stmt|;
switch|switch
condition|(
name|magic
condition|)
block|{
case|case
literal|0x14c
case|:
comment|/* i386 */
case|case
literal|0x166
case|:
comment|/* MIPS */
case|case
literal|0x184
case|:
comment|/* Alpha */
case|case
literal|0x268
case|:
comment|/* 68k */
case|case
literal|0x1f0
case|:
comment|/* PowerPC */
case|case
literal|0x290
case|:
comment|/* PA */
return|return
name|RES_FORMAT_COFF
return|;
block|}
comment|/* A RES file starts with 0x0 0x0 0x0 0x0 0x20 0x0 0x0 0x0.  */
if|if
condition|(
name|b1
operator|==
literal|0
operator|&&
name|b2
operator|==
literal|0
operator|&&
name|b3
operator|==
literal|0
operator|&&
name|b4
operator|==
literal|0
operator|&&
name|b5
operator|==
literal|0x20
condition|)
return|return
name|RES_FORMAT_RES
return|;
comment|/* If every character is printable or space, assume it's an RC file.  */
if|if
condition|(
operator|(
name|ISPRINT
argument_list|(
name|b1
argument_list|)
operator|||
name|ISSPACE
argument_list|(
name|b1
argument_list|)
operator|)
operator|&&
operator|(
name|ISPRINT
argument_list|(
name|b2
argument_list|)
operator|||
name|ISSPACE
argument_list|(
name|b2
argument_list|)
operator|)
operator|&&
operator|(
name|ISPRINT
argument_list|(
name|b3
argument_list|)
operator|||
name|ISSPACE
argument_list|(
name|b3
argument_list|)
operator|)
operator|&&
operator|(
name|ISPRINT
argument_list|(
name|b4
argument_list|)
operator|||
name|ISSPACE
argument_list|(
name|b4
argument_list|)
operator|)
operator|&&
operator|(
name|ISPRINT
argument_list|(
name|b5
argument_list|)
operator|||
name|ISSPACE
argument_list|(
name|b5
argument_list|)
operator|)
condition|)
return|return
name|RES_FORMAT_RC
return|;
comment|/* Otherwise, we give up.  */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"can not determine type of file `%s'; use the -J option"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Return something to silence the compiler warning.  */
return|return
name|RES_FORMAT_UNKNOWN
return|;
block|}
end_function

begin_comment
comment|/* Print a usage message and exit.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Usage: %s [option(s)] [input-file] [output-file]\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" The options are:\n\   -i --input=<file>            Name input file\n\   -o --output=<file>           Name output file\n\   -J --input-format=<format>   Specify input format\n\   -O --output-format=<format>  Specify output format\n\   -F --target=<target>         Specify COFF target\n\      --preprocessor=<program>  Program to use to preprocess rc file\n\   -I --include-dir=<dir>       Include directory when preprocessing rc file\n\   -D --define<sym>[=<val>]    Define SYM when preprocessing rc file\n\   -U --undefine<sym>          Undefine SYM when preprocessing rc file\n\   -v --verbose                 Verbose - tells you what it's doing\n\   -c --codepage=<codepage>     Specify default codepage\n\   -l --language=<val>          Set language when reading rc file\n\      --use-temp-file           Use a temporary file instead of popen to read\n\                                the preprocessor output\n\      --no-use-temp-file        Use popen (default)\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YYDEBUG
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\      --yydebug                 Turn on parser debugging\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -r                           Ignored for compatibility with rc\n\   @<file>                      Read options from<file>\n\   -h --help                    Print this help message\n\   -V --version                 Print version information\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ FORMAT is one of rc, res, or coff, and is deduced from the file name\n\ extension if not specified.  A single file name is an input file.\n\ No input-file is stdin, default rc.  No output-file is stdout, default rc.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|REPORT_BUGS_TO
index|[
literal|0
index|]
operator|&&
name|status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Quote characters that will confuse the shell when we run the preprocessor.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|quot
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|buf
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|buflen
init|=
literal|0
decl_stmt|;
name|int
name|slen
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
if|if
condition|(
operator|(
name|buflen
operator|<
name|slen
operator|*
literal|2
operator|+
literal|2
operator|)
operator|||
operator|!
name|buf
condition|)
block|{
name|buflen
operator|=
name|slen
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|src
operator|=
name|string
operator|,
name|dest
operator|=
name|buf
init|;
operator|*
name|src
condition|;
name|src
operator|++
operator|,
name|dest
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'('
operator|||
operator|*
name|src
operator|==
literal|')'
operator|||
operator|*
name|src
operator|==
literal|' '
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dest
operator|=
operator|*
name|src
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Long options.  */
end_comment

begin_comment
comment|/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */
end_comment

begin_define
define|#
directive|define
name|OPTION_PREPROCESSOR
value|150
end_define

begin_define
define|#
directive|define
name|OPTION_USE_TEMP_FILE
value|(OPTION_PREPROCESSOR + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_USE_TEMP_FILE
value|(OPTION_USE_TEMP_FILE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_YYDEBUG
value|(OPTION_NO_USE_TEMP_FILE + 1)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"input"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"output"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"input-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'J'
block|}
block|,
block|{
literal|"output-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
block|{
literal|"target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"preprocessor"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_PREPROCESSOR
block|}
block|,
block|{
literal|"include-dir"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"define"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'D'
block|}
block|,
block|{
literal|"undefine"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'U'
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"codepage"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"language"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"use-temp-file"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_USE_TEMP_FILE
block|}
block|,
block|{
literal|"no-use-temp-file"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_NO_USE_TEMP_FILE
block|}
block|,
block|{
literal|"yydebug"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_YYDEBUG
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This keeps gcc happy when using -Wmissing-prototypes -Wstrict-prototypes.  */
end_comment

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The main function.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|input_filename
decl_stmt|;
name|char
modifier|*
name|output_filename
decl_stmt|;
name|enum
name|res_format
name|input_format
decl_stmt|;
name|enum
name|res_format
name|input_format_tmp
decl_stmt|;
name|enum
name|res_format
name|output_format
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|;
name|char
modifier|*
name|preprocessor
decl_stmt|;
name|char
modifier|*
name|preprocargs
decl_stmt|;
specifier|const
name|char
modifier|*
name|quotedarg
decl_stmt|;
name|int
name|language
decl_stmt|;
name|rc_res_directory
modifier|*
name|resources
decl_stmt|;
name|int
name|use_temp_file
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|expandargv
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|set_default_bfd_target
argument_list|()
expr_stmt|;
name|res_init
argument_list|()
expr_stmt|;
name|input_filename
operator|=
name|NULL
expr_stmt|;
name|output_filename
operator|=
name|NULL
expr_stmt|;
name|input_format
operator|=
name|RES_FORMAT_UNKNOWN
expr_stmt|;
name|output_format
operator|=
name|RES_FORMAT_UNKNOWN
expr_stmt|;
name|target
operator|=
name|NULL
expr_stmt|;
name|preprocessor
operator|=
name|NULL
expr_stmt|;
name|preprocargs
operator|=
name|NULL
expr_stmt|;
name|language
operator|=
literal|0x409
expr_stmt|;
comment|/* LANG_ENGLISH, SUBLANG_ENGLISH_US.  */
name|use_temp_file
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:f:i:l:o:I:J:O:F:D:U:rhHvV"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
block|{
name|rc_uint_type
name|ncp
decl_stmt|;
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|optarg
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|optarg
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
name|ncp
operator|=
operator|(
name|rc_uint_type
operator|)
name|strtol
argument_list|(
name|optarg
operator|+
literal|2
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|ncp
operator|=
operator|(
name|rc_uint_type
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncp
operator|==
name|CP_UTF16
operator|||
operator|!
name|unicode_is_valid_codepage
argument_list|(
name|ncp
argument_list|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"invalid codepage specified.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|wind_default_codepage
operator|=
name|wind_current_codepage
operator|=
name|ncp
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
name|input_filename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* For compatibility with rc we accept "-fo<name>" as being the 	     equivalent of "-o<name>".  We do not advertise this fact 	     though, as we do not want users to use non-GNU like command 	     line switches.  */
if|if
condition|(
operator|*
name|optarg
operator|!=
literal|'o'
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"invalid option -f\n"
argument_list|)
argument_list|)
expr_stmt|;
name|optarg
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|optarg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"No filename following the -fo option.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|optarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
literal|'o'
case|:
name|output_filename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|input_format
operator|=
name|format_from_name
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|output_format
operator|=
name|format_from_name
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_PREPROCESSOR
case|:
name|preprocessor
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'U'
case|:
if|if
condition|(
name|preprocargs
operator|==
name|NULL
condition|)
block|{
name|quotedarg
operator|=
name|quot
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|preprocargs
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|quotedarg
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|preprocargs
argument_list|,
literal|"-%c%s"
argument_list|,
name|c
argument_list|,
name|quotedarg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|quotedarg
operator|=
name|quot
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|n
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|preprocargs
argument_list|)
operator|+
name|strlen
argument_list|(
name|quotedarg
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|n
argument_list|,
literal|"%s -%c%s"
argument_list|,
name|preprocargs
argument_list|,
name|c
argument_list|,
name|quotedarg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|preprocargs
argument_list|)
expr_stmt|;
name|preprocargs
operator|=
name|n
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* Ignored for compatibility with rc.  */
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* For backward compatibility, should be removed in the future.  */
name|input_format_tmp
operator|=
name|format_from_name
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_format_tmp
operator|!=
name|RES_FORMAT_UNKNOWN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Option -I is deprecated for setting the input format, please use -J instead.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|input_format
operator|=
name|input_format_tmp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|preprocargs
operator|==
name|NULL
condition|)
block|{
name|quotedarg
operator|=
name|quot
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|preprocargs
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|quotedarg
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|preprocargs
argument_list|,
literal|"-I%s"
argument_list|,
name|quotedarg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|quotedarg
operator|=
name|quot
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|n
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|preprocargs
argument_list|)
operator|+
name|strlen
argument_list|(
name|quotedarg
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|n
argument_list|,
literal|"%s -I%s"
argument_list|,
name|preprocargs
argument_list|,
name|quotedarg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|preprocargs
argument_list|)
expr_stmt|;
name|preprocargs
operator|=
name|n
expr_stmt|;
block|}
block|{
name|struct
name|include_dir
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|include_dir
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|dir
operator|=
name|optarg
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|include_dirs
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|n
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
name|language
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_USE_TEMP_FILE
case|:
name|use_temp_file
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_USE_TEMP_FILE
case|:
name|use_temp_file
operator|=
literal|0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|YYDEBUG
case|case
name|OPTION_YYDEBUG
case|:
name|yydebug
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|print_version
argument_list|(
literal|"windres"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|input_filename
operator|==
name|NULL
operator|&&
name|optind
operator|<
name|argc
condition|)
block|{
name|input_filename
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
operator|++
name|optind
expr_stmt|;
block|}
if|if
condition|(
name|output_filename
operator|==
name|NULL
operator|&&
name|optind
operator|<
name|argc
condition|)
block|{
name|output_filename
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
operator|++
name|optind
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
name|optind
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_format
operator|==
name|RES_FORMAT_UNKNOWN
condition|)
block|{
if|if
condition|(
name|input_filename
operator|==
name|NULL
condition|)
name|input_format
operator|=
name|RES_FORMAT_RC
expr_stmt|;
else|else
name|input_format
operator|=
name|format_from_filename
argument_list|(
name|input_filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_format
operator|==
name|RES_FORMAT_UNKNOWN
condition|)
block|{
if|if
condition|(
name|output_filename
operator|==
name|NULL
condition|)
name|output_format
operator|=
name|RES_FORMAT_RC
expr_stmt|;
else|else
name|output_format
operator|=
name|format_from_filename
argument_list|(
name|output_filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|set_endianess
argument_list|(
name|NULL
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Read the input file.  */
switch|switch
condition|(
name|input_format
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|RES_FORMAT_RC
case|:
name|resources
operator|=
name|read_rc_file
argument_list|(
name|input_filename
argument_list|,
name|preprocessor
argument_list|,
name|preprocargs
argument_list|,
name|language
argument_list|,
name|use_temp_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_FORMAT_RES
case|:
name|resources
operator|=
name|read_res_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_FORMAT_COFF
case|:
name|resources
operator|=
name|read_coff_rsrc
argument_list|(
name|input_filename
argument_list|,
name|target
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|resources
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"no resources"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sort the resources.  This is required for COFF, convenient for      rc, and unimportant for res.  */
name|resources
operator|=
name|sort_resources
argument_list|(
name|resources
argument_list|)
expr_stmt|;
comment|/* Write the output file.  */
name|reswr_init
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|output_format
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|RES_FORMAT_RC
case|:
name|write_rc_file
argument_list|(
name|output_filename
argument_list|,
name|resources
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_FORMAT_RES
case|:
name|write_res_file
argument_list|(
name|output_filename
argument_list|,
name|resources
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_FORMAT_COFF
case|:
name|write_coff_file
argument_list|(
name|output_filename
argument_list|,
name|target
argument_list|,
name|resources
argument_list|)
expr_stmt|;
break|break;
block|}
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_endianess
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
specifier|const
name|bfd_target
modifier|*
name|target_vec
decl_stmt|;
name|def_target_arch
operator|=
name|NULL
expr_stmt|;
name|target_vec
operator|=
name|bfd_find_target
argument_list|(
name|target
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_vec
condition|)
name|fatal
argument_list|(
literal|"Can't detect target endianess and architecture."
argument_list|)
expr_stmt|;
name|target_is_bigendian
operator|=
operator|(
operator|(
name|target_vec
operator|->
name|byteorder
operator|==
name|BFD_ENDIAN_BIG
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|tname
init|=
name|target_vec
operator|->
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|arch
init|=
name|bfd_arch_list
argument_list|()
decl_stmt|;
if|if
condition|(
name|arch
operator|&&
name|tname
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|tname
argument_list|,
literal|'-'
argument_list|)
operator|!=
name|NULL
condition|)
name|tname
operator|=
name|strchr
argument_list|(
name|tname
argument_list|,
literal|'-'
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|arch
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|in_a
init|=
name|strstr
argument_list|(
operator|*
name|arch
argument_list|,
name|tname
argument_list|)
decl_stmt|;
name|char
name|end_ch
init|=
operator|(
name|in_a
condition|?
name|in_a
index|[
name|strlen
argument_list|(
name|tname
argument_list|)
index|]
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|in_a
operator|&&
operator|(
name|in_a
operator|==
operator|*
name|arch
operator|||
name|in_a
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
operator|)
operator|&&
name|end_ch
operator|==
literal|0
condition|)
block|{
name|def_target_arch
operator|=
operator|*
name|arch
expr_stmt|;
break|break;
block|}
name|arch
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|def_target_arch
condition|)
name|fatal
argument_list|(
literal|"Can't detect architecture."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bfd
modifier|*
name|windres_open_as_binary
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|rdmode
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|abfd
operator|=
operator|(
name|rdmode
condition|?
name|bfd_openr
argument_list|(
name|filename
argument_list|,
literal|"binary"
argument_list|)
else|:
name|bfd_openw
argument_list|(
name|filename
argument_list|,
literal|"binary"
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
name|fatal
argument_list|(
literal|"can't open `%s' for %s"
argument_list|,
name|filename
argument_list|,
operator|(
name|rdmode
condition|?
literal|"input"
else|:
literal|"output"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdmode
operator|&&
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"can't open `%s' for input."
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|abfd
return|;
block|}
end_function

begin_function
name|void
name|set_windres_bfd_endianess
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|int
name|is_bigendian
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|!
name|wrbfd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|WR_KIND
argument_list|(
name|wrbfd
argument_list|)
condition|)
block|{
case|case
name|WR_KIND_BFD_BIN_L
case|:
if|if
condition|(
name|is_bigendian
condition|)
name|WR_KIND
argument_list|(
name|wrbfd
argument_list|)
operator|=
name|WR_KIND_BFD_BIN_B
expr_stmt|;
break|break;
case|case
name|WR_KIND_BFD_BIN_B
case|:
if|if
condition|(
operator|!
name|is_bigendian
condition|)
name|WR_KIND
argument_list|(
name|wrbfd
argument_list|)
operator|=
name|WR_KIND_BFD_BIN_L
expr_stmt|;
break|break;
default|default:
comment|/* only binary bfd can be overriden. */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|set_windres_bfd
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|rc_uint_type
name|kind
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|!
name|wrbfd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|WR_KIND_TARGET
case|:
name|abfd
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|WR_KIND_BFD
case|:
case|case
name|WR_KIND_BFD_BIN_L
case|:
case|case
name|WR_KIND_BFD_BIN_B
case|:
name|assert
argument_list|(
operator|!
operator|!
name|abfd
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|!
name|sec
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|WR_KIND
argument_list|(
name|wrbfd
argument_list|)
operator|=
name|kind
expr_stmt|;
name|WR_BFD
argument_list|(
name|wrbfd
argument_list|)
operator|=
name|abfd
expr_stmt|;
name|WR_SECTION
argument_list|(
name|wrbfd
argument_list|)
operator|=
name|sec
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_windres_bfd_content
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|rc_uint_type
name|off
parameter_list|,
name|rc_uint_type
name|length
parameter_list|)
block|{
if|if
condition|(
name|WR_KIND
argument_list|(
name|wrbfd
argument_list|)
operator|!=
name|WR_KIND_TARGET
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|WR_BFD
argument_list|(
name|wrbfd
argument_list|)
argument_list|,
name|WR_SECTION
argument_list|(
name|wrbfd
argument_list|)
argument_list|,
name|data
argument_list|,
name|off
argument_list|,
name|length
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_section_contents"
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|get_windres_bfd_content
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|rc_uint_type
name|off
parameter_list|,
name|rc_uint_type
name|length
parameter_list|)
block|{
if|if
condition|(
name|WR_KIND
argument_list|(
name|wrbfd
argument_list|)
operator|!=
name|WR_KIND_TARGET
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|WR_BFD
argument_list|(
name|wrbfd
argument_list|)
argument_list|,
name|WR_SECTION
argument_list|(
name|wrbfd
argument_list|)
argument_list|,
name|data
argument_list|,
name|off
argument_list|,
name|length
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_get_section_contents"
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|windres_put_8
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|rc_uint_type
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|WR_KIND
argument_list|(
name|wrbfd
argument_list|)
condition|)
block|{
case|case
name|WR_KIND_TARGET
case|:
name|target_put_8
argument_list|(
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|WR_KIND_BFD
case|:
case|case
name|WR_KIND_BFD_BIN_L
case|:
case|case
name|WR_KIND_BFD_BIN_B
case|:
name|bfd_put_8
argument_list|(
name|WR_BFD
argument_list|(
name|wrbfd
argument_list|)
argument_list|,
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|windres_put_16
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|rc_uint_type
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|WR_KIND
argument_list|(
name|wrbfd
argument_list|)
condition|)
block|{
case|case
name|WR_KIND_TARGET
case|:
name|target_put_16
argument_list|(
name|data
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|WR_KIND_BFD
case|:
case|case
name|WR_KIND_BFD_BIN_B
case|:
name|bfd_put_16
argument_list|(
name|WR_BFD
argument_list|(
name|wrbfd
argument_list|)
argument_list|,
name|value
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|WR_KIND_BFD_BIN_L
case|:
name|bfd_putl16
argument_list|(
name|value
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|windres_put_32
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|rc_uint_type
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|WR_KIND
argument_list|(
name|wrbfd
argument_list|)
condition|)
block|{
case|case
name|WR_KIND_TARGET
case|:
name|target_put_32
argument_list|(
name|data
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|WR_KIND_BFD
case|:
case|case
name|WR_KIND_BFD_BIN_B
case|:
name|bfd_put_32
argument_list|(
name|WR_BFD
argument_list|(
name|wrbfd
argument_list|)
argument_list|,
name|value
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|WR_KIND_BFD_BIN_L
case|:
name|bfd_putl32
argument_list|(
name|value
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|rc_uint_type
name|windres_get_8
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|rc_uint_type
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|<
literal|1
condition|)
name|fatal
argument_list|(
literal|"windres_get_8: unexpected eob."
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|WR_KIND
argument_list|(
name|wrbfd
argument_list|)
condition|)
block|{
case|case
name|WR_KIND_TARGET
case|:
return|return
name|target_get_8
argument_list|(
name|data
argument_list|,
name|length
argument_list|)
return|;
case|case
name|WR_KIND_BFD
case|:
case|case
name|WR_KIND_BFD_BIN_B
case|:
case|case
name|WR_KIND_BFD_BIN_L
case|:
return|return
name|bfd_get_8
argument_list|(
name|WR_BFD
argument_list|(
name|wrbfd
argument_list|)
argument_list|,
name|data
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|rc_uint_type
name|windres_get_16
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|rc_uint_type
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|<
literal|2
condition|)
name|fatal
argument_list|(
literal|"windres_get_16: unexpected eob."
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|WR_KIND
argument_list|(
name|wrbfd
argument_list|)
condition|)
block|{
case|case
name|WR_KIND_TARGET
case|:
return|return
name|target_get_16
argument_list|(
name|data
argument_list|,
name|length
argument_list|)
return|;
case|case
name|WR_KIND_BFD
case|:
case|case
name|WR_KIND_BFD_BIN_B
case|:
return|return
name|bfd_get_16
argument_list|(
name|WR_BFD
argument_list|(
name|wrbfd
argument_list|)
argument_list|,
name|data
argument_list|)
return|;
case|case
name|WR_KIND_BFD_BIN_L
case|:
return|return
name|bfd_getl16
argument_list|(
name|data
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|rc_uint_type
name|windres_get_32
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|rc_uint_type
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|<
literal|4
condition|)
name|fatal
argument_list|(
literal|"windres_get_32: unexpected eob."
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|WR_KIND
argument_list|(
name|wrbfd
argument_list|)
condition|)
block|{
case|case
name|WR_KIND_TARGET
case|:
return|return
name|target_get_32
argument_list|(
name|data
argument_list|,
name|length
argument_list|)
return|;
case|case
name|WR_KIND_BFD
case|:
case|case
name|WR_KIND_BFD_BIN_B
case|:
return|return
name|bfd_get_32
argument_list|(
name|WR_BFD
argument_list|(
name|wrbfd
argument_list|)
argument_list|,
name|data
argument_list|)
return|;
case|case
name|WR_KIND_BFD_BIN_L
case|:
return|return
name|bfd_getl32
argument_list|(
name|data
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|rc_uint_type
name|target_get_8
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
name|rc_uint_type
name|length
parameter_list|)
block|{
name|rc_uint_type
name|ret
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|1
condition|)
name|fatal
argument_list|(
literal|"Resource too small for getting 8-bit value."
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|rc_uint_type
operator|)
operator|*
operator|(
operator|(
specifier|const
name|bfd_byte
operator|*
operator|)
name|p
operator|)
expr_stmt|;
return|return
name|ret
operator|&
literal|0xff
return|;
block|}
end_function

begin_function
specifier|static
name|rc_uint_type
name|target_get_16
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
name|rc_uint_type
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|<
literal|2
condition|)
name|fatal
argument_list|(
literal|"Resource too small for getting 16-bit value."
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_is_bigendian
condition|)
return|return
name|bfd_getb16
argument_list|(
name|p
argument_list|)
return|;
else|else
return|return
name|bfd_getl16
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rc_uint_type
name|target_get_32
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
name|rc_uint_type
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|<
literal|4
condition|)
name|fatal
argument_list|(
literal|"Resource too small for getting 32-bit value."
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_is_bigendian
condition|)
return|return
name|bfd_getb32
argument_list|(
name|p
argument_list|)
return|;
else|else
return|return
name|bfd_getl32
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|target_put_8
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|rc_uint_type
name|value
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|!
name|p
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|p
operator|)
operator|=
operator|(
name|bfd_byte
operator|)
name|value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|target_put_16
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|rc_uint_type
name|value
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|!
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_is_bigendian
condition|)
name|bfd_putb16
argument_list|(
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|bfd_putl16
argument_list|(
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|target_put_32
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|rc_uint_type
name|value
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|!
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_is_bigendian
condition|)
name|bfd_putb32
argument_list|(
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|bfd_putl32
argument_list|(
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|isInComment
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|wr_printcomment
parameter_list|(
name|FILE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|arg
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isInComment
condition|)
name|r
operator|+=
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n   "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"/* "
argument_list|)
expr_stmt|;
name|isInComment
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
return|return
name|r
return|;
name|va_start
argument_list|(
name|arg
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|r
operator|+=
name|vfprintf
argument_list|(
name|e
argument_list|,
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|wr_print
parameter_list|(
name|FILE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|arg
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isInComment
condition|)
name|r
operator|+=
name|fprintf
argument_list|(
name|e
argument_list|,
literal|".  */\n"
argument_list|)
expr_stmt|;
name|isInComment
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fmt
condition|)
return|return
name|r
return|;
name|va_start
argument_list|(
name|arg
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|r
operator|+=
name|vfprintf
argument_list|(
name|e
argument_list|,
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

end_unit

