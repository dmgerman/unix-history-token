begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* nlmconv.c -- NLM conversion program    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,    2003, 2004, 2005 Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Written by Ian Lance Taylor<ian@cygnus.com>.     This program can be used to convert any appropriate object file    into a NetWare Loadable Module (an NLM).  It will accept a linker    specification file which is identical to that accepted by the    NetWare linker, NLMLINK.  */
end_comment

begin_comment
comment|/* AIX requires this to be the first thing in the file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/* Internal BFD NLM header.  */
end_comment

begin_include
include|#
directive|include
file|"libnlm.h"
end_include

begin_include
include|#
directive|include
file|"nlmconv.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NLMCONV_ALPHA
end_ifdef

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If strerror is just a macro, we want to use the one from libiberty    since it will handle undefined values.  */
end_comment

begin_undef
undef|#
directive|undef
name|strerror
end_undef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strerror
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_SET
end_ifndef

begin_define
define|#
directive|define
name|SEEK_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_OK
end_ifndef

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_define
define|#
directive|define
name|W_OK
value|2
end_define

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Global variables.  */
end_comment

begin_comment
comment|/* The name used to invoke the program.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local variables.  */
end_comment

begin_comment
comment|/* Whether to print out debugging information (currently just controls    whether it prints the linker command if there is one).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The symbol table.  */
end_comment

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A section we create in the output file to hold pointers to where    the sections of the input file end up.  We will put a pointer to    this section in the NLM header.  These is an entry for each input    section.  The format is        null terminated section name        zeroes to adjust to 4 byte boundary        4 byte section data file pointer        4 byte section size    We don't need a version number.  The way we find this information    is by finding a stamp in the NLM header information.  If we need to    change the format of this information, we can simply change the    stamp.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|secsec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A temporary file name to be unlinked on exit.  Actually, for most    errors, we leave it around.  It's not clear whether that is helpful    or not.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|unlink_on_exit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of long options.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"debug"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"header-file"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'T'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"input-target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"input-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"linker"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"output-target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
block|{
literal|"output-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local routines.  */
end_comment

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_usage
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|select_output_format
parameter_list|(
name|enum
name|bfd_architecture
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_sections
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_sections
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mangle_relocs
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|arelent
modifier|*
modifier|*
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|bfd_size_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_mangle_relocs
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|arelent
modifier|*
modifier|*
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|bfd_size_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|link_inputs
parameter_list|(
name|struct
name|string_list
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|NLMCONV_I386
end_ifdef

begin_function_decl
specifier|static
name|void
name|i386_mangle_relocs
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|arelent
modifier|*
modifier|*
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|bfd_size_type
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NLMCONV_ALPHA
end_ifdef

begin_function_decl
specifier|static
name|void
name|alpha_mangle_relocs
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|arelent
modifier|*
modifier|*
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|bfd_size_type
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NLMCONV_POWERPC
end_ifdef

begin_function_decl
specifier|static
name|void
name|powerpc_build_stubs
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asymbol
modifier|*
modifier|*
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|powerpc_resolve_stubs
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|powerpc_mangle_relocs
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|arelent
modifier|*
modifier|*
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|bfd_size_type
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* The main routine.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|opt
decl_stmt|;
name|char
modifier|*
name|input_file
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|input_format
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|output_format
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|header_file
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ld_arg
init|=
name|NULL
decl_stmt|;
name|Nlm_Internal_Fixed_Header
name|fixed_hdr_struct
decl_stmt|;
name|Nlm_Internal_Variable_Header
name|var_hdr_struct
decl_stmt|;
name|Nlm_Internal_Version_Header
name|version_hdr_struct
decl_stmt|;
name|Nlm_Internal_Copyright_Header
name|copyright_hdr_struct
decl_stmt|;
name|Nlm_Internal_Extended_Header
name|extended_hdr_struct
decl_stmt|;
name|bfd
modifier|*
name|inbfd
decl_stmt|;
name|bfd
modifier|*
name|outbfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|newsyms
decl_stmt|,
modifier|*
modifier|*
name|outsyms
decl_stmt|;
name|long
name|symcount
decl_stmt|,
name|newsymalloc
decl_stmt|,
name|newsymcount
decl_stmt|;
name|long
name|symsize
decl_stmt|;
name|asection
modifier|*
name|text_sec
decl_stmt|,
modifier|*
name|bss_sec
decl_stmt|,
modifier|*
name|data_sec
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|bfd_size_type
name|align
decl_stmt|;
name|asymbol
modifier|*
name|endsym
decl_stmt|;
name|long
name|i
decl_stmt|;
name|char
name|inlead
decl_stmt|,
name|outlead
decl_stmt|;
name|bfd_boolean
name|gotstart
decl_stmt|,
name|gotexit
decl_stmt|,
name|gotcheck
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|FILE
modifier|*
name|custom_data
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|help_data
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|message_data
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|rpc_data
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|shared_data
init|=
name|NULL
decl_stmt|;
name|size_t
name|custom_size
init|=
literal|0
decl_stmt|;
name|size_t
name|help_size
init|=
literal|0
decl_stmt|;
name|size_t
name|message_size
init|=
literal|0
decl_stmt|;
name|size_t
name|module_size
init|=
literal|0
decl_stmt|;
name|size_t
name|rpc_size
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|custom_section
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|help_section
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|message_section
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|module_section
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|rpc_section
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|shared_section
init|=
name|NULL
decl_stmt|;
name|bfd
modifier|*
name|sharedbfd
decl_stmt|;
name|size_t
name|shared_offset
init|=
literal|0
decl_stmt|;
name|size_t
name|shared_size
init|=
literal|0
decl_stmt|;
specifier|static
name|Nlm_Internal_Fixed_Header
name|sharedhdr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|modname
decl_stmt|;
name|char
modifier|*
modifier|*
name|matching
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|expandargv
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|set_default_bfd_target
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"dHhI:l:O:T:Vv"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'d'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
name|show_usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|input_format
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|ld_arg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|output_format
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|header_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|print_version
argument_list|(
literal|"nlmconv"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
default|default:
name|show_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* The input and output files may be named on the command line.  */
name|output_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|input_file
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
operator|++
name|optind
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|output_file
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
operator|++
name|optind
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|show_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|input_file
argument_list|,
name|output_file
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"input and output files must be different"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Initialize the header information to default values.  */
name|fixed_hdr
operator|=
operator|&
name|fixed_hdr_struct
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|fixed_hdr_struct
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|fixed_hdr_struct
argument_list|)
expr_stmt|;
name|var_hdr
operator|=
operator|&
name|var_hdr_struct
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|var_hdr_struct
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|var_hdr_struct
argument_list|)
expr_stmt|;
name|version_hdr
operator|=
operator|&
name|version_hdr_struct
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|version_hdr_struct
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|version_hdr_struct
argument_list|)
expr_stmt|;
name|copyright_hdr
operator|=
operator|&
name|copyright_hdr_struct
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|copyright_hdr_struct
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|copyright_hdr_struct
argument_list|)
expr_stmt|;
name|extended_hdr
operator|=
operator|&
name|extended_hdr_struct
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|extended_hdr_struct
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|extended_hdr_struct
argument_list|)
expr_stmt|;
name|check_procedure
operator|=
name|NULL
expr_stmt|;
name|custom_file
operator|=
name|NULL
expr_stmt|;
name|debug_info
operator|=
name|FALSE
expr_stmt|;
name|exit_procedure
operator|=
literal|"_Stop"
expr_stmt|;
name|export_symbols
operator|=
name|NULL
expr_stmt|;
name|map_file
operator|=
name|NULL
expr_stmt|;
name|full_map
operator|=
name|FALSE
expr_stmt|;
name|help_file
operator|=
name|NULL
expr_stmt|;
name|import_symbols
operator|=
name|NULL
expr_stmt|;
name|message_file
operator|=
name|NULL
expr_stmt|;
name|modules
operator|=
name|NULL
expr_stmt|;
name|sharelib_file
operator|=
name|NULL
expr_stmt|;
name|start_procedure
operator|=
literal|"_Prelude"
expr_stmt|;
name|verbose
operator|=
name|FALSE
expr_stmt|;
name|rpc_file
operator|=
name|NULL
expr_stmt|;
name|parse_errors
operator|=
literal|0
expr_stmt|;
comment|/* Parse the header file (if there is one).  */
if|if
condition|(
name|header_file
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|nlmlex_file
argument_list|(
name|header_file
argument_list|)
operator|||
name|yyparse
argument_list|()
operator|!=
literal|0
operator|||
name|parse_errors
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input_files
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|input_file
operator|!=
name|NULL
condition|)
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"input file named both on command line and with INPUT"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input_files
operator|->
name|next
operator|==
name|NULL
condition|)
name|input_file
operator|=
name|input_files
operator|->
name|string
expr_stmt|;
else|else
name|input_file
operator|=
name|link_inputs
argument_list|(
name|input_files
argument_list|,
name|ld_arg
argument_list|,
name|map_file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|input_file
operator|==
name|NULL
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"no input file"
argument_list|)
argument_list|)
expr_stmt|;
name|show_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|inbfd
operator|=
name|bfd_openr
argument_list|(
name|input_file
argument_list|,
name|input_format
argument_list|)
expr_stmt|;
if|if
condition|(
name|inbfd
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format_matches
argument_list|(
name|inbfd
argument_list|,
name|bfd_object
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|list_matching_formats
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matching
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_format
operator|==
name|NULL
condition|)
name|output_format
operator|=
name|select_output_format
argument_list|(
name|bfd_get_arch
argument_list|(
name|inbfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|inbfd
argument_list|)
argument_list|,
name|bfd_big_endian
argument_list|(
name|inbfd
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|output_format
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Use the output file named on the command line if it exists.      Otherwise use the file named in the OUTPUT statement.  */
if|if
condition|(
name|output_file
operator|==
name|NULL
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"no name for output file"
argument_list|)
argument_list|)
expr_stmt|;
name|show_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|outbfd
operator|=
name|bfd_openw
argument_list|(
name|output_file
argument_list|,
name|output_format
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbfd
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|outbfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bfd_get_flavour
argument_list|(
name|outbfd
argument_list|)
operator|==
name|bfd_target_nlm_flavour
argument_list|)
expr_stmt|;
comment|/* XXX: Should we accept the unknown bfd format here ?  */
if|if
condition|(
name|bfd_arch_get_compatible
argument_list|(
name|inbfd
argument_list|,
name|outbfd
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"warning: input and output formats are not compatible"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move the values read from the command file into outbfd.  */
operator|*
name|nlm_fixed_header
argument_list|(
name|outbfd
argument_list|)
operator|=
name|fixed_hdr_struct
expr_stmt|;
operator|*
name|nlm_variable_header
argument_list|(
name|outbfd
argument_list|)
operator|=
name|var_hdr_struct
expr_stmt|;
operator|*
name|nlm_version_header
argument_list|(
name|outbfd
argument_list|)
operator|=
name|version_hdr_struct
expr_stmt|;
operator|*
name|nlm_copyright_header
argument_list|(
name|outbfd
argument_list|)
operator|=
name|copyright_hdr_struct
expr_stmt|;
operator|*
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|=
name|extended_hdr_struct
expr_stmt|;
comment|/* Start copying the input BFD to the output BFD.  */
if|if
condition|(
operator|!
name|bfd_set_file_flags
argument_list|(
name|outbfd
argument_list|,
name|bfd_get_file_flags
argument_list|(
name|inbfd
argument_list|)
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|outbfd
argument_list|)
argument_list|)
expr_stmt|;
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|inbfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsize
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
name|symbols
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|inbfd
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
comment|/* Make sure we have a .bss section.  */
name|bss_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|outbfd
argument_list|,
name|NLM_UNINITIALIZED_DATA_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|bss_sec
operator|==
name|NULL
condition|)
block|{
name|bss_sec
operator|=
name|bfd_make_section
argument_list|(
name|outbfd
argument_list|,
name|NLM_UNINITIALIZED_DATA_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|bss_sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|outbfd
argument_list|,
name|bss_sec
argument_list|,
name|SEC_ALLOC
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|outbfd
argument_list|,
name|bss_sec
argument_list|,
literal|1
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"make .bss section"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We store the original section names in the .nlmsections section,      so that programs which understand it can resurrect the original      sections from the NLM.  We will put a pointer to .nlmsections in      the NLM header area.  */
name|secsec
operator|=
name|bfd_make_section
argument_list|(
name|outbfd
argument_list|,
literal|".nlmsections"
argument_list|)
expr_stmt|;
if|if
condition|(
name|secsec
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"make .nlmsections section"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|outbfd
argument_list|,
name|secsec
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"set .nlmsections flags"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NLMCONV_POWERPC
comment|/* For PowerPC NetWare we need to build stubs for calls to undefined      symbols.  Because each stub requires an entry in the TOC section      which must be at the same location as other entries in the TOC      section, we must do this before determining where the TOC section      goes in setup_sections.  */
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|inbfd
argument_list|)
operator|==
name|bfd_arch_powerpc
condition|)
name|powerpc_build_stubs
argument_list|(
name|inbfd
argument_list|,
name|outbfd
argument_list|,
operator|&
name|symbols
argument_list|,
operator|&
name|symcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set up the sections.  */
name|bfd_map_over_sections
argument_list|(
name|inbfd
argument_list|,
name|setup_sections
argument_list|,
operator|(
name|void
operator|*
operator|)
name|outbfd
argument_list|)
expr_stmt|;
name|text_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|outbfd
argument_list|,
name|NLM_CODE_NAME
argument_list|)
expr_stmt|;
comment|/* The .bss section immediately follows the .data section.  */
name|data_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|outbfd
argument_list|,
name|NLM_INITIALIZED_DATA_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_sec
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|add
decl_stmt|;
name|vma
operator|=
name|bfd_get_section_size
argument_list|(
name|data_sec
argument_list|)
expr_stmt|;
name|align
operator|=
literal|1
operator|<<
name|bss_sec
operator|->
name|alignment_power
expr_stmt|;
name|add
operator|=
operator|(
operator|(
name|vma
operator|+
name|align
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|-
name|vma
expr_stmt|;
name|vma
operator|+=
name|add
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_vma
argument_list|(
name|outbfd
argument_list|,
name|bss_sec
argument_list|,
name|vma
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"set .bss vma"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|data_size
decl_stmt|;
name|data_size
operator|=
name|bfd_get_section_size
argument_list|(
name|data_sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|outbfd
argument_list|,
name|data_sec
argument_list|,
name|data_size
operator|+
name|add
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"set .data size"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Adjust symbol information.  */
name|inlead
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|inbfd
argument_list|)
expr_stmt|;
name|outlead
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|outbfd
argument_list|)
expr_stmt|;
name|gotstart
operator|=
name|FALSE
expr_stmt|;
name|gotexit
operator|=
name|FALSE
expr_stmt|;
name|gotcheck
operator|=
name|FALSE
expr_stmt|;
name|newsymalloc
operator|=
literal|10
expr_stmt|;
name|newsyms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|newsymalloc
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|newsymcount
operator|=
literal|0
expr_stmt|;
name|endsym
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symcount
condition|;
name|i
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|symbols
index|[
name|i
index|]
expr_stmt|;
comment|/* Add or remove a leading underscore.  */
if|if
condition|(
name|inlead
operator|!=
name|outlead
condition|)
block|{
if|if
condition|(
name|inlead
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|==
name|inlead
condition|)
block|{
if|if
condition|(
name|outlead
operator|==
literal|'\0'
condition|)
operator|++
name|sym
operator|->
name|name
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new
index|[
literal|0
index|]
operator|=
name|outlead
expr_stmt|;
name|strcpy
argument_list|(
name|new
operator|+
literal|1
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sym
operator|->
name|name
operator|=
name|new
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|new
index|[
literal|0
index|]
operator|=
name|outlead
expr_stmt|;
name|strcpy
argument_list|(
name|new
operator|+
literal|1
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|->
name|name
operator|=
name|new
expr_stmt|;
block|}
block|}
comment|/* NLM's have an uninitialized data section, but they do not 	 have a common section in the Unix sense.  Move all common 	 symbols into the .bss section, and mark them as exported.  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|bfd_vma
name|size
init|=
name|sym
operator|->
name|value
decl_stmt|;
name|sym
operator|->
name|section
operator|=
name|bss_sec
expr_stmt|;
name|sym
operator|->
name|value
operator|=
name|bfd_get_section_size
argument_list|(
name|bss_sec
argument_list|)
expr_stmt|;
name|size
operator|+=
name|sym
operator|->
name|value
expr_stmt|;
name|align
operator|=
literal|1
operator|<<
name|bss_sec
operator|->
name|alignment_power
expr_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
name|align
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|outbfd
argument_list|,
name|bss_sec
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|sym
operator|->
name|flags
operator||=
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
comment|/* Move the symbol into the output section.  */
name|sym
operator|->
name|value
operator|+=
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|->
name|output_offset
expr_stmt|;
name|sym
operator|->
name|section
operator|=
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|->
name|output_section
expr_stmt|;
comment|/* This is no longer a section symbol.  */
name|sym
operator|->
name|flags
operator|&=
operator|~
name|BSF_SECTION_SYM
expr_stmt|;
block|}
comment|/* Force _edata and _end to be defined.  This would normally be 	 done by the linker, but the manipulation of the common 	 symbols will confuse it.  */
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|==
literal|0
operator|&&
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"_edata"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|section
operator|=
name|bss_sec
expr_stmt|;
name|sym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"_end"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|section
operator|=
name|bss_sec
expr_stmt|;
name|endsym
operator|=
name|sym
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NLMCONV_POWERPC
comment|/* For PowerPC NetWare, we define __GOT0.  This is the start 	     of the .got section.  */
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|inbfd
argument_list|)
operator|==
name|bfd_arch_powerpc
operator|&&
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"__GOT0"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
name|got_sec
decl_stmt|;
name|got_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|inbfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|got_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sym
operator|->
name|value
operator|=
name|got_sec
operator|->
name|output_offset
expr_stmt|;
name|sym
operator|->
name|section
operator|=
name|got_sec
operator|->
name|output_section
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* If this is a global symbol, check the export list.  */
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|string_list
modifier|*
name|l
decl_stmt|;
name|int
name|found_simple
decl_stmt|;
comment|/* Unfortunately, a symbol can appear multiple times on the 	     export list, with and without prefixes.  */
name|found_simple
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|export_symbols
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|l
operator|->
name|string
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|found_simple
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|zbase
decl_stmt|;
name|zbase
operator|=
name|strchr
argument_list|(
name|l
operator|->
name|string
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbase
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zbase
operator|+
literal|1
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We must add a symbol with this prefix.  */
if|if
condition|(
name|newsymcount
operator|>=
name|newsymalloc
condition|)
block|{
name|newsymalloc
operator|+=
literal|10
expr_stmt|;
name|newsyms
operator|=
operator|(
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|newsyms
argument_list|,
operator|(
name|newsymalloc
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|newsyms
index|[
name|newsymcount
index|]
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|newsyms
index|[
name|newsymcount
index|]
operator|=
operator|*
name|sym
expr_stmt|;
name|newsyms
index|[
name|newsymcount
index|]
operator|->
name|name
operator|=
name|l
operator|->
name|string
expr_stmt|;
operator|++
name|newsymcount
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found_simple
condition|)
block|{
comment|/* The unmodified symbol is actually not exported at 		 all.  */
name|sym
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BSF_GLOBAL
operator||
name|BSF_EXPORT
operator|)
expr_stmt|;
name|sym
operator|->
name|flags
operator||=
name|BSF_LOCAL
expr_stmt|;
block|}
block|}
comment|/* If it's an undefined symbol, see if it's on the import list. 	 Change the prefix if necessary.  */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|string_list
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|import_symbols
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|l
operator|->
name|string
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
else|else
block|{
name|char
modifier|*
name|zbase
decl_stmt|;
name|zbase
operator|=
name|strchr
argument_list|(
name|l
operator|->
name|string
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbase
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zbase
operator|+
literal|1
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|name
operator|=
name|l
operator|->
name|string
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|l
operator|==
name|NULL
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"warning: symbol %s imported but not in import list"
argument_list|)
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* See if it's one of the special named symbols.  */
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
comment|/* FIXME: If these symbols are not in the .text section, we 	     add the .text section size to the value.  This may not be 	     correct for all targets.  I'm not sure how this should 	     really be handled.  */
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|start_procedure
argument_list|)
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|==
name|data_sec
operator|&&
name|text_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|val
operator|+=
name|bfd_section_size
argument_list|(
name|outbfd
argument_list|,
name|text_sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_start_address
argument_list|(
name|outbfd
argument_list|,
name|val
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"set start address"
argument_list|)
argument_list|)
expr_stmt|;
name|gotstart
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|exit_procedure
argument_list|)
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|==
name|data_sec
operator|&&
name|text_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|val
operator|+=
name|bfd_section_size
argument_list|(
name|outbfd
argument_list|,
name|text_sec
argument_list|)
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|exitProcedureOffset
operator|=
name|val
expr_stmt|;
name|gotexit
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|check_procedure
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|check_procedure
argument_list|)
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|==
name|data_sec
operator|&&
name|text_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|val
operator|+=
name|bfd_section_size
argument_list|(
name|outbfd
argument_list|,
name|text_sec
argument_list|)
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|checkUnloadProcedureOffset
operator|=
name|val
expr_stmt|;
name|gotcheck
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|endsym
operator|!=
name|NULL
condition|)
block|{
name|endsym
operator|->
name|value
operator|=
name|bfd_get_section_size
argument_list|(
name|bss_sec
argument_list|)
expr_stmt|;
comment|/* FIXME: If any relocs referring to _end use inplace addends, 	 then I think they need to be updated.  This is handled by 	 i386_mangle_relocs.  Is it needed for any other object 	 formats?  */
block|}
if|if
condition|(
name|newsymcount
operator|==
literal|0
condition|)
name|outsyms
operator|=
name|symbols
expr_stmt|;
else|else
block|{
name|outsyms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|symcount
operator|+
name|newsymcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|outsyms
argument_list|,
name|symbols
argument_list|,
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|outsyms
operator|+
name|symcount
argument_list|,
name|newsyms
argument_list|,
name|newsymcount
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|outsyms
index|[
name|symcount
operator|+
name|newsymcount
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|bfd_set_symtab
argument_list|(
name|outbfd
argument_list|,
name|outsyms
argument_list|,
name|symcount
operator|+
name|newsymcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotstart
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"warning: START procedure %s not defined"
argument_list|)
argument_list|,
name|start_procedure
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotexit
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"warning: EXIT procedure %s not defined"
argument_list|)
argument_list|,
name|exit_procedure
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_procedure
operator|!=
name|NULL
operator|&&
operator|!
name|gotcheck
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"warning: CHECK procedure %s not defined"
argument_list|)
argument_list|,
name|check_procedure
argument_list|)
expr_stmt|;
comment|/* Add additional sections required for the header information.  */
if|if
condition|(
name|custom_file
operator|!=
name|NULL
condition|)
block|{
name|custom_data
operator|=
name|fopen
argument_list|(
name|custom_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|custom_data
operator|==
name|NULL
operator|||
name|fstat
argument_list|(
name|fileno
argument_list|(
name|custom_data
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|custom_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|custom_file
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|custom_size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|custom_section
operator|=
name|bfd_make_section
argument_list|(
name|outbfd
argument_list|,
literal|".nlmcustom"
argument_list|)
expr_stmt|;
if|if
condition|(
name|custom_section
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|outbfd
argument_list|,
name|custom_section
argument_list|,
name|custom_size
argument_list|)
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|outbfd
argument_list|,
name|custom_section
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"custom section"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|help_file
operator|!=
name|NULL
condition|)
block|{
name|help_data
operator|=
name|fopen
argument_list|(
name|help_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|help_data
operator|==
name|NULL
operator|||
name|fstat
argument_list|(
name|fileno
argument_list|(
name|help_data
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|help_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|help_file
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|help_size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|help_section
operator|=
name|bfd_make_section
argument_list|(
name|outbfd
argument_list|,
literal|".nlmhelp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|help_section
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|outbfd
argument_list|,
name|help_section
argument_list|,
name|help_size
argument_list|)
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|outbfd
argument_list|,
name|help_section
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"help section"
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|stamp
argument_list|,
literal|"MeSsAgEs"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|message_file
operator|!=
name|NULL
condition|)
block|{
name|message_data
operator|=
name|fopen
argument_list|(
name|message_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_data
operator|==
name|NULL
operator|||
name|fstat
argument_list|(
name|fileno
argument_list|(
name|message_data
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|message_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|message_file
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|message_size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|message_section
operator|=
name|bfd_make_section
argument_list|(
name|outbfd
argument_list|,
literal|".nlmmessages"
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_section
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|outbfd
argument_list|,
name|message_section
argument_list|,
name|message_size
argument_list|)
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|outbfd
argument_list|,
name|message_section
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"message section"
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|stamp
argument_list|,
literal|"MeSsAgEs"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|modules
operator|!=
name|NULL
condition|)
block|{
name|struct
name|string_list
modifier|*
name|l
decl_stmt|;
name|module_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|modules
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
name|module_size
operator|+=
name|strlen
argument_list|(
name|l
operator|->
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
name|module_section
operator|=
name|bfd_make_section
argument_list|(
name|outbfd
argument_list|,
literal|".nlmmodules"
argument_list|)
expr_stmt|;
if|if
condition|(
name|module_section
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|outbfd
argument_list|,
name|module_section
argument_list|,
name|module_size
argument_list|)
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|outbfd
argument_list|,
name|module_section
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"module section"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rpc_file
operator|!=
name|NULL
condition|)
block|{
name|rpc_data
operator|=
name|fopen
argument_list|(
name|rpc_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpc_data
operator|==
name|NULL
operator|||
name|fstat
argument_list|(
name|fileno
argument_list|(
name|rpc_data
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|rpc_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|rpc_file
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|rpc_size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|rpc_section
operator|=
name|bfd_make_section
argument_list|(
name|outbfd
argument_list|,
literal|".nlmrpc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpc_section
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|outbfd
argument_list|,
name|rpc_section
argument_list|,
name|rpc_size
argument_list|)
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|outbfd
argument_list|,
name|rpc_section
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"rpc section"
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|stamp
argument_list|,
literal|"MeSsAgEs"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sharelib_file
operator|!=
name|NULL
condition|)
block|{
name|sharedbfd
operator|=
name|bfd_openr
argument_list|(
name|sharelib_file
argument_list|,
name|output_format
argument_list|)
expr_stmt|;
if|if
condition|(
name|sharedbfd
operator|==
name|NULL
operator|||
operator|!
name|bfd_check_format
argument_list|(
name|sharedbfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|sharelib_file
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sharelib_file
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sharedhdr
operator|=
operator|*
name|nlm_fixed_header
argument_list|(
name|sharedbfd
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|sharedbfd
argument_list|)
expr_stmt|;
name|shared_data
operator|=
name|fopen
argument_list|(
name|sharelib_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shared_data
operator|==
name|NULL
operator|||
operator|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|shared_data
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|sharelib_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sharelib_file
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* If we were clever, we could just copy out the 		 sections of the shared library which we actually 		 need.  However, we would have to figure out the sizes 		 of the external and public information, and that can 		 not be done without reading through them.  */
if|if
condition|(
name|sharedhdr
operator|.
name|uninitializedDataSize
operator|>
literal|0
condition|)
block|{
comment|/* There is no place to record this information.  */
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: warning: shared libraries can not have uninitialized data"
argument_list|)
argument_list|,
name|sharelib_file
argument_list|)
expr_stmt|;
block|}
name|shared_offset
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|shared_offset
operator|>
operator|(
name|size_t
operator|)
name|sharedhdr
operator|.
name|codeImageOffset
condition|)
name|shared_offset
operator|=
name|sharedhdr
operator|.
name|codeImageOffset
expr_stmt|;
if|if
condition|(
name|shared_offset
operator|>
operator|(
name|size_t
operator|)
name|sharedhdr
operator|.
name|dataImageOffset
condition|)
name|shared_offset
operator|=
name|sharedhdr
operator|.
name|dataImageOffset
expr_stmt|;
if|if
condition|(
name|shared_offset
operator|>
operator|(
name|size_t
operator|)
name|sharedhdr
operator|.
name|relocationFixupOffset
condition|)
name|shared_offset
operator|=
name|sharedhdr
operator|.
name|relocationFixupOffset
expr_stmt|;
if|if
condition|(
name|shared_offset
operator|>
operator|(
name|size_t
operator|)
name|sharedhdr
operator|.
name|externalReferencesOffset
condition|)
name|shared_offset
operator|=
name|sharedhdr
operator|.
name|externalReferencesOffset
expr_stmt|;
if|if
condition|(
name|shared_offset
operator|>
operator|(
name|size_t
operator|)
name|sharedhdr
operator|.
name|publicsOffset
condition|)
name|shared_offset
operator|=
name|sharedhdr
operator|.
name|publicsOffset
expr_stmt|;
name|shared_size
operator|=
name|st
operator|.
name|st_size
operator|-
name|shared_offset
expr_stmt|;
name|shared_section
operator|=
name|bfd_make_section
argument_list|(
name|outbfd
argument_list|,
literal|".nlmshared"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shared_section
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|outbfd
argument_list|,
name|shared_section
argument_list|,
name|shared_size
argument_list|)
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|outbfd
argument_list|,
name|shared_section
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"shared section"
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|stamp
argument_list|,
literal|"MeSsAgEs"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Check whether a version was given.  */
if|if
condition|(
name|strncmp
argument_list|(
name|version_hdr
operator|->
name|stamp
argument_list|,
literal|"VeRsIoN#"
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"warning: No version number given"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* At least for now, always create an extended header, because that      is what NLMLINK does.  */
name|strncpy
argument_list|(
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|stamp
argument_list|,
literal|"MeSsAgEs"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|nlm_cygnus_ext_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|stamp
argument_list|,
literal|"CyGnUsEx"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* If the date was not given, force it in.  */
if|if
condition|(
name|nlm_version_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|month
operator|==
literal|0
operator|&&
name|nlm_version_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|day
operator|==
literal|0
operator|&&
name|nlm_version_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|year
operator|==
literal|0
condition|)
block|{
name|time_t
name|now
decl_stmt|;
name|struct
name|tm
modifier|*
name|ptm
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|ptm
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|nlm_version_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|month
operator|=
name|ptm
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|nlm_version_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|day
operator|=
name|ptm
operator|->
name|tm_mday
expr_stmt|;
name|nlm_version_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|year
operator|=
name|ptm
operator|->
name|tm_year
operator|+
literal|1900
expr_stmt|;
name|strncpy
argument_list|(
name|version_hdr
operator|->
name|stamp
argument_list|,
literal|"VeRsIoN#"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NLMCONV_POWERPC
comment|/* Resolve the stubs we build for PowerPC NetWare.  */
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|inbfd
argument_list|)
operator|==
name|bfd_arch_powerpc
condition|)
name|powerpc_resolve_stubs
argument_list|(
name|inbfd
argument_list|,
name|outbfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Copy over the sections.  */
name|bfd_map_over_sections
argument_list|(
name|inbfd
argument_list|,
name|copy_sections
argument_list|,
operator|(
name|void
operator|*
operator|)
name|outbfd
argument_list|)
expr_stmt|;
comment|/* Finish up the header information.  */
if|if
condition|(
name|custom_file
operator|!=
name|NULL
condition|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|xmalloc
argument_list|(
name|custom_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|custom_size
argument_list|,
name|custom_data
argument_list|)
operator|!=
name|custom_size
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: read: %s"
argument_list|)
argument_list|,
name|custom_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|outbfd
argument_list|,
name|custom_section
argument_list|,
name|data
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|custom_size
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"custom section"
argument_list|)
argument_list|)
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|customDataOffset
operator|=
name|custom_section
operator|->
name|filepos
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|customDataSize
operator|=
name|custom_size
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|debug_info
condition|)
block|{
comment|/* As a special hack, the backend recognizes a debugInfoOffset 	 of -1 to mean that it should not output any debugging 	 information.  This can not be handling by fiddling with the 	 symbol table because exported symbols appear in both the 	 export information and the debugging information.  */
name|nlm_fixed_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|debugInfoOffset
operator|=
operator|(
name|file_ptr
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|full_map
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"warning: FULLMAP is not supported; try ld -M"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|help_file
operator|!=
name|NULL
condition|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|xmalloc
argument_list|(
name|help_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|help_size
argument_list|,
name|help_data
argument_list|)
operator|!=
name|help_size
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: read: %s"
argument_list|)
argument_list|,
name|help_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|outbfd
argument_list|,
name|help_section
argument_list|,
name|data
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|help_size
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"help section"
argument_list|)
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|helpFileOffset
operator|=
name|help_section
operator|->
name|filepos
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|helpFileLength
operator|=
name|help_size
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|message_file
operator|!=
name|NULL
condition|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|xmalloc
argument_list|(
name|message_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|message_size
argument_list|,
name|message_data
argument_list|)
operator|!=
name|message_size
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: read: %s"
argument_list|)
argument_list|,
name|message_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|outbfd
argument_list|,
name|message_section
argument_list|,
name|data
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|message_size
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"message section"
argument_list|)
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|messageFileOffset
operator|=
name|message_section
operator|->
name|filepos
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|messageFileLength
operator|=
name|message_size
expr_stmt|;
comment|/* FIXME: Are these offsets correct on all platforms?  Are 	     they 32 bits on all platforms?  What endianness?  */
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|languageID
operator|=
name|bfd_h_get_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
literal|106
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|messageCount
operator|=
name|bfd_h_get_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
literal|110
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|modules
operator|!=
name|NULL
condition|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
name|unsigned
name|char
modifier|*
name|set
decl_stmt|;
name|struct
name|string_list
modifier|*
name|l
decl_stmt|;
name|bfd_size_type
name|c
decl_stmt|;
name|data
operator|=
name|xmalloc
argument_list|(
name|module_size
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|set
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
expr_stmt|;
for|for
control|(
name|l
operator|=
name|modules
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
operator|*
name|set
operator|=
name|strlen
argument_list|(
name|l
operator|->
name|string
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|set
operator|+
literal|1
argument_list|,
name|l
operator|->
name|string
argument_list|,
operator|*
name|set
argument_list|)
expr_stmt|;
name|set
operator|+=
operator|*
name|set
operator|+
literal|1
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|outbfd
argument_list|,
name|module_section
argument_list|,
name|data
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|module_size
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"module section"
argument_list|)
argument_list|)
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|moduleDependencyOffset
operator|=
name|module_section
operator|->
name|filepos
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|numberOfModuleDependencies
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|rpc_file
operator|!=
name|NULL
condition|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|xmalloc
argument_list|(
name|rpc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|rpc_size
argument_list|,
name|rpc_data
argument_list|)
operator|!=
name|rpc_size
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: read: %s"
argument_list|)
argument_list|,
name|rpc_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|outbfd
argument_list|,
name|rpc_section
argument_list|,
name|data
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|rpc_size
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"rpc section"
argument_list|)
argument_list|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|RPCDataOffset
operator|=
name|rpc_section
operator|->
name|filepos
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|RPCDataLength
operator|=
name|rpc_size
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sharelib_file
operator|!=
name|NULL
condition|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|xmalloc
argument_list|(
name|shared_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|shared_data
argument_list|,
name|shared_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|fread
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|shared_size
argument_list|,
name|shared_data
argument_list|)
operator|!=
name|shared_size
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: read: %s"
argument_list|)
argument_list|,
name|sharelib_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|outbfd
argument_list|,
name|shared_section
argument_list|,
name|data
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|shared_size
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"shared section"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|sharedCodeOffset
operator|=
name|sharedhdr
operator|.
name|codeImageOffset
operator|-
name|shared_offset
operator|+
name|shared_section
operator|->
name|filepos
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|sharedCodeLength
operator|=
name|sharedhdr
operator|.
name|codeImageSize
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|sharedDataOffset
operator|=
name|sharedhdr
operator|.
name|dataImageOffset
operator|-
name|shared_offset
operator|+
name|shared_section
operator|->
name|filepos
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|sharedDataLength
operator|=
name|sharedhdr
operator|.
name|dataImageSize
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|sharedRelocationFixupOffset
operator|=
operator|(
name|sharedhdr
operator|.
name|relocationFixupOffset
operator|-
name|shared_offset
operator|+
name|shared_section
operator|->
name|filepos
operator|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|sharedRelocationFixupCount
operator|=
name|sharedhdr
operator|.
name|numberOfRelocationFixups
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|sharedExternalReferenceOffset
operator|=
operator|(
name|sharedhdr
operator|.
name|externalReferencesOffset
operator|-
name|shared_offset
operator|+
name|shared_section
operator|->
name|filepos
operator|)
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|sharedExternalReferenceCount
operator|=
name|sharedhdr
operator|.
name|numberOfExternalReferences
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|sharedPublicsOffset
operator|=
name|sharedhdr
operator|.
name|publicsOffset
operator|-
name|shared_offset
operator|+
name|shared_section
operator|->
name|filepos
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|sharedPublicsCount
operator|=
name|sharedhdr
operator|.
name|numberOfPublics
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|sharedDebugRecordOffset
operator|=
name|sharedhdr
operator|.
name|debugInfoOffset
operator|-
name|shared_offset
operator|+
name|shared_section
operator|->
name|filepos
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|sharedDebugRecordCount
operator|=
name|sharedhdr
operator|.
name|numberOfDebugRecords
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|SharedInitializationOffset
operator|=
name|sharedhdr
operator|.
name|codeStartOffset
expr_stmt|;
name|nlm_extended_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|SharedExitProcedureOffset
operator|=
name|sharedhdr
operator|.
name|exitProcedureOffset
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|{
specifier|const
name|int
name|max_len
init|=
name|NLM_MODULE_NAME_SIZE
operator|-
literal|2
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
name|lbasename
argument_list|(
name|output_file
argument_list|)
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|max_len
condition|)
name|len
operator|=
name|max_len
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|moduleName
index|[
literal|0
index|]
operator|=
name|len
expr_stmt|;
name|strncpy
argument_list|(
name|nlm_fixed_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|moduleName
operator|+
literal|1
argument_list|,
name|filename
argument_list|,
name|max_len
argument_list|)
expr_stmt|;
name|nlm_fixed_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|moduleName
index|[
name|max_len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|modname
operator|=
name|nlm_fixed_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|moduleName
init|;
operator|*
name|modname
operator|!=
literal|'\0'
condition|;
name|modname
operator|++
control|)
operator|*
name|modname
operator|=
name|TOUPPER
argument_list|(
operator|*
name|modname
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|nlm_variable_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|oldThreadName
argument_list|,
literal|" LONG"
argument_list|,
name|NLM_OLD_THREAD_NAME_LENGTH
argument_list|)
expr_stmt|;
name|nlm_cygnus_ext_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|offset
operator|=
name|secsec
operator|->
name|filepos
expr_stmt|;
name|nlm_cygnus_ext_header
argument_list|(
name|outbfd
argument_list|)
operator|->
name|length
operator|=
name|bfd_section_size
argument_list|(
name|outbfd
argument_list|,
name|secsec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|outbfd
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|inbfd
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_on_exit
operator|!=
name|NULL
condition|)
name|unlink
argument_list|(
name|unlink_on_exit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Show a usage message and exit.  */
end_comment

begin_function
specifier|static
name|void
name|show_usage
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"Usage: %s [option(s)] [in-file [out-file]]\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" Convert an object file into a NetWare Loadable Module\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" The options are:\n\   -I --input-target=<bfdname>   Set the input binary file format\n\   -O --output-target=<bfdname>  Set the output binary file format\n\   -T --header-file=<file>       Read<file> for NLM header information\n\   -l --linker=<linker>          Use<linker> for any linking\n\   -d --debug                    Display on stderr the linker command line\n\   @<file>                       Read options from<file>.\n\   -h --help                     Display this information\n\   -v --version                  Display the program's version\n\ "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Select the output format based on the input architecture, machine,    and endianness.  This chooses the appropriate NLM target.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|select_output_format
parameter_list|(
name|enum
name|bfd_architecture
name|arch
parameter_list|,
name|unsigned
name|long
name|mach
parameter_list|,
name|bfd_boolean
name|bigendian
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|arch
condition|)
block|{
ifdef|#
directive|ifdef
name|NLMCONV_I386
case|case
name|bfd_arch_i386
case|:
return|return
literal|"nlm32-i386"
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NLMCONV_SPARC
case|case
name|bfd_arch_sparc
case|:
return|return
literal|"nlm32-sparc"
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NLMCONV_ALPHA
case|case
name|bfd_arch_alpha
case|:
return|return
literal|"nlm32-alpha"
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NLMCONV_POWERPC
case|case
name|bfd_arch_powerpc
case|:
return|return
literal|"nlm32-powerpc"
return|;
endif|#
directive|endif
default|default:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"support not compiled in for %s"
argument_list|)
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
name|arch
argument_list|,
name|mach
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The BFD sections are copied in two passes.  This function selects    the output section for each input section, and sets up the section    name, size, etc.  */
end_comment

begin_function
specifier|static
name|void
name|setup_sections
parameter_list|(
name|bfd
modifier|*
name|inbfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|insec
parameter_list|,
name|void
modifier|*
name|data_ptr
parameter_list|)
block|{
name|bfd
modifier|*
name|outbfd
init|=
operator|(
name|bfd
operator|*
operator|)
name|data_ptr
decl_stmt|;
name|flagword
name|f
decl_stmt|;
specifier|const
name|char
modifier|*
name|outname
decl_stmt|;
name|asection
modifier|*
name|outsec
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_size_type
name|align
decl_stmt|;
name|bfd_size_type
name|add
decl_stmt|;
name|bfd_size_type
name|secsecsize
decl_stmt|;
name|f
operator|=
name|bfd_get_section_flags
argument_list|(
name|inbfd
argument_list|,
name|insec
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|SEC_CODE
condition|)
name|outname
operator|=
name|NLM_CODE_NAME
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|&
name|SEC_LOAD
operator|)
operator|&&
operator|(
name|f
operator|&
name|SEC_HAS_CONTENTS
operator|)
condition|)
name|outname
operator|=
name|NLM_INITIALIZED_DATA_NAME
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|&
name|SEC_ALLOC
condition|)
name|outname
operator|=
name|NLM_UNINITIALIZED_DATA_NAME
expr_stmt|;
else|else
name|outname
operator|=
name|bfd_section_name
argument_list|(
name|inbfd
argument_list|,
name|insec
argument_list|)
expr_stmt|;
name|outsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|outbfd
argument_list|,
name|outname
argument_list|)
expr_stmt|;
if|if
condition|(
name|outsec
operator|==
name|NULL
condition|)
block|{
name|outsec
operator|=
name|bfd_make_section
argument_list|(
name|outbfd
argument_list|,
name|outname
argument_list|)
expr_stmt|;
if|if
condition|(
name|outsec
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"make section"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insec
operator|->
name|output_section
operator|=
name|outsec
expr_stmt|;
name|offset
operator|=
name|bfd_section_size
argument_list|(
name|outbfd
argument_list|,
name|outsec
argument_list|)
expr_stmt|;
name|align
operator|=
literal|1
operator|<<
name|bfd_section_alignment
argument_list|(
name|inbfd
argument_list|,
name|insec
argument_list|)
expr_stmt|;
name|add
operator|=
operator|(
operator|(
name|offset
operator|+
name|align
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|-
name|offset
expr_stmt|;
name|insec
operator|->
name|output_offset
operator|=
name|offset
operator|+
name|add
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|outbfd
argument_list|,
name|outsec
argument_list|,
operator|(
name|bfd_section_size
argument_list|(
name|outbfd
argument_list|,
name|outsec
argument_list|)
operator|+
name|bfd_section_size
argument_list|(
name|inbfd
argument_list|,
name|insec
argument_list|)
operator|+
name|add
operator|)
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"set section size"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_section_alignment
argument_list|(
name|inbfd
argument_list|,
name|insec
argument_list|)
operator|>
name|bfd_section_alignment
argument_list|(
name|outbfd
argument_list|,
name|outsec
argument_list|)
operator|)
operator|&&
operator|!
name|bfd_set_section_alignment
argument_list|(
name|outbfd
argument_list|,
name|outsec
argument_list|,
name|bfd_section_alignment
argument_list|(
name|inbfd
argument_list|,
name|insec
argument_list|)
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"set section alignment"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|outbfd
argument_list|,
name|outsec
argument_list|,
name|f
operator||
name|bfd_get_section_flags
argument_list|(
name|outbfd
argument_list|,
name|outsec
argument_list|)
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"set section flags"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_reloc
argument_list|(
name|outbfd
argument_list|,
name|outsec
argument_list|,
operator|(
name|arelent
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For each input section we allocate space for an entry in      .nlmsections.  */
name|secsecsize
operator|=
name|bfd_section_size
argument_list|(
name|outbfd
argument_list|,
name|secsec
argument_list|)
expr_stmt|;
name|secsecsize
operator|+=
name|strlen
argument_list|(
name|bfd_section_name
argument_list|(
name|inbfd
argument_list|,
name|insec
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|secsecsize
operator|=
operator|(
name|secsecsize
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|secsecsize
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|outbfd
argument_list|,
name|secsec
argument_list|,
name|secsecsize
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"set .nlmsections size"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the section contents.  */
end_comment

begin_function
specifier|static
name|void
name|copy_sections
parameter_list|(
name|bfd
modifier|*
name|inbfd
parameter_list|,
name|asection
modifier|*
name|insec
parameter_list|,
name|void
modifier|*
name|data_ptr
parameter_list|)
block|{
specifier|static
name|bfd_size_type
name|secsecoff
init|=
literal|0
decl_stmt|;
name|bfd
modifier|*
name|outbfd
init|=
operator|(
name|bfd
operator|*
operator|)
name|data_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|inname
decl_stmt|;
name|asection
modifier|*
name|outsec
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|void
modifier|*
name|contents
decl_stmt|;
name|long
name|reloc_size
decl_stmt|;
name|bfd_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|bfd_size_type
name|add
decl_stmt|;
name|inname
operator|=
name|bfd_section_name
argument_list|(
name|inbfd
argument_list|,
name|insec
argument_list|)
expr_stmt|;
name|outsec
operator|=
name|insec
operator|->
name|output_section
expr_stmt|;
name|assert
argument_list|(
name|outsec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|size
operator|=
name|bfd_get_section_size
argument_list|(
name|insec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|inbfd
argument_list|,
name|insec
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
name|contents
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|contents
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|inbfd
argument_list|,
name|insec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|size
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|inbfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reloc_size
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|inbfd
argument_list|,
name|insec
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_size
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|inbfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_size
operator|!=
literal|0
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
name|long
name|reloc_count
decl_stmt|;
name|relocs
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|reloc_size
argument_list|)
expr_stmt|;
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|inbfd
argument_list|,
name|insec
argument_list|,
name|relocs
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|inbfd
argument_list|)
argument_list|)
expr_stmt|;
name|mangle_relocs
argument_list|(
name|outbfd
argument_list|,
name|insec
argument_list|,
operator|&
name|relocs
argument_list|,
operator|&
name|reloc_count
argument_list|,
operator|(
name|char
operator|*
operator|)
name|contents
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* FIXME: refers to internal BFD fields.  */
if|if
condition|(
name|outsec
operator|->
name|orelocation
operator|!=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_size_type
name|total_count
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|combined
decl_stmt|;
name|total_count
operator|=
name|reloc_count
operator|+
name|outsec
operator|->
name|reloc_count
expr_stmt|;
name|combined
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|total_count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|combined
argument_list|,
name|outsec
operator|->
name|orelocation
argument_list|,
name|outsec
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|combined
operator|+
name|outsec
operator|->
name|reloc_count
argument_list|,
name|relocs
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outsec
operator|->
name|orelocation
argument_list|)
expr_stmt|;
name|reloc_count
operator|=
name|total_count
expr_stmt|;
name|relocs
operator|=
name|combined
expr_stmt|;
block|}
name|bfd_set_reloc
argument_list|(
name|outbfd
argument_list|,
name|outsec
argument_list|,
name|relocs
argument_list|,
name|reloc_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|outbfd
argument_list|,
name|outsec
argument_list|,
name|contents
argument_list|,
name|insec
operator|->
name|output_offset
argument_list|,
name|size
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|outbfd
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
comment|/* Add this section to .nlmsections.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|outbfd
argument_list|,
name|secsec
argument_list|,
operator|(
name|void
operator|*
operator|)
name|inname
argument_list|,
name|secsecoff
argument_list|,
name|strlen
argument_list|(
name|inname
argument_list|)
operator|+
literal|1
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"set .nlmsection contents"
argument_list|)
argument_list|)
expr_stmt|;
name|secsecoff
operator|+=
name|strlen
argument_list|(
name|inname
argument_list|)
operator|+
literal|1
expr_stmt|;
name|add
operator|=
operator|(
operator|(
name|secsecoff
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
operator|-
name|secsecoff
expr_stmt|;
if|if
condition|(
name|add
operator|!=
literal|0
condition|)
block|{
name|bfd_h_put_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|outbfd
argument_list|,
name|secsec
argument_list|,
name|buf
argument_list|,
name|secsecoff
argument_list|,
name|add
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"set .nlmsection contents"
argument_list|)
argument_list|)
expr_stmt|;
name|secsecoff
operator|+=
name|add
expr_stmt|;
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
name|bfd_h_put_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|outsec
operator|->
name|filepos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|bfd_h_put_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|outbfd
argument_list|,
name|secsec
argument_list|,
name|buf
argument_list|,
name|secsecoff
argument_list|,
literal|4
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"set .nlmsection contents"
argument_list|)
argument_list|)
expr_stmt|;
name|secsecoff
operator|+=
literal|4
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|outbfd
argument_list|,
name|secsec
argument_list|,
name|buf
argument_list|,
name|secsecoff
argument_list|,
literal|4
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"set .nlmsection contents"
argument_list|)
argument_list|)
expr_stmt|;
name|secsecoff
operator|+=
literal|4
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some, perhaps all, NetWare targets require changing the relocs used    by the input formats.  */
end_comment

begin_function
specifier|static
name|void
name|mangle_relocs
parameter_list|(
name|bfd
modifier|*
name|outbfd
parameter_list|,
name|asection
modifier|*
name|insec
parameter_list|,
name|arelent
modifier|*
modifier|*
modifier|*
name|relocs_ptr
parameter_list|,
name|long
modifier|*
name|reloc_count_ptr
parameter_list|,
name|char
modifier|*
name|contents
parameter_list|,
name|bfd_size_type
name|contents_size
parameter_list|)
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|outbfd
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|NLMCONV_I386
case|case
name|bfd_arch_i386
case|:
name|i386_mangle_relocs
argument_list|(
name|outbfd
argument_list|,
name|insec
argument_list|,
name|relocs_ptr
argument_list|,
name|reloc_count_ptr
argument_list|,
name|contents
argument_list|,
name|contents_size
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NLMCONV_ALPHA
case|case
name|bfd_arch_alpha
case|:
name|alpha_mangle_relocs
argument_list|(
name|outbfd
argument_list|,
name|insec
argument_list|,
name|relocs_ptr
argument_list|,
name|reloc_count_ptr
argument_list|,
name|contents
argument_list|,
name|contents_size
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NLMCONV_POWERPC
case|case
name|bfd_arch_powerpc
case|:
name|powerpc_mangle_relocs
argument_list|(
name|outbfd
argument_list|,
name|insec
argument_list|,
name|relocs_ptr
argument_list|,
name|reloc_count_ptr
argument_list|,
name|contents
argument_list|,
name|contents_size
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|default_mangle_relocs
argument_list|(
name|outbfd
argument_list|,
name|insec
argument_list|,
name|relocs_ptr
argument_list|,
name|reloc_count_ptr
argument_list|,
name|contents
argument_list|,
name|contents_size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* By default all we need to do for relocs is change the address by    the output_offset.  */
end_comment

begin_function
specifier|static
name|void
name|default_mangle_relocs
parameter_list|(
name|bfd
modifier|*
name|outbfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|insec
parameter_list|,
name|arelent
modifier|*
modifier|*
modifier|*
name|relocs_ptr
parameter_list|,
name|long
modifier|*
name|reloc_count_ptr
parameter_list|,
name|char
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_size_type
name|contents_size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|insec
operator|->
name|output_offset
operator|!=
literal|0
condition|)
block|{
name|long
name|reloc_count
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
name|long
name|i
decl_stmt|;
name|reloc_count
operator|=
operator|*
name|reloc_count_ptr
expr_stmt|;
name|relocs
operator|=
operator|*
name|relocs_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reloc_count
condition|;
name|i
operator|++
operator|,
name|relocs
operator|++
control|)
operator|(
operator|*
name|relocs
operator|)
operator|->
name|address
operator|+=
name|insec
operator|->
name|output_offset
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|NLMCONV_I386
end_ifdef

begin_comment
comment|/* NetWare on the i386 supports a restricted set of relocs, which are    different from those used on other i386 targets.  This routine    converts the relocs.  It is, obviously, very target dependent.  At    the moment, the nlm32-i386 backend performs similar translations;    however, it is more reliable and efficient to do them here.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|nlm_i386_pcrel_howto
init|=
name|HOWTO
argument_list|(
literal|1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"DISP32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_function
specifier|static
name|void
name|i386_mangle_relocs
parameter_list|(
name|bfd
modifier|*
name|outbfd
parameter_list|,
name|asection
modifier|*
name|insec
parameter_list|,
name|arelent
modifier|*
modifier|*
modifier|*
name|relocs_ptr
parameter_list|,
name|long
modifier|*
name|reloc_count_ptr
parameter_list|,
name|char
modifier|*
name|contents
parameter_list|,
name|bfd_size_type
name|contents_size
parameter_list|)
block|{
name|long
name|reloc_count
decl_stmt|,
name|i
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
name|reloc_count
operator|=
operator|*
name|reloc_count_ptr
expr_stmt|;
name|relocs
operator|=
operator|*
name|relocs_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|bfd_size_type
name|address
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|rel
operator|=
operator|*
name|relocs
operator|++
expr_stmt|;
name|sym
operator|=
operator|*
name|rel
operator|->
name|sym_ptr_ptr
expr_stmt|;
comment|/* We're moving the relocs from the input section to the output 	 section, so we must adjust the address accordingly.  */
name|address
operator|=
name|rel
operator|->
name|address
expr_stmt|;
name|rel
operator|->
name|address
operator|+=
name|insec
operator|->
name|output_offset
expr_stmt|;
comment|/* Note that no serious harm will ensue if we fail to change a 	 reloc.  The backend will fail when writing out the reloc.  */
comment|/* Make sure this reloc is within the data we have.  We use only 	 4 byte relocs here, so we insist on having 4 bytes.  */
if|if
condition|(
name|address
operator|+
literal|4
operator|>
name|contents_size
condition|)
continue|continue;
comment|/* A PC relative reloc entirely within a single section is 	 completely unnecessary.  This can be generated by ld -r.  */
if|if
condition|(
name|sym
operator|==
name|insec
operator|->
name|symbol
operator|&&
name|rel
operator|->
name|howto
operator|!=
name|NULL
operator|&&
name|rel
operator|->
name|howto
operator|->
name|pc_relative
operator|&&
operator|!
name|rel
operator|->
name|howto
operator|->
name|pcrel_offset
condition|)
block|{
operator|--
operator|*
name|reloc_count_ptr
expr_stmt|;
operator|--
name|relocs
expr_stmt|;
name|memmove
argument_list|(
name|relocs
argument_list|,
name|relocs
operator|+
literal|1
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|reloc_count
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the amount the relocation will add in.  */
name|addend
operator|=
name|rel
operator|->
name|addend
operator|+
name|sym
operator|->
name|value
expr_stmt|;
comment|/* NetWare doesn't support PC relative relocs against defined 	 symbols, so we have to eliminate them by doing the relocation 	 now.  We can only do this if the reloc is within a single 	 section.  */
if|if
condition|(
name|rel
operator|->
name|howto
operator|!=
name|NULL
operator|&&
name|rel
operator|->
name|howto
operator|->
name|pc_relative
operator|&&
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|==
name|insec
operator|->
name|output_section
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
if|if
condition|(
name|rel
operator|->
name|howto
operator|->
name|pcrel_offset
condition|)
name|addend
operator|-=
name|address
expr_stmt|;
name|val
operator|=
name|bfd_get_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
name|val
operator|+=
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|outbfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
operator|--
operator|*
name|reloc_count_ptr
expr_stmt|;
operator|--
name|relocs
expr_stmt|;
name|memmove
argument_list|(
name|relocs
argument_list|,
name|relocs
operator|+
literal|1
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|reloc_count
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* NetWare doesn't support reloc addends, so we get rid of them 	 here by simply adding them into the object data.  We handle 	 the symbol value, if any, the same way.  */
if|if
condition|(
name|addend
operator|!=
literal|0
operator|&&
name|rel
operator|->
name|howto
operator|!=
name|NULL
operator|&&
name|rel
operator|->
name|howto
operator|->
name|rightshift
operator|==
literal|0
operator|&&
name|rel
operator|->
name|howto
operator|->
name|size
operator|==
literal|2
operator|&&
name|rel
operator|->
name|howto
operator|->
name|bitsize
operator|==
literal|32
operator|&&
name|rel
operator|->
name|howto
operator|->
name|bitpos
operator|==
literal|0
operator|&&
name|rel
operator|->
name|howto
operator|->
name|src_mask
operator|==
literal|0xffffffff
operator|&&
name|rel
operator|->
name|howto
operator|->
name|dst_mask
operator|==
literal|0xffffffff
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|val
operator|=
name|bfd_get_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
name|val
operator|+=
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|outbfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
comment|/* Adjust the reloc for the changes we just made.  */
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
comment|/* NetWare uses a reloc with pcrel_offset set.  We adjust 	 pc_relative relocs accordingly.  We are going to change the 	 howto field, so we can only do this if the current one is 	 compatible.  We should check that special_function is NULL 	 here, but at the moment coff-i386 uses a special_function 	 which does not affect what we are doing here.  */
if|if
condition|(
name|rel
operator|->
name|howto
operator|!=
name|NULL
operator|&&
name|rel
operator|->
name|howto
operator|->
name|pc_relative
operator|&&
operator|!
name|rel
operator|->
name|howto
operator|->
name|pcrel_offset
operator|&&
name|rel
operator|->
name|howto
operator|->
name|rightshift
operator|==
literal|0
operator|&&
name|rel
operator|->
name|howto
operator|->
name|size
operator|==
literal|2
operator|&&
name|rel
operator|->
name|howto
operator|->
name|bitsize
operator|==
literal|32
operator|&&
name|rel
operator|->
name|howto
operator|->
name|bitpos
operator|==
literal|0
operator|&&
name|rel
operator|->
name|howto
operator|->
name|src_mask
operator|==
literal|0xffffffff
operator|&&
name|rel
operator|->
name|howto
operator|->
name|dst_mask
operator|==
literal|0xffffffff
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
comment|/* When pcrel_offset is not set, it means that the negative 	     of the address of the memory location is stored in the 	     memory location.  We must add it back in.  */
name|val
operator|=
name|bfd_get_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
name|val
operator|+=
name|address
expr_stmt|;
name|bfd_put_32
argument_list|(
name|outbfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
comment|/* We must change to a new howto.  */
name|rel
operator|->
name|howto
operator|=
operator|&
name|nlm_i386_pcrel_howto
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NLMCONV_I386 */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|NLMCONV_ALPHA
end_ifdef

begin_comment
comment|/* On the Alpha the first reloc for every section must be a special    relocs which hold the GP address.  Also, the first reloc in the    file must be a special reloc which holds the address of the .lita    section.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|nlm32_alpha_nw_howto
init|=
name|HOWTO
argument_list|(
name|ALPHA_R_NW_RELOC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"NW_RELOC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_function
specifier|static
name|void
name|alpha_mangle_relocs
parameter_list|(
name|bfd
modifier|*
name|outbfd
parameter_list|,
name|asection
modifier|*
name|insec
parameter_list|,
name|arelent
modifier|*
modifier|*
modifier|*
name|relocs_ptr
parameter_list|,
name|long
modifier|*
name|reloc_count_ptr
parameter_list|,
name|char
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_size_type
name|contents_size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|old_reloc_count
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|old_relocs
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
name|old_reloc_count
operator|=
operator|*
name|reloc_count_ptr
expr_stmt|;
name|old_relocs
operator|=
operator|*
name|relocs_ptr
expr_stmt|;
name|relocs
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|old_reloc_count
operator|+
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|relocs_ptr
operator|=
name|relocs
expr_stmt|;
if|if
condition|(
name|nlm_alpha_backend_data
argument_list|(
name|outbfd
argument_list|)
operator|->
name|lita_address
operator|==
literal|0
condition|)
block|{
name|bfd
modifier|*
name|inbfd
decl_stmt|;
name|asection
modifier|*
name|lita_section
decl_stmt|;
name|inbfd
operator|=
name|insec
operator|->
name|owner
expr_stmt|;
name|lita_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|inbfd
argument_list|,
name|_LITA
argument_list|)
expr_stmt|;
if|if
condition|(
name|lita_section
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|nlm_alpha_backend_data
argument_list|(
name|outbfd
argument_list|)
operator|->
name|lita_address
operator|=
name|bfd_get_section_vma
argument_list|(
name|inbfd
argument_list|,
name|lita_section
argument_list|)
expr_stmt|;
name|nlm_alpha_backend_data
argument_list|(
name|outbfd
argument_list|)
operator|->
name|lita_size
operator|=
name|bfd_section_size
argument_list|(
name|inbfd
argument_list|,
name|lita_section
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Avoid outputting this reloc again.  */
name|nlm_alpha_backend_data
argument_list|(
name|outbfd
argument_list|)
operator|->
name|lita_address
operator|=
literal|4
expr_stmt|;
block|}
operator|*
name|relocs
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|relocs
operator|)
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
operator|(
operator|*
name|relocs
operator|)
operator|->
name|address
operator|=
name|nlm_alpha_backend_data
argument_list|(
name|outbfd
argument_list|)
operator|->
name|lita_address
expr_stmt|;
operator|(
operator|*
name|relocs
operator|)
operator|->
name|addend
operator|=
name|nlm_alpha_backend_data
argument_list|(
name|outbfd
argument_list|)
operator|->
name|lita_size
operator|+
literal|1
expr_stmt|;
operator|(
operator|*
name|relocs
operator|)
operator|->
name|howto
operator|=
operator|&
name|nlm32_alpha_nw_howto
expr_stmt|;
operator|++
name|relocs
expr_stmt|;
operator|++
operator|(
operator|*
name|reloc_count_ptr
operator|)
expr_stmt|;
block|}
comment|/* Get the GP value from bfd.  */
if|if
condition|(
name|nlm_alpha_backend_data
argument_list|(
name|outbfd
argument_list|)
operator|->
name|gp
operator|==
literal|0
condition|)
name|nlm_alpha_backend_data
argument_list|(
name|outbfd
argument_list|)
operator|->
name|gp
operator|=
name|bfd_ecoff_get_gp_value
argument_list|(
name|insec
operator|->
name|owner
argument_list|)
expr_stmt|;
operator|*
name|relocs
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|relocs
operator|)
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
operator|(
operator|*
name|relocs
operator|)
operator|->
name|address
operator|=
name|nlm_alpha_backend_data
argument_list|(
name|outbfd
argument_list|)
operator|->
name|gp
expr_stmt|;
operator|(
operator|*
name|relocs
operator|)
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|relocs
operator|)
operator|->
name|howto
operator|=
operator|&
name|nlm32_alpha_nw_howto
expr_stmt|;
operator|++
name|relocs
expr_stmt|;
operator|++
operator|(
operator|*
name|reloc_count_ptr
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|relocs
argument_list|,
name|old_relocs
argument_list|,
operator|(
name|size_t
operator|)
name|old_reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|relocs
index|[
name|old_reloc_count
index|]
operator|=
operator|(
name|arelent
operator|*
operator|)
name|NULL
expr_stmt|;
name|free
argument_list|(
name|old_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|insec
operator|->
name|output_offset
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|bfd_size_type
operator|)
name|old_reloc_count
condition|;
name|i
operator|++
operator|,
name|relocs
operator|++
control|)
operator|(
operator|*
name|relocs
operator|)
operator|->
name|address
operator|+=
name|insec
operator|->
name|output_offset
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NLMCONV_ALPHA */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|NLMCONV_POWERPC
end_ifdef

begin_comment
comment|/* We keep a linked list of stubs which we must build.  Because BFD    requires us to know the sizes of all sections before we can set the    contents of any, we must figure out which stubs we want to build    before we can actually build any of them.  */
end_comment

begin_struct
struct|struct
name|powerpc_stub
block|{
comment|/* Next stub in linked list.  */
name|struct
name|powerpc_stub
modifier|*
name|next
decl_stmt|;
comment|/* Symbol whose value is the start of the stub.  This is a symbol      whose name begins with `.'.  */
name|asymbol
modifier|*
name|start
decl_stmt|;
comment|/* Symbol we are going to create a reloc against.  This is a symbol      with the same name as START but without the leading `.'.  */
name|asymbol
modifier|*
name|reloc
decl_stmt|;
comment|/* The TOC index for this stub.  This is the index into the TOC      section at which the reloc is created.  */
name|unsigned
name|int
name|toc_index
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The linked list of stubs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|powerpc_stub
modifier|*
name|powerpc_stubs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is what a stub looks like.  The first instruction will get    adjusted with the correct TOC index.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|powerpc_stub_insns
index|[]
init|=
block|{
literal|0x81820000
block|,
comment|/* lwz	 r12,0(r2) */
literal|0x90410014
block|,
comment|/* stw	 r2,20(r1) */
literal|0x800c0000
block|,
comment|/* lwz	 r0,0(r12) */
literal|0x804c0004
block|,
comment|/* lwz	 r2,r(r12) */
literal|0x7c0903a6
block|,
comment|/* mtctr r0 */
literal|0x4e800420
block|,
comment|/* bctr */
literal|0
block|,
comment|/* Traceback table.  */
literal|0xc8000
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|POWERPC_STUB_INSN_COUNT
define|\
value|(sizeof powerpc_stub_insns / sizeof powerpc_stub_insns[0])
end_define

begin_define
define|#
directive|define
name|POWERPC_STUB_SIZE
value|(4 * POWERPC_STUB_INSN_COUNT)
end_define

begin_comment
comment|/* Each stub uses a four byte TOC entry.  */
end_comment

begin_define
define|#
directive|define
name|POWERPC_STUB_TOC_ENTRY_SIZE
value|(4)
end_define

begin_comment
comment|/* The original size of the .got section.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_size_type
name|powerpc_initial_got_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look for all undefined symbols beginning with `.', and prepare to    build a stub for each one.  */
end_comment

begin_function
specifier|static
name|void
name|powerpc_build_stubs
parameter_list|(
name|bfd
modifier|*
name|inbfd
parameter_list|,
name|bfd
modifier|*
name|outbfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
modifier|*
modifier|*
name|symbols_ptr
parameter_list|,
name|long
modifier|*
name|symcount_ptr
parameter_list|)
block|{
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|asection
modifier|*
name|got_sec
decl_stmt|;
name|unsigned
name|int
name|got_base
decl_stmt|;
name|long
name|i
decl_stmt|;
name|long
name|symcount
decl_stmt|;
name|long
name|stubcount
decl_stmt|;
comment|/* Make a section to hold stubs.  We don't set SEC_HAS_CONTENTS for      the section to prevent copy_sections from reading from it.  */
name|stub_sec
operator|=
name|bfd_make_section
argument_list|(
name|inbfd
argument_list|,
literal|".stubs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|inbfd
argument_list|,
name|stub_sec
argument_list|,
operator|(
name|SEC_CODE
operator||
name|SEC_RELOC
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|inbfd
argument_list|,
name|stub_sec
argument_list|,
literal|2
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|".stubs"
argument_list|)
expr_stmt|;
comment|/* Get the TOC section, which is named .got.  */
name|got_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|inbfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_sec
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|got_sec
operator|=
name|bfd_make_section
argument_list|(
name|inbfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_sec
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|inbfd
argument_list|,
name|got_sec
argument_list|,
operator|(
name|SEC_DATA
operator||
name|SEC_RELOC
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|inbfd
argument_list|,
name|got_sec
argument_list|,
literal|2
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|".got"
argument_list|)
expr_stmt|;
block|}
name|powerpc_initial_got_size
operator|=
name|bfd_section_size
argument_list|(
name|inbfd
argument_list|,
name|got_sec
argument_list|)
expr_stmt|;
name|got_base
operator|=
name|powerpc_initial_got_size
expr_stmt|;
name|got_base
operator|=
operator|(
name|got_base
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|stubcount
operator|=
literal|0
expr_stmt|;
name|symcount
operator|=
operator|*
name|symcount_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symcount
condition|;
name|i
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|asymbol
modifier|*
name|newsym
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|struct
name|powerpc_stub
modifier|*
name|item
decl_stmt|;
name|sym
operator|=
operator|(
operator|*
name|symbols_ptr
operator|)
index|[
name|i
index|]
expr_stmt|;
comment|/* We must make a stub for every undefined symbol whose name 	 starts with '.'.  */
if|if
condition|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
operator|!
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Make a new undefined symbol with the same name but without 	 the leading `.'.  */
name|newsym
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|newsym
operator|=
operator|*
name|sym
expr_stmt|;
name|newname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|newsym
operator|->
name|name
operator|=
name|newname
expr_stmt|;
comment|/* Define the `.' symbol to be in the stub section.  */
name|sym
operator|->
name|section
operator|=
name|stub_sec
expr_stmt|;
name|sym
operator|->
name|value
operator|=
name|stubcount
operator|*
name|POWERPC_STUB_SIZE
expr_stmt|;
comment|/* We set the BSF_DYNAMIC flag here so that we can check it when 	 we are mangling relocs.  FIXME: This is a hack.  */
name|sym
operator|->
name|flags
operator|=
name|BSF_LOCAL
operator||
name|BSF_DYNAMIC
expr_stmt|;
comment|/* Add this stub to the linked list.  */
name|item
operator|=
operator|(
expr|struct
name|powerpc_stub
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|powerpc_stub
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|start
operator|=
name|sym
expr_stmt|;
name|item
operator|->
name|reloc
operator|=
name|newsym
expr_stmt|;
name|item
operator|->
name|toc_index
operator|=
name|got_base
operator|+
name|stubcount
operator|*
name|POWERPC_STUB_TOC_ENTRY_SIZE
expr_stmt|;
name|item
operator|->
name|next
operator|=
name|powerpc_stubs
expr_stmt|;
name|powerpc_stubs
operator|=
name|item
expr_stmt|;
operator|++
name|stubcount
expr_stmt|;
block|}
if|if
condition|(
name|stubcount
operator|>
literal|0
condition|)
block|{
name|asymbol
modifier|*
modifier|*
name|s
decl_stmt|;
name|struct
name|powerpc_stub
modifier|*
name|l
decl_stmt|;
comment|/* Add the new symbols we just created to the symbol table.  */
operator|*
name|symbols_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|symbols_ptr
argument_list|,
operator|(
operator|(
name|symcount
operator|+
name|stubcount
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|symcount_ptr
operator|+=
name|stubcount
expr_stmt|;
name|s
operator|=
operator|&
operator|(
operator|*
name|symbols_ptr
operator|)
index|[
name|symcount
index|]
expr_stmt|;
for|for
control|(
name|l
operator|=
name|powerpc_stubs
init|;
name|l
operator|!=
operator|(
expr|struct
name|powerpc_stub
operator|*
operator|)
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
operator|*
name|s
operator|++
operator|=
name|l
operator|->
name|reloc
expr_stmt|;
comment|/* Set the size of the .stubs section and increase the size of 	 the .got section.  */
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|inbfd
argument_list|,
name|stub_sec
argument_list|,
name|stubcount
operator|*
name|POWERPC_STUB_SIZE
argument_list|)
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|inbfd
argument_list|,
name|got_sec
argument_list|,
operator|(
name|got_base
operator|+
operator|(
name|stubcount
operator|*
name|POWERPC_STUB_TOC_ENTRY_SIZE
operator|)
operator|)
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"stub section sizes"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Resolve all the stubs for PowerPC NetWare.  We fill in the contents    of the output section, and create new relocs in the TOC.  */
end_comment

begin_function
specifier|static
name|void
name|powerpc_resolve_stubs
parameter_list|(
name|bfd
modifier|*
name|inbfd
parameter_list|,
name|bfd
modifier|*
name|outbfd
parameter_list|)
block|{
name|bfd_byte
name|buf
index|[
name|POWERPC_STUB_SIZE
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|stubcount
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
name|asection
modifier|*
name|got_sec
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|r
decl_stmt|;
name|struct
name|powerpc_stub
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|powerpc_stubs
operator|==
operator|(
expr|struct
name|powerpc_stub
operator|*
operator|)
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|POWERPC_STUB_INSN_COUNT
condition|;
name|i
operator|++
control|)
name|bfd_put_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|powerpc_stub_insns
index|[
name|i
index|]
argument_list|,
name|buf
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|got_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|inbfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|got_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|got_sec
operator|->
name|output_section
operator|->
name|orelocation
operator|==
operator|(
name|arelent
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|stubcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|powerpc_stubs
init|;
name|l
operator|!=
operator|(
expr|struct
name|powerpc_stub
operator|*
operator|)
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
operator|++
name|stubcount
expr_stmt|;
name|relocs
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|stubcount
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|relocs
expr_stmt|;
for|for
control|(
name|l
operator|=
name|powerpc_stubs
init|;
name|l
operator|!=
operator|(
expr|struct
name|powerpc_stub
operator|*
operator|)
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
comment|/* Adjust the first instruction to use the right TOC index.  */
name|bfd_put_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|powerpc_stub_insns
index|[
literal|0
index|]
operator|+
name|l
operator|->
name|toc_index
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Write this stub out.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|outbfd
argument_list|,
name|bfd_get_section
argument_list|(
name|l
operator|->
name|start
argument_list|)
argument_list|,
name|buf
argument_list|,
name|l
operator|->
name|start
operator|->
name|value
argument_list|,
name|POWERPC_STUB_SIZE
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"writing stub"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a new reloc for the TOC entry.  */
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|&
name|l
operator|->
name|reloc
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|l
operator|->
name|toc_index
operator|+
name|got_sec
operator|->
name|output_offset
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|inbfd
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
operator|*
name|r
operator|++
operator|=
name|reloc
expr_stmt|;
block|}
name|bfd_set_reloc
argument_list|(
name|outbfd
argument_list|,
name|got_sec
operator|->
name|output_section
argument_list|,
name|relocs
argument_list|,
name|stubcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjust relocation entries for PowerPC NetWare.  We do not output    TOC relocations.  The object code already contains the offset from    the TOC pointer.  When the function is called, the TOC register,    r2, will be set to the correct TOC value, so there is no need for    any further reloc.  */
end_comment

begin_function
specifier|static
name|void
name|powerpc_mangle_relocs
parameter_list|(
name|bfd
modifier|*
name|outbfd
parameter_list|,
name|asection
modifier|*
name|insec
parameter_list|,
name|arelent
modifier|*
modifier|*
modifier|*
name|relocs_ptr
parameter_list|,
name|long
modifier|*
name|reloc_count_ptr
parameter_list|,
name|char
modifier|*
name|contents
parameter_list|,
name|bfd_size_type
name|contents_size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|reloc_howto_type
modifier|*
name|toc_howto
decl_stmt|;
name|long
name|reloc_count
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
name|long
name|i
decl_stmt|;
name|toc_howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|insec
operator|->
name|owner
argument_list|,
name|BFD_RELOC_PPC_TOC16
argument_list|)
expr_stmt|;
if|if
condition|(
name|toc_howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If this is the .got section, clear out all the contents beyond      the initial size.  We must do this here because copy_sections is      going to write out whatever we return in the contents field.  */
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|insec
operator|->
name|owner
argument_list|,
name|insec
argument_list|)
argument_list|,
literal|".got"
argument_list|)
operator|==
literal|0
condition|)
name|memset
argument_list|(
name|contents
operator|+
name|powerpc_initial_got_size
argument_list|,
literal|0
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|bfd_get_section_size
argument_list|(
name|insec
argument_list|)
operator|-
name|powerpc_initial_got_size
argument_list|)
argument_list|)
expr_stmt|;
name|reloc_count
operator|=
operator|*
name|reloc_count_ptr
expr_stmt|;
name|relocs
operator|=
operator|*
name|relocs_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|rel
operator|=
operator|*
name|relocs
operator|++
expr_stmt|;
name|sym
operator|=
operator|*
name|rel
operator|->
name|sym_ptr_ptr
expr_stmt|;
comment|/* Convert any relocs against the .bss section into relocs          against the .data section.  */
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|outbfd
argument_list|,
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|,
name|NLM_UNINITIALIZED_DATA_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
name|datasec
decl_stmt|;
name|datasec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|outbfd
argument_list|,
name|NLM_INITIALIZED_DATA_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasec
operator|!=
name|NULL
condition|)
block|{
name|rel
operator|->
name|addend
operator|+=
operator|(
name|bfd_get_section_vma
argument_list|(
name|outbfd
argument_list|,
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|+
name|sym
operator|->
name|value
operator|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|datasec
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|sym
operator|=
operator|*
name|rel
operator|->
name|sym_ptr_ptr
expr_stmt|;
block|}
block|}
comment|/* We must be able to resolve all PC relative relocs at this 	 point.  If we get a branch to an undefined symbol we build a 	 stub, since NetWare will resolve undefined symbols into a 	 pointer to a function descriptor.  */
if|if
condition|(
name|rel
operator|->
name|howto
operator|->
name|pc_relative
condition|)
block|{
comment|/* This check for whether a symbol is in the same section as 	     the reloc will be wrong if there is a PC relative reloc 	     between two sections both of which were placed in the 	     same output section.  This should not happen.  */
if|if
condition|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|!=
name|insec
operator|->
name|output_section
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"unresolved PC relative reloc against %s"
argument_list|)
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_vma
name|val
decl_stmt|;
name|assert
argument_list|(
name|rel
operator|->
name|howto
operator|->
name|size
operator|==
literal|2
operator|&&
name|rel
operator|->
name|howto
operator|->
name|pcrel_offset
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_get_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|rel
operator|->
name|address
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
operator|~
name|rel
operator|->
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|&
name|rel
operator|->
name|howto
operator|->
name|src_mask
operator|)
operator|+
operator|(
name|sym
operator|->
name|value
operator|-
name|rel
operator|->
name|address
operator|)
operator|+
name|rel
operator|->
name|addend
operator|)
operator|&
name|rel
operator|->
name|howto
operator|->
name|dst_mask
operator|)
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|outbfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|rel
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* If this reloc is against an stubbed symbol and the 		 next instruction is 		     cror 31,31,31 		 then we replace the next instruction with 		     lwz  r2,20(r1) 		 This reloads the TOC pointer after a stub call.  */
if|if
condition|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|bfd_get_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|rel
operator|->
name|address
operator|+
literal|4
argument_list|)
operator|==
literal|0x4ffffb82
operator|)
condition|)
comment|/* cror 31,31,31 */
name|bfd_put_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0x80410014
argument_list|,
comment|/* lwz r2,20(r1) */
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|rel
operator|->
name|address
operator|+
literal|4
argument_list|)
expr_stmt|;
operator|--
operator|*
name|reloc_count_ptr
expr_stmt|;
operator|--
name|relocs
expr_stmt|;
name|memmove
argument_list|(
name|relocs
argument_list|,
name|relocs
operator|+
literal|1
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|reloc_count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* When considering a TOC reloc, we do not want to include the 	 symbol value.  The symbol will be start of the TOC section 	 (which is named .got).  We do want to include the addend.  */
if|if
condition|(
name|rel
operator|->
name|howto
operator|==
name|toc_howto
condition|)
name|sym_value
operator|=
literal|0
expr_stmt|;
else|else
name|sym_value
operator|=
name|sym
operator|->
name|value
expr_stmt|;
comment|/* If this is a relocation against a symbol with a value, or 	 there is a reloc addend, we need to update the addend in the 	 object file.  */
if|if
condition|(
name|sym_value
operator|+
name|rel
operator|->
name|addend
operator|!=
literal|0
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
switch|switch
condition|(
name|rel
operator|->
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|1
case|:
name|val
operator|=
name|bfd_get_16
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|rel
operator|->
name|address
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
operator|~
name|rel
operator|->
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|&
name|rel
operator|->
name|howto
operator|->
name|src_mask
operator|)
operator|+
name|sym_value
operator|+
name|rel
operator|->
name|addend
operator|)
operator|&
name|rel
operator|->
name|howto
operator|->
name|dst_mask
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|val
operator|<
operator|-
literal|0x8000
operator|||
operator|(
name|bfd_signed_vma
operator|)
name|val
operator|>=
literal|0x8000
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"overflow when adjusting relocation against %s"
argument_list|)
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|outbfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|rel
operator|->
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|val
operator|=
name|bfd_get_32
argument_list|(
name|outbfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|rel
operator|->
name|address
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
operator|~
name|rel
operator|->
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
operator|(
operator|(
name|val
operator|&
name|rel
operator|->
name|howto
operator|->
name|src_mask
operator|)
operator|+
name|sym_value
operator|+
name|rel
operator|->
name|addend
operator|)
operator|&
name|rel
operator|->
name|howto
operator|->
name|dst_mask
operator|)
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|outbfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|rel
operator|->
name|address
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now that we have incorporated the addend, remove any TOC 	 relocs.  */
if|if
condition|(
name|rel
operator|->
name|howto
operator|==
name|toc_howto
condition|)
block|{
operator|--
operator|*
name|reloc_count_ptr
expr_stmt|;
operator|--
name|relocs
expr_stmt|;
name|memmove
argument_list|(
name|relocs
argument_list|,
name|relocs
operator|+
literal|1
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|reloc_count
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rel
operator|->
name|address
operator|+=
name|insec
operator|->
name|output_offset
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NLMCONV_POWERPC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Name of linker.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LD_NAME
end_ifndef

begin_define
define|#
directive|define
name|LD_NAME
value|"ld"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The user has specified several input files.  Invoke the linker to    link them all together, and convert and delete the resulting output    file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|link_inputs
parameter_list|(
name|struct
name|string_list
modifier|*
name|inputs
parameter_list|,
name|char
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|map_file
parameter_list|)
block|{
name|size_t
name|c
decl_stmt|;
name|struct
name|string_list
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|errfmt
decl_stmt|;
name|char
modifier|*
name|errarg
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|inputs
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
operator|++
name|c
expr_stmt|;
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|c
operator|+
literal|7
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
if|if
condition|(
name|ld
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Find the linker to invoke based on how nlmconv was run.  */
name|p
operator|=
name|program_name
operator|+
name|strlen
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|program_name
condition|)
block|{
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|ld
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|p
operator|-
name|program_name
operator|+
name|strlen
argument_list|(
name|LD_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ld
argument_list|,
name|program_name
argument_list|,
name|p
operator|-
name|program_name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ld
operator|+
operator|(
name|p
operator|-
name|program_name
operator|)
argument_list|,
name|LD_NAME
argument_list|)
expr_stmt|;
break|break;
block|}
operator|--
name|p
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|ld
operator|==
name|NULL
condition|)
name|ld
operator|=
operator|(
name|char
operator|*
operator|)
name|LD_NAME
expr_stmt|;
name|unlink_on_exit
operator|=
name|make_temp_file
argument_list|(
literal|".O"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|ld
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|"-Ur"
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|"-o"
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|=
name|unlink_on_exit
expr_stmt|;
comment|/* If we have been given the name of a mapfile and that      name is not 'stderr' then pass it on to the linker.  */
if|if
condition|(
name|map_file
operator|&&
operator|*
name|map_file
operator|&&
name|strcmp
argument_list|(
name|map_file
argument_list|,
literal|"stderr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argv
index|[
literal|4
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|"-Map"
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|=
name|map_file
expr_stmt|;
name|i
operator|=
literal|6
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|q
operator|=
name|inputs
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
operator|,
name|i
operator|++
control|)
name|argv
index|[
name|i
index|]
operator|=
name|q
operator|->
name|string
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
name|pexecute
argument_list|(
name|ld
argument_list|,
name|argv
argument_list|,
name|program_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|errfmt
argument_list|,
operator|&
name|errarg
argument_list|,
name|PEXECUTE_SEARCH
operator||
name|PEXECUTE_ONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: execution of %s failed: "
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|ld
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|errfmt
argument_list|,
name|errarg
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|unlink_on_exit
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pwait
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"pwait"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|unlink_on_exit
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Execution of %s failed"
argument_list|)
argument_list|,
name|ld
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|unlink_on_exit
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|unlink_on_exit
return|;
block|}
end_function

end_unit

