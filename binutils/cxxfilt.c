begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Demangler for GNU C++ - main program    Copyright 1989, 1991, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2005 Free Software Foundation, Inc.    Written by James Clark (jjc@jclark.uucp)    Rewritten by Fred Fish (fnf@cygnus.com) for ARM and Lucid demangling    Modified by Satish Pai (pai@apollo.hp.com) for HP demangling     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under    the terms of the GNU General Public License as published by the Free    Software Foundation; either version 2, or (at your option) any later    version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License    for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|flags
init|=
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
operator||
name|DMGL_VERBOSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|strip_underscore
init|=
name|TARGET_PREPENDS_UNDERSCORE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"strip-underscore"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'_'
block|}
block|,
block|{
literal|"format"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"no-params"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"no-strip-underscores"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"no-verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"types"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|demangle_it
parameter_list|(
name|char
modifier|*
name|mangled_name
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|unsigned
name|int
name|skip_first
init|=
literal|0
decl_stmt|;
comment|/* _ and $ are sometimes found at the start of function names      in assembler sources in order to distinguish them from other      names (eg register names).  So skip them here.  */
if|if
condition|(
name|mangled_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|mangled_name
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
operator|++
name|skip_first
expr_stmt|;
if|if
condition|(
name|strip_underscore
operator|&&
name|mangled_name
index|[
name|skip_first
index|]
operator|==
literal|'_'
condition|)
operator|++
name|skip_first
expr_stmt|;
name|result
operator|=
name|cplus_demangle
argument_list|(
name|mangled_name
operator|+
name|skip_first
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|printf
argument_list|(
name|mangled_name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mangled_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|putchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_demangler_list
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
specifier|const
name|struct
name|demangler_engine
modifier|*
name|demangler
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"{%s"
argument_list|,
name|libiberty_demanglers
operator|->
name|demangling_style_name
argument_list|)
expr_stmt|;
for|for
control|(
name|demangler
operator|=
name|libiberty_demanglers
operator|+
literal|1
init|;
name|demangler
operator|->
name|demangling_style
operator|!=
name|unknown_demangling
condition|;
operator|++
name|demangler
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|demangler
operator|->
name|demangling_style_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ Usage: %s [options] [mangled names]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ Options are:\n\   [-_|--strip-underscore]     Ignore first leading underscore%s\n"
argument_list|,
name|TARGET_PREPENDS_UNDERSCORE
condition|?
literal|" (default)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\   [-n|--no-strip-underscore]  Do not ignore a leading underscore%s\n"
argument_list|,
name|TARGET_PREPENDS_UNDERSCORE
condition|?
literal|""
else|:
literal|" (default)"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\   [-p|--no-params]            Do not display function arguments\n\   [-i|--no-verbose]           Do not show implementation details (if any)\n\   [-t|--types]                Also attempt to demangle type encodings\n\   [-s|--format "
argument_list|)
expr_stmt|;
name|print_demangler_list
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\   [@<file>]                   Read extra options from<file>\n\   [-h|--help]                 Display this information\n\   [-v|--version]              Show the version information\n\ Demangled names are displayed to stdout.\n\ If a name cannot be demangled it is just echoed to stdout.\n\ If no names are provided on the command line, stdin is read.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the string of non-alnum characters that may occur    as a valid symbol component, in the standard assembler symbol    syntax.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|standard_symbol_characters
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|"_$."
return|;
block|}
end_function

begin_comment
comment|/* Return the string of non-alnum characters that may occur    as a valid symbol name component in an HP object file.     Note that, since HP's compiler generates object code straight from    C++ source, without going through an assembler, its mangled    identifiers can use all sorts of characters that no assembler would    tolerate, so the alphabet this function creates is a little odd.    Here are some sample mangled identifiers offered by HP:  	typeid*__XT24AddressIndExpClassMember_ 	[Vftptr]key:__dt__32OrdinaryCompareIndExpClassMemberFv 	__ct__Q2_9Elf64_Dyn18{unnamed.union.#1}Fv     This still seems really weird to me, since nowhere else in this    file is there anything to recognize curly brackets, parens, etc.    I've talked with Srikanth<srikanth@cup.hp.com>, and he assures me    this is right, but I still strongly suspect that there's a    misunderstanding here.     If we decide it's better for c++filt to use HP's assembler syntax    to scrape identifiers out of its input, here's the definition of    the symbol name syntax from the HP assembler manual:         Symbols are composed of uppercase and lowercase letters, decimal        digits, dollar symbol, period (.), ampersand (&), pound sign(#) and        underscore (_). A symbol can begin with a letter, digit underscore or        dollar sign. If a symbol begins with a digit, it must contain a        non-digit character.     So have fun.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hp_symbol_characters
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|"_$.<>#,*&[]:(){}"
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|valid_symbols
decl_stmt|;
name|enum
name|demangling_styles
name|style
init|=
name|auto_demangling
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|expandargv
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"_hinps:tv"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'n'
case|:
name|strip_underscore
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|flags
operator|&=
operator|~
name|DMGL_PARAMS
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|flags
operator||=
name|DMGL_TYPES
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|flags
operator|&=
operator|~
name|DMGL_VERBOSE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|print_version
argument_list|(
literal|"c++filt"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'_'
case|:
name|strip_underscore
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|style
operator|=
name|cplus_demangle_name_to_style
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|unknown_demangling
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown demangling style `%s'\n"
argument_list|,
name|program_name
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|cplus_demangle_set_style
argument_list|(
name|style
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|demangle_it
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|current_demangling_style
condition|)
block|{
case|case
name|gnu_demangling
case|:
case|case
name|lucid_demangling
case|:
case|case
name|arm_demangling
case|:
case|case
name|java_demangling
case|:
case|case
name|edg_demangling
case|:
case|case
name|gnat_demangling
case|:
case|case
name|gnu_v3_demangling
case|:
case|case
name|auto_demangling
case|:
name|valid_symbols
operator|=
name|standard_symbol_characters
argument_list|()
expr_stmt|;
break|break;
case|case
name|hp_demangling
case|:
name|valid_symbols
operator|=
name|hp_symbol_characters
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* Folks should explicitly indicate the appropriate alphabet for 	 each demangling.  Providing a default would allow the 	 question to go unconsidered.  */
name|fatal
argument_list|(
literal|"Internal error: no symbol alphabet for current style"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|static
name|char
name|mbuffer
index|[
literal|32767
index|]
decl_stmt|;
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* Try to read a mangled name.  */
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
operator|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
operator|||
name|strchr
argument_list|(
name|valid_symbols
argument_list|,
name|c
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|>=
sizeof|sizeof
argument_list|(
name|mbuffer
argument_list|)
operator|-
literal|1
condition|)
break|break;
name|mbuffer
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|mbuffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|demangle_it
argument_list|(
name|mbuffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
comment|/* Echo the whitespace characters so that the output looks 	 like the input, only with the mangled names demangled.  */
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

