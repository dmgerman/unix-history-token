begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* A Bison parser, made from nlmheader.y    by GNU bison 1.35.  */
end_comment

begin_define
define|#
directive|define
name|YYBISON
value|1
end_define

begin_comment
comment|/* Identify Bison output.  */
end_comment

begin_define
define|#
directive|define
name|CHECK
value|257
end_define

begin_define
define|#
directive|define
name|CODESTART
value|258
end_define

begin_define
define|#
directive|define
name|COPYRIGHT
value|259
end_define

begin_define
define|#
directive|define
name|CUSTOM
value|260
end_define

begin_define
define|#
directive|define
name|DATE
value|261
end_define

begin_define
define|#
directive|define
name|DEBUG
value|262
end_define

begin_define
define|#
directive|define
name|DESCRIPTION
value|263
end_define

begin_define
define|#
directive|define
name|EXIT
value|264
end_define

begin_define
define|#
directive|define
name|EXPORT
value|265
end_define

begin_define
define|#
directive|define
name|FLAG_ON
value|266
end_define

begin_define
define|#
directive|define
name|FLAG_OFF
value|267
end_define

begin_define
define|#
directive|define
name|FULLMAP
value|268
end_define

begin_define
define|#
directive|define
name|HELP
value|269
end_define

begin_define
define|#
directive|define
name|IMPORT
value|270
end_define

begin_define
define|#
directive|define
name|INPUT
value|271
end_define

begin_define
define|#
directive|define
name|MAP
value|272
end_define

begin_define
define|#
directive|define
name|MESSAGES
value|273
end_define

begin_define
define|#
directive|define
name|MODULE
value|274
end_define

begin_define
define|#
directive|define
name|MULTIPLE
value|275
end_define

begin_define
define|#
directive|define
name|OS_DOMAIN
value|276
end_define

begin_define
define|#
directive|define
name|OUTPUT
value|277
end_define

begin_define
define|#
directive|define
name|PSEUDOPREEMPTION
value|278
end_define

begin_define
define|#
directive|define
name|REENTRANT
value|279
end_define

begin_define
define|#
directive|define
name|SCREENNAME
value|280
end_define

begin_define
define|#
directive|define
name|SHARELIB
value|281
end_define

begin_define
define|#
directive|define
name|STACK
value|282
end_define

begin_define
define|#
directive|define
name|START
value|283
end_define

begin_define
define|#
directive|define
name|SYNCHRONIZE
value|284
end_define

begin_define
define|#
directive|define
name|THREADNAME
value|285
end_define

begin_define
define|#
directive|define
name|TYPE
value|286
end_define

begin_define
define|#
directive|define
name|VERBOSE
value|287
end_define

begin_define
define|#
directive|define
name|VERSIONK
value|288
end_define

begin_define
define|#
directive|define
name|XDCDATA
value|289
end_define

begin_define
define|#
directive|define
name|STRING
value|290
end_define

begin_define
define|#
directive|define
name|QUOTED_STRING
value|291
end_define

begin_line
line|#
directive|line
number|1
file|"nlmheader.y"
end_line

begin_comment
comment|/* nlmheader.y - parse NLM header specification keywords.      Copyright 1993, 1994, 1995, 1997, 1998, 2001, 2002, 2003      Free Software Foundation, Inc.  This file is part of GNU Binutils.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written by Ian Lance Taylor<ian@cygnus.com>.     This bison file parses the commands recognized by the NetWare NLM    linker, except for lists of object files.  It stores the    information in global variables.     This implementation is based on the description in the NetWare Tool    Maker Specification manual, edition 1.0.  */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"nlm/common.h"
end_include

begin_include
include|#
directive|include
file|"nlm/internal.h"
end_include

begin_include
include|#
directive|include
file|"nlmconv.h"
end_include

begin_comment
comment|/* Information is stored in the structures pointed to by these    variables.  */
end_comment

begin_decl_stmt
name|Nlm_Internal_Fixed_Header
modifier|*
name|fixed_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Nlm_Internal_Variable_Header
modifier|*
name|var_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Nlm_Internal_Version_Header
modifier|*
name|version_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Nlm_Internal_Copyright_Header
modifier|*
name|copyright_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Nlm_Internal_Extended_Header
modifier|*
name|extended_hdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Procedure named by CHECK.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|check_procedure
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File named by CUSTOM.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|custom_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to generate debugging information (DEBUG).  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|debug_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Procedure named by EXIT.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|exit_procedure
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exported symbols (EXPORT).  */
end_comment

begin_decl_stmt
name|struct
name|string_list
modifier|*
name|export_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of files from INPUT.  */
end_comment

begin_decl_stmt
name|struct
name|string_list
modifier|*
name|input_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map file name (MAP, FULLMAP).  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|map_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether a full map has been requested (FULLMAP).  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|full_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File named by HELP.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|help_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Imported symbols (IMPORT).  */
end_comment

begin_decl_stmt
name|struct
name|string_list
modifier|*
name|import_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File named by MESSAGES.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|message_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Autoload module list (MODULE).  */
end_comment

begin_decl_stmt
name|struct
name|string_list
modifier|*
name|modules
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File named by OUTPUT.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|output_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File named by SHARELIB.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sharelib_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start procedure name (START).  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|start_procedure
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VERBOSE.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RPC description file (XDCDATA).  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rpc_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of serious errors that have occurred.  */
end_comment

begin_decl_stmt
name|int
name|parse_errors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current symbol prefix when reading a list of import or export    symbols.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|symbol_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parser error message handler.  */
end_comment

begin_define
define|#
directive|define
name|yyerror
parameter_list|(
name|msg
parameter_list|)
value|nlmheader_error (msg);
end_define

begin_comment
comment|/* Local functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|yylex
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlmlex_file_push
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|nlmlex_file_open
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlmlex_buf_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
name|nlmlex_buf_add
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|nlmlex_get_number
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlmheader_identify
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlmheader_warn
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlmheader_error
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|string_list
modifier|*
name|string_list_cons
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|string_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|string_list
modifier|*
name|string_list_append
parameter_list|(
name|struct
name|string_list
modifier|*
parameter_list|,
name|struct
name|string_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|string_list
modifier|*
name|string_list_append1
parameter_list|(
name|struct
name|string_list
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|xstrdup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_line
line|#
directive|line
number|112
file|"nlmheader.y"
end_line

begin_ifndef
ifndef|#
directive|ifndef
name|YYSTYPE
end_ifndef

begin_typedef
typedef|typedef
union|union
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|struct
name|string_list
modifier|*
name|list
decl_stmt|;
block|}
name|yystype
typedef|;
end_typedef

begin_define
define|#
directive|define
name|YYSTYPE
value|yystype
end_define

begin_define
define|#
directive|define
name|YYSTYPE_IS_TRIVIAL
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|YYDEBUG
end_ifndef

begin_define
define|#
directive|define
name|YYDEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYFINAL
value|82
end_define

begin_define
define|#
directive|define
name|YYFLAG
value|-32768
end_define

begin_define
define|#
directive|define
name|YYNTBASE
value|40
end_define

begin_comment
comment|/* YYTRANSLATE(YYLEX) -- Bison token number corresponding to YYLEX. */
end_comment

begin_define
define|#
directive|define
name|YYTRANSLATE
parameter_list|(
name|x
parameter_list|)
value|((unsigned)(x)<= 291 ? yytranslate[x] : 50)
end_define

begin_comment
comment|/* YYTRANSLATE[YYLEX] -- Bison token number corresponding to YYLEX. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|yytranslate
index|[]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|38
block|,
literal|39
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yyprhs
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|6
block|,
literal|9
block|,
literal|12
block|,
literal|15
block|,
literal|18
block|,
literal|23
block|,
literal|25
block|,
literal|28
block|,
literal|31
block|,
literal|32
block|,
literal|36
block|,
literal|39
block|,
literal|42
block|,
literal|44
block|,
literal|47
block|,
literal|50
block|,
literal|51
block|,
literal|55
block|,
literal|58
block|,
literal|60
block|,
literal|63
block|,
literal|66
block|,
literal|69
block|,
literal|71
block|,
literal|73
block|,
literal|76
block|,
literal|78
block|,
literal|80
block|,
literal|83
block|,
literal|86
block|,
literal|89
block|,
literal|92
block|,
literal|94
block|,
literal|97
block|,
literal|100
block|,
literal|102
block|,
literal|107
block|,
literal|111
block|,
literal|114
block|,
literal|115
block|,
literal|117
block|,
literal|119
block|,
literal|121
block|,
literal|124
block|,
literal|127
block|,
literal|131
block|,
literal|133
block|,
literal|134
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yyrhs
index|[]
init|=
block|{
literal|41
block|,
literal|0
block|,
literal|0
block|,
literal|42
block|,
literal|41
block|,
literal|0
block|,
literal|3
block|,
literal|36
block|,
literal|0
block|,
literal|4
block|,
literal|36
block|,
literal|0
block|,
literal|5
block|,
literal|37
block|,
literal|0
block|,
literal|6
block|,
literal|36
block|,
literal|0
block|,
literal|7
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|0
block|,
literal|8
block|,
literal|0
block|,
literal|9
block|,
literal|37
block|,
literal|0
block|,
literal|10
block|,
literal|36
block|,
literal|0
block|,
literal|0
block|,
literal|11
block|,
literal|43
block|,
literal|45
block|,
literal|0
block|,
literal|12
block|,
literal|36
block|,
literal|0
block|,
literal|13
block|,
literal|36
block|,
literal|0
block|,
literal|14
block|,
literal|0
block|,
literal|14
block|,
literal|36
block|,
literal|0
block|,
literal|15
block|,
literal|36
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|44
block|,
literal|45
block|,
literal|0
block|,
literal|17
block|,
literal|49
block|,
literal|0
block|,
literal|18
block|,
literal|0
block|,
literal|18
block|,
literal|36
block|,
literal|0
block|,
literal|19
block|,
literal|36
block|,
literal|0
block|,
literal|20
block|,
literal|49
block|,
literal|0
block|,
literal|21
block|,
literal|0
block|,
literal|22
block|,
literal|0
block|,
literal|23
block|,
literal|36
block|,
literal|0
block|,
literal|24
block|,
literal|0
block|,
literal|25
block|,
literal|0
block|,
literal|26
block|,
literal|37
block|,
literal|0
block|,
literal|27
block|,
literal|36
block|,
literal|0
block|,
literal|28
block|,
literal|36
block|,
literal|0
block|,
literal|29
block|,
literal|36
block|,
literal|0
block|,
literal|30
block|,
literal|0
block|,
literal|31
block|,
literal|37
block|,
literal|0
block|,
literal|32
block|,
literal|36
block|,
literal|0
block|,
literal|33
block|,
literal|0
block|,
literal|34
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|0
block|,
literal|34
block|,
literal|36
block|,
literal|36
block|,
literal|0
block|,
literal|35
block|,
literal|36
block|,
literal|0
block|,
literal|0
block|,
literal|46
block|,
literal|0
block|,
literal|48
block|,
literal|0
block|,
literal|47
block|,
literal|0
block|,
literal|46
block|,
literal|48
block|,
literal|0
block|,
literal|46
block|,
literal|47
block|,
literal|0
block|,
literal|38
block|,
literal|36
block|,
literal|39
block|,
literal|0
block|,
literal|36
block|,
literal|0
block|,
literal|0
block|,
literal|36
block|,
literal|49
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_comment
comment|/* YYRLINE[YYN] -- source line where rule number YYN was defined. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yyrline
index|[]
init|=
block|{
literal|0
block|,
literal|143
block|,
literal|149
block|,
literal|151
block|,
literal|156
block|,
literal|161
block|,
literal|166
block|,
literal|183
block|,
literal|187
block|,
literal|205
block|,
literal|209
block|,
literal|225
block|,
literal|229
block|,
literal|229
block|,
literal|237
block|,
literal|242
block|,
literal|247
block|,
literal|252
block|,
literal|257
block|,
literal|261
block|,
literal|261
block|,
literal|269
block|,
literal|273
block|,
literal|277
block|,
literal|281
block|,
literal|285
block|,
literal|289
block|,
literal|293
block|,
literal|297
block|,
literal|304
block|,
literal|308
block|,
literal|312
block|,
literal|328
block|,
literal|332
block|,
literal|337
block|,
literal|341
block|,
literal|345
block|,
literal|361
block|,
literal|366
block|,
literal|370
block|,
literal|394
block|,
literal|410
block|,
literal|418
block|,
literal|423
block|,
literal|433
block|,
literal|438
block|,
literal|442
block|,
literal|446
block|,
literal|454
block|,
literal|465
block|,
literal|481
block|,
literal|486
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|YYDEBUG
operator|)
operator|||
name|defined
name|YYERROR_VERBOSE
end_if

begin_comment
comment|/* YYTNAME[TOKEN_NUM] -- String name of the token TOKEN_NUM. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|yytname
index|[]
init|=
block|{
literal|"$"
block|,
literal|"error"
block|,
literal|"$undefined."
block|,
literal|"CHECK"
block|,
literal|"CODESTART"
block|,
literal|"COPYRIGHT"
block|,
literal|"CUSTOM"
block|,
literal|"DATE"
block|,
literal|"DEBUG"
block|,
literal|"DESCRIPTION"
block|,
literal|"EXIT"
block|,
literal|"EXPORT"
block|,
literal|"FLAG_ON"
block|,
literal|"FLAG_OFF"
block|,
literal|"FULLMAP"
block|,
literal|"HELP"
block|,
literal|"IMPORT"
block|,
literal|"INPUT"
block|,
literal|"MAP"
block|,
literal|"MESSAGES"
block|,
literal|"MODULE"
block|,
literal|"MULTIPLE"
block|,
literal|"OS_DOMAIN"
block|,
literal|"OUTPUT"
block|,
literal|"PSEUDOPREEMPTION"
block|,
literal|"REENTRANT"
block|,
literal|"SCREENNAME"
block|,
literal|"SHARELIB"
block|,
literal|"STACK"
block|,
literal|"START"
block|,
literal|"SYNCHRONIZE"
block|,
literal|"THREADNAME"
block|,
literal|"TYPE"
block|,
literal|"VERBOSE"
block|,
literal|"VERSIONK"
block|,
literal|"XDCDATA"
block|,
literal|"STRING"
block|,
literal|"QUOTED_STRING"
block|,
literal|"'('"
block|,
literal|"')'"
block|,
literal|"file"
block|,
literal|"commands"
block|,
literal|"command"
block|,
literal|"@1"
block|,
literal|"@2"
block|,
literal|"symbol_list_opt"
block|,
literal|"symbol_list"
block|,
literal|"symbol_prefix"
block|,
literal|"symbol"
block|,
literal|"string_list"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yyr1
index|[]
init|=
block|{
literal|0
block|,
literal|40
block|,
literal|41
block|,
literal|41
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|43
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|44
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|45
block|,
literal|45
block|,
literal|46
block|,
literal|46
block|,
literal|46
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|49
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yyr2
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE    doesn't specify something else to do.  Zero means the default is an    error. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yydefact
index|[]
init|=
block|{
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|9
block|,
literal|0
block|,
literal|0
block|,
literal|12
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|0
block|,
literal|19
block|,
literal|50
block|,
literal|22
block|,
literal|0
block|,
literal|50
block|,
literal|26
block|,
literal|27
block|,
literal|0
block|,
literal|29
block|,
literal|30
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|35
block|,
literal|0
block|,
literal|0
block|,
literal|38
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|0
block|,
literal|10
block|,
literal|11
block|,
literal|42
block|,
literal|14
block|,
literal|15
block|,
literal|17
block|,
literal|18
block|,
literal|42
block|,
literal|50
block|,
literal|21
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|28
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|36
block|,
literal|37
block|,
literal|0
block|,
literal|41
block|,
literal|3
block|,
literal|0
block|,
literal|49
block|,
literal|0
block|,
literal|13
block|,
literal|43
block|,
literal|45
block|,
literal|44
block|,
literal|20
block|,
literal|51
block|,
literal|40
block|,
literal|8
block|,
literal|0
block|,
literal|47
block|,
literal|46
block|,
literal|39
block|,
literal|48
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yydefgoto
index|[]
init|=
block|{
literal|80
block|,
literal|34
block|,
literal|35
block|,
literal|43
block|,
literal|48
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|50
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yypact
index|[]
init|=
block|{
operator|-
literal|3
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|5
block|,
operator|-
literal|32768
block|,
literal|6
block|,
literal|8
block|,
operator|-
literal|32768
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
operator|-
literal|32768
block|,
literal|13
block|,
literal|14
block|,
literal|16
block|,
literal|13
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|17
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|18
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
operator|-
literal|32768
block|,
literal|23
block|,
literal|25
block|,
operator|-
literal|32768
block|,
literal|26
block|,
literal|27
block|,
operator|-
literal|32768
block|,
operator|-
literal|3
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|29
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|2
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|2
block|,
literal|13
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|30
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|31
block|,
operator|-
literal|32768
block|,
literal|32
block|,
operator|-
literal|32768
block|,
operator|-
literal|2
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|33
block|,
operator|-
literal|32768
block|,
literal|3
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|38
block|,
literal|51
block|,
operator|-
literal|32768
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yypgoto
index|[]
init|=
block|{
operator|-
literal|32768
block|,
literal|19
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|24
block|,
operator|-
literal|32768
block|,
operator|-
literal|9
block|,
literal|7
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYLAST
value|75
end_define

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yytable
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|53
block|,
literal|65
block|,
literal|36
block|,
literal|66
block|,
literal|37
block|,
literal|81
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|79
block|,
literal|41
block|,
literal|42
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|49
block|,
literal|51
block|,
literal|82
block|,
literal|52
block|,
literal|54
block|,
literal|63
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|76
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|72
block|,
literal|64
block|,
literal|73
block|,
literal|74
block|,
literal|75
block|,
literal|78
block|,
literal|0
block|,
literal|0
block|,
literal|71
block|,
literal|0
block|,
literal|0
block|,
literal|77
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yycheck
index|[]
init|=
block|{
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|18
block|,
literal|36
block|,
literal|36
block|,
literal|38
block|,
literal|36
block|,
literal|0
block|,
literal|37
block|,
literal|36
block|,
literal|36
block|,
literal|39
block|,
literal|37
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|0
block|,
literal|36
block|,
literal|36
block|,
literal|35
block|,
literal|37
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|68
block|,
literal|37
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|49
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|48
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|68
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
end_comment

begin_line
line|#
directive|line
number|3
file|"/usr/share/bison-1.35/bison.simple"
end_line

begin_comment
comment|/* Skeleton output parser for bison,     Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software    Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, when this file is copied by Bison into a    Bison output file, you may use that output file without restriction.    This special exception was added by the Free Software Foundation    in version 1.24 of Bison.  */
end_comment

begin_comment
comment|/* This is the parser code that is written into each bison parser when    the %semantic_parser declaration is not specified in the grammar.    It was written by Richard Stallman by simplifying the hairy parser    used when %semantic_parser is specified.  */
end_comment

begin_comment
comment|/* All symbols defined below should begin with yy or YY, to avoid    infringing on user name space.  This should be done even for local    variables, as they might otherwise be expanded by user macros.    There are some unavoidable exceptions within include files to    define necessary library symbols; they are noted "INFRINGES ON    USER NAME SPACE" below.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|yyoverflow
argument_list|)
operator|||
name|defined
argument_list|(
name|YYERROR_VERBOSE
argument_list|)
end_if

begin_comment
comment|/* The parser invokes alloca or malloc; define the necessary symbols.  */
end_comment

begin_if
if|#
directive|if
name|YYSTACK_USE_ALLOCA
end_if

begin_define
define|#
directive|define
name|YYSTACK_ALLOC
value|alloca
end_define

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|YYSTACK_USE_ALLOCA
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|alloca
argument_list|)
operator|||
name|defined
argument_list|(
name|_ALLOCA_H
argument_list|)
end_if

begin_define
define|#
directive|define
name|YYSTACK_ALLOC
value|alloca
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|YYSTACK_ALLOC
value|__builtin_alloca
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|YYSTACK_ALLOC
end_ifdef

begin_comment
comment|/* Pacify GCC's `empty if-body' warning. */
end_comment

begin_define
define|#
directive|define
name|YYSTACK_FREE
parameter_list|(
name|Ptr
parameter_list|)
value|do {
comment|/* empty */
value|; } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* INFRINGES ON USER NAME SPACE */
end_comment

begin_define
define|#
directive|define
name|YYSIZE_T
value|size_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYSTACK_ALLOC
value|malloc
end_define

begin_define
define|#
directive|define
name|YYSTACK_FREE
value|free
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (yyoverflow) || defined (YYERROR_VERBOSE) */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|yyoverflow
argument_list|)
expr|\
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__cplusplus
argument_list|)
expr|\
operator|||
operator|(
name|YYLTYPE_IS_TRIVIAL
operator|&&
name|YYSTYPE_IS_TRIVIAL
operator|)
operator|)
operator|)
end_if

begin_comment
comment|/* A type that is properly aligned for any stack member.  */
end_comment

begin_union
union|union
name|yyalloc
block|{
name|short
name|yyss
decl_stmt|;
name|YYSTYPE
name|yyvs
decl_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|YYLTYPE
name|yyls
decl_stmt|;
endif|#
directive|endif
block|}
union|;
end_union

begin_comment
comment|/* The size of the maximum gap between one aligned stack and the next.  */
end_comment

begin_define
define|#
directive|define
name|YYSTACK_GAP_MAX
value|(sizeof (union yyalloc) - 1)
end_define

begin_comment
comment|/* The size of an array large to enough to hold all stacks, each with    N elements.  */
end_comment

begin_if
if|#
directive|if
name|YYLSP_NEEDED
end_if

begin_define
define|#
directive|define
name|YYSTACK_BYTES
parameter_list|(
name|N
parameter_list|)
define|\
value|((N) * (sizeof (short) + sizeof (YYSTYPE) + sizeof (YYLTYPE))	\       + 2 * YYSTACK_GAP_MAX)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYSTACK_BYTES
parameter_list|(
name|N
parameter_list|)
define|\
value|((N) * (sizeof (short) + sizeof (YYSTYPE))				\       + YYSTACK_GAP_MAX)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Copy COUNT objects from FROM to TO.  The source and destination do    not overlap.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYCOPY
end_ifndef

begin_if
if|#
directive|if
literal|1
operator|<
name|__GNUC__
end_if

begin_define
define|#
directive|define
name|YYCOPY
parameter_list|(
name|To
parameter_list|,
name|From
parameter_list|,
name|Count
parameter_list|)
define|\
value|__builtin_memcpy (To, From, (Count) * sizeof (*(From)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYCOPY
parameter_list|(
name|To
parameter_list|,
name|From
parameter_list|,
name|Count
parameter_list|)
define|\
value|do					\ 	{					\ 	  register YYSIZE_T yyi;		\ 	  for (yyi = 0; yyi< (Count); yyi++)	\ 	    (To)[yyi] = (From)[yyi];		\ 	}					\       while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Relocate STACK from its old location to the new one.  The    local variables YYSIZE and YYSTACKSIZE give the old and new number of    elements in the stack, and YYPTR gives the new location of the    stack.  Advance YYPTR to a properly aligned location for the next    stack.  */
end_comment

begin_define
define|#
directive|define
name|YYSTACK_RELOCATE
parameter_list|(
name|Stack
parameter_list|)
define|\
value|do									\       {									\ 	YYSIZE_T yynewbytes;						\ 	YYCOPY (&yyptr->Stack, Stack, yysize);				\ 	Stack =&yyptr->Stack;						\ 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAX;	\ 	yyptr += yynewbytes / sizeof (*yyptr);				\       }									\     while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|YYSIZE_T
argument_list|)
operator|&&
name|defined
argument_list|(
name|__SIZE_TYPE__
argument_list|)
end_if

begin_define
define|#
directive|define
name|YYSIZE_T
value|__SIZE_TYPE__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|YYSIZE_T
argument_list|)
operator|&&
name|defined
argument_list|(
name|size_t
argument_list|)
end_if

begin_define
define|#
directive|define
name|YYSIZE_T
value|size_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|YYSIZE_T
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* INFRINGES ON USER NAME SPACE */
end_comment

begin_define
define|#
directive|define
name|YYSIZE_T
value|size_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|YYSIZE_T
argument_list|)
end_if

begin_define
define|#
directive|define
name|YYSIZE_T
value|unsigned int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|yyerrok
value|(yyerrstatus = 0)
end_define

begin_define
define|#
directive|define
name|yyclearin
value|(yychar = YYEMPTY)
end_define

begin_define
define|#
directive|define
name|YYEMPTY
value|-2
end_define

begin_define
define|#
directive|define
name|YYEOF
value|0
end_define

begin_define
define|#
directive|define
name|YYACCEPT
value|goto yyacceptlab
end_define

begin_define
define|#
directive|define
name|YYABORT
value|goto yyabortlab
end_define

begin_define
define|#
directive|define
name|YYERROR
value|goto yyerrlab1
end_define

begin_comment
comment|/* Like YYERROR except do call yyerror.  This remains here temporarily    to ease the transition to the new meaning of YYERROR, for GCC.    Once GCC version 2 has supplanted version 1, this can go.  */
end_comment

begin_define
define|#
directive|define
name|YYFAIL
value|goto yyerrlab
end_define

begin_define
define|#
directive|define
name|YYRECOVERING
parameter_list|()
value|(!!yyerrstatus)
end_define

begin_define
define|#
directive|define
name|YYBACKUP
parameter_list|(
name|Token
parameter_list|,
name|Value
parameter_list|)
define|\
value|do								\   if (yychar == YYEMPTY&& yylen == 1)				\     {								\       yychar = (Token);						\       yylval = (Value);						\       yychar1 = YYTRANSLATE (yychar);				\       YYPOPSTACK;						\       goto yybackup;						\     }								\   else								\     { 								\       yyerror ("syntax error: cannot back up");			\       YYERROR;							\     }								\ while (0)
end_define

begin_define
define|#
directive|define
name|YYTERROR
value|1
end_define

begin_define
define|#
directive|define
name|YYERRCODE
value|256
end_define

begin_comment
comment|/* YYLLOC_DEFAULT -- Compute the default location (before the actions    are run).     When YYLLOC_DEFAULT is run, CURRENT is set the location of the    first token.  By default, to implement support for ranges, extend    its range to the last symbol.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYLLOC_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|YYLLOC_DEFAULT
parameter_list|(
name|Current
parameter_list|,
name|Rhs
parameter_list|,
name|N
parameter_list|)
define|\
value|Current.last_line   = Rhs[N].last_line;	\    Current.last_column = Rhs[N].last_column;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYLEX -- calling `yylex' with the right arguments.  */
end_comment

begin_if
if|#
directive|if
name|YYPURE
end_if

begin_if
if|#
directive|if
name|YYLSP_NEEDED
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|YYLEX_PARAM
end_ifdef

begin_define
define|#
directive|define
name|YYLEX
value|yylex (&yylval,&yylloc, YYLEX_PARAM)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYLEX
value|yylex (&yylval,&yylloc)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !YYLSP_NEEDED */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYLEX_PARAM
end_ifdef

begin_define
define|#
directive|define
name|YYLEX
value|yylex (&yylval, YYLEX_PARAM)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYLEX
value|yylex (&yylval)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !YYLSP_NEEDED */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !YYPURE */
end_comment

begin_define
define|#
directive|define
name|YYLEX
value|yylex ()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !YYPURE */
end_comment

begin_comment
comment|/* Enable debugging if requested.  */
end_comment

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|YYFPRINTF
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* INFRINGES ON USER NAME SPACE */
end_comment

begin_define
define|#
directive|define
name|YYFPRINTF
value|fprintf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYDPRINTF
parameter_list|(
name|Args
parameter_list|)
define|\
value|do {						\   if (yydebug)					\     YYFPRINTF Args;				\ } while (0)
end_define

begin_comment
comment|/* Nonzero means print parse trace.  It is left uninitialized so that    multiple parsers can coexist.  */
end_comment

begin_decl_stmt
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !YYDEBUG */
end_comment

begin_define
define|#
directive|define
name|YYDPRINTF
parameter_list|(
name|Args
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !YYDEBUG */
end_comment

begin_comment
comment|/* YYINITDEPTH -- initial size of the parser's stacks.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYINITDEPTH
end_ifndef

begin_define
define|#
directive|define
name|YYINITDEPTH
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only    if the built-in stack extension method is used).     Do not make this value too large; the results are undefined if    SIZE_MAX< YYSTACK_BYTES (YYMAXDEPTH)    evaluated with infinite-precision integer arithmetic.  */
end_comment

begin_if
if|#
directive|if
name|YYMAXDEPTH
operator|==
literal|0
end_if

begin_undef
undef|#
directive|undef
name|YYMAXDEPTH
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|YYMAXDEPTH
end_ifndef

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|10000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|YYERROR_VERBOSE
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|yystrlen
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_STRING_H
argument_list|)
end_if

begin_define
define|#
directive|define
name|yystrlen
value|strlen
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Return the length of YYSTR.  */
end_comment

begin_function
specifier|static
name|YYSIZE_T
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
name|yystrlen
parameter_list|(
specifier|const
name|char
modifier|*
name|yystr
parameter_list|)
else|#
directive|else
function|yystrlen
parameter_list|(
name|yystr
parameter_list|)
specifier|const
name|char
modifier|*
name|yystr
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
specifier|const
name|char
modifier|*
name|yys
init|=
name|yystr
decl_stmt|;
while|while
condition|(
operator|*
name|yys
operator|++
operator|!=
literal|'\0'
condition|)
continue|continue;
return|return
name|yys
operator|-
name|yystr
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|yystpcpy
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_STRING_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|_GNU_SOURCE
argument_list|)
end_if

begin_define
define|#
directive|define
name|yystpcpy
value|stpcpy
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in    YYDEST.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
name|yystpcpy
parameter_list|(
name|char
modifier|*
name|yydest
parameter_list|,
specifier|const
name|char
modifier|*
name|yysrc
parameter_list|)
else|#
directive|else
function|yystpcpy
parameter_list|(
name|yydest
parameter_list|,
name|yysrc
parameter_list|)
name|char
modifier|*
name|yydest
decl_stmt|;
specifier|const
name|char
modifier|*
name|yysrc
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|char
modifier|*
name|yyd
init|=
name|yydest
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|yys
init|=
name|yysrc
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|yyd
operator|++
operator|=
operator|*
name|yys
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
continue|continue;
return|return
name|yyd
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_line
line|#
directive|line
number|315
file|"/usr/share/bison-1.35/bison.simple"
end_line

begin_comment
comment|/* The user can define YYPARSE_PARAM as the name of an argument to be passed    into yyparse.  The argument should have type void *.    It should actually point to an object.    Grammar actions can access the variable by casting it    to the proper pointer type.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYPARSE_PARAM
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_define
define|#
directive|define
name|YYPARSE_PARAM_ARG
value|void *YYPARSE_PARAM
end_define

begin_define
define|#
directive|define
name|YYPARSE_PARAM_DECL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYPARSE_PARAM_ARG
value|YYPARSE_PARAM
end_define

begin_define
define|#
directive|define
name|YYPARSE_PARAM_DECL
value|void *YYPARSE_PARAM;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !YYPARSE_PARAM */
end_comment

begin_define
define|#
directive|define
name|YYPARSE_PARAM_ARG
end_define

begin_define
define|#
directive|define
name|YYPARSE_PARAM_DECL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !YYPARSE_PARAM */
end_comment

begin_comment
comment|/* Prevent warning if -Wstrict-prototypes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|YYPARSE_PARAM
end_ifdef

begin_function_decl
name|int
name|yyparse
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|int
name|yyparse
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YY_DECL_VARIABLES -- depending whether we use a pure parser,    variables are global, or local to YYPARSE.  */
end_comment

begin_define
define|#
directive|define
name|YY_DECL_NON_LSP_VARIABLES
define|\
comment|/* The lookahead symbol.  */
define|\
value|int yychar;						\ 							\
comment|/* The semantic value of the lookahead symbol. */
value|\ YYSTYPE yylval;						\ 							\
comment|/* Number of parse errors so far.  */
value|\ int yynerrs;
end_define

begin_if
if|#
directive|if
name|YYLSP_NEEDED
end_if

begin_define
define|#
directive|define
name|YY_DECL_VARIABLES
define|\
value|YY_DECL_NON_LSP_VARIABLES			\ 						\
comment|/* Location data for the lookahead symbol.  */
value|\ YYLTYPE yylloc;
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YY_DECL_VARIABLES
define|\
value|YY_DECL_NON_LSP_VARIABLES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If nonreentrant, generate the variables here. */
end_comment

begin_if
if|#
directive|if
operator|!
name|YYPURE
end_if

begin_function
name|YY_DECL_VARIABLES
endif|#
directive|endif
comment|/* !YYPURE */
name|int
name|yyparse
parameter_list|(
name|YYPARSE_PARAM_ARG
parameter_list|)
function|YYPARSE_PARAM_DECL
block|{
comment|/* If reentrant, generate the variables here. */
if|#
directive|if
name|YYPURE
name|YY_DECL_VARIABLES
endif|#
directive|endif
comment|/* !YYPURE */
specifier|register
name|int
name|yystate
decl_stmt|;
specifier|register
name|int
name|yyn
decl_stmt|;
name|int
name|yyresult
decl_stmt|;
comment|/* Number of tokens to shift before error messages enabled.  */
name|int
name|yyerrstatus
decl_stmt|;
comment|/* Lookahead token as an internal (translated) token number.  */
name|int
name|yychar1
init|=
literal|0
decl_stmt|;
comment|/* Three stacks and their tools:      `yyss': related to states,      `yyvs': related to semantic values,      `yyls': related to locations.       Refer to the stacks thru separate pointers, to allow yyoverflow      to reallocate them elsewhere.  */
comment|/* The state stack. */
name|short
name|yyssa
index|[
name|YYINITDEPTH
index|]
decl_stmt|;
name|short
modifier|*
name|yyss
init|=
name|yyssa
decl_stmt|;
specifier|register
name|short
modifier|*
name|yyssp
decl_stmt|;
comment|/* The semantic value stack.  */
name|YYSTYPE
name|yyvsa
index|[
name|YYINITDEPTH
index|]
decl_stmt|;
name|YYSTYPE
modifier|*
name|yyvs
init|=
name|yyvsa
decl_stmt|;
specifier|register
name|YYSTYPE
modifier|*
name|yyvsp
decl_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
comment|/* The location stack.  */
name|YYLTYPE
name|yylsa
index|[
name|YYINITDEPTH
index|]
decl_stmt|;
name|YYLTYPE
modifier|*
name|yyls
init|=
name|yylsa
decl_stmt|;
name|YYLTYPE
modifier|*
name|yylsp
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|YYLSP_NEEDED
define|#
directive|define
name|YYPOPSTACK
value|(yyvsp--, yyssp--, yylsp--)
else|#
directive|else
define|#
directive|define
name|YYPOPSTACK
value|(yyvsp--, yyssp--)
endif|#
directive|endif
name|YYSIZE_T
name|yystacksize
init|=
name|YYINITDEPTH
decl_stmt|;
comment|/* The variables used to return semantic value and location from the      action routines.  */
name|YYSTYPE
name|yyval
decl_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|YYLTYPE
name|yyloc
decl_stmt|;
endif|#
directive|endif
comment|/* When reducing, the number of symbols on the RHS of the reduced      rule. */
name|int
name|yylen
decl_stmt|;
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Starting parse\n"
operator|)
argument_list|)
expr_stmt|;
name|yystate
operator|=
literal|0
expr_stmt|;
name|yyerrstatus
operator|=
literal|0
expr_stmt|;
name|yynerrs
operator|=
literal|0
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
comment|/* Cause a token to be read.  */
comment|/* Initialize stack pointers.      Waste one element of value and location stack      so that they stay on the same level as the state stack.      The wasted elements are never initialized.  */
name|yyssp
operator|=
name|yyss
expr_stmt|;
name|yyvsp
operator|=
name|yyvs
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|yylsp
operator|=
name|yyls
expr_stmt|;
endif|#
directive|endif
goto|goto
name|yysetstate
goto|;
comment|/*------------------------------------------------------------. | yynewstate -- Push a new state, which is found in yystate.  | `------------------------------------------------------------*/
name|yynewstate
label|:
comment|/* In all cases, when you get here, the value and location stacks      have just been pushed. so pushing a state here evens the stacks.      */
name|yyssp
operator|++
expr_stmt|;
name|yysetstate
label|:
operator|*
name|yyssp
operator|=
name|yystate
expr_stmt|;
if|if
condition|(
name|yyssp
operator|>=
name|yyss
operator|+
name|yystacksize
operator|-
literal|1
condition|)
block|{
comment|/* Get the current used size of the three stacks, in elements.  */
name|YYSIZE_T
name|yysize
init|=
name|yyssp
operator|-
name|yyss
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|yyoverflow
block|{
comment|/* Give user a chance to reallocate the stack. Use copies of 	   these so that the&'s don't force the real ones into 	   memory.  */
name|YYSTYPE
modifier|*
name|yyvs1
init|=
name|yyvs
decl_stmt|;
name|short
modifier|*
name|yyss1
init|=
name|yyss
decl_stmt|;
comment|/* Each stack pointer address is followed by the size of the 	   data in use in that stack, in bytes.  */
if|#
directive|if
name|YYLSP_NEEDED
name|YYLTYPE
modifier|*
name|yyls1
init|=
name|yyls
decl_stmt|;
comment|/* This used to be a conditional around just the two extra args, 	   but that might be undefined if yyoverflow is a macro.  */
name|yyoverflow
argument_list|(
literal|"parser stack overflow"
argument_list|,
operator|&
name|yyss1
argument_list|,
name|yysize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyssp
argument_list|)
argument_list|,
operator|&
name|yyvs1
argument_list|,
name|yysize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyvsp
argument_list|)
argument_list|,
operator|&
name|yyls1
argument_list|,
name|yysize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yylsp
argument_list|)
argument_list|,
operator|&
name|yystacksize
argument_list|)
expr_stmt|;
name|yyls
operator|=
name|yyls1
expr_stmt|;
else|#
directive|else
name|yyoverflow
argument_list|(
literal|"parser stack overflow"
argument_list|,
operator|&
name|yyss1
argument_list|,
name|yysize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyssp
argument_list|)
argument_list|,
operator|&
name|yyvs1
argument_list|,
name|yysize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyvsp
argument_list|)
argument_list|,
operator|&
name|yystacksize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yyss
operator|=
name|yyss1
expr_stmt|;
name|yyvs
operator|=
name|yyvs1
expr_stmt|;
block|}
else|#
directive|else
comment|/* no yyoverflow */
ifndef|#
directive|ifndef
name|YYSTACK_RELOCATE
goto|goto
name|yyoverflowlab
goto|;
else|#
directive|else
comment|/* Extend the stack our own way.  */
if|if
condition|(
name|yystacksize
operator|>=
name|YYMAXDEPTH
condition|)
goto|goto
name|yyoverflowlab
goto|;
name|yystacksize
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|yystacksize
operator|>
name|YYMAXDEPTH
condition|)
name|yystacksize
operator|=
name|YYMAXDEPTH
expr_stmt|;
block|{
name|short
modifier|*
name|yyss1
init|=
name|yyss
decl_stmt|;
name|union
name|yyalloc
modifier|*
name|yyptr
init|=
operator|(
expr|union
name|yyalloc
operator|*
operator|)
name|YYSTACK_ALLOC
argument_list|(
name|YYSTACK_BYTES
argument_list|(
name|yystacksize
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|yyptr
condition|)
goto|goto
name|yyoverflowlab
goto|;
name|YYSTACK_RELOCATE
argument_list|(
name|yyss
argument_list|)
expr_stmt|;
name|YYSTACK_RELOCATE
argument_list|(
name|yyvs
argument_list|)
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|YYSTACK_RELOCATE
argument_list|(
name|yyls
argument_list|)
expr_stmt|;
endif|#
directive|endif
undef|#
directive|undef
name|YYSTACK_RELOCATE
if|if
condition|(
name|yyss1
operator|!=
name|yyssa
condition|)
name|YYSTACK_FREE
argument_list|(
name|yyss1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* no yyoverflow */
name|yyssp
operator|=
name|yyss
operator|+
name|yysize
operator|-
literal|1
expr_stmt|;
name|yyvsp
operator|=
name|yyvs
operator|+
name|yysize
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|yylsp
operator|=
name|yyls
operator|+
name|yysize
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Stack size increased to %lu\n"
operator|,
operator|(
name|unsigned
name|long
name|int
operator|)
name|yystacksize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyssp
operator|>=
name|yyss
operator|+
name|yystacksize
operator|-
literal|1
condition|)
name|YYABORT
expr_stmt|;
block|}
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Entering state %d\n"
operator|,
name|yystate
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|yybackup
goto|;
comment|/*-----------. | yybackup.  | `-----------*/
name|yybackup
label|:
comment|/* Do appropriate processing given the current state.  */
comment|/* Read a lookahead token if we need one and don't already have one.  */
comment|/* yyresume: */
comment|/* First try to decide what to do without reference to lookahead token.  */
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|==
name|YYFLAG
condition|)
goto|goto
name|yydefault
goto|;
comment|/* Not known => get a lookahead token if don't already have one.  */
comment|/* yychar is either YYEMPTY or YYEOF      or a valid token in external form.  */
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
condition|)
block|{
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Reading a token: "
operator|)
argument_list|)
expr_stmt|;
name|yychar
operator|=
name|YYLEX
expr_stmt|;
block|}
comment|/* Convert token to internal form (in yychar1) for indexing tables with */
if|if
condition|(
name|yychar
operator|<=
literal|0
condition|)
comment|/* This means end of input. */
block|{
name|yychar1
operator|=
literal|0
expr_stmt|;
name|yychar
operator|=
name|YYEOF
expr_stmt|;
comment|/* Don't call YYLEX any more */
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Now at end of input.\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yychar1
operator|=
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
expr_stmt|;
if|#
directive|if
name|YYDEBUG
comment|/* We have to keep this `#if YYDEBUG', since we use variables 	which are defined only if `YYDEBUG' is set.  */
if|if
condition|(
name|yydebug
condition|)
block|{
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|"Next token is %d (%s"
argument_list|,
name|yychar
argument_list|,
name|yytname
index|[
name|yychar1
index|]
argument_list|)
expr_stmt|;
comment|/* Give the individual parser a way to print the precise 	     meaning of a token, for further debugging info.  */
ifdef|#
directive|ifdef
name|YYPRINT
name|YYPRINT
argument_list|(
name|stderr
argument_list|,
name|yychar
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|yyn
operator|+=
name|yychar1
expr_stmt|;
if|if
condition|(
name|yyn
operator|<
literal|0
operator|||
name|yyn
operator|>
name|YYLAST
operator|||
name|yycheck
index|[
name|yyn
index|]
operator|!=
name|yychar1
condition|)
goto|goto
name|yydefault
goto|;
name|yyn
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
comment|/* yyn is what to do for this token type in this state.      Negative => reduce, -yyn is rule number.      Positive => shift, yyn is new state.        New state is final state => don't bother to shift,        just return success.      0, or most negative number => error.  */
if|if
condition|(
name|yyn
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|yyn
operator|==
name|YYFLAG
condition|)
goto|goto
name|yyerrlab
goto|;
name|yyn
operator|=
operator|-
name|yyn
expr_stmt|;
goto|goto
name|yyreduce
goto|;
block|}
elseif|else
if|if
condition|(
name|yyn
operator|==
literal|0
condition|)
goto|goto
name|yyerrlab
goto|;
if|if
condition|(
name|yyn
operator|==
name|YYFINAL
condition|)
name|YYACCEPT
expr_stmt|;
comment|/* Shift the lookahead token.  */
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Shifting token %d (%s), "
operator|,
name|yychar
operator|,
name|yytname
index|[
name|yychar1
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* Discard the token being shifted unless it is eof.  */
if|if
condition|(
name|yychar
operator|!=
name|YYEOF
condition|)
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
operator|*
operator|++
name|yyvsp
operator|=
name|yylval
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
operator|*
operator|++
name|yylsp
operator|=
name|yylloc
expr_stmt|;
endif|#
directive|endif
comment|/* Count tokens shifted since error; after three, turn off error      status.  */
if|if
condition|(
name|yyerrstatus
condition|)
name|yyerrstatus
operator|--
expr_stmt|;
name|yystate
operator|=
name|yyn
expr_stmt|;
goto|goto
name|yynewstate
goto|;
comment|/*-----------------------------------------------------------. | yydefault -- do the default action for the current state.  | `-----------------------------------------------------------*/
name|yydefault
label|:
name|yyn
operator|=
name|yydefact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|==
literal|0
condition|)
goto|goto
name|yyerrlab
goto|;
goto|goto
name|yyreduce
goto|;
comment|/*-----------------------------. | yyreduce -- Do a reduction.  | `-----------------------------*/
name|yyreduce
label|:
comment|/* yyn is the number of a rule to reduce with.  */
name|yylen
operator|=
name|yyr2
index|[
name|yyn
index|]
expr_stmt|;
comment|/* If YYLEN is nonzero, implement the default value of the action:      `$$ = $1'.       Otherwise, the following line sets YYVAL to the semantic value of      the lookahead token.  This behavior is undocumented and Bison      users should not rely upon it.  Assigning to YYVAL      unconditionally makes the parser a bit smaller, and it avoids a      GCC warning that YYVAL may be used uninitialized.  */
name|yyval
operator|=
name|yyvsp
index|[
literal|1
operator|-
name|yylen
index|]
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
comment|/* Similarly for the default location.  Let the user run additional      commands if for instance locations are ranges.  */
name|yyloc
operator|=
name|yylsp
index|[
literal|1
operator|-
name|yylen
index|]
expr_stmt|;
name|YYLLOC_DEFAULT
argument_list|(
name|yyloc
argument_list|,
operator|(
name|yylsp
operator|-
name|yylen
operator|)
argument_list|,
name|yylen
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|YYDEBUG
comment|/* We have to keep this `#if YYDEBUG', since we use variables which      are defined only if `YYDEBUG' is set.  */
if|if
condition|(
name|yydebug
condition|)
block|{
name|int
name|yyi
decl_stmt|;
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|"Reducing via rule %d (line %d), "
argument_list|,
name|yyn
argument_list|,
name|yyrline
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
comment|/* Print the symbols being reduced, and their result.  */
for|for
control|(
name|yyi
operator|=
name|yyprhs
index|[
name|yyn
index|]
init|;
name|yyrhs
index|[
name|yyi
index|]
operator|>
literal|0
condition|;
name|yyi
operator|++
control|)
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|yytname
index|[
name|yyrhs
index|[
name|yyi
index|]
index|]
argument_list|)
expr_stmt|;
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|" -> %s\n"
argument_list|,
name|yytname
index|[
name|yyr1
index|[
name|yyn
index|]
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|yyn
condition|)
block|{
case|case
literal|4
case|:
line|#
directive|line
number|158
file|"nlmheader.y"
block|{
name|check_procedure
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
block|}
break|break;
case|case
literal|5
case|:
line|#
directive|line
number|162
file|"nlmheader.y"
block|{
name|nlmheader_warn
argument_list|(
name|_
argument_list|(
literal|"CODESTART is not implemented; sorry"
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|6
case|:
line|#
directive|line
number|167
file|"nlmheader.y"
block|{
name|int
name|len
decl_stmt|;
name|strncpy
argument_list|(
name|copyright_hdr
operator|->
name|stamp
argument_list|,
literal|"CoPyRiGhT="
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|NLM_MAX_COPYRIGHT_MESSAGE_LENGTH
condition|)
block|{
name|nlmheader_warn
argument_list|(
name|_
argument_list|(
literal|"copyright string is too long"
argument_list|)
argument_list|,
name|NLM_MAX_COPYRIGHT_MESSAGE_LENGTH
operator|-
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|NLM_MAX_COPYRIGHT_MESSAGE_LENGTH
operator|-
literal|1
expr_stmt|;
block|}
name|copyright_hdr
operator|->
name|copyrightMessageLength
operator|=
name|len
expr_stmt|;
name|strncpy
argument_list|(
name|copyright_hdr
operator|->
name|copyrightMessage
argument_list|,
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|copyright_hdr
operator|->
name|copyrightMessage
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|7
case|:
line|#
directive|line
number|184
file|"nlmheader.y"
block|{
name|custom_file
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
block|}
break|break;
case|case
literal|8
case|:
line|#
directive|line
number|188
file|"nlmheader.y"
block|{
comment|/* We don't set the version stamp here, because we use the 	       version stamp to detect whether the required VERSION 	       keyword was given.  */
name|version_hdr
operator|->
name|month
operator|=
name|nlmlex_get_number
argument_list|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|version_hdr
operator|->
name|day
operator|=
name|nlmlex_get_number
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|version_hdr
operator|->
name|year
operator|=
name|nlmlex_get_number
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|version_hdr
operator|->
name|month
operator|<
literal|1
operator|||
name|version_hdr
operator|->
name|month
operator|>
literal|12
condition|)
name|nlmheader_warn
argument_list|(
name|_
argument_list|(
literal|"illegal month"
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|version_hdr
operator|->
name|day
operator|<
literal|1
operator|||
name|version_hdr
operator|->
name|day
operator|>
literal|31
condition|)
name|nlmheader_warn
argument_list|(
name|_
argument_list|(
literal|"illegal day"
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|version_hdr
operator|->
name|year
operator|<
literal|1900
operator|||
name|version_hdr
operator|->
name|year
operator|>
literal|3000
condition|)
name|nlmheader_warn
argument_list|(
name|_
argument_list|(
literal|"illegal year"
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|9
case|:
line|#
directive|line
number|206
file|"nlmheader.y"
block|{
name|debug_info
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
literal|10
case|:
line|#
directive|line
number|210
file|"nlmheader.y"
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|NLM_MAX_DESCRIPTION_LENGTH
condition|)
block|{
name|nlmheader_warn
argument_list|(
name|_
argument_list|(
literal|"description string is too long"
argument_list|)
argument_list|,
name|NLM_MAX_DESCRIPTION_LENGTH
argument_list|)
expr_stmt|;
name|len
operator|=
name|NLM_MAX_DESCRIPTION_LENGTH
expr_stmt|;
block|}
name|var_hdr
operator|->
name|descriptionLength
operator|=
name|len
expr_stmt|;
name|strncpy
argument_list|(
name|var_hdr
operator|->
name|descriptionText
argument_list|,
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|var_hdr
operator|->
name|descriptionText
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|11
case|:
line|#
directive|line
number|226
file|"nlmheader.y"
block|{
name|exit_procedure
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
block|}
break|break;
case|case
literal|12
case|:
line|#
directive|line
number|230
file|"nlmheader.y"
block|{
name|symbol_prefix
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
literal|13
case|:
line|#
directive|line
number|234
file|"nlmheader.y"
block|{
name|export_symbols
operator|=
name|string_list_append
argument_list|(
name|export_symbols
argument_list|,
name|yyvsp
index|[
literal|0
index|]
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|14
case|:
line|#
directive|line
number|238
file|"nlmheader.y"
block|{
name|fixed_hdr
operator|->
name|flags
operator||=
name|nlmlex_get_number
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|15
case|:
line|#
directive|line
number|243
file|"nlmheader.y"
block|{
name|fixed_hdr
operator|->
name|flags
operator|&=
operator|~
name|nlmlex_get_number
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
line|#
directive|line
number|248
file|"nlmheader.y"
block|{
name|map_file
operator|=
literal|""
expr_stmt|;
name|full_map
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
literal|17
case|:
line|#
directive|line
number|253
file|"nlmheader.y"
block|{
name|map_file
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
name|full_map
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
literal|18
case|:
line|#
directive|line
number|258
file|"nlmheader.y"
block|{
name|help_file
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
block|}
break|break;
case|case
literal|19
case|:
line|#
directive|line
number|262
file|"nlmheader.y"
block|{
name|symbol_prefix
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
literal|20
case|:
line|#
directive|line
number|266
file|"nlmheader.y"
block|{
name|import_symbols
operator|=
name|string_list_append
argument_list|(
name|import_symbols
argument_list|,
name|yyvsp
index|[
literal|0
index|]
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|21
case|:
line|#
directive|line
number|270
file|"nlmheader.y"
block|{
name|input_files
operator|=
name|string_list_append
argument_list|(
name|input_files
argument_list|,
name|yyvsp
index|[
literal|0
index|]
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|22
case|:
line|#
directive|line
number|274
file|"nlmheader.y"
block|{
name|map_file
operator|=
literal|""
expr_stmt|;
block|}
break|break;
case|case
literal|23
case|:
line|#
directive|line
number|278
file|"nlmheader.y"
block|{
name|map_file
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
block|}
break|break;
case|case
literal|24
case|:
line|#
directive|line
number|282
file|"nlmheader.y"
block|{
name|message_file
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
block|}
break|break;
case|case
literal|25
case|:
line|#
directive|line
number|286
file|"nlmheader.y"
block|{
name|modules
operator|=
name|string_list_append
argument_list|(
name|modules
argument_list|,
name|yyvsp
index|[
literal|0
index|]
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|26
case|:
line|#
directive|line
number|290
file|"nlmheader.y"
block|{
name|fixed_hdr
operator|->
name|flags
operator||=
literal|0x2
expr_stmt|;
block|}
break|break;
case|case
literal|27
case|:
line|#
directive|line
number|294
file|"nlmheader.y"
block|{
name|fixed_hdr
operator|->
name|flags
operator||=
literal|0x10
expr_stmt|;
block|}
break|break;
case|case
literal|28
case|:
line|#
directive|line
number|298
file|"nlmheader.y"
block|{
if|if
condition|(
name|output_file
operator|==
name|NULL
condition|)
name|output_file
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
else|else
name|nlmheader_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring duplicate OUTPUT statement"
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|29
case|:
line|#
directive|line
number|305
file|"nlmheader.y"
block|{
name|fixed_hdr
operator|->
name|flags
operator||=
literal|0x8
expr_stmt|;
block|}
break|break;
case|case
literal|30
case|:
line|#
directive|line
number|309
file|"nlmheader.y"
block|{
name|fixed_hdr
operator|->
name|flags
operator||=
literal|0x1
expr_stmt|;
block|}
break|break;
case|case
literal|31
case|:
line|#
directive|line
number|313
file|"nlmheader.y"
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|NLM_MAX_SCREEN_NAME_LENGTH
condition|)
block|{
name|nlmheader_warn
argument_list|(
name|_
argument_list|(
literal|"screen name is too long"
argument_list|)
argument_list|,
name|NLM_MAX_SCREEN_NAME_LENGTH
argument_list|)
expr_stmt|;
name|len
operator|=
name|NLM_MAX_SCREEN_NAME_LENGTH
expr_stmt|;
block|}
name|var_hdr
operator|->
name|screenNameLength
operator|=
name|len
expr_stmt|;
name|strncpy
argument_list|(
name|var_hdr
operator|->
name|screenName
argument_list|,
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|var_hdr
operator|->
name|screenName
index|[
name|NLM_MAX_SCREEN_NAME_LENGTH
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|32
case|:
line|#
directive|line
number|329
file|"nlmheader.y"
block|{
name|sharelib_file
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
block|}
break|break;
case|case
literal|33
case|:
line|#
directive|line
number|333
file|"nlmheader.y"
block|{
name|var_hdr
operator|->
name|stackSize
operator|=
name|nlmlex_get_number
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|34
case|:
line|#
directive|line
number|338
file|"nlmheader.y"
block|{
name|start_procedure
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
block|}
break|break;
case|case
literal|35
case|:
line|#
directive|line
number|342
file|"nlmheader.y"
block|{
name|fixed_hdr
operator|->
name|flags
operator||=
literal|0x4
expr_stmt|;
block|}
break|break;
case|case
literal|36
case|:
line|#
directive|line
number|346
file|"nlmheader.y"
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|NLM_MAX_THREAD_NAME_LENGTH
condition|)
block|{
name|nlmheader_warn
argument_list|(
name|_
argument_list|(
literal|"thread name is too long"
argument_list|)
argument_list|,
name|NLM_MAX_THREAD_NAME_LENGTH
argument_list|)
expr_stmt|;
name|len
operator|=
name|NLM_MAX_THREAD_NAME_LENGTH
expr_stmt|;
block|}
name|var_hdr
operator|->
name|threadNameLength
operator|=
name|len
expr_stmt|;
name|strncpy
argument_list|(
name|var_hdr
operator|->
name|threadName
argument_list|,
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|var_hdr
operator|->
name|threadName
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|37
case|:
line|#
directive|line
number|362
file|"nlmheader.y"
block|{
name|fixed_hdr
operator|->
name|moduleType
operator|=
name|nlmlex_get_number
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|38
case|:
line|#
directive|line
number|367
file|"nlmheader.y"
block|{
name|verbose
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
literal|39
case|:
line|#
directive|line
number|371
file|"nlmheader.y"
block|{
name|long
name|val
decl_stmt|;
name|strncpy
argument_list|(
name|version_hdr
operator|->
name|stamp
argument_list|,
literal|"VeRsIoN#"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|version_hdr
operator|->
name|majorVersion
operator|=
name|nlmlex_get_number
argument_list|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|val
operator|=
name|nlmlex_get_number
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
literal|99
condition|)
name|nlmheader_warn
argument_list|(
name|_
argument_list|(
literal|"illegal minor version number (must be between 0 and 99)"
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|version_hdr
operator|->
name|minorVersion
operator|=
name|val
expr_stmt|;
name|val
operator|=
name|nlmlex_get_number
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|nlmheader_warn
argument_list|(
name|_
argument_list|(
literal|"illegal revision number (must be between 0 and 26)"
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|>
literal|26
condition|)
name|version_hdr
operator|->
name|revision
operator|=
literal|0
expr_stmt|;
else|else
name|version_hdr
operator|->
name|revision
operator|=
name|val
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|40
case|:
line|#
directive|line
number|395
file|"nlmheader.y"
block|{
name|long
name|val
decl_stmt|;
name|strncpy
argument_list|(
name|version_hdr
operator|->
name|stamp
argument_list|,
literal|"VeRsIoN#"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|version_hdr
operator|->
name|majorVersion
operator|=
name|nlmlex_get_number
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|val
operator|=
name|nlmlex_get_number
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
literal|99
condition|)
name|nlmheader_warn
argument_list|(
name|_
argument_list|(
literal|"illegal minor version number (must be between 0 and 99)"
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|version_hdr
operator|->
name|minorVersion
operator|=
name|val
expr_stmt|;
name|version_hdr
operator|->
name|revision
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|41
case|:
line|#
directive|line
number|411
file|"nlmheader.y"
block|{
name|rpc_file
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
block|}
break|break;
case|case
literal|42
case|:
line|#
directive|line
number|420
file|"nlmheader.y"
block|{
name|yyval
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
literal|43
case|:
line|#
directive|line
number|424
file|"nlmheader.y"
block|{
name|yyval
operator|.
name|list
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|list
expr_stmt|;
block|}
break|break;
case|case
literal|44
case|:
line|#
directive|line
number|435
file|"nlmheader.y"
block|{
name|yyval
operator|.
name|list
operator|=
name|string_list_cons
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|45
case|:
line|#
directive|line
number|439
file|"nlmheader.y"
block|{
name|yyval
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
literal|46
case|:
line|#
directive|line
number|443
file|"nlmheader.y"
block|{
name|yyval
operator|.
name|list
operator|=
name|string_list_append1
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|list
argument_list|,
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|47
case|:
line|#
directive|line
number|447
file|"nlmheader.y"
block|{
name|yyval
operator|.
name|list
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|list
expr_stmt|;
block|}
break|break;
case|case
literal|48
case|:
line|#
directive|line
number|456
file|"nlmheader.y"
block|{
if|if
condition|(
name|symbol_prefix
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|symbol_prefix
argument_list|)
expr_stmt|;
name|symbol_prefix
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|string
expr_stmt|;
block|}
break|break;
case|case
literal|49
case|:
line|#
directive|line
number|467
file|"nlmheader.y"
block|{
if|if
condition|(
name|symbol_prefix
operator|==
name|NULL
condition|)
name|yyval
operator|.
name|string
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
else|else
block|{
name|yyval
operator|.
name|string
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|symbol_prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|yyval
operator|.
name|string
argument_list|,
literal|"%s@%s"
argument_list|,
name|symbol_prefix
argument_list|,
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|50
case|:
line|#
directive|line
number|483
file|"nlmheader.y"
block|{
name|yyval
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
literal|51
case|:
line|#
directive|line
number|487
file|"nlmheader.y"
block|{
name|yyval
operator|.
name|list
operator|=
name|string_list_cons
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|string
argument_list|,
name|yyvsp
index|[
literal|0
index|]
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
line|#
directive|line
number|705
file|"/usr/share/bison-1.35/bison.simple"
name|yyvsp
operator|-=
name|yylen
expr_stmt|;
name|yyssp
operator|-=
name|yylen
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|yylsp
operator|-=
name|yylen
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
name|short
modifier|*
name|yyssp1
init|=
name|yyss
operator|-
literal|1
decl_stmt|;
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|"state stack now"
argument_list|)
expr_stmt|;
while|while
condition|(
name|yyssp1
operator|!=
name|yyssp
condition|)
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|" %d"
argument_list|,
operator|*
operator|++
name|yyssp1
argument_list|)
expr_stmt|;
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
operator|++
name|yyvsp
operator|=
name|yyval
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
operator|*
operator|++
name|yylsp
operator|=
name|yyloc
expr_stmt|;
endif|#
directive|endif
comment|/* Now `shift' the result of the reduction.  Determine what state      that goes to, based on the state we popped back to and the rule      number reduced by.  */
name|yyn
operator|=
name|yyr1
index|[
name|yyn
index|]
expr_stmt|;
name|yystate
operator|=
name|yypgoto
index|[
name|yyn
operator|-
name|YYNTBASE
index|]
operator|+
operator|*
name|yyssp
expr_stmt|;
if|if
condition|(
name|yystate
operator|>=
literal|0
operator|&&
name|yystate
operator|<=
name|YYLAST
operator|&&
name|yycheck
index|[
name|yystate
index|]
operator|==
operator|*
name|yyssp
condition|)
name|yystate
operator|=
name|yytable
index|[
name|yystate
index|]
expr_stmt|;
else|else
name|yystate
operator|=
name|yydefgoto
index|[
name|yyn
operator|-
name|YYNTBASE
index|]
expr_stmt|;
goto|goto
name|yynewstate
goto|;
comment|/*------------------------------------. | yyerrlab -- here on detecting error | `------------------------------------*/
name|yyerrlab
label|:
comment|/* If not already recovering from an error, report this error.  */
if|if
condition|(
operator|!
name|yyerrstatus
condition|)
block|{
operator|++
name|yynerrs
expr_stmt|;
ifdef|#
directive|ifdef
name|YYERROR_VERBOSE
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|>
name|YYFLAG
operator|&&
name|yyn
operator|<
name|YYLAST
condition|)
block|{
name|YYSIZE_T
name|yysize
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|yymsg
decl_stmt|;
name|int
name|yyx
decl_stmt|,
name|yycount
decl_stmt|;
name|yycount
operator|=
literal|0
expr_stmt|;
comment|/* Start YYX at -YYN if negative to avoid negative indexes in 	     YYCHECK.  */
for|for
control|(
name|yyx
operator|=
name|yyn
operator|<
literal|0
condition|?
operator|-
name|yyn
else|:
literal|0
init|;
name|yyx
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|yytname
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
condition|;
name|yyx
operator|++
control|)
if|if
condition|(
name|yycheck
index|[
name|yyx
operator|+
name|yyn
index|]
operator|==
name|yyx
condition|)
name|yysize
operator|+=
name|yystrlen
argument_list|(
name|yytname
index|[
name|yyx
index|]
argument_list|)
operator|+
literal|15
operator|,
name|yycount
operator|++
expr_stmt|;
name|yysize
operator|+=
name|yystrlen
argument_list|(
literal|"parse error, unexpected "
argument_list|)
operator|+
literal|1
expr_stmt|;
name|yysize
operator|+=
name|yystrlen
argument_list|(
name|yytname
index|[
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|yymsg
operator|=
operator|(
name|char
operator|*
operator|)
name|YYSTACK_ALLOC
argument_list|(
name|yysize
argument_list|)
expr_stmt|;
if|if
condition|(
name|yymsg
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|yyp
init|=
name|yystpcpy
argument_list|(
name|yymsg
argument_list|,
literal|"parse error, unexpected "
argument_list|)
decl_stmt|;
name|yyp
operator|=
name|yystpcpy
argument_list|(
name|yyp
argument_list|,
name|yytname
index|[
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|yycount
operator|<
literal|5
condition|)
block|{
name|yycount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|yyx
operator|=
name|yyn
operator|<
literal|0
condition|?
operator|-
name|yyn
else|:
literal|0
init|;
name|yyx
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|yytname
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
condition|;
name|yyx
operator|++
control|)
if|if
condition|(
name|yycheck
index|[
name|yyx
operator|+
name|yyn
index|]
operator|==
name|yyx
condition|)
block|{
specifier|const
name|char
modifier|*
name|yyq
init|=
operator|!
name|yycount
condition|?
literal|", expecting "
else|:
literal|" or "
decl_stmt|;
name|yyp
operator|=
name|yystpcpy
argument_list|(
name|yyp
argument_list|,
name|yyq
argument_list|)
expr_stmt|;
name|yyp
operator|=
name|yystpcpy
argument_list|(
name|yyp
argument_list|,
name|yytname
index|[
name|yyx
index|]
argument_list|)
expr_stmt|;
name|yycount
operator|++
expr_stmt|;
block|}
block|}
name|yyerror
argument_list|(
name|yymsg
argument_list|)
expr_stmt|;
name|YYSTACK_FREE
argument_list|(
name|yymsg
argument_list|)
expr_stmt|;
block|}
else|else
name|yyerror
argument_list|(
literal|"parse error; also virtual memory exhausted"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* defined (YYERROR_VERBOSE) */
name|yyerror
argument_list|(
literal|"parse error"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|yyerrlab1
goto|;
comment|/*--------------------------------------------------. | yyerrlab1 -- error raised explicitly by an action | `--------------------------------------------------*/
name|yyerrlab1
label|:
if|if
condition|(
name|yyerrstatus
operator|==
literal|3
condition|)
block|{
comment|/* If just tried and failed to reuse lookahead token after an 	 error, discard it.  */
comment|/* return failure if at end of input */
if|if
condition|(
name|yychar
operator|==
name|YYEOF
condition|)
name|YYABORT
expr_stmt|;
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Discarding token %d (%s).\n"
operator|,
name|yychar
operator|,
name|yytname
index|[
name|yychar1
index|]
operator|)
argument_list|)
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
block|}
comment|/* Else will try to reuse lookahead token after shifting the error      token.  */
name|yyerrstatus
operator|=
literal|3
expr_stmt|;
comment|/* Each real token shifted decrements this */
goto|goto
name|yyerrhandle
goto|;
comment|/*-------------------------------------------------------------------. | yyerrdefault -- current state does not do anything special for the | | error token.                                                       | `-------------------------------------------------------------------*/
name|yyerrdefault
label|:
if|#
directive|if
literal|0
comment|/* This is wrong; only states that explicitly want error tokens      should shift them.  */
comment|/* If its default is to accept any token, ok.  Otherwise pop it.  */
block|yyn = yydefact[yystate];   if (yyn)     goto yydefault;
endif|#
directive|endif
comment|/*---------------------------------------------------------------. | yyerrpop -- pop the current state because it cannot handle the | | error token                                                    | `---------------------------------------------------------------*/
name|yyerrpop
label|:
if|if
condition|(
name|yyssp
operator|==
name|yyss
condition|)
name|YYABORT
expr_stmt|;
name|yyvsp
operator|--
expr_stmt|;
name|yystate
operator|=
operator|*
operator|--
name|yyssp
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|yylsp
operator|--
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
name|short
modifier|*
name|yyssp1
init|=
name|yyss
operator|-
literal|1
decl_stmt|;
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|"Error: state stack now"
argument_list|)
expr_stmt|;
while|while
condition|(
name|yyssp1
operator|!=
name|yyssp
condition|)
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|" %d"
argument_list|,
operator|*
operator|++
name|yyssp1
argument_list|)
expr_stmt|;
name|YYFPRINTF
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*--------------. | yyerrhandle.  | `--------------*/
name|yyerrhandle
label|:
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|==
name|YYFLAG
condition|)
goto|goto
name|yyerrdefault
goto|;
name|yyn
operator|+=
name|YYTERROR
expr_stmt|;
if|if
condition|(
name|yyn
operator|<
literal|0
operator|||
name|yyn
operator|>
name|YYLAST
operator|||
name|yycheck
index|[
name|yyn
index|]
operator|!=
name|YYTERROR
condition|)
goto|goto
name|yyerrdefault
goto|;
name|yyn
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|yyn
operator|==
name|YYFLAG
condition|)
goto|goto
name|yyerrpop
goto|;
name|yyn
operator|=
operator|-
name|yyn
expr_stmt|;
goto|goto
name|yyreduce
goto|;
block|}
elseif|else
if|if
condition|(
name|yyn
operator|==
literal|0
condition|)
goto|goto
name|yyerrpop
goto|;
if|if
condition|(
name|yyn
operator|==
name|YYFINAL
condition|)
name|YYACCEPT
expr_stmt|;
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Shifting error token, "
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|++
name|yyvsp
operator|=
name|yylval
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
operator|*
operator|++
name|yylsp
operator|=
name|yylloc
expr_stmt|;
endif|#
directive|endif
name|yystate
operator|=
name|yyn
expr_stmt|;
goto|goto
name|yynewstate
goto|;
comment|/*-------------------------------------. | yyacceptlab -- YYACCEPT comes here.  | `-------------------------------------*/
name|yyacceptlab
label|:
name|yyresult
operator|=
literal|0
expr_stmt|;
goto|goto
name|yyreturn
goto|;
comment|/*-----------------------------------. | yyabortlab -- YYABORT comes here.  | `-----------------------------------*/
name|yyabortlab
label|:
name|yyresult
operator|=
literal|1
expr_stmt|;
goto|goto
name|yyreturn
goto|;
comment|/*---------------------------------------------. | yyoverflowab -- parser overflow comes here.  | `---------------------------------------------*/
name|yyoverflowlab
label|:
name|yyerror
argument_list|(
literal|"parser stack overflow"
argument_list|)
expr_stmt|;
name|yyresult
operator|=
literal|2
expr_stmt|;
comment|/* Fall through.  */
name|yyreturn
label|:
ifndef|#
directive|ifndef
name|yyoverflow
if|if
condition|(
name|yyss
operator|!=
name|yyssa
condition|)
name|YYSTACK_FREE
argument_list|(
name|yyss
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|yyresult
return|;
block|}
end_function

begin_line
line|#
directive|line
number|492
file|"nlmheader.y"
end_line

begin_comment
comment|/* If strerror is just a macro, we want to use the one from libiberty    since it will handle undefined values.  */
end_comment

begin_undef
undef|#
directive|undef
name|strerror
end_undef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strerror
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The lexer is simple, too simple for flex.  Keywords are only    recognized at the start of lines.  Everything else must be an    argument.  A comma is treated as whitespace.  */
end_comment

begin_comment
comment|/* The states the lexer can be in.  */
end_comment

begin_enum
enum|enum
name|lex_state
block|{
comment|/* At the beginning of a line.  */
name|BEGINNING_OF_LINE
block|,
comment|/* In the middle of a line.  */
name|IN_LINE
block|}
enum|;
end_enum

begin_comment
comment|/* We need to keep a stack of files to handle file inclusion.  */
end_comment

begin_struct
struct|struct
name|input
block|{
comment|/* The file to read from.  */
name|FILE
modifier|*
name|file
decl_stmt|;
comment|/* The name of the file.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The current line number.  */
name|int
name|lineno
decl_stmt|;
comment|/* The current state.  */
name|enum
name|lex_state
name|state
decl_stmt|;
comment|/* The next file on the stack.  */
name|struct
name|input
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The current input file.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|input
name|current
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The character which introduces comments.  */
end_comment

begin_define
define|#
directive|define
name|COMMENT_CHAR
value|'#'
end_define

begin_escape
end_escape

begin_comment
comment|/* Start the lexer going on the main input file.  */
end_comment

begin_function
name|bfd_boolean
name|nlmlex_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|current
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|nlmlex_file_open
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Start the lexer going on a subsidiary input file.  */
end_comment

begin_function
specifier|static
name|void
name|nlmlex_file_push
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|input
modifier|*
name|push
decl_stmt|;
name|push
operator|=
operator|(
expr|struct
name|input
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|input
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|push
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|nlmlex_file_open
argument_list|(
name|name
argument_list|)
condition|)
name|current
operator|.
name|next
operator|=
name|push
expr_stmt|;
else|else
block|{
name|current
operator|=
operator|*
name|push
expr_stmt|;
name|free
argument_list|(
name|push
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Start lexing from a file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|nlmlex_file_open
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|current
operator|.
name|file
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|file
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|parse_errors
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|current
operator|.
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|current
operator|.
name|lineno
operator|=
literal|1
expr_stmt|;
name|current
operator|.
name|state
operator|=
name|BEGINNING_OF_LINE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table used to turn keywords into tokens.  */
end_comment

begin_struct
struct|struct
name|keyword_tokens_struct
block|{
specifier|const
name|char
modifier|*
name|keyword
decl_stmt|;
name|int
name|token
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|keyword_tokens_struct
name|keyword_tokens
index|[]
init|=
block|{
block|{
literal|"CHECK"
block|,
name|CHECK
block|}
block|,
block|{
literal|"CODESTART"
block|,
name|CODESTART
block|}
block|,
block|{
literal|"COPYRIGHT"
block|,
name|COPYRIGHT
block|}
block|,
block|{
literal|"CUSTOM"
block|,
name|CUSTOM
block|}
block|,
block|{
literal|"DATE"
block|,
name|DATE
block|}
block|,
block|{
literal|"DEBUG"
block|,
name|DEBUG
block|}
block|,
block|{
literal|"DESCRIPTION"
block|,
name|DESCRIPTION
block|}
block|,
block|{
literal|"EXIT"
block|,
name|EXIT
block|}
block|,
block|{
literal|"EXPORT"
block|,
name|EXPORT
block|}
block|,
block|{
literal|"FLAG_ON"
block|,
name|FLAG_ON
block|}
block|,
block|{
literal|"FLAG_OFF"
block|,
name|FLAG_OFF
block|}
block|,
block|{
literal|"FULLMAP"
block|,
name|FULLMAP
block|}
block|,
block|{
literal|"HELP"
block|,
name|HELP
block|}
block|,
block|{
literal|"IMPORT"
block|,
name|IMPORT
block|}
block|,
block|{
literal|"INPUT"
block|,
name|INPUT
block|}
block|,
block|{
literal|"MAP"
block|,
name|MAP
block|}
block|,
block|{
literal|"MESSAGES"
block|,
name|MESSAGES
block|}
block|,
block|{
literal|"MODULE"
block|,
name|MODULE
block|}
block|,
block|{
literal|"MULTIPLE"
block|,
name|MULTIPLE
block|}
block|,
block|{
literal|"OS_DOMAIN"
block|,
name|OS_DOMAIN
block|}
block|,
block|{
literal|"OUTPUT"
block|,
name|OUTPUT
block|}
block|,
block|{
literal|"PSEUDOPREEMPTION"
block|,
name|PSEUDOPREEMPTION
block|}
block|,
block|{
literal|"REENTRANT"
block|,
name|REENTRANT
block|}
block|,
block|{
literal|"SCREENNAME"
block|,
name|SCREENNAME
block|}
block|,
block|{
literal|"SHARELIB"
block|,
name|SHARELIB
block|}
block|,
block|{
literal|"STACK"
block|,
name|STACK
block|}
block|,
block|{
literal|"STACKSIZE"
block|,
name|STACK
block|}
block|,
block|{
literal|"START"
block|,
name|START
block|}
block|,
block|{
literal|"SYNCHRONIZE"
block|,
name|SYNCHRONIZE
block|}
block|,
block|{
literal|"THREADNAME"
block|,
name|THREADNAME
block|}
block|,
block|{
literal|"TYPE"
block|,
name|TYPE
block|}
block|,
block|{
literal|"VERBOSE"
block|,
name|VERBOSE
block|}
block|,
block|{
literal|"VERSION"
block|,
name|VERSIONK
block|}
block|,
block|{
literal|"XDCDATA"
block|,
name|XDCDATA
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KEYWORD_COUNT
value|(sizeof (keyword_tokens) / sizeof (keyword_tokens[0]))
end_define

begin_escape
end_escape

begin_comment
comment|/* The lexer accumulates strings in these variables.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lex_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lex_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lex_pos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start accumulating strings into the buffer.  */
end_comment

begin_define
define|#
directive|define
name|BUF_INIT
parameter_list|()
define|\
value|((void) (lex_buf != NULL ? lex_pos = 0 : nlmlex_buf_init ()))
end_define

begin_function
specifier|static
name|int
name|nlmlex_buf_init
parameter_list|(
name|void
parameter_list|)
block|{
name|lex_size
operator|=
literal|10
expr_stmt|;
name|lex_buf
operator|=
name|xmalloc
argument_list|(
name|lex_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lex_pos
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Finish a string in the buffer.  */
end_comment

begin_define
define|#
directive|define
name|BUF_FINISH
parameter_list|()
value|((void) (lex_buf[lex_pos] = '\0'))
end_define

begin_comment
comment|/* Accumulate a character into the buffer.  */
end_comment

begin_define
define|#
directive|define
name|BUF_ADD
parameter_list|(
name|c
parameter_list|)
define|\
value|((void) (lex_pos< lex_size \ 	   ? lex_buf[lex_pos++] = (c) \ 	   : nlmlex_buf_add (c)))
end_define

begin_function
specifier|static
name|char
name|nlmlex_buf_add
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|lex_pos
operator|>=
name|lex_size
condition|)
block|{
name|lex_size
operator|*=
literal|2
expr_stmt|;
name|lex_buf
operator|=
name|xrealloc
argument_list|(
name|lex_buf
argument_list|,
name|lex_size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|lex_buf
index|[
name|lex_pos
operator|++
index|]
operator|=
name|c
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The lexer proper.  This is called by the bison generated parsing    code.  */
end_comment

begin_function
specifier|static
name|int
name|yylex
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|tail_recurse
label|:
name|c
operator|=
name|getc
argument_list|(
name|current
operator|.
name|file
argument_list|)
expr_stmt|;
comment|/* Commas are treated as whitespace characters.  */
while|while
condition|(
name|ISSPACE
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|','
condition|)
block|{
name|current
operator|.
name|state
operator|=
name|IN_LINE
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|current
operator|.
name|lineno
expr_stmt|;
name|current
operator|.
name|state
operator|=
name|BEGINNING_OF_LINE
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|current
operator|.
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* At the end of the file we either pop to the previous file or      finish up.  */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|fclose
argument_list|(
name|current
operator|.
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|current
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|next
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
else|else
block|{
name|struct
name|input
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|current
operator|.
name|next
expr_stmt|;
name|current
operator|=
operator|*
name|next
expr_stmt|;
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
goto|goto
name|tail_recurse
goto|;
block|}
block|}
comment|/* A comment character always means to drop everything until the      next newline.  */
if|if
condition|(
name|c
operator|==
name|COMMENT_CHAR
condition|)
block|{
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|current
operator|.
name|file
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
operator|++
name|current
operator|.
name|lineno
expr_stmt|;
name|current
operator|.
name|state
operator|=
name|BEGINNING_OF_LINE
expr_stmt|;
goto|goto
name|tail_recurse
goto|;
block|}
comment|/* An '@' introduces an include file.  */
if|if
condition|(
name|c
operator|==
literal|'@'
condition|)
block|{
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|current
operator|.
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|++
name|current
operator|.
name|lineno
expr_stmt|;
block|}
do|while
condition|(
name|ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|BUF_INIT
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|ISSPACE
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
name|BUF_ADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|current
operator|.
name|file
argument_list|)
expr_stmt|;
block|}
name|BUF_FINISH
argument_list|()
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|current
operator|.
name|file
argument_list|)
expr_stmt|;
name|nlmlex_file_push
argument_list|(
name|lex_buf
argument_list|)
expr_stmt|;
goto|goto
name|tail_recurse
goto|;
block|}
comment|/* A non-space character at the start of a line must be the start of      a keyword.  */
if|if
condition|(
name|current
operator|.
name|state
operator|==
name|BEGINNING_OF_LINE
condition|)
block|{
name|BUF_INIT
argument_list|()
expr_stmt|;
while|while
condition|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
condition|)
block|{
name|BUF_ADD
argument_list|(
name|TOUPPER
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|current
operator|.
name|file
argument_list|)
expr_stmt|;
block|}
name|BUF_FINISH
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
operator|!
name|ISSPACE
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|','
condition|)
block|{
name|nlmheader_identify
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s:%d: illegal character in keyword: %c\n"
argument_list|)
argument_list|,
name|current
operator|.
name|name
argument_list|,
name|current
operator|.
name|lineno
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KEYWORD_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lex_buf
index|[
literal|0
index|]
operator|==
name|keyword_tokens
index|[
name|i
index|]
operator|.
name|keyword
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|lex_buf
argument_list|,
name|keyword_tokens
index|[
name|i
index|]
operator|.
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Pushing back the final whitespace avoids worrying 		     about \n here.  */
name|ungetc
argument_list|(
name|c
argument_list|,
name|current
operator|.
name|file
argument_list|)
expr_stmt|;
name|current
operator|.
name|state
operator|=
name|IN_LINE
expr_stmt|;
return|return
name|keyword_tokens
index|[
name|i
index|]
operator|.
name|token
return|;
block|}
block|}
name|nlmheader_identify
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s:%d: unrecognized keyword: %s\n"
argument_list|)
argument_list|,
name|current
operator|.
name|name
argument_list|,
name|current
operator|.
name|lineno
argument_list|,
name|lex_buf
argument_list|)
expr_stmt|;
block|}
operator|++
name|parse_errors
expr_stmt|;
comment|/* Treat the rest of this line as a comment.  */
name|ungetc
argument_list|(
name|COMMENT_CHAR
argument_list|,
name|current
operator|.
name|file
argument_list|)
expr_stmt|;
goto|goto
name|tail_recurse
goto|;
block|}
comment|/* Parentheses just represent themselves.  */
if|if
condition|(
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|')'
condition|)
return|return
name|c
return|;
comment|/* Handle quoted strings.  */
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'\''
condition|)
block|{
name|int
name|quote
decl_stmt|;
name|int
name|start_lineno
decl_stmt|;
name|quote
operator|=
name|c
expr_stmt|;
name|start_lineno
operator|=
name|current
operator|.
name|lineno
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|current
operator|.
name|file
argument_list|)
expr_stmt|;
name|BUF_INIT
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|quote
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
name|BUF_ADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|++
name|current
operator|.
name|lineno
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|current
operator|.
name|file
argument_list|)
expr_stmt|;
block|}
name|BUF_FINISH
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|nlmheader_identify
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s:%d: end of file in quoted string\n"
argument_list|)
argument_list|,
name|current
operator|.
name|name
argument_list|,
name|start_lineno
argument_list|)
expr_stmt|;
operator|++
name|parse_errors
expr_stmt|;
block|}
comment|/* FIXME: Possible memory leak.  */
name|yylval
operator|.
name|string
operator|=
name|xstrdup
argument_list|(
name|lex_buf
argument_list|)
expr_stmt|;
return|return
name|QUOTED_STRING
return|;
block|}
comment|/* Gather a generic argument.  */
name|BUF_INIT
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|ISSPACE
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
name|COMMENT_CHAR
operator|&&
name|c
operator|!=
literal|'('
operator|&&
name|c
operator|!=
literal|')'
condition|)
block|{
name|BUF_ADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|current
operator|.
name|file
argument_list|)
expr_stmt|;
block|}
name|BUF_FINISH
argument_list|()
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|current
operator|.
name|file
argument_list|)
expr_stmt|;
comment|/* FIXME: Possible memory leak.  */
name|yylval
operator|.
name|string
operator|=
name|xstrdup
argument_list|(
name|lex_buf
argument_list|)
expr_stmt|;
return|return
name|STRING
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get a number from a string.  */
end_comment

begin_function
specifier|static
name|long
name|nlmlex_get_number
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|long
name|ret
decl_stmt|;
name|char
modifier|*
name|send
decl_stmt|;
name|ret
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|send
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|send
operator|!=
literal|'\0'
condition|)
name|nlmheader_warn
argument_list|(
name|_
argument_list|(
literal|"bad number"
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Prefix the nlmconv warnings with a note as to where they come from.    We don't use program_name on every warning, because then some    versions of the emacs next-error function can't recognize the line    number.  */
end_comment

begin_function
specifier|static
name|void
name|nlmheader_identify
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|done
decl_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: problems in NLM command language input:\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Issue a warning.  */
end_comment

begin_function
specifier|static
name|void
name|nlmheader_warn
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|imax
parameter_list|)
block|{
name|nlmheader_identify
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: %s"
argument_list|,
name|current
operator|.
name|name
argument_list|,
name|current
operator|.
name|lineno
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|imax
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (max %d)"
argument_list|,
name|imax
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an error.  */
end_comment

begin_function
specifier|static
name|void
name|nlmheader_error
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|nlmheader_warn
argument_list|(
name|s
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|++
name|parse_errors
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a string to a string list.  */
end_comment

begin_function
specifier|static
name|struct
name|string_list
modifier|*
name|string_list_cons
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|struct
name|string_list
modifier|*
name|l
parameter_list|)
block|{
name|struct
name|string_list
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|l
expr_stmt|;
name|ret
operator|->
name|string
operator|=
name|s
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Append a string list to another string list.  */
end_comment

begin_function
specifier|static
name|struct
name|string_list
modifier|*
name|string_list_append
parameter_list|(
name|struct
name|string_list
modifier|*
name|l1
parameter_list|,
name|struct
name|string_list
modifier|*
name|l2
parameter_list|)
block|{
specifier|register
name|struct
name|string_list
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|l1
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|l2
expr_stmt|;
return|return
name|l1
return|;
block|}
end_function

begin_comment
comment|/* Append a string to a string list.  */
end_comment

begin_function
specifier|static
name|struct
name|string_list
modifier|*
name|string_list_append1
parameter_list|(
name|struct
name|string_list
modifier|*
name|l
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|string_list
modifier|*
name|n
decl_stmt|;
specifier|register
name|struct
name|string_list
modifier|*
modifier|*
name|pp
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|string
operator|=
name|s
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|l
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|n
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* Duplicate a string in memory.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|xstrdup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|long
name|len
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ret
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

