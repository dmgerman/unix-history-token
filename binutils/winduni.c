begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* winduni.c -- unicode support for the windres program.    Copyright 1997, 1998, 2000, 2001, 2003 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains unicode support routines for the windres    program.  Ideally, we would have generic unicode support which    would work on all systems.  However, we don't.  Instead, on a    Windows host, we are prepared to call some Windows routines.  This    means that we will generate different output on Windows and Unix    hosts, but that seems better than not really supporting unicode at    all.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"winduni.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Convert an ASCII string to a unicode string.  We just copy it,    expanding chars to shorts, rather than doing something intelligent.  */
end_comment

begin_function
name|void
name|unicode_from_ascii
parameter_list|(
name|int
modifier|*
name|length
parameter_list|,
name|unichar
modifier|*
modifier|*
name|unicode
parameter_list|,
specifier|const
name|char
modifier|*
name|ascii
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|short
modifier|*
name|w
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ascii
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
operator|*
name|length
operator|=
name|len
expr_stmt|;
operator|*
name|unicode
operator|=
operator|(
operator|(
name|unichar
operator|*
operator|)
name|res_alloc
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
comment|/* FIXME: On Windows, we should be using MultiByteToWideChar to set      the length.  */
name|MultiByteToWideChar
argument_list|(
name|CP_ACP
argument_list|,
literal|0
argument_list|,
name|ascii
argument_list|,
name|len
operator|+
literal|1
argument_list|,
operator|*
name|unicode
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|s
operator|=
name|ascii
operator|,
name|w
operator|=
operator|*
name|unicode
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
operator|,
name|w
operator|++
control|)
operator|*
name|w
operator|=
operator|*
name|s
operator|&
literal|0xff
expr_stmt|;
operator|*
name|w
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Print the unicode string UNICODE to the file E.  LENGTH is the    number of characters to print, or -1 if we should print until the    end of the string.  FIXME: On a Windows host, we should be calling    some Windows function, probably WideCharToMultiByte.  */
end_comment

begin_function
name|void
name|unicode_print
parameter_list|(
name|FILE
modifier|*
name|e
parameter_list|,
specifier|const
name|unichar
modifier|*
name|unicode
parameter_list|,
name|int
name|length
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|unichar
name|ch
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
operator|--
name|length
expr_stmt|;
name|ch
operator|=
operator|*
name|unicode
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
operator|&&
name|length
operator|<
literal|0
condition|)
return|return;
operator|++
name|unicode
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0x7f
operator|)
operator|==
name|ch
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
name|fputs
argument_list|(
literal|"\\"
argument_list|,
name|e
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISPRINT
argument_list|(
name|ch
argument_list|)
condition|)
name|putc
argument_list|(
name|ch
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|ESCAPE_A
case|:
name|fputs
argument_list|(
literal|"\\a"
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESCAPE_B
case|:
name|fputs
argument_list|(
literal|"\\b"
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESCAPE_F
case|:
name|fputs
argument_list|(
literal|"\\f"
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESCAPE_N
case|:
name|fputs
argument_list|(
literal|"\\n"
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESCAPE_R
case|:
name|fputs
argument_list|(
literal|"\\r"
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESCAPE_T
case|:
name|fputs
argument_list|(
literal|"\\t"
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESCAPE_V
case|:
name|fputs
argument_list|(
literal|"\\v"
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xff
operator|)
operator|==
name|ch
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ch
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\\x%x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

