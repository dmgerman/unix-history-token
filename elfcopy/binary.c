begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010,2011 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<gelf.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"elfcopy.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: binary.c 2358 2011-12-19 18:22:32Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Convert ELF object to `binary'. Sections with SHF_ALLOC flag set  * are copied to the result binary. The relative offsets for each section  * are retained, so the result binary file might contain "holes".  */
end_comment

begin_function
name|void
name|create_binary
parameter_list|(
name|int
name|ifd
parameter_list|,
name|int
name|ofd
parameter_list|)
block|{
name|Elf
modifier|*
name|e
decl_stmt|;
name|Elf_Scn
modifier|*
name|scn
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|GElf_Shdr
name|sh
decl_stmt|;
name|off_t
name|base
decl_stmt|,
name|off
decl_stmt|;
name|int
name|elferr
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|elf_begin
argument_list|(
name|ifd
argument_list|,
name|ELF_C_READ
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_begin() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|ofd
argument_list|,
name|base
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"lseek failed"
argument_list|)
expr_stmt|;
comment|/* 	 * Find base offset in the first iteration. 	 */
name|base
operator|=
operator|-
literal|1
expr_stmt|;
name|scn
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|scn
operator|=
name|elf_nextscn
argument_list|(
name|e
argument_list|,
name|scn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|sh
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getshdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|sh
operator|.
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|==
literal|0
operator|||
name|sh
operator|.
name|sh_type
operator|==
name|SHT_NOBITS
operator|||
name|sh
operator|.
name|sh_size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|base
operator|==
operator|-
literal|1
operator|||
operator|(
name|off_t
operator|)
name|sh
operator|.
name|sh_offset
operator|<
name|base
condition|)
name|base
operator|=
name|sh
operator|.
name|sh_offset
expr_stmt|;
block|}
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_nextscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* 	 * Write out sections in the second iteration. 	 */
name|scn
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|scn
operator|=
name|elf_nextscn
argument_list|(
name|e
argument_list|,
name|scn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|sh
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getshdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|sh
operator|.
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|==
literal|0
operator|||
name|sh
operator|.
name|sh_type
operator|==
name|SHT_NOBITS
operator|||
name|sh
operator|.
name|sh_size
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|d
operator|->
name|d_buf
operator|==
name|NULL
operator|||
name|d
operator|->
name|d_size
operator|==
literal|0
condition|)
continue|continue;
comment|/* lseek to section offset relative to `base'. */
name|off
operator|=
name|sh
operator|.
name|sh_offset
operator|-
name|base
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|ofd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"lseek failed"
argument_list|)
expr_stmt|;
comment|/* Write out section contents. */
if|if
condition|(
name|write
argument_list|(
name|ofd
argument_list|,
name|d
operator|->
name|d_buf
argument_list|,
name|d
operator|->
name|d_size
argument_list|)
operator|!=
operator|(
name|ssize_t
operator|)
name|d
operator|->
name|d_size
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"write failed"
argument_list|)
expr_stmt|;
block|}
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_nextscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|_SYMBOL_NAMSZ
value|1024
end_define

begin_comment
comment|/*  * Convert `binary' to ELF object. The input `binary' is converted to  * a relocatable (.o) file, a few symbols will also be created to make  * it easier to access the binary data in other compilation units.  */
end_comment

begin_function
name|void
name|create_elf_from_binary
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|int
name|ifd
parameter_list|,
specifier|const
name|char
modifier|*
name|ifn
parameter_list|)
block|{
name|char
name|name
index|[
name|_SYMBOL_NAMSZ
index|]
decl_stmt|;
name|struct
name|section
modifier|*
name|sec
decl_stmt|,
modifier|*
name|sec_temp
decl_stmt|,
modifier|*
name|shtab
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|GElf_Ehdr
name|oeh
decl_stmt|;
name|GElf_Shdr
name|sh
decl_stmt|;
name|void
modifier|*
name|content
decl_stmt|;
name|uint64_t
name|off
decl_stmt|,
name|data_start
decl_stmt|,
name|data_end
decl_stmt|,
name|data_size
decl_stmt|;
comment|/* Reset internal section list. */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ecp
operator|->
name|v_sec
argument_list|)
condition|)
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sec
argument_list|,
argument|&ecp->v_sec
argument_list|,
argument|sec_list
argument_list|,
argument|sec_temp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ecp
operator|->
name|v_sec
argument_list|,
name|sec
argument_list|,
name|sec_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|ifd
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"fstat failed"
argument_list|)
expr_stmt|;
comment|/* Read the input binary file to a internal buffer. */
if|if
condition|(
operator|(
name|content
operator|=
name|malloc
argument_list|(
name|sb
operator|.
name|st_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|ifd
argument_list|,
name|content
argument_list|,
name|sb
operator|.
name|st_size
argument_list|)
operator|!=
name|sb
operator|.
name|st_size
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"read failed"
argument_list|)
expr_stmt|;
comment|/* 	 * TODO: copy the input binary to output binary verbatim if -O is not 	 * specified. 	 */
comment|/* Create EHDR for output .o file. */
if|if
condition|(
name|gelf_newehdr
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
name|ecp
operator|->
name|oec
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_newehdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gelf_getehdr
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
operator|&
name|oeh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getehdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialise e_ident fields. */
name|oeh
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|ecp
operator|->
name|oec
expr_stmt|;
name|oeh
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|ecp
operator|->
name|oed
expr_stmt|;
comment|/* 	 * TODO: Set OSABI according to the OS platform where elfcopy(1) 	 * was build. (probably) 	 */
name|oeh
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_NONE
expr_stmt|;
name|oeh
operator|.
name|e_machine
operator|=
name|ecp
operator|->
name|oem
expr_stmt|;
name|oeh
operator|.
name|e_type
operator|=
name|ET_REL
expr_stmt|;
name|oeh
operator|.
name|e_entry
operator|=
literal|0
expr_stmt|;
name|ecp
operator|->
name|flags
operator||=
name|RELOCATABLE
expr_stmt|;
comment|/* Create .shstrtab section */
name|init_shstrtab
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|shstrtab
operator|->
name|off
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Create `.data' section which contains the binary data. The 	 * section is inserted immediately after EHDR. 	 */
name|off
operator|=
name|gelf_fsize
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
name|ELF_T_EHDR
argument_list|,
literal|1
argument_list|,
name|EV_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_fsize() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|create_external_section
argument_list|(
name|ecp
argument_list|,
literal|".data"
argument_list|,
name|NULL
argument_list|,
name|content
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
name|off
argument_list|,
name|SHT_PROGBITS
argument_list|,
name|ELF_T_BYTE
argument_list|,
name|SHF_ALLOC
operator||
name|SHF_WRITE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Insert .shstrtab after .data section. */
if|if
condition|(
operator|(
name|ecp
operator|->
name|shstrtab
operator|->
name|os
operator|=
name|elf_newscn
argument_list|(
name|ecp
operator|->
name|eout
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_newscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|insert_to_sec_list
argument_list|(
name|ecp
argument_list|,
name|ecp
operator|->
name|shstrtab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Insert section header table here. */
name|shtab
operator|=
name|insert_shtab
argument_list|(
name|ecp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Count in .symtab and .strtab section headers.  */
name|shtab
operator|->
name|sz
operator|+=
name|gelf_fsize
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
name|ELF_T_SHDR
argument_list|,
literal|2
argument_list|,
name|EV_CURRENT
argument_list|)
expr_stmt|;
define|#
directive|define
name|_GEN_SYMNAME
parameter_list|(
name|S
parameter_list|)
value|do {						\ 	snprintf(name, sizeof(name), "%s%s%s", "_binary_", ifn, S);	\ } while (0)
comment|/* 	 * Create symbol table. 	 */
name|create_external_symtab
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|=
name|data_start
operator|+
name|sb
operator|.
name|st_size
expr_stmt|;
name|data_size
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
name|_GEN_SYMNAME
argument_list|(
literal|"_start"
argument_list|)
expr_stmt|;
name|add_to_symtab
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
name|data_start
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|ELF32_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_NOTYPE
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|_GEN_SYMNAME
argument_list|(
literal|"_end"
argument_list|)
expr_stmt|;
name|add_to_symtab
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
name|data_end
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|ELF32_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_NOTYPE
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|_GEN_SYMNAME
argument_list|(
literal|"_size"
argument_list|)
expr_stmt|;
name|add_to_symtab
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
name|data_size
argument_list|,
literal|0
argument_list|,
name|SHN_ABS
argument_list|,
name|ELF32_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_NOTYPE
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|finalize_external_symtab
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
name|create_symtab_data
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|_GEN_SYMNAME
comment|/* 	 * Write the underlying ehdr. Note that it should be called 	 * before elf_setshstrndx() since it will overwrite e->e_shstrndx. 	 */
if|if
condition|(
name|gelf_update_ehdr
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
operator|&
name|oeh
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_update_ehdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate section name string table (.shstrtab). */
name|ecp
operator|->
name|flags
operator||=
name|SYMTAB_EXIST
expr_stmt|;
name|set_shstrtab
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
comment|/* Update sh_name pointer for each section header entry. */
name|update_shdr
argument_list|(
name|ecp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Properly set sh_link field of .symtab section. */
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|ecp
operator|->
name|symtab
operator|->
name|os
argument_list|,
operator|&
name|sh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"692 gelf_getshdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sh
operator|.
name|sh_link
operator|=
name|elf_ndxscn
argument_list|(
name|ecp
operator|->
name|strtab
operator|->
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gelf_update_shdr
argument_list|(
name|ecp
operator|->
name|symtab
operator|->
name|os
argument_list|,
operator|&
name|sh
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_update_shdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Renew oeh to get the updated e_shstrndx. */
if|if
condition|(
name|gelf_getehdr
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
operator|&
name|oeh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getehdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Resync section offsets. */
name|resync_sections
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
comment|/* Store SHDR offset in EHDR. */
name|oeh
operator|.
name|e_shoff
operator|=
name|shtab
operator|->
name|off
expr_stmt|;
comment|/* Update ehdr since we modified e_shoff. */
if|if
condition|(
name|gelf_update_ehdr
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
operator|&
name|oeh
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_update_ehdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write out the output elf object. */
if|if
condition|(
name|elf_update
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
name|ELF_C_WRITE
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_update() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Release allocated resource. */
name|free
argument_list|(
name|content
argument_list|)
expr_stmt|;
name|free_elf
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

