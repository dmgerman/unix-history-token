begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2003 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/zmod.h>
end_include

begin_include
include|#
directive|include
file|<ctf_impl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<gelf.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|_LP64
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|_libctf_zlib
init|=
literal|"/usr/lib/64/libz.so"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|_libctf_zlib
init|=
literal|"/usr/lib/libz.so"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
block|{
name|int
function_decl|(
modifier|*
name|z_uncompress
function_decl|)
parameter_list|(
name|uchar_t
modifier|*
parameter_list|,
name|ulong_t
modifier|*
parameter_list|,
specifier|const
name|uchar_t
modifier|*
parameter_list|,
name|ulong_t
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|z_error
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|void
modifier|*
name|z_dlp
decl_stmt|;
block|}
name|zlib
struct|;
end_struct

begin_decl_stmt
specifier|static
name|size_t
name|_PAGESIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|_PAGEMASK
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|init
name|(
name|_libctf_init
name|)
end_pragma

begin_else
else|#
directive|else
end_else

begin_function_decl
name|void
name|_libctf_init
parameter_list|(
name|void
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(constructor
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|_libctf_init
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
specifier|const
name|char
modifier|*
name|p
init|=
name|getenv
argument_list|(
literal|"LIBCTF_DECOMPRESSOR"
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|_libctf_zlib
operator|=
name|p
expr_stmt|;
comment|/* use alternate decompression library */
endif|#
directive|endif
name|_libctf_debug
operator|=
name|getenv
argument_list|(
literal|"LIBCTF_DEBUG"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|_PAGESIZE
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
name|_PAGEMASK
operator|=
operator|~
operator|(
name|_PAGESIZE
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt to dlopen the decompression library and locate the symbols of  * interest that we will need to call.  This information in cached so  * that multiple calls to ctf_bufopen() do not need to reopen the library.  */
end_comment

begin_function
name|void
modifier|*
name|ctf_zopen
parameter_list|(
name|int
modifier|*
name|errp
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|ctf_dprintf
argument_list|(
literal|"decompressing CTF data using %s\n"
argument_list|,
name|_libctf_zlib
argument_list|)
expr_stmt|;
if|if
condition|(
name|zlib
operator|.
name|z_dlp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|zlib
operator|.
name|z_dlp
operator|)
return|;
comment|/* library is already loaded */
if|if
condition|(
name|access
argument_list|(
name|_libctf_zlib
argument_list|,
name|R_OK
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_ZMISSING
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|zlib
operator|.
name|z_dlp
operator|=
name|dlopen
argument_list|(
name|_libctf_zlib
argument_list|,
name|RTLD_LAZY
operator||
name|RTLD_LOCAL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_ZINIT
argument_list|)
operator|)
return|;
name|zlib
operator|.
name|z_uncompress
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|uchar_t
operator|*
argument_list|,
name|ulong_t
operator|*
argument_list|,
specifier|const
name|uchar_t
operator|*
argument_list|,
name|ulong_t
argument_list|)
operator|)
name|dlsym
argument_list|(
name|zlib
operator|.
name|z_dlp
argument_list|,
literal|"uncompress"
argument_list|)
expr_stmt|;
name|zlib
operator|.
name|z_error
operator|=
operator|(
specifier|const
name|char
operator|*
call|(
modifier|*
call|)
argument_list|(
name|int
argument_list|)
operator|)
name|dlsym
argument_list|(
name|zlib
operator|.
name|z_dlp
argument_list|,
literal|"zError"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zlib
operator|.
name|z_uncompress
operator|==
name|NULL
operator|||
name|zlib
operator|.
name|z_error
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|dlclose
argument_list|(
name|zlib
operator|.
name|z_dlp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|zlib
argument_list|,
sizeof|sizeof
argument_list|(
name|zlib
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_ZINIT
argument_list|)
operator|)
return|;
block|}
else|#
directive|else
name|zlib
operator|.
name|z_uncompress
operator|=
name|uncompress
expr_stmt|;
name|zlib
operator|.
name|z_error
operator|=
name|zError
expr_stmt|;
comment|/* Dummy return variable as 'no error' */
name|zlib
operator|.
name|z_dlp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|zlib
operator|.
name|z_dlp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The ctf_bufopen() routine calls these subroutines, defined by<sys/zmod.h>,  * which we then patch through to the functions in the decompression library.  */
end_comment

begin_function
name|int
name|z_uncompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|dstlen
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srclen
parameter_list|)
block|{
return|return
operator|(
name|zlib
operator|.
name|z_uncompress
argument_list|(
name|dst
argument_list|,
operator|(
name|ulong_t
operator|*
operator|)
name|dstlen
argument_list|,
name|src
argument_list|,
name|srclen
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|z_strerror
parameter_list|(
name|int
name|err
parameter_list|)
block|{
return|return
operator|(
name|zlib
operator|.
name|z_error
argument_list|(
name|err
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a 32-bit ELF file header into GElf.  */
end_comment

begin_function
specifier|static
name|void
name|ehdr_to_gelf
parameter_list|(
specifier|const
name|Elf32_Ehdr
modifier|*
name|src
parameter_list|,
name|GElf_Ehdr
modifier|*
name|dst
parameter_list|)
block|{
name|bcopy
argument_list|(
name|src
operator|->
name|e_ident
argument_list|,
name|dst
operator|->
name|e_ident
argument_list|,
name|EI_NIDENT
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_type
operator|=
name|src
operator|->
name|e_type
expr_stmt|;
name|dst
operator|->
name|e_machine
operator|=
name|src
operator|->
name|e_machine
expr_stmt|;
name|dst
operator|->
name|e_version
operator|=
name|src
operator|->
name|e_version
expr_stmt|;
name|dst
operator|->
name|e_entry
operator|=
operator|(
name|Elf64_Addr
operator|)
name|src
operator|->
name|e_entry
expr_stmt|;
name|dst
operator|->
name|e_phoff
operator|=
operator|(
name|Elf64_Off
operator|)
name|src
operator|->
name|e_phoff
expr_stmt|;
name|dst
operator|->
name|e_shoff
operator|=
operator|(
name|Elf64_Off
operator|)
name|src
operator|->
name|e_shoff
expr_stmt|;
name|dst
operator|->
name|e_flags
operator|=
name|src
operator|->
name|e_flags
expr_stmt|;
name|dst
operator|->
name|e_ehsize
operator|=
name|src
operator|->
name|e_ehsize
expr_stmt|;
name|dst
operator|->
name|e_phentsize
operator|=
name|src
operator|->
name|e_phentsize
expr_stmt|;
name|dst
operator|->
name|e_phnum
operator|=
name|src
operator|->
name|e_phnum
expr_stmt|;
name|dst
operator|->
name|e_shentsize
operator|=
name|src
operator|->
name|e_shentsize
expr_stmt|;
name|dst
operator|->
name|e_shnum
operator|=
name|src
operator|->
name|e_shnum
expr_stmt|;
name|dst
operator|->
name|e_shstrndx
operator|=
name|src
operator|->
name|e_shstrndx
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert a 32-bit ELF section header into GElf.  */
end_comment

begin_function
specifier|static
name|void
name|shdr_to_gelf
parameter_list|(
specifier|const
name|Elf32_Shdr
modifier|*
name|src
parameter_list|,
name|GElf_Shdr
modifier|*
name|dst
parameter_list|)
block|{
name|dst
operator|->
name|sh_name
operator|=
name|src
operator|->
name|sh_name
expr_stmt|;
name|dst
operator|->
name|sh_type
operator|=
name|src
operator|->
name|sh_type
expr_stmt|;
name|dst
operator|->
name|sh_flags
operator|=
name|src
operator|->
name|sh_flags
expr_stmt|;
name|dst
operator|->
name|sh_addr
operator|=
name|src
operator|->
name|sh_addr
expr_stmt|;
name|dst
operator|->
name|sh_offset
operator|=
name|src
operator|->
name|sh_offset
expr_stmt|;
name|dst
operator|->
name|sh_size
operator|=
name|src
operator|->
name|sh_size
expr_stmt|;
name|dst
operator|->
name|sh_link
operator|=
name|src
operator|->
name|sh_link
expr_stmt|;
name|dst
operator|->
name|sh_info
operator|=
name|src
operator|->
name|sh_info
expr_stmt|;
name|dst
operator|->
name|sh_addralign
operator|=
name|src
operator|->
name|sh_addralign
expr_stmt|;
name|dst
operator|->
name|sh_entsize
operator|=
name|src
operator|->
name|sh_entsize
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * In order to mmap a section from the ELF file, we must round down sh_offset  * to the previous page boundary, and mmap the surrounding page.  We store  * the pointer to the start of the actual section data back into sp->cts_data.  */
end_comment

begin_function
specifier|const
name|void
modifier|*
name|ctf_sect_mmap
parameter_list|(
name|ctf_sect_t
modifier|*
name|sp
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|size_t
name|pageoff
init|=
name|sp
operator|->
name|cts_offset
operator|&
operator|~
name|_PAGEMASK
decl_stmt|;
name|caddr_t
name|base
init|=
name|mmap64
argument_list|(
name|NULL
argument_list|,
name|sp
operator|->
name|cts_size
operator|+
name|pageoff
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
name|sp
operator|->
name|cts_offset
operator|&
name|_PAGEMASK
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|!=
name|MAP_FAILED
condition|)
name|sp
operator|->
name|cts_data
operator|=
name|base
operator|+
name|pageoff
expr_stmt|;
return|return
operator|(
name|base
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Since sp->cts_data has the adjusted offset, we have to again round down  * to get the actual mmap address and round up to get the size.  */
end_comment

begin_function
name|void
name|ctf_sect_munmap
parameter_list|(
specifier|const
name|ctf_sect_t
modifier|*
name|sp
parameter_list|)
block|{
name|uintptr_t
name|addr
init|=
operator|(
name|uintptr_t
operator|)
name|sp
operator|->
name|cts_data
decl_stmt|;
name|uintptr_t
name|pageoff
init|=
name|addr
operator|&
operator|~
name|_PAGEMASK
decl_stmt|;
operator|(
name|void
operator|)
name|munmap
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|addr
operator|-
name|pageoff
operator|)
argument_list|,
name|sp
operator|->
name|cts_size
operator|+
name|pageoff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open the specified file descriptor and return a pointer to a CTF container.  * The file can be either an ELF file or raw CTF file.  The caller is  * responsible for closing the file descriptor when it is no longer needed.  */
end_comment

begin_function
name|ctf_file_t
modifier|*
name|ctf_fdopen
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|ctf_sect_t
name|ctfsect
decl_stmt|,
name|symsect
decl_stmt|,
name|strsect
decl_stmt|;
name|ctf_file_t
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|struct
name|stat64
name|st
decl_stmt|;
name|ssize_t
name|nbytes
decl_stmt|;
union|union
block|{
name|ctf_preamble_t
name|ctf
decl_stmt|;
name|Elf32_Ehdr
name|e32
decl_stmt|;
name|GElf_Ehdr
name|e64
decl_stmt|;
block|}
name|hdr
union|;
name|bzero
argument_list|(
operator|&
name|ctfsect
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_sect_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|symsect
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_sect_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|strsect
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_sect_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|hdr
operator|.
name|ctf
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat64
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|nbytes
operator|=
name|pread64
argument_list|(
name|fd
argument_list|,
operator|&
name|hdr
operator|.
name|ctf
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|nbytes
operator|<
literal|0
condition|?
name|errno
else|:
name|ECTF_FMT
argument_list|)
operator|)
return|;
comment|/* 	 * If we have read enough bytes to form a CTF header and the magic 	 * string matches, attempt to interpret the file as raw CTF. 	 */
if|if
condition|(
name|nbytes
operator|>=
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|ctf_preamble_t
argument_list|)
operator|&&
name|hdr
operator|.
name|ctf
operator|.
name|ctp_magic
operator|==
name|CTF_MAGIC
condition|)
block|{
if|if
condition|(
name|hdr
operator|.
name|ctf
operator|.
name|ctp_version
operator|>
name|CTF_VERSION
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_CTFVERS
argument_list|)
operator|)
return|;
name|ctfsect
operator|.
name|cts_data
operator|=
name|mmap64
argument_list|(
name|NULL
argument_list|,
name|st
operator|.
name|st_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctfsect
operator|.
name|cts_data
operator|==
name|MAP_FAILED
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
name|ctfsect
operator|.
name|cts_name
operator|=
name|_CTF_SECTION
expr_stmt|;
name|ctfsect
operator|.
name|cts_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|ctfsect
operator|.
name|cts_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|ctfsect
operator|.
name|cts_size
operator|=
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
name|ctfsect
operator|.
name|cts_entsize
operator|=
literal|1
expr_stmt|;
name|ctfsect
operator|.
name|cts_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|ctf_bufopen
argument_list|(
operator|&
name|ctfsect
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|errp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ctf_sect_munmap
argument_list|(
operator|&
name|ctfsect
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
comment|/* 	 * If we have read enough bytes to form an ELF header and the magic 	 * string matches, attempt to interpret the file as an ELF file.  We 	 * do our own largefile ELF processing, and convert everything to 	 * GElf structures so that clients can operate on any data model. 	 */
if|if
condition|(
name|nbytes
operator|>=
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|Elf32_Ehdr
argument_list|)
operator|&&
name|bcmp
argument_list|(
operator|&
name|hdr
operator|.
name|e32
operator|.
name|e_ident
index|[
name|EI_MAG0
index|]
argument_list|,
name|ELFMAG
argument_list|,
name|SELFMAG
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|_BIG_ENDIAN
name|uchar_t
name|order
init|=
name|ELFDATA2MSB
decl_stmt|;
else|#
directive|else
name|uchar_t
name|order
init|=
name|ELFDATA2LSB
decl_stmt|;
endif|#
directive|endif
name|GElf_Half
name|i
decl_stmt|,
name|n
decl_stmt|;
name|GElf_Shdr
modifier|*
name|sp
decl_stmt|;
name|void
modifier|*
name|strs_map
decl_stmt|;
name|size_t
name|strs_mapsz
decl_stmt|;
name|char
modifier|*
name|strs
decl_stmt|;
if|if
condition|(
name|hdr
operator|.
name|e32
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|!=
name|order
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_ENDIAN
argument_list|)
operator|)
return|;
if|if
condition|(
name|hdr
operator|.
name|e32
operator|.
name|e_version
operator|!=
name|EV_CURRENT
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_ELFVERS
argument_list|)
operator|)
return|;
if|if
condition|(
name|hdr
operator|.
name|e32
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|)
block|{
if|if
condition|(
name|nbytes
operator|<
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|GElf_Ehdr
argument_list|)
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_FMT
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|Elf32_Ehdr
name|e32
init|=
name|hdr
operator|.
name|e32
decl_stmt|;
name|ehdr_to_gelf
argument_list|(
operator|&
name|e32
argument_list|,
operator|&
name|hdr
operator|.
name|e64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdr
operator|.
name|e64
operator|.
name|e_shstrndx
operator|>=
name|hdr
operator|.
name|e64
operator|.
name|e_shnum
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_CORRUPT
argument_list|)
operator|)
return|;
name|n
operator|=
name|hdr
operator|.
name|e64
operator|.
name|e_shnum
expr_stmt|;
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|GElf_Shdr
argument_list|)
operator|*
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
comment|/* 		 * Read in and convert to GElf the array of Shdr structures 		 * from e_shoff so we can locate sections of interest. 		 */
if|if
condition|(
name|hdr
operator|.
name|e32
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS32
condition|)
block|{
name|Elf32_Shdr
modifier|*
name|sp32
decl_stmt|;
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Shdr
argument_list|)
operator|*
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|sp32
operator|=
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|pread64
argument_list|(
name|fd
argument_list|,
name|sp32
argument_list|,
name|nbytes
argument_list|,
name|hdr
operator|.
name|e64
operator|.
name|e_shoff
argument_list|)
operator|!=
name|nbytes
condition|)
block|{
name|free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|shdr_to_gelf
argument_list|(
operator|&
name|sp32
index|[
name|i
index|]
argument_list|,
operator|&
name|sp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp32
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pread64
argument_list|(
name|fd
argument_list|,
name|sp
argument_list|,
name|nbytes
argument_list|,
name|hdr
operator|.
name|e64
operator|.
name|e_shoff
argument_list|)
operator|!=
name|nbytes
condition|)
block|{
name|free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * Now mmap the section header strings section so that we can 		 * perform string comparison on the section names. 		 */
name|strs_mapsz
operator|=
name|sp
index|[
name|hdr
operator|.
name|e64
operator|.
name|e_shstrndx
index|]
operator|.
name|sh_size
operator|+
operator|(
name|sp
index|[
name|hdr
operator|.
name|e64
operator|.
name|e_shstrndx
index|]
operator|.
name|sh_offset
operator|&
operator|~
name|_PAGEMASK
operator|)
expr_stmt|;
name|strs_map
operator|=
name|mmap64
argument_list|(
name|NULL
argument_list|,
name|strs_mapsz
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
name|sp
index|[
name|hdr
operator|.
name|e64
operator|.
name|e_shstrndx
index|]
operator|.
name|sh_offset
operator|&
name|_PAGEMASK
argument_list|)
expr_stmt|;
name|strs
operator|=
operator|(
name|char
operator|*
operator|)
name|strs_map
operator|+
operator|(
name|sp
index|[
name|hdr
operator|.
name|e64
operator|.
name|e_shstrndx
index|]
operator|.
name|sh_offset
operator|&
operator|~
name|_PAGEMASK
operator|)
expr_stmt|;
if|if
condition|(
name|strs_map
operator|==
name|MAP_FAILED
condition|)
block|{
name|free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_MMAP
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * Iterate over the section header array looking for the CTF 		 * section and symbol table.  The strtab is linked to symtab. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|GElf_Shdr
modifier|*
name|shp
init|=
operator|&
name|sp
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|GElf_Shdr
modifier|*
name|lhp
init|=
operator|&
name|sp
index|[
name|shp
operator|->
name|sh_link
index|]
decl_stmt|;
if|if
condition|(
name|shp
operator|->
name|sh_link
operator|>=
name|hdr
operator|.
name|e64
operator|.
name|e_shnum
condition|)
continue|continue;
comment|/* corrupt sh_link field */
if|if
condition|(
name|shp
operator|->
name|sh_name
operator|>=
name|sp
index|[
name|hdr
operator|.
name|e64
operator|.
name|e_shstrndx
index|]
operator|.
name|sh_size
operator|||
name|lhp
operator|->
name|sh_name
operator|>=
name|sp
index|[
name|hdr
operator|.
name|e64
operator|.
name|e_shstrndx
index|]
operator|.
name|sh_size
condition|)
continue|continue;
comment|/* corrupt sh_name field */
if|if
condition|(
name|shp
operator|->
name|sh_type
operator|==
name|SHT_PROGBITS
operator|&&
name|strcmp
argument_list|(
name|strs
operator|+
name|shp
operator|->
name|sh_name
argument_list|,
name|_CTF_SECTION
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctfsect
operator|.
name|cts_name
operator|=
name|strs
operator|+
name|shp
operator|->
name|sh_name
expr_stmt|;
name|ctfsect
operator|.
name|cts_type
operator|=
name|shp
operator|->
name|sh_type
expr_stmt|;
name|ctfsect
operator|.
name|cts_flags
operator|=
name|shp
operator|->
name|sh_flags
expr_stmt|;
name|ctfsect
operator|.
name|cts_size
operator|=
name|shp
operator|->
name|sh_size
expr_stmt|;
name|ctfsect
operator|.
name|cts_entsize
operator|=
name|shp
operator|->
name|sh_entsize
expr_stmt|;
name|ctfsect
operator|.
name|cts_offset
operator|=
operator|(
name|off64_t
operator|)
name|shp
operator|->
name|sh_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shp
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB
condition|)
block|{
name|symsect
operator|.
name|cts_name
operator|=
name|strs
operator|+
name|shp
operator|->
name|sh_name
expr_stmt|;
name|symsect
operator|.
name|cts_type
operator|=
name|shp
operator|->
name|sh_type
expr_stmt|;
name|symsect
operator|.
name|cts_flags
operator|=
name|shp
operator|->
name|sh_flags
expr_stmt|;
name|symsect
operator|.
name|cts_size
operator|=
name|shp
operator|->
name|sh_size
expr_stmt|;
name|symsect
operator|.
name|cts_entsize
operator|=
name|shp
operator|->
name|sh_entsize
expr_stmt|;
name|symsect
operator|.
name|cts_offset
operator|=
operator|(
name|off64_t
operator|)
name|shp
operator|->
name|sh_offset
expr_stmt|;
name|strsect
operator|.
name|cts_name
operator|=
name|strs
operator|+
name|lhp
operator|->
name|sh_name
expr_stmt|;
name|strsect
operator|.
name|cts_type
operator|=
name|lhp
operator|->
name|sh_type
expr_stmt|;
name|strsect
operator|.
name|cts_flags
operator|=
name|lhp
operator|->
name|sh_flags
expr_stmt|;
name|strsect
operator|.
name|cts_size
operator|=
name|lhp
operator|->
name|sh_size
expr_stmt|;
name|strsect
operator|.
name|cts_entsize
operator|=
name|lhp
operator|->
name|sh_entsize
expr_stmt|;
name|strsect
operator|.
name|cts_offset
operator|=
operator|(
name|off64_t
operator|)
name|lhp
operator|->
name|sh_offset
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* free section header array */
if|if
condition|(
name|ctfsect
operator|.
name|cts_type
operator|==
name|SHT_NULL
condition|)
block|{
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|strs_map
argument_list|,
name|strs_mapsz
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_NOCTFDATA
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * Now mmap the CTF data, symtab, and strtab sections and 		 * call ctf_bufopen() to do the rest of the work. 		 */
if|if
condition|(
name|ctf_sect_mmap
argument_list|(
operator|&
name|ctfsect
argument_list|,
name|fd
argument_list|)
operator|==
name|MAP_FAILED
condition|)
block|{
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|strs_map
argument_list|,
name|strs_mapsz
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_MMAP
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|symsect
operator|.
name|cts_type
operator|!=
name|SHT_NULL
operator|&&
name|strsect
operator|.
name|cts_type
operator|!=
name|SHT_NULL
condition|)
block|{
if|if
condition|(
name|ctf_sect_mmap
argument_list|(
operator|&
name|symsect
argument_list|,
name|fd
argument_list|)
operator|==
name|MAP_FAILED
operator|||
name|ctf_sect_mmap
argument_list|(
operator|&
name|strsect
argument_list|,
name|fd
argument_list|)
operator|==
name|MAP_FAILED
condition|)
block|{
operator|(
name|void
operator|)
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_MMAP
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
comment|/* unmap all and abort */
block|}
name|fp
operator|=
name|ctf_bufopen
argument_list|(
operator|&
name|ctfsect
argument_list|,
operator|&
name|symsect
argument_list|,
operator|&
name|strsect
argument_list|,
name|errp
argument_list|)
expr_stmt|;
block|}
else|else
name|fp
operator|=
name|ctf_bufopen
argument_list|(
operator|&
name|ctfsect
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|ctf_sect_munmap
argument_list|(
operator|&
name|ctfsect
argument_list|)
expr_stmt|;
name|ctf_sect_munmap
argument_list|(
operator|&
name|symsect
argument_list|)
expr_stmt|;
name|ctf_sect_munmap
argument_list|(
operator|&
name|strsect
argument_list|)
expr_stmt|;
block|}
else|else
name|fp
operator|->
name|ctf_flags
operator||=
name|LCTF_MMAP
expr_stmt|;
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|strs_map
argument_list|,
name|strs_mapsz
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_FMT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open the specified file and return a pointer to a CTF container.  The file  * can be either an ELF file or raw CTF file.  This is just a convenient  * wrapper around ctf_fdopen() for callers.  */
end_comment

begin_function
name|ctf_file_t
modifier|*
name|ctf_open
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fp
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open64
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errp
operator|!=
name|NULL
condition|)
operator|*
name|errp
operator|=
name|errno
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fp
operator|=
name|ctf_fdopen
argument_list|(
name|fd
argument_list|,
name|errp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write the uncompressed CTF data stream to the specified file descriptor.  * This is useful for saving the results of dynamic CTF containers.  */
end_comment

begin_function
name|int
name|ctf_write
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
specifier|const
name|uchar_t
modifier|*
name|buf
init|=
name|fp
operator|->
name|ctf_base
decl_stmt|;
name|ssize_t
name|resid
init|=
name|fp
operator|->
name|ctf_size
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
while|while
condition|(
name|resid
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|resid
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
name|resid
operator|-=
name|len
expr_stmt|;
name|buf
operator|+=
name|len
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the CTF library client version to the specified version.  If version is  * zero, we just return the default library version number.  */
end_comment

begin_function
name|int
name|ctf_version
parameter_list|(
name|int
name|version
parameter_list|)
block|{
if|if
condition|(
name|version
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|version
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|version
operator|>
name|CTF_VERSION
condition|)
block|{
name|errno
operator|=
name|ENOTSUP
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ctf_dprintf
argument_list|(
literal|"ctf_version: client using version %d\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|_libctf_version
operator|=
name|version
expr_stmt|;
block|}
return|return
operator|(
name|_libctf_version
operator|)
return|;
block|}
end_function

end_unit

