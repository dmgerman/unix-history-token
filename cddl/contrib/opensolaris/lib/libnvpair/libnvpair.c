begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<solaris.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"libnvpair.h"
end_include

begin_comment
comment|/*  * libnvpair - A tools library for manipulating<name, value> pairs.  *  *	This library provides routines packing an unpacking nv pairs  *	for transporting data across process boundaries, transporting  *	between kernel and userland, and possibly saving onto disk files.  */
end_comment

begin_comment
comment|/*  * Print control structure.  */
end_comment

begin_define
define|#
directive|define
name|DEFINEOP
parameter_list|(
name|opname
parameter_list|,
name|vtype
parameter_list|)
define|\
value|struct { \ 		int (*op)(struct nvlist_prtctl *, void *, nvlist_t *, \ 		    const char *, vtype); \ 		void *arg; \ 	} opname
end_define

begin_define
define|#
directive|define
name|DEFINEARROP
parameter_list|(
name|opname
parameter_list|,
name|vtype
parameter_list|)
define|\
value|struct { \ 		int (*op)(struct nvlist_prtctl *, void *, nvlist_t *, \ 		    const char *, vtype, uint_t); \ 		void *arg; \ 	} opname
end_define

begin_struct
struct|struct
name|nvlist_printops
block|{
name|DEFINEOP
argument_list|(
name|print_boolean
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|DEFINEOP
argument_list|(
name|print_boolean_value
argument_list|,
name|boolean_t
argument_list|)
expr_stmt|;
name|DEFINEOP
argument_list|(
name|print_byte
argument_list|,
name|uchar_t
argument_list|)
expr_stmt|;
name|DEFINEOP
argument_list|(
name|print_int8
argument_list|,
name|int8_t
argument_list|)
expr_stmt|;
name|DEFINEOP
argument_list|(
name|print_uint8
argument_list|,
name|uint8_t
argument_list|)
expr_stmt|;
name|DEFINEOP
argument_list|(
name|print_int16
argument_list|,
name|int16_t
argument_list|)
expr_stmt|;
name|DEFINEOP
argument_list|(
name|print_uint16
argument_list|,
name|uint16_t
argument_list|)
expr_stmt|;
name|DEFINEOP
argument_list|(
name|print_int32
argument_list|,
name|int32_t
argument_list|)
expr_stmt|;
name|DEFINEOP
argument_list|(
name|print_uint32
argument_list|,
name|uint32_t
argument_list|)
expr_stmt|;
name|DEFINEOP
argument_list|(
name|print_int64
argument_list|,
name|int64_t
argument_list|)
expr_stmt|;
name|DEFINEOP
argument_list|(
name|print_uint64
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
name|DEFINEOP
argument_list|(
name|print_double
argument_list|,
name|double
argument_list|)
expr_stmt|;
name|DEFINEOP
argument_list|(
name|print_string
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|DEFINEOP
argument_list|(
name|print_hrtime
argument_list|,
name|hrtime_t
argument_list|)
expr_stmt|;
name|DEFINEOP
argument_list|(
name|print_nvlist
argument_list|,
name|nvlist_t
operator|*
argument_list|)
expr_stmt|;
name|DEFINEARROP
argument_list|(
name|print_boolean_array
argument_list|,
name|boolean_t
operator|*
argument_list|)
expr_stmt|;
name|DEFINEARROP
argument_list|(
name|print_byte_array
argument_list|,
name|uchar_t
operator|*
argument_list|)
expr_stmt|;
name|DEFINEARROP
argument_list|(
name|print_int8_array
argument_list|,
name|int8_t
operator|*
argument_list|)
expr_stmt|;
name|DEFINEARROP
argument_list|(
name|print_uint8_array
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|DEFINEARROP
argument_list|(
name|print_int16_array
argument_list|,
name|int16_t
operator|*
argument_list|)
expr_stmt|;
name|DEFINEARROP
argument_list|(
name|print_uint16_array
argument_list|,
name|uint16_t
operator|*
argument_list|)
expr_stmt|;
name|DEFINEARROP
argument_list|(
name|print_int32_array
argument_list|,
name|int32_t
operator|*
argument_list|)
expr_stmt|;
name|DEFINEARROP
argument_list|(
name|print_uint32_array
argument_list|,
name|uint32_t
operator|*
argument_list|)
expr_stmt|;
name|DEFINEARROP
argument_list|(
name|print_int64_array
argument_list|,
name|int64_t
operator|*
argument_list|)
expr_stmt|;
name|DEFINEARROP
argument_list|(
name|print_uint64_array
argument_list|,
name|uint64_t
operator|*
argument_list|)
expr_stmt|;
name|DEFINEARROP
argument_list|(
name|print_string_array
argument_list|,
name|char
operator|*
operator|*
argument_list|)
expr_stmt|;
name|DEFINEARROP
argument_list|(
name|print_nvlist_array
argument_list|,
name|nvlist_t
operator|*
operator|*
argument_list|)
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nvlist_prtctl
block|{
name|FILE
modifier|*
name|nvprt_fp
decl_stmt|;
comment|/* output destination */
name|enum
name|nvlist_indent_mode
name|nvprt_indent_mode
decl_stmt|;
comment|/* see above */
name|int
name|nvprt_indent
decl_stmt|;
comment|/* absolute indent, or tab depth */
name|int
name|nvprt_indentinc
decl_stmt|;
comment|/* indent or tab increment */
specifier|const
name|char
modifier|*
name|nvprt_nmfmt
decl_stmt|;
comment|/* member name format, max one %s */
specifier|const
name|char
modifier|*
name|nvprt_eomfmt
decl_stmt|;
comment|/* after member format, e.g. "\n" */
specifier|const
name|char
modifier|*
name|nvprt_btwnarrfmt
decl_stmt|;
comment|/* between array members */
name|int
name|nvprt_btwnarrfmt_nl
decl_stmt|;
comment|/* nvprt_eoamfmt includes newline? */
name|struct
name|nvlist_printops
modifier|*
name|nvprt_dfltops
decl_stmt|;
name|struct
name|nvlist_printops
modifier|*
name|nvprt_custops
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DFLTPRTOP
parameter_list|(
name|pctl
parameter_list|,
name|type
parameter_list|)
define|\
value|((pctl)->nvprt_dfltops->print_##type.op)
end_define

begin_define
define|#
directive|define
name|DFLTPRTOPARG
parameter_list|(
name|pctl
parameter_list|,
name|type
parameter_list|)
define|\
value|((pctl)->nvprt_dfltops->print_##type.arg)
end_define

begin_define
define|#
directive|define
name|CUSTPRTOP
parameter_list|(
name|pctl
parameter_list|,
name|type
parameter_list|)
define|\
value|((pctl)->nvprt_custops->print_##type.op)
end_define

begin_define
define|#
directive|define
name|CUSTPRTOPARG
parameter_list|(
name|pctl
parameter_list|,
name|type
parameter_list|)
define|\
value|((pctl)->nvprt_custops->print_##type.arg)
end_define

begin_define
define|#
directive|define
name|RENDER
parameter_list|(
name|pctl
parameter_list|,
name|type
parameter_list|,
name|nvl
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|)
define|\
value|{ \ 		int done = 0; \ 		if ((pctl)->nvprt_custops&& CUSTPRTOP(pctl, type)) { \ 			done = CUSTPRTOP(pctl, type)(pctl, \ 			    CUSTPRTOPARG(pctl, type), nvl, name, val); \ 		} \ 		if (!done) { \ 			(void) DFLTPRTOP(pctl, type)(pctl, \ 			    DFLTPRTOPARG(pctl, type), nvl, name, val); \ 		} \ 		(void) fprintf(pctl->nvprt_fp, pctl->nvprt_eomfmt); \ 	}
end_define

begin_define
define|#
directive|define
name|ARENDER
parameter_list|(
name|pctl
parameter_list|,
name|type
parameter_list|,
name|nvl
parameter_list|,
name|name
parameter_list|,
name|arrp
parameter_list|,
name|count
parameter_list|)
define|\
value|{ \ 		int done = 0; \ 		if ((pctl)->nvprt_custops&& CUSTPRTOP(pctl, type)) { \ 			done = CUSTPRTOP(pctl, type)(pctl, \ 			    CUSTPRTOPARG(pctl, type), nvl, name, arrp, count); \ 		} \ 		if (!done) { \ 			(void) DFLTPRTOP(pctl, type)(pctl, \ 			    DFLTPRTOPARG(pctl, type), nvl, name, arrp, count); \ 		} \ 		(void) fprintf(pctl->nvprt_fp, pctl->nvprt_eomfmt); \ 	}
end_define

begin_function_decl
specifier|static
name|void
name|nvlist_print_with_indent
parameter_list|(
name|nvlist_t
modifier|*
parameter_list|,
name|nvlist_prtctl_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * ======================================================================  * |									|  * | Indentation							|  * |									|  * ======================================================================  */
end_comment

begin_function
specifier|static
name|void
name|indent
parameter_list|(
name|nvlist_prtctl_t
name|pctl
parameter_list|,
name|int
name|onemore
parameter_list|)
block|{
name|int
name|depth
decl_stmt|;
switch|switch
condition|(
name|pctl
operator|->
name|nvprt_indent_mode
condition|)
block|{
case|case
name|NVLIST_INDENT_ABS
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|pctl
operator|->
name|nvprt_fp
argument_list|,
literal|"%*s"
argument_list|,
name|pctl
operator|->
name|nvprt_indent
operator|+
name|onemore
operator|*
name|pctl
operator|->
name|nvprt_indentinc
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|NVLIST_INDENT_TABBED
case|:
name|depth
operator|=
name|pctl
operator|->
name|nvprt_indent
operator|+
name|onemore
expr_stmt|;
while|while
condition|(
name|depth
operator|--
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|pctl
operator|->
name|nvprt_fp
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ======================================================================  * |									|  * | Default nvlist member rendering functions.				|  * |									|  * ======================================================================  */
end_comment

begin_comment
comment|/*  * Generate functions to print single-valued nvlist members.  *  * type_and_variant - suffix to form function name  * vtype - C type for the member value  * ptype - C type to cast value to for printing  * vfmt - format string for pair value, e.g "%d" or "0x%llx"  */
end_comment

begin_define
define|#
directive|define
name|NVLIST_PRTFUNC
parameter_list|(
name|type_and_variant
parameter_list|,
name|vtype
parameter_list|,
name|ptype
parameter_list|,
name|vfmt
parameter_list|)
define|\
value|static int \ nvprint_##type_and_variant(nvlist_prtctl_t pctl, void *private, \     nvlist_t *nvl, const char *name, vtype value) \ { \ 	FILE *fp = pctl->nvprt_fp; \ 	NOTE(ARGUNUSED(private)) \ 	NOTE(ARGUNUSED(nvl)) \ 	indent(pctl, 1); \ 	(void) fprintf(fp, pctl->nvprt_nmfmt, name); \ 	(void) fprintf(fp, vfmt, (ptype)value); \ 	return (1); \ }
end_define

begin_macro
name|NVLIST_PRTFUNC
argument_list|(
argument|boolean
argument_list|,
argument|int
argument_list|,
argument|int
argument_list|,
literal|"%d"
argument_list|)
end_macro

begin_macro
name|NVLIST_PRTFUNC
argument_list|(
argument|boolean_value
argument_list|,
argument|boolean_t
argument_list|,
argument|int
argument_list|,
literal|"%d"
argument_list|)
end_macro

begin_macro
name|NVLIST_PRTFUNC
argument_list|(
argument|byte
argument_list|,
argument|uchar_t
argument_list|,
argument|uchar_t
argument_list|,
literal|"0x%2.2x"
argument_list|)
end_macro

begin_macro
name|NVLIST_PRTFUNC
argument_list|(
argument|int8
argument_list|,
argument|int8_t
argument_list|,
argument|int
argument_list|,
literal|"%d"
argument_list|)
end_macro

begin_macro
name|NVLIST_PRTFUNC
argument_list|(
argument|uint8
argument_list|,
argument|uint8_t
argument_list|,
argument|uint8_t
argument_list|,
literal|"0x%x"
argument_list|)
end_macro

begin_macro
name|NVLIST_PRTFUNC
argument_list|(
argument|int16
argument_list|,
argument|int16_t
argument_list|,
argument|int16_t
argument_list|,
literal|"%d"
argument_list|)
end_macro

begin_macro
name|NVLIST_PRTFUNC
argument_list|(
argument|uint16
argument_list|,
argument|uint16_t
argument_list|,
argument|uint16_t
argument_list|,
literal|"0x%x"
argument_list|)
end_macro

begin_macro
name|NVLIST_PRTFUNC
argument_list|(
argument|int32
argument_list|,
argument|int32_t
argument_list|,
argument|int32_t
argument_list|,
literal|"%d"
argument_list|)
end_macro

begin_macro
name|NVLIST_PRTFUNC
argument_list|(
argument|uint32
argument_list|,
argument|uint32_t
argument_list|,
argument|uint32_t
argument_list|,
literal|"0x%x"
argument_list|)
end_macro

begin_macro
name|NVLIST_PRTFUNC
argument_list|(
argument|int64
argument_list|,
argument|int64_t
argument_list|,
argument|longlong_t
argument_list|,
literal|"%lld"
argument_list|)
end_macro

begin_macro
name|NVLIST_PRTFUNC
argument_list|(
argument|uint64
argument_list|,
argument|uint64_t
argument_list|,
argument|u_longlong_t
argument_list|,
literal|"0x%llx"
argument_list|)
end_macro

begin_macro
name|NVLIST_PRTFUNC
argument_list|(
argument|double
argument_list|,
argument|double
argument_list|,
argument|double
argument_list|,
literal|"0x%f"
argument_list|)
end_macro

begin_macro
name|NVLIST_PRTFUNC
argument_list|(
argument|string
argument_list|,
argument|char *
argument_list|,
argument|char *
argument_list|,
literal|"%s"
argument_list|)
end_macro

begin_macro
name|NVLIST_PRTFUNC
argument_list|(
argument|hrtime
argument_list|,
argument|hrtime_t
argument_list|,
argument|hrtime_t
argument_list|,
literal|"0x%llx"
argument_list|)
end_macro

begin_comment
comment|/*  * Generate functions to print array-valued nvlist members.  */
end_comment

begin_define
define|#
directive|define
name|NVLIST_ARRPRTFUNC
parameter_list|(
name|type_and_variant
parameter_list|,
name|vtype
parameter_list|,
name|ptype
parameter_list|,
name|vfmt
parameter_list|)
define|\
value|static int \ nvaprint_##type_and_variant(nvlist_prtctl_t pctl, void *private, \     nvlist_t *nvl, const char *name, vtype *valuep, uint_t count) \ { \ 	FILE *fp = pctl->nvprt_fp; \ 	uint_t i; \ 	NOTE(ARGUNUSED(private)) \ 	NOTE(ARGUNUSED(nvl)) \ 	for (i = 0; i< count; i++) { \ 		if (i == 0 || pctl->nvprt_btwnarrfmt_nl) { \ 			indent(pctl, 1); \ 			(void) fprintf(fp, pctl->nvprt_nmfmt, name); \ 			if (pctl->nvprt_btwnarrfmt_nl) \ 				(void) fprintf(fp, "[%d]: ", i); \ 		} \ 		if (i != 0) \ 			(void) fprintf(fp, pctl->nvprt_btwnarrfmt); \ 		(void) fprintf(fp, vfmt, (ptype)valuep[i]); \ 	} \ 	return (1); \ }
end_define

begin_macro
name|NVLIST_ARRPRTFUNC
argument_list|(
argument|boolean_array
argument_list|,
argument|boolean_t
argument_list|,
argument|boolean_t
argument_list|,
literal|"%d"
argument_list|)
end_macro

begin_macro
name|NVLIST_ARRPRTFUNC
argument_list|(
argument|byte_array
argument_list|,
argument|uchar_t
argument_list|,
argument|uchar_t
argument_list|,
literal|"0x%2.2x"
argument_list|)
end_macro

begin_macro
name|NVLIST_ARRPRTFUNC
argument_list|(
argument|int8_array
argument_list|,
argument|int8_t
argument_list|,
argument|int8_t
argument_list|,
literal|"%d"
argument_list|)
end_macro

begin_macro
name|NVLIST_ARRPRTFUNC
argument_list|(
argument|uint8_array
argument_list|,
argument|uint8_t
argument_list|,
argument|uint8_t
argument_list|,
literal|"0x%x"
argument_list|)
end_macro

begin_macro
name|NVLIST_ARRPRTFUNC
argument_list|(
argument|int16_array
argument_list|,
argument|int16_t
argument_list|,
argument|int16_t
argument_list|,
literal|"%d"
argument_list|)
end_macro

begin_macro
name|NVLIST_ARRPRTFUNC
argument_list|(
argument|uint16_array
argument_list|,
argument|uint16_t
argument_list|,
argument|uint16_t
argument_list|,
literal|"0x%x"
argument_list|)
end_macro

begin_macro
name|NVLIST_ARRPRTFUNC
argument_list|(
argument|int32_array
argument_list|,
argument|int32_t
argument_list|,
argument|int32_t
argument_list|,
literal|"%d"
argument_list|)
end_macro

begin_macro
name|NVLIST_ARRPRTFUNC
argument_list|(
argument|uint32_array
argument_list|,
argument|uint32_t
argument_list|,
argument|uint32_t
argument_list|,
literal|"0x%x"
argument_list|)
end_macro

begin_macro
name|NVLIST_ARRPRTFUNC
argument_list|(
argument|int64_array
argument_list|,
argument|int64_t
argument_list|,
argument|longlong_t
argument_list|,
literal|"%lld"
argument_list|)
end_macro

begin_macro
name|NVLIST_ARRPRTFUNC
argument_list|(
argument|uint64_array
argument_list|,
argument|uint64_t
argument_list|,
argument|u_longlong_t
argument_list|,
literal|"0x%llx"
argument_list|)
end_macro

begin_macro
name|NVLIST_ARRPRTFUNC
argument_list|(
argument|string_array
argument_list|,
argument|char *
argument_list|,
argument|char *
argument_list|,
literal|"%s"
argument_list|)
end_macro

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|nvprint_nvlist
parameter_list|(
name|nvlist_prtctl_t
name|pctl
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|value
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|pctl
operator|->
name|nvprt_fp
decl_stmt|;
name|indent
argument_list|(
name|pctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s = (embedded nvlist)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pctl
operator|->
name|nvprt_indent
operator|+=
name|pctl
operator|->
name|nvprt_indentinc
expr_stmt|;
name|nvlist_print_with_indent
argument_list|(
name|value
argument_list|,
name|pctl
argument_list|)
expr_stmt|;
name|pctl
operator|->
name|nvprt_indent
operator|-=
name|pctl
operator|->
name|nvprt_indentinc
expr_stmt|;
name|indent
argument_list|(
name|pctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"(end %s)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|nvaprint_nvlist_array
parameter_list|(
name|nvlist_prtctl_t
name|pctl
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|valuep
parameter_list|,
name|uint_t
name|count
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|pctl
operator|->
name|nvprt_fp
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
name|indent
argument_list|(
name|pctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s = (array of embedded nvlists)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|indent
argument_list|(
name|pctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"(start %s[%d])\n"
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pctl
operator|->
name|nvprt_indent
operator|+=
name|pctl
operator|->
name|nvprt_indentinc
expr_stmt|;
name|nvlist_print_with_indent
argument_list|(
name|valuep
index|[
name|i
index|]
argument_list|,
name|pctl
argument_list|)
expr_stmt|;
name|pctl
operator|->
name|nvprt_indent
operator|-=
name|pctl
operator|->
name|nvprt_indentinc
expr_stmt|;
name|indent
argument_list|(
name|pctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"(end %s[%d])\n"
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ======================================================================  * |									|  * | Interfaces that allow control over formatting.			|  * |									|  * ======================================================================  */
end_comment

begin_function
name|void
name|nvlist_prtctl_setdest
parameter_list|(
name|nvlist_prtctl_t
name|pctl
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|pctl
operator|->
name|nvprt_fp
operator|=
name|fp
expr_stmt|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|nvlist_prtctl_getdest
parameter_list|(
name|nvlist_prtctl_t
name|pctl
parameter_list|)
block|{
return|return
operator|(
name|pctl
operator|->
name|nvprt_fp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nvlist_prtctl_setindent
parameter_list|(
name|nvlist_prtctl_t
name|pctl
parameter_list|,
name|enum
name|nvlist_indent_mode
name|mode
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|inc
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|<
name|NVLIST_INDENT_ABS
operator|||
name|mode
operator|>
name|NVLIST_INDENT_TABBED
condition|)
name|mode
operator|=
name|NVLIST_INDENT_TABBED
expr_stmt|;
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inc
operator|<
literal|0
condition|)
name|inc
operator|=
literal|1
expr_stmt|;
name|pctl
operator|->
name|nvprt_indent_mode
operator|=
name|mode
expr_stmt|;
name|pctl
operator|->
name|nvprt_indent
operator|=
name|start
expr_stmt|;
name|pctl
operator|->
name|nvprt_indentinc
operator|=
name|inc
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_prtctl_doindent
parameter_list|(
name|nvlist_prtctl_t
name|pctl
parameter_list|,
name|int
name|onemore
parameter_list|)
block|{
name|indent
argument_list|(
name|pctl
argument_list|,
name|onemore
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_prtctl_setfmt
parameter_list|(
name|nvlist_prtctl_t
name|pctl
parameter_list|,
name|enum
name|nvlist_prtctl_fmt
name|which
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|)
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|NVLIST_FMT_MEMBER_NAME
case|:
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
name|fmt
operator|=
literal|"%s = "
expr_stmt|;
name|pctl
operator|->
name|nvprt_nmfmt
operator|=
name|fmt
expr_stmt|;
break|break;
case|case
name|NVLIST_FMT_MEMBER_POSTAMBLE
case|:
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
name|fmt
operator|=
literal|"\n"
expr_stmt|;
name|pctl
operator|->
name|nvprt_eomfmt
operator|=
name|fmt
expr_stmt|;
break|break;
case|case
name|NVLIST_FMT_BTWN_ARRAY
case|:
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
block|{
name|pctl
operator|->
name|nvprt_btwnarrfmt
operator|=
literal|" "
expr_stmt|;
name|pctl
operator|->
name|nvprt_btwnarrfmt_nl
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pctl
operator|->
name|nvprt_btwnarrfmt
operator|=
name|fmt
expr_stmt|;
name|pctl
operator|->
name|nvprt_btwnarrfmt_nl
operator|=
operator|(
name|strstr
argument_list|(
name|fmt
argument_list|,
literal|"\n"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|void
name|nvlist_prtctl_dofmt
parameter_list|(
name|nvlist_prtctl_t
name|pctl
parameter_list|,
name|enum
name|nvlist_prtctl_fmt
name|which
parameter_list|,
modifier|...
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|pctl
operator|->
name|nvprt_fp
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|which
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|NVLIST_FMT_MEMBER_NAME
case|:
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|pctl
operator|->
name|nvprt_nmfmt
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|NVLIST_FMT_MEMBER_POSTAMBLE
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|pctl
operator|->
name|nvprt_eomfmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|NVLIST_FMT_BTWN_ARRAY
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|pctl
operator|->
name|nvprt_btwnarrfmt
argument_list|)
expr_stmt|;
block|\
break|break;
default|default:
break|break;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ======================================================================  * |									|  * | Interfaces to allow appointment of replacement rendering functions.|  * |									|  * ======================================================================  */
end_comment

begin_define
define|#
directive|define
name|NVLIST_PRINTCTL_REPLACE
parameter_list|(
name|type
parameter_list|,
name|vtype
parameter_list|)
define|\
value|void \ nvlist_prtctlop_##type(nvlist_prtctl_t pctl, \     int (*func)(nvlist_prtctl_t, void *, nvlist_t *, const char *, vtype), \     void *private) \ { \ 	CUSTPRTOP(pctl, type) = func; \ 	CUSTPRTOPARG(pctl, type) = private; \ }
end_define

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|boolean
argument_list|,
argument|int
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|boolean_value
argument_list|,
argument|boolean_t
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|byte
argument_list|,
argument|uchar_t
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|int8
argument_list|,
argument|int8_t
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|uint8
argument_list|,
argument|uint8_t
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|int16
argument_list|,
argument|int16_t
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|uint16
argument_list|,
argument|uint16_t
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|int32
argument_list|,
argument|int32_t
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|uint32
argument_list|,
argument|uint32_t
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|int64
argument_list|,
argument|int64_t
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|uint64
argument_list|,
argument|uint64_t
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|double
argument_list|,
argument|double
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|string
argument_list|,
argument|char *
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|hrtime
argument_list|,
argument|hrtime_t
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_REPLACE
argument_list|(
argument|nvlist
argument_list|,
argument|nvlist_t *
argument_list|)
end_macro

begin_define
define|#
directive|define
name|NVLIST_PRINTCTL_AREPLACE
parameter_list|(
name|type
parameter_list|,
name|vtype
parameter_list|)
define|\
value|void \ nvlist_prtctlop_##type(nvlist_prtctl_t pctl, \     int (*func)(nvlist_prtctl_t, void *, nvlist_t *, const char *, vtype, \     uint_t), void *private) \ { \ 	CUSTPRTOP(pctl, type) = func; \ 	CUSTPRTOPARG(pctl, type) = private; \ }
end_define

begin_macro
name|NVLIST_PRINTCTL_AREPLACE
argument_list|(
argument|boolean_array
argument_list|,
argument|boolean_t *
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_AREPLACE
argument_list|(
argument|byte_array
argument_list|,
argument|uchar_t *
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_AREPLACE
argument_list|(
argument|int8_array
argument_list|,
argument|int8_t *
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_AREPLACE
argument_list|(
argument|uint8_array
argument_list|,
argument|uint8_t *
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_AREPLACE
argument_list|(
argument|int16_array
argument_list|,
argument|int16_t *
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_AREPLACE
argument_list|(
argument|uint16_array
argument_list|,
argument|uint16_t *
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_AREPLACE
argument_list|(
argument|int32_array
argument_list|,
argument|int32_t *
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_AREPLACE
argument_list|(
argument|uint32_array
argument_list|,
argument|uint32_t *
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_AREPLACE
argument_list|(
argument|int64_array
argument_list|,
argument|int64_t *
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_AREPLACE
argument_list|(
argument|uint64_array
argument_list|,
argument|uint64_t *
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_AREPLACE
argument_list|(
argument|string_array
argument_list|,
argument|char **
argument_list|)
end_macro

begin_macro
name|NVLIST_PRINTCTL_AREPLACE
argument_list|(
argument|nvlist_array
argument_list|,
argument|nvlist_t **
argument_list|)
end_macro

begin_comment
comment|/*  * ======================================================================  * |									|  * | Interfaces to manage nvlist_prtctl_t cookies.			|  * |									|  * ======================================================================  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|nvlist_printops
name|defprtops
init|=
block|{
block|{
name|nvprint_boolean
block|,
name|NULL
block|}
block|,
block|{
name|nvprint_boolean_value
block|,
name|NULL
block|}
block|,
block|{
name|nvprint_byte
block|,
name|NULL
block|}
block|,
block|{
name|nvprint_int8
block|,
name|NULL
block|}
block|,
block|{
name|nvprint_uint8
block|,
name|NULL
block|}
block|,
block|{
name|nvprint_int16
block|,
name|NULL
block|}
block|,
block|{
name|nvprint_uint16
block|,
name|NULL
block|}
block|,
block|{
name|nvprint_int32
block|,
name|NULL
block|}
block|,
block|{
name|nvprint_uint32
block|,
name|NULL
block|}
block|,
block|{
name|nvprint_int64
block|,
name|NULL
block|}
block|,
block|{
name|nvprint_uint64
block|,
name|NULL
block|}
block|,
block|{
name|nvprint_double
block|,
name|NULL
block|}
block|,
block|{
name|nvprint_string
block|,
name|NULL
block|}
block|,
block|{
name|nvprint_hrtime
block|,
name|NULL
block|}
block|,
block|{
name|nvprint_nvlist
block|,
name|NULL
block|}
block|,
block|{
name|nvaprint_boolean_array
block|,
name|NULL
block|}
block|,
block|{
name|nvaprint_byte_array
block|,
name|NULL
block|}
block|,
block|{
name|nvaprint_int8_array
block|,
name|NULL
block|}
block|,
block|{
name|nvaprint_uint8_array
block|,
name|NULL
block|}
block|,
block|{
name|nvaprint_int16_array
block|,
name|NULL
block|}
block|,
block|{
name|nvaprint_uint16_array
block|,
name|NULL
block|}
block|,
block|{
name|nvaprint_int32_array
block|,
name|NULL
block|}
block|,
block|{
name|nvaprint_uint32_array
block|,
name|NULL
block|}
block|,
block|{
name|nvaprint_int64_array
block|,
name|NULL
block|}
block|,
block|{
name|nvaprint_uint64_array
block|,
name|NULL
block|}
block|,
block|{
name|nvaprint_string_array
block|,
name|NULL
block|}
block|,
block|{
name|nvaprint_nvlist_array
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|prtctl_defaults
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|nvlist_prtctl
modifier|*
name|pctl
parameter_list|,
name|struct
name|nvlist_printops
modifier|*
name|ops
parameter_list|)
block|{
name|pctl
operator|->
name|nvprt_fp
operator|=
name|fp
expr_stmt|;
name|pctl
operator|->
name|nvprt_indent_mode
operator|=
name|NVLIST_INDENT_TABBED
expr_stmt|;
name|pctl
operator|->
name|nvprt_indent
operator|=
literal|0
expr_stmt|;
name|pctl
operator|->
name|nvprt_indentinc
operator|=
literal|1
expr_stmt|;
name|pctl
operator|->
name|nvprt_nmfmt
operator|=
literal|"%s = "
expr_stmt|;
name|pctl
operator|->
name|nvprt_eomfmt
operator|=
literal|"\n"
expr_stmt|;
name|pctl
operator|->
name|nvprt_btwnarrfmt
operator|=
literal|" "
expr_stmt|;
name|pctl
operator|->
name|nvprt_btwnarrfmt_nl
operator|=
literal|0
expr_stmt|;
name|pctl
operator|->
name|nvprt_dfltops
operator|=
operator|(
expr|struct
name|nvlist_printops
operator|*
operator|)
operator|&
name|defprtops
expr_stmt|;
name|pctl
operator|->
name|nvprt_custops
operator|=
name|ops
expr_stmt|;
block|}
end_function

begin_function
name|nvlist_prtctl_t
name|nvlist_prtctl_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|nvlist_prtctl
modifier|*
name|pctl
decl_stmt|;
name|struct
name|nvlist_printops
modifier|*
name|ops
decl_stmt|;
if|if
condition|(
operator|(
name|pctl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pctl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|ops
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ops
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pctl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|prtctl_defaults
argument_list|(
name|stdout
argument_list|,
name|pctl
argument_list|,
name|ops
argument_list|)
expr_stmt|;
return|return
operator|(
name|pctl
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nvlist_prtctl_free
parameter_list|(
name|nvlist_prtctl_t
name|pctl
parameter_list|)
block|{
if|if
condition|(
name|pctl
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pctl
operator|->
name|nvprt_custops
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pctl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ======================================================================  * |									|  * | Top-level print request interfaces.				|  * |									|  * ======================================================================  */
end_comment

begin_comment
comment|/*  * nvlist_print - Prints elements in an event buffer  */
end_comment

begin_function
specifier|static
name|void
name|nvlist_print_with_indent
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvlist_prtctl_t
name|pctl
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|pctl
operator|->
name|nvprt_fp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|uint_t
name|nelem
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
return|return;
name|indent
argument_list|(
name|pctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"nvlist version: %d\n"
argument_list|,
name|NVL_VERSION
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|nvp
condition|)
block|{
name|data_type_t
name|type
init|=
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|name
operator|=
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|nelem
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATA_TYPE_BOOLEAN
case|:
block|{
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|boolean
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_BOOLEAN_VALUE
case|:
block|{
name|boolean_t
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_boolean_value
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|boolean_value
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_BYTE
case|:
block|{
name|uchar_t
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_byte
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|byte
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_INT8
case|:
block|{
name|int8_t
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_int8
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|int8
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT8
case|:
block|{
name|uint8_t
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_uint8
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|uint8
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_INT16
case|:
block|{
name|int16_t
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_int16
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|int16
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT16
case|:
block|{
name|uint16_t
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_uint16
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|uint16
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_INT32
case|:
block|{
name|int32_t
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_int32
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|int32
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT32
case|:
block|{
name|uint32_t
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_uint32
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|uint32
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_INT64
case|:
block|{
name|int64_t
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_int64
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|int64
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT64
case|:
block|{
name|uint64_t
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_uint64
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|uint64
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_DOUBLE
case|:
block|{
name|double
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_double
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|double
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_STRING
case|:
block|{
name|char
modifier|*
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_string
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|string
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_BOOLEAN_ARRAY
case|:
block|{
name|boolean_t
modifier|*
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_boolean_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|ARENDER
argument_list|(
name|pctl
argument_list|,
name|boolean_array
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_BYTE_ARRAY
case|:
block|{
name|uchar_t
modifier|*
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_byte_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|ARENDER
argument_list|(
name|pctl
argument_list|,
name|byte_array
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_INT8_ARRAY
case|:
block|{
name|int8_t
modifier|*
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_int8_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|ARENDER
argument_list|(
name|pctl
argument_list|,
name|int8_array
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT8_ARRAY
case|:
block|{
name|uint8_t
modifier|*
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_uint8_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|ARENDER
argument_list|(
name|pctl
argument_list|,
name|uint8_array
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_INT16_ARRAY
case|:
block|{
name|int16_t
modifier|*
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_int16_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|ARENDER
argument_list|(
name|pctl
argument_list|,
name|int16_array
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT16_ARRAY
case|:
block|{
name|uint16_t
modifier|*
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_uint16_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|ARENDER
argument_list|(
name|pctl
argument_list|,
name|uint16_array
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_INT32_ARRAY
case|:
block|{
name|int32_t
modifier|*
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_int32_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|ARENDER
argument_list|(
name|pctl
argument_list|,
name|int32_array
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT32_ARRAY
case|:
block|{
name|uint32_t
modifier|*
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_uint32_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|ARENDER
argument_list|(
name|pctl
argument_list|,
name|uint32_array
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_INT64_ARRAY
case|:
block|{
name|int64_t
modifier|*
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_int64_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|ARENDER
argument_list|(
name|pctl
argument_list|,
name|int64_array
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT64_ARRAY
case|:
block|{
name|uint64_t
modifier|*
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_uint64_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|ARENDER
argument_list|(
name|pctl
argument_list|,
name|uint64_array
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_STRING_ARRAY
case|:
block|{
name|char
modifier|*
modifier|*
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_string_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|ARENDER
argument_list|(
name|pctl
argument_list|,
name|string_array
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_HRTIME
case|:
block|{
name|hrtime_t
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_hrtime
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|hrtime
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_NVLIST
case|:
block|{
name|nvlist_t
modifier|*
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_nvlist
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|RENDER
argument_list|(
name|pctl
argument_list|,
name|nvlist
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
block|{
name|nvlist_t
modifier|*
modifier|*
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_nvlist_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|ARENDER
argument_list|(
name|pctl
argument_list|,
name|nvlist_array
argument_list|,
name|nvl
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" unknown data type (%d)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nvlist_print
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|struct
name|nvlist_prtctl
name|pc
decl_stmt|;
name|prtctl_defaults
argument_list|(
name|fp
argument_list|,
operator|&
name|pc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_print_with_indent
argument_list|(
name|nvl
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_prt
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvlist_prtctl_t
name|pctl
parameter_list|)
block|{
name|nvlist_print_with_indent
argument_list|(
name|nvl
argument_list|,
name|pctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NVP
parameter_list|(
name|elem
parameter_list|,
name|type
parameter_list|,
name|vtype
parameter_list|,
name|ptype
parameter_list|,
name|format
parameter_list|)
value|{ \ 	vtype	value; \ \ 	(void) nvpair_value_##type(elem,&value); \ 	(void) printf("%*s%s: " format "\n", indent, "", \ 	    nvpair_name(elem), (ptype)value); \ }
end_define

begin_define
define|#
directive|define
name|NVPA
parameter_list|(
name|elem
parameter_list|,
name|type
parameter_list|,
name|vtype
parameter_list|,
name|ptype
parameter_list|,
name|format
parameter_list|)
value|{ \ 	uint_t	i, count; \ 	vtype	*value;  \ \ 	(void) nvpair_value_##type(elem,&value,&count); \ 	for (i = 0; i< count; i++) { \ 		(void) printf("%*s%s[%d]: " format "\n", indent, "", \ 		    nvpair_name(elem), i, (ptype)value[i]); \ 	} \ }
end_define

begin_comment
comment|/*  * Similar to nvlist_print() but handles arrays slightly differently.  */
end_comment

begin_function
name|void
name|dump_nvlist
parameter_list|(
name|nvlist_t
modifier|*
name|list
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|bool_value
decl_stmt|;
name|nvlist_t
modifier|*
name|nvlist_value
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|nvlist_array_value
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|list
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
condition|)
block|{
case|case
name|DATA_TYPE_BOOLEAN
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_VALUE
case|:
operator|(
name|void
operator|)
name|nvpair_value_boolean_value
argument_list|(
name|elem
argument_list|,
operator|&
name|bool_value
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s: %s\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
name|bool_value
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BYTE
case|:
name|NVP
argument_list|(
name|elem
argument_list|,
name|byte
argument_list|,
name|uchar_t
argument_list|,
name|int
argument_list|,
literal|"%u"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT8
case|:
name|NVP
argument_list|(
name|elem
argument_list|,
name|int8
argument_list|,
name|int8_t
argument_list|,
name|int
argument_list|,
literal|"%d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT8
case|:
name|NVP
argument_list|(
name|elem
argument_list|,
name|uint8
argument_list|,
name|uint8_t
argument_list|,
name|int
argument_list|,
literal|"%u"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT16
case|:
name|NVP
argument_list|(
name|elem
argument_list|,
name|int16
argument_list|,
name|int16_t
argument_list|,
name|int
argument_list|,
literal|"%d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT16
case|:
name|NVP
argument_list|(
name|elem
argument_list|,
name|uint16
argument_list|,
name|uint16_t
argument_list|,
name|int
argument_list|,
literal|"%u"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT32
case|:
name|NVP
argument_list|(
name|elem
argument_list|,
name|int32
argument_list|,
name|int32_t
argument_list|,
name|long
argument_list|,
literal|"%ld"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT32
case|:
name|NVP
argument_list|(
name|elem
argument_list|,
name|uint32
argument_list|,
name|uint32_t
argument_list|,
name|ulong_t
argument_list|,
literal|"%lu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT64
case|:
name|NVP
argument_list|(
name|elem
argument_list|,
name|int64
argument_list|,
name|int64_t
argument_list|,
name|longlong_t
argument_list|,
literal|"%lld"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT64
case|:
name|NVP
argument_list|(
name|elem
argument_list|,
name|uint64
argument_list|,
name|uint64_t
argument_list|,
name|u_longlong_t
argument_list|,
literal|"%llu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_STRING
case|:
name|NVP
argument_list|(
name|elem
argument_list|,
name|string
argument_list|,
name|char
operator|*
argument_list|,
name|char
operator|*
argument_list|,
literal|"'%s'"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BYTE_ARRAY
case|:
name|NVPA
argument_list|(
name|elem
argument_list|,
name|byte_array
argument_list|,
name|uchar_t
argument_list|,
name|int
argument_list|,
literal|"%u"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT8_ARRAY
case|:
name|NVPA
argument_list|(
name|elem
argument_list|,
name|int8_array
argument_list|,
name|int8_t
argument_list|,
name|int
argument_list|,
literal|"%d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT8_ARRAY
case|:
name|NVPA
argument_list|(
name|elem
argument_list|,
name|uint8_array
argument_list|,
name|uint8_t
argument_list|,
name|int
argument_list|,
literal|"%u"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT16_ARRAY
case|:
name|NVPA
argument_list|(
name|elem
argument_list|,
name|int16_array
argument_list|,
name|int16_t
argument_list|,
name|int
argument_list|,
literal|"%d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT16_ARRAY
case|:
name|NVPA
argument_list|(
name|elem
argument_list|,
name|uint16_array
argument_list|,
name|uint16_t
argument_list|,
name|int
argument_list|,
literal|"%u"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT32_ARRAY
case|:
name|NVPA
argument_list|(
name|elem
argument_list|,
name|int32_array
argument_list|,
name|int32_t
argument_list|,
name|long
argument_list|,
literal|"%ld"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT32_ARRAY
case|:
name|NVPA
argument_list|(
name|elem
argument_list|,
name|uint32_array
argument_list|,
name|uint32_t
argument_list|,
name|ulong_t
argument_list|,
literal|"%lu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT64_ARRAY
case|:
name|NVPA
argument_list|(
name|elem
argument_list|,
name|int64_array
argument_list|,
name|int64_t
argument_list|,
name|longlong_t
argument_list|,
literal|"%lld"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT64_ARRAY
case|:
name|NVPA
argument_list|(
name|elem
argument_list|,
name|uint64_array
argument_list|,
name|uint64_t
argument_list|,
name|u_longlong_t
argument_list|,
literal|"%llu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_STRING_ARRAY
case|:
name|NVPA
argument_list|(
name|elem
argument_list|,
name|string_array
argument_list|,
name|char
operator|*
argument_list|,
name|char
operator|*
argument_list|,
literal|"'%s'"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_NVLIST
case|:
operator|(
name|void
operator|)
name|nvpair_value_nvlist
argument_list|(
name|elem
argument_list|,
operator|&
name|nvlist_value
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s:\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
name|dump_nvlist
argument_list|(
name|nvlist_value
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
operator|(
name|void
operator|)
name|nvpair_value_nvlist_array
argument_list|(
name|elem
argument_list|,
operator|&
name|nvlist_array_value
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s[%u]:\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_nvlist
argument_list|(
name|nvlist_array_value
index|[
name|i
index|]
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bad config type "
literal|"%d for %s\n"
argument_list|)
argument_list|,
name|nvpair_type
argument_list|(
name|elem
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * ======================================================================  * |									|  * | Misc private interface.						|  * |									|  * ======================================================================  */
end_comment

begin_comment
comment|/*  * Determine if string 'value' matches 'nvp' value.  The 'value' string is  * converted, depending on the type of 'nvp', prior to match.  For numeric  * types, a radix independent sscanf conversion of 'value' is used. If 'nvp'  * is an array type, 'ai' is the index into the array against which we are  * checking for match. If nvp is of DATA_TYPE_STRING*, the caller can pass  * in a regex_t compilation of value in 'value_regex' to trigger regular  * expression string match instead of simple strcmp().  *  * Return 1 on match, 0 on no-match, and -1 on error.  If the error is  * related to value syntax error and 'ep' is non-NULL, *ep will point into  * the 'value' string at the location where the error exists.  *  * NOTE: It may be possible to move the non-regex_t version of this into  * common code used by library/kernel/boot.  */
end_comment

begin_function
name|int
name|nvpair_value_match_regex
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|int
name|ai
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|regex_t
modifier|*
name|value_regex
parameter_list|,
name|char
modifier|*
modifier|*
name|ep
parameter_list|)
block|{
name|char
modifier|*
name|evalue
decl_stmt|;
name|uint_t
name|a_len
decl_stmt|;
name|int
name|sr
decl_stmt|;
if|if
condition|(
name|ep
condition|)
operator|*
name|ep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|nvp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|value
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error fail match - invalid args */
comment|/* make sure array and index combination make sense */
if|if
condition|(
operator|(
name|nvpair_type_is_array
argument_list|(
name|nvp
argument_list|)
operator|&&
operator|(
name|ai
operator|<
literal|0
operator|)
operator|)
operator|||
operator|(
operator|!
name|nvpair_type_is_array
argument_list|(
name|nvp
argument_list|)
operator|&&
operator|(
name|ai
operator|>=
literal|0
operator|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error fail match - bad index */
comment|/* non-string values should be single 'chunk' */
if|if
condition|(
operator|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
operator|!=
name|DATA_TYPE_STRING
operator|)
operator|&&
operator|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
operator|!=
name|DATA_TYPE_STRING_ARRAY
operator|)
condition|)
block|{
name|value
operator|+=
name|strspn
argument_list|(
name|value
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|evalue
operator|=
name|value
operator|+
name|strcspn
argument_list|(
name|value
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|evalue
condition|)
block|{
if|if
condition|(
name|ep
condition|)
operator|*
name|ep
operator|=
name|evalue
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error fail match - syntax */
block|}
block|}
name|sr
operator|=
name|EOF
expr_stmt|;
switch|switch
condition|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
condition|)
block|{
case|case
name|DATA_TYPE_STRING
case|:
block|{
name|char
modifier|*
name|val
decl_stmt|;
comment|/* check string value for match */
if|if
condition|(
name|nvpair_value_string
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value_regex
condition|)
block|{
if|if
condition|(
name|regexec
argument_list|(
name|value_regex
argument_list|,
name|val
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* match */
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|val
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* match */
block|}
block|}
break|break;
block|}
case|case
name|DATA_TYPE_STRING_ARRAY
case|:
block|{
name|char
modifier|*
modifier|*
name|val_array
decl_stmt|;
comment|/* check indexed string value of array for match */
if|if
condition|(
operator|(
name|nvpair_value_string_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val_array
argument_list|,
operator|&
name|a_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ai
operator|<
name|a_len
operator|)
condition|)
block|{
if|if
condition|(
name|value_regex
condition|)
block|{
if|if
condition|(
name|regexec
argument_list|(
name|value_regex
argument_list|,
name|val_array
index|[
name|ai
index|]
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|val_array
index|[
name|ai
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
break|break;
block|}
case|case
name|DATA_TYPE_BYTE
case|:
block|{
name|uchar_t
name|val
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* scanf uchar_t from value and check for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%c"
argument_list|,
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_byte
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|val
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_BYTE_ARRAY
case|:
block|{
name|uchar_t
modifier|*
name|val_array
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* check indexed value of array for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%c"
argument_list|,
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_byte_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val_array
argument_list|,
operator|&
name|a_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ai
operator|<
name|a_len
operator|)
operator|&&
operator|(
name|val_array
index|[
name|ai
index|]
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_INT8
case|:
block|{
name|int8_t
name|val
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* scanf int8_t from value and check for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi8
argument_list|,
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_int8
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|val
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_INT8_ARRAY
case|:
block|{
name|int8_t
modifier|*
name|val_array
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* check indexed value of array for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi8
argument_list|,
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_int8_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val_array
argument_list|,
operator|&
name|a_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ai
operator|<
name|a_len
operator|)
operator|&&
operator|(
name|val_array
index|[
name|ai
index|]
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT8
case|:
block|{
name|uint8_t
name|val
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* scanf uint8_t from value and check for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi8
argument_list|,
operator|(
name|int8_t
operator|*
operator|)
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_uint8
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|val
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT8_ARRAY
case|:
block|{
name|uint8_t
modifier|*
name|val_array
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* check indexed value of array for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi8
argument_list|,
operator|(
name|int8_t
operator|*
operator|)
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_uint8_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val_array
argument_list|,
operator|&
name|a_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ai
operator|<
name|a_len
operator|)
operator|&&
operator|(
name|val_array
index|[
name|ai
index|]
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_INT16
case|:
block|{
name|int16_t
name|val
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* scanf int16_t from value and check for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi16
argument_list|,
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_int16
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|val
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_INT16_ARRAY
case|:
block|{
name|int16_t
modifier|*
name|val_array
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* check indexed value of array for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi16
argument_list|,
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_int16_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val_array
argument_list|,
operator|&
name|a_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ai
operator|<
name|a_len
operator|)
operator|&&
operator|(
name|val_array
index|[
name|ai
index|]
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT16
case|:
block|{
name|uint16_t
name|val
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* scanf uint16_t from value and check for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi16
argument_list|,
operator|(
name|int16_t
operator|*
operator|)
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_uint16
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|val
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT16_ARRAY
case|:
block|{
name|uint16_t
modifier|*
name|val_array
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* check indexed value of array for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi16
argument_list|,
operator|(
name|int16_t
operator|*
operator|)
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_uint16_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val_array
argument_list|,
operator|&
name|a_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ai
operator|<
name|a_len
operator|)
operator|&&
operator|(
name|val_array
index|[
name|ai
index|]
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_INT32
case|:
block|{
name|int32_t
name|val
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* scanf int32_t from value and check for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi32
argument_list|,
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_int32
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|val
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_INT32_ARRAY
case|:
block|{
name|int32_t
modifier|*
name|val_array
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* check indexed value of array for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi32
argument_list|,
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_int32_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val_array
argument_list|,
operator|&
name|a_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ai
operator|<
name|a_len
operator|)
operator|&&
operator|(
name|val_array
index|[
name|ai
index|]
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT32
case|:
block|{
name|uint32_t
name|val
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* scanf uint32_t from value and check for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi32
argument_list|,
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_uint32
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|val
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT32_ARRAY
case|:
block|{
name|uint32_t
modifier|*
name|val_array
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* check indexed value of array for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi32
argument_list|,
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_uint32_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val_array
argument_list|,
operator|&
name|a_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ai
operator|<
name|a_len
operator|)
operator|&&
operator|(
name|val_array
index|[
name|ai
index|]
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_INT64
case|:
block|{
name|int64_t
name|val
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* scanf int64_t from value and check for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi64
argument_list|,
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_int64
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|val
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_INT64_ARRAY
case|:
block|{
name|int64_t
modifier|*
name|val_array
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* check indexed value of array for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi64
argument_list|,
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_int64_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val_array
argument_list|,
operator|&
name|a_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ai
operator|<
name|a_len
operator|)
operator|&&
operator|(
name|val_array
index|[
name|ai
index|]
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT64
case|:
block|{
name|uint64_t
name|val_arg
decl_stmt|,
name|val
decl_stmt|;
comment|/* scanf uint64_t from value and check for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi64
argument_list|,
operator|(
name|int64_t
operator|*
operator|)
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_uint64
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|val
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_UINT64_ARRAY
case|:
block|{
name|uint64_t
modifier|*
name|val_array
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* check indexed value of array for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi64
argument_list|,
operator|(
name|int64_t
operator|*
operator|)
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_uint64_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val_array
argument_list|,
operator|&
name|a_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ai
operator|<
name|a_len
operator|)
operator|&&
operator|(
name|val_array
index|[
name|ai
index|]
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_BOOLEAN_VALUE
case|:
block|{
name|boolean_t
name|val
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* scanf boolean_t from value and check for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi32
argument_list|,
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_boolean_value
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|val
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_BOOLEAN_ARRAY
case|:
block|{
name|boolean_t
modifier|*
name|val_array
decl_stmt|,
name|val_arg
decl_stmt|;
comment|/* check indexed value of array for match */
name|sr
operator|=
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%"
name|SCNi32
argument_list|,
operator|&
name|val_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nvpair_value_boolean_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val_array
argument_list|,
operator|&
name|a_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ai
operator|<
name|a_len
operator|)
operator|&&
operator|(
name|val_array
index|[
name|ai
index|]
operator|==
name|val_arg
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
case|case
name|DATA_TYPE_HRTIME
case|:
case|case
name|DATA_TYPE_NVLIST
case|:
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
case|case
name|DATA_TYPE_BOOLEAN
case|:
case|case
name|DATA_TYPE_DOUBLE
case|:
case|case
name|DATA_TYPE_UNKNOWN
case|:
default|default:
comment|/* 		 * unknown/unsupported data type 		 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error fail match */
block|}
comment|/* 	 * check to see if sscanf failed conversion, return approximate 	 * pointer to problem 	 */
if|if
condition|(
name|sr
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|ep
condition|)
operator|*
name|ep
operator|=
name|value
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error fail match  - syntax */
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* fail match */
block|}
end_function

begin_function
name|int
name|nvpair_value_match
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|int
name|ai
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|char
modifier|*
modifier|*
name|ep
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_match_regex
argument_list|(
name|nvp
argument_list|,
name|ai
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|,
name|ep
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

