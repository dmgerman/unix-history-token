begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2013, Joyent Inc. All rights reserved.  * Copyright (c) 2012 by Delphix. All rights reserved.  */
end_comment

begin_comment
comment|/*  * DTrace D Language Compiler  *  * The code in this source file implements the main engine for the D language  * compiler.  The driver routine for the compiler is dt_compile(), below.  The  * compiler operates on either stdio FILEs or in-memory strings as its input  * and can produce either dtrace_prog_t structures from a D program or a single  * dtrace_difo_t structure from a D expression.  Multiple entry points are  * provided as wrappers around dt_compile() for the various input/output pairs.  * The compiler itself is implemented across the following source files:  *  * dt_lex.l - lex scanner  * dt_grammar.y - yacc grammar  * dt_parser.c - parse tree creation and semantic checking  * dt_decl.c - declaration stack processing  * dt_xlator.c - D translator lookup and creation  * dt_ident.c - identifier and symbol table routines  * dt_pragma.c - #pragma processing and D pragmas  * dt_printf.c - D printf() and printa() argument checking and processing  * dt_cc.c - compiler driver and dtrace_prog_t construction  * dt_cg.c - DIF code generator  * dt_as.c - DIF assembler  * dt_dof.c - dtrace_prog_t -> DOF conversion  *  * Several other source files provide collections of utility routines used by  * these major files.  The compiler itself is implemented in multiple passes:  *  * (1) The input program is scanned and parsed by dt_lex.l and dt_grammar.y  *     and parse tree nodes are constructed using the routines in dt_parser.c.  *     This node construction pass is described further in dt_parser.c.  *  * (2) The parse tree is "cooked" by assigning each clause a context (see the  *     routine dt_setcontext(), below) based on its probe description and then  *     recursively descending the tree performing semantic checking.  The cook  *     routines are also implemented in dt_parser.c and described there.  *  * (3) For actions that are DIF expression statements, the DIF code generator  *     and assembler are invoked to create a finished DIFO for the statement.  *  * (4) The dtrace_prog_t data structures for the program clauses and actions  *     are built, containing pointers to any DIFOs created in step (3).  *  * (5) The caller invokes a routine in dt_dof.c to convert the finished program  *     into DOF format for use in anonymous tracing or enabling in the kernel.  *  * In the implementation, steps 2-4 are intertwined in that they are performed  * in order for each clause as part of a loop that executes over the clauses.  *  * The D compiler currently implements nearly no optimization.  The compiler  * implements integer constant folding as part of pass (1), and a set of very  * simple peephole optimizations as part of pass (3).  As with any C compiler,  * a large number of optimizations are possible on both the intermediate data  * structures and the generated DIF code.  These possibilities should be  * investigated in the context of whether they will have any substantive effect  * on the overall DTrace probe effect before they are undertaken.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ucontext.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<dt_module.h>
end_include

begin_include
include|#
directive|include
file|<dt_program.h>
end_include

begin_include
include|#
directive|include
file|<dt_provider.h>
end_include

begin_include
include|#
directive|include
file|<dt_printf.h>
end_include

begin_include
include|#
directive|include
file|<dt_pid.h>
end_include

begin_include
include|#
directive|include
file|<dt_grammar.h>
end_include

begin_include
include|#
directive|include
file|<dt_ident.h>
end_include

begin_include
include|#
directive|include
file|<dt_string.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|dtrace_diftype_t
name|dt_void_rtype
init|=
block|{
name|DIF_TYPE_CTF
block|,
name|CTF_K_INTEGER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|dtrace_diftype_t
name|dt_int_rtype
init|=
block|{
name|DIF_TYPE_CTF
block|,
name|CTF_K_INTEGER
block|,
literal|0
block|,
literal|0
block|,
expr|sizeof
operator|(
name|uint64_t
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
modifier|*
name|dt_compile
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|dtrace_probespec_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
specifier|const
type|[]
parameter_list|,
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_idreset
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|void
modifier|*
name|ignored
parameter_list|)
block|{
name|idp
operator|->
name|di_flags
operator|&=
operator|~
operator|(
name|DT_IDFLG_REF
operator||
name|DT_IDFLG_MOD
operator||
name|DT_IDFLG_DIFR
operator||
name|DT_IDFLG_DIFW
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_idpragma
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|void
modifier|*
name|ignored
parameter_list|)
block|{
name|yylineno
operator|=
name|idp
operator|->
name|di_lineno
expr_stmt|;
name|xyerror
argument_list|(
name|D_PRAGMA_UNUSED
argument_list|,
literal|"unused #pragma %s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|idp
operator|->
name|di_iarg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dtrace_stmtdesc_t
modifier|*
name|dt_stmt_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_ecbdesc_t
modifier|*
name|edp
parameter_list|,
name|dtrace_attribute_t
name|descattr
parameter_list|,
name|dtrace_attribute_t
name|stmtattr
parameter_list|)
block|{
name|dtrace_stmtdesc_t
modifier|*
name|sdp
init|=
name|dtrace_stmt_create
argument_list|(
name|dtp
argument_list|,
name|edp
argument_list|)
decl_stmt|;
if|if
condition|(
name|sdp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|yypcb
operator|->
name|pcb_stmt
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|yypcb
operator|->
name|pcb_stmt
operator|=
name|sdp
expr_stmt|;
name|sdp
operator|->
name|dtsd_descattr
operator|=
name|descattr
expr_stmt|;
name|sdp
operator|->
name|dtsd_stmtattr
operator|=
name|stmtattr
expr_stmt|;
return|return
operator|(
name|sdp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dtrace_actdesc_t
modifier|*
name|dt_stmt_action
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|dtrace_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility function to determine if a given action description is destructive.  * The dtdo_destructive bit is set for us by the DIF assembler (see dt_as.c).  */
end_comment

begin_function
specifier|static
name|int
name|dt_action_destructive
parameter_list|(
specifier|const
name|dtrace_actdesc_t
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|DTRACEACT_ISDESTRUCTIVE
argument_list|(
name|ap
operator|->
name|dtad_kind
argument_list|)
operator|||
operator|(
name|ap
operator|->
name|dtad_kind
operator|==
name|DTRACEACT_DIFEXPR
operator|&&
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_destructive
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_stmt_append
parameter_list|(
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|,
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dtrace_ecbdesc_t
modifier|*
name|edp
init|=
name|sdp
operator|->
name|dtsd_ecbdesc
decl_stmt|;
name|dtrace_actdesc_t
modifier|*
name|ap
decl_stmt|,
modifier|*
name|tap
decl_stmt|;
name|int
name|commit
init|=
literal|0
decl_stmt|;
name|int
name|speculate
init|=
literal|0
decl_stmt|;
name|int
name|datarec
init|=
literal|0
decl_stmt|;
comment|/* 	 * Make sure that the new statement jibes with the rest of the ECB. 	 */
for|for
control|(
name|ap
operator|=
name|edp
operator|->
name|dted_action
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|dtad_next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|dtad_kind
operator|==
name|DTRACEACT_COMMIT
condition|)
block|{
if|if
condition|(
name|commit
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_COMM_COMM
argument_list|,
literal|"commit( ) may "
literal|"not follow commit( )\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|datarec
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_COMM_DREC
argument_list|,
literal|"commit( ) may "
literal|"not follow data-recording action(s)\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tap
operator|=
name|ap
init|;
name|tap
operator|!=
name|NULL
condition|;
name|tap
operator|=
name|tap
operator|->
name|dtad_next
control|)
block|{
if|if
condition|(
operator|!
name|DTRACEACT_ISAGG
argument_list|(
name|tap
operator|->
name|dtad_kind
argument_list|)
condition|)
continue|continue;
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_AGG_COMM
argument_list|,
literal|"aggregating actions "
literal|"may not follow commit( )\n"
argument_list|)
expr_stmt|;
block|}
name|commit
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ap
operator|->
name|dtad_kind
operator|==
name|DTRACEACT_SPECULATE
condition|)
block|{
if|if
condition|(
name|speculate
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_SPEC_SPEC
argument_list|,
literal|"speculate( ) may "
literal|"not follow speculate( )\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commit
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_SPEC_COMM
argument_list|,
literal|"speculate( ) may "
literal|"not follow commit( )\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|datarec
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_SPEC_DREC
argument_list|,
literal|"speculate( ) may "
literal|"not follow data-recording action(s)\n"
argument_list|)
expr_stmt|;
block|}
name|speculate
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|DTRACEACT_ISAGG
argument_list|(
name|ap
operator|->
name|dtad_kind
argument_list|)
condition|)
block|{
if|if
condition|(
name|speculate
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_AGG_SPEC
argument_list|,
literal|"aggregating actions "
literal|"may not follow speculate( )\n"
argument_list|)
expr_stmt|;
block|}
name|datarec
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|speculate
condition|)
block|{
if|if
condition|(
name|dt_action_destructive
argument_list|(
name|ap
argument_list|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_ACT_SPEC
argument_list|,
literal|"destructive actions "
literal|"may not follow speculate( )\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|dtad_kind
operator|==
name|DTRACEACT_EXIT
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_EXIT_SPEC
argument_list|,
literal|"exit( ) may not "
literal|"follow speculate( )\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Exclude all non data-recording actions. 		 */
if|if
condition|(
name|dt_action_destructive
argument_list|(
name|ap
argument_list|)
operator|||
name|ap
operator|->
name|dtad_kind
operator|==
name|DTRACEACT_DISCARD
condition|)
continue|continue;
if|if
condition|(
name|ap
operator|->
name|dtad_kind
operator|==
name|DTRACEACT_DIFEXPR
operator|&&
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|.
name|dtdt_kind
operator|==
name|DIF_TYPE_CTF
operator|&&
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|commit
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_DREC_COMM
argument_list|,
literal|"data-recording actions "
literal|"may not follow commit( )\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|speculate
condition|)
name|datarec
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_stmt_add
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|,
name|yypcb
operator|->
name|pcb_prog
argument_list|,
name|sdp
argument_list|)
operator|!=
literal|0
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|dtrace_errno
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yypcb
operator|->
name|pcb_stmt
operator|==
name|sdp
condition|)
name|yypcb
operator|->
name|pcb_stmt
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For the first element of an aggregation tuple or for printa(), we create a  * simple DIF program that simply returns the immediate value that is the ID  * of the aggregation itself.  This could be optimized in the future by  * creating a new in-kernel dtad_kind that just returns an integer.  */
end_comment

begin_function
specifier|static
name|void
name|dt_action_difconst
parameter_list|(
name|dtrace_actdesc_t
modifier|*
name|ap
parameter_list|,
name|uint_t
name|id
parameter_list|,
name|dtrace_actkind_t
name|kind
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dtrace_difo_t
modifier|*
name|dp
init|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_difo_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dtdo_buf
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dif_instr_t
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dtdo_inttab
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dtdo_buf
operator|==
name|NULL
operator|||
name|dp
operator|->
name|dtdo_inttab
operator|==
name|NULL
condition|)
block|{
name|dt_difo_free
argument_list|(
name|dtp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
block|}
name|dp
operator|->
name|dtdo_buf
index|[
literal|0
index|]
operator|=
name|DIF_INSTR_SETX
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* setx	DIF_INTEGER[0], %r1 */
name|dp
operator|->
name|dtdo_buf
index|[
literal|1
index|]
operator|=
name|DIF_INSTR_RET
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* ret	%r1 */
name|dp
operator|->
name|dtdo_len
operator|=
literal|2
expr_stmt|;
name|dp
operator|->
name|dtdo_inttab
index|[
literal|0
index|]
operator|=
name|id
expr_stmt|;
name|dp
operator|->
name|dtdo_intlen
operator|=
literal|1
expr_stmt|;
name|dp
operator|->
name|dtdo_rtype
operator|=
name|dt_int_rtype
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dp
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|kind
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_clear
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|aid
decl_stmt|;
name|dtrace_actdesc_t
modifier|*
name|ap
decl_stmt|;
name|dt_node_t
modifier|*
name|anp
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|anp
operator|=
name|dnp
operator|->
name|dn_args
init|;
name|anp
operator|!=
name|NULL
condition|;
name|anp
operator|=
name|anp
operator|->
name|dn_list
control|)
name|argc
operator|++
expr_stmt|;
comment|/* count up arguments for error messages below */
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_CLEAR_PROTO
argument_list|,
literal|"%s( ) prototype mismatch: %d args passed, 1 expected\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|argc
argument_list|)
expr_stmt|;
block|}
name|anp
operator|=
name|dnp
operator|->
name|dn_args
expr_stmt|;
name|assert
argument_list|(
name|anp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|anp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_AGG
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_CLEAR_AGGARG
argument_list|,
literal|"%s( ) argument #1 is incompatible with prototype:\n"
literal|"\tprototype: aggregation\n\t argument: %s\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|dt_node_type_name
argument_list|(
name|anp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|aid
operator|=
name|anp
operator|->
name|dn_ident
expr_stmt|;
if|if
condition|(
name|aid
operator|->
name|di_gen
operator|==
name|dtp
operator|->
name|dt_gen
operator|&&
operator|!
operator|(
name|aid
operator|->
name|di_flags
operator|&
name|DT_IDFLG_MOD
operator|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_CLEAR_AGGBAD
argument_list|,
literal|"undefined aggregation: @%s\n"
argument_list|,
name|aid
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
name|dt_action_difconst
argument_list|(
name|ap
argument_list|,
name|anp
operator|->
name|dn_ident
operator|->
name|di_id
argument_list|,
name|DTRACEACT_LIBACT
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_arg
operator|=
name|DT_ACT_CLEAR
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_normalize
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|aid
decl_stmt|;
name|dtrace_actdesc_t
modifier|*
name|ap
decl_stmt|;
name|dt_node_t
modifier|*
name|anp
decl_stmt|,
modifier|*
name|normal
decl_stmt|;
name|int
name|denormal
init|=
operator|(
name|strcmp
argument_list|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
literal|"denormalize"
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|anp
operator|=
name|dnp
operator|->
name|dn_args
init|;
name|anp
operator|!=
name|NULL
condition|;
name|anp
operator|=
name|anp
operator|->
name|dn_list
control|)
name|argc
operator|++
expr_stmt|;
comment|/* count up arguments for error messages below */
if|if
condition|(
operator|(
name|denormal
operator|&&
name|argc
operator|!=
literal|1
operator|)
operator|||
operator|(
operator|!
name|denormal
operator|&&
name|argc
operator|!=
literal|2
operator|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_NORMALIZE_PROTO
argument_list|,
literal|"%s( ) prototype mismatch: %d args passed, %d expected\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|argc
argument_list|,
name|denormal
condition|?
literal|1
else|:
literal|2
argument_list|)
expr_stmt|;
block|}
name|anp
operator|=
name|dnp
operator|->
name|dn_args
expr_stmt|;
name|assert
argument_list|(
name|anp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|anp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_AGG
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_NORMALIZE_AGGARG
argument_list|,
literal|"%s( ) argument #1 is incompatible with prototype:\n"
literal|"\tprototype: aggregation\n\t argument: %s\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|dt_node_type_name
argument_list|(
name|anp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|normal
operator|=
name|anp
operator|->
name|dn_list
operator|)
operator|!=
name|NULL
operator|&&
operator|!
name|dt_node_is_scalar
argument_list|(
name|normal
argument_list|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_NORMALIZE_SCALAR
argument_list|,
literal|"%s( ) argument #2 must be of scalar type\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
name|aid
operator|=
name|anp
operator|->
name|dn_ident
expr_stmt|;
if|if
condition|(
name|aid
operator|->
name|di_gen
operator|==
name|dtp
operator|->
name|dt_gen
operator|&&
operator|!
operator|(
name|aid
operator|->
name|di_flags
operator|&
name|DT_IDFLG_MOD
operator|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_NORMALIZE_AGGBAD
argument_list|,
literal|"undefined aggregation: @%s\n"
argument_list|,
name|aid
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
name|dt_action_difconst
argument_list|(
name|ap
argument_list|,
name|anp
operator|->
name|dn_ident
operator|->
name|di_id
argument_list|,
name|DTRACEACT_LIBACT
argument_list|)
expr_stmt|;
if|if
condition|(
name|denormal
condition|)
block|{
name|ap
operator|->
name|dtad_arg
operator|=
name|DT_ACT_DENORMALIZE
expr_stmt|;
return|return;
block|}
name|ap
operator|->
name|dtad_arg
operator|=
name|DT_ACT_NORMALIZE
expr_stmt|;
name|assert
argument_list|(
name|normal
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|normal
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_LIBACT
expr_stmt|;
name|ap
operator|->
name|dtad_arg
operator|=
name|DT_ACT_NORMALIZE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_trunc
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|aid
decl_stmt|;
name|dtrace_actdesc_t
modifier|*
name|ap
decl_stmt|;
name|dt_node_t
modifier|*
name|anp
decl_stmt|,
modifier|*
name|trunc
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|anp
operator|=
name|dnp
operator|->
name|dn_args
init|;
name|anp
operator|!=
name|NULL
condition|;
name|anp
operator|=
name|anp
operator|->
name|dn_list
control|)
name|argc
operator|++
expr_stmt|;
comment|/* count up arguments for error messages below */
if|if
condition|(
name|argc
operator|>
literal|2
operator|||
name|argc
operator|<
literal|1
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_TRUNC_PROTO
argument_list|,
literal|"%s( ) prototype mismatch: %d args passed, %s expected\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|argc
argument_list|,
name|argc
operator|<
literal|1
condition|?
literal|"at least 1"
else|:
literal|"no more than 2"
argument_list|)
expr_stmt|;
block|}
name|anp
operator|=
name|dnp
operator|->
name|dn_args
expr_stmt|;
name|assert
argument_list|(
name|anp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|trunc
operator|=
name|anp
operator|->
name|dn_list
expr_stmt|;
if|if
condition|(
name|anp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_AGG
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_TRUNC_AGGARG
argument_list|,
literal|"%s( ) argument #1 is incompatible with prototype:\n"
literal|"\tprototype: aggregation\n\t argument: %s\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|dt_node_type_name
argument_list|(
name|anp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|assert
argument_list|(
name|trunc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dt_node_is_scalar
argument_list|(
name|trunc
argument_list|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_TRUNC_SCALAR
argument_list|,
literal|"%s( ) argument #2 must be of scalar type\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
block|}
name|aid
operator|=
name|anp
operator|->
name|dn_ident
expr_stmt|;
if|if
condition|(
name|aid
operator|->
name|di_gen
operator|==
name|dtp
operator|->
name|dt_gen
operator|&&
operator|!
operator|(
name|aid
operator|->
name|di_flags
operator|&
name|DT_IDFLG_MOD
operator|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_TRUNC_AGGBAD
argument_list|,
literal|"undefined aggregation: @%s\n"
argument_list|,
name|aid
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
name|dt_action_difconst
argument_list|(
name|ap
argument_list|,
name|anp
operator|->
name|dn_ident
operator|->
name|di_id
argument_list|,
name|DTRACEACT_LIBACT
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_arg
operator|=
name|DT_ACT_TRUNC
expr_stmt|;
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|dt_action_difconst
argument_list|(
name|ap
argument_list|,
literal|0
argument_list|,
name|DTRACEACT_LIBACT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|trunc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|trunc
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_LIBACT
expr_stmt|;
block|}
name|ap
operator|->
name|dtad_arg
operator|=
name|DT_ACT_TRUNC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_printa
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|aid
decl_stmt|,
modifier|*
name|fid
decl_stmt|;
name|dtrace_actdesc_t
modifier|*
name|ap
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|dt_node_t
modifier|*
name|anp
decl_stmt|,
modifier|*
name|proto
init|=
name|NULL
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|,
name|argr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|anp
operator|=
name|dnp
operator|->
name|dn_args
init|;
name|anp
operator|!=
name|NULL
condition|;
name|anp
operator|=
name|anp
operator|->
name|dn_list
control|)
name|argc
operator|++
expr_stmt|;
comment|/* count up arguments for error messages below */
switch|switch
condition|(
name|dnp
operator|->
name|dn_args
operator|->
name|dn_kind
condition|)
block|{
case|case
name|DT_NODE_STRING
case|:
name|format
operator|=
name|dnp
operator|->
name|dn_args
operator|->
name|dn_string
expr_stmt|;
name|anp
operator|=
name|dnp
operator|->
name|dn_args
operator|->
name|dn_list
expr_stmt|;
name|argr
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|DT_NODE_AGG
case|:
name|format
operator|=
name|NULL
expr_stmt|;
name|anp
operator|=
name|dnp
operator|->
name|dn_args
expr_stmt|;
name|argr
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|format
operator|=
name|NULL
expr_stmt|;
name|anp
operator|=
name|dnp
operator|->
name|dn_args
expr_stmt|;
name|argr
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
name|argr
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_PRINTA_PROTO
argument_list|,
literal|"%s( ) prototype mismatch: %d args passed, %d expected\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|argc
argument_list|,
name|argr
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|anp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|anp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|anp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_AGG
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_PRINTA_AGGARG
argument_list|,
literal|"%s( ) argument #%d is incompatible with "
literal|"prototype:\n\tprototype: aggregation\n"
literal|"\t argument: %s\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|argr
argument_list|,
name|dt_node_type_name
argument_list|(
name|anp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|aid
operator|=
name|anp
operator|->
name|dn_ident
expr_stmt|;
name|fid
operator|=
name|aid
operator|->
name|di_iarg
expr_stmt|;
if|if
condition|(
name|aid
operator|->
name|di_gen
operator|==
name|dtp
operator|->
name|dt_gen
operator|&&
operator|!
operator|(
name|aid
operator|->
name|di_flags
operator|&
name|DT_IDFLG_MOD
operator|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_PRINTA_AGGBAD
argument_list|,
literal|"undefined aggregation: @%s\n"
argument_list|,
name|aid
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we have multiple aggregations, we must be sure that 		 * their key signatures match. 		 */
if|if
condition|(
name|proto
operator|!=
name|NULL
condition|)
block|{
name|dt_printa_validate
argument_list|(
name|proto
argument_list|,
name|anp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proto
operator|=
name|anp
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|!=
name|NULL
condition|)
block|{
name|yylineno
operator|=
name|dnp
operator|->
name|dn_line
expr_stmt|;
name|sdp
operator|->
name|dtsd_fmtdata
operator|=
name|dt_printf_create
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|dt_printf_validate
argument_list|(
name|sdp
operator|->
name|dtsd_fmtdata
argument_list|,
name|DT_PRINTF_AGGREGATION
argument_list|,
name|dnp
operator|->
name|dn_ident
argument_list|,
literal|1
argument_list|,
name|fid
operator|->
name|di_id
argument_list|,
operator|(
operator|(
name|dt_idsig_t
operator|*
operator|)
name|aid
operator|->
name|di_data
operator|)
operator|->
name|dis_args
argument_list|)
expr_stmt|;
name|format
operator|=
name|NULL
expr_stmt|;
block|}
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
name|dt_action_difconst
argument_list|(
name|ap
argument_list|,
name|anp
operator|->
name|dn_ident
operator|->
name|di_id
argument_list|,
name|DTRACEACT_PRINTA
argument_list|)
expr_stmt|;
name|anp
operator|=
name|anp
operator|->
name|dn_list
expr_stmt|;
name|argr
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_printflike
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|,
name|dtrace_actkind_t
name|kind
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|anp
decl_stmt|,
modifier|*
name|arg1
decl_stmt|;
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|NULL
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|assert
argument_list|(
name|DTRACEACT_ISPRINTFLIKE
argument_list|(
name|kind
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_args
operator|->
name|dn_kind
operator|!=
name|DT_NODE_STRING
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_PRINTF_ARG_FMT
argument_list|,
literal|"%s( ) argument #1 is incompatible with prototype:\n"
literal|"\tprototype: string constant\n\t argument: %s\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|dt_node_type_name
argument_list|(
name|dnp
operator|->
name|dn_args
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arg1
operator|=
name|dnp
operator|->
name|dn_args
operator|->
name|dn_list
expr_stmt|;
name|yylineno
operator|=
name|dnp
operator|->
name|dn_line
expr_stmt|;
name|str
operator|=
name|dnp
operator|->
name|dn_args
operator|->
name|dn_string
expr_stmt|;
comment|/* 	 * If this is an freopen(), we use an empty string to denote that 	 * stdout should be restored.  For other printf()-like actions, an 	 * empty format string is illegal:  an empty format string would 	 * result in malformed DOF, and the compiler thus flags an empty 	 * format string as a compile-time error.  To avoid propagating the 	 * freopen() special case throughout the system, we simply transpose 	 * an empty string into a sentinel string (DT_FREOPEN_RESTORE) that 	 * denotes that stdout should be restored. 	 */
if|if
condition|(
name|kind
operator|==
name|DTRACEACT_FREOPEN
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|DT_FREOPEN_RESTORE
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Our sentinel is always an invalid argument to 			 * freopen(), but if it's been manually specified, we 			 * must fail now instead of when the freopen() is 			 * actually evaluated. 			 */
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_FREOPEN_INVALID
argument_list|,
literal|"%s( ) argument #1 cannot be \"%s\"\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|DT_FREOPEN_RESTORE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|str
operator|=
name|DT_FREOPEN_RESTORE
expr_stmt|;
block|}
name|sdp
operator|->
name|dtsd_fmtdata
operator|=
name|dt_printf_create
argument_list|(
name|dtp
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|dt_printf_validate
argument_list|(
name|sdp
operator|->
name|dtsd_fmtdata
argument_list|,
name|DT_PRINTF_EXACTLEN
argument_list|,
name|dnp
operator|->
name|dn_ident
argument_list|,
literal|1
argument_list|,
name|DTRACEACT_AGGREGATION
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|==
name|NULL
condition|)
block|{
name|dif_instr_t
modifier|*
name|dbuf
decl_stmt|;
name|dtrace_difo_t
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dbuf
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dif_instr_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|dp
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_difo_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
block|}
name|dbuf
index|[
literal|0
index|]
operator|=
name|DIF_INSTR_RET
argument_list|(
name|DIF_REG_R0
argument_list|)
expr_stmt|;
comment|/* ret %r0 */
name|dp
operator|->
name|dtdo_buf
operator|=
name|dbuf
expr_stmt|;
name|dp
operator|->
name|dtdo_len
operator|=
literal|1
expr_stmt|;
name|dp
operator|->
name|dtdo_rtype
operator|=
name|dt_int_rtype
expr_stmt|;
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dp
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|kind
expr_stmt|;
return|return;
block|}
for|for
control|(
name|anp
operator|=
name|arg1
init|;
name|anp
operator|!=
name|NULL
condition|;
name|anp
operator|=
name|anp
operator|->
name|dn_list
control|)
block|{
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|anp
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|kind
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_trace
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|int
name|ctflib
decl_stmt|;
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|boolean_t
name|istrace
init|=
operator|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
operator|==
name|DT_ACT_TRACE
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|act
init|=
name|istrace
condition|?
literal|"trace"
else|:
literal|"print"
decl_stmt|;
if|if
condition|(
name|dt_node_is_void
argument_list|(
name|dnp
operator|->
name|dn_args
argument_list|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
operator|->
name|dn_args
argument_list|,
name|istrace
condition|?
name|D_TRACE_VOID
else|:
name|D_PRINT_VOID
argument_list|,
literal|"%s( ) may not be applied to a void expression\n"
argument_list|,
name|act
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_node_resolve
argument_list|(
name|dnp
operator|->
name|dn_args
argument_list|,
name|DT_IDENT_XLPTR
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
operator|->
name|dn_args
argument_list|,
name|istrace
condition|?
name|D_TRACE_DYN
else|:
name|D_PRINT_DYN
argument_list|,
literal|"%s( ) may not be applied to a translated pointer\n"
argument_list|,
name|act
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dnp
operator|->
name|dn_args
operator|->
name|dn_kind
operator|==
name|DT_NODE_AGG
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
operator|->
name|dn_args
argument_list|,
name|istrace
condition|?
name|D_TRACE_AGG
else|:
name|D_PRINT_AGG
argument_list|,
literal|"%s( ) may not be applied to an aggregation%s\n"
argument_list|,
name|act
argument_list|,
name|istrace
condition|?
literal|""
else|:
literal|" -- did you mean printa()?"
argument_list|)
expr_stmt|;
block|}
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|dnp
operator|->
name|dn_args
argument_list|)
expr_stmt|;
comment|/* 	 * The print() action behaves identically to trace(), except that it 	 * stores the CTF type of the argument (if present) within the DOF for 	 * the DIFEXPR action.  To do this, we set the 'dtsd_strdata' to point 	 * to the fully-qualified CTF type ID for the result of the DIF 	 * action.  We use the ID instead of the name to handles complex types 	 * like arrays and function pointers that can't be resolved by 	 * ctf_type_lookup().  This is later processed by dtrace_dof_create() 	 * and turned into a reference into the string table so that we can 	 * get the type information when we process the data after the fact.  In 	 * the case where we are referring to userland CTF data, we also need to 	 * to identify which ctf container in question we care about and encode 	 * that within the name. 	 */
if|if
condition|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
operator|==
name|DT_ACT_PRINT
condition|)
block|{
name|dt_node_t
modifier|*
name|dret
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
name|dret
operator|=
name|yypcb
operator|->
name|pcb_dret
expr_stmt|;
name|dmp
operator|=
name|dt_module_lookup_by_ctf
argument_list|(
name|dtp
argument_list|,
name|dret
operator|->
name|dn_ctfp
argument_list|)
expr_stmt|;
name|n
operator|=
name|snprintf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|"%s`%ld"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
name|dret
operator|->
name|dn_type
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_pid
operator|!=
literal|0
condition|)
block|{
name|ctflib
operator|=
name|dt_module_getlibid
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|,
name|dret
operator|->
name|dn_ctfp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ctflib
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|snprintf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|"%s`%d`%ld"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
name|ctflib
argument_list|,
name|dret
operator|->
name|dn_type
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|snprintf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|"%s`%ld"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
name|dret
operator|->
name|dn_type
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|sdp
operator|->
name|dtsd_strdata
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdp
operator|->
name|dtsd_strdata
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|sdp
operator|->
name|dtsd_strdata
argument_list|,
name|n
argument_list|,
literal|"%s`%ld"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
name|dret
operator|->
name|dn_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_pid
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|sdp
operator|->
name|dtsd_strdata
argument_list|,
name|n
argument_list|,
literal|"%s`%d`%ld"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
name|ctflib
argument_list|,
name|dret
operator|->
name|dn_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|sdp
operator|->
name|dtsd_strdata
argument_list|,
name|n
argument_list|,
literal|"%s`%ld"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
name|dret
operator|->
name|dn_type
argument_list|)
expr_stmt|;
block|}
block|}
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_DIFEXPR
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_tracemem
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|dt_node_t
modifier|*
name|addr
init|=
name|dnp
operator|->
name|dn_args
decl_stmt|;
name|dt_node_t
modifier|*
name|max
init|=
name|dnp
operator|->
name|dn_args
operator|->
name|dn_list
decl_stmt|;
name|dt_node_t
modifier|*
name|size
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|dt_node_is_integer
argument_list|(
name|addr
argument_list|)
operator|==
literal|0
operator|&&
name|dt_node_is_pointer
argument_list|(
name|addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dnerror
argument_list|(
name|addr
argument_list|,
name|D_TRACEMEM_ADDR
argument_list|,
literal|"tracemem( ) argument #1 is incompatible with "
literal|"prototype:\n\tprototype: pointer or integer\n"
literal|"\t argument: %s\n"
argument_list|,
name|dt_node_type_name
argument_list|(
name|addr
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_node_is_posconst
argument_list|(
name|max
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dnerror
argument_list|(
name|max
argument_list|,
name|D_TRACEMEM_SIZE
argument_list|,
literal|"tracemem( ) argument #2 must "
literal|"be a non-zero positive integral constant expression\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
operator|=
name|max
operator|->
name|dn_list
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|size
operator|->
name|dn_list
operator|!=
name|NULL
condition|)
block|{
name|dnerror
argument_list|(
name|size
argument_list|,
name|D_TRACEMEM_ARGS
argument_list|,
literal|"tracemem ( ) prototype "
literal|"mismatch: expected at most 3 args\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dt_node_is_scalar
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|dnerror
argument_list|(
name|size
argument_list|,
name|D_TRACEMEM_DYNSIZE
argument_list|,
literal|"tracemem ( ) "
literal|"dynamic size (argument #3) must be of "
literal|"scalar type\n"
argument_list|)
expr_stmt|;
block|}
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|=
name|dt_int_rtype
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_TRACEMEM_DYNSIZE
expr_stmt|;
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
block|}
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_TRACEMEM
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|.
name|dtdt_flags
operator||=
name|DIF_TF_BYREF
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
operator|=
name|max
operator|->
name|dn_value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_stack_args
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_actdesc_t
modifier|*
name|ap
parameter_list|,
name|dt_node_t
modifier|*
name|arg0
parameter_list|)
block|{
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_STACK
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_STACKFRAMES
index|]
operator|!=
name|DTRACEOPT_UNSET
condition|)
block|{
name|ap
operator|->
name|dtad_arg
operator|=
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_STACKFRAMES
index|]
expr_stmt|;
block|}
else|else
block|{
name|ap
operator|->
name|dtad_arg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|arg0
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|arg0
operator|->
name|dn_list
operator|!=
name|NULL
condition|)
block|{
name|dnerror
argument_list|(
name|arg0
argument_list|,
name|D_STACK_PROTO
argument_list|,
literal|"stack( ) prototype "
literal|"mismatch: too many arguments\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_node_is_posconst
argument_list|(
name|arg0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dnerror
argument_list|(
name|arg0
argument_list|,
name|D_STACK_SIZE
argument_list|,
literal|"stack( ) size must be a "
literal|"non-zero positive integral constant expression\n"
argument_list|)
expr_stmt|;
block|}
name|ap
operator|->
name|dtad_arg
operator|=
name|arg0
operator|->
name|dn_value
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_stack
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|dt_action_stack_args
argument_list|(
name|dtp
argument_list|,
name|ap
argument_list|,
name|dnp
operator|->
name|dn_args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_ustack_args
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_actdesc_t
modifier|*
name|ap
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|uint32_t
name|nframes
init|=
literal|0
decl_stmt|;
name|uint32_t
name|strsize
init|=
literal|0
decl_stmt|;
comment|/* default string table size */
name|dt_node_t
modifier|*
name|arg0
init|=
name|dnp
operator|->
name|dn_args
decl_stmt|;
name|dt_node_t
modifier|*
name|arg1
init|=
name|arg0
operator|!=
name|NULL
condition|?
name|arg0
operator|->
name|dn_list
else|:
name|NULL
decl_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
operator|==
name|DT_ACT_JSTACK
operator|||
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
operator|==
name|DT_ACT_USTACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
operator|==
name|DT_ACT_JSTACK
condition|)
block|{
if|if
condition|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_JSTACKFRAMES
index|]
operator|!=
name|DTRACEOPT_UNSET
condition|)
name|nframes
operator|=
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_JSTACKFRAMES
index|]
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_JSTACKSTRSIZE
index|]
operator|!=
name|DTRACEOPT_UNSET
condition|)
name|strsize
operator|=
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_JSTACKSTRSIZE
index|]
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_JSTACK
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
operator|==
name|DT_ACT_USTACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_USTACKFRAMES
index|]
operator|!=
name|DTRACEOPT_UNSET
condition|)
name|nframes
operator|=
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_USTACKFRAMES
index|]
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_USTACK
expr_stmt|;
block|}
if|if
condition|(
name|arg0
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|dt_node_is_posconst
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
name|dnerror
argument_list|(
name|arg0
argument_list|,
name|D_USTACK_FRAMES
argument_list|,
literal|"ustack( ) argument #1 "
literal|"must be a non-zero positive integer constant\n"
argument_list|)
expr_stmt|;
block|}
name|nframes
operator|=
operator|(
name|uint32_t
operator|)
name|arg0
operator|->
name|dn_value
expr_stmt|;
block|}
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|arg1
operator|->
name|dn_kind
operator|!=
name|DT_NODE_INT
operator|||
operator|(
operator|(
name|arg1
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
operator|&&
operator|(
name|int64_t
operator|)
name|arg1
operator|->
name|dn_value
operator|<
literal|0
operator|)
condition|)
block|{
name|dnerror
argument_list|(
name|arg1
argument_list|,
name|D_USTACK_STRSIZE
argument_list|,
literal|"ustack( ) argument #2 "
literal|"must be a positive integer constant\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg1
operator|->
name|dn_list
operator|!=
name|NULL
condition|)
block|{
name|dnerror
argument_list|(
name|arg1
argument_list|,
name|D_USTACK_PROTO
argument_list|,
literal|"ustack( ) prototype "
literal|"mismatch: too many arguments\n"
argument_list|)
expr_stmt|;
block|}
name|strsize
operator|=
operator|(
name|uint32_t
operator|)
name|arg1
operator|->
name|dn_value
expr_stmt|;
block|}
name|ap
operator|->
name|dtad_arg
operator|=
name|DTRACE_USTACK_ARG
argument_list|(
name|nframes
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_ustack
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|dt_action_ustack_args
argument_list|(
name|dtp
argument_list|,
name|ap
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_setopt
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
decl_stmt|;
name|dt_node_t
modifier|*
name|arg0
decl_stmt|,
modifier|*
name|arg1
decl_stmt|;
comment|/* 	 * The prototype guarantees that we are called with either one or 	 * two arguments, and that any arguments that are present are strings. 	 */
name|arg0
operator|=
name|dnp
operator|->
name|dn_args
expr_stmt|;
name|arg1
operator|=
name|arg0
operator|->
name|dn_list
expr_stmt|;
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_LIBACT
expr_stmt|;
name|ap
operator|->
name|dtad_arg
operator|=
name|DT_ACT_SETOPT
expr_stmt|;
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|==
name|NULL
condition|)
block|{
name|dt_action_difconst
argument_list|(
name|ap
argument_list|,
literal|0
argument_list|,
name|DTRACEACT_LIBACT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_LIBACT
expr_stmt|;
block|}
name|ap
operator|->
name|dtad_arg
operator|=
name|DT_ACT_SETOPT
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dt_action_symmod_args
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_actdesc_t
modifier|*
name|ap
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_actkind_t
name|kind
parameter_list|)
block|{
name|assert
argument_list|(
name|kind
operator|==
name|DTRACEACT_SYM
operator|||
name|kind
operator|==
name|DTRACEACT_MOD
operator|||
name|kind
operator|==
name|DTRACEACT_USYM
operator|||
name|kind
operator|==
name|DTRACEACT_UMOD
operator|||
name|kind
operator|==
name|DTRACEACT_UADDR
argument_list|)
expr_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|kind
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_symmod
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|,
name|dtrace_actkind_t
name|kind
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|dt_action_symmod_args
argument_list|(
name|dtp
argument_list|,
name|ap
argument_list|,
name|dnp
operator|->
name|dn_args
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dt_action_ftruncate
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
comment|/* 	 * Library actions need a DIFO that serves as an argument.  As 	 * ftruncate() doesn't take an argument, we generate the constant 0 	 * in a DIFO; this constant will be ignored when the ftruncate() is 	 * processed. 	 */
name|dt_action_difconst
argument_list|(
name|ap
argument_list|,
literal|0
argument_list|,
name|DTRACEACT_LIBACT
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_arg
operator|=
name|DT_ACT_FTRUNCATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dt_action_stop
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_STOP
expr_stmt|;
name|ap
operator|->
name|dtad_arg
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dt_action_breakpoint
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_BREAKPOINT
expr_stmt|;
name|ap
operator|->
name|dtad_arg
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dt_action_panic
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_PANIC
expr_stmt|;
name|ap
operator|->
name|dtad_arg
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_chill
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|dnp
operator|->
name|dn_args
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_CHILL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_raise
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|dnp
operator|->
name|dn_args
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_RAISE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_exit
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|dnp
operator|->
name|dn_args
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_EXIT
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_speculate
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|dnp
operator|->
name|dn_args
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_SPECULATE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_printm
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|dt_node_t
modifier|*
name|size
init|=
name|dnp
operator|->
name|dn_args
decl_stmt|;
name|dt_node_t
modifier|*
name|addr
init|=
name|dnp
operator|->
name|dn_args
operator|->
name|dn_list
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|dt_node_is_posconst
argument_list|(
name|size
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dnerror
argument_list|(
name|size
argument_list|,
name|D_PRINTM_SIZE
argument_list|,
literal|"printm( ) argument #1 must "
literal|"be a non-zero positive integral constant expression\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_node_is_pointer
argument_list|(
name|addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dnerror
argument_list|(
name|addr
argument_list|,
name|D_PRINTM_ADDR
argument_list|,
literal|"printm( ) argument #2 is incompatible with "
literal|"prototype:\n\tprototype: pointer\n"
literal|"\t argument: %s\n"
argument_list|,
name|dt_node_type_name
argument_list|(
name|addr
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_PRINTM
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|.
name|dtdt_flags
operator||=
name|DIF_TF_BYREF
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
operator|=
name|size
operator|->
name|dn_value
operator|+
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_printt
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|dt_node_t
modifier|*
name|size
init|=
name|dnp
operator|->
name|dn_args
decl_stmt|;
name|dt_node_t
modifier|*
name|addr
init|=
name|dnp
operator|->
name|dn_args
operator|->
name|dn_list
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|dt_node_is_posconst
argument_list|(
name|size
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dnerror
argument_list|(
name|size
argument_list|,
name|D_PRINTT_SIZE
argument_list|,
literal|"printt( ) argument #1 must "
literal|"be a non-zero positive integral constant expression\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|==
name|NULL
operator|||
name|addr
operator|->
name|dn_kind
operator|!=
name|DT_NODE_FUNC
operator|||
name|addr
operator|->
name|dn_ident
operator|!=
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|,
literal|"typeref"
argument_list|)
condition|)
block|{
name|dnerror
argument_list|(
name|addr
argument_list|,
name|D_PRINTT_ADDR
argument_list|,
literal|"printt( ) argument #2 is incompatible with "
literal|"prototype:\n\tprototype: typeref()\n"
literal|"\t argument: %s\n"
argument_list|,
name|dt_node_type_name
argument_list|(
name|addr
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_PRINTT
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|.
name|dtdt_flags
operator||=
name|DIF_TF_BYREF
expr_stmt|;
comment|/* 	 * Allow additional buffer space for the data size, type size, 	 * type string length and a stab in the dark (32 bytes) for the 	 * type string. The type string is part of the typeref() that 	 * this action references. 	 */
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
operator|=
name|size
operator|->
name|dn_value
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|+
literal|32
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_commit
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|dnp
operator|->
name|dn_args
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_COMMIT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_action_discard
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|dnp
operator|->
name|dn_args
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_DISCARD
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_compile_fun
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
switch|switch
condition|(
name|dnp
operator|->
name|dn_expr
operator|->
name|dn_ident
operator|->
name|di_id
condition|)
block|{
case|case
name|DT_ACT_BREAKPOINT
case|:
name|dt_action_breakpoint
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_CHILL
case|:
name|dt_action_chill
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_CLEAR
case|:
name|dt_action_clear
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_COMMIT
case|:
name|dt_action_commit
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_DENORMALIZE
case|:
name|dt_action_normalize
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_DISCARD
case|:
name|dt_action_discard
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_EXIT
case|:
name|dt_action_exit
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_FREOPEN
case|:
name|dt_action_printflike
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|,
name|DTRACEACT_FREOPEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_FTRUNCATE
case|:
name|dt_action_ftruncate
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_MOD
case|:
name|dt_action_symmod
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|,
name|DTRACEACT_MOD
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_NORMALIZE
case|:
name|dt_action_normalize
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_PANIC
case|:
name|dt_action_panic
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_PRINT
case|:
name|dt_action_trace
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_PRINTA
case|:
name|dt_action_printa
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_PRINTF
case|:
name|dt_action_printflike
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|,
name|DTRACEACT_PRINTF
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_PRINTM
case|:
name|dt_action_printm
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_PRINTT
case|:
name|dt_action_printt
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_RAISE
case|:
name|dt_action_raise
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_SETOPT
case|:
name|dt_action_setopt
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_SPECULATE
case|:
name|dt_action_speculate
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_STACK
case|:
name|dt_action_stack
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_STOP
case|:
name|dt_action_stop
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_SYM
case|:
name|dt_action_symmod
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|,
name|DTRACEACT_SYM
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_SYSTEM
case|:
name|dt_action_printflike
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|,
name|DTRACEACT_SYSTEM
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_TRACE
case|:
name|dt_action_trace
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_TRACEMEM
case|:
name|dt_action_tracemem
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_TRUNC
case|:
name|dt_action_trunc
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_UADDR
case|:
name|dt_action_symmod
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|,
name|DTRACEACT_UADDR
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_UMOD
case|:
name|dt_action_symmod
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|,
name|DTRACEACT_UMOD
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_USYM
case|:
name|dt_action_symmod
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|,
name|DTRACEACT_USYM
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_ACT_USTACK
case|:
case|case
name|DT_ACT_JSTACK
case|:
name|dt_action_ustack
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dnerror
argument_list|(
name|dnp
operator|->
name|dn_expr
argument_list|,
name|D_UNKNOWN
argument_list|,
literal|"tracing function %s( ) is "
literal|"not yet supported\n"
argument_list|,
name|dnp
operator|->
name|dn_expr
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dt_compile_exp
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
decl_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|=
name|dt_void_rtype
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_DIFEXPR
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_compile_agg
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|aid
decl_stmt|,
modifier|*
name|fid
decl_stmt|;
name|dt_node_t
modifier|*
name|anp
decl_stmt|,
modifier|*
name|incr
init|=
name|NULL
decl_stmt|;
name|dtrace_actdesc_t
modifier|*
name|ap
decl_stmt|;
name|uint_t
name|n
init|=
literal|1
decl_stmt|,
name|argmax
decl_stmt|;
name|uint64_t
name|arg
init|=
literal|0
decl_stmt|;
comment|/* 	 * If the aggregation has no aggregating function applied to it, then 	 * this statement has no effect.  Flag this as a programming error. 	 */
if|if
condition|(
name|dnp
operator|->
name|dn_aggfun
operator|==
name|NULL
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_AGG_NULL
argument_list|,
literal|"expression has null effect: @%s\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
name|aid
operator|=
name|dnp
operator|->
name|dn_ident
expr_stmt|;
name|fid
operator|=
name|dnp
operator|->
name|dn_aggfun
operator|->
name|dn_ident
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_aggfun
operator|->
name|dn_args
operator|!=
name|NULL
operator|&&
name|dt_node_is_scalar
argument_list|(
name|dnp
operator|->
name|dn_aggfun
operator|->
name|dn_args
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
operator|->
name|dn_aggfun
argument_list|,
name|D_AGG_SCALAR
argument_list|,
literal|"%s( ) argument #1 must "
literal|"be of scalar type\n"
argument_list|,
name|fid
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The ID of the aggregation itself is implicitly recorded as the first 	 * member of each aggregation tuple so we can distinguish them later. 	 */
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
name|dt_action_difconst
argument_list|(
name|ap
argument_list|,
name|aid
operator|->
name|di_id
argument_list|,
name|DTRACEACT_DIFEXPR
argument_list|)
expr_stmt|;
for|for
control|(
name|anp
operator|=
name|dnp
operator|->
name|dn_aggtup
init|;
name|anp
operator|!=
name|NULL
condition|;
name|anp
operator|=
name|anp
operator|->
name|dn_list
control|)
block|{
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|anp
operator|->
name|dn_kind
operator|==
name|DT_NODE_FUNC
condition|)
block|{
if|if
condition|(
name|anp
operator|->
name|dn_ident
operator|->
name|di_id
operator|==
name|DT_ACT_STACK
condition|)
block|{
name|dt_action_stack_args
argument_list|(
name|dtp
argument_list|,
name|ap
argument_list|,
name|anp
operator|->
name|dn_args
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|anp
operator|->
name|dn_ident
operator|->
name|di_id
operator|==
name|DT_ACT_USTACK
operator|||
name|anp
operator|->
name|dn_ident
operator|->
name|di_id
operator|==
name|DT_ACT_JSTACK
condition|)
block|{
name|dt_action_ustack_args
argument_list|(
name|dtp
argument_list|,
name|ap
argument_list|,
name|anp
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|anp
operator|->
name|dn_ident
operator|->
name|di_id
condition|)
block|{
case|case
name|DT_ACT_UADDR
case|:
name|dt_action_symmod_args
argument_list|(
name|dtp
argument_list|,
name|ap
argument_list|,
name|anp
operator|->
name|dn_args
argument_list|,
name|DTRACEACT_UADDR
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DT_ACT_USYM
case|:
name|dt_action_symmod_args
argument_list|(
name|dtp
argument_list|,
name|ap
argument_list|,
name|anp
operator|->
name|dn_args
argument_list|,
name|DTRACEACT_USYM
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DT_ACT_UMOD
case|:
name|dt_action_symmod_args
argument_list|(
name|dtp
argument_list|,
name|ap
argument_list|,
name|anp
operator|->
name|dn_args
argument_list|,
name|DTRACEACT_UMOD
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DT_ACT_SYM
case|:
name|dt_action_symmod_args
argument_list|(
name|dtp
argument_list|,
name|ap
argument_list|,
name|anp
operator|->
name|dn_args
argument_list|,
name|DTRACEACT_SYM
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DT_ACT_MOD
case|:
name|dt_action_symmod_args
argument_list|(
name|dtp
argument_list|,
name|ap
argument_list|,
name|anp
operator|->
name|dn_args
argument_list|,
name|DTRACEACT_MOD
argument_list|)
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
block|}
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|anp
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_DIFEXPR
expr_stmt|;
block|}
if|if
condition|(
name|fid
operator|->
name|di_id
operator|==
name|DTRACEAGG_LQUANTIZE
condition|)
block|{
comment|/* 		 * For linear quantization, we have between two and four 		 * arguments in addition to the expression: 		 * 		 *    arg1 => Base value 		 *    arg2 => Limit value 		 *    arg3 => Quantization level step size (defaults to 1) 		 *    arg4 => Quantization increment value (defaults to 1) 		 */
name|dt_node_t
modifier|*
name|arg1
init|=
name|dnp
operator|->
name|dn_aggfun
operator|->
name|dn_args
operator|->
name|dn_list
decl_stmt|;
name|dt_node_t
modifier|*
name|arg2
init|=
name|arg1
operator|->
name|dn_list
decl_stmt|;
name|dt_node_t
modifier|*
name|arg3
init|=
name|arg2
operator|->
name|dn_list
decl_stmt|;
name|dt_idsig_t
modifier|*
name|isp
decl_stmt|;
name|uint64_t
name|nlevels
decl_stmt|,
name|step
init|=
literal|1
decl_stmt|,
name|oarg
decl_stmt|;
name|int64_t
name|baseval
decl_stmt|,
name|limitval
decl_stmt|;
if|if
condition|(
name|arg1
operator|->
name|dn_kind
operator|!=
name|DT_NODE_INT
condition|)
block|{
name|dnerror
argument_list|(
name|arg1
argument_list|,
name|D_LQUANT_BASETYPE
argument_list|,
literal|"lquantize( ) "
literal|"argument #1 must be an integer constant\n"
argument_list|)
expr_stmt|;
block|}
name|baseval
operator|=
operator|(
name|int64_t
operator|)
name|arg1
operator|->
name|dn_value
expr_stmt|;
if|if
condition|(
name|baseval
operator|<
name|INT32_MIN
operator|||
name|baseval
operator|>
name|INT32_MAX
condition|)
block|{
name|dnerror
argument_list|(
name|arg1
argument_list|,
name|D_LQUANT_BASEVAL
argument_list|,
literal|"lquantize( ) "
literal|"argument #1 must be a 32-bit quantity\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg2
operator|->
name|dn_kind
operator|!=
name|DT_NODE_INT
condition|)
block|{
name|dnerror
argument_list|(
name|arg2
argument_list|,
name|D_LQUANT_LIMTYPE
argument_list|,
literal|"lquantize( ) "
literal|"argument #2 must be an integer constant\n"
argument_list|)
expr_stmt|;
block|}
name|limitval
operator|=
operator|(
name|int64_t
operator|)
name|arg2
operator|->
name|dn_value
expr_stmt|;
if|if
condition|(
name|limitval
operator|<
name|INT32_MIN
operator|||
name|limitval
operator|>
name|INT32_MAX
condition|)
block|{
name|dnerror
argument_list|(
name|arg2
argument_list|,
name|D_LQUANT_LIMVAL
argument_list|,
literal|"lquantize( ) "
literal|"argument #2 must be a 32-bit quantity\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|limitval
operator|<
name|baseval
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_LQUANT_MISMATCH
argument_list|,
literal|"lquantize( ) base (argument #1) must be less "
literal|"than limit (argument #2)\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg3
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|dt_node_is_posconst
argument_list|(
name|arg3
argument_list|)
condition|)
block|{
name|dnerror
argument_list|(
name|arg3
argument_list|,
name|D_LQUANT_STEPTYPE
argument_list|,
literal|"lquantize( ) "
literal|"argument #3 must be a non-zero positive "
literal|"integer constant\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|step
operator|=
name|arg3
operator|->
name|dn_value
operator|)
operator|>
name|UINT16_MAX
condition|)
block|{
name|dnerror
argument_list|(
name|arg3
argument_list|,
name|D_LQUANT_STEPVAL
argument_list|,
literal|"lquantize( ) "
literal|"argument #3 must be a 16-bit quantity\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|nlevels
operator|=
operator|(
name|limitval
operator|-
name|baseval
operator|)
operator|/
name|step
expr_stmt|;
if|if
condition|(
name|nlevels
operator|==
literal|0
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_LQUANT_STEPLARGE
argument_list|,
literal|"lquantize( ) step (argument #3) too large: must "
literal|"have at least one quantization level\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nlevels
operator|>
name|UINT16_MAX
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_LQUANT_STEPSMALL
argument_list|,
literal|"lquantize( ) step "
literal|"(argument #3) too small: number of quantization "
literal|"levels must be a 16-bit quantity\n"
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
operator|(
name|step
operator|<<
name|DTRACE_LQUANTIZE_STEPSHIFT
operator|)
operator||
operator|(
name|nlevels
operator|<<
name|DTRACE_LQUANTIZE_LEVELSHIFT
operator|)
operator||
operator|(
operator|(
name|baseval
operator|<<
name|DTRACE_LQUANTIZE_BASESHIFT
operator|)
operator|&
name|DTRACE_LQUANTIZE_BASEMASK
operator|)
expr_stmt|;
name|assert
argument_list|(
name|arg
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|isp
operator|=
operator|(
name|dt_idsig_t
operator|*
operator|)
name|aid
operator|->
name|di_data
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|dis_auxinfo
operator|==
literal|0
condition|)
block|{
comment|/* 			 * This is the first time we've seen an lquantize() 			 * for this aggregation; we'll store our argument 			 * as the auxiliary signature information. 			 */
name|isp
operator|->
name|dis_auxinfo
operator|=
name|arg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|oarg
operator|=
name|isp
operator|->
name|dis_auxinfo
operator|)
operator|!=
name|arg
condition|)
block|{
comment|/* 			 * If we have seen this lquantize() before and the 			 * argument doesn't match the original argument, pick 			 * the original argument apart to concisely report the 			 * mismatch. 			 */
name|int
name|obaseval
init|=
name|DTRACE_LQUANTIZE_BASE
argument_list|(
name|oarg
argument_list|)
decl_stmt|;
name|int
name|onlevels
init|=
name|DTRACE_LQUANTIZE_LEVELS
argument_list|(
name|oarg
argument_list|)
decl_stmt|;
name|int
name|ostep
init|=
name|DTRACE_LQUANTIZE_STEP
argument_list|(
name|oarg
argument_list|)
decl_stmt|;
if|if
condition|(
name|obaseval
operator|!=
name|baseval
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_LQUANT_MATCHBASE
argument_list|,
literal|"lquantize( ) "
literal|"base (argument #1) doesn't match previous "
literal|"declaration: expected %d, found %d\n"
argument_list|,
name|obaseval
argument_list|,
operator|(
name|int
operator|)
name|baseval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|onlevels
operator|*
name|ostep
operator|!=
name|nlevels
operator|*
name|step
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_LQUANT_MATCHLIM
argument_list|,
literal|"lquantize( ) "
literal|"limit (argument #2) doesn't match previous"
literal|" declaration: expected %d, found %d\n"
argument_list|,
name|obaseval
operator|+
name|onlevels
operator|*
name|ostep
argument_list|,
operator|(
name|int
operator|)
name|baseval
operator|+
operator|(
name|int
operator|)
name|nlevels
operator|*
operator|(
name|int
operator|)
name|step
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ostep
operator|!=
name|step
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_LQUANT_MATCHSTEP
argument_list|,
literal|"lquantize( ) "
literal|"step (argument #3) doesn't match previous "
literal|"declaration: expected %d, found %d\n"
argument_list|,
name|ostep
argument_list|,
operator|(
name|int
operator|)
name|step
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * We shouldn't be able to get here -- one of the 			 * parameters must be mismatched if the arguments 			 * didn't match. 			 */
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|incr
operator|=
name|arg3
operator|!=
name|NULL
condition|?
name|arg3
operator|->
name|dn_list
else|:
name|NULL
expr_stmt|;
name|argmax
operator|=
literal|5
expr_stmt|;
block|}
if|if
condition|(
name|fid
operator|->
name|di_id
operator|==
name|DTRACEAGG_LLQUANTIZE
condition|)
block|{
comment|/* 		 * For log/linear quantizations, we have between one and five 		 * arguments in addition to the expression: 		 * 		 *    arg1 => Factor 		 *    arg2 => Low magnitude 		 *    arg3 => High magnitude 		 *    arg4 => Number of steps per magnitude 		 *    arg5 => Quantization increment value (defaults to 1) 		 */
name|dt_node_t
modifier|*
name|llarg
init|=
name|dnp
operator|->
name|dn_aggfun
operator|->
name|dn_args
operator|->
name|dn_list
decl_stmt|;
name|uint64_t
name|oarg
decl_stmt|,
name|order
decl_stmt|,
name|v
decl_stmt|;
name|dt_idsig_t
modifier|*
name|isp
decl_stmt|;
name|int
name|i
decl_stmt|;
struct|struct
block|{
name|char
modifier|*
name|str
decl_stmt|;
comment|/* string identifier */
name|int
name|badtype
decl_stmt|;
comment|/* error on bad type */
name|int
name|badval
decl_stmt|;
comment|/* error on bad value */
name|int
name|mismatch
decl_stmt|;
comment|/* error on bad match */
name|int
name|shift
decl_stmt|;
comment|/* shift value */
name|uint16_t
name|value
decl_stmt|;
comment|/* value itself */
block|}
name|args
index|[]
init|=
block|{
block|{
literal|"factor"
block|,
name|D_LLQUANT_FACTORTYPE
block|,
name|D_LLQUANT_FACTORVAL
block|,
name|D_LLQUANT_FACTORMATCH
block|,
name|DTRACE_LLQUANTIZE_FACTORSHIFT
block|}
block|,
block|{
literal|"low magnitude"
block|,
name|D_LLQUANT_LOWTYPE
block|,
name|D_LLQUANT_LOWVAL
block|,
name|D_LLQUANT_LOWMATCH
block|,
name|DTRACE_LLQUANTIZE_LOWSHIFT
block|}
block|,
block|{
literal|"high magnitude"
block|,
name|D_LLQUANT_HIGHTYPE
block|,
name|D_LLQUANT_HIGHVAL
block|,
name|D_LLQUANT_HIGHMATCH
block|,
name|DTRACE_LLQUANTIZE_HIGHSHIFT
block|}
block|,
block|{
literal|"linear steps per magnitude"
block|,
name|D_LLQUANT_NSTEPTYPE
block|,
name|D_LLQUANT_NSTEPVAL
block|,
name|D_LLQUANT_NSTEPMATCH
block|,
name|DTRACE_LLQUANTIZE_NSTEPSHIFT
block|}
block|,
block|{
name|NULL
block|}
block|}
struct|;
name|assert
argument_list|(
name|arg
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
index|[
name|i
index|]
operator|.
name|str
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|llarg
operator|->
name|dn_kind
operator|!=
name|DT_NODE_INT
condition|)
block|{
name|dnerror
argument_list|(
name|llarg
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|badtype
argument_list|,
literal|"llquantize( ) "
literal|"argument #%d (%s) must be an "
literal|"integer constant\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uint64_t
operator|)
name|llarg
operator|->
name|dn_value
operator|>
name|UINT16_MAX
condition|)
block|{
name|dnerror
argument_list|(
name|llarg
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|badval
argument_list|,
literal|"llquantize( ) "
literal|"argument #%d (%s) must be an unsigned "
literal|"16-bit quantity\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|args
index|[
name|i
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
block|}
name|args
index|[
name|i
index|]
operator|.
name|value
operator|=
operator|(
name|uint16_t
operator|)
name|llarg
operator|->
name|dn_value
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|arg
operator|&
operator|(
operator|(
name|uint64_t
operator|)
name|UINT16_MAX
operator|<<
name|args
index|[
name|i
index|]
operator|.
name|shift
operator|)
operator|)
argument_list|)
expr_stmt|;
name|arg
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|args
index|[
name|i
index|]
operator|.
name|value
operator|<<
name|args
index|[
name|i
index|]
operator|.
name|shift
operator|)
expr_stmt|;
name|llarg
operator|=
name|llarg
operator|->
name|dn_list
expr_stmt|;
block|}
name|assert
argument_list|(
name|arg
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|<
literal|2
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_LLQUANT_FACTORSMALL
argument_list|,
literal|"llquantize( ) "
literal|"factor (argument #1) must be two or more\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|.
name|value
operator|>=
name|args
index|[
literal|2
index|]
operator|.
name|value
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_LLQUANT_MAGRANGE
argument_list|,
literal|"llquantize( ) "
literal|"high magnitude (argument #3) must be greater "
literal|"than low magnitude (argument #2)\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|<
name|args
index|[
literal|0
index|]
operator|.
name|value
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_LLQUANT_FACTORNSTEPS
argument_list|,
literal|"llquantize( ) "
literal|"factor (argument #1) must be less than or "
literal|"equal to the number of linear steps per "
literal|"magnitude (argument #4)\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|v
operator|=
name|args
index|[
literal|0
index|]
operator|.
name|value
init|;
name|v
operator|<
name|args
index|[
literal|3
index|]
operator|.
name|value
condition|;
name|v
operator|*=
name|args
index|[
literal|0
index|]
operator|.
name|value
control|)
continue|continue;
if|if
condition|(
operator|(
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|%
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|)
operator|||
operator|(
name|v
operator|%
name|args
index|[
literal|3
index|]
operator|.
name|value
operator|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_LLQUANT_FACTOREVEN
argument_list|,
literal|"llquantize( ) "
literal|"factor (argument #1) must evenly divide the "
literal|"number of steps per magnitude (argument #4), "
literal|"and the number of steps per magnitude must evenly "
literal|"divide a power of the factor\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|order
operator|=
literal|1
init|;
name|i
operator|<
name|args
index|[
literal|2
index|]
operator|.
name|value
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|order
operator|*
name|args
index|[
literal|0
index|]
operator|.
name|value
operator|>
name|order
condition|)
block|{
name|order
operator|*=
name|args
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
continue|continue;
block|}
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_LLQUANT_MAGTOOBIG
argument_list|,
literal|"llquantize( ) "
literal|"factor (%d) raised to power of high magnitude "
literal|"(%d) overflows 64-bits\n"
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|value
argument_list|,
name|args
index|[
literal|2
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
name|isp
operator|=
operator|(
name|dt_idsig_t
operator|*
operator|)
name|aid
operator|->
name|di_data
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|dis_auxinfo
operator|==
literal|0
condition|)
block|{
comment|/* 			 * This is the first time we've seen an llquantize() 			 * for this aggregation; we'll store our argument 			 * as the auxiliary signature information. 			 */
name|isp
operator|->
name|dis_auxinfo
operator|=
name|arg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|oarg
operator|=
name|isp
operator|->
name|dis_auxinfo
operator|)
operator|!=
name|arg
condition|)
block|{
comment|/* 			 * If we have seen this llquantize() before and the 			 * argument doesn't match the original argument, pick 			 * the original argument apart to concisely report the 			 * mismatch. 			 */
name|int
name|expected
init|=
literal|0
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|expected
operator|==
name|found
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|str
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|expected
operator|=
operator|(
name|oarg
operator|>>
name|args
index|[
name|i
index|]
operator|.
name|shift
operator|)
operator|&
name|UINT16_MAX
expr_stmt|;
name|found
operator|=
operator|(
name|arg
operator|>>
name|args
index|[
name|i
index|]
operator|.
name|shift
operator|)
operator|&
name|UINT16_MAX
expr_stmt|;
block|}
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|args
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|mismatch
argument_list|,
literal|"llquantize( ) "
literal|"%s (argument #%d) doesn't match previous "
literal|"declaration: expected %d, found %d\n"
argument_list|,
name|args
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|str
argument_list|,
name|i
argument_list|,
name|expected
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
name|incr
operator|=
name|llarg
expr_stmt|;
name|argmax
operator|=
literal|6
expr_stmt|;
block|}
if|if
condition|(
name|fid
operator|->
name|di_id
operator|==
name|DTRACEAGG_QUANTIZE
condition|)
block|{
name|incr
operator|=
name|dnp
operator|->
name|dn_aggfun
operator|->
name|dn_args
operator|->
name|dn_list
expr_stmt|;
name|argmax
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|incr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|dt_node_is_scalar
argument_list|(
name|incr
argument_list|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_PROTO_ARG
argument_list|,
literal|"%s( ) increment value "
literal|"(argument #%d) must be of scalar type\n"
argument_list|,
name|fid
operator|->
name|di_name
argument_list|,
name|argmax
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|anp
operator|=
name|incr
operator|->
name|dn_list
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|argc
init|=
name|argmax
decl_stmt|;
for|for
control|(
init|;
name|anp
operator|!=
name|NULL
condition|;
name|anp
operator|=
name|anp
operator|->
name|dn_list
control|)
name|argc
operator|++
expr_stmt|;
name|dnerror
argument_list|(
name|incr
argument_list|,
name|D_PROTO_LEN
argument_list|,
literal|"%s( ) prototype "
literal|"mismatch: %d args passed, at most %d expected"
argument_list|,
name|fid
operator|->
name|di_name
argument_list|,
name|argc
argument_list|,
name|argmax
argument_list|)
expr_stmt|;
block|}
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|incr
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|=
name|dt_void_rtype
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|DTRACEACT_DIFEXPR
expr_stmt|;
block|}
name|assert
argument_list|(
name|sdp
operator|->
name|dtsd_aggdata
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|dtsd_aggdata
operator|=
name|aid
expr_stmt|;
name|ap
operator|=
name|dt_stmt_action
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fid
operator|->
name|di_kind
operator|==
name|DT_IDENT_AGGFUNC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|DTRACEACT_ISAGG
argument_list|(
name|fid
operator|->
name|di_id
argument_list|)
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_kind
operator|=
name|fid
operator|->
name|di_id
expr_stmt|;
name|ap
operator|->
name|dtad_ntuple
operator|=
name|n
expr_stmt|;
name|ap
operator|->
name|dtad_arg
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_aggfun
operator|->
name|dn_args
operator|!=
name|NULL
condition|)
block|{
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|dnp
operator|->
name|dn_aggfun
operator|->
name|dn_args
argument_list|)
expr_stmt|;
name|ap
operator|->
name|dtad_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dt_compile_one_clause
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|cnp
parameter_list|,
name|dt_node_t
modifier|*
name|pnp
parameter_list|)
block|{
name|dtrace_ecbdesc_t
modifier|*
name|edp
decl_stmt|;
name|dtrace_stmtdesc_t
modifier|*
name|sdp
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
name|yylineno
operator|=
name|pnp
operator|->
name|dn_line
expr_stmt|;
name|dt_setcontext
argument_list|(
name|dtp
argument_list|,
name|pnp
operator|->
name|dn_desc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_node_cook
argument_list|(
name|cnp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
if|if
condition|(
name|DT_TREEDUMP_PASS
argument_list|(
name|dtp
argument_list|,
literal|2
argument_list|)
condition|)
name|dt_node_printr
argument_list|(
name|cnp
argument_list|,
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|edp
operator|=
name|dt_ecbdesc_create
argument_list|(
name|dtp
argument_list|,
name|pnp
operator|->
name|dn_desc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|yypcb
operator|->
name|pcb_ecbdesc
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|yypcb
operator|->
name|pcb_ecbdesc
operator|=
name|edp
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|dn_pred
operator|!=
name|NULL
condition|)
block|{
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|cnp
operator|->
name|dn_pred
argument_list|)
expr_stmt|;
name|edp
operator|->
name|dted_pred
operator|.
name|dtpdd_difo
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cnp
operator|->
name|dn_acts
operator|==
name|NULL
condition|)
block|{
name|dt_stmt_append
argument_list|(
name|dt_stmt_create
argument_list|(
name|dtp
argument_list|,
name|edp
argument_list|,
name|cnp
operator|->
name|dn_ctxattr
argument_list|,
name|_dtrace_defattr
argument_list|)
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|dnp
operator|=
name|cnp
operator|->
name|dn_acts
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
control|)
block|{
name|assert
argument_list|(
name|yypcb
operator|->
name|pcb_stmt
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|sdp
operator|=
name|dt_stmt_create
argument_list|(
name|dtp
argument_list|,
name|edp
argument_list|,
name|cnp
operator|->
name|dn_ctxattr
argument_list|,
name|cnp
operator|->
name|dn_attr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dnp
operator|->
name|dn_kind
condition|)
block|{
case|case
name|DT_NODE_DEXPR
case|:
if|if
condition|(
name|dnp
operator|->
name|dn_expr
operator|->
name|dn_kind
operator|==
name|DT_NODE_AGG
condition|)
name|dt_compile_agg
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
else|else
name|dt_compile_exp
argument_list|(
name|dtp
argument_list|,
name|dnp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_DFUNC
case|:
name|dt_compile_fun
argument_list|(
name|dtp
argument_list|,
name|dnp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_AGG
case|:
name|dt_compile_agg
argument_list|(
name|dtp
argument_list|,
name|dnp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_UNKNOWN
argument_list|,
literal|"internal error -- node kind "
literal|"%u is not a valid statement\n"
argument_list|,
name|dnp
operator|->
name|dn_kind
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|yypcb
operator|->
name|pcb_stmt
operator|==
name|sdp
argument_list|)
expr_stmt|;
name|dt_stmt_append
argument_list|(
name|sdp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|yypcb
operator|->
name|pcb_ecbdesc
operator|==
name|edp
argument_list|)
expr_stmt|;
name|dt_ecbdesc_release
argument_list|(
name|dtp
argument_list|,
name|edp
argument_list|)
expr_stmt|;
name|dt_endcontext
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|yypcb
operator|->
name|pcb_ecbdesc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_compile_clause
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|cnp
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|pnp
decl_stmt|;
for|for
control|(
name|pnp
operator|=
name|cnp
operator|->
name|dn_pdescs
init|;
name|pnp
operator|!=
name|NULL
condition|;
name|pnp
operator|=
name|pnp
operator|->
name|dn_list
control|)
name|dt_compile_one_clause
argument_list|(
name|dtp
argument_list|,
name|cnp
argument_list|,
name|pnp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_compile_xlator
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dt_xlator_t
modifier|*
name|dxp
init|=
name|dnp
operator|->
name|dn_xlator
decl_stmt|;
name|dt_node_t
modifier|*
name|mnp
decl_stmt|;
for|for
control|(
name|mnp
operator|=
name|dnp
operator|->
name|dn_members
init|;
name|mnp
operator|!=
name|NULL
condition|;
name|mnp
operator|=
name|mnp
operator|->
name|dn_list
control|)
block|{
name|assert
argument_list|(
name|dxp
operator|->
name|dx_membdif
index|[
name|mnp
operator|->
name|dn_membid
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|mnp
argument_list|)
expr_stmt|;
name|dxp
operator|->
name|dx_membdif
index|[
name|mnp
operator|->
name|dn_membid
index|]
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dt_setcontext
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|)
block|{
specifier|const
name|dtrace_pattr_t
modifier|*
name|pap
decl_stmt|;
name|dt_probe_t
modifier|*
name|prp
decl_stmt|;
name|dt_provider_t
modifier|*
name|pvp
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|char
name|attrstr
index|[
literal|8
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Both kernel and pid based providers are allowed to have names 	 * ending with what could be interpreted as a number. We assume it's 	 * a pid and that we may need to dynamically create probes for 	 * that process if: 	 * 	 * (1) The provider doesn't exist, or, 	 * (2) The provider exists and has DTRACE_PRIV_PROC privilege. 	 * 	 * On an error, dt_pid_create_probes() will set the error message 	 * and tag -- we just have to longjmp() out of here. 	 */
if|if
condition|(
name|isdigit
argument_list|(
name|pdp
operator|->
name|dtpd_provider
index|[
name|strlen
argument_list|(
name|pdp
operator|->
name|dtpd_provider
argument_list|)
operator|-
literal|1
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|pvp
operator|=
name|dt_provider_lookup
argument_list|(
name|dtp
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_priv
operator|.
name|dtpp_flags
operator|&
name|DTRACE_PRIV_PROC
operator|)
operator|&&
name|dt_pid_create_probes
argument_list|(
name|pdp
argument_list|,
name|dtp
argument_list|,
name|yypcb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Call dt_probe_info() to get the probe arguments and attributes.  If 	 * a representative probe is found, set 'pap' to the probe provider's 	 * attributes.  Otherwise set 'pap' to default Unstable attributes. 	 */
if|if
condition|(
operator|(
name|prp
operator|=
name|dt_probe_info
argument_list|(
name|dtp
argument_list|,
name|pdp
argument_list|,
operator|&
name|yypcb
operator|->
name|pcb_pinfo
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pap
operator|=
operator|&
name|_dtrace_prvdesc
expr_stmt|;
name|err
operator|=
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|yypcb
operator|->
name|pcb_pinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_probeinfo_t
argument_list|)
argument_list|)
expr_stmt|;
name|yypcb
operator|->
name|pcb_pinfo
operator|.
name|dtp_attr
operator|=
name|pap
operator|->
name|dtpa_provider
expr_stmt|;
name|yypcb
operator|->
name|pcb_pinfo
operator|.
name|dtp_arga
operator|=
name|pap
operator|->
name|dtpa_args
expr_stmt|;
block|}
else|else
block|{
name|pap
operator|=
operator|&
name|prp
operator|->
name|pr_pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|EDT_NOPROBE
operator|&&
operator|!
operator|(
name|yypcb
operator|->
name|pcb_cflags
operator|&
name|DTRACE_C_ZDEFS
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_PDESC_ZERO
argument_list|,
literal|"probe description %s:%s:%s:%s does not "
literal|"match any probes\n"
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|,
name|pdp
operator|->
name|dtpd_mod
argument_list|,
name|pdp
operator|->
name|dtpd_func
argument_list|,
name|pdp
operator|->
name|dtpd_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
name|EDT_NOPROBE
operator|&&
name|err
operator|!=
name|EDT_UNSTABLE
operator|&&
name|err
operator|!=
literal|0
condition|)
name|xyerror
argument_list|(
name|D_PDESC_INVAL
argument_list|,
literal|"%s\n"
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"set context to %s:%s:%s:%s [%u] prp=%p attr=%s argc=%d\n"
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|,
name|pdp
operator|->
name|dtpd_mod
argument_list|,
name|pdp
operator|->
name|dtpd_func
argument_list|,
name|pdp
operator|->
name|dtpd_name
argument_list|,
name|pdp
operator|->
name|dtpd_id
argument_list|,
operator|(
name|void
operator|*
operator|)
name|prp
argument_list|,
name|dt_attr_str
argument_list|(
name|yypcb
operator|->
name|pcb_pinfo
operator|.
name|dtp_attr
argument_list|,
name|attrstr
argument_list|,
sizeof|sizeof
argument_list|(
name|attrstr
argument_list|)
argument_list|)
argument_list|,
name|yypcb
operator|->
name|pcb_pinfo
operator|.
name|dtp_argc
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the stability attributes of D global variables that vary 	 * based on the attributes of the provider and context itself. 	 */
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|,
literal|"probeprov"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|idp
operator|->
name|di_attr
operator|=
name|pap
operator|->
name|dtpa_provider
expr_stmt|;
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|,
literal|"probemod"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|idp
operator|->
name|di_attr
operator|=
name|pap
operator|->
name|dtpa_mod
expr_stmt|;
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|,
literal|"probefunc"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|idp
operator|->
name|di_attr
operator|=
name|pap
operator|->
name|dtpa_func
expr_stmt|;
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|,
literal|"probename"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|idp
operator|->
name|di_attr
operator|=
name|pap
operator|->
name|dtpa_name
expr_stmt|;
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|,
literal|"args"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|idp
operator|->
name|di_attr
operator|=
name|pap
operator|->
name|dtpa_args
expr_stmt|;
name|yypcb
operator|->
name|pcb_pdesc
operator|=
name|pdp
expr_stmt|;
name|yypcb
operator|->
name|pcb_probe
operator|=
name|prp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset context-dependent variables and state at the end of cooking a D probe  * definition clause.  This ensures that external declarations between clauses  * do not reference any stale context-dependent data from the previous clause.  */
end_comment

begin_function
name|void
name|dt_endcontext
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|cvars
index|[]
init|=
block|{
literal|"probeprov"
block|,
literal|"probemod"
block|,
literal|"probefunc"
block|,
literal|"probename"
block|,
literal|"args"
block|,
name|NULL
block|}
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cvars
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|,
name|cvars
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|idp
operator|->
name|di_attr
operator|=
name|_dtrace_defattr
expr_stmt|;
block|}
name|yypcb
operator|->
name|pcb_pdesc
operator|=
name|NULL
expr_stmt|;
name|yypcb
operator|->
name|pcb_probe
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_reduceid
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
if|if
condition|(
name|idp
operator|->
name|di_vers
operator|!=
literal|0
operator|&&
name|idp
operator|->
name|di_vers
operator|>
name|dtp
operator|->
name|dt_vmax
condition|)
name|dt_idhash_delete
argument_list|(
name|dhp
argument_list|,
name|idp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When dtrace_setopt() is called for "version", it calls dt_reduce() to remove  * any identifiers or translators that have been previously defined as bound to  * a version greater than the specified version.  Therefore, in our current  * version implementation, establishing a binding is a one-way transformation.  * In addition, no versioning is currently provided for types as our .d library  * files do not define any types and we reserve prefixes DTRACE_ and dtrace_  * for our exclusive use.  If required, type versioning will require more work.  */
end_comment

begin_function
name|int
name|dt_reduce
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_version_t
name|v
parameter_list|)
block|{
name|char
name|s
index|[
name|DT_VERSION_STRMAX
index|]
decl_stmt|;
name|dt_xlator_t
modifier|*
name|dxp
decl_stmt|,
modifier|*
name|nxp
decl_stmt|;
if|if
condition|(
name|v
operator|>
name|dtp
operator|->
name|dt_vmax
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_VERSREDUCED
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|v
operator|==
name|dtp
operator|->
name|dt_vmax
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no reduction necessary */
name|dt_dprintf
argument_list|(
literal|"reducing api version to %s\n"
argument_list|,
name|dt_version_num2str
argument_list|(
name|v
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_vmax
operator|=
name|v
expr_stmt|;
for|for
control|(
name|dxp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_xlators
argument_list|)
init|;
name|dxp
operator|!=
name|NULL
condition|;
name|dxp
operator|=
name|nxp
control|)
block|{
name|nxp
operator|=
name|dt_list_next
argument_list|(
name|dxp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dxp
operator|->
name|dx_souid
operator|.
name|di_vers
operator|!=
literal|0
operator|&&
name|dxp
operator|->
name|dx_souid
operator|.
name|di_vers
operator|>
name|v
operator|)
operator|||
operator|(
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_vers
operator|!=
literal|0
operator|&&
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_vers
operator|>
name|v
operator|)
condition|)
name|dt_list_delete
argument_list|(
operator|&
name|dtp
operator|->
name|dt_xlators
argument_list|,
name|dxp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dt_idhash_iter
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
operator|(
name|dt_idhash_f
operator|*
operator|)
name|dt_reduceid
argument_list|,
name|dtp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_idhash_iter
argument_list|(
name|dtp
operator|->
name|dt_aggs
argument_list|,
operator|(
name|dt_idhash_f
operator|*
operator|)
name|dt_reduceid
argument_list|,
name|dtp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_idhash_iter
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|,
operator|(
name|dt_idhash_f
operator|*
operator|)
name|dt_reduceid
argument_list|,
name|dtp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_idhash_iter
argument_list|(
name|dtp
operator|->
name|dt_tls
argument_list|,
operator|(
name|dt_idhash_f
operator|*
operator|)
name|dt_reduceid
argument_list|,
name|dtp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fork and exec the cpp(1) preprocessor to run over the specified input file,  * and return a FILE handle for the cpp output.  We use the /dev/fd filesystem  * here to simplify the code by leveraging file descriptor inheritance.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|dt_preproc
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|argc
init|=
name|dtp
operator|->
name|dt_cpp_argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|argc
operator|+
literal|5
operator|)
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|ofp
init|=
name|tmpfile
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|char
name|ipath
index|[
literal|20
index|]
decl_stmt|,
name|opath
index|[
literal|20
index|]
decl_stmt|;
comment|/* big enough for /dev/fd/ + INT_MAX + \0 */
endif|#
directive|endif
name|char
name|verdef
index|[
literal|32
index|]
decl_stmt|;
comment|/* big enough for -D__SUNW_D_VERSION=0x%08x + \0 */
name|struct
name|sigaction
name|act
decl_stmt|,
name|oact
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|,
name|omask
decl_stmt|;
name|int
name|wstat
decl_stmt|,
name|estat
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|off64_t
name|off
decl_stmt|;
else|#
directive|else
name|off_t
name|off
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|int
name|c
decl_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
operator|||
name|ofp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * If the input is a seekable file, see if it is an interpreter file. 	 * If we see #!, seek past the first line because cpp will choke on it. 	 * We start cpp just prior to the \n at the end of this line so that 	 * it still sees the newline, ensuring that #line values are correct. 	 */
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|ifp
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|off
operator|=
name|ftello64
argument_list|(
name|ifp
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|ifp
argument_list|)
operator|)
operator|==
literal|'#'
operator|&&
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|ifp
argument_list|)
operator|)
operator|==
literal|'!'
condition|)
block|{
for|for
control|(
name|off
operator|+=
literal|2
init|;
name|c
operator|!=
literal|'\n'
condition|;
name|off
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|ifp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|off
operator|--
expr_stmt|;
comment|/* start cpp just prior to \n */
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseeko64
argument_list|(
name|ifp
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|ipath
argument_list|,
sizeof|sizeof
argument_list|(
name|ipath
argument_list|)
argument_list|,
literal|"/dev/fd/%d"
argument_list|,
name|fileno
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|opath
argument_list|,
sizeof|sizeof
argument_list|(
name|opath
argument_list|)
argument_list|,
literal|"/dev/fd/%d"
argument_list|,
name|fileno
argument_list|(
name|ofp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
name|dtp
operator|->
name|dt_cpp_argv
argument_list|,
name|argv
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|argc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|verdef
argument_list|,
sizeof|sizeof
argument_list|(
name|verdef
argument_list|)
argument_list|,
literal|"-D__SUNW_D_VERSION=0x%08x"
argument_list|,
name|dtp
operator|->
name|dt_vmax
argument_list|)
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|verdef
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
switch|switch
condition|(
name|dtp
operator|->
name|dt_stdcmode
condition|)
block|{
case|case
name|DT_STDC_XA
case|:
case|case
name|DT_STDC_XT
case|:
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-D__STDC__=0"
expr_stmt|;
break|break;
case|case
name|DT_STDC_XC
case|:
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-D__STDC__=1"
expr_stmt|;
break|break;
block|}
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|ipath
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|opath
expr_stmt|;
else|#
directive|else
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-P"
expr_stmt|;
endif|#
directive|endif
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * libdtrace must be able to be embedded in other programs that may 	 * include application-specific signal handlers.  Therefore, if we 	 * need to fork to run cpp(1), we must avoid generating a SIGCHLD 	 * that could confuse the containing application.  To do this, 	 * we block SIGCHLD and reset its disposition to SIG_DFL. 	 * We restore our signal state once we are done. 	 */
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|mask
argument_list|,
operator|&
name|omask
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|act
argument_list|,
sizeof|sizeof
argument_list|(
name|act
argument_list|)
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|SIG_DFL
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|oact
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork1
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|oact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|omask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_CPPFORK
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|ifp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|lseek
argument_list|(
name|fileno
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fileno
argument_list|(
name|ifp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fileno
argument_list|(
name|ofp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|execvp
argument_list|(
name|dtp
operator|->
name|dt_cpp_path
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|errno
operator|==
name|ENOENT
condition|?
literal|127
else|:
literal|126
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|dt_dprintf
argument_list|(
literal|"waiting for %s (PID %d)\n"
argument_list|,
name|dtp
operator|->
name|dt_cpp_path
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|wstat
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|oact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|omask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"%s returned exit status 0x%x\n"
argument_list|,
name|dtp
operator|->
name|dt_cpp_path
argument_list|,
name|wstat
argument_list|)
expr_stmt|;
name|estat
operator|=
name|WIFEXITED
argument_list|(
name|wstat
argument_list|)
condition|?
name|WEXITSTATUS
argument_list|(
name|wstat
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|estat
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|estat
condition|)
block|{
case|case
literal|126
case|:
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_CPPEXEC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|127
case|:
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_CPPENT
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_CPPERR
argument_list|)
expr_stmt|;
block|}
goto|goto
name|err
goto|;
block|}
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ofp
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
return|return
operator|(
name|ofp
operator|)
return|;
name|err
label|:
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_lib_depend_error
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|dt_set_errmsg
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dt_lib_depend_add
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_list_t
modifier|*
name|dlp
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|dt_lib_depend_t
modifier|*
name|dld
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|assert
argument_list|(
name|arg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|end
operator|=
name|strrchr
argument_list|(
name|arg
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|dld
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_lib_depend_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|dld
operator|->
name|dtld_libpath
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|MAXPATHLEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dld
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dld
operator|->
name|dtld_libpath
argument_list|,
name|arg
argument_list|,
name|end
operator|-
name|arg
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dld
operator|->
name|dtld_library
operator|=
name|strdup
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dld
operator|->
name|dtld_libpath
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dld
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|dt_list_append
argument_list|(
name|dlp
argument_list|,
name|dld
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|dt_lib_depend_t
modifier|*
name|dt_lib_depend_lookup
parameter_list|(
name|dt_list_t
modifier|*
name|dld
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|dt_lib_depend_t
modifier|*
name|dldn
decl_stmt|;
for|for
control|(
name|dldn
operator|=
name|dt_list_next
argument_list|(
name|dld
argument_list|)
init|;
name|dldn
operator|!=
name|NULL
condition|;
name|dldn
operator|=
name|dt_list_next
argument_list|(
name|dldn
argument_list|)
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dldn
operator|->
name|dtld_library
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|dldn
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Go through all the library files, and, if any library dependencies exist for  * that file, add it to that node's list of dependents. The result of this  * will be a graph which can then be topologically sorted to produce a  * compilation order.  */
end_comment

begin_function
specifier|static
name|int
name|dt_lib_build_graph
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dt_lib_depend_t
modifier|*
name|dld
decl_stmt|,
modifier|*
name|dpld
decl_stmt|;
for|for
control|(
name|dld
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_dep
argument_list|)
init|;
name|dld
operator|!=
name|NULL
condition|;
name|dld
operator|=
name|dt_list_next
argument_list|(
name|dld
argument_list|)
control|)
block|{
name|char
modifier|*
name|library
init|=
name|dld
operator|->
name|dtld_library
decl_stmt|;
for|for
control|(
name|dpld
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dld
operator|->
name|dtld_dependencies
argument_list|)
init|;
name|dpld
operator|!=
name|NULL
condition|;
name|dpld
operator|=
name|dt_list_next
argument_list|(
name|dpld
argument_list|)
control|)
block|{
name|dt_lib_depend_t
modifier|*
name|dlda
decl_stmt|;
if|if
condition|(
operator|(
name|dlda
operator|=
name|dt_lib_depend_lookup
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_dep
argument_list|,
name|dpld
operator|->
name|dtld_library
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_lib_depend_error
argument_list|(
name|dtp
argument_list|,
literal|"Invalid library dependency in %s: %s\n"
argument_list|,
name|dld
operator|->
name|dtld_library
argument_list|,
name|dpld
operator|->
name|dtld_library
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_COMPILER
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dt_lib_depend_add
argument_list|(
name|dtp
argument_list|,
operator|&
name|dlda
operator|->
name|dtld_dependents
argument_list|,
name|library
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* preserve dt_errno */
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_topo_sort
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_lib_depend_t
modifier|*
name|dld
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|dt_lib_depend_t
modifier|*
name|dpld
decl_stmt|,
modifier|*
name|dlda
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|dld
operator|->
name|dtld_start
operator|=
operator|++
operator|(
operator|*
name|count
operator|)
expr_stmt|;
for|for
control|(
name|dpld
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dld
operator|->
name|dtld_dependents
argument_list|)
init|;
name|dpld
operator|!=
name|NULL
condition|;
name|dpld
operator|=
name|dt_list_next
argument_list|(
name|dpld
argument_list|)
control|)
block|{
name|dlda
operator|=
name|dt_lib_depend_lookup
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_dep
argument_list|,
name|dpld
operator|->
name|dtld_library
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dlda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlda
operator|->
name|dtld_start
operator|==
literal|0
operator|&&
name|dt_topo_sort
argument_list|(
name|dtp
argument_list|,
name|dlda
argument_list|,
name|count
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|new
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_lib_depend_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|new
operator|->
name|dtld_library
operator|=
name|strdup
argument_list|(
name|dld
operator|->
name|dtld_library
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|new
operator|->
name|dtld_start
operator|=
name|dld
operator|->
name|dtld_start
expr_stmt|;
name|new
operator|->
name|dtld_finish
operator|=
name|dld
operator|->
name|dtld_finish
operator|=
operator|++
operator|(
operator|*
name|count
operator|)
expr_stmt|;
name|dt_list_prepend
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_dep_sorted
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"library %s sorted (%d/%d)\n"
argument_list|,
name|new
operator|->
name|dtld_library
argument_list|,
name|new
operator|->
name|dtld_start
argument_list|,
name|new
operator|->
name|dtld_finish
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_lib_depend_sort
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dt_lib_depend_t
modifier|*
name|dld
decl_stmt|,
modifier|*
name|dpld
decl_stmt|,
modifier|*
name|dlda
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dt_lib_build_graph
argument_list|(
name|dtp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* preserve dt_errno */
comment|/* 	 * Perform a topological sort of the graph that hangs off 	 * dtp->dt_lib_dep. The result of this process will be a 	 * dependency ordered list located at dtp->dt_lib_dep_sorted. 	 */
for|for
control|(
name|dld
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_dep
argument_list|)
init|;
name|dld
operator|!=
name|NULL
condition|;
name|dld
operator|=
name|dt_list_next
argument_list|(
name|dld
argument_list|)
control|)
block|{
if|if
condition|(
name|dld
operator|->
name|dtld_start
operator|==
literal|0
operator|&&
name|dt_topo_sort
argument_list|(
name|dtp
argument_list|,
name|dld
argument_list|,
operator|&
name|count
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* preserve dt_errno */
empty_stmt|;
block|}
comment|/* 	 * Check the graph for cycles. If an ancestor's finishing time is 	 * less than any of its dependent's finishing times then a back edge 	 * exists in the graph and this is a cycle. 	 */
for|for
control|(
name|dld
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_dep
argument_list|)
init|;
name|dld
operator|!=
name|NULL
condition|;
name|dld
operator|=
name|dt_list_next
argument_list|(
name|dld
argument_list|)
control|)
block|{
for|for
control|(
name|dpld
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dld
operator|->
name|dtld_dependents
argument_list|)
init|;
name|dpld
operator|!=
name|NULL
condition|;
name|dpld
operator|=
name|dt_list_next
argument_list|(
name|dpld
argument_list|)
control|)
block|{
name|dlda
operator|=
name|dt_lib_depend_lookup
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_dep_sorted
argument_list|,
name|dpld
operator|->
name|dtld_library
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dlda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlda
operator|->
name|dtld_finish
operator|>
name|dld
operator|->
name|dtld_finish
condition|)
block|{
name|dt_lib_depend_error
argument_list|(
name|dtp
argument_list|,
literal|"Cyclic dependency detected: %s => %s\n"
argument_list|,
name|dld
operator|->
name|dtld_library
argument_list|,
name|dpld
operator|->
name|dtld_library
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_COMPILER
argument_list|)
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_lib_depend_free
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dt_lib_depend_t
modifier|*
name|dld
decl_stmt|,
modifier|*
name|dlda
decl_stmt|;
while|while
condition|(
operator|(
name|dld
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_dep
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|dlda
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dld
operator|->
name|dtld_dependencies
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dt_list_delete
argument_list|(
operator|&
name|dld
operator|->
name|dtld_dependencies
argument_list|,
name|dlda
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dlda
operator|->
name|dtld_library
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dlda
operator|->
name|dtld_libpath
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dlda
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|dlda
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dld
operator|->
name|dtld_dependents
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dt_list_delete
argument_list|(
operator|&
name|dld
operator|->
name|dtld_dependents
argument_list|,
name|dlda
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dlda
operator|->
name|dtld_library
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dlda
operator|->
name|dtld_libpath
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dlda
argument_list|)
expr_stmt|;
block|}
name|dt_list_delete
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_dep
argument_list|,
name|dld
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dld
operator|->
name|dtld_library
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dld
operator|->
name|dtld_libpath
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dld
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|dld
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_dep_sorted
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dt_list_delete
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_dep_sorted
argument_list|,
name|dld
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dld
operator|->
name|dtld_library
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dld
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Open all the .d library files found in the specified directory and  * compile each one of them.  We silently ignore any missing directories and  * other files found therein.  We only fail (and thereby fail dt_load_libs()) if  * we fail to compile a library and the error is something other than #pragma D  * depends_on.  Dependency errors are silently ignored to permit a library  * directory to contain libraries which may not be accessible depending on our  * privileges.  */
end_comment

begin_function
specifier|static
name|int
name|dt_load_libs_dir
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|char
name|fname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|rv
decl_stmt|;
name|dt_lib_depend_t
modifier|*
name|dld
decl_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"skipping lib dir %s: %s\n"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* First, parse each file for library dependencies. */
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".d"
argument_list|)
condition|)
continue|continue;
comment|/* skip any filename not ending in .d */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|fname
argument_list|,
sizeof|sizeof
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|path
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"skipping library %s: %s\n"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Skip files whose name match an already processed library 		 */
for|for
control|(
name|dld
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_dep
argument_list|)
init|;
name|dld
operator|!=
name|NULL
condition|;
name|dld
operator|=
name|dt_list_next
argument_list|(
name|dld
argument_list|)
control|)
block|{
name|end
operator|=
name|strrchr
argument_list|(
name|dld
operator|->
name|dtld_library
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* dt_lib_depend_add ensures this */
name|assert
argument_list|(
name|end
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|end
operator|+
literal|1
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|dld
operator|!=
name|NULL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"skipping library %s, already processed "
literal|"library with the same name: %s"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|dld
operator|->
name|dtld_library
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dtp
operator|->
name|dt_filetag
operator|=
name|fname
expr_stmt|;
if|if
condition|(
name|dt_lib_depend_add
argument_list|(
name|dtp
argument_list|,
operator|&
name|dtp
operator|->
name|dt_lib_dep
argument_list|,
name|fname
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* preserve dt_errno */
name|rv
operator|=
name|dt_compile
argument_list|(
name|dtp
argument_list|,
name|DT_CTX_DPROG
argument_list|,
name|DTRACE_PROBESPEC_NAME
argument_list|,
name|NULL
argument_list|,
name|DTRACE_C_EMPTY
operator||
name|DTRACE_C_CTL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|NULL
operator|&&
name|dtp
operator|->
name|dt_errno
operator|&&
operator|(
name|dtp
operator|->
name|dt_errno
operator|!=
name|EDT_COMPILER
operator|||
name|dtp
operator|->
name|dt_errtag
operator|!=
name|dt_errtag
argument_list|(
name|D_PRAGMA_DEPEND
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* preserve dt_errno */
if|if
condition|(
name|dtp
operator|->
name|dt_errno
condition|)
name|dt_dprintf
argument_list|(
literal|"error parsing library %s: %s\n"
argument_list|,
name|fname
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_filetag
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a topological sorting of all the libraries found across the entire  * dt_lib_path.  Once sorted, compile each one in topological order to cache its  * inlines and translators, etc.  We silently ignore any missing directories and  * other files found therein. We only fail (and thereby fail dt_load_libs()) if  * we fail to compile a library and the error is something other than #pragma D  * depends_on.  Dependency errors are silently ignored to permit a library  * directory to contain libraries which may not be accessible depending on our  * privileges.  */
end_comment

begin_function
specifier|static
name|int
name|dt_load_libs_sort
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dtrace_prog_t
modifier|*
name|pgp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|dt_lib_depend_t
modifier|*
name|dld
decl_stmt|;
comment|/* 	 * Finish building the graph containing the library dependencies 	 * and perform a topological sort to generate an ordered list 	 * for compilation. 	 */
if|if
condition|(
name|dt_lib_depend_sort
argument_list|(
name|dtp
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|dld
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_dep_sorted
argument_list|)
init|;
name|dld
operator|!=
name|NULL
condition|;
name|dld
operator|=
name|dt_list_next
argument_list|(
name|dld
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|dld
operator|->
name|dtld_library
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"skipping library %s: %s\n"
argument_list|,
name|dld
operator|->
name|dtld_library
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dtp
operator|->
name|dt_filetag
operator|=
name|dld
operator|->
name|dtld_library
expr_stmt|;
name|pgp
operator|=
name|dtrace_program_fcompile
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|DTRACE_C_EMPTY
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_filetag
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pgp
operator|==
name|NULL
operator|&&
operator|(
name|dtp
operator|->
name|dt_errno
operator|!=
name|EDT_COMPILER
operator|||
name|dtp
operator|->
name|dt_errtag
operator|!=
name|dt_errtag
argument_list|(
name|D_PRAGMA_DEPEND
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|pgp
operator|==
name|NULL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"skipping library %s: %s\n"
argument_list|,
name|dld
operator|->
name|dtld_library
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dld
operator|->
name|dtld_loaded
operator|=
name|B_TRUE
expr_stmt|;
name|dt_program_destroy
argument_list|(
name|dtp
argument_list|,
name|pgp
argument_list|)
expr_stmt|;
block|}
block|}
name|dt_lib_depend_free
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|dt_lib_depend_free
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* preserve dt_errno */
block|}
end_function

begin_comment
comment|/*  * Load the contents of any appropriate DTrace .d library files.  These files  * contain inlines and translators that will be cached by the compiler.  We  * defer this activity until the first compile to permit libdtrace clients to  * add their own library directories and so that we can properly report errors.  */
end_comment

begin_function
specifier|static
name|int
name|dt_load_libs
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dt_dirpath_t
modifier|*
name|dirp
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_cflags
operator|&
name|DTRACE_C_NOLIBS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* libraries already processed */
name|dtp
operator|->
name|dt_cflags
operator||=
name|DTRACE_C_NOLIBS
expr_stmt|;
comment|/* 	 * /usr/lib/dtrace is always at the head of the list. The rest of the 	 * list is specified in the precedence order the user requested. Process 	 * everything other than the head first. DTRACE_C_NOLIBS has already 	 * been spcified so dt_vopen will ensure that there is always one entry 	 * in dt_lib_path. 	 */
for|for
control|(
name|dirp
operator|=
name|dt_list_next
argument_list|(
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_path
argument_list|)
argument_list|)
init|;
name|dirp
operator|!=
name|NULL
condition|;
name|dirp
operator|=
name|dt_list_next
argument_list|(
name|dirp
argument_list|)
control|)
block|{
if|if
condition|(
name|dt_load_libs_dir
argument_list|(
name|dtp
argument_list|,
name|dirp
operator|->
name|dir_path
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dtp
operator|->
name|dt_cflags
operator|&=
operator|~
name|DTRACE_C_NOLIBS
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
block|}
block|}
comment|/* Handle /usr/lib/dtrace */
name|dirp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_load_libs_dir
argument_list|(
name|dtp
argument_list|,
name|dirp
operator|->
name|dir_path
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dtp
operator|->
name|dt_cflags
operator|&=
operator|~
name|DTRACE_C_NOLIBS
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
block|}
if|if
condition|(
name|dt_load_libs_sort
argument_list|(
name|dtp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|dt_compile
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|int
name|context
parameter_list|,
name|dtrace_probespec_t
name|pspec
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint_t
name|cflags
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
name|dt_decl_t
modifier|*
name|ddp
decl_stmt|;
name|dt_pcb_t
name|pcb
decl_stmt|;
name|void
modifier|*
name|rv
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|==
name|NULL
operator|&&
name|s
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cflags
operator|&
operator|~
name|DTRACE_C_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_path
argument_list|)
operator|!=
name|NULL
operator|&&
name|dt_load_libs
argument_list|(
name|dtp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
name|dtp
operator|->
name|dt_globals
operator|->
name|dh_nelems
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|dt_idhash_iter
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|,
name|dt_idreset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_tls
operator|->
name|dh_nelems
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|dt_idhash_iter
argument_list|(
name|dtp
operator|->
name|dt_tls
argument_list|,
name|dt_idreset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|&&
operator|(
name|cflags
operator|&
name|DTRACE_C_CPP
operator|)
operator|&&
operator|(
name|fp
operator|=
name|dt_preproc
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* errno is set for us */
name|dt_pcb_push
argument_list|(
name|dtp
argument_list|,
operator|&
name|pcb
argument_list|)
expr_stmt|;
name|pcb
operator|.
name|pcb_fileptr
operator|=
name|fp
expr_stmt|;
name|pcb
operator|.
name|pcb_string
operator|=
name|s
expr_stmt|;
name|pcb
operator|.
name|pcb_strptr
operator|=
name|s
expr_stmt|;
name|pcb
operator|.
name|pcb_strlen
operator|=
name|s
condition|?
name|strlen
argument_list|(
name|s
argument_list|)
else|:
literal|0
expr_stmt|;
name|pcb
operator|.
name|pcb_sargc
operator|=
name|argc
expr_stmt|;
name|pcb
operator|.
name|pcb_sargv
operator|=
name|argv
expr_stmt|;
name|pcb
operator|.
name|pcb_sflagv
operator|=
name|argc
condition|?
name|calloc
argument_list|(
name|argc
argument_list|,
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
argument_list|)
else|:
name|NULL
expr_stmt|;
name|pcb
operator|.
name|pcb_pspec
operator|=
name|pspec
expr_stmt|;
name|pcb
operator|.
name|pcb_cflags
operator|=
name|dtp
operator|->
name|dt_cflags
operator||
name|cflags
expr_stmt|;
name|pcb
operator|.
name|pcb_amin
operator|=
name|dtp
operator|->
name|dt_amin
expr_stmt|;
name|pcb
operator|.
name|pcb_yystate
operator|=
operator|-
literal|1
expr_stmt|;
name|pcb
operator|.
name|pcb_context
operator|=
name|context
expr_stmt|;
name|pcb
operator|.
name|pcb_token
operator|=
name|context
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|DT_CTX_DPROG
condition|)
name|yybegin
argument_list|(
name|YYS_EXPR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|&
name|DTRACE_C_CTL
condition|)
name|yybegin
argument_list|(
name|YYS_CONTROL
argument_list|)
expr_stmt|;
else|else
name|yybegin
argument_list|(
name|YYS_CLAUSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|setjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|yypcb
operator|->
name|pcb_sargc
operator|!=
literal|0
operator|&&
name|yypcb
operator|->
name|pcb_sflagv
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|yypcb
operator|->
name|pcb_idents
operator|=
name|dt_idhash_create
argument_list|(
literal|"ambiguous"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|yypcb
operator|->
name|pcb_locals
operator|=
name|dt_idhash_create
argument_list|(
literal|"clause local"
argument_list|,
name|NULL
argument_list|,
name|DIF_VAR_OTHER_UBASE
argument_list|,
name|DIF_VAR_OTHER_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|yypcb
operator|->
name|pcb_idents
operator|==
name|NULL
operator|||
name|yypcb
operator|->
name|pcb_locals
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
comment|/* 	 * Invoke the parser to evaluate the D source code.  If any errors 	 * occur during parsing, an error function will be called and we 	 * will longjmp back to pcb_jmpbuf to abort.  If parsing succeeds, 	 * we optionally display the parse tree if debugging is enabled. 	 */
if|if
condition|(
name|yyparse
argument_list|()
operator|!=
literal|0
operator|||
name|yypcb
operator|->
name|pcb_root
operator|==
name|NULL
condition|)
name|xyerror
argument_list|(
name|D_EMPTY
argument_list|,
literal|"empty D program translation unit\n"
argument_list|)
expr_stmt|;
name|yybegin
argument_list|(
name|YYS_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflags
operator|&
name|DTRACE_C_CTL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|context
operator|!=
name|DT_CTX_DTYPE
operator|&&
name|DT_TREEDUMP_PASS
argument_list|(
name|dtp
argument_list|,
literal|1
argument_list|)
condition|)
name|dt_node_printr
argument_list|(
name|yypcb
operator|->
name|pcb_root
argument_list|,
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|yypcb
operator|->
name|pcb_pragmas
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|dt_idhash_iter
argument_list|(
name|yypcb
operator|->
name|pcb_pragmas
argument_list|,
name|dt_idpragma
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|!
operator|(
name|yypcb
operator|->
name|pcb_cflags
operator|&
name|DTRACE_C_ARGREF
operator|)
operator|&&
operator|!
operator|(
name|yypcb
operator|->
name|pcb_sflagv
index|[
name|argc
operator|-
literal|1
index|]
operator|&
name|DT_IDFLG_REF
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_MACRO_UNUSED
argument_list|,
literal|"extraneous argument '%s' ($%d is "
literal|"not referenced)\n"
argument_list|,
name|yypcb
operator|->
name|pcb_sargv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
name|argc
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we have successfully created a parse tree for a D program, loop 	 * over the clauses and actions and instantiate the corresponding 	 * libdtrace program.  If we are parsing a D expression, then we 	 * simply run the code generator and assembler on the resulting tree. 	 */
switch|switch
condition|(
name|context
condition|)
block|{
case|case
name|DT_CTX_DPROG
case|:
name|assert
argument_list|(
name|yypcb
operator|->
name|pcb_root
operator|->
name|dn_kind
operator|==
name|DT_NODE_PROG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dnp
operator|=
name|yypcb
operator|->
name|pcb_root
operator|->
name|dn_list
operator|)
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|yypcb
operator|->
name|pcb_cflags
operator|&
name|DTRACE_C_EMPTY
operator|)
condition|)
name|xyerror
argument_list|(
name|D_EMPTY
argument_list|,
literal|"empty D program translation unit\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|yypcb
operator|->
name|pcb_prog
operator|=
name|dt_program_create
argument_list|(
name|dtp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
control|)
block|{
switch|switch
condition|(
name|dnp
operator|->
name|dn_kind
condition|)
block|{
case|case
name|DT_NODE_CLAUSE
case|:
name|dt_compile_clause
argument_list|(
name|dtp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_XLATOR
case|:
if|if
condition|(
name|dtp
operator|->
name|dt_xlatemode
operator|==
name|DT_XL_DYNAMIC
condition|)
name|dt_compile_xlator
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_PROVIDER
case|:
operator|(
name|void
operator|)
name|dt_node_cook
argument_list|(
name|dnp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|yypcb
operator|->
name|pcb_prog
operator|->
name|dp_xrefs
operator|=
name|yypcb
operator|->
name|pcb_asxrefs
expr_stmt|;
name|yypcb
operator|->
name|pcb_prog
operator|->
name|dp_xrefslen
operator|=
name|yypcb
operator|->
name|pcb_asxreflen
expr_stmt|;
name|yypcb
operator|->
name|pcb_asxrefs
operator|=
name|NULL
expr_stmt|;
name|yypcb
operator|->
name|pcb_asxreflen
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|yypcb
operator|->
name|pcb_prog
expr_stmt|;
break|break;
case|case
name|DT_CTX_DEXPR
case|:
operator|(
name|void
operator|)
name|dt_node_cook
argument_list|(
name|yypcb
operator|->
name|pcb_root
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|dt_cg
argument_list|(
name|yypcb
argument_list|,
name|yypcb
operator|->
name|pcb_root
argument_list|)
expr_stmt|;
name|rv
operator|=
name|dt_as
argument_list|(
name|yypcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_CTX_DTYPE
case|:
name|ddp
operator|=
operator|(
name|dt_decl_t
operator|*
operator|)
name|yypcb
operator|->
name|pcb_root
expr_stmt|;
comment|/* root is really a decl */
name|err
operator|=
name|dt_decl_type
argument_list|(
name|ddp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|dt_decl_free
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
name|rv
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|out
label|:
if|if
condition|(
name|context
operator|!=
name|DT_CTX_DTYPE
operator|&&
name|yypcb
operator|->
name|pcb_root
operator|!=
name|NULL
operator|&&
name|DT_TREEDUMP_PASS
argument_list|(
name|dtp
argument_list|,
literal|3
argument_list|)
condition|)
name|dt_node_printr
argument_list|(
name|yypcb
operator|->
name|pcb_root
argument_list|,
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_cdefs_fd
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|ftruncate64
argument_list|(
name|dtp
operator|->
name|dt_cdefs_fd
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|lseek64
argument_list|(
name|dtp
operator|->
name|dt_cdefs_fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|ctf_write
argument_list|(
name|dtp
operator|->
name|dt_cdefs
operator|->
name|dm_ctfp
argument_list|,
name|dtp
operator|->
name|dt_cdefs_fd
argument_list|)
operator|==
name|CTF_ERR
operator|)
condition|)
name|dt_dprintf
argument_list|(
literal|"failed to update CTF cache: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_ddefs_fd
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|ftruncate64
argument_list|(
name|dtp
operator|->
name|dt_ddefs_fd
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|lseek64
argument_list|(
name|dtp
operator|->
name|dt_ddefs_fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|ctf_write
argument_list|(
name|dtp
operator|->
name|dt_ddefs
operator|->
name|dm_ctfp
argument_list|,
name|dtp
operator|->
name|dt_ddefs_fd
argument_list|)
operator|==
name|CTF_ERR
operator|)
condition|)
name|dt_dprintf
argument_list|(
literal|"failed to update CTF cache: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yypcb
operator|->
name|pcb_fileptr
operator|&&
operator|(
name|cflags
operator|&
name|DTRACE_C_CPP
operator|)
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|yypcb
operator|->
name|pcb_fileptr
argument_list|)
expr_stmt|;
comment|/* close dt_preproc() file */
name|dt_pcb_pop
argument_list|(
name|dtp
argument_list|,
name|err
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
condition|?
name|NULL
else|:
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|dtrace_prog_t
modifier|*
name|dtrace_program_strcompile
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|dtrace_probespec_t
name|spec
parameter_list|,
name|uint_t
name|cflags
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|)
block|{
return|return
operator|(
name|dt_compile
argument_list|(
name|dtp
argument_list|,
name|DT_CTX_DPROG
argument_list|,
name|spec
argument_list|,
name|NULL
argument_list|,
name|cflags
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|NULL
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|dtrace_prog_t
modifier|*
name|dtrace_program_fcompile
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|uint_t
name|cflags
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|)
block|{
return|return
operator|(
name|dt_compile
argument_list|(
name|dtp
argument_list|,
name|DT_CTX_DPROG
argument_list|,
name|DTRACE_PROBESPEC_NAME
argument_list|,
name|NULL
argument_list|,
name|cflags
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_type_strcompile
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|dtrace_typeinfo_t
modifier|*
name|dtt
parameter_list|)
block|{
operator|(
name|void
operator|)
name|dt_compile
argument_list|(
name|dtp
argument_list|,
name|DT_CTX_DTYPE
argument_list|,
name|DTRACE_PROBESPEC_NONE
argument_list|,
name|dtt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|dtp
operator|->
name|dt_errno
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_type_fcompile
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|dtrace_typeinfo_t
modifier|*
name|dtt
parameter_list|)
block|{
operator|(
name|void
operator|)
name|dt_compile
argument_list|(
name|dtp
argument_list|,
name|DT_CTX_DTYPE
argument_list|,
name|DTRACE_PROBESPEC_NONE
argument_list|,
name|dtt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|dtp
operator|->
name|dt_errno
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

end_unit

