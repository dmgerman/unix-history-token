begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * This file and its contents are supplied under the terms of the  * Common Development and Distribution License ("CDDL"), version 1.0.  * You may only use this file in accordance with the terms of version  * 1.0 of the CDDL.  *  * A full copy of the text of the CDDL should have accompanied this  * source.  A copy of the CDDL is also available via the Internet at  * http://www.illumos.org/license/CDDL.  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012, 2016 by Delphix. All rights reserved.  */
end_comment

begin_comment
comment|/*  * Syntactic sugar features are implemented by transforming the D parse tree  * such that it only uses the subset of D that is supported by the rest of the  * compiler / the kernel.  A clause containing these language features is  * referred to as a "super-clause", and its transformation typically entails  * creating several "sub-clauses" to implement it. For diagnosability, the  * sub-clauses will be printed if the "-xtree=8" flag is specified.  *  * Currently, the only syntactic sugar feature is "if/else" statements.  Each  * basic block (e.g. the body of the "if" and "else" statements, and the  * statements before and after) is turned into its own sub-clause, with a  * predicate that causes it to be executed only if the code flows to this point.  * Nested if/else statements are supported.  *  * This infrastructure is designed to accommodate other syntactic sugar features  * in the future.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dt_module.h>
end_include

begin_include
include|#
directive|include
file|<dt_program.h>
end_include

begin_include
include|#
directive|include
file|<dt_provider.h>
end_include

begin_include
include|#
directive|include
file|<dt_printf.h>
end_include

begin_include
include|#
directive|include
file|<dt_pid.h>
end_include

begin_include
include|#
directive|include
file|<dt_grammar.h>
end_include

begin_include
include|#
directive|include
file|<dt_ident.h>
end_include

begin_include
include|#
directive|include
file|<dt_string.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_typedef
typedef|typedef
struct|struct
name|dt_sugar_parse
block|{
name|dtrace_hdl_t
modifier|*
name|dtsp_dtp
decl_stmt|;
comment|/* dtrace handle */
name|dt_node_t
modifier|*
name|dtsp_pdescs
decl_stmt|;
comment|/* probe descriptions */
name|int
name|dtsp_num_conditions
decl_stmt|;
comment|/* number of condition variables */
name|int
name|dtsp_num_ifs
decl_stmt|;
comment|/* number of "if" statements */
name|dt_node_t
modifier|*
name|dtsp_clause_list
decl_stmt|;
comment|/* list of clauses */
block|}
name|dt_sugar_parse_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|dt_sugar_visit_stmts
parameter_list|(
name|dt_sugar_parse_t
modifier|*
parameter_list|,
name|dt_node_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Return a node for "self->%error".  *  * Note that the "%" is part of the variable name, and is included so that  * this variable name can not collide with any user-specified variable.  *  * This error variable is used to keep track of if there has been an error  * in any of the sub-clauses, and is used to prevent execution of subsequent  * sub-clauses following an error.  */
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_sugar_new_error_var
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|dt_node_op2
argument_list|(
name|DT_TOK_PTR
argument_list|,
name|dt_node_ident
argument_list|(
name|strdup
argument_list|(
literal|"self"
argument_list|)
argument_list|)
argument_list|,
name|dt_node_ident
argument_list|(
name|strdup
argument_list|(
literal|"%error"
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append this clause to the clause list.  */
end_comment

begin_function
specifier|static
name|void
name|dt_sugar_append_clause
parameter_list|(
name|dt_sugar_parse_t
modifier|*
name|dp
parameter_list|,
name|dt_node_t
modifier|*
name|clause
parameter_list|)
block|{
name|dp
operator|->
name|dtsp_clause_list
operator|=
name|dt_node_link
argument_list|(
name|dp
operator|->
name|dtsp_clause_list
argument_list|,
name|clause
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prepend this clause to the clause list.  */
end_comment

begin_function
specifier|static
name|void
name|dt_sugar_prepend_clause
parameter_list|(
name|dt_sugar_parse_t
modifier|*
name|dp
parameter_list|,
name|dt_node_t
modifier|*
name|clause
parameter_list|)
block|{
name|dp
operator|->
name|dtsp_clause_list
operator|=
name|dt_node_link
argument_list|(
name|clause
argument_list|,
name|dp
operator|->
name|dtsp_clause_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return a node for "this->%condition_<condid>", or NULL if condid==0.  *  * Note that the "%" is part of the variable name, and is included so that  * this variable name can not collide with any user-specified variable.  */
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_sugar_new_condition_var
parameter_list|(
name|int
name|condid
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|condid
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|assert
argument_list|(
name|condid
operator|>
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|asprintf
argument_list|(
operator|&
name|str
argument_list|,
literal|"%%condition_%d"
argument_list|,
name|ABS
argument_list|(
name|condid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_node_op2
argument_list|(
name|DT_TOK_PTR
argument_list|,
name|dt_node_ident
argument_list|(
name|strdup
argument_list|(
literal|"this"
argument_list|)
argument_list|)
argument_list|,
name|dt_node_ident
argument_list|(
name|str
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return new clause to evaluate predicate and set newcond.  condid is  * the condition that we are already under, or 0 if none.  * The new clause will be of the form:  *  * dp_pdescs  * /!self->%error/  * {  *	this->%condition_<newcond> =  *	    (this->%condition_<condid>&& pred);  * }  *  * Note: if condid==0, we will instead do "... = (1&& pred)", to effectively  * convert the pred to a boolean.  *  * Note: Unless an error has been encountered, we always set the condition  * variable (either to 0 or 1).  This lets us avoid resetting the condition  * variables back to 0 when the super-clause completes.  */
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_sugar_new_condition_impl
parameter_list|(
name|dt_sugar_parse_t
modifier|*
name|dp
parameter_list|,
name|dt_node_t
modifier|*
name|pred
parameter_list|,
name|int
name|condid
parameter_list|,
name|int
name|newcond
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|value
decl_stmt|,
modifier|*
name|body
decl_stmt|,
modifier|*
name|newpred
decl_stmt|;
comment|/* predicate is !self->%error */
name|newpred
operator|=
name|dt_node_op1
argument_list|(
name|DT_TOK_LNEG
argument_list|,
name|dt_sugar_new_error_var
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|condid
operator|==
literal|0
condition|)
block|{
comment|/* 		 * value is (1&& pred) 		 * 		 * Note, D doesn't allow a probe-local "this" variable to 		 * be reused as a different type, even from a different probe. 		 * Therefore, value can't simply be<pred>, because then 		 * its type could be different when we reuse this condid 		 * in a different meta-clause. 		 */
name|value
operator|=
name|dt_node_op2
argument_list|(
name|DT_TOK_LAND
argument_list|,
name|dt_node_int
argument_list|(
literal|1
argument_list|)
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* value is (this->%condition_<condid>&& pred) */
name|value
operator|=
name|dt_node_op2
argument_list|(
name|DT_TOK_LAND
argument_list|,
name|dt_sugar_new_condition_var
argument_list|(
name|condid
argument_list|)
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
comment|/* body is "this->%condition_<retval> =<value>;" */
name|body
operator|=
name|dt_node_statement
argument_list|(
name|dt_node_op2
argument_list|(
name|DT_TOK_ASGN
argument_list|,
name|dt_sugar_new_condition_var
argument_list|(
name|newcond
argument_list|)
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_node_clause
argument_list|(
name|dp
operator|->
name|dtsp_pdescs
argument_list|,
name|newpred
argument_list|,
name|body
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate a new clause to evaluate predicate and set a new condition variable,  * whose ID will be returned.  The new clause will be appended to  * dp_first_new_clause.  */
end_comment

begin_function
specifier|static
name|int
name|dt_sugar_new_condition
parameter_list|(
name|dt_sugar_parse_t
modifier|*
name|dp
parameter_list|,
name|dt_node_t
modifier|*
name|pred
parameter_list|,
name|int
name|condid
parameter_list|)
block|{
name|dp
operator|->
name|dtsp_num_conditions
operator|++
expr_stmt|;
name|dt_sugar_append_clause
argument_list|(
name|dp
argument_list|,
name|dt_sugar_new_condition_impl
argument_list|(
name|dp
argument_list|,
name|pred
argument_list|,
name|condid
argument_list|,
name|dp
operator|->
name|dtsp_num_conditions
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|->
name|dtsp_num_conditions
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Visit the specified node and all of its descendants.  Currently this is only  * used to count the number of "if" statements (dtsp_num_ifs).  */
end_comment

begin_function
specifier|static
name|void
name|dt_sugar_visit_all
parameter_list|(
name|dt_sugar_parse_t
modifier|*
name|dp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|arg
decl_stmt|;
switch|switch
condition|(
name|dnp
operator|->
name|dn_kind
condition|)
block|{
case|case
name|DT_NODE_FREE
case|:
case|case
name|DT_NODE_INT
case|:
case|case
name|DT_NODE_STRING
case|:
case|case
name|DT_NODE_SYM
case|:
case|case
name|DT_NODE_TYPE
case|:
case|case
name|DT_NODE_PROBE
case|:
case|case
name|DT_NODE_PDESC
case|:
case|case
name|DT_NODE_IDENT
case|:
break|break;
case|case
name|DT_NODE_FUNC
case|:
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_OP1
case|:
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|dnp
operator|->
name|dn_child
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_OP2
case|:
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|dnp
operator|->
name|dn_left
argument_list|)
expr_stmt|;
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|dnp
operator|->
name|dn_right
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_LBRAC
condition|)
block|{
name|dt_node_t
modifier|*
name|ln
init|=
name|dnp
operator|->
name|dn_right
decl_stmt|;
while|while
condition|(
name|ln
operator|->
name|dn_list
operator|!=
name|NULL
condition|)
block|{
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|ln
operator|->
name|dn_list
argument_list|)
expr_stmt|;
name|ln
operator|=
name|ln
operator|->
name|dn_list
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_NODE_OP3
case|:
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|)
expr_stmt|;
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|dnp
operator|->
name|dn_left
argument_list|)
expr_stmt|;
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|dnp
operator|->
name|dn_right
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_DEXPR
case|:
case|case
name|DT_NODE_DFUNC
case|:
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|dnp
operator|->
name|dn_expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_AGG
case|:
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_aggtup
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_aggfun
condition|)
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|dnp
operator|->
name|dn_aggfun
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_CLAUSE
case|:
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_pdescs
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_pred
operator|!=
name|NULL
condition|)
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|dnp
operator|->
name|dn_pred
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_acts
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_INLINE
case|:
block|{
specifier|const
name|dt_idnode_t
modifier|*
name|inp
init|=
name|dnp
operator|->
name|dn_ident
operator|->
name|di_iarg
decl_stmt|;
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|inp
operator|->
name|din_root
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DT_NODE_MEMBER
case|:
if|if
condition|(
name|dnp
operator|->
name|dn_membexpr
condition|)
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|dnp
operator|->
name|dn_membexpr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_XLATOR
case|:
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_members
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_PROVIDER
case|:
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_probes
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_PROG
case|:
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_list
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_IF
case|:
name|dp
operator|->
name|dtsp_num_ifs
operator|++
expr_stmt|;
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|dnp
operator|->
name|dn_conditional
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_body
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_alternate_body
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
name|dt_sugar_visit_all
argument_list|(
name|dp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_UNKNOWN
argument_list|,
literal|"bad node %p, kind %d\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dnp
argument_list|,
name|dnp
operator|->
name|dn_kind
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return a new clause which resets the error variable to zero:  *  *   dp_pdescs{ self->%error = 0; }  *  * This clause will be executed at the beginning of each meta-clause, to  * ensure the error variable is unset (in case the previous meta-clause  * failed).  */
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_sugar_new_clearerror_clause
parameter_list|(
name|dt_sugar_parse_t
modifier|*
name|dp
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|stmt
init|=
name|dt_node_statement
argument_list|(
name|dt_node_op2
argument_list|(
name|DT_TOK_ASGN
argument_list|,
name|dt_sugar_new_error_var
argument_list|()
argument_list|,
name|dt_node_int
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|dt_node_clause
argument_list|(
name|dp
operator|->
name|dtsp_pdescs
argument_list|,
name|NULL
argument_list|,
name|stmt
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate the conditional, and recursively visit the body of the "if"  * statement (and the "else", if present).  */
end_comment

begin_function
specifier|static
name|void
name|dt_sugar_do_if
parameter_list|(
name|dt_sugar_parse_t
modifier|*
name|dp
parameter_list|,
name|dt_node_t
modifier|*
name|if_stmt
parameter_list|,
name|int
name|precondition
parameter_list|)
block|{
name|int
name|newid
decl_stmt|;
name|assert
argument_list|(
name|if_stmt
operator|->
name|dn_kind
operator|==
name|DT_NODE_IF
argument_list|)
expr_stmt|;
comment|/* condition */
name|newid
operator|=
name|dt_sugar_new_condition
argument_list|(
name|dp
argument_list|,
name|if_stmt
operator|->
name|dn_conditional
argument_list|,
name|precondition
argument_list|)
expr_stmt|;
comment|/* body of if */
name|dt_sugar_visit_stmts
argument_list|(
name|dp
argument_list|,
name|if_stmt
operator|->
name|dn_body
argument_list|,
name|newid
argument_list|)
expr_stmt|;
comment|/* 	 * Visit the body of the "else" statement, if present.  Note that we 	 * generate a new condition which is the inverse of the previous 	 * condition. 	 */
if|if
condition|(
name|if_stmt
operator|->
name|dn_alternate_body
operator|!=
name|NULL
condition|)
block|{
name|dt_node_t
modifier|*
name|pred
init|=
name|dt_node_op1
argument_list|(
name|DT_TOK_LNEG
argument_list|,
name|dt_sugar_new_condition_var
argument_list|(
name|newid
argument_list|)
argument_list|)
decl_stmt|;
name|dt_sugar_visit_stmts
argument_list|(
name|dp
argument_list|,
name|if_stmt
operator|->
name|dn_alternate_body
argument_list|,
name|dt_sugar_new_condition
argument_list|(
name|dp
argument_list|,
name|pred
argument_list|,
name|precondition
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Generate a new clause to evaluate the statements based on the condition.  * The new clause will be appended to dp_first_new_clause.  *  * dp_pdescs  * /!self->%error&& this->%condition_<condid>/  * {  *	stmts  * }  */
end_comment

begin_function
specifier|static
name|void
name|dt_sugar_new_basic_block
parameter_list|(
name|dt_sugar_parse_t
modifier|*
name|dp
parameter_list|,
name|int
name|condid
parameter_list|,
name|dt_node_t
modifier|*
name|stmts
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|pred
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|condid
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Don't bother with !error on the first clause, because if 		 * there is only one clause, we don't add the prelude to 		 * zero out %error. 		 */
if|if
condition|(
name|dp
operator|->
name|dtsp_num_conditions
operator|!=
literal|0
condition|)
block|{
name|pred
operator|=
name|dt_node_op1
argument_list|(
name|DT_TOK_LNEG
argument_list|,
name|dt_sugar_new_error_var
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pred
operator|=
name|dt_node_op2
argument_list|(
name|DT_TOK_LAND
argument_list|,
name|dt_node_op1
argument_list|(
name|DT_TOK_LNEG
argument_list|,
name|dt_sugar_new_error_var
argument_list|()
argument_list|)
argument_list|,
name|dt_sugar_new_condition_var
argument_list|(
name|condid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_sugar_append_clause
argument_list|(
name|dp
argument_list|,
name|dt_node_clause
argument_list|(
name|dp
operator|->
name|dtsp_pdescs
argument_list|,
name|pred
argument_list|,
name|stmts
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Visit all the statements in this list, and break them into basic blocks,  * generating new clauses for "if" and "else" statements.  */
end_comment

begin_function
specifier|static
name|void
name|dt_sugar_visit_stmts
parameter_list|(
name|dt_sugar_parse_t
modifier|*
name|dp
parameter_list|,
name|dt_node_t
modifier|*
name|stmts
parameter_list|,
name|int
name|precondition
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|stmt
decl_stmt|;
name|dt_node_t
modifier|*
name|prev_stmt
init|=
name|NULL
decl_stmt|;
name|dt_node_t
modifier|*
name|next_stmt
decl_stmt|;
name|dt_node_t
modifier|*
name|first_stmt_in_basic_block
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|stmt
operator|=
name|stmts
init|;
name|stmt
operator|!=
name|NULL
condition|;
name|stmt
operator|=
name|next_stmt
control|)
block|{
name|next_stmt
operator|=
name|stmt
operator|->
name|dn_list
expr_stmt|;
if|if
condition|(
name|stmt
operator|->
name|dn_kind
operator|!=
name|DT_NODE_IF
condition|)
block|{
if|if
condition|(
name|first_stmt_in_basic_block
operator|==
name|NULL
condition|)
name|first_stmt_in_basic_block
operator|=
name|stmt
expr_stmt|;
name|prev_stmt
operator|=
name|stmt
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Remove this and following statements from the previous 		 * clause. 		 */
if|if
condition|(
name|prev_stmt
operator|!=
name|NULL
condition|)
name|prev_stmt
operator|->
name|dn_list
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Generate clause for statements preceding the "if" 		 */
if|if
condition|(
name|first_stmt_in_basic_block
operator|!=
name|NULL
condition|)
block|{
name|dt_sugar_new_basic_block
argument_list|(
name|dp
argument_list|,
name|precondition
argument_list|,
name|first_stmt_in_basic_block
argument_list|)
expr_stmt|;
block|}
name|dt_sugar_do_if
argument_list|(
name|dp
argument_list|,
name|stmt
argument_list|,
name|precondition
argument_list|)
expr_stmt|;
name|first_stmt_in_basic_block
operator|=
name|NULL
expr_stmt|;
name|prev_stmt
operator|=
name|stmt
expr_stmt|;
block|}
comment|/* generate clause for statements after last "if". */
if|if
condition|(
name|first_stmt_in_basic_block
operator|!=
name|NULL
condition|)
block|{
name|dt_sugar_new_basic_block
argument_list|(
name|dp
argument_list|,
name|precondition
argument_list|,
name|first_stmt_in_basic_block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Generate a new clause which will set the error variable when an error occurs.  * Only one of these clauses is created per program (e.g. script file).  * The clause is:  *  * dtrace:::ERROR{ self->%error = 1; }  */
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_sugar_makeerrorclause
parameter_list|(
name|void
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|acts
decl_stmt|,
modifier|*
name|pdesc
decl_stmt|;
name|pdesc
operator|=
name|dt_node_pdesc_by_name
argument_list|(
name|strdup
argument_list|(
literal|"dtrace:::ERROR"
argument_list|)
argument_list|)
expr_stmt|;
name|acts
operator|=
name|dt_node_statement
argument_list|(
name|dt_node_op2
argument_list|(
name|DT_TOK_ASGN
argument_list|,
name|dt_sugar_new_error_var
argument_list|()
argument_list|,
name|dt_node_int
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_node_clause
argument_list|(
name|pdesc
argument_list|,
name|NULL
argument_list|,
name|acts
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Transform the super-clause into straight-D, returning the new list of  * sub-clauses.  */
end_comment

begin_function
name|dt_node_t
modifier|*
name|dt_compile_sugar
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|clause
parameter_list|)
block|{
name|dt_sugar_parse_t
name|dp
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|condid
init|=
literal|0
decl_stmt|;
name|dp
operator|.
name|dtsp_dtp
operator|=
name|dtp
expr_stmt|;
name|dp
operator|.
name|dtsp_pdescs
operator|=
name|clause
operator|->
name|dn_pdescs
expr_stmt|;
comment|/* make dt_node_int() generate an "int"-typed integer */
name|yyintdecimal
operator|=
name|B_TRUE
expr_stmt|;
name|yyintsuffix
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|yyintprefix
operator|=
literal|0
expr_stmt|;
name|dt_sugar_visit_all
argument_list|(
operator|&
name|dp
argument_list|,
name|clause
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|.
name|dtsp_num_ifs
operator|==
literal|0
operator|&&
name|dp
operator|.
name|dtsp_num_conditions
operator|==
literal|0
condition|)
block|{
comment|/* 		 * There is nothing that modifies the number of clauses.  Use 		 * the existing clause as-is, with its predicate intact.  This 		 * ensures that in the absence of D sugar, the body of the 		 * clause can create a variable that is referenced in the 		 * predicate. 		 */
name|dt_sugar_append_clause
argument_list|(
operator|&
name|dp
argument_list|,
name|dt_node_clause
argument_list|(
name|clause
operator|->
name|dn_pdescs
argument_list|,
name|clause
operator|->
name|dn_pred
argument_list|,
name|clause
operator|->
name|dn_acts
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|clause
operator|->
name|dn_pred
operator|!=
name|NULL
condition|)
block|{
name|condid
operator|=
name|dt_sugar_new_condition
argument_list|(
operator|&
name|dp
argument_list|,
name|clause
operator|->
name|dn_pred
argument_list|,
name|condid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clause
operator|->
name|dn_acts
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * dt_sugar_visit_stmts() does not emit a clause with 			 * an empty body (e.g. if there's an empty "if" body), 			 * but we need the empty body here so that we 			 * continue to get the default tracing action. 			 */
name|dt_sugar_new_basic_block
argument_list|(
operator|&
name|dp
argument_list|,
name|condid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dt_sugar_visit_stmts
argument_list|(
operator|&
name|dp
argument_list|,
name|clause
operator|->
name|dn_acts
argument_list|,
name|condid
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dp
operator|.
name|dtsp_num_conditions
operator|!=
literal|0
condition|)
block|{
name|dt_sugar_prepend_clause
argument_list|(
operator|&
name|dp
argument_list|,
name|dt_sugar_new_clearerror_clause
argument_list|(
operator|&
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|.
name|dtsp_clause_list
operator|!=
name|NULL
operator|&&
name|dp
operator|.
name|dtsp_clause_list
operator|->
name|dn_list
operator|!=
name|NULL
operator|&&
operator|!
name|dtp
operator|->
name|dt_has_sugar
condition|)
block|{
name|dtp
operator|->
name|dt_has_sugar
operator|=
name|B_TRUE
expr_stmt|;
name|dt_sugar_prepend_clause
argument_list|(
operator|&
name|dp
argument_list|,
name|dt_sugar_makeerrorclause
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dp
operator|.
name|dtsp_clause_list
operator|)
return|;
block|}
end_function

end_unit

