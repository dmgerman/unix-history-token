begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013, Joyent, Inc.  All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<dt_provider.h>
end_include

begin_include
include|#
directive|include
file|<dt_module.h>
end_include

begin_include
include|#
directive|include
file|<dt_string.h>
end_include

begin_include
include|#
directive|include
file|<dt_list.h>
end_include

begin_include
include|#
directive|include
file|<dt_pid.h>
end_include

begin_include
include|#
directive|include
file|<dtrace.h>
end_include

begin_function
specifier|static
name|dt_provider_t
modifier|*
name|dt_provider_insert
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_provider_t
modifier|*
name|pvp
parameter_list|,
name|uint_t
name|h
parameter_list|)
block|{
name|dt_list_append
argument_list|(
operator|&
name|dtp
operator|->
name|dt_provlist
argument_list|,
name|pvp
argument_list|)
expr_stmt|;
name|pvp
operator|->
name|pv_next
operator|=
name|dtp
operator|->
name|dt_provs
index|[
name|h
index|]
expr_stmt|;
name|dtp
operator|->
name|dt_provs
index|[
name|h
index|]
operator|=
name|pvp
expr_stmt|;
name|dtp
operator|->
name|dt_nprovs
operator|++
expr_stmt|;
return|return
operator|(
name|pvp
operator|)
return|;
block|}
end_function

begin_function
name|dt_provider_t
modifier|*
name|dt_provider_lookup
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|uint_t
name|h
init|=
name|dt_strtab_hash
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
operator|%
name|dtp
operator|->
name|dt_provbuckets
decl_stmt|;
name|dtrace_providerdesc_t
name|desc
decl_stmt|;
name|dt_provider_t
modifier|*
name|pvp
decl_stmt|;
for|for
control|(
name|pvp
operator|=
name|dtp
operator|->
name|dt_provs
index|[
name|h
index|]
init|;
name|pvp
operator|!=
name|NULL
condition|;
name|pvp
operator|=
name|pvp
operator|->
name|pv_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|pvp
operator|)
return|;
block|}
if|if
condition|(
name|strisglob
argument_list|(
name|name
argument_list|)
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOPROV
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|desc
operator|.
name|dtvd_name
argument_list|,
name|name
argument_list|,
name|DTRACE_PROVNAMELEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_PROVIDER
argument_list|,
operator|&
name|desc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
operator|==
name|ESRCH
condition|?
name|EDT_NOPROV
else|:
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|pvp
operator|=
name|dt_provider_create
argument_list|(
name|dtp
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* dt_errno is set for us */
name|bcopy
argument_list|(
operator|&
name|desc
argument_list|,
operator|&
name|pvp
operator|->
name|pv_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|pvp
operator|->
name|pv_flags
operator||=
name|DT_PROVIDER_IMPL
expr_stmt|;
return|return
operator|(
name|pvp
operator|)
return|;
block|}
end_function

begin_function
name|dt_provider_t
modifier|*
name|dt_provider_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dt_provider_t
modifier|*
name|pvp
decl_stmt|;
if|if
condition|(
operator|(
name|pvp
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_provider_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|name
argument_list|,
name|DTRACE_PROVNAMELEN
argument_list|)
expr_stmt|;
name|pvp
operator|->
name|pv_probes
operator|=
name|dt_idhash_create
argument_list|(
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pvp
operator|->
name|pv_gen
operator|=
name|dtp
operator|->
name|dt_gen
expr_stmt|;
name|pvp
operator|->
name|pv_hdl
operator|=
name|dtp
expr_stmt|;
if|if
condition|(
name|pvp
operator|->
name|pv_probes
operator|==
name|NULL
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
operator|.
name|dtpa_provider
operator|=
name|_dtrace_prvattr
expr_stmt|;
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
operator|.
name|dtpa_mod
operator|=
name|_dtrace_prvattr
expr_stmt|;
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
operator|.
name|dtpa_func
operator|=
name|_dtrace_prvattr
expr_stmt|;
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
operator|.
name|dtpa_name
operator|=
name|_dtrace_prvattr
expr_stmt|;
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
operator|.
name|dtpa_args
operator|=
name|_dtrace_prvattr
expr_stmt|;
return|return
operator|(
name|dt_provider_insert
argument_list|(
name|dtp
argument_list|,
name|pvp
argument_list|,
name|dt_strtab_hash
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
operator|%
name|dtp
operator|->
name|dt_provbuckets
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_provider_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_provider_t
modifier|*
name|pvp
parameter_list|)
block|{
name|dt_provider_t
modifier|*
modifier|*
name|pp
decl_stmt|;
name|uint_t
name|h
decl_stmt|;
name|assert
argument_list|(
name|pvp
operator|->
name|pv_hdl
operator|==
name|dtp
argument_list|)
expr_stmt|;
name|h
operator|=
name|dt_strtab_hash
argument_list|(
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|NULL
argument_list|)
operator|%
name|dtp
operator|->
name|dt_provbuckets
expr_stmt|;
name|pp
operator|=
operator|&
name|dtp
operator|->
name|dt_provs
index|[
name|h
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|!=
name|NULL
operator|&&
operator|*
name|pp
operator|!=
name|pvp
condition|)
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|pv_next
expr_stmt|;
name|assert
argument_list|(
operator|*
name|pp
operator|!=
name|NULL
operator|&&
operator|*
name|pp
operator|==
name|pvp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|pvp
operator|->
name|pv_next
expr_stmt|;
name|dt_list_delete
argument_list|(
operator|&
name|dtp
operator|->
name|dt_provlist
argument_list|,
name|pvp
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_nprovs
operator|--
expr_stmt|;
if|if
condition|(
name|pvp
operator|->
name|pv_probes
operator|!=
name|NULL
condition|)
name|dt_idhash_destroy
argument_list|(
name|pvp
operator|->
name|pv_probes
argument_list|)
expr_stmt|;
name|dt_node_link_free
argument_list|(
operator|&
name|pvp
operator|->
name|pv_nodes
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pvp
operator|->
name|pv_xrefs
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dt_provider_xref
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_provider_t
modifier|*
name|pvp
parameter_list|,
name|id_t
name|id
parameter_list|)
block|{
name|size_t
name|oldsize
init|=
name|BT_SIZEOFMAP
argument_list|(
name|pvp
operator|->
name|pv_xrmax
argument_list|)
decl_stmt|;
name|size_t
name|newsize
init|=
name|BT_SIZEOFMAP
argument_list|(
name|dtp
operator|->
name|dt_xlatorid
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|id
operator|>=
literal|0
operator|&&
name|id
operator|<
name|dtp
operator|->
name|dt_xlatorid
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsize
operator|>
name|oldsize
condition|)
block|{
name|ulong_t
modifier|*
name|xrefs
init|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
name|newsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|xrefs
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bcopy
argument_list|(
name|pvp
operator|->
name|pv_xrefs
argument_list|,
name|xrefs
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pvp
operator|->
name|pv_xrefs
argument_list|)
expr_stmt|;
name|pvp
operator|->
name|pv_xrefs
operator|=
name|xrefs
expr_stmt|;
name|pvp
operator|->
name|pv_xrmax
operator|=
name|dtp
operator|->
name|dt_xlatorid
expr_stmt|;
block|}
name|BT_SET
argument_list|(
name|pvp
operator|->
name|pv_xrefs
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|dt_probe_argmap
parameter_list|(
name|dt_node_t
modifier|*
name|xnp
parameter_list|,
name|dt_node_t
modifier|*
name|nnp
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nnp
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nnp
operator|->
name|dn_string
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|nnp
operator|->
name|dn_string
argument_list|,
name|xnp
operator|->
name|dn_string
argument_list|)
operator|==
literal|0
condition|)
break|break;
else|else
name|nnp
operator|=
name|nnp
operator|->
name|dn_list
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_probe_alloc_args
parameter_list|(
name|dt_provider_t
modifier|*
name|pvp
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|args
init|=
name|NULL
decl_stmt|,
modifier|*
name|pnp
init|=
name|NULL
decl_stmt|,
modifier|*
name|dnp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
operator|,
name|pnp
operator|=
name|dnp
control|)
block|{
if|if
condition|(
operator|(
name|dnp
operator|=
name|dt_node_xalloc
argument_list|(
name|pvp
operator|->
name|pv_hdl
argument_list|,
name|DT_NODE_TYPE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dnp
operator|->
name|dn_link
operator|=
name|pvp
operator|->
name|pv_nodes
expr_stmt|;
name|pvp
operator|->
name|pv_nodes
operator|=
name|dnp
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|args
operator|=
name|dnp
expr_stmt|;
else|else
name|pnp
operator|->
name|dn_list
operator|=
name|dnp
expr_stmt|;
block|}
return|return
operator|(
name|args
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|dt_probe_keylen
parameter_list|(
specifier|const
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|)
block|{
return|return
operator|(
name|strlen
argument_list|(
name|pdp
operator|->
name|dtpd_mod
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|pdp
operator|->
name|dtpd_func
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|pdp
operator|->
name|dtpd_name
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dt_probe_key
parameter_list|(
specifier|const
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|INT_MAX
argument_list|,
literal|"%s:%s:%s"
argument_list|,
name|pdp
operator|->
name|dtpd_mod
argument_list|,
name|pdp
operator|->
name|dtpd_func
argument_list|,
name|pdp
operator|->
name|dtpd_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If a probe was discovered from the kernel, ask dtrace(7D) for a description  * of each of its arguments, including native and translated types.  */
end_comment

begin_function
specifier|static
name|dt_probe_t
modifier|*
name|dt_probe_discover
parameter_list|(
name|dt_provider_t
modifier|*
name|pvp
parameter_list|,
specifier|const
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|pvp
operator|->
name|pv_hdl
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|dt_probe_key
argument_list|(
name|pdp
argument_list|,
name|alloca
argument_list|(
name|dt_probe_keylen
argument_list|(
name|pdp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|dt_node_t
modifier|*
name|xargs
decl_stmt|,
modifier|*
name|nargs
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|dt_probe_t
modifier|*
name|prp
decl_stmt|;
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nc
decl_stmt|,
name|xc
decl_stmt|;
name|int
name|adc
init|=
name|_dtrace_argmax
decl_stmt|;
name|dtrace_argdesc_t
modifier|*
name|adv
init|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_argdesc_t
argument_list|)
operator|*
name|adc
argument_list|)
decl_stmt|;
name|dtrace_argdesc_t
modifier|*
name|adp
init|=
name|adv
decl_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pdp
operator|->
name|dtpd_id
operator|!=
name|DTRACE_IDNONE
argument_list|)
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"discovering probe %s:%s id=%d\n"
argument_list|,
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|name
argument_list|,
name|pdp
operator|->
name|dtpd_id
argument_list|)
expr_stmt|;
for|for
control|(
name|nc
operator|=
operator|-
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adc
condition|;
name|i
operator|++
operator|,
name|adp
operator|++
control|)
block|{
name|bzero
argument_list|(
name|adp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_argdesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|adp
operator|->
name|dtargd_ndx
operator|=
name|i
expr_stmt|;
name|adp
operator|->
name|dtargd_id
operator|=
name|pdp
operator|->
name|dtpd_id
expr_stmt|;
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_PROBEARG
argument_list|,
name|adp
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|adp
operator|->
name|dtargd_ndx
operator|==
name|DTRACE_ARGNONE
condition|)
break|break;
comment|/* all argument descs have been retrieved */
name|nc
operator|=
name|MAX
argument_list|(
name|nc
argument_list|,
name|adp
operator|->
name|dtargd_mapping
argument_list|)
expr_stmt|;
block|}
name|xc
operator|=
name|i
expr_stmt|;
name|nc
operator|++
expr_stmt|;
comment|/* 	 * The pid provider believes in giving the kernel a break. No reason to 	 * give the kernel all the ctf containers that we're keeping ourselves 	 * just to get it back from it. So if we're coming from a pid provider 	 * probe and the kernel gave us no argument information we'll get some 	 * here. If for some crazy reason the kernel knows about our userland 	 * types then we just ignore this. 	 */
if|if
condition|(
name|xc
operator|==
literal|0
operator|&&
name|nc
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
literal|"pid"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nc
operator|=
name|adc
expr_stmt|;
name|dt_pid_get_types
argument_list|(
name|dtp
argument_list|,
name|pdp
argument_list|,
name|adv
argument_list|,
operator|&
name|nc
argument_list|)
expr_stmt|;
name|xc
operator|=
name|nc
expr_stmt|;
block|}
comment|/* 	 * Now that we have discovered the number of native and translated 	 * arguments from the argument descriptions, allocate a new probe ident 	 * and corresponding dt_probe_t and hash it into the provider. 	 */
name|xargs
operator|=
name|dt_probe_alloc_args
argument_list|(
name|pvp
argument_list|,
name|xc
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|dt_probe_alloc_args
argument_list|(
name|pvp
argument_list|,
name|nc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xc
operator|!=
literal|0
operator|&&
name|xargs
operator|==
name|NULL
operator|)
operator|||
operator|(
name|nc
operator|!=
literal|0
operator|&&
name|nargs
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* dt_errno is set for us */
name|idp
operator|=
name|dt_ident_create
argument_list|(
name|name
argument_list|,
name|DT_IDENT_PROBE
argument_list|,
name|DT_IDFLG_ORPHAN
argument_list|,
name|pdp
operator|->
name|dtpd_id
argument_list|,
name|_dtrace_defattr
argument_list|,
literal|0
argument_list|,
operator|&
name|dt_idops_probe
argument_list|,
name|NULL
argument_list|,
name|dtp
operator|->
name|dt_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|prp
operator|=
name|dt_probe_create
argument_list|(
name|dtp
argument_list|,
name|idp
argument_list|,
literal|2
argument_list|,
name|nargs
argument_list|,
name|nc
argument_list|,
name|xargs
argument_list|,
name|xc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_ident_destroy
argument_list|(
name|idp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dt_probe_declare
argument_list|(
name|pvp
argument_list|,
name|prp
argument_list|)
expr_stmt|;
comment|/* 	 * Once our new dt_probe_t is fully constructed, iterate over the 	 * cached argument descriptions and assign types to prp->pr_nargv[] 	 * and prp->pr_xargv[] and assign mappings to prp->pr_mapping[]. 	 */
for|for
control|(
name|adp
operator|=
name|adv
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xc
condition|;
name|i
operator|++
operator|,
name|adp
operator|++
control|)
block|{
if|if
condition|(
name|dtrace_type_strcompile
argument_list|(
name|dtp
argument_list|,
name|adp
operator|->
name|dtargd_native
argument_list|,
operator|&
name|dtt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to resolve input type %s "
literal|"for %s:%s arg #%d: %s\n"
argument_list|,
name|adp
operator|->
name|dtargd_native
argument_list|,
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|name
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dtt
operator|.
name|dtt_object
operator|=
name|NULL
expr_stmt|;
name|dtt
operator|.
name|dtt_ctfp
operator|=
name|NULL
expr_stmt|;
name|dtt
operator|.
name|dtt_type
operator|=
name|CTF_ERR
expr_stmt|;
block|}
else|else
block|{
name|dt_node_type_assign
argument_list|(
name|prp
operator|->
name|pr_nargv
index|[
name|adp
operator|->
name|dtargd_mapping
index|]
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|,
name|dtt
operator|.
name|dtt_flags
operator|&
name|DTT_FL_USER
condition|?
name|B_TRUE
else|:
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dtt
operator|.
name|dtt_type
operator|!=
name|CTF_ERR
operator|&&
operator|(
name|adp
operator|->
name|dtargd_xlate
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|adp
operator|->
name|dtargd_native
argument_list|,
name|adp
operator|->
name|dtargd_xlate
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|dt_node_type_propagate
argument_list|(
name|prp
operator|->
name|pr_nargv
index|[
name|adp
operator|->
name|dtargd_mapping
index|]
argument_list|,
name|prp
operator|->
name|pr_xargv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dtrace_type_strcompile
argument_list|(
name|dtp
argument_list|,
name|adp
operator|->
name|dtargd_xlate
argument_list|,
operator|&
name|dtt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to resolve output type %s "
literal|"for %s:%s arg #%d: %s\n"
argument_list|,
name|adp
operator|->
name|dtargd_xlate
argument_list|,
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|name
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dtt
operator|.
name|dtt_object
operator|=
name|NULL
expr_stmt|;
name|dtt
operator|.
name|dtt_ctfp
operator|=
name|NULL
expr_stmt|;
name|dtt
operator|.
name|dtt_type
operator|=
name|CTF_ERR
expr_stmt|;
block|}
else|else
block|{
name|dt_node_type_assign
argument_list|(
name|prp
operator|->
name|pr_xargv
index|[
name|i
index|]
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|prp
operator|->
name|pr_mapping
index|[
name|i
index|]
operator|=
name|adp
operator|->
name|dtargd_mapping
expr_stmt|;
name|prp
operator|->
name|pr_argv
index|[
name|i
index|]
operator|=
name|dtt
expr_stmt|;
block|}
return|return
operator|(
name|prp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup a probe declaration based on a known provider and full or partially  * specified module, function, and name.  If the probe is not known to us yet,  * ask dtrace(7D) to match the description and then cache any useful results.  */
end_comment

begin_function
name|dt_probe_t
modifier|*
name|dt_probe_lookup
parameter_list|(
name|dt_provider_t
modifier|*
name|pvp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|pvp
operator|->
name|pv_hdl
decl_stmt|;
name|dtrace_probedesc_t
name|pd
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|size_t
name|keylen
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
if|if
condition|(
name|dtrace_str2desc
argument_list|(
name|dtp
argument_list|,
name|DTRACE_PROBESPEC_NAME
argument_list|,
name|s
argument_list|,
operator|&
name|pd
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* dt_errno is set for us */
name|keylen
operator|=
name|dt_probe_keylen
argument_list|(
operator|&
name|pd
argument_list|)
expr_stmt|;
name|key
operator|=
name|dt_probe_key
argument_list|(
operator|&
name|pd
argument_list|,
name|alloca
argument_list|(
name|keylen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the probe is already declared, then return the dt_probe_t from 	 * the existing identifier.  This could come from a static declaration 	 * or it could have been cached from an earlier call to this function. 	 */
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|pvp
operator|->
name|pv_probes
argument_list|,
name|key
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|idp
operator|->
name|di_data
operator|)
return|;
comment|/* 	 * If the probe isn't known, use the probe description computed above 	 * to ask dtrace(7D) to find the first matching probe. 	 */
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_PROBEMATCH
argument_list|,
operator|&
name|pd
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|dt_probe_discover
argument_list|(
name|pvp
argument_list|,
operator|&
name|pd
argument_list|)
operator|)
return|;
if|if
condition|(
name|errno
operator|==
name|ESRCH
operator|||
name|errno
operator|==
name|EBADF
condition|)
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOPROBE
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|dt_probe_t
modifier|*
name|dt_probe_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|int
name|protoc
parameter_list|,
name|dt_node_t
modifier|*
name|nargs
parameter_list|,
name|uint_t
name|nargc
parameter_list|,
name|dt_node_t
modifier|*
name|xargs
parameter_list|,
name|uint_t
name|xargc
parameter_list|)
block|{
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
name|dt_probe_t
modifier|*
name|prp
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
name|assert
argument_list|(
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_PROBE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|idp
operator|->
name|di_data
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If only a single prototype is given, set xargc/s to nargc/s to 	 * simplify subsequent use.  Note that we can have one or both of nargs 	 * and xargs be specified but set to NULL, indicating a void prototype. 	 */
if|if
condition|(
name|protoc
operator|<
literal|2
condition|)
block|{
name|assert
argument_list|(
name|xargs
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|xargc
operator|==
literal|0
argument_list|)
expr_stmt|;
name|xargs
operator|=
name|nargs
expr_stmt|;
name|xargc
operator|=
name|nargc
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|prp
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_probe_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|prp
operator|->
name|pr_pvp
operator|=
name|NULL
expr_stmt|;
name|prp
operator|->
name|pr_ident
operator|=
name|idp
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|idp
operator|->
name|di_name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|prp
operator|->
name|pr_name
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|prp
operator|->
name|pr_nargs
operator|=
name|nargs
expr_stmt|;
name|prp
operator|->
name|pr_nargv
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_node_t
operator|*
argument_list|)
operator|*
name|nargc
argument_list|)
expr_stmt|;
name|prp
operator|->
name|pr_nargc
operator|=
name|nargc
expr_stmt|;
name|prp
operator|->
name|pr_xargs
operator|=
name|xargs
expr_stmt|;
name|prp
operator|->
name|pr_xargv
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_node_t
operator|*
argument_list|)
operator|*
name|xargc
argument_list|)
expr_stmt|;
name|prp
operator|->
name|pr_xargc
operator|=
name|xargc
expr_stmt|;
name|prp
operator|->
name|pr_mapping
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|xargc
argument_list|)
expr_stmt|;
name|prp
operator|->
name|pr_inst
operator|=
name|NULL
expr_stmt|;
name|prp
operator|->
name|pr_argv
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_typeinfo_t
argument_list|)
operator|*
name|xargc
argument_list|)
expr_stmt|;
name|prp
operator|->
name|pr_argc
operator|=
name|xargc
expr_stmt|;
if|if
condition|(
operator|(
name|prp
operator|->
name|pr_nargc
operator|!=
literal|0
operator|&&
name|prp
operator|->
name|pr_nargv
operator|==
name|NULL
operator|)
operator|||
operator|(
name|prp
operator|->
name|pr_xargc
operator|!=
literal|0
operator|&&
name|prp
operator|->
name|pr_xargv
operator|==
name|NULL
operator|)
operator|||
operator|(
name|prp
operator|->
name|pr_xargc
operator|!=
literal|0
operator|&&
name|prp
operator|->
name|pr_mapping
operator|==
name|NULL
operator|)
operator|||
operator|(
name|prp
operator|->
name|pr_argc
operator|!=
literal|0
operator|&&
name|prp
operator|->
name|pr_argv
operator|==
name|NULL
operator|)
condition|)
block|{
name|dt_probe_destroy
argument_list|(
name|prp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xargc
condition|;
name|i
operator|++
operator|,
name|xargs
operator|=
name|xargs
operator|->
name|dn_list
control|)
block|{
if|if
condition|(
name|xargs
operator|->
name|dn_string
operator|!=
name|NULL
condition|)
name|prp
operator|->
name|pr_mapping
index|[
name|i
index|]
operator|=
name|dt_probe_argmap
argument_list|(
name|xargs
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
else|else
name|prp
operator|->
name|pr_mapping
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|prp
operator|->
name|pr_xargv
index|[
name|i
index|]
operator|=
name|xargs
expr_stmt|;
if|if
condition|(
operator|(
name|dmp
operator|=
name|dt_module_lookup_by_ctf
argument_list|(
name|dtp
argument_list|,
name|xargs
operator|->
name|dn_ctfp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|prp
operator|->
name|pr_argv
index|[
name|i
index|]
operator|.
name|dtt_object
operator|=
name|dmp
operator|->
name|dm_name
expr_stmt|;
else|else
name|prp
operator|->
name|pr_argv
index|[
name|i
index|]
operator|.
name|dtt_object
operator|=
name|NULL
expr_stmt|;
name|prp
operator|->
name|pr_argv
index|[
name|i
index|]
operator|.
name|dtt_ctfp
operator|=
name|xargs
operator|->
name|dn_ctfp
expr_stmt|;
name|prp
operator|->
name|pr_argv
index|[
name|i
index|]
operator|.
name|dtt_type
operator|=
name|xargs
operator|->
name|dn_type
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargc
condition|;
name|i
operator|++
operator|,
name|nargs
operator|=
name|nargs
operator|->
name|dn_list
control|)
name|prp
operator|->
name|pr_nargv
index|[
name|i
index|]
operator|=
name|nargs
expr_stmt|;
name|idp
operator|->
name|di_data
operator|=
name|prp
expr_stmt|;
return|return
operator|(
name|prp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_probe_declare
parameter_list|(
name|dt_provider_t
modifier|*
name|pvp
parameter_list|,
name|dt_probe_t
modifier|*
name|prp
parameter_list|)
block|{
name|assert
argument_list|(
name|prp
operator|->
name|pr_ident
operator|->
name|di_kind
operator|==
name|DT_IDENT_PROBE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|prp
operator|->
name|pr_ident
operator|->
name|di_data
operator|==
name|prp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|prp
operator|->
name|pr_pvp
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|prp
operator|->
name|pr_xargs
operator|!=
name|prp
operator|->
name|pr_nargs
condition|)
name|pvp
operator|->
name|pv_flags
operator|&=
operator|~
name|DT_PROVIDER_INTF
expr_stmt|;
name|prp
operator|->
name|pr_pvp
operator|=
name|pvp
expr_stmt|;
name|dt_idhash_xinsert
argument_list|(
name|pvp
operator|->
name|pv_probes
argument_list|,
name|prp
operator|->
name|pr_ident
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_probe_destroy
parameter_list|(
name|dt_probe_t
modifier|*
name|prp
parameter_list|)
block|{
name|dt_probe_instance_t
modifier|*
name|pip
decl_stmt|,
modifier|*
name|pip_next
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
decl_stmt|;
if|if
condition|(
name|prp
operator|->
name|pr_pvp
operator|!=
name|NULL
condition|)
name|dtp
operator|=
name|prp
operator|->
name|pr_pvp
operator|->
name|pv_hdl
expr_stmt|;
else|else
name|dtp
operator|=
name|yypcb
operator|->
name|pcb_hdl
expr_stmt|;
name|dt_node_list_free
argument_list|(
operator|&
name|prp
operator|->
name|pr_nargs
argument_list|)
expr_stmt|;
name|dt_node_list_free
argument_list|(
operator|&
name|prp
operator|->
name|pr_xargs
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|prp
operator|->
name|pr_nargv
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|prp
operator|->
name|pr_xargv
argument_list|)
expr_stmt|;
for|for
control|(
name|pip
operator|=
name|prp
operator|->
name|pr_inst
init|;
name|pip
operator|!=
name|NULL
condition|;
name|pip
operator|=
name|pip_next
control|)
block|{
name|pip_next
operator|=
name|pip
operator|->
name|pi_next
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pip
operator|->
name|pi_offs
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pip
operator|->
name|pi_enoffs
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pip
argument_list|)
expr_stmt|;
block|}
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|prp
operator|->
name|pr_mapping
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|prp
operator|->
name|pr_argv
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|prp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dt_probe_define
parameter_list|(
name|dt_provider_t
modifier|*
name|pvp
parameter_list|,
name|dt_probe_t
modifier|*
name|prp
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
specifier|const
name|char
modifier|*
name|rname
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|int
name|isenabled
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|pvp
operator|->
name|pv_hdl
decl_stmt|;
name|dt_probe_instance_t
modifier|*
name|pip
decl_stmt|;
name|uint32_t
modifier|*
modifier|*
name|offs
decl_stmt|;
name|uint_t
modifier|*
name|noffs
decl_stmt|,
modifier|*
name|maxoffs
decl_stmt|;
name|assert
argument_list|(
name|fname
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|pip
operator|=
name|prp
operator|->
name|pr_inst
init|;
name|pip
operator|!=
name|NULL
condition|;
name|pip
operator|=
name|pip
operator|->
name|pi_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pip
operator|->
name|pi_fname
argument_list|,
name|fname
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|rname
operator|==
name|NULL
operator|&&
name|pip
operator|->
name|pi_rname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|rname
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|pip
operator|->
name|pi_rname
argument_list|,
name|rname
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|pip
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pip
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pip
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|pip
operator|->
name|pi_offs
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pip
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|pip
operator|->
name|pi_enoffs
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pip
operator|->
name|pi_offs
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pip
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pip
operator|->
name|pi_fname
argument_list|,
name|fname
argument_list|,
sizeof|sizeof
argument_list|(
name|pip
operator|->
name|pi_fname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|rname
argument_list|)
operator|+
literal|1
operator|>
sizeof|sizeof
argument_list|(
name|pip
operator|->
name|pi_rname
argument_list|)
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pip
operator|->
name|pi_offs
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pip
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_COMPILER
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pip
operator|->
name|pi_rname
argument_list|,
name|rname
argument_list|)
expr_stmt|;
block|}
name|pip
operator|->
name|pi_noffs
operator|=
literal|0
expr_stmt|;
name|pip
operator|->
name|pi_maxoffs
operator|=
literal|1
expr_stmt|;
name|pip
operator|->
name|pi_nenoffs
operator|=
literal|0
expr_stmt|;
name|pip
operator|->
name|pi_maxenoffs
operator|=
literal|1
expr_stmt|;
name|pip
operator|->
name|pi_next
operator|=
name|prp
operator|->
name|pr_inst
expr_stmt|;
name|prp
operator|->
name|pr_inst
operator|=
name|pip
expr_stmt|;
block|}
if|if
condition|(
name|isenabled
condition|)
block|{
name|offs
operator|=
operator|&
name|pip
operator|->
name|pi_enoffs
expr_stmt|;
name|noffs
operator|=
operator|&
name|pip
operator|->
name|pi_nenoffs
expr_stmt|;
name|maxoffs
operator|=
operator|&
name|pip
operator|->
name|pi_maxenoffs
expr_stmt|;
block|}
else|else
block|{
name|offs
operator|=
operator|&
name|pip
operator|->
name|pi_offs
expr_stmt|;
name|noffs
operator|=
operator|&
name|pip
operator|->
name|pi_noffs
expr_stmt|;
name|maxoffs
operator|=
operator|&
name|pip
operator|->
name|pi_maxoffs
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|noffs
operator|==
operator|*
name|maxoffs
condition|)
block|{
name|uint_t
name|new_max
init|=
operator|*
name|maxoffs
operator|*
literal|2
decl_stmt|;
name|uint32_t
modifier|*
name|new_offs
init|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|new_max
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_offs
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bcopy
argument_list|(
operator|*
name|offs
argument_list|,
name|new_offs
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
operator|*
name|maxoffs
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
operator|*
name|offs
argument_list|)
expr_stmt|;
operator|*
name|maxoffs
operator|=
name|new_max
expr_stmt|;
operator|*
name|offs
operator|=
name|new_offs
expr_stmt|;
block|}
name|dt_dprintf
argument_list|(
literal|"defined probe %s %s:%s %s() +0x%x (%s)\n"
argument_list|,
name|isenabled
condition|?
literal|"(is-enabled)"
else|:
literal|""
argument_list|,
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|prp
operator|->
name|pr_ident
operator|->
name|di_name
argument_list|,
name|fname
argument_list|,
name|offset
argument_list|,
name|rname
operator|!=
name|NULL
condition|?
name|rname
else|:
name|fname
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|noffs
operator|<
operator|*
name|maxoffs
argument_list|)
expr_stmt|;
operator|(
operator|*
name|offs
operator|)
index|[
operator|(
operator|*
name|noffs
operator|)
operator|++
index|]
operator|=
name|offset
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup the dynamic translator type tag for the specified probe argument and  * assign the type to the specified node.  If the type is not yet defined, add  * it to the "D" module's type container as a typedef for an unknown type.  */
end_comment

begin_function
name|dt_node_t
modifier|*
name|dt_probe_tag
parameter_list|(
name|dt_probe_t
modifier|*
name|prp
parameter_list|,
name|uint_t
name|argn
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|prp
operator|->
name|pr_pvp
operator|->
name|pv_hdl
decl_stmt|;
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|"__dtrace_%s___%s_arg%u"
argument_list|,
name|prp
operator|->
name|pr_pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|prp
operator|->
name|pr_name
argument_list|,
name|argn
argument_list|)
expr_stmt|;
name|tag
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tag
argument_list|,
name|len
operator|+
literal|1
argument_list|,
literal|"__dtrace_%s___%s_arg%u"
argument_list|,
name|prp
operator|->
name|pr_pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|prp
operator|->
name|pr_name
argument_list|,
name|argn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_lookup_by_type
argument_list|(
name|dtp
argument_list|,
name|DTRACE_OBJ_DDEFS
argument_list|,
name|tag
argument_list|,
operator|&
name|dtt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dtt
operator|.
name|dtt_object
operator|=
name|DTRACE_OBJ_DDEFS
expr_stmt|;
name|dtt
operator|.
name|dtt_ctfp
operator|=
name|DT_DYN_CTFP
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|dtt
operator|.
name|dtt_type
operator|=
name|ctf_add_typedef
argument_list|(
name|DT_DYN_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
name|tag
argument_list|,
name|DT_DYN_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtt
operator|.
name|dtt_type
operator|==
name|CTF_ERR
operator|||
name|ctf_update
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"cannot define type %s: %s\n"
argument_list|,
name|tag
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
name|dnp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_kind
operator|=
name|DT_NODE_TYPE
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|_dtrace_defattr
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_probe_desc
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|dtrace_probedesc_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|dtpd_id
operator|==
name|DTRACE_IDNONE
condition|)
block|{
name|bcopy
argument_list|(
name|pdp
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_probedesc_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|dt_probe_t
modifier|*
name|dt_probe_info
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|dtrace_probeinfo_t
modifier|*
name|pip
parameter_list|)
block|{
name|int
name|m_is_glob
init|=
name|pdp
operator|->
name|dtpd_mod
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|strisglob
argument_list|(
name|pdp
operator|->
name|dtpd_mod
argument_list|)
decl_stmt|;
name|int
name|f_is_glob
init|=
name|pdp
operator|->
name|dtpd_func
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|strisglob
argument_list|(
name|pdp
operator|->
name|dtpd_func
argument_list|)
decl_stmt|;
name|int
name|n_is_glob
init|=
name|pdp
operator|->
name|dtpd_name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|strisglob
argument_list|(
name|pdp
operator|->
name|dtpd_name
argument_list|)
decl_stmt|;
name|dt_probe_t
modifier|*
name|prp
init|=
name|NULL
decl_stmt|;
specifier|const
name|dtrace_pattr_t
modifier|*
name|pap
decl_stmt|;
name|dt_provider_t
modifier|*
name|pvp
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
comment|/* 	 * Attempt to lookup the probe in our existing cache for this provider. 	 * If none is found and an explicit probe ID was specified, discover 	 * that specific probe and cache its description and arguments. 	 */
if|if
condition|(
operator|(
name|pvp
operator|=
name|dt_provider_lookup
argument_list|(
name|dtp
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|keylen
init|=
name|dt_probe_keylen
argument_list|(
name|pdp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|key
init|=
name|dt_probe_key
argument_list|(
name|pdp
argument_list|,
name|alloca
argument_list|(
name|keylen
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|pvp
operator|->
name|pv_probes
argument_list|,
name|key
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|prp
operator|=
name|idp
operator|->
name|di_data
expr_stmt|;
elseif|else
if|if
condition|(
name|pdp
operator|->
name|dtpd_id
operator|!=
name|DTRACE_IDNONE
condition|)
name|prp
operator|=
name|dt_probe_discover
argument_list|(
name|pvp
argument_list|,
name|pdp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If no probe was found in our cache, convert the caller's partial 	 * probe description into a fully-formed matching probe description by 	 * iterating over up to at most two probes that match 'pdp'.  We then 	 * call dt_probe_discover() on the resulting probe identifier. 	 */
if|if
condition|(
name|prp
operator|==
name|NULL
condition|)
block|{
name|dtrace_probedesc_t
name|pd
decl_stmt|;
name|int
name|m
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|pd
argument_list|,
sizeof|sizeof
argument_list|(
name|pd
argument_list|)
argument_list|)
expr_stmt|;
name|pd
operator|.
name|dtpd_id
operator|=
name|DTRACE_IDNONE
expr_stmt|;
comment|/* 		 * Call dtrace_probe_iter() to find matching probes.  Our 		 * dt_probe_desc() callback will produce the following results: 		 * 		 * m< 0 dtrace_probe_iter() found zero matches (or failed). 		 * m> 0 dtrace_probe_iter() found more than one match. 		 * m = 0 dtrace_probe_iter() found exactly one match. 		 */
if|if
condition|(
operator|(
name|m
operator|=
name|dtrace_probe_iter
argument_list|(
name|dtp
argument_list|,
name|pdp
argument_list|,
name|dt_probe_desc
argument_list|,
operator|&
name|pd
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* dt_errno is set for us */
if|if
condition|(
operator|(
name|pvp
operator|=
name|dt_provider_lookup
argument_list|(
name|dtp
argument_list|,
name|pd
operator|.
name|dtpd_provider
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* dt_errno is set for us */
comment|/* 		 * If more than one probe was matched, then do not report probe 		 * information if either of the following conditions is true: 		 * 		 * (a) The Arguments Data stability of the matched provider is 		 *	less than Evolving. 		 * 		 * (b) Any description component that is at least Evolving is 		 *	empty or is specified using a globbing expression. 		 * 		 * These conditions imply that providers that provide Evolving 		 * or better Arguments Data stability must guarantee that all 		 * probes with identical field names in a field of Evolving or 		 * better Name stability have identical argument signatures. 		 */
if|if
condition|(
name|m
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
operator|.
name|dtpa_args
operator|.
name|dtat_data
operator|<
name|DTRACE_STABILITY_EVOLVING
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_UNSTABLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
operator|.
name|dtpa_mod
operator|.
name|dtat_name
operator|>=
name|DTRACE_STABILITY_EVOLVING
operator|&&
name|m_is_glob
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_UNSTABLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
operator|.
name|dtpa_func
operator|.
name|dtat_name
operator|>=
name|DTRACE_STABILITY_EVOLVING
operator|&&
name|f_is_glob
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_UNSTABLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
operator|.
name|dtpa_name
operator|.
name|dtat_name
operator|>=
name|DTRACE_STABILITY_EVOLVING
operator|&&
name|n_is_glob
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_UNSTABLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 		 * If we matched a probe exported by dtrace(7D), then discover 		 * the real attributes.  Otherwise grab the static declaration. 		 */
if|if
condition|(
name|pd
operator|.
name|dtpd_id
operator|!=
name|DTRACE_IDNONE
condition|)
name|prp
operator|=
name|dt_probe_discover
argument_list|(
name|pvp
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
else|else
name|prp
operator|=
name|dt_probe_lookup
argument_list|(
name|pvp
argument_list|,
name|pd
operator|.
name|dtpd_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|prp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* dt_errno is set for us */
block|}
name|assert
argument_list|(
name|pvp
operator|!=
name|NULL
operator|&&
name|prp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the probe description attributes by taking the minimum of 	 * the attributes of the specified fields.  If no provider is specified 	 * or a glob pattern is used for the provider, use Unstable attributes. 	 */
if|if
condition|(
name|pdp
operator|->
name|dtpd_provider
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|strisglob
argument_list|(
name|pdp
operator|->
name|dtpd_provider
argument_list|)
condition|)
name|pap
operator|=
operator|&
name|_dtrace_prvdesc
expr_stmt|;
else|else
name|pap
operator|=
operator|&
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
expr_stmt|;
name|pip
operator|->
name|dtp_attr
operator|=
name|pap
operator|->
name|dtpa_provider
expr_stmt|;
if|if
condition|(
operator|!
name|m_is_glob
condition|)
name|pip
operator|->
name|dtp_attr
operator|=
name|dt_attr_min
argument_list|(
name|pip
operator|->
name|dtp_attr
argument_list|,
name|pap
operator|->
name|dtpa_mod
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f_is_glob
condition|)
name|pip
operator|->
name|dtp_attr
operator|=
name|dt_attr_min
argument_list|(
name|pip
operator|->
name|dtp_attr
argument_list|,
name|pap
operator|->
name|dtpa_func
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n_is_glob
condition|)
name|pip
operator|->
name|dtp_attr
operator|=
name|dt_attr_min
argument_list|(
name|pip
operator|->
name|dtp_attr
argument_list|,
name|pap
operator|->
name|dtpa_name
argument_list|)
expr_stmt|;
name|pip
operator|->
name|dtp_arga
operator|=
name|pap
operator|->
name|dtpa_args
expr_stmt|;
name|pip
operator|->
name|dtp_argv
operator|=
name|prp
operator|->
name|pr_argv
expr_stmt|;
name|pip
operator|->
name|dtp_argc
operator|=
name|prp
operator|->
name|pr_argc
expr_stmt|;
return|return
operator|(
name|prp
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_probe_info
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|dtrace_probeinfo_t
modifier|*
name|pip
parameter_list|)
block|{
return|return
operator|(
name|dt_probe_info
argument_list|(
name|dtp
argument_list|,
name|pdp
argument_list|,
name|pip
argument_list|)
operator|!=
name|NULL
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_probe_iter
parameter_list|(
name|dt_idhash_t
modifier|*
name|ihp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|dt_probe_iter_t
modifier|*
name|pit
parameter_list|)
block|{
specifier|const
name|dt_probe_t
modifier|*
name|prp
init|=
name|idp
operator|->
name|di_data
decl_stmt|;
if|if
condition|(
operator|!
name|dt_gmatch
argument_list|(
name|prp
operator|->
name|pr_name
argument_list|,
name|pit
operator|->
name|pit_pat
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* continue on and examine next probe in hash */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pit
operator|->
name|pit_desc
operator|.
name|dtpd_name
argument_list|,
name|prp
operator|->
name|pr_name
argument_list|,
name|DTRACE_NAMELEN
argument_list|)
expr_stmt|;
name|pit
operator|->
name|pit_desc
operator|.
name|dtpd_id
operator|=
name|idp
operator|->
name|di_id
expr_stmt|;
name|pit
operator|->
name|pit_matches
operator|++
expr_stmt|;
return|return
operator|(
name|pit
operator|->
name|pit_func
argument_list|(
name|pit
operator|->
name|pit_hdl
argument_list|,
operator|&
name|pit
operator|->
name|pit_desc
argument_list|,
name|pit
operator|->
name|pit_arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_probe_iter
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|dtrace_probe_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|provider
init|=
name|pdp
condition|?
name|pdp
operator|->
name|dtpd_provider
else|:
name|NULL
decl_stmt|;
name|dtrace_id_t
name|id
init|=
name|DTRACE_IDNONE
decl_stmt|;
name|dtrace_probedesc_t
name|pd
decl_stmt|;
name|dt_probe_iter_t
name|pit
decl_stmt|;
name|int
name|cmd
decl_stmt|,
name|rv
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|pit
argument_list|,
sizeof|sizeof
argument_list|(
name|pit
argument_list|)
argument_list|)
expr_stmt|;
name|pit
operator|.
name|pit_hdl
operator|=
name|dtp
expr_stmt|;
name|pit
operator|.
name|pit_func
operator|=
name|func
expr_stmt|;
name|pit
operator|.
name|pit_arg
operator|=
name|arg
expr_stmt|;
name|pit
operator|.
name|pit_pat
operator|=
name|pdp
condition|?
name|pdp
operator|->
name|dtpd_name
else|:
name|NULL
expr_stmt|;
for|for
control|(
name|pit
operator|.
name|pit_pvp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_provlist
argument_list|)
init|;
name|pit
operator|.
name|pit_pvp
operator|!=
name|NULL
condition|;
name|pit
operator|.
name|pit_pvp
operator|=
name|dt_list_next
argument_list|(
name|pit
operator|.
name|pit_pvp
argument_list|)
control|)
block|{
if|if
condition|(
name|pit
operator|.
name|pit_pvp
operator|->
name|pv_flags
operator|&
name|DT_PROVIDER_IMPL
condition|)
continue|continue;
comment|/* we'll get these later using dt_ioctl() */
if|if
condition|(
operator|!
name|dt_gmatch
argument_list|(
name|pit
operator|.
name|pit_pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|provider
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pit
operator|.
name|pit_desc
operator|.
name|dtpd_provider
argument_list|,
name|pit
operator|.
name|pit_pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|DTRACE_PROVNAMELEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|dt_idhash_iter
argument_list|(
name|pit
operator|.
name|pit_pvp
operator|->
name|pv_probes
argument_list|,
operator|(
name|dt_idhash_f
operator|*
operator|)
name|dt_probe_iter
argument_list|,
operator|&
name|pit
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
if|if
condition|(
name|pdp
operator|!=
name|NULL
condition|)
name|cmd
operator|=
name|DTRACEIOC_PROBEMATCH
expr_stmt|;
else|else
name|cmd
operator|=
name|DTRACEIOC_PROBES
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pdp
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|pdp
argument_list|,
operator|&
name|pd
argument_list|,
sizeof|sizeof
argument_list|(
name|pd
argument_list|)
argument_list|)
expr_stmt|;
name|pd
operator|.
name|dtpd_id
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|cmd
argument_list|,
operator|&
name|pd
argument_list|)
operator|!=
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
operator|(
name|rv
operator|=
name|func
argument_list|(
name|dtp
argument_list|,
operator|&
name|pd
argument_list|,
name|arg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|pit
operator|.
name|pit_matches
operator|++
expr_stmt|;
name|id
operator|=
name|pd
operator|.
name|dtpd_id
operator|+
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ESRCH
case|:
case|case
name|EBADF
case|:
return|return
operator|(
name|pit
operator|.
name|pit_matches
condition|?
literal|0
else|:
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOPROBE
argument_list|)
operator|)
return|;
case|case
name|EINVAL
case|:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADPGLOB
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
block|}
end_function

end_unit

