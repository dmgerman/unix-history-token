begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_include
include|#
directive|include
file|<dt_program.h>
end_include

begin_include
include|#
directive|include
file|<dt_printf.h>
end_include

begin_include
include|#
directive|include
file|<dt_provider.h>
end_include

begin_function
name|dtrace_prog_t
modifier|*
name|dt_program_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dtrace_prog_t
modifier|*
name|pgp
init|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_prog_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pgp
operator|!=
name|NULL
condition|)
block|{
name|dt_list_append
argument_list|(
operator|&
name|dtp
operator|->
name|dt_programs
argument_list|,
name|pgp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * By default, programs start with DOF version 1 so that output files 	 * containing DOF are backward compatible. If a program requires new 	 * DOF features, the version is increased as needed. 	 */
name|pgp
operator|->
name|dp_dofversion
operator|=
name|DOF_VERSION_1
expr_stmt|;
return|return
operator|(
name|pgp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_program_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_prog_t
modifier|*
name|pgp
parameter_list|)
block|{
name|dt_stmt_t
modifier|*
name|stp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
for|for
control|(
name|stp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|pgp
operator|->
name|dp_stmts
argument_list|)
init|;
name|stp
operator|!=
name|NULL
condition|;
name|stp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|dt_list_next
argument_list|(
name|stp
argument_list|)
expr_stmt|;
name|dtrace_stmt_destroy
argument_list|(
name|dtp
argument_list|,
name|stp
operator|->
name|ds_desc
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|stp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pgp
operator|->
name|dp_xrefslen
condition|;
name|i
operator|++
control|)
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pgp
operator|->
name|dp_xrefs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pgp
operator|->
name|dp_xrefs
argument_list|)
expr_stmt|;
name|dt_list_delete
argument_list|(
operator|&
name|dtp
operator|->
name|dt_programs
argument_list|,
name|pgp
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pgp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|dtrace_program_info
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_prog_t
modifier|*
name|pgp
parameter_list|,
name|dtrace_proginfo_t
modifier|*
name|pip
parameter_list|)
block|{
name|dt_stmt_t
modifier|*
name|stp
decl_stmt|;
name|dtrace_actdesc_t
modifier|*
name|ap
decl_stmt|;
name|dtrace_ecbdesc_t
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pip
operator|==
name|NULL
condition|)
return|return;
name|bzero
argument_list|(
name|pip
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_proginfo_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_list_next
argument_list|(
operator|&
name|pgp
operator|->
name|dp_stmts
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|pip
operator|->
name|dpi_descattr
operator|=
name|_dtrace_maxattr
expr_stmt|;
name|pip
operator|->
name|dpi_stmtattr
operator|=
name|_dtrace_maxattr
expr_stmt|;
block|}
else|else
block|{
name|pip
operator|->
name|dpi_descattr
operator|=
name|_dtrace_defattr
expr_stmt|;
name|pip
operator|->
name|dpi_stmtattr
operator|=
name|_dtrace_defattr
expr_stmt|;
block|}
for|for
control|(
name|stp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|pgp
operator|->
name|dp_stmts
argument_list|)
init|;
name|stp
condition|;
name|stp
operator|=
name|dt_list_next
argument_list|(
name|stp
argument_list|)
control|)
block|{
name|dtrace_ecbdesc_t
modifier|*
name|edp
init|=
name|stp
operator|->
name|ds_desc
operator|->
name|dtsd_ecbdesc
decl_stmt|;
if|if
condition|(
name|edp
operator|==
name|last
condition|)
continue|continue;
name|last
operator|=
name|edp
expr_stmt|;
name|pip
operator|->
name|dpi_descattr
operator|=
name|dt_attr_min
argument_list|(
name|stp
operator|->
name|ds_desc
operator|->
name|dtsd_descattr
argument_list|,
name|pip
operator|->
name|dpi_descattr
argument_list|)
expr_stmt|;
name|pip
operator|->
name|dpi_stmtattr
operator|=
name|dt_attr_min
argument_list|(
name|stp
operator|->
name|ds_desc
operator|->
name|dtsd_stmtattr
argument_list|,
name|pip
operator|->
name|dpi_stmtattr
argument_list|)
expr_stmt|;
comment|/* 		 * If there aren't any actions, account for the fact that 		 * recording the epid will generate a record. 		 */
if|if
condition|(
name|edp
operator|->
name|dted_action
operator|==
name|NULL
condition|)
name|pip
operator|->
name|dpi_recgens
operator|++
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|edp
operator|->
name|dted_action
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|dtad_next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|dtad_kind
operator|==
name|DTRACEACT_SPECULATE
condition|)
block|{
name|pip
operator|->
name|dpi_speculations
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|DTRACEACT_ISAGG
argument_list|(
name|ap
operator|->
name|dtad_kind
argument_list|)
condition|)
block|{
name|pip
operator|->
name|dpi_recgens
operator|-=
name|ap
operator|->
name|dtad_arg
expr_stmt|;
name|pip
operator|->
name|dpi_aggregates
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|DTRACEACT_ISDESTRUCTIVE
argument_list|(
name|ap
operator|->
name|dtad_kind
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ap
operator|->
name|dtad_kind
operator|==
name|DTRACEACT_DIFEXPR
operator|&&
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|.
name|dtdt_kind
operator|==
name|DIF_TYPE_CTF
operator|&&
name|ap
operator|->
name|dtad_difo
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
operator|==
literal|0
condition|)
continue|continue;
name|pip
operator|->
name|dpi_recgens
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|dtrace_program_exec
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_prog_t
modifier|*
name|pgp
parameter_list|,
name|dtrace_proginfo_t
modifier|*
name|pip
parameter_list|)
block|{
name|dtrace_enable_io_t
name|args
decl_stmt|;
name|void
modifier|*
name|dof
decl_stmt|;
name|int
name|n
decl_stmt|,
name|err
decl_stmt|;
name|dtrace_program_info
argument_list|(
name|dtp
argument_list|,
name|pgp
argument_list|,
name|pip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dof
operator|=
name|dtrace_dof_create
argument_list|(
name|dtp
argument_list|,
name|pgp
argument_list|,
name|DTRACE_D_STRIP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|args
operator|.
name|dof
operator|=
name|dof
expr_stmt|;
name|args
operator|.
name|n_matched
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_ENABLE
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dtp
argument_list|,
name|dof
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINVAL
case|:
name|err
operator|=
name|EDT_DIFINVAL
expr_stmt|;
break|break;
case|case
name|EFAULT
case|:
name|err
operator|=
name|EDT_DIFFAULT
expr_stmt|;
break|break;
case|case
name|E2BIG
case|:
name|err
operator|=
name|EDT_DIFSIZE
expr_stmt|;
break|break;
case|case
name|EBUSY
case|:
name|err
operator|=
name|EDT_ENABLING_ERR
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|errno
expr_stmt|;
block|}
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|err
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|pip
operator|!=
name|NULL
condition|)
name|pip
operator|->
name|dpi_matches
operator|+=
name|args
operator|.
name|n_matched
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_ecbdesc_hold
parameter_list|(
name|dtrace_ecbdesc_t
modifier|*
name|edp
parameter_list|)
block|{
name|edp
operator|->
name|dted_refcnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_ecbdesc_release
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_ecbdesc_t
modifier|*
name|edp
parameter_list|)
block|{
if|if
condition|(
operator|--
name|edp
operator|->
name|dted_refcnt
operator|>
literal|0
condition|)
return|return;
name|dt_difo_free
argument_list|(
name|dtp
argument_list|,
name|edp
operator|->
name|dted_pred
operator|.
name|dtpdd_difo
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|edp
operator|->
name|dted_action
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|edp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dtrace_ecbdesc_t
modifier|*
name|dt_ecbdesc_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|)
block|{
name|dtrace_ecbdesc_t
modifier|*
name|edp
decl_stmt|;
if|if
condition|(
operator|(
name|edp
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_ecbdesc_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|edp
operator|->
name|dted_probe
operator|=
operator|*
name|pdp
expr_stmt|;
name|dt_ecbdesc_hold
argument_list|(
name|edp
argument_list|)
expr_stmt|;
return|return
operator|(
name|edp
operator|)
return|;
block|}
end_function

begin_function
name|dtrace_stmtdesc_t
modifier|*
name|dtrace_stmt_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_ecbdesc_t
modifier|*
name|edp
parameter_list|)
block|{
name|dtrace_stmtdesc_t
modifier|*
name|sdp
decl_stmt|;
if|if
condition|(
operator|(
name|sdp
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_stmtdesc_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dt_ecbdesc_hold
argument_list|(
name|edp
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|dtsd_ecbdesc
operator|=
name|edp
expr_stmt|;
name|sdp
operator|->
name|dtsd_descattr
operator|=
name|_dtrace_defattr
expr_stmt|;
name|sdp
operator|->
name|dtsd_stmtattr
operator|=
name|_dtrace_defattr
expr_stmt|;
return|return
operator|(
name|sdp
operator|)
return|;
block|}
end_function

begin_function
name|dtrace_actdesc_t
modifier|*
name|dtrace_stmt_action
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|new
decl_stmt|;
name|dtrace_ecbdesc_t
modifier|*
name|edp
init|=
name|sdp
operator|->
name|dtsd_ecbdesc
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_actdesc_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|sdp
operator|->
name|dtsd_action_last
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|sdp
operator|->
name|dtsd_action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sdp
operator|->
name|dtsd_action_last
operator|->
name|dtad_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|dtsd_action_last
operator|->
name|dtad_next
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|edp
operator|->
name|dted_action
decl_stmt|;
name|assert
argument_list|(
name|sdp
operator|->
name|dtsd_action
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|sdp
operator|->
name|dtsd_action
operator|=
name|new
expr_stmt|;
while|while
condition|(
name|ap
operator|!=
name|NULL
operator|&&
name|ap
operator|->
name|dtad_next
operator|!=
name|NULL
condition|)
name|ap
operator|=
name|ap
operator|->
name|dtad_next
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
name|edp
operator|->
name|dted_action
operator|=
name|new
expr_stmt|;
else|else
name|ap
operator|->
name|dtad_next
operator|=
name|new
expr_stmt|;
block|}
name|sdp
operator|->
name|dtsd_action_last
operator|=
name|new
expr_stmt|;
name|bzero
argument_list|(
name|new
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_actdesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|dtad_uarg
operator|=
operator|(
name|uintptr_t
operator|)
name|sdp
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_stmt_add
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_prog_t
modifier|*
name|pgp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dt_stmt_t
modifier|*
name|stp
init|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_stmt_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|stp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
name|dt_list_append
argument_list|(
operator|&
name|pgp
operator|->
name|dp_stmts
argument_list|,
name|stp
argument_list|)
expr_stmt|;
name|stp
operator|->
name|ds_desc
operator|=
name|sdp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_stmt_iter
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_prog_t
modifier|*
name|pgp
parameter_list|,
name|dtrace_stmt_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|dt_stmt_t
modifier|*
name|stp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
for|for
control|(
name|stp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|pgp
operator|->
name|dp_stmts
argument_list|)
init|;
name|stp
operator|!=
name|NULL
condition|;
name|stp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|dt_list_next
argument_list|(
name|stp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|func
argument_list|(
name|dtp
argument_list|,
name|pgp
argument_list|,
name|stp
operator|->
name|ds_desc
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dtrace_stmt_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|sdp
parameter_list|)
block|{
name|dtrace_ecbdesc_t
modifier|*
name|edp
init|=
name|sdp
operator|->
name|dtsd_ecbdesc
decl_stmt|;
comment|/* 	 * We need to remove any actions that we have on this ECB, and 	 * remove our hold on the ECB itself. 	 */
if|if
condition|(
name|sdp
operator|->
name|dtsd_action
operator|!=
name|NULL
condition|)
block|{
name|dtrace_actdesc_t
modifier|*
name|last
init|=
name|sdp
operator|->
name|dtsd_action_last
decl_stmt|;
name|dtrace_actdesc_t
modifier|*
name|ap
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|assert
argument_list|(
name|last
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|edp
operator|->
name|dted_action
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|dtad_next
control|)
block|{
if|if
condition|(
name|ap
operator|==
name|sdp
operator|->
name|dtsd_action
condition|)
break|break;
if|if
condition|(
name|ap
operator|->
name|dtad_next
operator|==
name|sdp
operator|->
name|dtsd_action
condition|)
break|break;
block|}
name|assert
argument_list|(
name|ap
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|edp
operator|->
name|dted_action
condition|)
name|edp
operator|->
name|dted_action
operator|=
name|last
operator|->
name|dtad_next
expr_stmt|;
else|else
name|ap
operator|->
name|dtad_next
operator|=
name|last
operator|->
name|dtad_next
expr_stmt|;
comment|/* 		 * We have now removed our action list from its ECB; we can 		 * safely destroy the list. 		 */
name|last
operator|->
name|dtad_next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|sdp
operator|->
name|dtsd_action
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|next
control|)
block|{
name|assert
argument_list|(
name|ap
operator|->
name|dtad_uarg
operator|==
operator|(
name|uintptr_t
operator|)
name|sdp
argument_list|)
expr_stmt|;
name|dt_difo_free
argument_list|(
name|dtp
argument_list|,
name|ap
operator|->
name|dtad_difo
argument_list|)
expr_stmt|;
name|next
operator|=
name|ap
operator|->
name|dtad_next
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sdp
operator|->
name|dtsd_fmtdata
operator|!=
name|NULL
condition|)
name|dt_printf_destroy
argument_list|(
name|sdp
operator|->
name|dtsd_fmtdata
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|sdp
operator|->
name|dtsd_strdata
argument_list|)
expr_stmt|;
name|dt_ecbdesc_release
argument_list|(
name|dtp
argument_list|,
name|sdp
operator|->
name|dtsd_ecbdesc
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|sdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dt_header_info
block|{
name|dtrace_hdl_t
modifier|*
name|dthi_dtp
decl_stmt|;
comment|/* consumer handle */
name|FILE
modifier|*
name|dthi_out
decl_stmt|;
comment|/* output file */
name|char
modifier|*
name|dthi_pmname
decl_stmt|;
comment|/* provider macro name */
name|char
modifier|*
name|dthi_pfname
decl_stmt|;
comment|/* provider function name */
name|int
name|dthi_empty
decl_stmt|;
comment|/* should we generate empty macros */
block|}
name|dt_header_info_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|dt_header_fmt_macro
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|islower
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
operator|*
name|str
operator|++
operator|+
literal|'A'
operator|-
literal|'a'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
literal|'_'
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'.'
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
literal|'_'
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|buf
operator|++
operator|=
operator|*
name|str
operator|++
operator|)
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dt_header_fmt_func
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'_'
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|buf
operator|++
operator|=
operator|*
name|str
operator|++
operator|)
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_header_decl
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|dt_header_info_t
modifier|*
name|infop
init|=
name|data
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|infop
operator|->
name|dthi_dtp
decl_stmt|;
name|dt_probe_t
modifier|*
name|prp
init|=
name|idp
operator|->
name|di_data
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
name|char
name|buf
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|prp
operator|->
name|pr_name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|p
operator|++
expr_stmt|;
name|fname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|prp
operator|->
name|pr_name
argument_list|)
operator|+
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
name|dt_header_fmt_func
argument_list|(
name|fname
argument_list|,
name|prp
operator|->
name|pr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|"extern void __dtrace_%s___%s("
argument_list|,
name|infop
operator|->
name|dthi_pfname
argument_list|,
name|fname
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
for|for
control|(
name|dnp
operator|=
name|prp
operator|->
name|pr_nargs
operator|,
name|i
operator|=
literal|0
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|"%s"
argument_list|,
name|ctf_type_name
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|prp
operator|->
name|pr_nargc
operator|&&
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|", "
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|"void"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|");\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|"#ifndef\t__sparc\n"
literal|"extern int __dtraceenabled_%s___%s(void);\n"
literal|"#else\n"
literal|"extern int __dtraceenabled_%s___%s(long);\n"
literal|"#endif\n"
argument_list|,
name|infop
operator|->
name|dthi_pfname
argument_list|,
name|fname
argument_list|,
name|infop
operator|->
name|dthi_pfname
argument_list|,
name|fname
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_header_probe
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|dt_header_info_t
modifier|*
name|infop
init|=
name|data
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|infop
operator|->
name|dthi_dtp
decl_stmt|;
name|dt_probe_t
modifier|*
name|prp
init|=
name|idp
operator|->
name|di_data
decl_stmt|;
name|char
modifier|*
name|mname
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|prp
operator|->
name|pr_name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|p
operator|++
expr_stmt|;
name|mname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|prp
operator|->
name|pr_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dt_header_fmt_macro
argument_list|(
name|mname
argument_list|,
name|prp
operator|->
name|pr_name
argument_list|)
expr_stmt|;
name|fname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|prp
operator|->
name|pr_name
argument_list|)
operator|+
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
name|dt_header_fmt_func
argument_list|(
name|fname
argument_list|,
name|prp
operator|->
name|pr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|"#define\t%s_%s("
argument_list|,
name|infop
operator|->
name|dthi_pmname
argument_list|,
name|mname
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prp
operator|->
name|pr_nargc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|"arg%d"
argument_list|,
name|i
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|prp
operator|->
name|pr_nargc
operator|&&
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|", "
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|infop
operator|->
name|dthi_empty
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|") \\\n\t"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|"__dtrace_%s___%s("
argument_list|,
name|infop
operator|->
name|dthi_pfname
argument_list|,
name|fname
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prp
operator|->
name|pr_nargc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|"arg%d"
argument_list|,
name|i
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|prp
operator|->
name|pr_nargc
operator|&&
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|", "
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|")\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|infop
operator|->
name|dthi_empty
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|"#ifndef\t__sparc\n"
literal|"#define\t%s_%s_ENABLED() \\\n"
literal|"\t__dtraceenabled_%s___%s()\n"
literal|"#else\n"
literal|"#define\t%s_%s_ENABLED() \\\n"
literal|"\t__dtraceenabled_%s___%s(0)\n"
literal|"#endif\n"
argument_list|,
name|infop
operator|->
name|dthi_pmname
argument_list|,
name|mname
argument_list|,
name|infop
operator|->
name|dthi_pfname
argument_list|,
name|fname
argument_list|,
name|infop
operator|->
name|dthi_pmname
argument_list|,
name|mname
argument_list|,
name|infop
operator|->
name|dthi_pfname
argument_list|,
name|fname
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|infop
operator|->
name|dthi_out
argument_list|,
literal|"#define\t%s_%s_ENABLED() (0)\n"
argument_list|,
name|infop
operator|->
name|dthi_pmname
argument_list|,
name|mname
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_header_provider
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_provider_t
modifier|*
name|pvp
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|dt_header_info_t
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pvp
operator|->
name|pv_flags
operator|&
name|DT_PROVIDER_IMPL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Count the instances of the '-' character since we'll need to double 	 * those up. 	 */
name|p
operator|=
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|p
operator|++
expr_stmt|;
name|info
operator|.
name|dthi_dtp
operator|=
name|dtp
expr_stmt|;
name|info
operator|.
name|dthi_out
operator|=
name|out
expr_stmt|;
name|info
operator|.
name|dthi_empty
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|dthi_pmname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dt_header_fmt_macro
argument_list|(
name|info
operator|.
name|dthi_pmname
argument_list|,
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|)
expr_stmt|;
name|info
operator|.
name|dthi_pfname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|)
operator|+
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
name|dt_header_fmt_func
argument_list|(
name|info
operator|.
name|dthi_pfname
argument_list|,
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#include<sys/sdt.h>\n\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#if _DTRACE_VERSION\n\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
name|dt_idhash_iter
argument_list|(
name|pvp
operator|->
name|pv_probes
argument_list|,
name|dt_header_probe
argument_list|,
operator|&
name|info
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dt_errno is set for us */
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
name|dt_idhash_iter
argument_list|(
name|pvp
operator|->
name|pv_probes
argument_list|,
name|dt_header_decl
argument_list|,
operator|&
name|info
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dt_errno is set for us */
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n#else\n\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
name|info
operator|.
name|dthi_empty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dt_idhash_iter
argument_list|(
name|pvp
operator|->
name|pv_probes
argument_list|,
name|dt_header_probe
argument_list|,
operator|&
name|info
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dt_errno is set for us */
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n#endif\n\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_program_header
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|dt_provider_t
modifier|*
name|pvp
decl_stmt|;
name|char
modifier|*
name|mfname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|fname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|mfname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dt_header_fmt_macro
argument_list|(
name|mfname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#ifndef\t_%s\n#define\t_%s\n\n"
argument_list|,
name|mfname
argument_list|,
name|mfname
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#include<unistd.h>\n\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|pvp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_provlist
argument_list|)
init|;
name|pvp
operator|!=
name|NULL
condition|;
name|pvp
operator|=
name|dt_list_next
argument_list|(
name|pvp
argument_list|)
control|)
block|{
if|if
condition|(
name|dt_header_provider
argument_list|(
name|dtp
argument_list|,
name|pvp
argument_list|,
name|out
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dt_errno is set for us */
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n#ifdef\t__cplusplus\n}\n#endif\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
name|fname
operator|!=
name|NULL
operator|&&
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n#endif\t/* _%s */\n"
argument_list|,
name|mfname
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

