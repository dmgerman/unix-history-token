begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011 by Delphix. All rights reserved.  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_include
include|#
directive|include
file|<dt_strtab.h>
end_include

begin_include
include|#
directive|include
file|<dt_program.h>
end_include

begin_include
include|#
directive|include
file|<dt_provider.h>
end_include

begin_include
include|#
directive|include
file|<dt_xlator.h>
end_include

begin_include
include|#
directive|include
file|<dt_dof.h>
end_include

begin_function
name|void
name|dt_dof_init
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dt_dof_t
modifier|*
name|ddo
init|=
operator|&
name|dtp
operator|->
name|dt_dof
decl_stmt|;
name|ddo
operator|->
name|ddo_hdl
operator|=
name|dtp
expr_stmt|;
name|ddo
operator|->
name|ddo_nsecs
operator|=
literal|0
expr_stmt|;
name|ddo
operator|->
name|ddo_strsec
operator|=
name|DOF_SECIDX_NONE
expr_stmt|;
name|ddo
operator|->
name|ddo_xlimport
operator|=
name|NULL
expr_stmt|;
name|ddo
operator|->
name|ddo_xlexport
operator|=
name|NULL
expr_stmt|;
name|dt_buf_create
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_secs
argument_list|,
literal|"section headers"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dt_buf_create
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_strs
argument_list|,
literal|"string table"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dt_buf_create
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_ldata
argument_list|,
literal|"loadable data"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dt_buf_create
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_udata
argument_list|,
literal|"unloadable data"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dt_buf_create
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_probes
argument_list|,
literal|"probe data"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dt_buf_create
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_args
argument_list|,
literal|"probe args"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dt_buf_create
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_offs
argument_list|,
literal|"probe offs"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dt_buf_create
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_enoffs
argument_list|,
literal|"probe is-enabled offs"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dt_buf_create
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_rels
argument_list|,
literal|"probe rels"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dt_buf_create
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_xlms
argument_list|,
literal|"xlate members"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_dof_fini
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dt_dof_t
modifier|*
name|ddo
init|=
operator|&
name|dtp
operator|->
name|dt_dof
decl_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|ddo
operator|->
name|ddo_xlimport
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|ddo
operator|->
name|ddo_xlexport
argument_list|)
expr_stmt|;
name|dt_buf_destroy
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_secs
argument_list|)
expr_stmt|;
name|dt_buf_destroy
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_strs
argument_list|)
expr_stmt|;
name|dt_buf_destroy
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_ldata
argument_list|)
expr_stmt|;
name|dt_buf_destroy
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_udata
argument_list|)
expr_stmt|;
name|dt_buf_destroy
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_probes
argument_list|)
expr_stmt|;
name|dt_buf_destroy
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_args
argument_list|)
expr_stmt|;
name|dt_buf_destroy
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_offs
argument_list|)
expr_stmt|;
name|dt_buf_destroy
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_enoffs
argument_list|)
expr_stmt|;
name|dt_buf_destroy
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_rels
argument_list|)
expr_stmt|;
name|dt_buf_destroy
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_xlms
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_dof_reset
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_prog_t
modifier|*
name|pgp
parameter_list|)
block|{
name|dt_dof_t
modifier|*
name|ddo
init|=
operator|&
name|dtp
operator|->
name|dt_dof
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|nx
init|=
name|dtp
operator|->
name|dt_xlatorid
decl_stmt|;
name|assert
argument_list|(
name|ddo
operator|->
name|ddo_hdl
operator|==
name|dtp
argument_list|)
expr_stmt|;
name|ddo
operator|->
name|ddo_pgp
operator|=
name|pgp
expr_stmt|;
name|ddo
operator|->
name|ddo_nsecs
operator|=
literal|0
expr_stmt|;
name|ddo
operator|->
name|ddo_strsec
operator|=
name|DOF_SECIDX_NONE
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|ddo
operator|->
name|ddo_xlimport
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|ddo
operator|->
name|ddo_xlexport
argument_list|)
expr_stmt|;
name|ddo
operator|->
name|ddo_xlimport
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
operator|*
name|nx
argument_list|)
expr_stmt|;
name|ddo
operator|->
name|ddo_xlexport
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
operator|*
name|nx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|!=
literal|0
operator|&&
operator|(
name|ddo
operator|->
name|ddo_xlimport
operator|==
name|NULL
operator|||
name|ddo
operator|->
name|ddo_xlexport
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nx
condition|;
name|i
operator|++
control|)
block|{
name|ddo
operator|->
name|ddo_xlimport
index|[
name|i
index|]
operator|=
name|DOF_SECIDX_NONE
expr_stmt|;
name|ddo
operator|->
name|ddo_xlexport
index|[
name|i
index|]
operator|=
name|DOF_SECIDX_NONE
expr_stmt|;
block|}
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_secs
argument_list|)
expr_stmt|;
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_strs
argument_list|)
expr_stmt|;
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_ldata
argument_list|)
expr_stmt|;
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_udata
argument_list|)
expr_stmt|;
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_probes
argument_list|)
expr_stmt|;
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_args
argument_list|)
expr_stmt|;
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_offs
argument_list|)
expr_stmt|;
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_enoffs
argument_list|)
expr_stmt|;
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_rels
argument_list|)
expr_stmt|;
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_xlms
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a loadable DOF section to the file using the specified data buffer and  * the specified DOF section attributes.  DOF_SECF_LOAD must be set in flags.  * If 'data' is NULL, the caller is responsible for manipulating the ldata buf.  */
end_comment

begin_function
specifier|static
name|dof_secidx_t
name|dof_add_lsect
parameter_list|(
name|dt_dof_t
modifier|*
name|ddo
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|type
parameter_list|,
name|uint32_t
name|align
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|uint32_t
name|entsize
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|ddo
operator|->
name|ddo_hdl
decl_stmt|;
name|dof_sec_t
name|s
decl_stmt|;
name|s
operator|.
name|dofs_type
operator|=
name|type
expr_stmt|;
name|s
operator|.
name|dofs_align
operator|=
name|align
expr_stmt|;
name|s
operator|.
name|dofs_flags
operator|=
name|flags
operator||
name|DOF_SECF_LOAD
expr_stmt|;
name|s
operator|.
name|dofs_entsize
operator|=
name|entsize
expr_stmt|;
name|s
operator|.
name|dofs_offset
operator|=
name|dt_buf_offset
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_ldata
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|s
operator|.
name|dofs_size
operator|=
name|size
expr_stmt|;
name|dt_buf_write
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_secs
argument_list|,
operator|&
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
name|dt_buf_write
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_ldata
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return
operator|(
name|ddo
operator|->
name|ddo_nsecs
operator|++
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an unloadable DOF section to the file using the specified data buffer  * and DOF section attributes.  DOF_SECF_LOAD must *not* be set in flags.  * If 'data' is NULL, the caller is responsible for manipulating the udata buf.  */
end_comment

begin_function
specifier|static
name|dof_secidx_t
name|dof_add_usect
parameter_list|(
name|dt_dof_t
modifier|*
name|ddo
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|type
parameter_list|,
name|uint32_t
name|align
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|uint32_t
name|entsize
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|ddo
operator|->
name|ddo_hdl
decl_stmt|;
name|dof_sec_t
name|s
decl_stmt|;
name|s
operator|.
name|dofs_type
operator|=
name|type
expr_stmt|;
name|s
operator|.
name|dofs_align
operator|=
name|align
expr_stmt|;
name|s
operator|.
name|dofs_flags
operator|=
name|flags
operator|&
operator|~
name|DOF_SECF_LOAD
expr_stmt|;
name|s
operator|.
name|dofs_entsize
operator|=
name|entsize
expr_stmt|;
name|s
operator|.
name|dofs_offset
operator|=
name|dt_buf_offset
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_udata
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|s
operator|.
name|dofs_size
operator|=
name|size
expr_stmt|;
name|dt_buf_write
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_secs
argument_list|,
operator|&
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
name|dt_buf_write
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_udata
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return
operator|(
name|ddo
operator|->
name|ddo_nsecs
operator|++
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a string to the global string table associated with the DOF.  The offset  * of the string is returned as an index into the string table.  */
end_comment

begin_function
specifier|static
name|dof_stridx_t
name|dof_add_string
parameter_list|(
name|dt_dof_t
modifier|*
name|ddo
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dt_buf_t
modifier|*
name|bp
init|=
operator|&
name|ddo
operator|->
name|ddo_strs
decl_stmt|;
name|dof_stridx_t
name|i
init|=
name|dt_buf_len
argument_list|(
name|bp
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
operator|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* string table has \0 at offset 0 */
name|dt_buf_write
argument_list|(
name|ddo
operator|->
name|ddo_hdl
argument_list|,
name|bp
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dof_attr_t
name|dof_attr
parameter_list|(
specifier|const
name|dtrace_attribute_t
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|DOF_ATTR
argument_list|(
name|ap
operator|->
name|dtat_name
argument_list|,
name|ap
operator|->
name|dtat_data
argument_list|,
name|ap
operator|->
name|dtat_class
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dof_secidx_t
name|dof_add_difo
parameter_list|(
name|dt_dof_t
modifier|*
name|ddo
parameter_list|,
specifier|const
name|dtrace_difo_t
modifier|*
name|dp
parameter_list|)
block|{
name|dof_secidx_t
name|dsecs
index|[
literal|5
index|]
decl_stmt|;
comment|/* enough for all possible DIFO sections */
name|uint_t
name|nsecs
init|=
literal|0
decl_stmt|;
name|dof_difohdr_t
modifier|*
name|dofd
decl_stmt|;
name|dof_relohdr_t
name|dofr
decl_stmt|;
name|dof_secidx_t
name|relsec
decl_stmt|;
name|dof_secidx_t
name|strsec
init|=
name|DOF_SECIDX_NONE
decl_stmt|;
name|dof_secidx_t
name|intsec
init|=
name|DOF_SECIDX_NONE
decl_stmt|;
name|dof_secidx_t
name|hdrsec
init|=
name|DOF_SECIDX_NONE
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|dtdo_buf
operator|!=
name|NULL
condition|)
block|{
name|dsecs
index|[
name|nsecs
operator|++
index|]
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|dp
operator|->
name|dtdo_buf
argument_list|,
name|DOF_SECT_DIF
argument_list|,
sizeof|sizeof
argument_list|(
name|dif_instr_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dif_instr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dif_instr_t
argument_list|)
operator|*
name|dp
operator|->
name|dtdo_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|dtdo_inttab
operator|!=
name|NULL
condition|)
block|{
name|dsecs
index|[
name|nsecs
operator|++
index|]
operator|=
name|intsec
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|dp
operator|->
name|dtdo_inttab
argument_list|,
name|DOF_SECT_INTTAB
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|dp
operator|->
name|dtdo_intlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|dtdo_strtab
operator|!=
name|NULL
condition|)
block|{
name|dsecs
index|[
name|nsecs
operator|++
index|]
operator|=
name|strsec
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|dp
operator|->
name|dtdo_strtab
argument_list|,
name|DOF_SECT_STRTAB
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dp
operator|->
name|dtdo_strlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|dtdo_vartab
operator|!=
name|NULL
condition|)
block|{
name|dsecs
index|[
name|nsecs
operator|++
index|]
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|dp
operator|->
name|dtdo_vartab
argument_list|,
name|DOF_SECT_VARTAB
argument_list|,
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_difv_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_difv_t
argument_list|)
operator|*
name|dp
operator|->
name|dtdo_varlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|dtdo_xlmtab
operator|!=
name|NULL
condition|)
block|{
name|dof_xlref_t
modifier|*
name|xlt
decl_stmt|,
modifier|*
name|xlp
decl_stmt|;
name|dt_node_t
modifier|*
modifier|*
name|pnp
decl_stmt|;
name|xlt
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|dof_xlref_t
argument_list|)
operator|*
name|dp
operator|->
name|dtdo_xlmlen
argument_list|)
expr_stmt|;
name|pnp
operator|=
name|dp
operator|->
name|dtdo_xlmtab
expr_stmt|;
comment|/* 		 * dtdo_xlmtab contains pointers to the translator members. 		 * The translator itself is in sect ddo_xlimport[dxp->dx_id]. 		 * The XLMEMBERS entries are in order by their dn_membid, so 		 * the member section offset is the population count of bits 		 * in ddo_pgp->dp_xlrefs[] up to and not including dn_membid. 		 */
for|for
control|(
name|xlp
operator|=
name|xlt
init|;
name|xlp
operator|<
name|xlt
operator|+
name|dp
operator|->
name|dtdo_xlmlen
condition|;
name|xlp
operator|++
control|)
block|{
name|dt_node_t
modifier|*
name|dnp
init|=
operator|*
name|pnp
operator|++
decl_stmt|;
name|dt_xlator_t
modifier|*
name|dxp
init|=
name|dnp
operator|->
name|dn_membexpr
operator|->
name|dn_xlator
decl_stmt|;
name|xlp
operator|->
name|dofxr_xlator
operator|=
name|ddo
operator|->
name|ddo_xlimport
index|[
name|dxp
operator|->
name|dx_id
index|]
expr_stmt|;
name|xlp
operator|->
name|dofxr_member
operator|=
name|dt_popcb
argument_list|(
name|ddo
operator|->
name|ddo_pgp
operator|->
name|dp_xrefs
index|[
name|dxp
operator|->
name|dx_id
index|]
argument_list|,
name|dnp
operator|->
name|dn_membid
argument_list|)
expr_stmt|;
name|xlp
operator|->
name|dofxr_argn
operator|=
operator|(
name|uint32_t
operator|)
name|dxp
operator|->
name|dx_arg
expr_stmt|;
block|}
name|dsecs
index|[
name|nsecs
operator|++
index|]
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|xlt
argument_list|,
name|DOF_SECT_XLTAB
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_xlref_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_xlref_t
argument_list|)
operator|*
name|dp
operator|->
name|dtdo_xlmlen
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy the return type and the array of section indices that form the 	 * DIFO into a single dof_difohdr_t and then add DOF_SECT_DIFOHDR. 	 */
name|assert
argument_list|(
name|nsecs
operator|<=
sizeof|sizeof
argument_list|(
name|dsecs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dsecs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dofd
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_diftype_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dsecs
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dp
operator|->
name|dtdo_rtype
argument_list|,
operator|&
name|dofd
operator|->
name|dofd_rtype
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_diftype_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dsecs
argument_list|,
operator|&
name|dofd
operator|->
name|dofd_links
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
operator|*
name|nsecs
argument_list|)
expr_stmt|;
name|hdrsec
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|dofd
argument_list|,
name|DOF_SECT_DIFOHDR
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_diftype_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
operator|*
name|nsecs
argument_list|)
expr_stmt|;
comment|/* 	 * Add any other sections related to dtrace_difo_t.  These are not 	 * referenced in dof_difohdr_t because they are not used by emulation. 	 */
if|if
condition|(
name|dp
operator|->
name|dtdo_kreltab
operator|!=
name|NULL
condition|)
block|{
name|relsec
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|dp
operator|->
name|dtdo_kreltab
argument_list|,
name|DOF_SECT_RELTAB
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_relodesc_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_relodesc_t
argument_list|)
operator|*
name|dp
operator|->
name|dtdo_krelen
argument_list|)
expr_stmt|;
comment|/* 		 * This code assumes the target of all relocations is the 		 * integer table 'intsec' (DOF_SECT_INTTAB).  If other sections 		 * need relocation in the future this will need to change. 		 */
name|dofr
operator|.
name|dofr_strtab
operator|=
name|strsec
expr_stmt|;
name|dofr
operator|.
name|dofr_relsec
operator|=
name|relsec
expr_stmt|;
name|dofr
operator|.
name|dofr_tgtsec
operator|=
name|intsec
expr_stmt|;
operator|(
name|void
operator|)
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
operator|&
name|dofr
argument_list|,
name|DOF_SECT_KRELHDR
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_relohdr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|dtdo_ureltab
operator|!=
name|NULL
condition|)
block|{
name|relsec
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|dp
operator|->
name|dtdo_ureltab
argument_list|,
name|DOF_SECT_RELTAB
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_relodesc_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_relodesc_t
argument_list|)
operator|*
name|dp
operator|->
name|dtdo_urelen
argument_list|)
expr_stmt|;
comment|/* 		 * This code assumes the target of all relocations is the 		 * integer table 'intsec' (DOF_SECT_INTTAB).  If other sections 		 * need relocation in the future this will need to change. 		 */
name|dofr
operator|.
name|dofr_strtab
operator|=
name|strsec
expr_stmt|;
name|dofr
operator|.
name|dofr_relsec
operator|=
name|relsec
expr_stmt|;
name|dofr
operator|.
name|dofr_tgtsec
operator|=
name|intsec
expr_stmt|;
operator|(
name|void
operator|)
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
operator|&
name|dofr
argument_list|,
name|DOF_SECT_URELHDR
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_relohdr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|hdrsec
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dof_add_translator
parameter_list|(
name|dt_dof_t
modifier|*
name|ddo
parameter_list|,
specifier|const
name|dt_xlator_t
modifier|*
name|dxp
parameter_list|,
name|uint_t
name|type
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|ddo
operator|->
name|ddo_hdl
decl_stmt|;
name|dof_xlmember_t
name|dofxm
decl_stmt|;
name|dof_xlator_t
name|dofxl
decl_stmt|;
name|dof_secidx_t
modifier|*
name|xst
decl_stmt|;
name|char
name|buf
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
name|uint_t
name|i
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|type
operator|==
name|DOF_SECT_XLIMPORT
operator|||
name|type
operator|==
name|DOF_SECT_XLEXPORT
argument_list|)
expr_stmt|;
name|xst
operator|=
name|type
operator|==
name|DOF_SECT_XLIMPORT
condition|?
name|ddo
operator|->
name|ddo_xlimport
else|:
name|ddo
operator|->
name|ddo_xlexport
expr_stmt|;
if|if
condition|(
name|xst
index|[
name|dxp
operator|->
name|dx_id
index|]
operator|!=
name|DOF_SECIDX_NONE
condition|)
return|return;
comment|/* translator has already been emitted */
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_xlms
argument_list|)
expr_stmt|;
comment|/* 	 * Generate an array of dof_xlmember_t's into ddo_xlms.  If we are 	 * importing the translator, add only those members referenced by the 	 * program and set the dofxm_difo reference of each member to NONE.  If 	 * we're exporting the translator, add all members and a DIFO for each. 	 */
for|for
control|(
name|dnp
operator|=
name|dxp
operator|->
name|dx_members
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|type
operator|==
name|DOF_SECT_XLIMPORT
condition|)
block|{
if|if
condition|(
operator|!
name|BT_TEST
argument_list|(
name|ddo
operator|->
name|ddo_pgp
operator|->
name|dp_xrefs
index|[
name|dxp
operator|->
name|dx_id
index|]
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
comment|/* member is not referenced */
name|dofxm
operator|.
name|dofxm_difo
operator|=
name|DOF_SECIDX_NONE
expr_stmt|;
block|}
else|else
block|{
name|dofxm
operator|.
name|dofxm_difo
operator|=
name|dof_add_difo
argument_list|(
name|ddo
argument_list|,
name|dxp
operator|->
name|dx_membdif
index|[
name|dnp
operator|->
name|dn_membid
index|]
argument_list|)
expr_stmt|;
block|}
name|dofxm
operator|.
name|dofxm_name
operator|=
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|dnp
operator|->
name|dn_membname
argument_list|)
expr_stmt|;
name|dt_node_diftype
argument_list|(
name|dtp
argument_list|,
name|dnp
argument_list|,
operator|&
name|dofxm
operator|.
name|dofxm_type
argument_list|)
expr_stmt|;
name|dt_buf_write
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_xlms
argument_list|,
operator|&
name|dofxm
argument_list|,
sizeof|sizeof
argument_list|(
name|dofxm
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dofxl
operator|.
name|dofxl_members
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|NULL
argument_list|,
name|DOF_SECT_XLMEMBERS
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dofxm
argument_list|)
argument_list|,
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_xlms
argument_list|)
argument_list|)
expr_stmt|;
name|dt_buf_concat
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_ldata
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_xlms
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|dofxl
operator|.
name|dofxl_strtab
operator|=
name|ddo
operator|->
name|ddo_strsec
expr_stmt|;
name|dofxl
operator|.
name|dofxl_argv
operator|=
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|ctf_type_name
argument_list|(
name|dxp
operator|->
name|dx_src_ctfp
argument_list|,
name|dxp
operator|->
name|dx_src_type
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dofxl
operator|.
name|dofxl_argc
operator|=
literal|1
expr_stmt|;
name|dofxl
operator|.
name|dofxl_type
operator|=
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|ctf_type_name
argument_list|(
name|dxp
operator|->
name|dx_dst_ctfp
argument_list|,
name|dxp
operator|->
name|dx_dst_type
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dofxl
operator|.
name|dofxl_attr
operator|=
name|dof_attr
argument_list|(
operator|&
name|dxp
operator|->
name|dx_souid
operator|.
name|di_attr
argument_list|)
expr_stmt|;
name|xst
index|[
name|dxp
operator|->
name|dx_id
index|]
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
operator|&
name|dofxl
argument_list|,
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dofxl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dof_add_probe
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|dt_dof_t
modifier|*
name|ddo
init|=
name|data
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|ddo
operator|->
name|ddo_hdl
decl_stmt|;
name|dt_probe_t
modifier|*
name|prp
init|=
name|idp
operator|->
name|di_data
decl_stmt|;
name|dof_probe_t
name|dofpr
decl_stmt|;
name|dof_relodesc_t
name|dofr
decl_stmt|;
name|dt_probe_instance_t
modifier|*
name|pip
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
name|char
name|buf
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
name|dofpr
operator|.
name|dofpr_addr
operator|=
literal|0
expr_stmt|;
name|dofpr
operator|.
name|dofpr_name
operator|=
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|prp
operator|->
name|pr_name
argument_list|)
expr_stmt|;
name|dofpr
operator|.
name|dofpr_nargv
operator|=
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_strs
argument_list|)
expr_stmt|;
for|for
control|(
name|dnp
operator|=
name|prp
operator|->
name|pr_nargs
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
control|)
block|{
operator|(
name|void
operator|)
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|ctf_type_name
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dofpr
operator|.
name|dofpr_xargv
operator|=
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_strs
argument_list|)
expr_stmt|;
for|for
control|(
name|dnp
operator|=
name|prp
operator|->
name|pr_xargs
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
control|)
block|{
operator|(
name|void
operator|)
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|ctf_type_name
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dofpr
operator|.
name|dofpr_argidx
operator|=
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prp
operator|->
name|pr_xargc
condition|;
name|i
operator|++
control|)
block|{
name|dt_buf_write
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_args
argument_list|,
operator|&
name|prp
operator|->
name|pr_mapping
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dofpr
operator|.
name|dofpr_nargc
operator|=
name|prp
operator|->
name|pr_nargc
expr_stmt|;
name|dofpr
operator|.
name|dofpr_xargc
operator|=
name|prp
operator|->
name|pr_xargc
expr_stmt|;
name|dofpr
operator|.
name|dofpr_pad1
operator|=
literal|0
expr_stmt|;
name|dofpr
operator|.
name|dofpr_pad2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pip
operator|=
name|prp
operator|->
name|pr_inst
init|;
name|pip
operator|!=
name|NULL
condition|;
name|pip
operator|=
name|pip
operator|->
name|pi_next
control|)
block|{
name|dt_dprintf
argument_list|(
literal|"adding probe for %s:%s\n"
argument_list|,
name|pip
operator|->
name|pi_fname
argument_list|,
name|prp
operator|->
name|pr_name
argument_list|)
expr_stmt|;
name|dofpr
operator|.
name|dofpr_func
operator|=
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|pip
operator|->
name|pi_fname
argument_list|)
expr_stmt|;
comment|/* 		 * There should be one probe offset or is-enabled probe offset 		 * or else this probe instance won't have been created. The 		 * kernel will reject DOF which has a probe with no offsets. 		 */
name|assert
argument_list|(
name|pip
operator|->
name|pi_noffs
operator|+
name|pip
operator|->
name|pi_nenoffs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|dofpr
operator|.
name|dofpr_offidx
operator|=
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_offs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|dofpr
operator|.
name|dofpr_noffs
operator|=
name|pip
operator|->
name|pi_noffs
expr_stmt|;
name|dt_buf_write
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_offs
argument_list|,
name|pip
operator|->
name|pi_offs
argument_list|,
name|pip
operator|->
name|pi_noffs
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|dofpr
operator|.
name|dofpr_enoffidx
operator|=
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_enoffs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|dofpr
operator|.
name|dofpr_nenoffs
operator|=
name|pip
operator|->
name|pi_nenoffs
expr_stmt|;
name|dt_buf_write
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_enoffs
argument_list|,
name|pip
operator|->
name|pi_enoffs
argument_list|,
name|pip
operator|->
name|pi_nenoffs
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If pi_rname isn't set, the relocation will be against the 		 * function name. If it is, the relocation will be against 		 * pi_rname. This will be used if the function is scoped 		 * locally so an alternate symbol is added for the purpose 		 * of this relocation. 		 */
if|if
condition|(
name|pip
operator|->
name|pi_rname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|dofr
operator|.
name|dofr_name
operator|=
name|dofpr
operator|.
name|dofpr_func
expr_stmt|;
else|else
name|dofr
operator|.
name|dofr_name
operator|=
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|pip
operator|->
name|pi_rname
argument_list|)
expr_stmt|;
name|dofr
operator|.
name|dofr_type
operator|=
name|DOF_RELO_SETX
expr_stmt|;
name|dofr
operator|.
name|dofr_offset
operator|=
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_probes
argument_list|)
expr_stmt|;
name|dofr
operator|.
name|dofr_data
operator|=
literal|0
expr_stmt|;
name|dt_buf_write
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_rels
argument_list|,
operator|&
name|dofr
argument_list|,
sizeof|sizeof
argument_list|(
name|dofr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|dt_buf_write
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_probes
argument_list|,
operator|&
name|dofpr
argument_list|,
sizeof|sizeof
argument_list|(
name|dofpr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dof_add_provider
parameter_list|(
name|dt_dof_t
modifier|*
name|ddo
parameter_list|,
specifier|const
name|dt_provider_t
modifier|*
name|pvp
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|ddo
operator|->
name|ddo_hdl
decl_stmt|;
name|dof_provider_t
name|dofpv
decl_stmt|;
name|dof_relohdr_t
name|dofr
decl_stmt|;
name|dof_secidx_t
modifier|*
name|dofs
decl_stmt|;
name|ulong_t
name|xr
decl_stmt|,
name|nxr
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|id_t
name|i
decl_stmt|;
if|if
condition|(
name|pvp
operator|->
name|pv_flags
operator|&
name|DT_PROVIDER_IMPL
condition|)
block|{
comment|/* 		 * ignore providers that are exported by dtrace(7D) 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nxr
operator|=
name|dt_popcb
argument_list|(
name|pvp
operator|->
name|pv_xrefs
argument_list|,
name|pvp
operator|->
name|pv_xrmax
argument_list|)
expr_stmt|;
name|dofs
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
operator|*
operator|(
name|nxr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|xr
operator|=
literal|1
expr_stmt|;
comment|/* reserve dofs[0] for the provider itself */
comment|/* 	 * For each translator referenced by the provider (pv_xrefs), emit an 	 * exported translator section for it if one hasn't been created yet. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pvp
operator|->
name|pv_xrmax
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BT_TEST
argument_list|(
name|pvp
operator|->
name|pv_xrefs
argument_list|,
name|i
argument_list|)
operator|&&
name|dtp
operator|->
name|dt_xlatemode
operator|==
name|DT_XL_DYNAMIC
condition|)
block|{
name|dof_add_translator
argument_list|(
name|ddo
argument_list|,
name|dt_xlator_lookup_id
argument_list|(
name|dtp
argument_list|,
name|i
argument_list|)
argument_list|,
name|DOF_SECT_XLEXPORT
argument_list|)
expr_stmt|;
name|dofs
index|[
name|xr
operator|++
index|]
operator|=
name|ddo
operator|->
name|ddo_xlexport
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_probes
argument_list|)
expr_stmt|;
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_args
argument_list|)
expr_stmt|;
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_offs
argument_list|)
expr_stmt|;
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_enoffs
argument_list|)
expr_stmt|;
name|dt_buf_reset
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_rels
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_idhash_iter
argument_list|(
name|pvp
operator|->
name|pv_probes
argument_list|,
name|dof_add_probe
argument_list|,
name|ddo
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_probes
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOPROBES
argument_list|)
operator|)
return|;
name|dofpv
operator|.
name|dofpv_probes
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|NULL
argument_list|,
name|DOF_SECT_PROBES
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_probe_t
argument_list|)
argument_list|,
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_probes
argument_list|)
argument_list|)
expr_stmt|;
name|dt_buf_concat
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_ldata
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_probes
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|dofpv
operator|.
name|dofpv_prargs
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|NULL
argument_list|,
name|DOF_SECT_PRARGS
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|,
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_args
argument_list|)
argument_list|)
expr_stmt|;
name|dt_buf_concat
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_ldata
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_args
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|dofpv
operator|.
name|dofpv_proffs
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|NULL
argument_list|,
name|DOF_SECT_PROFFS
argument_list|,
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
argument_list|,
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_offs
argument_list|)
argument_list|)
expr_stmt|;
name|dt_buf_concat
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_ldata
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_offs
argument_list|,
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sz
operator|=
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_enoffs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|dofpv
operator|.
name|dofpv_prenoffs
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|NULL
argument_list|,
name|DOF_SECT_PRENOFFS
argument_list|,
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dofpv
operator|.
name|dofpv_prenoffs
operator|=
name|DOF_SECT_NONE
expr_stmt|;
block|}
name|dt_buf_concat
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_ldata
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_enoffs
argument_list|,
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
argument_list|)
expr_stmt|;
name|dofpv
operator|.
name|dofpv_strtab
operator|=
name|ddo
operator|->
name|ddo_strsec
expr_stmt|;
name|dofpv
operator|.
name|dofpv_name
operator|=
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|)
expr_stmt|;
name|dofpv
operator|.
name|dofpv_provattr
operator|=
name|dof_attr
argument_list|(
operator|&
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
operator|.
name|dtpa_provider
argument_list|)
expr_stmt|;
name|dofpv
operator|.
name|dofpv_modattr
operator|=
name|dof_attr
argument_list|(
operator|&
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
operator|.
name|dtpa_mod
argument_list|)
expr_stmt|;
name|dofpv
operator|.
name|dofpv_funcattr
operator|=
name|dof_attr
argument_list|(
operator|&
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
operator|.
name|dtpa_func
argument_list|)
expr_stmt|;
name|dofpv
operator|.
name|dofpv_nameattr
operator|=
name|dof_attr
argument_list|(
operator|&
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
operator|.
name|dtpa_name
argument_list|)
expr_stmt|;
name|dofpv
operator|.
name|dofpv_argsattr
operator|=
name|dof_attr
argument_list|(
operator|&
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_attr
operator|.
name|dtpa_args
argument_list|)
expr_stmt|;
name|dofs
index|[
literal|0
index|]
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
operator|&
name|dofpv
argument_list|,
name|DOF_SECT_PROVIDER
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_provider_t
argument_list|)
argument_list|)
expr_stmt|;
name|dofr
operator|.
name|dofr_strtab
operator|=
name|dofpv
operator|.
name|dofpv_strtab
expr_stmt|;
name|dofr
operator|.
name|dofr_tgtsec
operator|=
name|dofpv
operator|.
name|dofpv_probes
expr_stmt|;
name|dofr
operator|.
name|dofr_relsec
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|NULL
argument_list|,
name|DOF_SECT_RELTAB
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_relodesc_t
argument_list|)
argument_list|,
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_rels
argument_list|)
argument_list|)
expr_stmt|;
name|dt_buf_concat
argument_list|(
name|dtp
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_ldata
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_rels
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
operator|&
name|dofr
argument_list|,
name|DOF_SECT_URELHDR
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_relohdr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxr
operator|!=
literal|0
operator|&&
name|dtp
operator|->
name|dt_xlatemode
operator|==
name|DT_XL_DYNAMIC
condition|)
block|{
operator|(
name|void
operator|)
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|dofs
argument_list|,
name|DOF_SECT_PREXPORT
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
operator|*
operator|(
name|nxr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dof_hdr
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|uint8_t
name|dofversion
parameter_list|,
name|dof_hdr_t
modifier|*
name|hp
parameter_list|)
block|{
comment|/* 	 * If our config values cannot fit in a uint8_t, we can't generate a 	 * DOF header since the values won't fit.  This can only happen if the 	 * user forcibly compiles a program with an artificial configuration. 	 */
if|if
condition|(
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_difversion
operator|>
name|UINT8_MAX
operator|||
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_difintregs
operator|>
name|UINT8_MAX
operator|||
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_diftupregs
operator|>
name|UINT8_MAX
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EOVERFLOW
argument_list|)
operator|)
return|;
name|bzero
argument_list|(
name|hp
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|dofh_ident
index|[
name|DOF_ID_MAG0
index|]
operator|=
name|DOF_MAG_MAG0
expr_stmt|;
name|hp
operator|->
name|dofh_ident
index|[
name|DOF_ID_MAG1
index|]
operator|=
name|DOF_MAG_MAG1
expr_stmt|;
name|hp
operator|->
name|dofh_ident
index|[
name|DOF_ID_MAG2
index|]
operator|=
name|DOF_MAG_MAG2
expr_stmt|;
name|hp
operator|->
name|dofh_ident
index|[
name|DOF_ID_MAG3
index|]
operator|=
name|DOF_MAG_MAG3
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_ctfmodel
operator|==
name|CTF_MODEL_LP64
condition|)
name|hp
operator|->
name|dofh_ident
index|[
name|DOF_ID_MODEL
index|]
operator|=
name|DOF_MODEL_LP64
expr_stmt|;
else|else
name|hp
operator|->
name|dofh_ident
index|[
name|DOF_ID_MODEL
index|]
operator|=
name|DOF_MODEL_ILP32
expr_stmt|;
name|hp
operator|->
name|dofh_ident
index|[
name|DOF_ID_ENCODING
index|]
operator|=
name|DOF_ENCODE_NATIVE
expr_stmt|;
name|hp
operator|->
name|dofh_ident
index|[
name|DOF_ID_VERSION
index|]
operator|=
name|dofversion
expr_stmt|;
name|hp
operator|->
name|dofh_ident
index|[
name|DOF_ID_DIFVERS
index|]
operator|=
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_difversion
expr_stmt|;
name|hp
operator|->
name|dofh_ident
index|[
name|DOF_ID_DIFIREG
index|]
operator|=
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_difintregs
expr_stmt|;
name|hp
operator|->
name|dofh_ident
index|[
name|DOF_ID_DIFTREG
index|]
operator|=
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_diftupregs
expr_stmt|;
name|hp
operator|->
name|dofh_hdrsize
operator|=
sizeof|sizeof
argument_list|(
name|dof_hdr_t
argument_list|)
expr_stmt|;
name|hp
operator|->
name|dofh_secsize
operator|=
sizeof|sizeof
argument_list|(
name|dof_sec_t
argument_list|)
expr_stmt|;
name|hp
operator|->
name|dofh_secoff
operator|=
sizeof|sizeof
argument_list|(
name|dof_hdr_t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|dtrace_dof_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_prog_t
modifier|*
name|pgp
parameter_list|,
name|uint_t
name|flags
parameter_list|)
block|{
name|dt_dof_t
modifier|*
name|ddo
init|=
operator|&
name|dtp
operator|->
name|dt_dof
decl_stmt|;
specifier|const
name|dtrace_ecbdesc_t
modifier|*
name|edp
decl_stmt|,
modifier|*
name|last
decl_stmt|;
specifier|const
name|dtrace_probedesc_t
modifier|*
name|pdp
decl_stmt|;
specifier|const
name|dtrace_actdesc_t
modifier|*
name|ap
decl_stmt|;
specifier|const
name|dt_stmt_t
modifier|*
name|stp
decl_stmt|;
name|uint_t
name|maxacts
init|=
literal|0
decl_stmt|;
name|uint_t
name|maxfmt
init|=
literal|0
decl_stmt|;
name|dt_provider_t
modifier|*
name|pvp
decl_stmt|;
name|dt_xlator_t
modifier|*
name|dxp
decl_stmt|;
name|dof_actdesc_t
modifier|*
name|dofa
decl_stmt|;
name|dof_sec_t
modifier|*
name|sp
decl_stmt|;
name|size_t
name|ssize
decl_stmt|,
name|lsize
decl_stmt|;
name|dof_hdr_t
name|h
decl_stmt|;
name|dt_buf_t
name|dof
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
if|if
condition|(
name|flags
operator|&
operator|~
name|DTRACE_D_MASK
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|flags
operator||=
name|dtp
operator|->
name|dt_dflags
expr_stmt|;
if|if
condition|(
name|dof_hdr
argument_list|(
name|dtp
argument_list|,
name|pgp
operator|->
name|dp_dofversion
argument_list|,
operator|&
name|h
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|dt_dof_reset
argument_list|(
name|dtp
argument_list|,
name|pgp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Iterate through the statement list computing the maximum number of 	 * actions and the maximum format string for allocating local buffers. 	 */
for|for
control|(
name|last
operator|=
name|NULL
operator|,
name|stp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|pgp
operator|->
name|dp_stmts
argument_list|)
init|;
name|stp
operator|!=
name|NULL
condition|;
name|stp
operator|=
name|dt_list_next
argument_list|(
name|stp
argument_list|)
operator|,
name|last
operator|=
name|edp
control|)
block|{
name|dtrace_stmtdesc_t
modifier|*
name|sdp
init|=
name|stp
operator|->
name|ds_desc
decl_stmt|;
name|dtrace_actdesc_t
modifier|*
name|ap
init|=
name|sdp
operator|->
name|dtsd_action
decl_stmt|;
if|if
condition|(
name|sdp
operator|->
name|dtsd_fmtdata
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|dtrace_printf_format
argument_list|(
name|dtp
argument_list|,
name|sdp
operator|->
name|dtsd_fmtdata
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|maxfmt
operator|=
name|MAX
argument_list|(
name|maxfmt
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|edp
operator|=
name|sdp
operator|->
name|dtsd_ecbdesc
operator|)
operator|==
name|last
condition|)
continue|continue;
comment|/* same ecb as previous statement */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ap
operator|=
name|edp
operator|->
name|dted_action
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|dtad_next
control|)
name|i
operator|++
expr_stmt|;
name|maxacts
operator|=
name|MAX
argument_list|(
name|maxacts
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|dofa
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|dof_actdesc_t
argument_list|)
operator|*
name|maxacts
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|alloca
argument_list|(
name|maxfmt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ddo
operator|->
name|ddo_strsec
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|NULL
argument_list|,
name|DOF_SECT_STRTAB
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * If there are references to dynamic translators in the program, add 	 * an imported translator table entry for each referenced translator. 	 */
if|if
condition|(
name|pgp
operator|->
name|dp_xrefslen
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|dxp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_xlators
argument_list|)
init|;
name|dxp
operator|!=
name|NULL
condition|;
name|dxp
operator|=
name|dt_list_next
argument_list|(
name|dxp
argument_list|)
control|)
block|{
if|if
condition|(
name|dxp
operator|->
name|dx_id
operator|<
name|pgp
operator|->
name|dp_xrefslen
operator|&&
name|pgp
operator|->
name|dp_xrefs
index|[
name|dxp
operator|->
name|dx_id
index|]
operator|!=
name|NULL
condition|)
name|dof_add_translator
argument_list|(
name|ddo
argument_list|,
name|dxp
argument_list|,
name|DOF_SECT_XLIMPORT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Now iterate through the statement list, creating the DOF section 	 * headers and data for each one and adding them to our buffers. 	 */
for|for
control|(
name|last
operator|=
name|NULL
operator|,
name|stp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|pgp
operator|->
name|dp_stmts
argument_list|)
init|;
name|stp
operator|!=
name|NULL
condition|;
name|stp
operator|=
name|dt_list_next
argument_list|(
name|stp
argument_list|)
operator|,
name|last
operator|=
name|edp
control|)
block|{
name|dof_secidx_t
name|probesec
init|=
name|DOF_SECIDX_NONE
decl_stmt|;
name|dof_secidx_t
name|prdsec
init|=
name|DOF_SECIDX_NONE
decl_stmt|;
name|dof_secidx_t
name|actsec
init|=
name|DOF_SECIDX_NONE
decl_stmt|;
specifier|const
name|dt_stmt_t
modifier|*
name|next
init|=
name|stp
decl_stmt|;
name|dtrace_stmtdesc_t
modifier|*
name|sdp
init|=
name|stp
operator|->
name|ds_desc
decl_stmt|;
name|dof_stridx_t
name|strndx
init|=
literal|0
decl_stmt|;
name|dof_probedesc_t
name|dofp
decl_stmt|;
name|dof_ecbdesc_t
name|dofe
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|edp
operator|=
name|stp
operator|->
name|ds_desc
operator|->
name|dtsd_ecbdesc
operator|)
operator|==
name|last
condition|)
continue|continue;
comment|/* same ecb as previous statement */
name|pdp
operator|=
operator|&
name|edp
operator|->
name|dted_probe
expr_stmt|;
comment|/* 		 * Add a DOF_SECT_PROBEDESC for the ECB's probe description, 		 * and copy the probe description strings into the string table. 		 */
name|dofp
operator|.
name|dofp_strtab
operator|=
name|ddo
operator|->
name|ddo_strsec
expr_stmt|;
name|dofp
operator|.
name|dofp_provider
operator|=
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
expr_stmt|;
name|dofp
operator|.
name|dofp_mod
operator|=
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|pdp
operator|->
name|dtpd_mod
argument_list|)
expr_stmt|;
name|dofp
operator|.
name|dofp_func
operator|=
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|pdp
operator|->
name|dtpd_func
argument_list|)
expr_stmt|;
name|dofp
operator|.
name|dofp_name
operator|=
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|pdp
operator|->
name|dtpd_name
argument_list|)
expr_stmt|;
name|dofp
operator|.
name|dofp_id
operator|=
name|pdp
operator|->
name|dtpd_id
expr_stmt|;
name|probesec
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
operator|&
name|dofp
argument_list|,
name|DOF_SECT_PROBEDESC
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_probedesc_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_probedesc_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If there is a predicate DIFO associated with the ecbdesc, 		 * write out the DIFO sections and save the DIFO section index. 		 */
if|if
condition|(
name|edp
operator|->
name|dted_pred
operator|.
name|dtpdd_difo
operator|!=
name|NULL
condition|)
name|prdsec
operator|=
name|dof_add_difo
argument_list|(
name|ddo
argument_list|,
name|edp
operator|->
name|dted_pred
operator|.
name|dtpdd_difo
argument_list|)
expr_stmt|;
comment|/* 		 * Now iterate through the action list generating DIFOs as 		 * referenced therein and adding action descriptions to 'dofa'. 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ap
operator|=
name|edp
operator|->
name|dted_action
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|dtad_next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|dtad_difo
operator|!=
name|NULL
condition|)
block|{
name|dofa
index|[
name|i
index|]
operator|.
name|dofa_difo
operator|=
name|dof_add_difo
argument_list|(
name|ddo
argument_list|,
name|ap
operator|->
name|dtad_difo
argument_list|)
expr_stmt|;
block|}
else|else
name|dofa
index|[
name|i
index|]
operator|.
name|dofa_difo
operator|=
name|DOF_SECIDX_NONE
expr_stmt|;
comment|/* 			 * If the first action in a statement has string data, 			 * add the string to the global string table.  This can 			 * be due either to a printf() format string 			 * (dtsd_fmtdata) or a print() type string 			 * (dtsd_strdata). 			 */
if|if
condition|(
name|sdp
operator|!=
name|NULL
operator|&&
name|ap
operator|==
name|sdp
operator|->
name|dtsd_action
condition|)
block|{
if|if
condition|(
name|sdp
operator|->
name|dtsd_fmtdata
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|dtrace_printf_format
argument_list|(
name|dtp
argument_list|,
name|sdp
operator|->
name|dtsd_fmtdata
argument_list|,
name|fmt
argument_list|,
name|maxfmt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strndx
operator|=
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sdp
operator|->
name|dtsd_strdata
operator|!=
name|NULL
condition|)
block|{
name|strndx
operator|=
name|dof_add_string
argument_list|(
name|ddo
argument_list|,
name|sdp
operator|->
name|dtsd_strdata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strndx
operator|=
literal|0
expr_stmt|;
comment|/* use dtad_arg instead */
block|}
if|if
condition|(
operator|(
name|next
operator|=
name|dt_list_next
argument_list|(
name|next
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sdp
operator|=
name|next
operator|->
name|ds_desc
expr_stmt|;
else|else
name|sdp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|strndx
operator|!=
literal|0
condition|)
block|{
name|dofa
index|[
name|i
index|]
operator|.
name|dofa_arg
operator|=
name|strndx
expr_stmt|;
name|dofa
index|[
name|i
index|]
operator|.
name|dofa_strtab
operator|=
name|ddo
operator|->
name|ddo_strsec
expr_stmt|;
block|}
else|else
block|{
name|dofa
index|[
name|i
index|]
operator|.
name|dofa_arg
operator|=
name|ap
operator|->
name|dtad_arg
expr_stmt|;
name|dofa
index|[
name|i
index|]
operator|.
name|dofa_strtab
operator|=
name|DOF_SECIDX_NONE
expr_stmt|;
block|}
name|dofa
index|[
name|i
index|]
operator|.
name|dofa_kind
operator|=
name|ap
operator|->
name|dtad_kind
expr_stmt|;
name|dofa
index|[
name|i
index|]
operator|.
name|dofa_ntuple
operator|=
name|ap
operator|->
name|dtad_ntuple
expr_stmt|;
name|dofa
index|[
name|i
index|]
operator|.
name|dofa_uarg
operator|=
name|ap
operator|->
name|dtad_uarg
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|actsec
operator|=
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
name|dofa
argument_list|,
name|DOF_SECT_ACTDESC
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_actdesc_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_actdesc_t
argument_list|)
operator|*
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now finally, add the DOF_SECT_ECBDESC referencing all the 		 * previously created sub-sections. 		 */
name|dofe
operator|.
name|dofe_probes
operator|=
name|probesec
expr_stmt|;
name|dofe
operator|.
name|dofe_pred
operator|=
name|prdsec
expr_stmt|;
name|dofe
operator|.
name|dofe_actions
operator|=
name|actsec
expr_stmt|;
name|dofe
operator|.
name|dofe_pad
operator|=
literal|0
expr_stmt|;
name|dofe
operator|.
name|dofe_uarg
operator|=
name|edp
operator|->
name|dted_uarg
expr_stmt|;
operator|(
name|void
operator|)
name|dof_add_lsect
argument_list|(
name|ddo
argument_list|,
operator|&
name|dofe
argument_list|,
name|DOF_SECT_ECBDESC
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dof_ecbdesc_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If any providers are user-defined, output DOF sections corresponding 	 * to the providers and the probes and arguments that they define. 	 */
if|if
condition|(
name|flags
operator|&
name|DTRACE_D_PROBES
condition|)
block|{
for|for
control|(
name|pvp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_provlist
argument_list|)
init|;
name|pvp
operator|!=
name|NULL
condition|;
name|pvp
operator|=
name|dt_list_next
argument_list|(
name|pvp
argument_list|)
control|)
block|{
if|if
condition|(
name|dof_add_provider
argument_list|(
name|ddo
argument_list|,
name|pvp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 	 * If we're not stripping unloadable sections, generate compiler 	 * comments and any other unloadable miscellany. 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DTRACE_D_STRIP
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|dof_add_usect
argument_list|(
name|ddo
argument_list|,
name|_dtrace_version
argument_list|,
name|DOF_SECT_COMMENTS
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|_dtrace_version
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dof_add_usect
argument_list|(
name|ddo
argument_list|,
operator|&
name|dtp
operator|->
name|dt_uts
argument_list|,
name|DOF_SECT_UTSNAME
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|utsname
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Compute and fill in the appropriate values for the dof_hdr_t's 	 * dofh_secnum, dofh_loadsz, and dofh_filez values. 	 */
name|h
operator|.
name|dofh_secnum
operator|=
name|ddo
operator|->
name|ddo_nsecs
expr_stmt|;
name|ssize
operator|=
sizeof|sizeof
argument_list|(
name|h
argument_list|)
operator|+
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_secs
argument_list|)
expr_stmt|;
name|h
operator|.
name|dofh_loadsz
operator|=
name|ssize
operator|+
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_ldata
argument_list|)
operator|+
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_strs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_udata
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|lsize
operator|=
name|roundup
argument_list|(
name|h
operator|.
name|dofh_loadsz
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|dofh_filesz
operator|=
name|lsize
operator|+
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_udata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lsize
operator|=
name|h
operator|.
name|dofh_loadsz
expr_stmt|;
name|h
operator|.
name|dofh_filesz
operator|=
name|lsize
expr_stmt|;
block|}
comment|/* 	 * Set the global DOF_SECT_STRTAB's offset to be after the header, 	 * section headers, and other loadable data.  Since we're going to 	 * iterate over the buffer data directly, we must check for errors. 	 */
if|if
condition|(
operator|(
name|i
operator|=
name|dt_buf_error
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_secs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sp
operator|=
name|dt_buf_ptr
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_secs
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
index|[
name|ddo
operator|->
name|ddo_strsec
index|]
operator|.
name|dofs_type
operator|==
name|DOF_SECT_STRTAB
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ssize
operator|==
sizeof|sizeof
argument_list|(
name|h
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dof_sec_t
argument_list|)
operator|*
name|ddo
operator|->
name|ddo_nsecs
argument_list|)
expr_stmt|;
name|sp
index|[
name|ddo
operator|->
name|ddo_strsec
index|]
operator|.
name|dofs_offset
operator|=
name|ssize
operator|+
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_ldata
argument_list|)
expr_stmt|;
name|sp
index|[
name|ddo
operator|->
name|ddo_strsec
index|]
operator|.
name|dofs_size
operator|=
name|dt_buf_len
argument_list|(
operator|&
name|ddo
operator|->
name|ddo_strs
argument_list|)
expr_stmt|;
comment|/* 	 * Now relocate all the other section headers by adding the appropriate 	 * delta to their respective dofs_offset values. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ddo
operator|->
name|ddo_nsecs
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|ddo
operator|->
name|ddo_strsec
condition|)
continue|continue;
comment|/* already relocated above */
if|if
condition|(
name|sp
operator|->
name|dofs_flags
operator|&
name|DOF_SECF_LOAD
condition|)
name|sp
operator|->
name|dofs_offset
operator|+=
name|ssize
expr_stmt|;
else|else
name|sp
operator|->
name|dofs_offset
operator|+=
name|lsize
expr_stmt|;
block|}
comment|/* 	 * Finally, assemble the complete in-memory DOF buffer by writing the 	 * header and then concatenating all our buffers.  dt_buf_concat() will 	 * propagate any errors and cause dt_buf_claim() to return NULL. 	 */
name|dt_buf_create
argument_list|(
name|dtp
argument_list|,
operator|&
name|dof
argument_list|,
literal|"dof"
argument_list|,
name|h
operator|.
name|dofh_filesz
argument_list|)
expr_stmt|;
name|dt_buf_write
argument_list|(
name|dtp
argument_list|,
operator|&
name|dof
argument_list|,
operator|&
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|h
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|dt_buf_concat
argument_list|(
name|dtp
argument_list|,
operator|&
name|dof
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_secs
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|dt_buf_concat
argument_list|(
name|dtp
argument_list|,
operator|&
name|dof
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_ldata
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|dt_buf_concat
argument_list|(
name|dtp
argument_list|,
operator|&
name|dof
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_strs
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|dt_buf_concat
argument_list|(
name|dtp
argument_list|,
operator|&
name|dof
argument_list|,
operator|&
name|ddo
operator|->
name|ddo_udata
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_buf_claim
argument_list|(
name|dtp
argument_list|,
operator|&
name|dof
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dtrace_dof_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|void
modifier|*
name|dof
parameter_list|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dof
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|dtrace_getopt_dof
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dof_hdr_t
modifier|*
name|dof
decl_stmt|;
name|dof_sec_t
modifier|*
name|sec
decl_stmt|;
name|dof_optdesc_t
modifier|*
name|dofo
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nopts
init|=
literal|0
decl_stmt|,
name|len
init|=
sizeof|sizeof
argument_list|(
name|dof_hdr_t
argument_list|)
operator|+
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|dof_sec_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DTRACEOPT_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dtp
operator|->
name|dt_options
index|[
name|i
index|]
operator|!=
name|DTRACEOPT_UNSET
condition|)
name|nopts
operator|++
expr_stmt|;
block|}
name|len
operator|+=
sizeof|sizeof
argument_list|(
name|dof_optdesc_t
argument_list|)
operator|*
name|nopts
expr_stmt|;
if|if
condition|(
operator|(
name|dof
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|dof_hdr
argument_list|(
name|dtp
argument_list|,
name|DOF_VERSION
argument_list|,
name|dof
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dof
operator|->
name|dofh_secnum
operator|=
literal|1
expr_stmt|;
comment|/* only DOF_SECT_OPTDESC */
name|dof
operator|->
name|dofh_loadsz
operator|=
name|len
expr_stmt|;
name|dof
operator|->
name|dofh_filesz
operator|=
name|len
expr_stmt|;
comment|/* 	 * Fill in the option section header... 	 */
name|sec
operator|=
operator|(
name|dof_sec_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|dof
operator|+
sizeof|sizeof
argument_list|(
name|dof_hdr_t
argument_list|)
operator|)
expr_stmt|;
name|sec
operator|->
name|dofs_type
operator|=
name|DOF_SECT_OPTDESC
expr_stmt|;
name|sec
operator|->
name|dofs_align
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|sec
operator|->
name|dofs_flags
operator|=
name|DOF_SECF_LOAD
expr_stmt|;
name|sec
operator|->
name|dofs_entsize
operator|=
sizeof|sizeof
argument_list|(
name|dof_optdesc_t
argument_list|)
expr_stmt|;
name|dofo
operator|=
operator|(
name|dof_optdesc_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|sec
operator|+
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|dof_sec_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|sec
operator|->
name|dofs_offset
operator|=
operator|(
name|uintptr_t
operator|)
name|dofo
operator|-
operator|(
name|uintptr_t
operator|)
name|dof
expr_stmt|;
name|sec
operator|->
name|dofs_size
operator|=
sizeof|sizeof
argument_list|(
name|dof_optdesc_t
argument_list|)
operator|*
name|nopts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DTRACEOPT_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dtp
operator|->
name|dt_options
index|[
name|i
index|]
operator|==
name|DTRACEOPT_UNSET
condition|)
continue|continue;
name|dofo
operator|->
name|dofo_option
operator|=
name|i
expr_stmt|;
name|dofo
operator|->
name|dofo_strtab
operator|=
name|DOF_SECIDX_NONE
expr_stmt|;
name|dofo
operator|->
name|dofo_value
operator|=
name|dtp
operator|->
name|dt_options
index|[
name|i
index|]
expr_stmt|;
name|dofo
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|dof
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|dtrace_geterr_dof
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
if|if
condition|(
name|dtp
operator|->
name|dt_errprog
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dtrace_dof_create
argument_list|(
name|dtp
argument_list|,
name|dtp
operator|->
name|dt_errprog
argument_list|,
literal|0
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADERROR
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

