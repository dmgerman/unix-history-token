begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2011 by Delphix. All rights reserved.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013, Joyent, Inc.  All rights reserved.  */
end_comment

begin_comment
comment|/*  * DTrace print() action  *  * This file contains the post-processing logic for the print() action.  The  * print action behaves identically to trace() in that it generates a  * DTRACEACT_DIFEXPR action, but the action argument field refers to a CTF type  * string stored in the DOF string table (similar to printf formats).  We  * take the result of the trace action and post-process it in the fashion of  * MDB's ::print dcmd.  *  * This implementation differs from MDB's in the following ways:  *  * 	- We do not expose any options or flags.  The behavior of print() is  *	  equivalent to "::print -tn".  *  * 	- MDB will display "holes" in structures (unused padding between  *	  members).  *  * 	- When printing arrays of structures, MDB will leave a trailing ','  *	  after the last element.  *  *	- MDB will print time_t types as date and time.  *  *	- MDB will detect when an enum is actually the OR of several flags,  *	  and print it out with the constituent flags separated.  *  *	- For large arrays, MDB will print the first few members and then  *	  print a "..." continuation line.  *  *	- MDB will break and wrap arrays at 80 columns.  *  *	- MDB prints out floats and doubles by hand, as it must run in kmdb  *	  context.  We're able to leverage the printf() format strings,  *	  but the result is a slightly different format.  */
end_comment

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<dt_module.h>
end_include

begin_include
include|#
directive|include
file|<dt_printf.h>
end_include

begin_include
include|#
directive|include
file|<dt_string.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_comment
comment|/* determines whether the given integer CTF encoding is a character */
end_comment

begin_define
define|#
directive|define
name|CTF_IS_CHAR
parameter_list|(
name|e
parameter_list|)
define|\
value|(((e).cte_format& (CTF_INT_CHAR | CTF_INT_SIGNED)) == \ 	(CTF_INT_CHAR | CTF_INT_SIGNED)&& (e).cte_bits == NBBY)
end_define

begin_comment
comment|/* determines whether the given CTF kind is a struct or union */
end_comment

begin_define
define|#
directive|define
name|CTF_IS_STRUCTLIKE
parameter_list|(
name|k
parameter_list|)
define|\
value|((k) == CTF_K_STRUCT || (k) == CTF_K_UNION)
end_define

begin_comment
comment|/*  * Print structure passed down recursively through printing algorithm.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dt_printarg
block|{
name|dtrace_hdl_t
modifier|*
name|pa_dtp
decl_stmt|;
comment|/* libdtrace handle */
name|caddr_t
name|pa_addr
decl_stmt|;
comment|/* base address of trace data */
name|ctf_file_t
modifier|*
name|pa_ctfp
decl_stmt|;
comment|/* CTF container */
name|int
name|pa_depth
decl_stmt|;
comment|/* member depth */
name|int
name|pa_nest
decl_stmt|;
comment|/* nested array depth */
name|FILE
modifier|*
name|pa_file
decl_stmt|;
comment|/* output file */
block|}
name|dt_printarg_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|dt_print_member
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|ctf_id_t
parameter_list|,
name|ulong_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Safe version of ctf_type_name() that will fall back to just "<ctfid>" if it  * can't resolve the type.  */
end_comment

begin_function
specifier|static
name|void
name|dt_print_type_name
parameter_list|(
name|ctf_file_t
modifier|*
name|ctfp
parameter_list|,
name|ctf_id_t
name|id
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
if|if
condition|(
name|ctf_type_name
argument_list|(
name|ctfp
argument_list|,
name|id
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"<%ld>"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print any necessary trailing braces for structures or unions.  We don't get  * invoked when a struct or union ends, so we infer the need to print braces  * based on the depth the last time we printed something and the new depth.  */
end_comment

begin_function
specifier|static
name|void
name|dt_print_trailing_braces
parameter_list|(
name|dt_printarg_t
modifier|*
name|pap
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|int
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|pap
operator|->
name|pa_depth
init|;
name|d
operator|>
name|depth
condition|;
name|d
operator|--
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|pap
operator|->
name|pa_file
argument_list|,
literal|"%*s}%s"
argument_list|,
operator|(
name|d
operator|+
name|pap
operator|->
name|pa_nest
operator|-
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|d
operator|==
name|depth
operator|+
literal|1
condition|?
literal|""
else|:
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print the appropriate amount of indentation given the current depth and  * array nesting.  */
end_comment

begin_function
specifier|static
name|void
name|dt_print_indent
parameter_list|(
name|dt_printarg_t
modifier|*
name|pap
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|pap
operator|->
name|pa_file
argument_list|,
literal|"%*s"
argument_list|,
operator|(
name|pap
operator|->
name|pa_depth
operator|+
name|pap
operator|->
name|pa_nest
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a bitfield.  It's worth noting that the D compiler support for  * bitfields is currently broken; printing "D`user_desc_t" (pulled in by the  * various D provider files) will produce incorrect results compared to  * "genunix`user_desc_t".  */
end_comment

begin_function
specifier|static
name|void
name|print_bitfield
parameter_list|(
name|dt_printarg_t
modifier|*
name|pap
parameter_list|,
name|ulong_t
name|off
parameter_list|,
name|ctf_encoding_t
modifier|*
name|ep
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|pap
operator|->
name|pa_file
decl_stmt|;
name|caddr_t
name|addr
init|=
name|pap
operator|->
name|pa_addr
operator|+
name|off
operator|/
name|NBBY
decl_stmt|;
name|uint64_t
name|mask
init|=
operator|(
literal|1ULL
operator|<<
name|ep
operator|->
name|cte_bits
operator|)
operator|-
literal|1
decl_stmt|;
name|uint64_t
name|value
init|=
literal|0
decl_stmt|;
name|size_t
name|size
init|=
operator|(
name|ep
operator|->
name|cte_bits
operator|+
operator|(
name|NBBY
operator|-
literal|1
operator|)
operator|)
operator|/
name|NBBY
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|value
decl_stmt|;
name|uint8_t
name|shift
decl_stmt|;
comment|/* 	 * On big-endian machines, we need to adjust the buf pointer to refer 	 * to the lowest 'size' bytes in 'value', and we need to shift based on 	 * the offset from the end of the data, not the offset of the start. 	 */
ifdef|#
directive|ifdef
name|_BIG_ENDIAN
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|value
argument_list|)
operator|-
name|size
expr_stmt|;
name|off
operator|+=
name|ep
operator|->
name|cte_bits
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|shift
operator|=
name|off
operator|%
name|NBBY
expr_stmt|;
comment|/* 	 * Offsets are counted from opposite ends on little- and 	 * big-endian machines. 	 */
ifdef|#
directive|ifdef
name|_BIG_ENDIAN
name|shift
operator|=
name|NBBY
operator|-
name|shift
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If the bits we want do not begin on a byte boundary, shift the data 	 * right so that the value is in the lowest 'cte_bits' of 'value'. 	 */
if|if
condition|(
name|off
operator|%
name|NBBY
operator|!=
literal|0
condition|)
name|value
operator|>>=
name|shift
expr_stmt|;
name|value
operator|&=
name|mask
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%#llx"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump the contents of memory as a fixed-size integer in hex.  */
end_comment

begin_function
specifier|static
name|void
name|dt_print_hex
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%#x"
argument_list|,
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
case|:
comment|/* LINTED - alignment */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%#x"
argument_list|,
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
case|:
comment|/* LINTED - alignment */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%#x"
argument_list|,
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%#llx"
argument_list|,
comment|/* LINTED - alignment */
operator|(
name|unsigned
name|long
name|long
operator|)
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"<invalid size %u>"
argument_list|,
operator|(
name|uint_t
operator|)
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print an integer type.  Before dumping the contents via dt_print_hex(), we  * first check the encoding to see if it's part of a bitfield or a character.  */
end_comment

begin_function
specifier|static
name|void
name|dt_print_int
parameter_list|(
name|ctf_id_t
name|base
parameter_list|,
name|ulong_t
name|off
parameter_list|,
name|dt_printarg_t
modifier|*
name|pap
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|pap
operator|->
name|pa_file
decl_stmt|;
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|pap
operator|->
name|pa_ctfp
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|caddr_t
name|addr
init|=
name|pap
operator|->
name|pa_addr
operator|+
name|off
operator|/
name|NBBY
decl_stmt|;
if|if
condition|(
name|ctf_type_encoding
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|,
operator|&
name|e
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"<unknown encoding>"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * This comes from MDB - it's not clear under what circumstances this 	 * would be found. 	 */
if|if
condition|(
name|e
operator|.
name|cte_format
operator|&
name|CTF_INT_VARARGS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We print this as a bitfield if the bit encoding indicates it's not 	 * an even power of two byte size, or is larger than 8 bytes. 	 */
name|size
operator|=
name|e
operator|.
name|cte_bits
operator|/
name|NBBY
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|8
operator|||
operator|(
name|e
operator|.
name|cte_bits
operator|%
name|NBBY
operator|)
operator|!=
literal|0
operator|||
operator|(
name|size
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|print_bitfield
argument_list|(
name|pap
argument_list|,
name|off
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this is a character, print it out as such. 	 */
if|if
condition|(
name|CTF_IS_CHAR
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|char
name|c
init|=
operator|*
operator|(
name|char
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"'%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"'\\0'"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"'\\%03o'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|dt_print_hex
argument_list|(
name|fp
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a floating point (float, double, long double) value.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dt_print_float
parameter_list|(
name|ctf_id_t
name|base
parameter_list|,
name|ulong_t
name|off
parameter_list|,
name|dt_printarg_t
modifier|*
name|pap
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|pap
operator|->
name|pa_file
decl_stmt|;
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|pap
operator|->
name|pa_ctfp
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|caddr_t
name|addr
init|=
name|pap
operator|->
name|pa_addr
operator|+
name|off
operator|/
name|NBBY
decl_stmt|;
if|if
condition|(
name|ctf_type_encoding
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|.
name|cte_format
operator|==
name|CTF_FP_SINGLE
operator|&&
name|e
operator|.
name|cte_bits
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
name|NBBY
condition|)
block|{
comment|/* LINTED - alignment */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%+.7e"
argument_list|,
operator|*
operator|(
operator|(
name|float
operator|*
operator|)
name|addr
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|cte_format
operator|==
name|CTF_FP_DOUBLE
operator|&&
name|e
operator|.
name|cte_bits
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|*
name|NBBY
condition|)
block|{
comment|/* LINTED - alignment */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%+.7e"
argument_list|,
operator|*
operator|(
operator|(
name|double
operator|*
operator|)
name|addr
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|cte_format
operator|==
name|CTF_FP_LDOUBLE
operator|&&
name|e
operator|.
name|cte_bits
operator|==
expr|sizeof
operator|(
name|long
name|double
operator|)
operator|*
name|NBBY
condition|)
block|{
comment|/* LINTED - alignment */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%+.16LE"
argument_list|,
operator|*
operator|(
operator|(
name|long
name|double
operator|*
operator|)
name|addr
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"<unknown encoding>"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * A pointer is generally printed as a fixed-size integer.  If we have a  * function pointer, we try to look up its name.  */
end_comment

begin_function
specifier|static
name|void
name|dt_print_ptr
parameter_list|(
name|ctf_id_t
name|base
parameter_list|,
name|ulong_t
name|off
parameter_list|,
name|dt_printarg_t
modifier|*
name|pap
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|pap
operator|->
name|pa_file
decl_stmt|;
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|pap
operator|->
name|pa_ctfp
decl_stmt|;
name|caddr_t
name|addr
init|=
name|pap
operator|->
name|pa_addr
operator|+
name|off
operator|/
name|NBBY
decl_stmt|;
name|size_t
name|size
init|=
name|ctf_type_size
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|ctf_id_t
name|bid
init|=
name|ctf_type_reference
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|uint64_t
name|pc
decl_stmt|;
name|dtrace_syminfo_t
name|dts
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
if|if
condition|(
name|bid
operator|==
name|CTF_ERR
operator|||
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|bid
argument_list|)
operator|!=
name|CTF_K_FUNCTION
condition|)
block|{
name|dt_print_hex
argument_list|(
name|fp
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* LINTED - alignment */
name|pc
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
if|if
condition|(
name|dtrace_lookup_by_addr
argument_list|(
name|pap
operator|->
name|pa_dtp
argument_list|,
name|pc
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|dts
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dt_print_hex
argument_list|(
name|fp
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s`%s"
argument_list|,
name|dts
operator|.
name|dts_object
argument_list|,
name|dts
operator|.
name|dts_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print out an array.  This is somewhat complex, as we must manually visit  * each member, and recursively invoke ctf_type_visit() for each member.  If  * the members are non-structs, then we print them out directly:  *  * 	[ 0x14, 0x2e, 0 ]  *  * If they are structs, then we print out the necessary leading and trailing  * braces, to end up with:  *  *	[  *	    type {  *	    ...  *	    },  *	    type {  *	    ...  *	    }  *	]  *  * We also use a heuristic to detect whether the array looks like a character  * array.  If the encoding indicates it's a character, and we have all  * printable characters followed by a null byte, then we display it as a  * string:  *  *	[ "string" ]  */
end_comment

begin_function
specifier|static
name|void
name|dt_print_array
parameter_list|(
name|ctf_id_t
name|base
parameter_list|,
name|ulong_t
name|off
parameter_list|,
name|dt_printarg_t
modifier|*
name|pap
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|pap
operator|->
name|pa_file
decl_stmt|;
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|pap
operator|->
name|pa_ctfp
decl_stmt|;
name|caddr_t
name|addr
init|=
name|pap
operator|->
name|pa_addr
operator|+
name|off
operator|/
name|NBBY
decl_stmt|;
name|ctf_arinfo_t
name|car
decl_stmt|;
name|ssize_t
name|eltsize
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
name|boolean_t
name|isstring
decl_stmt|;
name|int
name|kind
decl_stmt|;
name|ctf_id_t
name|rtype
decl_stmt|;
if|if
condition|(
name|ctf_array_info
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|,
operator|&
name|car
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"0x%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|eltsize
operator|=
name|ctf_type_size
argument_list|(
name|ctfp
argument_list|,
name|car
operator|.
name|ctr_contents
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|rtype
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|car
operator|.
name|ctr_contents
argument_list|)
operator|)
operator|==
name|CTF_ERR
operator|||
operator|(
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|rtype
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"<invalid type %lu>"
argument_list|,
name|car
operator|.
name|ctr_contents
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* see if this looks like a string */
name|isstring
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_INTEGER
operator|&&
name|ctf_type_encoding
argument_list|(
name|ctfp
argument_list|,
name|rtype
argument_list|,
operator|&
name|e
argument_list|)
operator|!=
name|CTF_ERR
operator|&&
name|CTF_IS_CHAR
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|char
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|car
operator|.
name|ctr_nelems
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
name|eltsize
operator|*
name|i
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'\0'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|!=
name|car
operator|.
name|ctr_nelems
operator|&&
name|c
operator|==
literal|'\0'
condition|)
name|isstring
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * As a slight aesthetic optimization, if we are a top-level type, then 	 * don't bother printing out the brackets.  This lets print("foo") look 	 * like: 	 * 	 * 	string "foo" 	 * 	 * As D will internally represent this as a char[256] array. 	 */
if|if
condition|(
operator|!
name|isstring
operator|||
name|pap
operator|->
name|pa_depth
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"[ "
argument_list|)
expr_stmt|;
if|if
condition|(
name|isstring
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|car
operator|.
name|ctr_nelems
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isstring
condition|)
block|{
name|char
name|c
init|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
name|eltsize
operator|*
name|i
operator|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Recursively invoke ctf_type_visit() on each member. 			 * We setup a new printarg struct with 'pa_nest' set to 			 * indicate that we are within a nested array. 			 */
name|dt_printarg_t
name|pa
init|=
operator|*
name|pap
decl_stmt|;
name|pa
operator|.
name|pa_nest
operator|+=
name|pap
operator|->
name|pa_depth
operator|+
literal|1
expr_stmt|;
name|pa
operator|.
name|pa_depth
operator|=
literal|0
expr_stmt|;
name|pa
operator|.
name|pa_addr
operator|=
name|addr
operator|+
name|eltsize
operator|*
name|i
expr_stmt|;
operator|(
name|void
operator|)
name|ctf_type_visit
argument_list|(
name|ctfp
argument_list|,
name|car
operator|.
name|ctr_contents
argument_list|,
name|dt_print_member
argument_list|,
operator|&
name|pa
argument_list|)
expr_stmt|;
name|dt_print_trailing_braces
argument_list|(
operator|&
name|pa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|car
operator|.
name|ctr_nelems
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CTF_IS_STRUCTLIKE
argument_list|(
name|kind
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isstring
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isstring
operator|||
name|pap
operator|->
name|pa_depth
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|CTF_IS_STRUCTLIKE
argument_list|(
name|kind
argument_list|)
condition|)
name|dt_print_indent
argument_list|(
name|pap
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This isued by both structs and unions to print the leading brace.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dt_print_structlike
parameter_list|(
name|ctf_id_t
name|id
parameter_list|,
name|ulong_t
name|off
parameter_list|,
name|dt_printarg_t
modifier|*
name|pap
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|pap
operator|->
name|pa_file
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For enums, we try to print the enum name, and fall back to the value if it  * can't be determined.  We do not do any fancy flag processing like mdb.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dt_print_enum
parameter_list|(
name|ctf_id_t
name|base
parameter_list|,
name|ulong_t
name|off
parameter_list|,
name|dt_printarg_t
modifier|*
name|pap
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|pap
operator|->
name|pa_file
decl_stmt|;
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|pap
operator|->
name|pa_ctfp
decl_stmt|;
specifier|const
name|char
modifier|*
name|ename
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
name|caddr_t
name|addr
init|=
name|pap
operator|->
name|pa_addr
operator|+
name|off
operator|/
name|NBBY
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
comment|/* 	 * The C standard says that an enum will be at most the sizeof (int). 	 * But if all the values are less than that, the compiler can use a 	 * smaller size. Thanks standards. 	 */
name|size
operator|=
name|ctf_type_size
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
case|:
name|value
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
case|:
name|value
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
case|:
name|value
operator|=
operator|*
operator|(
name|int32_t
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"<invalid enum size %u>"
argument_list|,
operator|(
name|uint_t
operator|)
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ename
operator|=
name|ctf_enum_name
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|,
name|value
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|ename
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Forward declaration.  There's not much to do here without the complete  * type information, so just print out this fact and drive on.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dt_print_tag
parameter_list|(
name|ctf_id_t
name|base
parameter_list|,
name|ulong_t
name|off
parameter_list|,
name|dt_printarg_t
modifier|*
name|pap
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|pap
operator|->
name|pa_file
argument_list|,
literal|"<forward decl>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
name|void
name|dt_printarg_f
parameter_list|(
name|ctf_id_t
parameter_list|,
name|ulong_t
parameter_list|,
name|dt_printarg_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|dt_printarg_f
modifier|*
specifier|const
name|dt_printfuncs
index|[]
init|=
block|{
name|dt_print_int
block|,
comment|/* CTF_K_INTEGER */
name|dt_print_float
block|,
comment|/* CTF_K_FLOAT */
name|dt_print_ptr
block|,
comment|/* CTF_K_POINTER */
name|dt_print_array
block|,
comment|/* CTF_K_ARRAY */
name|dt_print_ptr
block|,
comment|/* CTF_K_FUNCTION */
name|dt_print_structlike
block|,
comment|/* CTF_K_STRUCT */
name|dt_print_structlike
block|,
comment|/* CTF_K_UNION */
name|dt_print_enum
block|,
comment|/* CTF_K_ENUM */
name|dt_print_tag
comment|/* CTF_K_FORWARD */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print one member of a structure.  This callback is invoked from  * ctf_type_visit() recursively.  */
end_comment

begin_function
specifier|static
name|int
name|dt_print_member
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ctf_id_t
name|id
parameter_list|,
name|ulong_t
name|off
parameter_list|,
name|int
name|depth
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|char
name|type
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|int
name|kind
decl_stmt|;
name|dt_printarg_t
modifier|*
name|pap
init|=
name|data
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|pap
operator|->
name|pa_file
decl_stmt|;
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|pap
operator|->
name|pa_ctfp
decl_stmt|;
name|boolean_t
name|arraymember
decl_stmt|;
name|boolean_t
name|brief
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|ctf_id_t
name|rtype
decl_stmt|;
name|dt_print_trailing_braces
argument_list|(
name|pap
argument_list|,
name|depth
argument_list|)
expr_stmt|;
comment|/* 	 * dt_print_trailing_braces() doesn't include the trailing newline; add 	 * it here if necessary. 	 */
if|if
condition|(
name|depth
operator|<
name|pap
operator|->
name|pa_depth
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|pap
operator|->
name|pa_depth
operator|=
name|depth
expr_stmt|;
if|if
condition|(
operator|(
name|rtype
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|id
argument_list|)
operator|)
operator|==
name|CTF_ERR
operator|||
operator|(
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|rtype
argument_list|)
operator|)
operator|==
name|CTF_ERR
operator|||
name|kind
operator|<
name|CTF_K_INTEGER
operator|||
name|kind
operator|>
name|CTF_K_FORWARD
condition|)
block|{
name|dt_print_indent
argument_list|(
name|pap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s =<invalid type %lu>"
argument_list|,
name|name
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dt_print_type_name
argument_list|(
name|ctfp
argument_list|,
name|id
argument_list|,
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|arraymember
operator|=
operator|(
name|pap
operator|->
name|pa_nest
operator|!=
literal|0
operator|&&
name|depth
operator|==
literal|0
operator|)
expr_stmt|;
name|brief
operator|=
operator|(
name|arraymember
operator|&&
operator|!
name|CTF_IS_STRUCTLIKE
argument_list|(
name|kind
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|brief
condition|)
block|{
comment|/* 		 * If this is a direct array member and a struct (otherwise 		 * brief would be true), then print a trailing newline, as the 		 * array printing code doesn't include it because it might be a 		 * simple type. 		 */
if|if
condition|(
name|arraymember
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|dt_print_indent
argument_list|(
name|pap
argument_list|)
expr_stmt|;
comment|/* always print the type */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 			 * For aesthetics, we don't include a space between the 			 * type name and member name if the type is a pointer. 			 * This will give us "void *foo =" instead of "void * 			 * foo =".  Unions also have the odd behavior that the 			 * type name is returned as "union ", with a trailing 			 * space, so we also avoid printing a space if the type 			 * name already ends with a space. 			 */
if|if
condition|(
name|type
index|[
name|strlen
argument_list|(
name|type
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'*'
operator|&&
name|type
index|[
name|strlen
argument_list|(
name|type
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 			 * If this looks like a bitfield, or is an integer not 			 * aligned on a byte boundary, print the number of 			 * bits after the name. 			 */
if|if
condition|(
name|kind
operator|==
name|CTF_K_INTEGER
operator|&&
name|ctf_type_encoding
argument_list|(
name|ctfp
argument_list|,
name|id
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ulong_t
name|bits
init|=
name|e
operator|.
name|cte_bits
decl_stmt|;
name|ulong_t
name|size
init|=
name|bits
operator|/
name|NBBY
decl_stmt|;
if|if
condition|(
name|bits
operator|%
name|NBBY
operator|!=
literal|0
operator|||
name|off
operator|%
name|NBBY
operator|!=
literal|0
operator|||
name|size
operator|>
literal|8
operator|||
name|size
operator|!=
name|ctf_type_size
argument_list|(
name|ctfp
argument_list|,
name|id
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" :%lu"
argument_list|,
name|bits
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" ="
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|dt_printfuncs
index|[
name|kind
operator|-
literal|1
index|]
operator|(
name|rtype
operator|,
name|off
operator|,
name|pap
operator|)
expr_stmt|;
comment|/* direct simple array members are not separated by newlines */
if|if
condition|(
operator|!
name|brief
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Main print function invoked by dt_consume_cpu().  */
end_comment

begin_function
name|int
name|dtrace_print
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|typename
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|object
decl_stmt|;
name|dt_printarg_t
name|pa
decl_stmt|;
name|ctf_id_t
name|id
decl_stmt|;
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
name|ctf_file_t
modifier|*
name|ctfp
decl_stmt|;
name|int
name|libid
decl_stmt|;
comment|/* 	 * Split the fully-qualified type ID (module`id).  This should 	 * always be the format, but if for some reason we don't find the 	 * expected value, return 0 to fall back to the generic trace() 	 * behavior. In the case of userland CTF modules this will actually be 	 * of the format (module`lib`id). This is due to the fact that those 	 * modules have multiple CTF containers which `lib` identifies. 	 */
for|for
control|(
name|s
operator|=
name|typename
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|s
operator|!=
literal|'`'
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'`'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|object
operator|=
name|alloca
argument_list|(
name|s
operator|-
name|typename
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|typename
argument_list|,
name|object
argument_list|,
name|s
operator|-
name|typename
argument_list|)
expr_stmt|;
name|object
index|[
name|s
operator|-
name|typename
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dmp
operator|=
name|dt_module_lookup_by_name
argument_list|(
name|dtp
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dmp
operator|->
name|dm_pid
operator|!=
literal|0
condition|)
block|{
name|libid
operator|=
name|atoi
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|'`'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|libid
operator|>
name|dmp
operator|->
name|dm_nctflibs
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ctfp
operator|=
name|dmp
operator|->
name|dm_libctfp
index|[
name|libid
index|]
expr_stmt|;
block|}
else|else
block|{
name|ctfp
operator|=
name|dt_module_getctf
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
block|}
name|id
operator|=
name|atoi
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Try to get the CTF kind for this id.  If something has gone horribly 	 * wrong and we can't resolve the ID, bail out and let trace() do the 	 * work. 	 */
if|if
condition|(
name|ctfp
operator|==
name|NULL
operator|||
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|id
argument_list|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* setup the print structure and kick off the main print routine */
name|pa
operator|.
name|pa_dtp
operator|=
name|dtp
expr_stmt|;
name|pa
operator|.
name|pa_addr
operator|=
name|addr
expr_stmt|;
name|pa
operator|.
name|pa_ctfp
operator|=
name|ctfp
expr_stmt|;
name|pa
operator|.
name|pa_nest
operator|=
literal|0
expr_stmt|;
name|pa
operator|.
name|pa_depth
operator|=
literal|0
expr_stmt|;
name|pa
operator|.
name|pa_file
operator|=
name|fp
expr_stmt|;
operator|(
name|void
operator|)
name|ctf_type_visit
argument_list|(
name|pa
operator|.
name|pa_ctfp
argument_list|,
name|id
argument_list|,
name|dt_print_member
argument_list|,
operator|&
name|pa
argument_list|)
expr_stmt|;
name|dt_print_trailing_braces
argument_list|(
operator|&
name|pa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

end_unit

