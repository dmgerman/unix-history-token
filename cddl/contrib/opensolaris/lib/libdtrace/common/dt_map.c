begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_include
include|#
directive|include
file|<dt_printf.h>
end_include

begin_function
specifier|static
name|int
name|dt_epid_add
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_epid_t
name|id
parameter_list|)
block|{
name|dtrace_id_t
name|max
decl_stmt|;
name|int
name|rval
decl_stmt|,
name|i
decl_stmt|,
name|maxformat
decl_stmt|;
name|dtrace_eprobedesc_t
modifier|*
name|enabled
decl_stmt|,
modifier|*
name|nenabled
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
name|probe
decl_stmt|;
while|while
condition|(
name|id
operator|>=
operator|(
name|max
operator|=
name|dtp
operator|->
name|dt_maxprobe
operator|)
operator|||
name|dtp
operator|->
name|dt_pdesc
operator|==
name|NULL
condition|)
block|{
name|dtrace_id_t
name|new_max
init|=
name|max
condition|?
operator|(
name|max
operator|<<
literal|1
operator|)
else|:
literal|1
decl_stmt|;
name|size_t
name|nsize
init|=
name|new_max
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
modifier|*
name|new_pdesc
decl_stmt|;
name|dtrace_eprobedesc_t
modifier|*
modifier|*
name|new_edesc
decl_stmt|;
if|if
condition|(
operator|(
name|new_pdesc
operator|=
name|malloc
argument_list|(
name|nsize
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|new_edesc
operator|=
name|malloc
argument_list|(
name|nsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|new_pdesc
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|bzero
argument_list|(
name|new_pdesc
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|new_edesc
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_pdesc
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|osize
init|=
name|max
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|dtp
operator|->
name|dt_pdesc
argument_list|,
name|new_pdesc
argument_list|,
name|osize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtp
operator|->
name|dt_pdesc
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dtp
operator|->
name|dt_edesc
argument_list|,
name|new_edesc
argument_list|,
name|osize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtp
operator|->
name|dt_edesc
argument_list|)
expr_stmt|;
block|}
name|dtp
operator|->
name|dt_pdesc
operator|=
name|new_pdesc
expr_stmt|;
name|dtp
operator|->
name|dt_edesc
operator|=
name|new_edesc
expr_stmt|;
name|dtp
operator|->
name|dt_maxprobe
operator|=
name|new_max
expr_stmt|;
block|}
if|if
condition|(
name|dtp
operator|->
name|dt_pdesc
index|[
name|id
index|]
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|enabled
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_eprobedesc_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
name|bzero
argument_list|(
name|enabled
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_eprobedesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|enabled
operator|->
name|dtepd_epid
operator|=
name|id
expr_stmt|;
name|enabled
operator|->
name|dtepd_nrecs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_EPROBE
argument_list|,
name|enabled
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rval
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
if|if
condition|(
name|DTRACE_SIZEOF_EPROBEDESC
argument_list|(
name|enabled
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|enabled
argument_list|)
condition|)
block|{
comment|/* 		 * There must be more than one action.  Allocate the 		 * appropriate amount of space and try again. 		 */
if|if
condition|(
operator|(
name|nenabled
operator|=
name|malloc
argument_list|(
name|DTRACE_SIZEOF_EPROBEDESC
argument_list|(
name|enabled
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|enabled
argument_list|,
name|nenabled
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|enabled
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|enabled
operator|=
name|nenabled
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
name|rval
operator|=
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_EPROBE
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
condition|)
block|{
name|rval
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|probe
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_probedesc_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|probe
operator|->
name|dtpd_id
operator|=
name|enabled
operator|->
name|dtepd_probeid
expr_stmt|;
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_PROBES
argument_list|,
name|probe
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rval
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enabled
operator|->
name|dtepd_nrecs
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_fmtdesc_t
name|fmt
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|rec
init|=
operator|&
name|enabled
operator|->
name|dtepd_rec
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|DTRACEACT_ISPRINTFLIKE
argument_list|(
name|rec
operator|->
name|dtrd_action
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|rec
operator|->
name|dtrd_format
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|rec
operator|->
name|dtrd_format
operator|<=
name|dtp
operator|->
name|dt_maxformat
operator|&&
name|dtp
operator|->
name|dt_formats
index|[
name|rec
operator|->
name|dtrd_format
operator|-
literal|1
index|]
operator|!=
name|NULL
condition|)
continue|continue;
name|bzero
argument_list|(
operator|&
name|fmt
argument_list|,
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|dtfd_format
operator|=
name|rec
operator|->
name|dtrd_format
expr_stmt|;
name|fmt
operator|.
name|dtfd_string
operator|=
name|NULL
expr_stmt|;
name|fmt
operator|.
name|dtfd_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_FORMAT
argument_list|,
operator|&
name|fmt
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rval
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|fmt
operator|.
name|dtfd_string
operator|=
name|malloc
argument_list|(
name|fmt
operator|.
name|dtfd_length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_FORMAT
argument_list|,
operator|&
name|fmt
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rval
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fmt
operator|.
name|dtfd_string
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
while|while
condition|(
name|rec
operator|->
name|dtrd_format
operator|>
operator|(
name|maxformat
operator|=
name|dtp
operator|->
name|dt_maxformat
operator|)
condition|)
block|{
name|int
name|new_max
init|=
name|maxformat
condition|?
operator|(
name|maxformat
operator|<<
literal|1
operator|)
else|:
literal|1
decl_stmt|;
name|size_t
name|nsize
init|=
name|new_max
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
name|size_t
name|osize
init|=
name|maxformat
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
name|void
modifier|*
modifier|*
name|new_formats
init|=
name|malloc
argument_list|(
name|nsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_formats
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fmt
operator|.
name|dtfd_string
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|bzero
argument_list|(
name|new_formats
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dtp
operator|->
name|dt_formats
argument_list|,
name|new_formats
argument_list|,
name|osize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtp
operator|->
name|dt_formats
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_formats
operator|=
name|new_formats
expr_stmt|;
name|dtp
operator|->
name|dt_maxformat
operator|=
name|new_max
expr_stmt|;
block|}
name|dtp
operator|->
name|dt_formats
index|[
name|rec
operator|->
name|dtrd_format
operator|-
literal|1
index|]
operator|=
name|rec
operator|->
name|dtrd_action
operator|==
name|DTRACEACT_PRINTA
condition|?
name|dtrace_printa_create
argument_list|(
name|dtp
argument_list|,
name|fmt
operator|.
name|dtfd_string
argument_list|)
else|:
name|dtrace_printf_create
argument_list|(
name|dtp
argument_list|,
name|fmt
operator|.
name|dtfd_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fmt
operator|.
name|dtfd_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_formats
index|[
name|rec
operator|->
name|dtrd_format
operator|-
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* dt_errno is set for us */
goto|goto
name|err
goto|;
block|}
block|}
name|dtp
operator|->
name|dt_pdesc
index|[
name|id
index|]
operator|=
name|probe
expr_stmt|;
name|dtp
operator|->
name|dt_edesc
index|[
name|id
index|]
operator|=
name|enabled
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
comment|/* 	 * If we failed, free our allocated probes.  Note that if we failed 	 * while allocating formats, we aren't going to free formats that 	 * we have already allocated.  This is okay; these formats are 	 * hanging off of dt_formats and will therefore not be leaked. 	 */
name|free
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|probe
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_epid_lookup
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_epid_t
name|epid
parameter_list|,
name|dtrace_eprobedesc_t
modifier|*
modifier|*
name|epdp
parameter_list|,
name|dtrace_probedesc_t
modifier|*
modifier|*
name|pdp
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
if|if
condition|(
name|epid
operator|>=
name|dtp
operator|->
name|dt_maxprobe
operator|||
name|dtp
operator|->
name|dt_pdesc
index|[
name|epid
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_epid_add
argument_list|(
name|dtp
argument_list|,
name|epid
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
block|}
name|assert
argument_list|(
name|epid
operator|<
name|dtp
operator|->
name|dt_maxprobe
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dtp
operator|->
name|dt_edesc
index|[
name|epid
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dtp
operator|->
name|dt_pdesc
index|[
name|epid
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|epdp
operator|=
name|dtp
operator|->
name|dt_edesc
index|[
name|epid
index|]
expr_stmt|;
operator|*
name|pdp
operator|=
name|dtp
operator|->
name|dt_pdesc
index|[
name|epid
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_epid_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|assert
argument_list|(
operator|(
name|dtp
operator|->
name|dt_pdesc
operator|!=
name|NULL
operator|&&
name|dtp
operator|->
name|dt_edesc
operator|!=
name|NULL
operator|&&
name|dtp
operator|->
name|dt_maxprobe
operator|>
literal|0
operator|)
operator|||
operator|(
name|dtp
operator|->
name|dt_pdesc
operator|==
name|NULL
operator|&&
name|dtp
operator|->
name|dt_edesc
operator|==
name|NULL
operator|&&
name|dtp
operator|->
name|dt_maxprobe
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_pdesc
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtp
operator|->
name|dt_maxprobe
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dtp
operator|->
name|dt_edesc
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|dtp
operator|->
name|dt_pdesc
index|[
name|i
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|assert
argument_list|(
name|dtp
operator|->
name|dt_pdesc
index|[
name|i
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtp
operator|->
name|dt_edesc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtp
operator|->
name|dt_pdesc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dtp
operator|->
name|dt_pdesc
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_pdesc
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|dtp
operator|->
name|dt_edesc
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_edesc
operator|=
name|NULL
expr_stmt|;
name|dtp
operator|->
name|dt_maxprobe
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|dt_format_lookup
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|int
name|format
parameter_list|)
block|{
if|if
condition|(
name|format
operator|==
literal|0
operator|||
name|format
operator|>
name|dtp
operator|->
name|dt_maxformat
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|dtp
operator|->
name|dt_formats
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|dtp
operator|->
name|dt_formats
index|[
name|format
operator|-
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_format_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtp
operator|->
name|dt_maxformat
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dtp
operator|->
name|dt_formats
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|dt_printf_destroy
argument_list|(
name|dtp
operator|->
name|dt_formats
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dtp
operator|->
name|dt_formats
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_formats
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggid_add
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_aggid_t
name|id
parameter_list|)
block|{
name|dtrace_id_t
name|max
decl_stmt|;
name|dtrace_epid_t
name|epid
decl_stmt|;
name|int
name|rval
decl_stmt|;
while|while
condition|(
name|id
operator|>=
operator|(
name|max
operator|=
name|dtp
operator|->
name|dt_maxagg
operator|)
operator|||
name|dtp
operator|->
name|dt_aggdesc
operator|==
name|NULL
condition|)
block|{
name|dtrace_id_t
name|new_max
init|=
name|max
condition|?
operator|(
name|max
operator|<<
literal|1
operator|)
else|:
literal|1
decl_stmt|;
name|size_t
name|nsize
init|=
name|new_max
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
modifier|*
name|new_aggdesc
decl_stmt|;
if|if
condition|(
operator|(
name|new_aggdesc
operator|=
name|malloc
argument_list|(
name|nsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
name|bzero
argument_list|(
name|new_aggdesc
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_aggdesc
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|dtp
operator|->
name|dt_aggdesc
argument_list|,
name|new_aggdesc
argument_list|,
name|max
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtp
operator|->
name|dt_aggdesc
argument_list|)
expr_stmt|;
block|}
name|dtp
operator|->
name|dt_aggdesc
operator|=
name|new_aggdesc
expr_stmt|;
name|dtp
operator|->
name|dt_maxagg
operator|=
name|new_max
expr_stmt|;
block|}
if|if
condition|(
name|dtp
operator|->
name|dt_aggdesc
index|[
name|id
index|]
operator|==
name|NULL
condition|)
block|{
name|dtrace_aggdesc_t
modifier|*
name|agg
decl_stmt|,
modifier|*
name|nagg
decl_stmt|;
if|if
condition|(
operator|(
name|agg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_aggdesc_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
name|bzero
argument_list|(
name|agg
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_aggdesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|agg
operator|->
name|dtagd_id
operator|=
name|id
expr_stmt|;
name|agg
operator|->
name|dtagd_nrecs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_AGGDESC
argument_list|,
name|agg
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rval
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|agg
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
if|if
condition|(
name|DTRACE_SIZEOF_AGGDESC
argument_list|(
name|agg
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|agg
argument_list|)
condition|)
block|{
comment|/* 			 * There must be more than one action.  Allocate the 			 * appropriate amount of space and try again. 			 */
if|if
condition|(
operator|(
name|nagg
operator|=
name|malloc
argument_list|(
name|DTRACE_SIZEOF_AGGDESC
argument_list|(
name|agg
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|agg
argument_list|,
name|nagg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|agg
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|agg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|agg
operator|=
name|nagg
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
name|rval
operator|=
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_AGGDESC
argument_list|,
name|agg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
condition|)
block|{
name|rval
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|agg
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
block|}
comment|/* 		 * If we have a uarg, it's a pointer to the compiler-generated 		 * statement; we'll use this value to get the name and 		 * compiler-generated variable ID for the aggregation.  If 		 * we're grabbing an anonymous enabling, this pointer value 		 * is obviously meaningless -- and in this case, we can't 		 * provide the compiler-generated aggregation information. 		 */
if|if
condition|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_GRABANON
index|]
operator|==
name|DTRACEOPT_UNSET
operator|&&
name|agg
operator|->
name|dtagd_rec
index|[
literal|0
index|]
operator|.
name|dtrd_uarg
operator|!=
name|NULL
condition|)
block|{
name|dtrace_stmtdesc_t
modifier|*
name|sdp
decl_stmt|;
name|dt_ident_t
modifier|*
name|aid
decl_stmt|;
name|sdp
operator|=
operator|(
name|dtrace_stmtdesc_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|agg
operator|->
name|dtagd_rec
index|[
literal|0
index|]
operator|.
name|dtrd_uarg
expr_stmt|;
name|aid
operator|=
name|sdp
operator|->
name|dtsd_aggdata
expr_stmt|;
name|agg
operator|->
name|dtagd_name
operator|=
name|aid
operator|->
name|di_name
expr_stmt|;
name|agg
operator|->
name|dtagd_varid
operator|=
name|aid
operator|->
name|di_id
expr_stmt|;
block|}
else|else
block|{
name|agg
operator|->
name|dtagd_varid
operator|=
name|DTRACE_AGGVARIDNONE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|epid
operator|=
name|agg
operator|->
name|dtagd_epid
operator|)
operator|>=
name|dtp
operator|->
name|dt_maxprobe
operator|||
name|dtp
operator|->
name|dt_pdesc
index|[
name|epid
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_epid_add
argument_list|(
name|dtp
argument_list|,
name|epid
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|agg
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
block|}
name|dtp
operator|->
name|dt_aggdesc
index|[
name|id
index|]
operator|=
name|agg
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_aggid_lookup
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_aggid_t
name|aggid
parameter_list|,
name|dtrace_aggdesc_t
modifier|*
modifier|*
name|adp
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
if|if
condition|(
name|aggid
operator|>=
name|dtp
operator|->
name|dt_maxagg
operator|||
name|dtp
operator|->
name|dt_aggdesc
index|[
name|aggid
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_aggid_add
argument_list|(
name|dtp
argument_list|,
name|aggid
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
block|}
name|assert
argument_list|(
name|aggid
operator|<
name|dtp
operator|->
name|dt_maxagg
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dtp
operator|->
name|dt_aggdesc
index|[
name|aggid
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|adp
operator|=
name|dtp
operator|->
name|dt_aggdesc
index|[
name|aggid
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_aggid_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|assert
argument_list|(
operator|(
name|dtp
operator|->
name|dt_aggdesc
operator|!=
name|NULL
operator|&&
name|dtp
operator|->
name|dt_maxagg
operator|!=
literal|0
operator|)
operator|||
operator|(
name|dtp
operator|->
name|dt_aggdesc
operator|==
name|NULL
operator|&&
name|dtp
operator|->
name|dt_maxagg
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_aggdesc
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtp
operator|->
name|dt_maxagg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dtp
operator|->
name|dt_aggdesc
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dtp
operator|->
name|dt_aggdesc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dtp
operator|->
name|dt_aggdesc
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_aggdesc
operator|=
name|NULL
expr_stmt|;
name|dtp
operator|->
name|dt_maxagg
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

