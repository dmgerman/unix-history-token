begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|int
name|dtslt_option
decl_stmt|;
name|size_t
name|dtslt_offs
decl_stmt|;
block|}
name|_dtrace_sleeptab
index|[]
init|=
block|{
block|{
name|DTRACEOPT_STATUSRATE
block|,
name|offsetof
argument_list|(
argument|dtrace_hdl_t
argument_list|,
argument|dt_laststatus
argument_list|)
block|}
block|,
block|{
name|DTRACEOPT_AGGRATE
block|,
name|offsetof
argument_list|(
argument|dtrace_hdl_t
argument_list|,
argument|dt_lastagg
argument_list|)
block|}
block|,
block|{
name|DTRACEOPT_SWITCHRATE
block|,
name|offsetof
argument_list|(
argument|dtrace_hdl_t
argument_list|,
argument|dt_lastswitch
argument_list|)
block|}
block|,
block|{
name|DTRACEOPT_MAX
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
name|void
name|dtrace_sleep
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dt_proc_hash_t
modifier|*
name|dph
init|=
name|dtp
operator|->
name|dt_procs
decl_stmt|;
name|dtrace_optval_t
name|policy
init|=
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_BUFPOLICY
index|]
decl_stmt|;
name|dt_proc_notify_t
modifier|*
name|dprn
decl_stmt|;
name|hrtime_t
name|earliest
init|=
name|INT64_MAX
decl_stmt|;
name|struct
name|timespec
name|tv
decl_stmt|;
name|hrtime_t
name|now
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|_dtrace_sleeptab
index|[
name|i
index|]
operator|.
name|dtslt_option
operator|<
name|DTRACEOPT_MAX
condition|;
name|i
operator|++
control|)
block|{
name|uintptr_t
name|a
init|=
operator|(
name|uintptr_t
operator|)
name|dtp
operator|+
name|_dtrace_sleeptab
index|[
name|i
index|]
operator|.
name|dtslt_offs
decl_stmt|;
name|int
name|opt
init|=
name|_dtrace_sleeptab
index|[
name|i
index|]
operator|.
name|dtslt_option
decl_stmt|;
name|dtrace_optval_t
name|interval
init|=
name|dtp
operator|->
name|dt_options
index|[
name|opt
index|]
decl_stmt|;
comment|/* 		 * If the buffering policy is set to anything other than 		 * "switch", we ignore the aggrate and switchrate -- they're 		 * meaningless. 		 */
if|if
condition|(
name|policy
operator|!=
name|DTRACEOPT_BUFPOLICY_SWITCH
operator|&&
name|_dtrace_sleeptab
index|[
name|i
index|]
operator|.
name|dtslt_option
operator|!=
name|DTRACEOPT_STATUSRATE
condition|)
continue|continue;
if|if
condition|(
operator|*
operator|(
operator|(
name|hrtime_t
operator|*
operator|)
name|a
operator|)
operator|+
name|interval
operator|<
name|earliest
condition|)
name|earliest
operator|=
operator|*
operator|(
operator|(
name|hrtime_t
operator|*
operator|)
name|a
operator|)
operator|+
name|interval
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dph
operator|->
name|dph_lock
argument_list|)
expr_stmt|;
name|now
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|earliest
operator|<
name|now
condition|)
block|{
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dph
operator|->
name|dph_lock
argument_list|)
expr_stmt|;
return|return;
comment|/* sleep duration has already past */
block|}
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|tv
operator|.
name|tv_sec
operator|=
operator|(
name|earliest
operator|-
name|now
operator|)
operator|/
name|NANOSEC
expr_stmt|;
name|tv
operator|.
name|tv_nsec
operator|=
operator|(
name|earliest
operator|-
name|now
operator|)
operator|%
name|NANOSEC
expr_stmt|;
comment|/* 	 * Wait for either 'tv' nanoseconds to pass or to receive notification 	 * that a process is in an interesting state.  Regardless of why we 	 * awaken, iterate over any pending notifications and process them. 	 */
operator|(
name|void
operator|)
name|pthread_cond_reltimedwait_np
argument_list|(
operator|&
name|dph
operator|->
name|dph_cv
argument_list|,
operator|&
name|dph
operator|->
name|dph_lock
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
else|#
directive|else
name|earliest
operator|-=
name|now
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|+=
name|earliest
operator|/
name|NANOSEC
expr_stmt|;
name|tv
operator|.
name|tv_nsec
operator|+=
name|earliest
operator|%
name|NANOSEC
expr_stmt|;
while|while
condition|(
name|tv
operator|.
name|tv_nsec
operator|>
name|NANOSEC
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|+=
literal|1
expr_stmt|;
name|tv
operator|.
name|tv_nsec
operator|-=
name|NANOSEC
expr_stmt|;
block|}
comment|/* 	 * Wait for either 'tv' nanoseconds to pass or to receive notification 	 * that a process is in an interesting state.  Regardless of why we 	 * awaken, iterate over any pending notifications and process them. 	 */
operator|(
name|void
operator|)
name|pthread_cond_timedwait
argument_list|(
operator|&
name|dph
operator|->
name|dph_cv
argument_list|,
operator|&
name|dph
operator|->
name|dph_lock
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|dprn
operator|=
name|dph
operator|->
name|dph_notify
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dtp
operator|->
name|dt_prochdlr
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|err
init|=
name|dprn
operator|->
name|dprn_errmsg
decl_stmt|;
if|if
condition|(
operator|*
name|err
operator|==
literal|'\0'
condition|)
name|err
operator|=
name|NULL
expr_stmt|;
name|dtp
operator|->
name|dt_prochdlr
argument_list|(
name|dprn
operator|->
name|dprn_dpr
operator|->
name|dpr_proc
argument_list|,
name|err
argument_list|,
name|dtp
operator|->
name|dt_procarg
argument_list|)
expr_stmt|;
block|}
name|dph
operator|->
name|dph_notify
operator|=
name|dprn
operator|->
name|dprn_next
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dprn
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dph
operator|->
name|dph_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dtrace_status
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|int
name|gen
init|=
name|dtp
operator|->
name|dt_statusgen
decl_stmt|;
name|dtrace_optval_t
name|interval
init|=
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_STATUSRATE
index|]
decl_stmt|;
name|hrtime_t
name|now
init|=
name|gethrtime
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dtp
operator|->
name|dt_active
condition|)
return|return
operator|(
name|DTRACE_STATUS_NONE
operator|)
return|;
if|if
condition|(
name|dtp
operator|->
name|dt_stopped
condition|)
return|return
operator|(
name|DTRACE_STATUS_STOPPED
operator|)
return|;
if|if
condition|(
name|dtp
operator|->
name|dt_laststatus
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|now
operator|-
name|dtp
operator|->
name|dt_laststatus
operator|<
name|interval
condition|)
return|return
operator|(
name|DTRACE_STATUS_NONE
operator|)
return|;
name|dtp
operator|->
name|dt_laststatus
operator|+=
name|interval
expr_stmt|;
block|}
else|else
block|{
name|dtp
operator|->
name|dt_laststatus
operator|=
name|now
expr_stmt|;
block|}
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_STATUS
argument_list|,
operator|&
name|dtp
operator|->
name|dt_status
index|[
name|gen
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
name|dtp
operator|->
name|dt_statusgen
operator|^=
literal|1
expr_stmt|;
if|if
condition|(
name|dt_handle_status
argument_list|(
name|dtp
argument_list|,
operator|&
name|dtp
operator|->
name|dt_status
index|[
name|dtp
operator|->
name|dt_statusgen
index|]
argument_list|,
operator|&
name|dtp
operator|->
name|dt_status
index|[
name|gen
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dtp
operator|->
name|dt_status
index|[
name|gen
index|]
operator|.
name|dtst_exiting
condition|)
block|{
if|if
condition|(
operator|!
name|dtp
operator|->
name|dt_stopped
condition|)
operator|(
name|void
operator|)
name|dtrace_stop
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|DTRACE_STATUS_EXITED
operator|)
return|;
block|}
if|if
condition|(
name|dtp
operator|->
name|dt_status
index|[
name|gen
index|]
operator|.
name|dtst_filled
operator|==
literal|0
condition|)
return|return
operator|(
name|DTRACE_STATUS_OKAY
operator|)
return|;
if|if
condition|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_BUFPOLICY
index|]
operator|!=
name|DTRACEOPT_BUFPOLICY_FILL
condition|)
return|return
operator|(
name|DTRACE_STATUS_OKAY
operator|)
return|;
if|if
condition|(
operator|!
name|dtp
operator|->
name|dt_stopped
condition|)
block|{
if|if
condition|(
name|dtrace_stop
argument_list|(
name|dtp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|DTRACE_STATUS_FILLED
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_go
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dtrace_enable_io_t
name|args
decl_stmt|;
name|void
modifier|*
name|dof
decl_stmt|;
name|int
name|error
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_active
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* 	 * If a dtrace:::ERROR program and callback are registered, enable the 	 * program before we start tracing.  If this fails for a vector open 	 * with ENOTTY, we permit dtrace_go() to succeed so that vector clients 	 * such as mdb's dtrace module can execute the rest of dtrace_go() even 	 * though they do not provide support for the DTRACEIOC_ENABLE ioctl. 	 */
if|if
condition|(
name|dtp
operator|->
name|dt_errprog
operator|!=
name|NULL
operator|&&
name|dtrace_program_exec
argument_list|(
name|dtp
argument_list|,
name|dtp
operator|->
name|dt_errprog
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|dtp
operator|->
name|dt_errno
operator|!=
name|ENOTTY
operator|||
name|dtp
operator|->
name|dt_vector
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dt_errno has been set for us */
if|if
condition|(
operator|(
name|dof
operator|=
name|dtrace_getopt_dof
argument_list|(
name|dtp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dt_errno has been set for us */
name|args
operator|.
name|dof
operator|=
name|dof
expr_stmt|;
name|args
operator|.
name|n_matched
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_ENABLE
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|error
operator|=
name|errno
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dtp
argument_list|,
name|dof
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
operator|&&
operator|(
name|error
operator|!=
name|ENOTTY
operator|||
name|dtp
operator|->
name|dt_vector
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|error
argument_list|)
operator|)
return|;
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_GO
argument_list|,
operator|&
name|dtp
operator|->
name|dt_beganon
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EACCES
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DESTRUCTIVE
argument_list|)
operator|)
return|;
if|if
condition|(
name|errno
operator|==
name|EALREADY
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_ISANON
argument_list|)
operator|)
return|;
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOANON
argument_list|)
operator|)
return|;
if|if
condition|(
name|errno
operator|==
name|E2BIG
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_ENDTOOBIG
argument_list|)
operator|)
return|;
if|if
condition|(
name|errno
operator|==
name|ENOSPC
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BUFTOOSMALL
argument_list|)
operator|)
return|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
name|dtp
operator|->
name|dt_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dt_options_load
argument_list|(
name|dtp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
return|return
operator|(
name|dt_aggregate_go
argument_list|(
name|dtp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_stop
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|int
name|gen
init|=
name|dtp
operator|->
name|dt_statusgen
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_stopped
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_STOP
argument_list|,
operator|&
name|dtp
operator|->
name|dt_endedon
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
name|dtp
operator|->
name|dt_stopped
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Now that we're stopped, we're going to get status one final time. 	 */
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_STATUS
argument_list|,
operator|&
name|dtp
operator|->
name|dt_status
index|[
name|gen
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
name|dt_handle_status
argument_list|(
name|dtp
argument_list|,
operator|&
name|dtp
operator|->
name|dt_status
index|[
name|gen
operator|^
literal|1
index|]
argument_list|,
operator|&
name|dtp
operator|->
name|dt_status
index|[
name|gen
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|dtrace_workstatus_t
name|dtrace_work
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|dtrace_consume_probe_f
modifier|*
name|pfunc
parameter_list|,
name|dtrace_consume_rec_f
modifier|*
name|rfunc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|status
init|=
name|dtrace_status
argument_list|(
name|dtp
argument_list|)
decl_stmt|;
name|dtrace_optval_t
name|policy
init|=
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_BUFPOLICY
index|]
decl_stmt|;
name|dtrace_workstatus_t
name|rval
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|DTRACE_STATUS_EXITED
case|:
case|case
name|DTRACE_STATUS_FILLED
case|:
case|case
name|DTRACE_STATUS_STOPPED
case|:
comment|/* 		 * Tracing is stopped.  We now want to force dtrace_consume() 		 * and dtrace_aggregate_snap() to proceed, regardless of 		 * switchrate and aggrate.  We do this by clearing the times. 		 */
name|dtp
operator|->
name|dt_lastswitch
operator|=
literal|0
expr_stmt|;
name|dtp
operator|->
name|dt_lastagg
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
name|DTRACE_WORKSTATUS_DONE
expr_stmt|;
break|break;
case|case
name|DTRACE_STATUS_NONE
case|:
case|case
name|DTRACE_STATUS_OKAY
case|:
name|rval
operator|=
name|DTRACE_WORKSTATUS_OKAY
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
return|return
operator|(
name|DTRACE_WORKSTATUS_ERROR
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|==
name|DTRACE_STATUS_NONE
operator|||
name|status
operator|==
name|DTRACE_STATUS_OKAY
operator|)
operator|&&
name|policy
operator|!=
name|DTRACEOPT_BUFPOLICY_SWITCH
condition|)
block|{
comment|/* 		 * There either isn't any status or things are fine -- and 		 * this is a "ring" or "fill" buffer.  We don't want to consume 		 * any of the trace data or snapshot the aggregations; we just 		 * return. 		 */
name|assert
argument_list|(
name|rval
operator|==
name|DTRACE_WORKSTATUS_OKAY
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
if|if
condition|(
name|dtrace_aggregate_snap
argument_list|(
name|dtp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|DTRACE_WORKSTATUS_ERROR
operator|)
return|;
if|if
condition|(
name|dtrace_consume
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|pfunc
argument_list|,
name|rfunc
argument_list|,
name|arg
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|DTRACE_WORKSTATUS_ERROR
operator|)
return|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

end_unit

