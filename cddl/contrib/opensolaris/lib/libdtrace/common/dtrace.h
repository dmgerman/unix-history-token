begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013 by Delphix. All rights reserved.  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_DTRACE_H
end_ifndef

begin_define
define|#
directive|define
name|_DTRACE_H
end_define

begin_include
include|#
directive|include
file|<sys/dtrace.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<gelf.h>
end_include

begin_include
include|#
directive|include
file|<libproc.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<rtld_db.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * DTrace Dynamic Tracing Software: Library Interfaces  *  * Note: The contents of this file are private to the implementation of the  * Solaris system and DTrace subsystem and are subject to change at any time  * without notice.  Applications and drivers using these interfaces will fail  * to run on future releases.  These interfaces should not be used for any  * purpose except those expressly outlined in dtrace(7D) and libdtrace(3LIB).  * Please refer to the "Solaris Dynamic Tracing Guide" for more information.  */
define|#
directive|define
name|DTRACE_VERSION
value|3
comment|/* library ABI interface version */
struct_decl|struct
name|ps_prochandle
struct_decl|;
typedef|typedef
name|struct
name|dtrace_hdl
name|dtrace_hdl_t
typedef|;
typedef|typedef
name|struct
name|dtrace_prog
name|dtrace_prog_t
typedef|;
typedef|typedef
name|struct
name|dtrace_vector
name|dtrace_vector_t
typedef|;
typedef|typedef
name|struct
name|dtrace_aggdata
name|dtrace_aggdata_t
typedef|;
define|#
directive|define
name|DTRACE_O_NODEV
value|0x01
comment|/* do not open dtrace(7D) device */
define|#
directive|define
name|DTRACE_O_NOSYS
value|0x02
comment|/* do not load /system/object modules */
define|#
directive|define
name|DTRACE_O_LP64
value|0x04
comment|/* force D compiler to be LP64 */
define|#
directive|define
name|DTRACE_O_ILP32
value|0x08
comment|/* force D compiler to be ILP32 */
define|#
directive|define
name|DTRACE_O_MASK
value|0x0f
comment|/* mask of valid flags to dtrace_open */
specifier|extern
name|dtrace_hdl_t
modifier|*
name|dtrace_open
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|dtrace_hdl_t
modifier|*
name|dtrace_vopen
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
specifier|const
name|dtrace_vector_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_go
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_stop
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dtrace_sleep
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dtrace_close
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_errno
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
specifier|const
name|char
modifier|*
name|dtrace_errmsg
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
specifier|const
name|char
modifier|*
name|dtrace_faultstr
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
specifier|const
name|char
modifier|*
name|dtrace_subrstr
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_setopt
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_getopt
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|dtrace_optval_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dtrace_update
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_ctlfd
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * DTrace Program Interface  *  * DTrace programs can be created by compiling ASCII text files containing  * D programs or by compiling in-memory C strings that specify a D program.  * Once created, callers can examine the list of program statements and  * enable the probes and actions described by these statements.  */
typedef|typedef
struct|struct
name|dtrace_proginfo
block|{
name|dtrace_attribute_t
name|dpi_descattr
decl_stmt|;
comment|/* minimum probedesc attributes */
name|dtrace_attribute_t
name|dpi_stmtattr
decl_stmt|;
comment|/* minimum statement attributes */
name|uint_t
name|dpi_aggregates
decl_stmt|;
comment|/* number of aggregates specified in program */
name|uint_t
name|dpi_recgens
decl_stmt|;
comment|/* number of record generating probes in prog */
name|uint_t
name|dpi_matches
decl_stmt|;
comment|/* number of probes matched by program */
name|uint_t
name|dpi_speculations
decl_stmt|;
comment|/* number of speculations specified in prog */
block|}
name|dtrace_proginfo_t
typedef|;
define|#
directive|define
name|DTRACE_C_DIFV
value|0x0001
comment|/* DIF verbose mode: show each compiled DIFO */
define|#
directive|define
name|DTRACE_C_EMPTY
value|0x0002
comment|/* Permit compilation of empty D source files */
define|#
directive|define
name|DTRACE_C_ZDEFS
value|0x0004
comment|/* Permit probe defs that match zero probes */
define|#
directive|define
name|DTRACE_C_EATTR
value|0x0008
comment|/* Error if program attributes less than min */
define|#
directive|define
name|DTRACE_C_CPP
value|0x0010
comment|/* Preprocess input file with cpp(1) utility */
define|#
directive|define
name|DTRACE_C_KNODEF
value|0x0020
comment|/* Permit unresolved kernel symbols in DIFO */
define|#
directive|define
name|DTRACE_C_UNODEF
value|0x0040
comment|/* Permit unresolved user symbols in DIFO */
define|#
directive|define
name|DTRACE_C_PSPEC
value|0x0080
comment|/* Intepret ambiguous specifiers as probes */
define|#
directive|define
name|DTRACE_C_ETAGS
value|0x0100
comment|/* Prefix error messages with error tags */
define|#
directive|define
name|DTRACE_C_ARGREF
value|0x0200
comment|/* Do not require all macro args to be used */
define|#
directive|define
name|DTRACE_C_DEFARG
value|0x0800
comment|/* Use 0/"" as value for unspecified args */
define|#
directive|define
name|DTRACE_C_NOLIBS
value|0x1000
comment|/* Do not process D system libraries */
define|#
directive|define
name|DTRACE_C_CTL
value|0x2000
comment|/* Only process control directives */
define|#
directive|define
name|DTRACE_C_MASK
value|0x3bff
comment|/* mask of all valid flags to dtrace_*compile */
specifier|extern
name|dtrace_prog_t
modifier|*
name|dtrace_program_strcompile
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|dtrace_probespec_t
parameter_list|,
name|uint_t
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
specifier|const
type|[]
parameter_list|)
function_decl|;
specifier|extern
name|dtrace_prog_t
modifier|*
name|dtrace_program_fcompile
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
specifier|const
type|[]
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_program_exec
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_prog_t
modifier|*
parameter_list|,
name|dtrace_proginfo_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dtrace_program_info
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_prog_t
modifier|*
parameter_list|,
name|dtrace_proginfo_t
modifier|*
parameter_list|)
function_decl|;
define|#
directive|define
name|DTRACE_D_STRIP
value|0x01
comment|/* strip non-loadable sections from program */
define|#
directive|define
name|DTRACE_D_PROBES
value|0x02
comment|/* include provider and probe definitions */
define|#
directive|define
name|DTRACE_D_MASK
value|0x03
comment|/* mask of valid flags to dtrace_dof_create */
specifier|extern
name|int
name|dtrace_program_link
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_prog_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
specifier|const
type|[]
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_program_header
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
name|dtrace_dof_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_prog_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dtrace_dof_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
name|dtrace_getopt_dof
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
name|dtrace_geterr_dof
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|dtrace_stmtdesc
block|{
name|dtrace_ecbdesc_t
modifier|*
name|dtsd_ecbdesc
decl_stmt|;
comment|/* ECB description */
name|dtrace_actdesc_t
modifier|*
name|dtsd_action
decl_stmt|;
comment|/* action list */
name|dtrace_actdesc_t
modifier|*
name|dtsd_action_last
decl_stmt|;
comment|/* last action in action list */
name|void
modifier|*
name|dtsd_aggdata
decl_stmt|;
comment|/* aggregation data */
name|void
modifier|*
name|dtsd_fmtdata
decl_stmt|;
comment|/* type-specific output data */
name|void
modifier|*
name|dtsd_strdata
decl_stmt|;
comment|/* type-specific string data */
name|void
function_decl|(
modifier|*
name|dtsd_callback
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* callback function for EPID */
name|void
modifier|*
name|dtsd_data
decl_stmt|;
comment|/* callback data pointer */
name|dtrace_attribute_t
name|dtsd_descattr
decl_stmt|;
comment|/* probedesc attributes */
name|dtrace_attribute_t
name|dtsd_stmtattr
decl_stmt|;
comment|/* statement attributes */
block|}
name|dtrace_stmtdesc_t
typedef|;
typedef|typedef
name|int
name|dtrace_stmt_f
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_prog_t
modifier|*
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|dtrace_stmtdesc_t
modifier|*
name|dtrace_stmt_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_ecbdesc_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|dtrace_actdesc_t
modifier|*
name|dtrace_stmt_action
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_stmt_add
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_prog_t
modifier|*
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_stmt_iter
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_prog_t
modifier|*
parameter_list|,
name|dtrace_stmt_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dtrace_stmt_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * DTrace Data Consumption Interface  */
typedef|typedef
enum|enum
block|{
name|DTRACEFLOW_ENTRY
block|,
name|DTRACEFLOW_RETURN
block|,
name|DTRACEFLOW_NONE
block|}
name|dtrace_flowkind_t
typedef|;
define|#
directive|define
name|DTRACE_CONSUME_ERROR
value|-1
comment|/* error while processing */
define|#
directive|define
name|DTRACE_CONSUME_THIS
value|0
comment|/* consume this probe/record */
define|#
directive|define
name|DTRACE_CONSUME_NEXT
value|1
comment|/* advance to next probe/rec */
define|#
directive|define
name|DTRACE_CONSUME_ABORT
value|2
comment|/* abort consumption */
typedef|typedef
struct|struct
name|dtrace_probedata
block|{
name|dtrace_hdl_t
modifier|*
name|dtpda_handle
decl_stmt|;
comment|/* handle to DTrace library */
name|dtrace_eprobedesc_t
modifier|*
name|dtpda_edesc
decl_stmt|;
comment|/* enabled probe description */
name|dtrace_probedesc_t
modifier|*
name|dtpda_pdesc
decl_stmt|;
comment|/* probe description */
name|processorid_t
name|dtpda_cpu
decl_stmt|;
comment|/* CPU for data */
name|caddr_t
name|dtpda_data
decl_stmt|;
comment|/* pointer to raw data */
name|dtrace_flowkind_t
name|dtpda_flow
decl_stmt|;
comment|/* flow kind */
specifier|const
name|char
modifier|*
name|dtpda_prefix
decl_stmt|;
comment|/* recommended flow prefix */
name|int
name|dtpda_indent
decl_stmt|;
comment|/* recommended flow indent */
block|}
name|dtrace_probedata_t
typedef|;
typedef|typedef
name|int
name|dtrace_consume_probe_f
parameter_list|(
specifier|const
name|dtrace_probedata_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
name|dtrace_consume_rec_f
parameter_list|(
specifier|const
name|dtrace_probedata_t
modifier|*
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_consume
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|dtrace_consume_probe_f
modifier|*
parameter_list|,
name|dtrace_consume_rec_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
define|#
directive|define
name|DTRACE_STATUS_NONE
value|0
comment|/* no status; not yet time */
define|#
directive|define
name|DTRACE_STATUS_OKAY
value|1
comment|/* status okay */
define|#
directive|define
name|DTRACE_STATUS_EXITED
value|2
comment|/* exit() was called; tracing stopped */
define|#
directive|define
name|DTRACE_STATUS_FILLED
value|3
comment|/* fill buffer filled; tracing stoped */
define|#
directive|define
name|DTRACE_STATUS_STOPPED
value|4
comment|/* tracing already stopped */
specifier|extern
name|int
name|dtrace_status
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * DTrace Formatted Output Interfaces  *  * To format output associated with a given dtrace_stmtdesc, the caller can  * invoke one of the following functions, passing the opaque dtsd_fmtdata and a  * list of record descriptions.  These functions return either -1 to indicate  * an error, or a positive integer indicating the number of records consumed.  * For anonymous enablings, the consumer can use the dtrd_format member of  * the record description to obtain a format description.  The dtfd_string  * member of the format description may be passed to dtrace_print{fa}_create()  * to create the opaque format data.  */
specifier|extern
name|void
modifier|*
name|dtrace_printf_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
name|dtrace_printa_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|size_t
name|dtrace_printf_format
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_fprintf
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|dtrace_probedata_t
modifier|*
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_fprinta
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|dtrace_probedata_t
modifier|*
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_system
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|dtrace_probedata_t
modifier|*
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_freopen
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|dtrace_probedata_t
modifier|*
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
comment|/*  * Type-specific output printing  *  * The print() action will associate a string data record that is actually the  * fully-qualified type name of the data traced by the DIFEXPR action.  This is  * stored in the same 'format' record from the kernel, but we know by virtue of  * the fact that the action is still DIFEXPR that it is actually a reference to  * plain string data.  */
specifier|extern
name|int
name|dtrace_print
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
comment|/*  * DTrace Work Interface  */
typedef|typedef
enum|enum
block|{
name|DTRACE_WORKSTATUS_ERROR
init|=
operator|-
literal|1
block|,
name|DTRACE_WORKSTATUS_OKAY
block|,
name|DTRACE_WORKSTATUS_DONE
block|}
name|dtrace_workstatus_t
typedef|;
specifier|extern
name|dtrace_workstatus_t
name|dtrace_work
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|dtrace_consume_probe_f
modifier|*
parameter_list|,
name|dtrace_consume_rec_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/*  * DTrace Handler Interface  */
define|#
directive|define
name|DTRACE_HANDLE_ABORT
value|-1
comment|/* abort current operation */
define|#
directive|define
name|DTRACE_HANDLE_OK
value|0
comment|/* handled okay; continue */
typedef|typedef
struct|struct
name|dtrace_errdata
block|{
name|dtrace_hdl_t
modifier|*
name|dteda_handle
decl_stmt|;
comment|/* handle to DTrace library */
name|dtrace_eprobedesc_t
modifier|*
name|dteda_edesc
decl_stmt|;
comment|/* enabled probe inducing err */
name|dtrace_probedesc_t
modifier|*
name|dteda_pdesc
decl_stmt|;
comment|/* probe inducing error */
name|processorid_t
name|dteda_cpu
decl_stmt|;
comment|/* CPU of error */
name|int
name|dteda_action
decl_stmt|;
comment|/* action inducing error */
name|int
name|dteda_offset
decl_stmt|;
comment|/* offset in DIFO of error */
name|int
name|dteda_fault
decl_stmt|;
comment|/* specific fault */
name|uint64_t
name|dteda_addr
decl_stmt|;
comment|/* address of fault, if any */
specifier|const
name|char
modifier|*
name|dteda_msg
decl_stmt|;
comment|/* preconstructed message */
block|}
name|dtrace_errdata_t
typedef|;
typedef|typedef
name|int
name|dtrace_handle_err_f
parameter_list|(
specifier|const
name|dtrace_errdata_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_handle_err
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_handle_err_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
enum|enum
block|{
name|DTRACEDROP_PRINCIPAL
block|,
comment|/* drop to principal buffer */
name|DTRACEDROP_AGGREGATION
block|,
comment|/* drop to aggregation buffer */
name|DTRACEDROP_DYNAMIC
block|,
comment|/* dynamic drop */
name|DTRACEDROP_DYNRINSE
block|,
comment|/* dyn drop due to rinsing */
name|DTRACEDROP_DYNDIRTY
block|,
comment|/* dyn drop due to dirty */
name|DTRACEDROP_SPEC
block|,
comment|/* speculative drop */
name|DTRACEDROP_SPECBUSY
block|,
comment|/* spec drop due to busy */
name|DTRACEDROP_SPECUNAVAIL
block|,
comment|/* spec drop due to unavail */
name|DTRACEDROP_STKSTROVERFLOW
block|,
comment|/* stack string tab overflow */
name|DTRACEDROP_DBLERROR
comment|/* error in ERROR probe */
block|}
name|dtrace_dropkind_t
typedef|;
typedef|typedef
struct|struct
name|dtrace_dropdata
block|{
name|dtrace_hdl_t
modifier|*
name|dtdda_handle
decl_stmt|;
comment|/* handle to DTrace library */
name|processorid_t
name|dtdda_cpu
decl_stmt|;
comment|/* CPU, if any */
name|dtrace_dropkind_t
name|dtdda_kind
decl_stmt|;
comment|/* kind of drop */
name|uint64_t
name|dtdda_drops
decl_stmt|;
comment|/* number of drops */
name|uint64_t
name|dtdda_total
decl_stmt|;
comment|/* total drops */
specifier|const
name|char
modifier|*
name|dtdda_msg
decl_stmt|;
comment|/* preconstructed message */
block|}
name|dtrace_dropdata_t
typedef|;
typedef|typedef
name|int
name|dtrace_handle_drop_f
parameter_list|(
specifier|const
name|dtrace_dropdata_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_handle_drop
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_handle_drop_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|void
name|dtrace_handle_proc_f
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_handle_proc
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_handle_proc_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
define|#
directive|define
name|DTRACE_BUFDATA_AGGKEY
value|0x0001
comment|/* aggregation key */
define|#
directive|define
name|DTRACE_BUFDATA_AGGVAL
value|0x0002
comment|/* aggregation value */
define|#
directive|define
name|DTRACE_BUFDATA_AGGFORMAT
value|0x0004
comment|/* aggregation format data */
define|#
directive|define
name|DTRACE_BUFDATA_AGGLAST
value|0x0008
comment|/* last for this key/val */
typedef|typedef
struct|struct
name|dtrace_bufdata
block|{
name|dtrace_hdl_t
modifier|*
name|dtbda_handle
decl_stmt|;
comment|/* handle to DTrace library */
specifier|const
name|char
modifier|*
name|dtbda_buffered
decl_stmt|;
comment|/* buffered output */
name|dtrace_probedata_t
modifier|*
name|dtbda_probe
decl_stmt|;
comment|/* probe data */
specifier|const
name|dtrace_recdesc_t
modifier|*
name|dtbda_recdesc
decl_stmt|;
comment|/* record description */
specifier|const
name|dtrace_aggdata_t
modifier|*
name|dtbda_aggdata
decl_stmt|;
comment|/* aggregation data, if agg. */
name|uint32_t
name|dtbda_flags
decl_stmt|;
comment|/* flags; see above */
block|}
name|dtrace_bufdata_t
typedef|;
typedef|typedef
name|int
name|dtrace_handle_buffered_f
parameter_list|(
specifier|const
name|dtrace_bufdata_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_handle_buffered
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_handle_buffered_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|dtrace_setoptdata
block|{
name|dtrace_hdl_t
modifier|*
name|dtsda_handle
decl_stmt|;
comment|/* handle to DTrace library */
specifier|const
name|dtrace_probedata_t
modifier|*
name|dtsda_probe
decl_stmt|;
comment|/* probe data */
specifier|const
name|char
modifier|*
name|dtsda_option
decl_stmt|;
comment|/* option that was set */
name|dtrace_optval_t
name|dtsda_oldval
decl_stmt|;
comment|/* old value */
name|dtrace_optval_t
name|dtsda_newval
decl_stmt|;
comment|/* new value */
block|}
name|dtrace_setoptdata_t
typedef|;
typedef|typedef
name|int
name|dtrace_handle_setopt_f
parameter_list|(
specifier|const
name|dtrace_setoptdata_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_handle_setopt
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_handle_setopt_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/*  * DTrace Aggregate Interface  */
define|#
directive|define
name|DTRACE_A_PERCPU
value|0x0001
define|#
directive|define
name|DTRACE_A_KEEPDELTA
value|0x0002
define|#
directive|define
name|DTRACE_A_ANONYMOUS
value|0x0004
define|#
directive|define
name|DTRACE_A_TOTAL
value|0x0008
define|#
directive|define
name|DTRACE_A_MINMAXBIN
value|0x0010
define|#
directive|define
name|DTRACE_A_HASNEGATIVES
value|0x0020
define|#
directive|define
name|DTRACE_A_HASPOSITIVES
value|0x0040
define|#
directive|define
name|DTRACE_AGGZOOM_MAX
value|0.95
comment|/* height of max bar */
define|#
directive|define
name|DTRACE_AGGWALK_ERROR
value|-1
comment|/* error while processing */
define|#
directive|define
name|DTRACE_AGGWALK_NEXT
value|0
comment|/* proceed to next element */
define|#
directive|define
name|DTRACE_AGGWALK_ABORT
value|1
comment|/* abort aggregation walk */
define|#
directive|define
name|DTRACE_AGGWALK_CLEAR
value|2
comment|/* clear this element */
define|#
directive|define
name|DTRACE_AGGWALK_NORMALIZE
value|3
comment|/* normalize this element */
define|#
directive|define
name|DTRACE_AGGWALK_DENORMALIZE
value|4
comment|/* denormalize this element */
define|#
directive|define
name|DTRACE_AGGWALK_REMOVE
value|5
comment|/* remove this element */
struct|struct
name|dtrace_aggdata
block|{
name|dtrace_hdl_t
modifier|*
name|dtada_handle
decl_stmt|;
comment|/* handle to DTrace library */
name|dtrace_aggdesc_t
modifier|*
name|dtada_desc
decl_stmt|;
comment|/* aggregation description */
name|dtrace_eprobedesc_t
modifier|*
name|dtada_edesc
decl_stmt|;
comment|/* enabled probe description */
name|dtrace_probedesc_t
modifier|*
name|dtada_pdesc
decl_stmt|;
comment|/* probe description */
name|caddr_t
name|dtada_data
decl_stmt|;
comment|/* pointer to raw data */
name|uint64_t
name|dtada_normal
decl_stmt|;
comment|/* the normal -- 1 for denorm */
name|size_t
name|dtada_size
decl_stmt|;
comment|/* total size of the data */
name|caddr_t
name|dtada_delta
decl_stmt|;
comment|/* delta data, if available */
name|caddr_t
modifier|*
name|dtada_percpu
decl_stmt|;
comment|/* per CPU data, if avail */
name|caddr_t
modifier|*
name|dtada_percpu_delta
decl_stmt|;
comment|/* per CPU delta, if avail */
name|int64_t
name|dtada_total
decl_stmt|;
comment|/* per agg total, if avail */
name|uint16_t
name|dtada_minbin
decl_stmt|;
comment|/* minimum bin, if avail */
name|uint16_t
name|dtada_maxbin
decl_stmt|;
comment|/* maximum bin, if avail */
name|uint32_t
name|dtada_flags
decl_stmt|;
comment|/* flags */
block|}
struct|;
typedef|typedef
name|int
name|dtrace_aggregate_f
parameter_list|(
specifier|const
name|dtrace_aggdata_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
name|dtrace_aggregate_walk_f
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_aggregate_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
name|int
name|dtrace_aggregate_walk_joined_f
parameter_list|(
specifier|const
name|dtrace_aggdata_t
modifier|*
modifier|*
parameter_list|,
specifier|const
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dtrace_aggregate_clear
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_aggregate_snap
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_aggregate_print
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|dtrace_aggregate_walk_f
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_aggregate_walk
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_aggregate_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_aggregate_walk_joined
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_aggvarid_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|dtrace_aggregate_walk_joined_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_aggregate_walk_sorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_aggregate_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_aggregate_walk_keysorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_aggregate_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_aggregate_walk_valsorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_aggregate_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_aggregate_walk_keyvarsorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_aggregate_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_aggregate_walk_valvarsorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_aggregate_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_aggregate_walk_keyrevsorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_aggregate_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_aggregate_walk_valrevsorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_aggregate_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_aggregate_walk_keyvarrevsorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_aggregate_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_aggregate_walk_valvarrevsorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_aggregate_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
define|#
directive|define
name|DTRACE_AGD_PRINTED
value|0x1
comment|/* aggregation printed in program */
comment|/*  * DTrace Process Control Interface  *  * Library clients who wish to have libdtrace create or grab processes for  * monitoring of their symbol table changes may use these interfaces to  * request that libdtrace obtain control of the process using libproc.  */
specifier|extern
name|struct
name|ps_prochandle
modifier|*
name|dtrace_proc_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
name|proc_child_func
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|struct
name|ps_prochandle
modifier|*
name|dtrace_proc_grab
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|pid_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dtrace_proc_release
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|struct
name|ps_prochandle
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dtrace_proc_continue
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|struct
name|ps_prochandle
modifier|*
parameter_list|)
function_decl|;
comment|/*  * DTrace Object, Symbol, and Type Interfaces  *  * Library clients can use libdtrace to perform symbol and C type information  * lookups by symbol name, symbol address, or C type name, or to lookup meta-  * information cached for each of the program objects in use by DTrace.  The  * resulting struct contain pointers to arbitrary-length strings, including  * object, symbol, and type names, that are persistent until the next call to  * dtrace_update().  Once dtrace_update() is called, any cached values must  * be flushed and not used subsequently by the client program.  */
define|#
directive|define
name|DTRACE_OBJ_EXEC
value|((const char *)0L)
comment|/* primary executable file */
define|#
directive|define
name|DTRACE_OBJ_RTLD
value|((const char *)1L)
comment|/* run-time link-editor */
define|#
directive|define
name|DTRACE_OBJ_CDEFS
value|((const char *)2L)
comment|/* C include definitions */
define|#
directive|define
name|DTRACE_OBJ_DDEFS
value|((const char *)3L)
comment|/* D program definitions */
define|#
directive|define
name|DTRACE_OBJ_EVERY
value|((const char *)-1L)
comment|/* all known objects */
define|#
directive|define
name|DTRACE_OBJ_KMODS
value|((const char *)-2L)
comment|/* all kernel objects */
define|#
directive|define
name|DTRACE_OBJ_UMODS
value|((const char *)-3L)
comment|/* all user objects */
typedef|typedef
struct|struct
name|dtrace_objinfo
block|{
specifier|const
name|char
modifier|*
name|dto_name
decl_stmt|;
comment|/* object file scope name */
specifier|const
name|char
modifier|*
name|dto_file
decl_stmt|;
comment|/* object file path (if any) */
name|int
name|dto_id
decl_stmt|;
comment|/* object file id (if any) */
name|uint_t
name|dto_flags
decl_stmt|;
comment|/* object flags (see below) */
name|GElf_Addr
name|dto_text_va
decl_stmt|;
comment|/* address of text section */
name|GElf_Xword
name|dto_text_size
decl_stmt|;
comment|/* size of text section */
name|GElf_Addr
name|dto_data_va
decl_stmt|;
comment|/* address of data section */
name|GElf_Xword
name|dto_data_size
decl_stmt|;
comment|/* size of data section */
name|GElf_Addr
name|dto_bss_va
decl_stmt|;
comment|/* address of BSS */
name|GElf_Xword
name|dto_bss_size
decl_stmt|;
comment|/* size of BSS */
block|}
name|dtrace_objinfo_t
typedef|;
define|#
directive|define
name|DTRACE_OBJ_F_KERNEL
value|0x1
comment|/* object is a kernel module */
define|#
directive|define
name|DTRACE_OBJ_F_PRIMARY
value|0x2
comment|/* object is a primary module */
typedef|typedef
name|int
name|dtrace_obj_f
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|dtrace_objinfo_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_object_iter
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_obj_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_object_info
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|dtrace_objinfo_t
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|dtrace_syminfo
block|{
specifier|const
name|char
modifier|*
name|dts_object
decl_stmt|;
comment|/* object name */
specifier|const
name|char
modifier|*
name|dts_name
decl_stmt|;
comment|/* symbol name */
name|ulong_t
name|dts_id
decl_stmt|;
comment|/* symbol id */
block|}
name|dtrace_syminfo_t
typedef|;
specifier|extern
name|int
name|dtrace_lookup_by_name
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|GElf_Sym
modifier|*
parameter_list|,
name|dtrace_syminfo_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_lookup_by_addr
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|GElf_Addr
name|addr
parameter_list|,
name|GElf_Sym
modifier|*
parameter_list|,
name|dtrace_syminfo_t
modifier|*
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|dtrace_typeinfo
block|{
specifier|const
name|char
modifier|*
name|dtt_object
decl_stmt|;
comment|/* object containing type */
name|ctf_file_t
modifier|*
name|dtt_ctfp
decl_stmt|;
comment|/* CTF container handle */
name|ctf_id_t
name|dtt_type
decl_stmt|;
comment|/* CTF type identifier */
name|uint_t
name|dtt_flags
decl_stmt|;
comment|/* Misc. flags */
block|}
name|dtrace_typeinfo_t
typedef|;
define|#
directive|define
name|DTT_FL_USER
value|0x1
comment|/* user type */
specifier|extern
name|int
name|dtrace_lookup_by_type
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|dtrace_typeinfo_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_symbol_type
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
parameter_list|,
specifier|const
name|dtrace_syminfo_t
modifier|*
parameter_list|,
name|dtrace_typeinfo_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_type_strcompile
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|dtrace_typeinfo_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_type_fcompile
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|dtrace_typeinfo_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * DTrace Probe Interface  *  * Library clients can use these functions to iterate over the set of available  * probe definitions and inquire as to their attributes.  The probe iteration  * interfaces report probes that are declared as well as those from dtrace(7D).  */
typedef|typedef
struct|struct
name|dtrace_probeinfo
block|{
name|dtrace_attribute_t
name|dtp_attr
decl_stmt|;
comment|/* name attributes */
name|dtrace_attribute_t
name|dtp_arga
decl_stmt|;
comment|/* arg attributes */
specifier|const
name|dtrace_typeinfo_t
modifier|*
name|dtp_argv
decl_stmt|;
comment|/* arg types */
name|int
name|dtp_argc
decl_stmt|;
comment|/* arg count */
block|}
name|dtrace_probeinfo_t
typedef|;
typedef|typedef
name|int
name|dtrace_probe_f
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|dtrace_probedesc_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_probe_iter
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|dtrace_probe_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_probe_info
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|dtrace_probedesc_t
modifier|*
parameter_list|,
name|dtrace_probeinfo_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * DTrace Vector Interface  *  * The DTrace library normally speaks directly to dtrace(7D).  However,  * this communication may be vectored elsewhere.  Consumers who wish to  * perform a vectored open must fill in the vector, and use the dtrace_vopen()  * entry point to obtain a library handle.  */
struct|struct
name|dtrace_vector
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|int
function_decl|(
modifier|*
name|dtv_ioctl
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
else|#
directive|else
name|int
function_decl|(
modifier|*
name|dtv_ioctl
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
name|int
function_decl|(
modifier|*
name|dtv_lookup_by_addr
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|GElf_Addr
parameter_list|,
name|GElf_Sym
modifier|*
parameter_list|,
name|dtrace_syminfo_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|dtv_status
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|processorid_t
parameter_list|)
function_decl|;
name|long
function_decl|(
modifier|*
name|dtv_sysconf
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
struct|;
comment|/*  * DTrace Utility Functions  *  * Library clients can use these functions to convert addresses strings, to  * convert between string and integer probe descriptions and the  * dtrace_probedesc_t representation, and to perform similar conversions on  * stability attributes.  */
specifier|extern
name|int
name|dtrace_addr2str
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_uaddr2str
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|pid_t
parameter_list|,
name|uint64_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_xstr2desc
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_probespec_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
specifier|const
type|[]
parameter_list|,
name|dtrace_probedesc_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_str2desc
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_probespec_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|dtrace_probedesc_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_id2desc
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|dtrace_probedesc_t
modifier|*
parameter_list|)
function_decl|;
define|#
directive|define
name|DTRACE_DESC2STR_MAX
value|1024
comment|/* min buf size for dtrace_desc2str() */
specifier|extern
name|char
modifier|*
name|dtrace_desc2str
parameter_list|(
specifier|const
name|dtrace_probedesc_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
define|#
directive|define
name|DTRACE_ATTR2STR_MAX
value|64
comment|/* min buf size for dtrace_attr2str() */
specifier|extern
name|char
modifier|*
name|dtrace_attr2str
parameter_list|(
name|dtrace_attribute_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_str2attr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|dtrace_attribute_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
specifier|const
name|char
modifier|*
name|dtrace_stability_name
parameter_list|(
name|dtrace_stability_t
parameter_list|)
function_decl|;
specifier|extern
specifier|const
name|char
modifier|*
name|dtrace_class_name
parameter_list|(
name|dtrace_class_t
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dtrace_provider_modules
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
specifier|const
name|char
modifier|*
specifier|const
name|_dtrace_version
decl_stmt|;
specifier|extern
name|int
name|_dtrace_debug
decl_stmt|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_define
define|#
directive|define
name|_SC_CPUID_MAX
value|_SC_NPROCESSORS_CONF
end_define

begin_define
define|#
directive|define
name|_SC_NPROCESSORS_MAX
value|_SC_NPROCESSORS_CONF
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _DTRACE_H */
end_comment

end_unit

