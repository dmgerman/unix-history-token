begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Copyright (c) 2011, Joyent Inc. All rights reserved.  * Copyright (c) 2012 by Delphix. All rights reserved.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * DTrace D Language Parser  *  * The D Parser is a lex/yacc parser consisting of the lexer dt_lex.l, the  * parsing grammar dt_grammar.y, and this file, dt_parser.c, which handles  * the construction of the parse tree nodes and their syntactic validation.  * The parse tree is constructed of dt_node_t structures (see<dt_parser.h>)  * that are built in two passes: (1) the "create" pass, where the parse tree  * nodes are allocated by calls from the grammar to dt_node_*() subroutines,  * and (2) the "cook" pass, where nodes are coalesced, assigned D types, and  * validated according to the syntactic rules of the language.  *  * All node allocations are performed using dt_node_alloc().  All node frees  * during the parsing phase are performed by dt_node_free(), which frees node-  * internal state but does not actually free the nodes.  All final node frees  * are done as part of the end of dt_compile() or as part of destroying  * persistent identifiers or translators which have embedded nodes.  *  * The dt_node_* routines that implement pass (1) may allocate new nodes.  The  * dt_cook_* routines that implement pass (2) may *not* allocate new nodes.  * They may free existing nodes using dt_node_free(), but they may not actually  * deallocate any dt_node_t's.  Currently dt_cook_op2() is an exception to this  * rule: see the comments therein for how this issue is resolved.  *  * The dt_cook_* routines are responsible for (at minimum) setting the final  * node type (dn_ctfp/dn_type) and attributes (dn_attr).  If dn_ctfp/dn_type  * are set manually (i.e. not by one of the type assignment functions), then  * the DT_NF_COOKED flag must be set manually on the node.  *  * The cooking pass can be applied to the same parse tree more than once (used  * in the case of a comma-separated list of probe descriptions).  As such, the  * cook routines must not perform any parse tree transformations which would  * be invalid if the tree were subsequently cooked using a different context.  *  * The dn_ctfp and dn_type fields form the type of the node.  This tuple can  * take on the following set of values, which form our type invariants:  *  * 1. dn_ctfp = NULL, dn_type = CTF_ERR  *  *    In this state, the node has unknown type and is not yet cooked.  The  *    DT_NF_COOKED flag is not yet set on the node.  *  * 2. dn_ctfp = DT_DYN_CTFP(dtp), dn_type = DT_DYN_TYPE(dtp)  *  *    In this state, the node is a dynamic D type.  This means that generic  *    operations are not valid on this node and only code that knows how to  *    examine the inner details of the node can operate on it.  A<DYN> node  *    must have dn_ident set to point to an identifier describing the object  *    and its type.  The DT_NF_REF flag is set for all nodes of type<DYN>.  *    At present, the D compiler uses the<DYN> type for:  *  *    - associative arrays that do not yet have a value type defined  *    - translated data (i.e. the result of the xlate operator)  *    - aggregations  *  * 3. dn_ctfp = DT_STR_CTFP(dtp), dn_type = DT_STR_TYPE(dtp)  *  *    In this state, the node is of type D string.  The string type is really  *    a char[0] typedef, but requires special handling throughout the compiler.  *  * 4. dn_ctfp != NULL, dn_type = any other type ID  *  *    In this state, the node is of some known D/CTF type.  The normal libctf  *    APIs can be used to learn more about the type name or structure.  When  *    the type is assigned, the DT_NF_SIGNED, DT_NF_REF, and DT_NF_BITFIELD  *    flags cache the corresponding attributes of the underlying CTF type.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_include
include|#
directive|include
file|<dt_grammar.h>
end_include

begin_include
include|#
directive|include
file|<dt_module.h>
end_include

begin_include
include|#
directive|include
file|<dt_provider.h>
end_include

begin_include
include|#
directive|include
file|<dt_string.h>
end_include

begin_include
include|#
directive|include
file|<dt_as.h>
end_include

begin_decl_stmt
name|dt_pcb_t
modifier|*
name|yypcb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current control block for parser */
end_comment

begin_decl_stmt
name|dt_node_t
modifier|*
name|yypragma
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lex token list for control lines */
end_comment

begin_decl_stmt
name|char
name|yyintprefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* int token macro prefix (+/-) */
end_comment

begin_decl_stmt
name|char
name|yyintsuffix
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* int token suffix string [uU][lL] */
end_comment

begin_decl_stmt
name|int
name|yyintdecimal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* int token format flag (1=decimal, 0=octal/hex) */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|opstr
parameter_list|(
name|int
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DT_TOK_COMMA
case|:
return|return
operator|(
literal|","
operator|)
return|;
case|case
name|DT_TOK_ELLIPSIS
case|:
return|return
operator|(
literal|"..."
operator|)
return|;
case|case
name|DT_TOK_ASGN
case|:
return|return
operator|(
literal|"="
operator|)
return|;
case|case
name|DT_TOK_ADD_EQ
case|:
return|return
operator|(
literal|"+="
operator|)
return|;
case|case
name|DT_TOK_SUB_EQ
case|:
return|return
operator|(
literal|"-="
operator|)
return|;
case|case
name|DT_TOK_MUL_EQ
case|:
return|return
operator|(
literal|"*="
operator|)
return|;
case|case
name|DT_TOK_DIV_EQ
case|:
return|return
operator|(
literal|"/="
operator|)
return|;
case|case
name|DT_TOK_MOD_EQ
case|:
return|return
operator|(
literal|"%="
operator|)
return|;
case|case
name|DT_TOK_AND_EQ
case|:
return|return
operator|(
literal|"&="
operator|)
return|;
case|case
name|DT_TOK_XOR_EQ
case|:
return|return
operator|(
literal|"^="
operator|)
return|;
case|case
name|DT_TOK_OR_EQ
case|:
return|return
operator|(
literal|"|="
operator|)
return|;
case|case
name|DT_TOK_LSH_EQ
case|:
return|return
operator|(
literal|"<<="
operator|)
return|;
case|case
name|DT_TOK_RSH_EQ
case|:
return|return
operator|(
literal|">>="
operator|)
return|;
case|case
name|DT_TOK_QUESTION
case|:
return|return
operator|(
literal|"?"
operator|)
return|;
case|case
name|DT_TOK_COLON
case|:
return|return
operator|(
literal|":"
operator|)
return|;
case|case
name|DT_TOK_LOR
case|:
return|return
operator|(
literal|"||"
operator|)
return|;
case|case
name|DT_TOK_LXOR
case|:
return|return
operator|(
literal|"^^"
operator|)
return|;
case|case
name|DT_TOK_LAND
case|:
return|return
operator|(
literal|"&&"
operator|)
return|;
case|case
name|DT_TOK_BOR
case|:
return|return
operator|(
literal|"|"
operator|)
return|;
case|case
name|DT_TOK_XOR
case|:
return|return
operator|(
literal|"^"
operator|)
return|;
case|case
name|DT_TOK_BAND
case|:
return|return
operator|(
literal|"&"
operator|)
return|;
case|case
name|DT_TOK_EQU
case|:
return|return
operator|(
literal|"=="
operator|)
return|;
case|case
name|DT_TOK_NEQ
case|:
return|return
operator|(
literal|"!="
operator|)
return|;
case|case
name|DT_TOK_LT
case|:
return|return
operator|(
literal|"<"
operator|)
return|;
case|case
name|DT_TOK_LE
case|:
return|return
operator|(
literal|"<="
operator|)
return|;
case|case
name|DT_TOK_GT
case|:
return|return
operator|(
literal|">"
operator|)
return|;
case|case
name|DT_TOK_GE
case|:
return|return
operator|(
literal|">="
operator|)
return|;
case|case
name|DT_TOK_LSH
case|:
return|return
operator|(
literal|"<<"
operator|)
return|;
case|case
name|DT_TOK_RSH
case|:
return|return
operator|(
literal|">>"
operator|)
return|;
case|case
name|DT_TOK_ADD
case|:
return|return
operator|(
literal|"+"
operator|)
return|;
case|case
name|DT_TOK_SUB
case|:
return|return
operator|(
literal|"-"
operator|)
return|;
case|case
name|DT_TOK_MUL
case|:
return|return
operator|(
literal|"*"
operator|)
return|;
case|case
name|DT_TOK_DIV
case|:
return|return
operator|(
literal|"/"
operator|)
return|;
case|case
name|DT_TOK_MOD
case|:
return|return
operator|(
literal|"%"
operator|)
return|;
case|case
name|DT_TOK_LNEG
case|:
return|return
operator|(
literal|"!"
operator|)
return|;
case|case
name|DT_TOK_BNEG
case|:
return|return
operator|(
literal|"~"
operator|)
return|;
case|case
name|DT_TOK_ADDADD
case|:
return|return
operator|(
literal|"++"
operator|)
return|;
case|case
name|DT_TOK_PREINC
case|:
return|return
operator|(
literal|"++"
operator|)
return|;
case|case
name|DT_TOK_POSTINC
case|:
return|return
operator|(
literal|"++"
operator|)
return|;
case|case
name|DT_TOK_SUBSUB
case|:
return|return
operator|(
literal|"--"
operator|)
return|;
case|case
name|DT_TOK_PREDEC
case|:
return|return
operator|(
literal|"--"
operator|)
return|;
case|case
name|DT_TOK_POSTDEC
case|:
return|return
operator|(
literal|"--"
operator|)
return|;
case|case
name|DT_TOK_IPOS
case|:
return|return
operator|(
literal|"+"
operator|)
return|;
case|case
name|DT_TOK_INEG
case|:
return|return
operator|(
literal|"-"
operator|)
return|;
case|case
name|DT_TOK_DEREF
case|:
return|return
operator|(
literal|"*"
operator|)
return|;
case|case
name|DT_TOK_ADDROF
case|:
return|return
operator|(
literal|"&"
operator|)
return|;
case|case
name|DT_TOK_OFFSETOF
case|:
return|return
operator|(
literal|"offsetof"
operator|)
return|;
case|case
name|DT_TOK_SIZEOF
case|:
return|return
operator|(
literal|"sizeof"
operator|)
return|;
case|case
name|DT_TOK_STRINGOF
case|:
return|return
operator|(
literal|"stringof"
operator|)
return|;
case|case
name|DT_TOK_XLATE
case|:
return|return
operator|(
literal|"xlate"
operator|)
return|;
case|case
name|DT_TOK_LPAR
case|:
return|return
operator|(
literal|"("
operator|)
return|;
case|case
name|DT_TOK_RPAR
case|:
return|return
operator|(
literal|")"
operator|)
return|;
case|case
name|DT_TOK_LBRAC
case|:
return|return
operator|(
literal|"["
operator|)
return|;
case|case
name|DT_TOK_RBRAC
case|:
return|return
operator|(
literal|"]"
operator|)
return|;
case|case
name|DT_TOK_PTR
case|:
return|return
operator|(
literal|"->"
operator|)
return|;
case|case
name|DT_TOK_DOT
case|:
return|return
operator|(
literal|"."
operator|)
return|;
case|case
name|DT_TOK_STRING
case|:
return|return
operator|(
literal|"<string>"
operator|)
return|;
case|case
name|DT_TOK_IDENT
case|:
return|return
operator|(
literal|"<ident>"
operator|)
return|;
case|case
name|DT_TOK_TNAME
case|:
return|return
operator|(
literal|"<type>"
operator|)
return|;
case|case
name|DT_TOK_INT
case|:
return|return
operator|(
literal|"<int>"
operator|)
return|;
default|default:
return|return
operator|(
literal|"<?>"
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|dt_type_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|dtrace_typeinfo_t
modifier|*
name|tip
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|delimiters
index|[]
init|=
literal|" \t\n\r\v\f*`"
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|obj
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
operator|,
name|end
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|=
name|q
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* skip leading whitespace prior to token */
if|if
condition|(
name|p
operator|==
name|end
operator|||
operator|(
name|q
operator|=
name|strpbrk
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|delimiters
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
comment|/* empty string or single token remaining */
if|if
condition|(
operator|*
name|q
operator|==
literal|'`'
condition|)
block|{
name|char
modifier|*
name|object
init|=
name|alloca
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|q
operator|-
name|p
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|type
init|=
name|alloca
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|end
operator|-
name|s
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* 			 * Copy from the start of the token (p) to the location 			 * backquote (q) to extract the nul-terminated object. 			 */
name|bcopy
argument_list|(
name|p
argument_list|,
name|object
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|q
operator|-
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|object
index|[
call|(
name|size_t
call|)
argument_list|(
name|q
operator|-
name|p
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * Copy the original string up to the start of this 			 * token (p) into type, and then concatenate everything 			 * after q.  This is the type name without the object. 			 */
name|bcopy
argument_list|(
name|s
argument_list|,
name|type
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|q
operator|+
literal|1
argument_list|,
name|type
operator|+
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|s
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|q
operator|+
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|q
operator|+
literal|1
argument_list|,
literal|'`'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADSCOPE
argument_list|)
operator|)
return|;
return|return
operator|(
name|dtrace_lookup_by_type
argument_list|(
name|dtp
argument_list|,
name|object
argument_list|,
name|type
argument_list|,
name|tip
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|yypcb
operator|->
name|pcb_idepth
operator|!=
literal|0
condition|)
name|obj
operator|=
name|DTRACE_OBJ_CDEFS
expr_stmt|;
else|else
name|obj
operator|=
name|DTRACE_OBJ_EVERY
expr_stmt|;
return|return
operator|(
name|dtrace_lookup_by_type
argument_list|(
name|dtp
argument_list|,
name|obj
argument_list|,
name|s
argument_list|,
name|tip
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When we parse type expressions or parse an expression with unary "&", we  * need to find a type that is a pointer to a previously known type.  * Unfortunately CTF is limited to a per-container view, so ctf_type_pointer()  * alone does not suffice for our needs.  We provide a more intelligent wrapper  * for the compiler that attempts to compute a pointer to either the given type  * or its base (that is, we try both "foo_t *" and "struct foo *"), and also  * to potentially construct the required type on-the-fly.  */
end_comment

begin_function
name|int
name|dt_type_pointer
parameter_list|(
name|dtrace_typeinfo_t
modifier|*
name|tip
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|tip
operator|->
name|dtt_ctfp
decl_stmt|;
name|ctf_id_t
name|type
init|=
name|tip
operator|->
name|dtt_type
decl_stmt|;
name|ctf_id_t
name|base
init|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
name|ctf_id_t
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|ctf_type_pointer
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
name|CTF_ERR
operator|||
operator|(
name|ptr
operator|=
name|ctf_type_pointer
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|)
operator|)
operator|!=
name|CTF_ERR
condition|)
block|{
name|tip
operator|->
name|dtt_type
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|yypcb
operator|->
name|pcb_idepth
operator|!=
literal|0
condition|)
name|dmp
operator|=
name|dtp
operator|->
name|dt_cdefs
expr_stmt|;
else|else
name|dmp
operator|=
name|dtp
operator|->
name|dt_ddefs
expr_stmt|;
if|if
condition|(
name|ctfp
operator|!=
name|dmp
operator|->
name|dm_ctfp
operator|&&
name|ctfp
operator|!=
name|ctf_parent_file
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
operator|&&
operator|(
name|type
operator|=
name|ctf_add_type
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|ctfp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
block|{
name|dtp
operator|->
name|dt_ctferr
operator|=
name|ctf_errno
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_CTF
argument_list|)
operator|)
return|;
block|}
name|ptr
operator|=
name|ctf_add_pointer
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|CTF_ERR
operator|||
name|ctf_update
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|dtp
operator|->
name|dt_ctferr
operator|=
name|ctf_errno
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_CTF
argument_list|)
operator|)
return|;
block|}
name|tip
operator|->
name|dtt_object
operator|=
name|dmp
operator|->
name|dm_name
expr_stmt|;
name|tip
operator|->
name|dtt_ctfp
operator|=
name|dmp
operator|->
name|dm_ctfp
expr_stmt|;
name|tip
operator|->
name|dtt_type
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|dt_type_name
parameter_list|(
name|ctf_file_t
modifier|*
name|ctfp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
if|if
condition|(
name|ctfp
operator|==
name|DT_FPTR_CTFP
argument_list|(
name|dtp
argument_list|)
operator|&&
name|type
operator|==
name|DT_FPTR_TYPE
argument_list|(
name|dtp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"function pointer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctfp
operator|==
name|DT_FUNC_CTFP
argument_list|(
name|dtp
argument_list|)
operator|&&
name|type
operator|==
name|DT_FUNC_TYPE
argument_list|(
name|dtp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctfp
operator|==
name|DT_DYN_CTFP
argument_list|(
name|dtp
argument_list|)
operator|&&
name|type
operator|==
name|DT_DYN_TYPE
argument_list|(
name|dtp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"dynamic variable"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctfp
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"<none>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctf_type_name
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform the "usual arithmetic conversions" to determine which of the two  * input operand types should be promoted and used as a result type.  The  * rules for this are described in ISOC[6.3.1.8] and K&R[A6.5].  */
end_comment

begin_function
specifier|static
name|void
name|dt_type_promote
parameter_list|(
name|dt_node_t
modifier|*
name|lp
parameter_list|,
name|dt_node_t
modifier|*
name|rp
parameter_list|,
name|ctf_file_t
modifier|*
modifier|*
name|ofp
parameter_list|,
name|ctf_id_t
modifier|*
name|otype
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|lfp
init|=
name|lp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_id_t
name|ltype
init|=
name|lp
operator|->
name|dn_type
decl_stmt|;
name|ctf_file_t
modifier|*
name|rfp
init|=
name|rp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_id_t
name|rtype
init|=
name|rp
operator|->
name|dn_type
decl_stmt|;
name|ctf_id_t
name|lbase
init|=
name|ctf_type_resolve
argument_list|(
name|lfp
argument_list|,
name|ltype
argument_list|)
decl_stmt|;
name|uint_t
name|lkind
init|=
name|ctf_type_kind
argument_list|(
name|lfp
argument_list|,
name|lbase
argument_list|)
decl_stmt|;
name|ctf_id_t
name|rbase
init|=
name|ctf_type_resolve
argument_list|(
name|rfp
argument_list|,
name|rtype
argument_list|)
decl_stmt|;
name|uint_t
name|rkind
init|=
name|ctf_type_kind
argument_list|(
name|rfp
argument_list|,
name|rbase
argument_list|)
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|ctf_encoding_t
name|le
decl_stmt|,
name|re
decl_stmt|;
name|uint_t
name|lrank
decl_stmt|,
name|rrank
decl_stmt|;
name|assert
argument_list|(
name|lkind
operator|==
name|CTF_K_INTEGER
operator|||
name|lkind
operator|==
name|CTF_K_ENUM
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rkind
operator|==
name|CTF_K_INTEGER
operator|||
name|rkind
operator|==
name|CTF_K_ENUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|lkind
operator|==
name|CTF_K_ENUM
condition|)
block|{
name|lfp
operator|=
name|DT_INT_CTFP
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|ltype
operator|=
name|lbase
operator|=
name|DT_INT_TYPE
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rkind
operator|==
name|CTF_K_ENUM
condition|)
block|{
name|rfp
operator|=
name|DT_INT_CTFP
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|rtype
operator|=
name|rbase
operator|=
name|DT_INT_TYPE
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctf_type_encoding
argument_list|(
name|lfp
argument_list|,
name|lbase
argument_list|,
operator|&
name|le
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_ctferr
operator|=
name|ctf_errno
argument_list|(
name|lfp
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_CTF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctf_type_encoding
argument_list|(
name|rfp
argument_list|,
name|rbase
argument_list|,
operator|&
name|re
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_ctferr
operator|=
name|ctf_errno
argument_list|(
name|rfp
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_CTF
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Compute an integer rank based on the size and unsigned status. 	 * If rank is identical, pick the "larger" of the equivalent types 	 * which we define as having a larger base ctf_id_t.  If rank is 	 * different, pick the type with the greater rank. 	 */
name|lrank
operator|=
name|le
operator|.
name|cte_bits
operator|+
operator|(
operator|(
name|le
operator|.
name|cte_format
operator|&
name|CTF_INT_SIGNED
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
name|rrank
operator|=
name|re
operator|.
name|cte_bits
operator|+
operator|(
operator|(
name|re
operator|.
name|cte_format
operator|&
name|CTF_INT_SIGNED
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|lrank
operator|==
name|rrank
condition|)
block|{
if|if
condition|(
name|lbase
operator|-
name|rbase
operator|<
literal|0
condition|)
goto|goto
name|return_rtype
goto|;
else|else
goto|goto
name|return_ltype
goto|;
block|}
elseif|else
if|if
condition|(
name|lrank
operator|>
name|rrank
condition|)
block|{
goto|goto
name|return_ltype
goto|;
block|}
else|else
goto|goto
name|return_rtype
goto|;
name|return_ltype
label|:
operator|*
name|ofp
operator|=
name|lfp
expr_stmt|;
operator|*
name|otype
operator|=
name|ltype
expr_stmt|;
return|return;
name|return_rtype
label|:
operator|*
name|ofp
operator|=
name|rfp
expr_stmt|;
operator|*
name|otype
operator|=
name|rtype
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_node_promote
parameter_list|(
name|dt_node_t
modifier|*
name|lp
parameter_list|,
name|dt_node_t
modifier|*
name|rp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dt_type_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
operator|&
name|dnp
operator|->
name|dn_ctfp
argument_list|,
operator|&
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_attr_min
argument_list|(
name|lp
operator|->
name|dn_attr
argument_list|,
name|rp
operator|->
name|dn_attr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|dt_node_name
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|n1
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|char
name|n2
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
init|=
literal|""
decl_stmt|,
modifier|*
name|suffix
init|=
literal|""
decl_stmt|;
specifier|const
name|dtrace_syminfo_t
modifier|*
name|dts
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|dnp
operator|->
name|dn_kind
condition|)
block|{
case|case
name|DT_NODE_INT
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"integer constant 0x%llx"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|dnp
operator|->
name|dn_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_STRING
case|:
name|s
operator|=
name|strchr2esc
argument_list|(
name|dnp
operator|->
name|dn_string
argument_list|,
name|strlen
argument_list|(
name|dnp
operator|->
name|dn_string
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"string constant \"%s\""
argument_list|,
name|s
operator|!=
name|NULL
condition|?
name|s
else|:
name|dnp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_IDENT
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"identifier %s"
argument_list|,
name|dnp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_VAR
case|:
case|case
name|DT_NODE_FUNC
case|:
case|case
name|DT_NODE_AGG
case|:
case|case
name|DT_NODE_INLINE
case|:
switch|switch
condition|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_kind
condition|)
block|{
case|case
name|DT_IDENT_FUNC
case|:
case|case
name|DT_IDENT_AGGFUNC
case|:
case|case
name|DT_IDENT_ACTFUNC
case|:
name|suffix
operator|=
literal|"( )"
expr_stmt|;
break|break;
case|case
name|DT_IDENT_AGG
case|:
name|prefix
operator|=
literal|"@"
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s %s%s%s"
argument_list|,
name|dt_idkind_name
argument_list|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_kind
argument_list|)
argument_list|,
name|prefix
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_SYM
case|:
name|dts
operator|=
name|dnp
operator|->
name|dn_ident
operator|->
name|di_data
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"symbol %s`%s"
argument_list|,
name|dts
operator|->
name|dts_object
argument_list|,
name|dts
operator|->
name|dts_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_TYPE
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"type %s"
argument_list|,
name|dt_node_type_name
argument_list|(
name|dnp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_OP1
case|:
case|case
name|DT_NODE_OP2
case|:
case|case
name|DT_NODE_OP3
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"operator %s"
argument_list|,
name|opstr
argument_list|(
name|dnp
operator|->
name|dn_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_DEXPR
case|:
case|case
name|DT_NODE_DFUNC
case|:
if|if
condition|(
name|dnp
operator|->
name|dn_expr
condition|)
return|return
operator|(
name|dt_node_name
argument_list|(
name|dnp
operator|->
name|dn_expr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s"
argument_list|,
literal|"statement"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_PDESC
case|:
if|if
condition|(
name|dnp
operator|->
name|dn_desc
operator|->
name|dtpd_id
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"probe description %s:%s:%s:%s"
argument_list|,
name|dnp
operator|->
name|dn_desc
operator|->
name|dtpd_provider
argument_list|,
name|dnp
operator|->
name|dn_desc
operator|->
name|dtpd_mod
argument_list|,
name|dnp
operator|->
name|dn_desc
operator|->
name|dtpd_func
argument_list|,
name|dnp
operator|->
name|dn_desc
operator|->
name|dtpd_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"probe description %u"
argument_list|,
name|dnp
operator|->
name|dn_desc
operator|->
name|dtpd_id
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_NODE_CLAUSE
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s"
argument_list|,
literal|"clause"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_MEMBER
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"member %s"
argument_list|,
name|dnp
operator|->
name|dn_membname
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_XLATOR
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"translator<%s> (%s)"
argument_list|,
name|dt_type_name
argument_list|(
name|dnp
operator|->
name|dn_xlator
operator|->
name|dx_dst_ctfp
argument_list|,
name|dnp
operator|->
name|dn_xlator
operator|->
name|dx_dst_type
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dt_type_name
argument_list|(
name|dnp
operator|->
name|dn_xlator
operator|->
name|dx_src_ctfp
argument_list|,
name|dnp
operator|->
name|dn_xlator
operator|->
name|dx_src_type
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_PROG
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s"
argument_list|,
literal|"program"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"node<%u>"
argument_list|,
name|dnp
operator|->
name|dn_kind
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * dt_node_xalloc() can be used to create new parse nodes from any libdtrace  * caller.  The caller is responsible for assigning dn_link appropriately.  */
end_comment

begin_function
name|dt_node_t
modifier|*
name|dt_node_xalloc
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|int
name|kind
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
init|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_node_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dnp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dnp
operator|->
name|dn_ctfp
operator|=
name|NULL
expr_stmt|;
name|dnp
operator|->
name|dn_type
operator|=
name|CTF_ERR
expr_stmt|;
name|dnp
operator|->
name|dn_kind
operator|=
operator|(
name|uchar_t
operator|)
name|kind
expr_stmt|;
name|dnp
operator|->
name|dn_flags
operator|=
literal|0
expr_stmt|;
name|dnp
operator|->
name|dn_op
operator|=
literal|0
expr_stmt|;
name|dnp
operator|->
name|dn_line
operator|=
operator|-
literal|1
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
operator|-
literal|1
expr_stmt|;
name|dnp
operator|->
name|dn_attr
operator|=
name|_dtrace_defattr
expr_stmt|;
name|dnp
operator|->
name|dn_list
operator|=
name|NULL
expr_stmt|;
name|dnp
operator|->
name|dn_link
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dnp
operator|->
name|dn_u
argument_list|,
sizeof|sizeof
argument_list|(
name|dnp
operator|->
name|dn_u
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * dt_node_alloc() is used to create new parse nodes from the parser.  It  * assigns the node location based on the current lexer line number and places  * the new node on the default allocation list.  If allocation fails, we  * automatically longjmp the caller back to the enclosing compilation call.  */
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_node_alloc
parameter_list|(
name|int
name|kind
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
init|=
name|dt_node_xalloc
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|,
name|kind
argument_list|)
decl_stmt|;
if|if
condition|(
name|dnp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_line
operator|=
name|yylineno
expr_stmt|;
name|dnp
operator|->
name|dn_link
operator|=
name|yypcb
operator|->
name|pcb_list
expr_stmt|;
name|yypcb
operator|->
name|pcb_list
operator|=
name|dnp
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_node_free
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|uchar_t
name|kind
init|=
name|dnp
operator|->
name|dn_kind
decl_stmt|;
name|dnp
operator|->
name|dn_kind
operator|=
name|DT_NODE_FREE
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|DT_NODE_STRING
case|:
case|case
name|DT_NODE_IDENT
case|:
case|case
name|DT_NODE_TYPE
case|:
name|free
argument_list|(
name|dnp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_string
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|DT_NODE_VAR
case|:
case|case
name|DT_NODE_FUNC
case|:
case|case
name|DT_NODE_PROBE
case|:
if|if
condition|(
name|dnp
operator|->
name|dn_ident
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator|&
name|DT_IDFLG_ORPHAN
condition|)
name|dt_ident_destroy
argument_list|(
name|dnp
operator|->
name|dn_ident
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_ident
operator|=
name|NULL
expr_stmt|;
block|}
name|dt_node_list_free
argument_list|(
operator|&
name|dnp
operator|->
name|dn_args
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_OP1
case|:
if|if
condition|(
name|dnp
operator|->
name|dn_child
operator|!=
name|NULL
condition|)
block|{
name|dt_node_free
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_child
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|DT_NODE_OP3
case|:
if|if
condition|(
name|dnp
operator|->
name|dn_expr
operator|!=
name|NULL
condition|)
block|{
name|dt_node_free
argument_list|(
name|dnp
operator|->
name|dn_expr
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_expr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*FALLTHRU*/
case|case
name|DT_NODE_OP2
case|:
if|if
condition|(
name|dnp
operator|->
name|dn_left
operator|!=
name|NULL
condition|)
block|{
name|dt_node_free
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_left
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dnp
operator|->
name|dn_right
operator|!=
name|NULL
condition|)
block|{
name|dt_node_free
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_right
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|DT_NODE_DEXPR
case|:
case|case
name|DT_NODE_DFUNC
case|:
if|if
condition|(
name|dnp
operator|->
name|dn_expr
operator|!=
name|NULL
condition|)
block|{
name|dt_node_free
argument_list|(
name|dnp
operator|->
name|dn_expr
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_expr
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|DT_NODE_AGG
case|:
if|if
condition|(
name|dnp
operator|->
name|dn_aggfun
operator|!=
name|NULL
condition|)
block|{
name|dt_node_free
argument_list|(
name|dnp
operator|->
name|dn_aggfun
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_aggfun
operator|=
name|NULL
expr_stmt|;
block|}
name|dt_node_list_free
argument_list|(
operator|&
name|dnp
operator|->
name|dn_aggtup
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_PDESC
case|:
name|free
argument_list|(
name|dnp
operator|->
name|dn_spec
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_spec
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|dnp
operator|->
name|dn_desc
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_desc
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|DT_NODE_CLAUSE
case|:
if|if
condition|(
name|dnp
operator|->
name|dn_pred
operator|!=
name|NULL
condition|)
name|dt_node_free
argument_list|(
name|dnp
operator|->
name|dn_pred
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_locals
operator|!=
name|NULL
condition|)
name|dt_idhash_destroy
argument_list|(
name|dnp
operator|->
name|dn_locals
argument_list|)
expr_stmt|;
name|dt_node_list_free
argument_list|(
operator|&
name|dnp
operator|->
name|dn_pdescs
argument_list|)
expr_stmt|;
name|dt_node_list_free
argument_list|(
operator|&
name|dnp
operator|->
name|dn_acts
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_MEMBER
case|:
name|free
argument_list|(
name|dnp
operator|->
name|dn_membname
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_membname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_membexpr
operator|!=
name|NULL
condition|)
block|{
name|dt_node_free
argument_list|(
name|dnp
operator|->
name|dn_membexpr
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_membexpr
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|DT_NODE_PROVIDER
case|:
name|dt_node_list_free
argument_list|(
operator|&
name|dnp
operator|->
name|dn_probes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dnp
operator|->
name|dn_provname
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_provname
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|DT_NODE_PROG
case|:
name|dt_node_list_free
argument_list|(
operator|&
name|dnp
operator|->
name|dn_list
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|dt_node_attr_assign
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_attribute_t
name|attr
parameter_list|)
block|{
if|if
condition|(
operator|(
name|yypcb
operator|->
name|pcb_cflags
operator|&
name|DTRACE_C_EATTR
operator|)
operator|&&
operator|(
name|dt_attr_cmp
argument_list|(
name|attr
argument_list|,
name|yypcb
operator|->
name|pcb_amin
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|char
name|a
index|[
name|DTRACE_ATTR2STR_MAX
index|]
decl_stmt|;
name|char
name|s
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_ATTR_MIN
argument_list|,
literal|"attributes for %s (%s) are less than "
literal|"predefined minimum\n"
argument_list|,
name|dt_node_name
argument_list|(
name|dnp
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|,
name|dtrace_attr2str
argument_list|(
name|attr
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dnp
operator|->
name|dn_attr
operator|=
name|attr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_node_type_assign
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
name|ctf_id_t
name|base
init|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|uint_t
name|kind
init|=
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|dnp
operator|->
name|dn_flags
operator|&=
operator|~
operator|(
name|DT_NF_SIGNED
operator||
name|DT_NF_REF
operator||
name|DT_NF_BITFIELD
operator||
name|DT_NF_USERLAND
operator|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_INTEGER
operator|&&
name|ctf_type_encoding
argument_list|(
name|fp
argument_list|,
name|base
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|size
init|=
name|e
operator|.
name|cte_bits
operator|/
name|NBBY
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|8
operator|||
operator|(
name|e
operator|.
name|cte_bits
operator|%
name|NBBY
operator|)
operator|!=
literal|0
operator|||
operator|(
name|size
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_BITFIELD
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|cte_format
operator|&
name|CTF_INT_SIGNED
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_SIGNED
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|==
name|CTF_K_FLOAT
operator|&&
name|ctf_type_encoding
argument_list|(
name|fp
argument_list|,
name|base
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|.
name|cte_bits
operator|/
name|NBBY
operator|>
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_REF
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|==
name|CTF_K_STRUCT
operator|||
name|kind
operator|==
name|CTF_K_UNION
operator|||
name|kind
operator|==
name|CTF_K_FORWARD
operator|||
name|kind
operator|==
name|CTF_K_ARRAY
operator|||
name|kind
operator|==
name|CTF_K_FUNCTION
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_REF
expr_stmt|;
elseif|else
if|if
condition|(
name|yypcb
operator|!=
name|NULL
operator|&&
name|fp
operator|==
name|DT_DYN_CTFP
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
operator|&&
name|type
operator|==
name|DT_DYN_TYPE
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_REF
expr_stmt|;
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_COOKED
expr_stmt|;
name|dnp
operator|->
name|dn_ctfp
operator|=
name|fp
expr_stmt|;
name|dnp
operator|->
name|dn_type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_node_type_propagate
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|src
parameter_list|,
name|dt_node_t
modifier|*
name|dst
parameter_list|)
block|{
name|assert
argument_list|(
name|src
operator|->
name|dn_flags
operator|&
name|DT_NF_COOKED
argument_list|)
expr_stmt|;
name|dst
operator|->
name|dn_flags
operator|=
name|src
operator|->
name|dn_flags
operator|&
operator|~
name|DT_NF_LVALUE
expr_stmt|;
name|dst
operator|->
name|dn_ctfp
operator|=
name|src
operator|->
name|dn_ctfp
expr_stmt|;
name|dst
operator|->
name|dn_type
operator|=
name|src
operator|->
name|dn_type
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|dt_node_type_name
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|dt_node_is_dynamic
argument_list|(
name|dnp
argument_list|)
operator|&&
name|dnp
operator|->
name|dn_ident
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s"
argument_list|,
name|dt_idkind_name
argument_list|(
name|dt_ident_resolve
argument_list|(
name|dnp
operator|->
name|dn_ident
argument_list|)
operator|->
name|di_kind
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
condition|)
block|{
name|size_t
name|n
init|=
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"userland "
argument_list|)
decl_stmt|;
name|len
operator|=
name|len
operator|>
name|n
condition|?
name|len
operator|-
name|n
else|:
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|dt_type_name
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|,
name|buf
operator|+
name|n
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
return|return
operator|(
name|dt_type_name
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|dt_node_type_size
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|ctf_id_t
name|base
decl_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_STRING
condition|)
return|return
operator|(
name|strlen
argument_list|(
name|dnp
operator|->
name|dn_string
argument_list|)
operator|+
literal|1
operator|)
return|;
if|if
condition|(
name|dt_node_is_dynamic
argument_list|(
name|dnp
argument_list|)
operator|&&
name|dnp
operator|->
name|dn_ident
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dt_ident_size
argument_list|(
name|dnp
operator|->
name|dn_ident
argument_list|)
operator|)
return|;
name|base
operator|=
name|ctf_type_resolve
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctf_type_kind
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|base
argument_list|)
operator|==
name|CTF_K_FORWARD
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ctf_type_size
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if the specified parse tree node references an identifier of the  * specified kind, and if so return a pointer to it; otherwise return NULL.  * This function resolves the identifier itself, following through any inlines.  */
end_comment

begin_function
name|dt_ident_t
modifier|*
name|dt_node_resolve
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idkind
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
switch|switch
condition|(
name|dnp
operator|->
name|dn_kind
condition|)
block|{
case|case
name|DT_NODE_VAR
case|:
case|case
name|DT_NODE_SYM
case|:
case|case
name|DT_NODE_FUNC
case|:
case|case
name|DT_NODE_AGG
case|:
case|case
name|DT_NODE_INLINE
case|:
case|case
name|DT_NODE_PROBE
case|:
name|idp
operator|=
name|dt_ident_resolve
argument_list|(
name|dnp
operator|->
name|dn_ident
argument_list|)
expr_stmt|;
return|return
operator|(
name|idp
operator|->
name|di_kind
operator|==
name|idkind
condition|?
name|idp
else|:
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|dt_node_is_dynamic
argument_list|(
name|dnp
argument_list|)
condition|)
block|{
name|idp
operator|=
name|dt_ident_resolve
argument_list|(
name|dnp
operator|->
name|dn_ident
argument_list|)
expr_stmt|;
return|return
operator|(
name|idp
operator|->
name|di_kind
operator|==
name|idkind
condition|?
name|idp
else|:
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|dt_node_sizeof
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dtrace_syminfo_t
modifier|*
name|sip
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
comment|/* 	 * The size of the node as used for the sizeof() operator depends on 	 * the kind of the node.  If the node is a SYM, the size is obtained 	 * from the symbol table; if it is not a SYM, the size is determined 	 * from the node's type.  This is slightly different from C's sizeof() 	 * operator in that (for example) when applied to a function, sizeof() 	 * will evaluate to the length of the function rather than the size of 	 * the function type. 	 */
if|if
condition|(
name|dnp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_SYM
condition|)
return|return
operator|(
name|dt_node_type_size
argument_list|(
name|dnp
argument_list|)
operator|)
return|;
name|sip
operator|=
name|dnp
operator|->
name|dn_ident
operator|->
name|di_data
expr_stmt|;
if|if
condition|(
name|dtrace_lookup_by_name
argument_list|(
name|dtp
argument_list|,
name|sip
operator|->
name|dts_object
argument_list|,
name|sip
operator|->
name|dts_name
argument_list|,
operator|&
name|sym
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|sym
operator|.
name|st_size
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_integer
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|uint_t
name|kind
decl_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_COOKED
argument_list|)
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_INTEGER
operator|&&
name|ctf_type_encoding
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
operator|&&
name|IS_VOID
argument_list|(
name|e
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* void integer */
return|return
operator|(
name|kind
operator|==
name|CTF_K_INTEGER
operator|||
name|kind
operator|==
name|CTF_K_ENUM
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_float
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|uint_t
name|kind
decl_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_COOKED
argument_list|)
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|kind
operator|==
name|CTF_K_FLOAT
operator|&&
name|ctf_type_encoding
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|type
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|e
operator|.
name|cte_format
operator|==
name|CTF_FP_SINGLE
operator|||
name|e
operator|.
name|cte_format
operator|==
name|CTF_FP_DOUBLE
operator|||
name|e
operator|.
name|cte_format
operator|==
name|CTF_FP_LDOUBLE
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_scalar
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|uint_t
name|kind
decl_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_COOKED
argument_list|)
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_INTEGER
operator|&&
name|ctf_type_encoding
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
operator|&&
name|IS_VOID
argument_list|(
name|e
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* void cannot be used as a scalar */
return|return
operator|(
name|kind
operator|==
name|CTF_K_INTEGER
operator|||
name|kind
operator|==
name|CTF_K_ENUM
operator|||
name|kind
operator|==
name|CTF_K_POINTER
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_arith
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|uint_t
name|kind
decl_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_COOKED
argument_list|)
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_INTEGER
condition|)
return|return
operator|(
name|ctf_type_encoding
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|IS_VOID
argument_list|(
name|e
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|kind
operator|==
name|CTF_K_ENUM
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_vfptr
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|uint_t
name|kind
decl_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_COOKED
argument_list|)
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|!=
name|CTF_K_POINTER
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* type is not a pointer */
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|ctf_type_reference
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|kind
operator|==
name|CTF_K_FUNCTION
operator|||
operator|(
name|kind
operator|==
name|CTF_K_INTEGER
operator|&&
name|ctf_type_encoding
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
operator|&&
name|IS_VOID
argument_list|(
name|e
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_dynamic
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
if|if
condition|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
operator|&&
operator|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator|&
name|DT_IDFLG_INLINE
operator|)
condition|)
block|{
specifier|const
name|dt_idnode_t
modifier|*
name|inp
init|=
name|dnp
operator|->
name|dn_ident
operator|->
name|di_iarg
decl_stmt|;
return|return
operator|(
name|inp
operator|->
name|din_root
condition|?
name|dt_node_is_dynamic
argument_list|(
name|inp
operator|->
name|din_root
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|dnp
operator|->
name|dn_ctfp
operator|==
name|DT_DYN_CTFP
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
operator|&&
name|dnp
operator|->
name|dn_type
operator|==
name|DT_DYN_TYPE
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_string
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dnp
operator|->
name|dn_ctfp
operator|==
name|DT_STR_CTFP
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
operator|&&
name|dnp
operator|->
name|dn_type
operator|==
name|DT_STR_TYPE
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_stack
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dnp
operator|->
name|dn_ctfp
operator|==
name|DT_STACK_CTFP
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
operator|&&
name|dnp
operator|->
name|dn_type
operator|==
name|DT_STACK_TYPE
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_symaddr
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dnp
operator|->
name|dn_ctfp
operator|==
name|DT_SYMADDR_CTFP
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
operator|&&
name|dnp
operator|->
name|dn_type
operator|==
name|DT_SYMADDR_TYPE
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_usymaddr
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dnp
operator|->
name|dn_ctfp
operator|==
name|DT_USYMADDR_CTFP
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
operator|&&
name|dnp
operator|->
name|dn_type
operator|==
name|DT_USYMADDR_TYPE
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_strcompat
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|ctf_arinfo_t
name|r
decl_stmt|;
name|ctf_id_t
name|base
decl_stmt|;
name|uint_t
name|kind
decl_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_COOKED
argument_list|)
expr_stmt|;
name|base
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_POINTER
operator|&&
operator|(
name|base
operator|=
name|ctf_type_reference
argument_list|(
name|fp
argument_list|,
name|base
argument_list|)
operator|)
operator|!=
name|CTF_ERR
operator|&&
operator|(
name|base
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|base
argument_list|)
operator|)
operator|!=
name|CTF_ERR
operator|&&
name|ctf_type_encoding
argument_list|(
name|fp
argument_list|,
name|base
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
operator|&&
name|IS_CHAR
argument_list|(
name|e
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* promote char pointer to string */
if|if
condition|(
name|kind
operator|==
name|CTF_K_ARRAY
operator|&&
name|ctf_array_info
argument_list|(
name|fp
argument_list|,
name|base
argument_list|,
operator|&
name|r
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|base
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|r
operator|.
name|ctr_contents
argument_list|)
operator|)
operator|!=
name|CTF_ERR
operator|&&
name|ctf_type_encoding
argument_list|(
name|fp
argument_list|,
name|base
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
operator|&&
name|IS_CHAR
argument_list|(
name|e
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* promote char array to string */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_pointer
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|uint_t
name|kind
decl_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_COOKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_node_is_string
argument_list|(
name|dnp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* string are pass-by-ref but act like structs */
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|kind
operator|==
name|CTF_K_POINTER
operator|||
name|kind
operator|==
name|CTF_K_ARRAY
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_void
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
if|if
condition|(
name|dt_node_is_dynamic
argument_list|(
name|dnp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*<DYN> is an alias for void but not the same */
if|if
condition|(
name|dt_node_is_stack
argument_list|(
name|dnp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dt_node_is_symaddr
argument_list|(
name|dnp
argument_list|)
operator|||
name|dt_node_is_usymaddr
argument_list|(
name|dnp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|==
name|CTF_K_INTEGER
operator|&&
name|ctf_type_encoding
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
operator|&&
name|IS_VOID
argument_list|(
name|e
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_ptrcompat
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|lp
parameter_list|,
specifier|const
name|dt_node_t
modifier|*
name|rp
parameter_list|,
name|ctf_file_t
modifier|*
modifier|*
name|fpp
parameter_list|,
name|ctf_id_t
modifier|*
name|tp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|lfp
init|=
name|lp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_file_t
modifier|*
name|rfp
init|=
name|rp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_id_t
name|lbase
init|=
name|CTF_ERR
decl_stmt|,
name|rbase
init|=
name|CTF_ERR
decl_stmt|;
name|ctf_id_t
name|lref
init|=
name|CTF_ERR
decl_stmt|,
name|rref
init|=
name|CTF_ERR
decl_stmt|;
name|int
name|lp_is_void
decl_stmt|,
name|rp_is_void
decl_stmt|,
name|lp_is_int
decl_stmt|,
name|rp_is_int
decl_stmt|,
name|compat
decl_stmt|;
name|uint_t
name|lkind
decl_stmt|,
name|rkind
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|ctf_arinfo_t
name|r
decl_stmt|;
name|assert
argument_list|(
name|lp
operator|->
name|dn_flags
operator|&
name|DT_NF_COOKED
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rp
operator|->
name|dn_flags
operator|&
name|DT_NF_COOKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_node_is_dynamic
argument_list|(
name|lp
argument_list|)
operator|||
name|dt_node_is_dynamic
argument_list|(
name|rp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* fail if either node is a dynamic variable */
name|lp_is_int
operator|=
name|dt_node_is_integer
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|rp_is_int
operator|=
name|dt_node_is_integer
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp_is_int
operator|&&
name|rp_is_int
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* fail if both nodes are integers */
if|if
condition|(
name|lp_is_int
operator|&&
operator|(
name|lp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_INT
operator|||
name|lp
operator|->
name|dn_value
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* fail if lp is an integer that isn't 0 constant */
if|if
condition|(
name|rp_is_int
operator|&&
operator|(
name|rp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_INT
operator|||
name|rp
operator|->
name|dn_value
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* fail if rp is an integer that isn't 0 constant */
if|if
condition|(
operator|(
name|lp_is_int
operator|==
literal|0
operator|&&
name|rp_is_int
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|lp
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
operator|)
operator|^
operator|(
name|rp
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* fail if only one pointer is a userland address */
comment|/* 	 * Resolve the left-hand and right-hand types to their base type, and 	 * then resolve the referenced type as well (assuming the base type 	 * is CTF_K_POINTER or CTF_K_ARRAY).  Otherwise [lr]ref = CTF_ERR. 	 */
if|if
condition|(
operator|!
name|lp_is_int
condition|)
block|{
name|lbase
operator|=
name|ctf_type_resolve
argument_list|(
name|lfp
argument_list|,
name|lp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|lkind
operator|=
name|ctf_type_kind
argument_list|(
name|lfp
argument_list|,
name|lbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|lkind
operator|==
name|CTF_K_POINTER
condition|)
block|{
name|lref
operator|=
name|ctf_type_resolve
argument_list|(
name|lfp
argument_list|,
name|ctf_type_reference
argument_list|(
name|lfp
argument_list|,
name|lbase
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lkind
operator|==
name|CTF_K_ARRAY
operator|&&
name|ctf_array_info
argument_list|(
name|lfp
argument_list|,
name|lbase
argument_list|,
operator|&
name|r
argument_list|)
operator|==
literal|0
condition|)
block|{
name|lref
operator|=
name|ctf_type_resolve
argument_list|(
name|lfp
argument_list|,
name|r
operator|.
name|ctr_contents
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|rp_is_int
condition|)
block|{
name|rbase
operator|=
name|ctf_type_resolve
argument_list|(
name|rfp
argument_list|,
name|rp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|rkind
operator|=
name|ctf_type_kind
argument_list|(
name|rfp
argument_list|,
name|rbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|rkind
operator|==
name|CTF_K_POINTER
condition|)
block|{
name|rref
operator|=
name|ctf_type_resolve
argument_list|(
name|rfp
argument_list|,
name|ctf_type_reference
argument_list|(
name|rfp
argument_list|,
name|rbase
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rkind
operator|==
name|CTF_K_ARRAY
operator|&&
name|ctf_array_info
argument_list|(
name|rfp
argument_list|,
name|rbase
argument_list|,
operator|&
name|r
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rref
operator|=
name|ctf_type_resolve
argument_list|(
name|rfp
argument_list|,
name|r
operator|.
name|ctr_contents
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * We know that one or the other type may still be a zero-valued 	 * integer constant.  To simplify the code below, set the integer 	 * type variables equal to the non-integer types and proceed. 	 */
if|if
condition|(
name|lp_is_int
condition|)
block|{
name|lbase
operator|=
name|rbase
expr_stmt|;
name|lkind
operator|=
name|rkind
expr_stmt|;
name|lref
operator|=
name|rref
expr_stmt|;
name|lfp
operator|=
name|rfp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp_is_int
condition|)
block|{
name|rbase
operator|=
name|lbase
expr_stmt|;
name|rkind
operator|=
name|lkind
expr_stmt|;
name|rref
operator|=
name|lref
expr_stmt|;
name|rfp
operator|=
name|lfp
expr_stmt|;
block|}
name|lp_is_void
operator|=
name|ctf_type_encoding
argument_list|(
name|lfp
argument_list|,
name|lref
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
operator|&&
name|IS_VOID
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|rp_is_void
operator|=
name|ctf_type_encoding
argument_list|(
name|rfp
argument_list|,
name|rref
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
operator|&&
name|IS_VOID
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* 	 * The types are compatible if both are pointers to the same type, or 	 * if either pointer is a void pointer.  If they are compatible, set 	 * tp to point to the more specific pointer type and return it. 	 */
name|compat
operator|=
operator|(
name|lkind
operator|==
name|CTF_K_POINTER
operator|||
name|lkind
operator|==
name|CTF_K_ARRAY
operator|)
operator|&&
operator|(
name|rkind
operator|==
name|CTF_K_POINTER
operator|||
name|rkind
operator|==
name|CTF_K_ARRAY
operator|)
operator|&&
operator|(
name|lp_is_void
operator|||
name|rp_is_void
operator|||
name|ctf_type_compat
argument_list|(
name|lfp
argument_list|,
name|lref
argument_list|,
name|rfp
argument_list|,
name|rref
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|compat
condition|)
block|{
if|if
condition|(
name|fpp
operator|!=
name|NULL
condition|)
operator|*
name|fpp
operator|=
name|rp_is_void
condition|?
name|lfp
else|:
name|rfp
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
operator|*
name|tp
operator|=
name|rp_is_void
condition|?
name|lbase
else|:
name|rbase
expr_stmt|;
block|}
return|return
operator|(
name|compat
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The rules for checking argument types against parameter types are described  * in the ANSI-C spec (see K&R[A7.3.2] and K&R[A7.17]).  We use the same rule  * set to determine whether associative array arguments match the prototype.  */
end_comment

begin_function
name|int
name|dt_node_is_argcompat
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|lp
parameter_list|,
specifier|const
name|dt_node_t
modifier|*
name|rp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|lfp
init|=
name|lp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_file_t
modifier|*
name|rfp
init|=
name|rp
operator|->
name|dn_ctfp
decl_stmt|;
name|assert
argument_list|(
name|lp
operator|->
name|dn_flags
operator|&
name|DT_NF_COOKED
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rp
operator|->
name|dn_flags
operator|&
name|DT_NF_COOKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_node_is_integer
argument_list|(
name|lp
argument_list|)
operator|&&
name|dt_node_is_integer
argument_list|(
name|rp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* integer types are compatible */
if|if
condition|(
name|dt_node_is_strcompat
argument_list|(
name|lp
argument_list|)
operator|&&
name|dt_node_is_strcompat
argument_list|(
name|rp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* string types are compatible */
if|if
condition|(
name|dt_node_is_stack
argument_list|(
name|lp
argument_list|)
operator|&&
name|dt_node_is_stack
argument_list|(
name|rp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* stack types are compatible */
if|if
condition|(
name|dt_node_is_symaddr
argument_list|(
name|lp
argument_list|)
operator|&&
name|dt_node_is_symaddr
argument_list|(
name|rp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* symaddr types are compatible */
if|if
condition|(
name|dt_node_is_usymaddr
argument_list|(
name|lp
argument_list|)
operator|&&
name|dt_node_is_usymaddr
argument_list|(
name|rp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* usymaddr types are compatible */
switch|switch
condition|(
name|ctf_type_kind
argument_list|(
name|lfp
argument_list|,
name|ctf_type_resolve
argument_list|(
name|lfp
argument_list|,
name|lp
operator|->
name|dn_type
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CTF_K_FUNCTION
case|:
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
return|return
operator|(
name|ctf_type_compat
argument_list|(
name|lfp
argument_list|,
name|lp
operator|->
name|dn_type
argument_list|,
name|rfp
argument_list|,
name|rp
operator|->
name|dn_type
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|dt_node_is_ptrcompat
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * We provide dt_node_is_posconst() as a convenience routine for callers who  * wish to verify that an argument is a positive non-zero integer constant.  */
end_comment

begin_function
name|int
name|dt_node_is_posconst
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_INT
operator|&&
name|dnp
operator|->
name|dn_value
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
operator|==
literal|0
operator|||
operator|(
name|int64_t
operator|)
name|dnp
operator|->
name|dn_value
operator|>
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_node_is_actfunc
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_FUNC
operator|&&
name|dnp
operator|->
name|dn_ident
operator|->
name|di_kind
operator|==
name|DT_IDENT_ACTFUNC
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The original rules for integer constant typing are described in K&R[A2.5.1].  * However, since we support long long, we instead use the rules from ISO C99  * clause 6.4.4.1 since that is where long longs are formally described.  The  * rules require us to know whether the constant was specified in decimal or  * in octal or hex, which we do by looking at our lexer's 'yyintdecimal' flag.  * The type of an integer constant is the first of the corresponding list in  * which its value can be represented:  *  * unsuffixed decimal:   int, long, long long  * unsuffixed oct/hex:   int, unsigned int, long, unsigned long,  *                       long long, unsigned long long  * suffix [uU]:          unsigned int, unsigned long, unsigned long long  * suffix [lL] decimal:  long, long long  * suffix [lL] oct/hex:  long, unsigned long, long long, unsigned long long  * suffix [uU][Ll]:      unsigned long, unsigned long long  * suffix ll/LL decimal: long long  * suffix ll/LL oct/hex: long long, unsigned long long  * suffix [uU][ll/LL]:   unsigned long long  *  * Given that our lexer has already validated the suffixes by regexp matching,  * there is an obvious way to concisely encode these rules: construct an array  * of the types in the order int, unsigned int, long, unsigned long, long long,  * unsigned long long.  Compute an integer array starting index based on the  * suffix (e.g. none = 0, u = 1, ull = 5), and compute an increment based on  * the specifier (dec/oct/hex) and suffix (u).  Then iterate from the starting  * index to the end, advancing using the increment, and searching until we  * find a limit that matches or we run out of choices (overflow).  To make it  * even faster, we precompute the table of type information in dtrace_open().  */
end_comment

begin_function
name|dt_node_t
modifier|*
name|dt_node_int
parameter_list|(
name|uintmax_t
name|value
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
init|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_INT
argument_list|)
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|int
name|n
init|=
operator|(
name|yyintdecimal
operator||
operator|(
name|yyintsuffix
index|[
literal|0
index|]
operator|==
literal|'u'
operator|)
operator|)
operator|+
literal|1
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|dnp
operator|->
name|dn_op
operator|=
name|DT_TOK_INT
expr_stmt|;
name|dnp
operator|->
name|dn_value
operator|=
name|value
expr_stmt|;
for|for
control|(
name|p
operator|=
name|yyintsuffix
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'U'
operator|||
name|c
operator|==
literal|'u'
condition|)
name|i
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'L'
operator|||
name|c
operator|==
literal|'l'
condition|)
name|i
operator|+=
literal|2
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|dtp
operator|->
name|dt_ints
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dtp
operator|->
name|dt_ints
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|+=
name|n
control|)
block|{
if|if
condition|(
name|value
operator|<=
name|dtp
operator|->
name|dt_ints
index|[
name|i
index|]
operator|.
name|did_limit
condition|)
block|{
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|dtp
operator|->
name|dt_ints
index|[
name|i
index|]
operator|.
name|did_ctfp
argument_list|,
name|dtp
operator|->
name|dt_ints
index|[
name|i
index|]
operator|.
name|did_type
argument_list|)
expr_stmt|;
comment|/* 			 * If a prefix character is present in macro text, add 			 * in the corresponding operator node (see dt_lex.l). 			 */
switch|switch
condition|(
name|yyintprefix
condition|)
block|{
case|case
literal|'+'
case|:
return|return
operator|(
name|dt_node_op1
argument_list|(
name|DT_TOK_IPOS
argument_list|,
name|dnp
argument_list|)
operator|)
return|;
case|case
literal|'-'
case|:
return|return
operator|(
name|dt_node_op1
argument_list|(
name|DT_TOK_INEG
argument_list|,
name|dnp
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|dnp
operator|)
return|;
block|}
block|}
block|}
name|xyerror
argument_list|(
name|D_INT_OFLOW
argument_list|,
literal|"integer constant 0x%llx cannot be represented "
literal|"in any built-in integral type\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|value
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* keep gcc happy */
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_string
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|dnp
operator|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_STRING
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_op
operator|=
name|DT_TOK_STRING
expr_stmt|;
name|dnp
operator|->
name|dn_string
operator|=
name|string
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_STR_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_STR_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_ident
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
comment|/* 	 * If the identifier is an inlined integer constant, then create an INT 	 * node that is a clone of the inline parse tree node and return that 	 * immediately, allowing this inline to be used in parsing contexts 	 * that require constant expressions (e.g. scalar array sizes). 	 */
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_idstack_lookup
argument_list|(
operator|&
name|yypcb
operator|->
name|pcb_globals
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_INLINE
operator|)
condition|)
block|{
name|dt_idnode_t
modifier|*
name|inp
init|=
name|idp
operator|->
name|di_iarg
decl_stmt|;
if|if
condition|(
name|inp
operator|->
name|din_root
operator|!=
name|NULL
operator|&&
name|inp
operator|->
name|din_root
operator|->
name|dn_kind
operator|==
name|DT_NODE_INT
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|dnp
operator|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_INT
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_op
operator|=
name|DT_TOK_INT
expr_stmt|;
name|dnp
operator|->
name|dn_value
operator|=
name|inp
operator|->
name|din_root
operator|->
name|dn_value
expr_stmt|;
name|dt_node_type_propagate
argument_list|(
name|inp
operator|->
name|din_root
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
block|}
name|dnp
operator|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_IDENT
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_op
operator|=
name|name
index|[
literal|0
index|]
operator|==
literal|'@'
condition|?
name|DT_TOK_AGG
else|:
name|DT_TOK_IDENT
expr_stmt|;
name|dnp
operator|->
name|dn_string
operator|=
name|name
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create an empty node of type corresponding to the given declaration.  * Explicit references to user types (C or D) are assigned the default  * stability; references to other types are _dtrace_typattr (Private).  */
end_comment

begin_function
name|dt_node_t
modifier|*
name|dt_node_type
parameter_list|(
name|dt_decl_t
modifier|*
name|ddp
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * If 'ddp' is NULL, we get a decl by popping the decl stack.  This 	 * form of dt_node_type() is used by parameter rules in dt_grammar.y. 	 */
if|if
condition|(
name|ddp
operator|==
name|NULL
condition|)
name|ddp
operator|=
name|dt_decl_pop_param
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|err
operator|=
name|dt_decl_type
argument_list|(
name|ddp
argument_list|,
operator|&
name|dtt
argument_list|)
expr_stmt|;
name|dt_decl_free
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
block|}
name|dnp
operator|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_TYPE
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_op
operator|=
name|DT_TOK_IDENT
expr_stmt|;
name|dnp
operator|->
name|dn_string
operator|=
name|name
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtt
operator|.
name|dtt_ctfp
operator|==
name|dtp
operator|->
name|dt_cdefs
operator|->
name|dm_ctfp
operator|||
name|dtt
operator|.
name|dtt_ctfp
operator|==
name|dtp
operator|->
name|dt_ddefs
operator|->
name|dm_ctfp
condition|)
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|_dtrace_defattr
argument_list|)
expr_stmt|;
else|else
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|_dtrace_typattr
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a type node corresponding to a varargs (...) parameter by just  * assigning it type CTF_ERR.  The decl processing code will handle this.  */
end_comment

begin_function
name|dt_node_t
modifier|*
name|dt_node_vatype
parameter_list|(
name|void
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
init|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_TYPE
argument_list|)
decl_stmt|;
name|dnp
operator|->
name|dn_op
operator|=
name|DT_TOK_IDENT
expr_stmt|;
name|dnp
operator|->
name|dn_ctfp
operator|=
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_cdefs
operator|->
name|dm_ctfp
expr_stmt|;
name|dnp
operator|->
name|dn_type
operator|=
name|CTF_ERR
expr_stmt|;
name|dnp
operator|->
name|dn_attr
operator|=
name|_dtrace_defattr
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Instantiate a decl using the contents of the current declaration stack.  As  * we do not currently permit decls to be initialized, this function currently  * returns NULL and no parse node is created.  When this function is called,  * the topmost scope's ds_ident pointer will be set to NULL (indicating no  * init_declarator rule was matched) or will point to the identifier to use.  */
end_comment

begin_function
name|dt_node_t
modifier|*
name|dt_node_decl
parameter_list|(
name|void
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_scope_t
modifier|*
name|dsp
init|=
operator|&
name|yypcb
operator|->
name|pcb_dstack
decl_stmt|;
name|dt_dclass_t
name|class
init|=
name|dsp
operator|->
name|ds_class
decl_stmt|;
name|dt_decl_t
modifier|*
name|ddp
init|=
name|dt_decl_top
argument_list|()
decl_stmt|;
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|char
name|n1
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|char
name|n2
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|dt_decl_type
argument_list|(
name|ddp
argument_list|,
operator|&
name|dtt
argument_list|)
operator|!=
literal|0
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
comment|/* 	 * If we have no declaration identifier, then this is either a spurious 	 * declaration of an intrinsic type (e.g. "extern int;") or declaration 	 * or redeclaration of a struct, union, or enum type or tag. 	 */
if|if
condition|(
name|dsp
operator|->
name|ds_ident
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ddp
operator|->
name|dd_kind
operator|!=
name|CTF_K_STRUCT
operator|&&
name|ddp
operator|->
name|dd_kind
operator|!=
name|CTF_K_UNION
operator|&&
name|ddp
operator|->
name|dd_kind
operator|!=
name|CTF_K_ENUM
condition|)
name|xyerror
argument_list|(
name|D_DECL_USELESS
argument_list|,
literal|"useless declaration\n"
argument_list|)
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"type %s added as id %ld\n"
argument_list|,
name|dt_type_name
argument_list|(
name|ddp
operator|->
name|dd_ctfp
argument_list|,
name|ddp
operator|->
name|dd_type
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|ddp
operator|->
name|dd_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|dsp
operator|->
name|ds_ident
argument_list|,
literal|'`'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_SCOPE
argument_list|,
literal|"D scoping operator may not be used in "
literal|"a declaration name (%s)\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we are nested inside of a C include file, add the declaration to 	 * the C definition module; otherwise use the D definition module. 	 */
if|if
condition|(
name|yypcb
operator|->
name|pcb_idepth
operator|!=
literal|0
condition|)
name|dmp
operator|=
name|dtp
operator|->
name|dt_cdefs
expr_stmt|;
else|else
name|dmp
operator|=
name|dtp
operator|->
name|dt_ddefs
expr_stmt|;
comment|/* 	 * If we see a global or static declaration of a function prototype, 	 * treat this as equivalent to a D extern declaration. 	 */
if|if
condition|(
name|ctf_type_kind
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
operator|==
name|CTF_K_FUNCTION
operator|&&
operator|(
name|class
operator|==
name|DT_DC_DEFAULT
operator|||
name|class
operator|==
name|DT_DC_STATIC
operator|)
condition|)
name|class
operator|=
name|DT_DC_EXTERN
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|DT_DC_AUTO
case|:
case|case
name|DT_DC_REGISTER
case|:
case|case
name|DT_DC_STATIC
case|:
name|xyerror
argument_list|(
name|D_DECL_BADCLASS
argument_list|,
literal|"specified storage class not "
literal|"appropriate in D\n"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
name|DT_DC_EXTERN
case|:
block|{
name|dtrace_typeinfo_t
name|ott
decl_stmt|;
name|dtrace_syminfo_t
name|dts
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|int
name|exists
init|=
name|dtrace_lookup_by_name
argument_list|(
name|dtp
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|dts
argument_list|)
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|exists
operator|&&
operator|(
name|dtrace_symbol_type
argument_list|(
name|dtp
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|dts
argument_list|,
operator|&
name|ott
argument_list|)
operator|!=
literal|0
operator|||
name|ctf_type_cmp
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|,
name|ott
operator|.
name|dtt_ctfp
argument_list|,
name|ott
operator|.
name|dtt_type
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_IDRED
argument_list|,
literal|"identifier redeclared: %s`%s\n"
literal|"\t current: %s\n\tprevious: %s\n"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|dt_type_name
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dt_type_name
argument_list|(
name|ott
operator|.
name|dtt_ctfp
argument_list|,
name|ott
operator|.
name|dtt_type
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|exists
operator|&&
name|dt_module_extern
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
operator|&
name|dtt
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to extern %s: %s\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dt_dprintf
argument_list|(
literal|"extern %s`%s type=<%s>\n"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|dt_type_name
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DT_DC_TYPEDEF
case|:
if|if
condition|(
name|dt_idstack_lookup
argument_list|(
operator|&
name|yypcb
operator|->
name|pcb_globals
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_IDRED
argument_list|,
literal|"global variable identifier "
literal|"redeclared: %s\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctf_lookup_by_name
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
operator|!=
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_IDRED
argument_list|,
literal|"typedef redeclared: %s\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the source type for the typedef is not defined in the 		 * target container or its parent, copy the type to the target 		 * container and reset dtt_ctfp and dtt_type to the copy. 		 */
if|if
condition|(
name|dtt
operator|.
name|dtt_ctfp
operator|!=
name|dmp
operator|->
name|dm_ctfp
operator|&&
name|dtt
operator|.
name|dtt_ctfp
operator|!=
name|ctf_parent_file
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
condition|)
block|{
name|dtt
operator|.
name|dtt_type
operator|=
name|ctf_add_type
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
name|dtt
operator|.
name|dtt_ctfp
operator|=
name|dmp
operator|->
name|dm_ctfp
expr_stmt|;
if|if
condition|(
name|dtt
operator|.
name|dtt_type
operator|==
name|CTF_ERR
operator|||
name|ctf_update
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to copy typedef %s "
literal|"source type: %s\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|type
operator|=
name|ctf_add_typedef
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CTF_ERR
operator|||
name|ctf_update
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to typedef %s: %s\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_dprintf
argument_list|(
literal|"typedef %s added as id %ld\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
name|ctf_encoding_t
name|cte
decl_stmt|;
name|dt_idhash_t
modifier|*
name|dhp
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|dt_node_t
name|idn
decl_stmt|;
name|int
name|assc
decl_stmt|,
name|idkind
decl_stmt|;
name|uint_t
name|id
decl_stmt|,
name|kind
decl_stmt|;
name|ushort_t
name|idflags
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|DT_DC_THIS
case|:
name|dhp
operator|=
name|yypcb
operator|->
name|pcb_locals
expr_stmt|;
name|idflags
operator|=
name|DT_IDFLG_LOCAL
expr_stmt|;
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|dhp
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_DC_SELF
case|:
name|dhp
operator|=
name|dtp
operator|->
name|dt_tls
expr_stmt|;
name|idflags
operator|=
name|DT_IDFLG_TLS
expr_stmt|;
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|dhp
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dhp
operator|=
name|dtp
operator|->
name|dt_globals
expr_stmt|;
name|idflags
operator|=
literal|0
expr_stmt|;
name|idp
operator|=
name|dt_idstack_lookup
argument_list|(
operator|&
name|yypcb
operator|->
name|pcb_globals
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ddp
operator|->
name|dd_kind
operator|==
name|CTF_K_ARRAY
operator|&&
name|ddp
operator|->
name|dd_node
operator|==
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_ARRNULL
argument_list|,
literal|"array declaration requires array dimension or "
literal|"tuple signature: %s\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idp
operator|!=
name|NULL
operator|&&
name|idp
operator|->
name|di_gen
operator|==
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_IDRED
argument_list|,
literal|"built-in identifier "
literal|"redeclared: %s\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_lookup_by_type
argument_list|(
name|dtp
argument_list|,
name|DTRACE_OBJ_CDEFS
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
operator|||
name|dtrace_lookup_by_type
argument_list|(
name|dtp
argument_list|,
name|DTRACE_OBJ_DDEFS
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_IDRED
argument_list|,
literal|"typedef identifier "
literal|"redeclared: %s\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Cache some attributes of the decl to make the rest of this 		 * code simpler: if the decl is an array which is subscripted 		 * by a type rather than an integer, then it's an associative 		 * array (assc).  We then expect to match either DT_IDENT_ARRAY 		 * for associative arrays or DT_IDENT_SCALAR for anything else. 		 */
name|assc
operator|=
name|ddp
operator|->
name|dd_kind
operator|==
name|CTF_K_ARRAY
operator|&&
name|ddp
operator|->
name|dd_node
operator|->
name|dn_kind
operator|==
name|DT_NODE_TYPE
expr_stmt|;
name|idkind
operator|=
name|assc
condition|?
name|DT_IDENT_ARRAY
else|:
name|DT_IDENT_SCALAR
expr_stmt|;
comment|/* 		 * Create a fake dt_node_t on the stack so we can determine the 		 * type of any matching identifier by assigning to this node. 		 * If the pre-existing ident has its di_type set, propagate 		 * the type by hand so as not to trigger a prototype check for 		 * arrays (yet); otherwise we use dt_ident_cook() on the ident 		 * to ensure it is fully initialized before looking at it. 		 */
name|bzero
argument_list|(
operator|&
name|idn
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_node_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|!=
name|NULL
operator|&&
name|idp
operator|->
name|di_type
operator|!=
name|CTF_ERR
condition|)
name|dt_node_type_assign
argument_list|(
operator|&
name|idn
argument_list|,
name|idp
operator|->
name|di_ctfp
argument_list|,
name|idp
operator|->
name|di_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|dt_ident_cook
argument_list|(
operator|&
name|idn
argument_list|,
name|idp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|assc
condition|)
block|{
if|if
condition|(
name|class
operator|==
name|DT_DC_THIS
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_LOCASSC
argument_list|,
literal|"associative arrays "
literal|"may not be declared as local variables:"
literal|" %s\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_decl_type
argument_list|(
name|ddp
operator|->
name|dd_next
argument_list|,
operator|&
name|dtt
argument_list|)
operator|!=
literal|0
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idp
operator|!=
name|NULL
operator|&&
operator|(
name|idp
operator|->
name|di_kind
operator|!=
name|idkind
operator|||
name|ctf_type_cmp
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|,
name|idn
operator|.
name|dn_ctfp
argument_list|,
name|idn
operator|.
name|dn_type
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_IDRED
argument_list|,
literal|"identifier redeclared: %s\n"
literal|"\t current: %s %s\n\tprevious: %s %s\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|dt_idkind_name
argument_list|(
name|idkind
argument_list|)
argument_list|,
name|dt_type_name
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dt_idkind_name
argument_list|(
name|idp
operator|->
name|di_kind
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
operator|&
name|idn
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idp
operator|!=
name|NULL
operator|&&
name|assc
condition|)
block|{
specifier|const
name|dt_idsig_t
modifier|*
name|isp
init|=
name|idp
operator|->
name|di_data
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
init|=
name|ddp
operator|->
name|dd_node
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
operator|,
name|argc
operator|++
control|)
block|{
specifier|const
name|dt_node_t
modifier|*
name|pnp
init|=
operator|&
name|isp
operator|->
name|dis_args
index|[
name|argc
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|>=
name|isp
operator|->
name|dis_argc
condition|)
continue|continue;
comment|/* tuple length mismatch */
if|if
condition|(
name|ctf_type_cmp
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|,
name|pnp
operator|->
name|dn_ctfp
argument_list|,
name|pnp
operator|->
name|dn_type
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|xyerror
argument_list|(
name|D_DECL_IDRED
argument_list|,
literal|"identifier redeclared: %s\n"
literal|"\t current: %s, key #%d of type %s\n"
literal|"\tprevious: %s, key #%d of type %s\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|dt_idkind_name
argument_list|(
name|idkind
argument_list|)
argument_list|,
name|argc
operator|+
literal|1
argument_list|,
name|dt_node_type_name
argument_list|(
name|dnp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dt_idkind_name
argument_list|(
name|idp
operator|->
name|di_kind
argument_list|)
argument_list|,
name|argc
operator|+
literal|1
argument_list|,
name|dt_node_type_name
argument_list|(
name|pnp
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|dis_argc
operator|!=
name|argc
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_IDRED
argument_list|,
literal|"identifier redeclared: %s\n"
literal|"\t current: %s of %s, tuple length %d\n"
literal|"\tprevious: %s of %s, tuple length %d\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|dt_idkind_name
argument_list|(
name|idkind
argument_list|)
argument_list|,
name|dt_type_name
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|argc
argument_list|,
name|dt_idkind_name
argument_list|(
name|idp
operator|->
name|di_kind
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
operator|&
name|idn
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|,
name|isp
operator|->
name|dis_argc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|idp
operator|==
name|NULL
condition|)
block|{
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
if|if
condition|(
name|ctf_type_encoding
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|type
argument_list|,
operator|&
name|cte
argument_list|)
operator|==
literal|0
operator|&&
name|IS_VOID
argument_list|(
name|cte
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_VOIDOBJ
argument_list|,
literal|"cannot have "
literal|"void object: %s\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
if|if
condition|(
name|ctf_type_size
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|type
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* proceed to declaring */
comment|/*FALLTHRU*/
case|case
name|CTF_K_FORWARD
case|:
name|xyerror
argument_list|(
name|D_DECL_INCOMPLETE
argument_list|,
literal|"incomplete struct/union/enum %s: %s\n"
argument_list|,
name|dt_type_name
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|dt_idhash_nextid
argument_list|(
name|dhp
argument_list|,
operator|&
name|id
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|xyerror
argument_list|(
name|D_ID_OFLOW
argument_list|,
literal|"cannot create %s: limit "
literal|"on number of %s variables exceeded\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|dt_idhash_name
argument_list|(
name|dhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_dprintf
argument_list|(
literal|"declare %s %s variable %s, id=%u\n"
argument_list|,
name|dt_idhash_name
argument_list|(
name|dhp
argument_list|)
argument_list|,
name|dt_idkind_name
argument_list|(
name|idkind
argument_list|)
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|idp
operator|=
name|dt_idhash_insert
argument_list|(
name|dhp
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|,
name|idkind
argument_list|,
name|idflags
operator||
name|DT_IDFLG_WRITE
operator||
name|DT_IDFLG_DECL
argument_list|,
name|id
argument_list|,
name|_dtrace_defattr
argument_list|,
literal|0
argument_list|,
name|assc
condition|?
operator|&
name|dt_idops_assc
else|:
operator|&
name|dt_idops_thaw
argument_list|,
name|NULL
argument_list|,
name|dtp
operator|->
name|dt_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|dt_ident_type_assign
argument_list|(
name|idp
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
comment|/* 			 * If we are declaring an associative array, use our 			 * fake parse node to cook the new assoc identifier. 			 * This will force the ident code to instantiate the 			 * array type signature corresponding to the list of 			 * types pointed to by ddp->dd_node.  We also reset 			 * the identifier's attributes based upon the result. 			 */
if|if
condition|(
name|assc
condition|)
block|{
name|idp
operator|->
name|di_attr
operator|=
name|dt_ident_cook
argument_list|(
operator|&
name|idn
argument_list|,
name|idp
argument_list|,
operator|&
name|ddp
operator|->
name|dd_node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end of switch */
name|free
argument_list|(
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
name|dsp
operator|->
name|ds_ident
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_func
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_node_t
modifier|*
name|args
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_IDENT
condition|)
block|{
name|xyerror
argument_list|(
name|D_FUNC_IDENT
argument_list|,
literal|"function designator is not of function type\n"
argument_list|)
expr_stmt|;
block|}
name|idp
operator|=
name|dt_idstack_lookup
argument_list|(
operator|&
name|yypcb
operator|->
name|pcb_globals
argument_list|,
name|dnp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|==
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_FUNC_UNDEF
argument_list|,
literal|"undefined function name: %s\n"
argument_list|,
name|dnp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idp
operator|->
name|di_kind
operator|!=
name|DT_IDENT_FUNC
operator|&&
name|idp
operator|->
name|di_kind
operator|!=
name|DT_IDENT_AGGFUNC
operator|&&
name|idp
operator|->
name|di_kind
operator|!=
name|DT_IDENT_ACTFUNC
condition|)
block|{
name|xyerror
argument_list|(
name|D_FUNC_IDKIND
argument_list|,
literal|"%s '%s' may not be referenced as a "
literal|"function\n"
argument_list|,
name|dt_idkind_name
argument_list|(
name|idp
operator|->
name|di_kind
argument_list|)
argument_list|,
name|idp
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dnp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_string
operator|=
name|NULL
expr_stmt|;
name|dnp
operator|->
name|dn_kind
operator|=
name|DT_NODE_FUNC
expr_stmt|;
name|dnp
operator|->
name|dn_flags
operator|&=
operator|~
name|DT_NF_COOKED
expr_stmt|;
name|dnp
operator|->
name|dn_ident
operator|=
name|idp
expr_stmt|;
name|dnp
operator|->
name|dn_args
operator|=
name|args
expr_stmt|;
name|dnp
operator|->
name|dn_list
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The offsetof() function is special because it takes a type name as an  * argument.  It does not actually construct its own node; after looking up the  * structure or union offset, we just return an integer node with the offset.  */
end_comment

begin_function
name|dt_node_t
modifier|*
name|dt_node_offsetof
parameter_list|(
name|dt_decl_t
modifier|*
name|ddp
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
name|dt_node_t
name|dn
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ctf_membinfo_t
name|ctm
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|uint_t
name|kind
decl_stmt|;
name|name
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|err
operator|=
name|dt_decl_type
argument_list|(
name|ddp
argument_list|,
operator|&
name|dtt
argument_list|)
expr_stmt|;
name|dt_decl_free
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|CTF_K_STRUCT
operator|&&
name|kind
operator|!=
name|CTF_K_UNION
condition|)
block|{
name|xyerror
argument_list|(
name|D_OFFSETOF_TYPE
argument_list|,
literal|"offsetof operand must be a struct or union type\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctf_member_info
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
operator|&
name|ctm
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to determine offset of %s: %s\n"
argument_list|,
name|name
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|dn
argument_list|,
sizeof|sizeof
argument_list|(
name|dn
argument_list|)
argument_list|)
expr_stmt|;
name|dt_node_type_assign
argument_list|(
operator|&
name|dn
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|ctm
operator|.
name|ctm_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|.
name|dn_flags
operator|&
name|DT_NF_BITFIELD
condition|)
block|{
name|xyerror
argument_list|(
name|D_OFFSETOF_BITFIELD
argument_list|,
literal|"cannot take offset of a bit-field: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dt_node_int
argument_list|(
name|ctm
operator|.
name|ctm_offset
operator|/
name|NBBY
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_op1
parameter_list|(
name|int
name|op
parameter_list|,
name|dt_node_t
modifier|*
name|cp
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|dn_kind
operator|==
name|DT_NODE_INT
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DT_TOK_INEG
case|:
comment|/* 			 * If we're negating an unsigned integer, zero out any 			 * extra top bits to truncate the value to the size of 			 * the effective type determined by dt_node_int(). 			 */
name|cp
operator|->
name|dn_value
operator|=
operator|-
name|cp
operator|->
name|dn_value
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
condition|)
block|{
name|cp
operator|->
name|dn_value
operator|&=
operator|~
literal|0ULL
operator|>>
operator|(
literal|64
operator|-
name|dt_node_type_size
argument_list|(
name|cp
argument_list|)
operator|*
name|NBBY
operator|)
expr_stmt|;
block|}
comment|/*FALLTHRU*/
case|case
name|DT_TOK_IPOS
case|:
return|return
operator|(
name|cp
operator|)
return|;
case|case
name|DT_TOK_BNEG
case|:
name|cp
operator|->
name|dn_value
operator|=
operator|~
name|cp
operator|->
name|dn_value
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
case|case
name|DT_TOK_LNEG
case|:
name|cp
operator|->
name|dn_value
operator|=
operator|!
name|cp
operator|->
name|dn_value
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
block|}
comment|/* 	 * If sizeof is applied to a type_name or string constant, we can 	 * transform 'cp' into an integer constant in the node construction 	 * pass so that it can then be used for arithmetic in this pass. 	 */
if|if
condition|(
name|op
operator|==
name|DT_TOK_SIZEOF
operator|&&
operator|(
name|cp
operator|->
name|dn_kind
operator|==
name|DT_NODE_STRING
operator|||
name|cp
operator|->
name|dn_kind
operator|==
name|DT_NODE_TYPE
operator|)
condition|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|size_t
name|size
init|=
name|dt_node_type_size
argument_list|(
name|cp
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_SIZEOF_TYPE
argument_list|,
literal|"cannot apply sizeof to an "
literal|"operand of unknown size\n"
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_assign
argument_list|(
name|cp
argument_list|,
name|dtp
operator|->
name|dt_ddefs
operator|->
name|dm_ctfp
argument_list|,
name|ctf_lookup_by_name
argument_list|(
name|dtp
operator|->
name|dt_ddefs
operator|->
name|dm_ctfp
argument_list|,
literal|"size_t"
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|dn_kind
operator|=
name|DT_NODE_INT
expr_stmt|;
name|cp
operator|->
name|dn_op
operator|=
name|DT_TOK_INT
expr_stmt|;
name|cp
operator|->
name|dn_value
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
name|dnp
operator|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_OP1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|op
operator|<=
name|USHRT_MAX
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_op
operator|=
operator|(
name|ushort_t
operator|)
name|op
expr_stmt|;
name|dnp
operator|->
name|dn_child
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If an integer constant is being cast to another integer type, we can  * perform the cast as part of integer constant folding in this pass. We must  * take action when the integer is being cast to a smaller type or if it is  * changing signed-ness. If so, we first shift rp's bits bits high (losing  * excess bits if narrowing) and then shift them down with either a logical  * shift (unsigned) or arithmetic shift (signed).  */
end_comment

begin_function
specifier|static
name|void
name|dt_cast
parameter_list|(
name|dt_node_t
modifier|*
name|lp
parameter_list|,
name|dt_node_t
modifier|*
name|rp
parameter_list|)
block|{
name|size_t
name|srcsize
init|=
name|dt_node_type_size
argument_list|(
name|rp
argument_list|)
decl_stmt|;
name|size_t
name|dstsize
init|=
name|dt_node_type_size
argument_list|(
name|lp
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstsize
operator|<
name|srcsize
condition|)
block|{
name|int
name|n
init|=
operator|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|-
name|dstsize
operator|)
operator|*
name|NBBY
decl_stmt|;
name|rp
operator|->
name|dn_value
operator|<<=
name|n
expr_stmt|;
name|rp
operator|->
name|dn_value
operator|>>=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dstsize
operator|>
name|srcsize
condition|)
block|{
name|int
name|n
init|=
operator|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|-
name|srcsize
operator|)
operator|*
name|NBBY
decl_stmt|;
name|int
name|s
init|=
operator|(
name|dstsize
operator|-
name|srcsize
operator|)
operator|*
name|NBBY
decl_stmt|;
name|rp
operator|->
name|dn_value
operator|<<=
name|n
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
condition|)
block|{
name|rp
operator|->
name|dn_value
operator|=
operator|(
name|intmax_t
operator|)
name|rp
operator|->
name|dn_value
operator|>>
name|s
expr_stmt|;
name|rp
operator|->
name|dn_value
operator|>>=
name|n
operator|-
name|s
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|->
name|dn_value
operator|>>=
name|n
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_op2
parameter_list|(
name|int
name|op
parameter_list|,
name|dt_node_t
modifier|*
name|lp
parameter_list|,
name|dt_node_t
modifier|*
name|rp
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
comment|/* 	 * First we check for operations that are illegal -- namely those that 	 * might result in integer division by zero, and abort if one is found. 	 */
if|if
condition|(
name|rp
operator|->
name|dn_kind
operator|==
name|DT_NODE_INT
operator|&&
name|rp
operator|->
name|dn_value
operator|==
literal|0
operator|&&
operator|(
name|op
operator|==
name|DT_TOK_MOD
operator|||
name|op
operator|==
name|DT_TOK_DIV
operator|||
name|op
operator|==
name|DT_TOK_MOD_EQ
operator|||
name|op
operator|==
name|DT_TOK_DIV_EQ
operator|)
condition|)
name|xyerror
argument_list|(
name|D_DIV_ZERO
argument_list|,
literal|"expression contains division by zero\n"
argument_list|)
expr_stmt|;
comment|/* 	 * If both children are immediate values, we can just perform inline 	 * calculation and return a new immediate node with the result. 	 */
if|if
condition|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_INT
operator|&&
name|rp
operator|->
name|dn_kind
operator|==
name|DT_NODE_INT
condition|)
block|{
name|uintmax_t
name|l
init|=
name|lp
operator|->
name|dn_value
decl_stmt|;
name|uintmax_t
name|r
init|=
name|rp
operator|->
name|dn_value
decl_stmt|;
name|dnp
operator|=
name|dt_node_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* allocate new integer node for result */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DT_TOK_LOR
case|:
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|||
name|r
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_INT_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_INT_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_LXOR
case|:
name|dnp
operator|->
name|dn_value
operator|=
operator|(
name|l
operator|!=
literal|0
operator|)
operator|^
operator|(
name|r
operator|!=
literal|0
operator|)
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_INT_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_INT_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_LAND
case|:
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|&&
name|r
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_INT_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_INT_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_BOR
case|:
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator||
name|r
expr_stmt|;
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_XOR
case|:
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|^
name|r
expr_stmt|;
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_BAND
case|:
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|&
name|r
expr_stmt|;
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_EQU
case|:
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|==
name|r
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_INT_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_INT_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_NEQ
case|:
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|!=
name|r
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_INT_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_INT_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_LT
case|:
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
condition|)
name|dnp
operator|->
name|dn_value
operator|=
operator|(
name|intmax_t
operator|)
name|l
operator|<
operator|(
name|intmax_t
operator|)
name|r
expr_stmt|;
else|else
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|<
name|r
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_INT_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_INT_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_LE
case|:
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
condition|)
name|dnp
operator|->
name|dn_value
operator|=
operator|(
name|intmax_t
operator|)
name|l
operator|<=
operator|(
name|intmax_t
operator|)
name|r
expr_stmt|;
else|else
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|<=
name|r
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_INT_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_INT_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_GT
case|:
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
condition|)
name|dnp
operator|->
name|dn_value
operator|=
operator|(
name|intmax_t
operator|)
name|l
operator|>
operator|(
name|intmax_t
operator|)
name|r
expr_stmt|;
else|else
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|>
name|r
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_INT_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_INT_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_GE
case|:
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
condition|)
name|dnp
operator|->
name|dn_value
operator|=
operator|(
name|intmax_t
operator|)
name|l
operator|>=
operator|(
name|intmax_t
operator|)
name|r
expr_stmt|;
else|else
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|>=
name|r
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_INT_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_INT_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_LSH
case|:
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|<<
name|r
expr_stmt|;
name|dt_node_type_propagate
argument_list|(
name|lp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|rp
argument_list|,
name|dt_attr_min
argument_list|(
name|lp
operator|->
name|dn_attr
argument_list|,
name|rp
operator|->
name|dn_attr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_RSH
case|:
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|>>
name|r
expr_stmt|;
name|dt_node_type_propagate
argument_list|(
name|lp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|rp
argument_list|,
name|dt_attr_min
argument_list|(
name|lp
operator|->
name|dn_attr
argument_list|,
name|rp
operator|->
name|dn_attr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_ADD
case|:
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|+
name|r
expr_stmt|;
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_SUB
case|:
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|-
name|r
expr_stmt|;
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_MUL
case|:
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|*
name|r
expr_stmt|;
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_DIV
case|:
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
condition|)
name|dnp
operator|->
name|dn_value
operator|=
operator|(
name|intmax_t
operator|)
name|l
operator|/
operator|(
name|intmax_t
operator|)
name|r
expr_stmt|;
else|else
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|/
name|r
expr_stmt|;
break|break;
case|case
name|DT_TOK_MOD
case|:
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
condition|)
name|dnp
operator|->
name|dn_value
operator|=
operator|(
name|intmax_t
operator|)
name|l
operator|%
operator|(
name|intmax_t
operator|)
name|r
expr_stmt|;
else|else
name|dnp
operator|->
name|dn_value
operator|=
name|l
operator|%
name|r
expr_stmt|;
break|break;
default|default:
name|dt_node_free
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|dnp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dnp
operator|!=
name|NULL
condition|)
block|{
name|dt_node_free
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|dt_node_free
argument_list|(
name|rp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
block|}
if|if
condition|(
name|op
operator|==
name|DT_TOK_LPAR
operator|&&
name|rp
operator|->
name|dn_kind
operator|==
name|DT_NODE_INT
operator|&&
name|dt_node_is_integer
argument_list|(
name|lp
argument_list|)
condition|)
block|{
name|dt_cast
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|dt_node_type_propagate
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|rp
argument_list|,
name|dt_attr_min
argument_list|(
name|lp
operator|->
name|dn_attr
argument_list|,
name|rp
operator|->
name|dn_attr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_node_free
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rp
operator|)
return|;
block|}
comment|/* 	 * If no immediate optimizations are available, create an new OP2 node 	 * and glue the left and right children into place and return. 	 */
name|dnp
operator|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_OP2
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|op
operator|<=
name|USHRT_MAX
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_op
operator|=
operator|(
name|ushort_t
operator|)
name|op
expr_stmt|;
name|dnp
operator|->
name|dn_left
operator|=
name|lp
expr_stmt|;
name|dnp
operator|->
name|dn_right
operator|=
name|rp
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_op3
parameter_list|(
name|dt_node_t
modifier|*
name|expr
parameter_list|,
name|dt_node_t
modifier|*
name|lp
parameter_list|,
name|dt_node_t
modifier|*
name|rp
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
if|if
condition|(
name|expr
operator|->
name|dn_kind
operator|==
name|DT_NODE_INT
condition|)
return|return
operator|(
name|expr
operator|->
name|dn_value
operator|!=
literal|0
condition|?
name|lp
else|:
name|rp
operator|)
return|;
name|dnp
operator|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_OP3
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_op
operator|=
name|DT_TOK_QUESTION
expr_stmt|;
name|dnp
operator|->
name|dn_expr
operator|=
name|expr
expr_stmt|;
name|dnp
operator|->
name|dn_left
operator|=
name|lp
expr_stmt|;
name|dnp
operator|->
name|dn_right
operator|=
name|rp
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_statement
parameter_list|(
name|dt_node_t
modifier|*
name|expr
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
if|if
condition|(
name|expr
operator|->
name|dn_kind
operator|==
name|DT_NODE_AGG
condition|)
return|return
operator|(
name|expr
operator|)
return|;
if|if
condition|(
name|expr
operator|->
name|dn_kind
operator|==
name|DT_NODE_FUNC
operator|&&
name|expr
operator|->
name|dn_ident
operator|->
name|di_kind
operator|==
name|DT_IDENT_ACTFUNC
condition|)
name|dnp
operator|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_DFUNC
argument_list|)
expr_stmt|;
else|else
name|dnp
operator|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_DEXPR
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_expr
operator|=
name|expr
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_pdesc_by_name
parameter_list|(
name|char
modifier|*
name|spec
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
if|if
condition|(
name|spec
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|dnp
operator|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_PDESC
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_spec
operator|=
name|spec
expr_stmt|;
name|dnp
operator|->
name|dn_desc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_probedesc_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_desc
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_xstr2desc
argument_list|(
name|dtp
argument_list|,
name|yypcb
operator|->
name|pcb_pspec
argument_list|,
name|dnp
operator|->
name|dn_spec
argument_list|,
name|yypcb
operator|->
name|pcb_sargc
argument_list|,
name|yypcb
operator|->
name|pcb_sargv
argument_list|,
name|dnp
operator|->
name|dn_desc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_PDESC_INVAL
argument_list|,
literal|"invalid probe description \"%s\": %s\n"
argument_list|,
name|dnp
operator|->
name|dn_spec
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dnp
operator|->
name|dn_spec
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_spec
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_pdesc_by_id
parameter_list|(
name|uintmax_t
name|id
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|names
index|[]
init|=
block|{
literal|"providers"
block|,
literal|"modules"
block|,
literal|"functions"
block|}
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
init|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_PDESC
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|dnp
operator|->
name|dn_desc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_probedesc_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|>
name|UINT_MAX
condition|)
block|{
name|xyerror
argument_list|(
name|D_PDESC_INVAL
argument_list|,
literal|"identifier %llu exceeds maximum "
literal|"probe id\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yypcb
operator|->
name|pcb_pspec
operator|!=
name|DTRACE_PROBESPEC_NAME
condition|)
block|{
name|xyerror
argument_list|(
name|D_PDESC_INVAL
argument_list|,
literal|"probe identifier %llu not permitted "
literal|"when specifying %s\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|id
argument_list|,
name|names
index|[
name|yypcb
operator|->
name|pcb_pspec
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_id2desc
argument_list|(
name|dtp
argument_list|,
operator|(
name|dtrace_id_t
operator|)
name|id
argument_list|,
name|dnp
operator|->
name|dn_desc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_PDESC_INVAL
argument_list|,
literal|"invalid probe identifier %llu: %s\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|id
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_clause
parameter_list|(
name|dt_node_t
modifier|*
name|pdescs
parameter_list|,
name|dt_node_t
modifier|*
name|pred
parameter_list|,
name|dt_node_t
modifier|*
name|acts
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
init|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_CLAUSE
argument_list|)
decl_stmt|;
name|dnp
operator|->
name|dn_pdescs
operator|=
name|pdescs
expr_stmt|;
name|dnp
operator|->
name|dn_pred
operator|=
name|pred
expr_stmt|;
name|dnp
operator|->
name|dn_acts
operator|=
name|acts
expr_stmt|;
name|yybegin
argument_list|(
name|YYS_CLAUSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_inline
parameter_list|(
name|dt_node_t
modifier|*
name|expr
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_scope_t
modifier|*
name|dsp
init|=
operator|&
name|yypcb
operator|->
name|pcb_dstack
decl_stmt|;
name|dt_decl_t
modifier|*
name|ddp
init|=
name|dt_decl_top
argument_list|()
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|,
modifier|*
name|rdp
decl_stmt|;
name|dt_idnode_t
modifier|*
name|inp
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
if|if
condition|(
name|dt_decl_type
argument_list|(
name|ddp
argument_list|,
operator|&
name|dtt
argument_list|)
operator|!=
literal|0
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsp
operator|->
name|ds_class
operator|!=
name|DT_DC_DEFAULT
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_BADCLASS
argument_list|,
literal|"specified storage class not "
literal|"appropriate for inline declaration\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dsp
operator|->
name|ds_ident
operator|==
name|NULL
condition|)
name|xyerror
argument_list|(
name|D_DECL_USELESS
argument_list|,
literal|"inline declaration requires a name\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_idstack_lookup
argument_list|(
operator|&
name|yypcb
operator|->
name|pcb_globals
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_IDRED
argument_list|,
literal|"identifier redefined: %s\n\t current: "
literal|"inline definition\n\tprevious: %s %s\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|dt_idkind_name
argument_list|(
name|idp
operator|->
name|di_kind
argument_list|)
argument_list|,
operator|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_INLINE
operator|)
condition|?
literal|"inline"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we are declaring an inlined array, verify that we have a tuple 	 * signature, and then recompute 'dtt' as the array's value type. 	 */
if|if
condition|(
name|ddp
operator|->
name|dd_kind
operator|==
name|CTF_K_ARRAY
condition|)
block|{
if|if
condition|(
name|ddp
operator|->
name|dd_node
operator|==
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_ARRNULL
argument_list|,
literal|"inline declaration requires "
literal|"array tuple signature: %s\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ddp
operator|->
name|dd_node
operator|->
name|dn_kind
operator|!=
name|DT_NODE_TYPE
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_ARRNULL
argument_list|,
literal|"inline declaration cannot be "
literal|"of scalar array type: %s\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_decl_type
argument_list|(
name|ddp
operator|->
name|dd_next
argument_list|,
operator|&
name|dtt
argument_list|)
operator|!=
literal|0
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the inline identifier is not defined, then create it with the 	 * orphan flag set.  We do not insert the identifier into dt_globals 	 * until we have successfully cooked the right-hand expression, below. 	 */
name|dnp
operator|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_INLINE
argument_list|)
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|_dtrace_defattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_node_is_void
argument_list|(
name|dnp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_VOIDOBJ
argument_list|,
literal|"cannot declare void inline: %s\n"
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctf_type_kind
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|ctf_type_resolve
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
argument_list|)
operator|==
name|CTF_K_FORWARD
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_INCOMPLETE
argument_list|,
literal|"incomplete struct/union/enum %s: %s\n"
argument_list|,
name|dt_node_type_name
argument_list|(
name|dnp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|,
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_idnode_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|inp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_idnode_t
argument_list|)
argument_list|)
expr_stmt|;
name|idp
operator|=
name|dnp
operator|->
name|dn_ident
operator|=
name|dt_ident_create
argument_list|(
name|dsp
operator|->
name|ds_ident
argument_list|,
name|ddp
operator|->
name|dd_kind
operator|==
name|CTF_K_ARRAY
condition|?
name|DT_IDENT_ARRAY
else|:
name|DT_IDENT_SCALAR
argument_list|,
name|DT_IDFLG_INLINE
operator||
name|DT_IDFLG_REF
operator||
name|DT_IDFLG_DECL
operator||
name|DT_IDFLG_ORPHAN
argument_list|,
literal|0
argument_list|,
name|_dtrace_defattr
argument_list|,
literal|0
argument_list|,
operator|&
name|dt_idops_inline
argument_list|,
name|inp
argument_list|,
name|dtp
operator|->
name|dt_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're inlining an associative array, create a private identifier 	 * hash containing the named parameters and store it in inp->din_hash. 	 * We then push this hash on to the top of the pcb_globals stack. 	 */
if|if
condition|(
name|ddp
operator|->
name|dd_kind
operator|==
name|CTF_K_ARRAY
condition|)
block|{
name|dt_idnode_t
modifier|*
name|pinp
decl_stmt|;
name|dt_ident_t
modifier|*
name|pidp
decl_stmt|;
name|dt_node_t
modifier|*
name|pnp
decl_stmt|;
name|uint_t
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|pnp
operator|=
name|ddp
operator|->
name|dd_node
init|;
name|pnp
operator|!=
name|NULL
condition|;
name|pnp
operator|=
name|pnp
operator|->
name|dn_list
control|)
name|i
operator|++
expr_stmt|;
comment|/* count up parameters for din_argv[] */
name|inp
operator|->
name|din_hash
operator|=
name|dt_idhash_create
argument_list|(
literal|"inline args"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inp
operator|->
name|din_argv
operator|=
name|calloc
argument_list|(
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_ident_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|din_hash
operator|==
name|NULL
operator|||
name|inp
operator|->
name|din_argv
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
comment|/* 		 * Create an identifier for each parameter as a scalar inline, 		 * and store it in din_hash and in position in din_argv[].  The 		 * parameter identifiers also use dt_idops_inline, but we leave 		 * the dt_idnode_t argument 'pinp' zeroed.  This will be filled 		 * in by the code generation pass with references to the args. 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pnp
operator|=
name|ddp
operator|->
name|dd_node
init|;
name|pnp
operator|!=
name|NULL
condition|;
name|pnp
operator|=
name|pnp
operator|->
name|dn_list
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pnp
operator|->
name|dn_string
operator|==
name|NULL
condition|)
continue|continue;
comment|/* ignore anonymous parameters */
if|if
condition|(
operator|(
name|pinp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_idnode_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|pidp
operator|=
name|dt_idhash_insert
argument_list|(
name|inp
operator|->
name|din_hash
argument_list|,
name|pnp
operator|->
name|dn_string
argument_list|,
name|DT_IDENT_SCALAR
argument_list|,
name|DT_IDFLG_DECL
operator||
name|DT_IDFLG_INLINE
argument_list|,
literal|0
argument_list|,
name|_dtrace_defattr
argument_list|,
literal|0
argument_list|,
operator|&
name|dt_idops_inline
argument_list|,
name|pinp
argument_list|,
name|dtp
operator|->
name|dt_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pidp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pinp
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
block|}
name|inp
operator|->
name|din_argv
index|[
name|i
index|]
operator|=
name|pidp
expr_stmt|;
name|bzero
argument_list|(
name|pinp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_idnode_t
argument_list|)
argument_list|)
expr_stmt|;
name|dt_ident_type_assign
argument_list|(
name|pidp
argument_list|,
name|pnp
operator|->
name|dn_ctfp
argument_list|,
name|pnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
block|}
name|dt_idstack_push
argument_list|(
operator|&
name|yypcb
operator|->
name|pcb_globals
argument_list|,
name|inp
operator|->
name|din_hash
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Unlike most constructors, we need to explicitly cook the right-hand 	 * side of the inline definition immediately to prevent recursion.  If 	 * the right-hand side uses the inline itself, the cook will fail. 	 */
name|expr
operator|=
name|dt_node_cook
argument_list|(
name|expr
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddp
operator|->
name|dd_kind
operator|==
name|CTF_K_ARRAY
condition|)
name|dt_idstack_pop
argument_list|(
operator|&
name|yypcb
operator|->
name|pcb_globals
argument_list|,
name|inp
operator|->
name|din_hash
argument_list|)
expr_stmt|;
comment|/* 	 * Set the type, attributes, and flags for the inline.  If the right- 	 * hand expression has an identifier, propagate its flags.  Then cook 	 * the identifier to fully initialize it: if we're declaring an inline 	 * associative array this will construct a type signature from 'ddp'. 	 */
if|if
condition|(
name|dt_node_is_dynamic
argument_list|(
name|expr
argument_list|)
condition|)
name|rdp
operator|=
name|dt_ident_resolve
argument_list|(
name|expr
operator|->
name|dn_ident
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|expr
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
operator|||
name|expr
operator|->
name|dn_kind
operator|==
name|DT_NODE_SYM
condition|)
name|rdp
operator|=
name|expr
operator|->
name|dn_ident
expr_stmt|;
else|else
name|rdp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rdp
operator|!=
name|NULL
condition|)
block|{
name|idp
operator|->
name|di_flags
operator||=
operator|(
name|rdp
operator|->
name|di_flags
operator|&
operator|(
name|DT_IDFLG_WRITE
operator||
name|DT_IDFLG_USER
operator||
name|DT_IDFLG_PRIM
operator|)
operator|)
expr_stmt|;
block|}
name|idp
operator|->
name|di_attr
operator|=
name|dt_attr_min
argument_list|(
name|_dtrace_defattr
argument_list|,
name|expr
operator|->
name|dn_attr
argument_list|)
expr_stmt|;
name|dt_ident_type_assign
argument_list|(
name|idp
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_ident_cook
argument_list|(
name|dnp
argument_list|,
name|idp
argument_list|,
operator|&
name|ddp
operator|->
name|dd_node
argument_list|)
expr_stmt|;
comment|/* 	 * Store the parse tree nodes for 'expr' inside of idp->di_data ('inp') 	 * so that they will be preserved with this identifier.  Then pop the 	 * inline declaration from the declaration stack and restore the lexer. 	 */
name|inp
operator|->
name|din_list
operator|=
name|yypcb
operator|->
name|pcb_list
expr_stmt|;
name|inp
operator|->
name|din_root
operator|=
name|expr
expr_stmt|;
name|dt_decl_free
argument_list|(
name|dt_decl_pop
argument_list|()
argument_list|)
expr_stmt|;
name|yybegin
argument_list|(
name|YYS_CLAUSE
argument_list|)
expr_stmt|;
comment|/* 	 * Finally, insert the inline identifier into dt_globals to make it 	 * visible, and then cook 'dnp' to check its type against 'expr'. 	 */
name|dt_idhash_xinsert
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|,
name|idp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_node_cook
argument_list|(
name|dnp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_member
parameter_list|(
name|dt_decl_t
modifier|*
name|ddp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|dt_node_t
modifier|*
name|expr
parameter_list|)
block|{
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|ddp
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|dt_decl_type
argument_list|(
name|ddp
argument_list|,
operator|&
name|dtt
argument_list|)
expr_stmt|;
name|dt_decl_free
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
block|}
name|dnp
operator|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_MEMBER
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_membname
operator|=
name|name
expr_stmt|;
name|dnp
operator|->
name|dn_membexpr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|ddp
operator|!=
name|NULL
condition|)
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_xlator
parameter_list|(
name|dt_decl_t
modifier|*
name|ddp
parameter_list|,
name|dt_decl_t
modifier|*
name|sdp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|dt_node_t
modifier|*
name|members
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dtrace_typeinfo_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|dt_node_t
name|sn
decl_stmt|,
name|dn
decl_stmt|;
name|dt_xlator_t
modifier|*
name|dxp
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
name|int
name|edst
decl_stmt|,
name|esrc
decl_stmt|;
name|uint_t
name|kind
decl_stmt|;
name|char
name|n1
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|char
name|n2
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|edst
operator|=
name|dt_decl_type
argument_list|(
name|ddp
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|dt_decl_free
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
name|esrc
operator|=
name|dt_decl_type
argument_list|(
name|sdp
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
name|dt_decl_free
argument_list|(
name|sdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|edst
operator|!=
literal|0
operator|||
name|esrc
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|sn
argument_list|,
sizeof|sizeof
argument_list|(
name|sn
argument_list|)
argument_list|)
expr_stmt|;
name|dt_node_type_assign
argument_list|(
operator|&
name|sn
argument_list|,
name|src
operator|.
name|dtt_ctfp
argument_list|,
name|src
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dn
argument_list|,
sizeof|sizeof
argument_list|(
name|dn
argument_list|)
argument_list|)
expr_stmt|;
name|dt_node_type_assign
argument_list|(
operator|&
name|dn
argument_list|,
name|dst
operator|.
name|dtt_ctfp
argument_list|,
name|dst
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_xlator_lookup
argument_list|(
name|dtp
argument_list|,
operator|&
name|sn
argument_list|,
operator|&
name|dn
argument_list|,
name|DT_XLATE_EXACT
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_XLATE_REDECL
argument_list|,
literal|"translator from %s to %s has already been declared\n"
argument_list|,
name|dt_node_type_name
argument_list|(
operator|&
name|sn
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
operator|&
name|dn
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|dst
operator|.
name|dtt_ctfp
argument_list|,
name|ctf_type_resolve
argument_list|(
name|dst
operator|.
name|dtt_ctfp
argument_list|,
name|dst
operator|.
name|dtt_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_FORWARD
condition|)
block|{
name|xyerror
argument_list|(
name|D_XLATE_SOU
argument_list|,
literal|"incomplete struct/union/enum %s\n"
argument_list|,
name|dt_type_name
argument_list|(
name|dst
operator|.
name|dtt_ctfp
argument_list|,
name|dst
operator|.
name|dtt_type
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|!=
name|CTF_K_STRUCT
operator|&&
name|kind
operator|!=
name|CTF_K_UNION
condition|)
block|{
name|xyerror
argument_list|(
name|D_XLATE_SOU
argument_list|,
literal|"translator output type must be a struct or union\n"
argument_list|)
expr_stmt|;
block|}
name|dxp
operator|=
name|dt_xlator_create
argument_list|(
name|dtp
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|name
argument_list|,
name|members
argument_list|,
name|yypcb
operator|->
name|pcb_list
argument_list|)
expr_stmt|;
name|yybegin
argument_list|(
name|YYS_CLAUSE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dxp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|dnp
operator|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_XLATOR
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_xlator
operator|=
name|dxp
expr_stmt|;
name|dnp
operator|->
name|dn_members
operator|=
name|members
expr_stmt|;
return|return
operator|(
name|dt_node_cook
argument_list|(
name|dnp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_probe
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|protoc
parameter_list|,
name|dt_node_t
modifier|*
name|nargs
parameter_list|,
name|dt_node_t
modifier|*
name|xargs
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|int
name|nargc
decl_stmt|,
name|xargc
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|3
decl_stmt|;
comment|/* +3 for :: and \0 */
name|char
modifier|*
name|name
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
literal|"::%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strhyphenate
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'`'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_PROV_BADNAME
argument_list|,
literal|"probe name may not "
literal|"contain scoping operator: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|2
operator|>=
name|DTRACE_NAMELEN
condition|)
block|{
name|xyerror
argument_list|(
name|D_PROV_BADNAME
argument_list|,
literal|"probe name may not exceed %d "
literal|"characters: %s\n"
argument_list|,
name|DTRACE_NAMELEN
operator|-
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|dnp
operator|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_PROBE
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_ident
operator|=
name|dt_ident_create
argument_list|(
name|name
argument_list|,
name|DT_IDENT_PROBE
argument_list|,
name|DT_IDFLG_ORPHAN
argument_list|,
name|DTRACE_IDNONE
argument_list|,
name|_dtrace_defattr
argument_list|,
literal|0
argument_list|,
operator|&
name|dt_idops_probe
argument_list|,
name|NULL
argument_list|,
name|dtp
operator|->
name|dt_gen
argument_list|)
expr_stmt|;
name|nargc
operator|=
name|dt_decl_prototype
argument_list|(
name|nargs
argument_list|,
name|nargs
argument_list|,
literal|"probe input"
argument_list|,
name|DT_DP_VOID
operator||
name|DT_DP_ANON
argument_list|)
expr_stmt|;
name|xargc
operator|=
name|dt_decl_prototype
argument_list|(
name|xargs
argument_list|,
name|nargs
argument_list|,
literal|"probe output"
argument_list|,
name|DT_DP_VOID
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargc
operator|>
name|UINT8_MAX
condition|)
block|{
name|xyerror
argument_list|(
name|D_PROV_PRARGLEN
argument_list|,
literal|"probe %s input prototype exceeds %u "
literal|"parameters: %d params used\n"
argument_list|,
name|name
argument_list|,
name|UINT8_MAX
argument_list|,
name|nargc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xargc
operator|>
name|UINT8_MAX
condition|)
block|{
name|xyerror
argument_list|(
name|D_PROV_PRARGLEN
argument_list|,
literal|"probe %s output prototype exceeds %u "
literal|"parameters: %d params used\n"
argument_list|,
name|name
argument_list|,
name|UINT8_MAX
argument_list|,
name|xargc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dnp
operator|->
name|dn_ident
operator|==
name|NULL
operator|||
name|dt_probe_create
argument_list|(
name|dtp
argument_list|,
name|dnp
operator|->
name|dn_ident
argument_list|,
name|protoc
argument_list|,
name|nargs
argument_list|,
name|nargc
argument_list|,
name|xargs
argument_list|,
name|xargc
argument_list|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_provider
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|dt_node_t
modifier|*
name|probes
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
init|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_PROVIDER
argument_list|)
decl_stmt|;
name|dt_node_t
modifier|*
name|lnp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|dnp
operator|->
name|dn_provname
operator|=
name|name
expr_stmt|;
name|dnp
operator|->
name|dn_probes
operator|=
name|probes
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'`'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_PROV_BADNAME
argument_list|,
literal|"provider name may not "
literal|"contain scoping operator: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|)
operator|>=
name|DTRACE_PROVNAMELEN
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_PROV_BADNAME
argument_list|,
literal|"provider name may not exceed %d "
literal|"characters: %s\n"
argument_list|,
name|DTRACE_PROVNAMELEN
operator|-
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|name
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_PROV_BADNAME
argument_list|,
literal|"provider name may not "
literal|"end with a digit: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check to see if the provider is already defined or visible through 	 * dtrace(7D).  If so, set dn_provred to treat it as a re-declaration. 	 * If not, create a new provider and set its interface-only flag.  This 	 * flag may be cleared later by calls made to dt_probe_declare(). 	 */
if|if
condition|(
operator|(
name|dnp
operator|->
name|dn_provider
operator|=
name|dt_provider_lookup
argument_list|(
name|dtp
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|dnp
operator|->
name|dn_provred
operator|=
name|B_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dnp
operator|->
name|dn_provider
operator|=
name|dt_provider_create
argument_list|(
name|dtp
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
else|else
name|dnp
operator|->
name|dn_provider
operator|->
name|pv_flags
operator||=
name|DT_PROVIDER_INTF
expr_stmt|;
comment|/* 	 * Store all parse nodes created since we consumed the DT_KEY_PROVIDER 	 * token with the provider and then restore our lexing state to CLAUSE. 	 * Note that if dnp->dn_provred is true, we may end up storing dups of 	 * a provider's interface and implementation: we eat this space because 	 * the implementation will likely need to redeclare probe members, and 	 * therefore may result in those member nodes becoming persistent. 	 */
for|for
control|(
name|lnp
operator|=
name|yypcb
operator|->
name|pcb_list
init|;
name|lnp
operator|->
name|dn_link
operator|!=
name|NULL
condition|;
name|lnp
operator|=
name|lnp
operator|->
name|dn_link
control|)
continue|continue;
comment|/* skip to end of allocation list */
name|lnp
operator|->
name|dn_link
operator|=
name|dnp
operator|->
name|dn_provider
operator|->
name|pv_nodes
expr_stmt|;
name|dnp
operator|->
name|dn_provider
operator|->
name|pv_nodes
operator|=
name|yypcb
operator|->
name|pcb_list
expr_stmt|;
name|yybegin
argument_list|(
name|YYS_CLAUSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_program
parameter_list|(
name|dt_node_t
modifier|*
name|lnp
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
init|=
name|dt_node_alloc
argument_list|(
name|DT_NODE_PROG
argument_list|)
decl_stmt|;
name|dnp
operator|->
name|dn_list
operator|=
name|lnp
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function provides the underlying implementation of cooking an  * identifier given its node, a hash of dynamic identifiers, an identifier  * kind, and a boolean flag indicating whether we are allowed to instantiate  * a new identifier if the string is not found.  This function is either  * called from dt_cook_ident(), below, or directly by the various cooking  * routines that are allowed to instantiate identifiers (e.g. op2 TOK_ASGN).  */
end_comment

begin_function
specifier|static
name|void
name|dt_xcook_ident
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
name|uint_t
name|idkind
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
specifier|const
name|char
modifier|*
name|sname
init|=
name|dt_idhash_name
argument_list|(
name|dhp
argument_list|)
decl_stmt|;
name|int
name|uref
init|=
literal|0
decl_stmt|;
name|dtrace_attribute_t
name|attr
init|=
name|_dtrace_defattr
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|dtrace_syminfo_t
name|dts
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|scope
decl_stmt|,
modifier|*
name|mark
decl_stmt|;
name|uchar_t
name|dnkind
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* 	 * Look for scoping marks in the identifier.  If one is found, set our 	 * scope to either DTRACE_OBJ_KMODS or UMODS or to the first part of 	 * the string that specifies the scope using an explicit module name. 	 * If two marks in a row are found, set 'uref' (user symbol reference). 	 * Otherwise we set scope to DTRACE_OBJ_EXEC, indicating that normal 	 * scope is desired and we should search the specified idhash. 	 */
if|if
condition|(
operator|(
name|name
operator|=
name|strrchr
argument_list|(
name|dnp
operator|->
name|dn_string
argument_list|,
literal|'`'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|name
operator|>
name|dnp
operator|->
name|dn_string
operator|&&
name|name
index|[
operator|-
literal|1
index|]
operator|==
literal|'`'
condition|)
block|{
name|uref
operator|++
expr_stmt|;
name|name
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|dnp
operator|->
name|dn_string
operator|+
name|uref
condition|)
name|scope
operator|=
name|uref
condition|?
name|DTRACE_OBJ_UMODS
else|:
name|DTRACE_OBJ_KMODS
expr_stmt|;
else|else
name|scope
operator|=
name|dnp
operator|->
name|dn_string
expr_stmt|;
operator|*
name|name
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* leave name pointing after scoping mark */
name|dnkind
operator|=
name|DT_NODE_VAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idkind
operator|==
name|DT_IDENT_AGG
condition|)
block|{
name|scope
operator|=
name|DTRACE_OBJ_EXEC
expr_stmt|;
name|name
operator|=
name|dnp
operator|->
name|dn_string
operator|+
literal|1
expr_stmt|;
name|dnkind
operator|=
name|DT_NODE_AGG
expr_stmt|;
block|}
else|else
block|{
name|scope
operator|=
name|DTRACE_OBJ_EXEC
expr_stmt|;
name|name
operator|=
name|dnp
operator|->
name|dn_string
expr_stmt|;
name|dnkind
operator|=
name|DT_NODE_VAR
expr_stmt|;
block|}
comment|/* 	 * If create is set to false, and we fail our idhash lookup, preset 	 * the errno code to EDT_NOVAR for our final error message below. 	 * If we end up calling dtrace_lookup_by_name(), it will reset the 	 * errno appropriately and that error will be reported instead. 	 */
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOVAR
argument_list|)
expr_stmt|;
name|mark
operator|=
name|uref
condition|?
literal|"``"
else|:
literal|"`"
expr_stmt|;
if|if
condition|(
name|scope
operator|==
name|DTRACE_OBJ_EXEC
operator|&&
operator|(
operator|(
name|dhp
operator|!=
name|dtp
operator|->
name|dt_globals
operator|&&
operator|(
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|dhp
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|dhp
operator|==
name|dtp
operator|->
name|dt_globals
operator|&&
operator|(
name|idp
operator|=
name|dt_idstack_lookup
argument_list|(
operator|&
name|yypcb
operator|->
name|pcb_globals
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Check that we are referencing the ident in the manner that 		 * matches its type if this is a global lookup.  In the TLS or 		 * local case, we don't know how the ident will be used until 		 * the time operator -> is seen; more parsing is needed. 		 */
if|if
condition|(
name|idp
operator|->
name|di_kind
operator|!=
name|idkind
operator|&&
name|dhp
operator|==
name|dtp
operator|->
name|dt_globals
condition|)
block|{
name|xyerror
argument_list|(
name|D_IDENT_BADREF
argument_list|,
literal|"%s '%s' may not be referenced "
literal|"as %s\n"
argument_list|,
name|dt_idkind_name
argument_list|(
name|idp
operator|->
name|di_kind
argument_list|)
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|dt_idkind_name
argument_list|(
name|idkind
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Arrays and aggregations are not cooked individually. They 		 * have dynamic types and must be referenced using operator []. 		 * This is handled explicitly by the code for DT_TOK_LBRAC. 		 */
if|if
condition|(
name|idp
operator|->
name|di_kind
operator|!=
name|DT_IDENT_ARRAY
operator|&&
name|idp
operator|->
name|di_kind
operator|!=
name|DT_IDENT_AGG
condition|)
name|attr
operator|=
name|dt_ident_cook
argument_list|(
name|dnp
argument_list|,
name|idp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_DYN_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_DYN_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|=
name|idp
operator|->
name|di_attr
expr_stmt|;
block|}
name|free
argument_list|(
name|dnp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_string
operator|=
name|NULL
expr_stmt|;
name|dnp
operator|->
name|dn_kind
operator|=
name|dnkind
expr_stmt|;
name|dnp
operator|->
name|dn_ident
operator|=
name|idp
expr_stmt|;
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_LVALUE
expr_stmt|;
if|if
condition|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_WRITE
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_WRITABLE
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dhp
operator|==
name|dtp
operator|->
name|dt_globals
operator|&&
name|scope
operator|!=
name|DTRACE_OBJ_EXEC
operator|&&
name|dtrace_lookup_by_name
argument_list|(
name|dtp
argument_list|,
name|scope
argument_list|,
name|name
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|dts
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dt_module_t
modifier|*
name|mp
init|=
name|dt_module_lookup_by_name
argument_list|(
name|dtp
argument_list|,
name|dts
operator|.
name|dts_object
argument_list|)
decl_stmt|;
name|int
name|umod
init|=
operator|(
name|mp
operator|->
name|dm_flags
operator|&
name|DT_DM_KERNEL
operator|)
operator|==
literal|0
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|kunames
index|[]
init|=
block|{
literal|"kernel"
block|,
literal|"user"
block|}
decl_stmt|;
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
name|dtrace_syminfo_t
modifier|*
name|sip
decl_stmt|;
if|if
condition|(
name|uref
operator|^
name|umod
condition|)
block|{
name|xyerror
argument_list|(
name|D_SYM_BADREF
argument_list|,
literal|"%s module '%s' symbol '%s' may "
literal|"not be referenced as a %s symbol\n"
argument_list|,
name|kunames
index|[
name|umod
index|]
argument_list|,
name|dts
operator|.
name|dts_object
argument_list|,
name|dts
operator|.
name|dts_name
argument_list|,
name|kunames
index|[
name|uref
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_symbol_type
argument_list|(
name|dtp
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|dts
argument_list|,
operator|&
name|dtt
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * For now, we special-case EDT_DATAMODEL to clarify 			 * that mixed data models are not currently supported. 			 */
if|if
condition|(
name|dtp
operator|->
name|dt_errno
operator|==
name|EDT_DATAMODEL
condition|)
block|{
name|xyerror
argument_list|(
name|D_SYM_MODEL
argument_list|,
literal|"cannot use %s symbol "
literal|"%s%s%s in a %s D program\n"
argument_list|,
name|dt_module_modelname
argument_list|(
name|mp
argument_list|)
argument_list|,
name|dts
operator|.
name|dts_object
argument_list|,
name|mark
argument_list|,
name|dts
operator|.
name|dts_name
argument_list|,
name|dt_module_modelname
argument_list|(
name|dtp
operator|->
name|dt_ddefs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xyerror
argument_list|(
name|D_SYM_NOTYPES
argument_list|,
literal|"no symbolic type information is available for "
literal|"%s%s%s: %s\n"
argument_list|,
name|dts
operator|.
name|dts_object
argument_list|,
name|mark
argument_list|,
name|dts
operator|.
name|dts_name
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|idp
operator|=
name|dt_ident_create
argument_list|(
name|name
argument_list|,
name|DT_IDENT_SYMBOL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|_dtrace_symattr
argument_list|,
literal|0
argument_list|,
operator|&
name|dt_idops_thaw
argument_list|,
name|NULL
argument_list|,
name|dtp
operator|->
name|dt_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|dm_flags
operator|&
name|DT_DM_PRIMARY
condition|)
name|idp
operator|->
name|di_flags
operator||=
name|DT_IDFLG_PRIM
expr_stmt|;
name|idp
operator|->
name|di_next
operator|=
name|dtp
operator|->
name|dt_externs
expr_stmt|;
name|dtp
operator|->
name|dt_externs
operator|=
name|idp
expr_stmt|;
if|if
condition|(
operator|(
name|sip
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_syminfo_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dts
argument_list|,
name|sip
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_syminfo_t
argument_list|)
argument_list|)
expr_stmt|;
name|idp
operator|->
name|di_data
operator|=
name|sip
expr_stmt|;
name|idp
operator|->
name|di_ctfp
operator|=
name|dtt
operator|.
name|dtt_ctfp
expr_stmt|;
name|idp
operator|->
name|di_type
operator|=
name|dtt
operator|.
name|dtt_type
expr_stmt|;
name|free
argument_list|(
name|dnp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_string
operator|=
name|NULL
expr_stmt|;
name|dnp
operator|->
name|dn_kind
operator|=
name|DT_NODE_SYM
expr_stmt|;
name|dnp
operator|->
name|dn_ident
operator|=
name|idp
expr_stmt|;
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_LVALUE
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|_dtrace_symattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|uref
condition|)
block|{
name|idp
operator|->
name|di_flags
operator||=
name|DT_IDFLG_USER
expr_stmt|;
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_USERLAND
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|scope
operator|==
name|DTRACE_OBJ_EXEC
operator|&&
name|create
operator|==
name|B_TRUE
condition|)
block|{
name|uint_t
name|flags
init|=
name|DT_IDFLG_WRITE
decl_stmt|;
name|uint_t
name|id
decl_stmt|;
if|if
condition|(
name|dt_idhash_nextid
argument_list|(
name|dhp
argument_list|,
operator|&
name|id
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|xyerror
argument_list|(
name|D_ID_OFLOW
argument_list|,
literal|"cannot create %s: limit on number "
literal|"of %s variables exceeded\n"
argument_list|,
name|name
argument_list|,
name|sname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dhp
operator|==
name|yypcb
operator|->
name|pcb_locals
condition|)
name|flags
operator||=
name|DT_IDFLG_LOCAL
expr_stmt|;
elseif|else
if|if
condition|(
name|dhp
operator|==
name|dtp
operator|->
name|dt_tls
condition|)
name|flags
operator||=
name|DT_IDFLG_TLS
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"create %s %s variable %s, id=%u\n"
argument_list|,
name|sname
argument_list|,
name|dt_idkind_name
argument_list|(
name|idkind
argument_list|)
argument_list|,
name|name
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|idkind
operator|==
name|DT_IDENT_ARRAY
operator|||
name|idkind
operator|==
name|DT_IDENT_AGG
condition|)
block|{
name|idp
operator|=
name|dt_idhash_insert
argument_list|(
name|dhp
argument_list|,
name|name
argument_list|,
name|idkind
argument_list|,
name|flags
argument_list|,
name|id
argument_list|,
name|_dtrace_defattr
argument_list|,
literal|0
argument_list|,
operator|&
name|dt_idops_assc
argument_list|,
name|NULL
argument_list|,
name|dtp
operator|->
name|dt_gen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idp
operator|=
name|dt_idhash_insert
argument_list|(
name|dhp
argument_list|,
name|name
argument_list|,
name|idkind
argument_list|,
name|flags
argument_list|,
name|id
argument_list|,
name|_dtrace_defattr
argument_list|,
literal|0
argument_list|,
operator|&
name|dt_idops_thaw
argument_list|,
name|NULL
argument_list|,
name|dtp
operator|->
name|dt_gen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
comment|/* 		 * Arrays and aggregations are not cooked individually. They 		 * have dynamic types and must be referenced using operator []. 		 * This is handled explicitly by the code for DT_TOK_LBRAC. 		 */
if|if
condition|(
name|idp
operator|->
name|di_kind
operator|!=
name|DT_IDENT_ARRAY
operator|&&
name|idp
operator|->
name|di_kind
operator|!=
name|DT_IDENT_AGG
condition|)
name|attr
operator|=
name|dt_ident_cook
argument_list|(
name|dnp
argument_list|,
name|idp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_DYN_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_DYN_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|=
name|idp
operator|->
name|di_attr
expr_stmt|;
block|}
name|free
argument_list|(
name|dnp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_string
operator|=
name|NULL
expr_stmt|;
name|dnp
operator|->
name|dn_kind
operator|=
name|dnkind
expr_stmt|;
name|dnp
operator|->
name|dn_ident
operator|=
name|idp
expr_stmt|;
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_LVALUE
operator||
name|DT_NF_WRITABLE
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scope
operator|!=
name|DTRACE_OBJ_EXEC
condition|)
block|{
name|xyerror
argument_list|(
name|D_IDENT_UNDEF
argument_list|,
literal|"failed to resolve %s%s%s: %s\n"
argument_list|,
name|dnp
operator|->
name|dn_string
argument_list|,
name|mark
argument_list|,
name|name
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xyerror
argument_list|(
name|D_IDENT_UNDEF
argument_list|,
literal|"failed to resolve %s: %s\n"
argument_list|,
name|dnp
operator|->
name|dn_string
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_cook_ident
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_AGG
condition|)
name|dt_xcook_ident
argument_list|(
name|dnp
argument_list|,
name|dtp
operator|->
name|dt_aggs
argument_list|,
name|DT_IDENT_AGG
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
else|else
name|dt_xcook_ident
argument_list|(
name|dnp
argument_list|,
name|dtp
operator|->
name|dt_globals
argument_list|,
name|DT_IDENT_SCALAR
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_node_cook
argument_list|(
name|dnp
argument_list|,
name|idflags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Since operators [ and -> can instantiate new variables before we know  * whether the reference is for a read or a write, we need to check read  * references to determine if the identifier is currently dt_ident_unref().  * If so, we report that this first access was to an undefined variable.  */
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_cook_var
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|idp
init|=
name|dnp
operator|->
name|dn_ident
decl_stmt|;
if|if
condition|(
operator|(
name|idflags
operator|&
name|DT_IDFLG_REF
operator|)
operator|&&
name|dt_ident_unref
argument_list|(
name|idp
argument_list|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_VAR_UNDEF
argument_list|,
literal|"%s%s has not yet been declared or assigned\n"
argument_list|,
operator|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_LOCAL
operator|)
condition|?
literal|"this->"
else|:
operator|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_TLS
operator|)
condition|?
literal|"self->"
else|:
literal|""
argument_list|,
name|idp
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_ident_cook
argument_list|(
name|dnp
argument_list|,
name|idp
argument_list|,
operator|&
name|dnp
operator|->
name|dn_args
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_cook_func
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_ident_cook
argument_list|(
name|dnp
argument_list|,
name|dnp
operator|->
name|dn_ident
argument_list|,
operator|&
name|dnp
operator|->
name|dn_args
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_cook_op1
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_node_t
modifier|*
name|cp
init|=
name|dnp
operator|->
name|dn_child
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|ctf_arinfo_t
name|r
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|,
name|base
decl_stmt|;
name|uint_t
name|kind
decl_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_PREINC
operator|||
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_POSTINC
operator|||
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_PREDEC
operator|||
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_POSTDEC
condition|)
name|idflags
operator|=
name|DT_IDFLG_REF
operator||
name|DT_IDFLG_MOD
expr_stmt|;
else|else
name|idflags
operator|=
name|DT_IDFLG_REF
expr_stmt|;
comment|/* 	 * We allow the unary ++ and -- operators to instantiate new scalar 	 * variables if applied to an identifier; otherwise just cook as usual. 	 */
if|if
condition|(
name|cp
operator|->
name|dn_kind
operator|==
name|DT_NODE_IDENT
operator|&&
operator|(
name|idflags
operator|&
name|DT_IDFLG_MOD
operator|)
condition|)
name|dt_xcook_ident
argument_list|(
name|cp
argument_list|,
name|dtp
operator|->
name|dt_globals
argument_list|,
name|DT_IDENT_SCALAR
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|cp
operator|=
name|dnp
operator|->
name|dn_child
operator|=
name|dt_node_cook
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* don't set idflags yet */
if|if
condition|(
name|cp
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
operator|&&
name|dt_ident_unref
argument_list|(
name|cp
operator|->
name|dn_ident
argument_list|)
condition|)
block|{
if|if
condition|(
name|dt_type_lookup
argument_list|(
literal|"int64_t"
argument_list|,
operator|&
name|dtt
argument_list|)
operator|!=
literal|0
condition|)
name|xyerror
argument_list|(
name|D_TYPE_ERR
argument_list|,
literal|"failed to lookup int64_t\n"
argument_list|)
expr_stmt|;
name|dt_ident_type_assign
argument_list|(
name|cp
operator|->
name|dn_ident
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|cp
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
condition|)
name|cp
operator|->
name|dn_ident
operator|->
name|di_flags
operator||=
name|idflags
expr_stmt|;
switch|switch
condition|(
name|dnp
operator|->
name|dn_op
condition|)
block|{
case|case
name|DT_TOK_DEREF
case|:
comment|/* 		 * If the deref operator is applied to a translated pointer, 		 * we set our output type to the output of the translation. 		 */
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_node_resolve
argument_list|(
name|cp
argument_list|,
name|DT_IDENT_XLPTR
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dt_xlator_t
modifier|*
name|dxp
init|=
name|idp
operator|->
name|di_data
decl_stmt|;
name|dnp
operator|->
name|dn_ident
operator|=
operator|&
name|dxp
operator|->
name|dx_souid
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_ctfp
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|cp
operator|->
name|dn_ctfp
argument_list|,
name|cp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|cp
operator|->
name|dn_ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_ARRAY
condition|)
block|{
if|if
condition|(
name|ctf_array_info
argument_list|(
name|cp
operator|->
name|dn_ctfp
argument_list|,
name|type
argument_list|,
operator|&
name|r
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dtp
operator|->
name|dt_ctferr
operator|=
name|ctf_errno
argument_list|(
name|cp
operator|->
name|dn_ctfp
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_CTF
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|r
operator|.
name|ctr_contents
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
name|CTF_K_POINTER
condition|)
block|{
name|type
operator|=
name|ctf_type_reference
argument_list|(
name|cp
operator|->
name|dn_ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xyerror
argument_list|(
name|D_DEREF_NONPTR
argument_list|,
literal|"cannot dereference non-pointer type\n"
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|cp
operator|->
name|dn_ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|base
operator|=
name|ctf_type_resolve
argument_list|(
name|cp
operator|->
name|dn_ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|cp
operator|->
name|dn_ctfp
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_INTEGER
operator|&&
name|ctf_type_encoding
argument_list|(
name|cp
operator|->
name|dn_ctfp
argument_list|,
name|base
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
operator|&&
name|IS_VOID
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_DEREF_VOID
argument_list|,
literal|"cannot dereference pointer to void\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|==
name|CTF_K_FUNCTION
condition|)
block|{
name|xyerror
argument_list|(
name|D_DEREF_FUNC
argument_list|,
literal|"cannot dereference pointer to function\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|!=
name|CTF_K_ARRAY
operator|||
name|dt_node_is_string
argument_list|(
name|dnp
argument_list|)
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_LVALUE
expr_stmt|;
comment|/* see K&R[A7.4.3] */
comment|/* 		 * If we propagated the l-value bit and the child operand was 		 * a writable D variable or a binary operation of the form 		 * a + b where a is writable, then propagate the writable bit. 		 * This is necessary to permit assignments to scalar arrays, 		 * which are converted to expressions of the form *(a + i). 		 */
if|if
condition|(
operator|(
name|cp
operator|->
name|dn_flags
operator|&
name|DT_NF_WRITABLE
operator|)
operator|||
operator|(
name|cp
operator|->
name|dn_kind
operator|==
name|DT_NODE_OP2
operator|&&
name|cp
operator|->
name|dn_op
operator|==
name|DT_TOK_ADD
operator|&&
operator|(
name|cp
operator|->
name|dn_left
operator|->
name|dn_flags
operator|&
name|DT_NF_WRITABLE
operator|)
operator|)
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_WRITABLE
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
operator|)
operator|&&
operator|(
name|kind
operator|==
name|CTF_K_POINTER
operator|||
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_REF
operator|)
operator|)
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_USERLAND
expr_stmt|;
break|break;
case|case
name|DT_TOK_IPOS
case|:
case|case
name|DT_TOK_INEG
case|:
if|if
condition|(
operator|!
name|dt_node_is_arith
argument_list|(
name|cp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_ARITH
argument_list|,
literal|"operator %s requires an operand "
literal|"of arithmetic type\n"
argument_list|,
name|opstr
argument_list|(
name|dnp
operator|->
name|dn_op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_propagate
argument_list|(
name|cp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
comment|/* see K&R[A7.4.4-6] */
break|break;
case|case
name|DT_TOK_BNEG
case|:
if|if
condition|(
operator|!
name|dt_node_is_integer
argument_list|(
name|cp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_INT
argument_list|,
literal|"operator %s requires an operand of "
literal|"integral type\n"
argument_list|,
name|opstr
argument_list|(
name|dnp
operator|->
name|dn_op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_propagate
argument_list|(
name|cp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
comment|/* see K&R[A7.4.4-6] */
break|break;
case|case
name|DT_TOK_LNEG
case|:
if|if
condition|(
operator|!
name|dt_node_is_scalar
argument_list|(
name|cp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_SCALAR
argument_list|,
literal|"operator %s requires an operand "
literal|"of scalar type\n"
argument_list|,
name|opstr
argument_list|(
name|dnp
operator|->
name|dn_op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_INT_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_INT_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_ADDROF
case|:
if|if
condition|(
name|cp
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
operator|||
name|cp
operator|->
name|dn_kind
operator|==
name|DT_NODE_AGG
condition|)
block|{
name|xyerror
argument_list|(
name|D_ADDROF_VAR
argument_list|,
literal|"cannot take address of dynamic variable\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_node_is_dynamic
argument_list|(
name|cp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_ADDROF_VAR
argument_list|,
literal|"cannot take address of dynamic object\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|cp
operator|->
name|dn_flags
operator|&
name|DT_NF_LVALUE
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_ADDROF_LVAL
argument_list|,
comment|/* see K&R[A7.4.2] */
literal|"unacceptable operand for unary& operator\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|dn_flags
operator|&
name|DT_NF_BITFIELD
condition|)
block|{
name|xyerror
argument_list|(
name|D_ADDROF_BITFIELD
argument_list|,
literal|"cannot take address of bit-field\n"
argument_list|)
expr_stmt|;
block|}
name|dtt
operator|.
name|dtt_object
operator|=
name|NULL
expr_stmt|;
name|dtt
operator|.
name|dtt_ctfp
operator|=
name|cp
operator|->
name|dn_ctfp
expr_stmt|;
name|dtt
operator|.
name|dtt_type
operator|=
name|cp
operator|->
name|dn_type
expr_stmt|;
if|if
condition|(
name|dt_type_pointer
argument_list|(
operator|&
name|dtt
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|xyerror
argument_list|(
name|D_TYPE_ERR
argument_list|,
literal|"cannot find type for \"&\": %s*\n"
argument_list|,
name|dt_node_type_name
argument_list|(
name|cp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_USERLAND
expr_stmt|;
break|break;
case|case
name|DT_TOK_SIZEOF
case|:
if|if
condition|(
name|cp
operator|->
name|dn_flags
operator|&
name|DT_NF_BITFIELD
condition|)
block|{
name|xyerror
argument_list|(
name|D_SIZEOF_BITFIELD
argument_list|,
literal|"cannot apply sizeof to a bit-field\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_node_sizeof
argument_list|(
name|cp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_SIZEOF_TYPE
argument_list|,
literal|"cannot apply sizeof to an "
literal|"operand of unknown size\n"
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|dtp
operator|->
name|dt_ddefs
operator|->
name|dm_ctfp
argument_list|,
name|ctf_lookup_by_name
argument_list|(
name|dtp
operator|->
name|dt_ddefs
operator|->
name|dm_ctfp
argument_list|,
literal|"size_t"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_STRINGOF
case|:
if|if
condition|(
operator|!
name|dt_node_is_scalar
argument_list|(
name|cp
argument_list|)
operator|&&
operator|!
name|dt_node_is_pointer
argument_list|(
name|cp
argument_list|)
operator|&&
operator|!
name|dt_node_is_strcompat
argument_list|(
name|cp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_STRINGOF_TYPE
argument_list|,
literal|"cannot apply stringof to a value of type %s\n"
argument_list|,
name|dt_node_type_name
argument_list|(
name|cp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_STR_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_STR_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_PREINC
case|:
case|case
name|DT_TOK_POSTINC
case|:
case|case
name|DT_TOK_PREDEC
case|:
case|case
name|DT_TOK_POSTDEC
case|:
if|if
condition|(
name|dt_node_is_scalar
argument_list|(
name|cp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_SCALAR
argument_list|,
literal|"operator %s requires operand of "
literal|"scalar type\n"
argument_list|,
name|opstr
argument_list|(
name|dnp
operator|->
name|dn_op
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_node_is_vfptr
argument_list|(
name|cp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_VFPTR
argument_list|,
literal|"operator %s requires an operand "
literal|"of known size\n"
argument_list|,
name|opstr
argument_list|(
name|dnp
operator|->
name|dn_op
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|cp
operator|->
name|dn_flags
operator|&
name|DT_NF_LVALUE
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_LVAL
argument_list|,
literal|"operator %s requires modifiable "
literal|"lvalue as an operand\n"
argument_list|,
name|opstr
argument_list|(
name|dnp
operator|->
name|dn_op
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|cp
operator|->
name|dn_flags
operator|&
name|DT_NF_WRITABLE
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_WRITE
argument_list|,
literal|"operator %s can only be applied "
literal|"to a writable variable\n"
argument_list|,
name|opstr
argument_list|(
name|dnp
operator|->
name|dn_op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_propagate
argument_list|(
name|cp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
comment|/* see K&R[A7.4.1] */
break|break;
default|default:
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"invalid unary op %s\n"
argument_list|,
name|opstr
argument_list|(
name|dnp
operator|->
name|dn_op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|cp
operator|->
name|dn_attr
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_assign_common
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|lp
init|=
name|dnp
operator|->
name|dn_left
decl_stmt|;
name|dt_node_t
modifier|*
name|rp
init|=
name|dnp
operator|->
name|dn_right
decl_stmt|;
name|int
name|op
init|=
name|dnp
operator|->
name|dn_op
decl_stmt|;
if|if
condition|(
name|rp
operator|->
name|dn_kind
operator|==
name|DT_NODE_INT
condition|)
name|dt_cast
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lp
operator|->
name|dn_flags
operator|&
name|DT_NF_LVALUE
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_LVAL
argument_list|,
literal|"operator %s requires modifiable "
literal|"lvalue as an operand\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
comment|/* see K&R[A7.17] */
block|}
if|if
condition|(
operator|!
operator|(
name|lp
operator|->
name|dn_flags
operator|&
name|DT_NF_WRITABLE
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_WRITE
argument_list|,
literal|"operator %s can only be applied "
literal|"to a writable variable\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_propagate
argument_list|(
name|lp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
comment|/* see K&R[A7.17] */
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_attr_min
argument_list|(
name|lp
operator|->
name|dn_attr
argument_list|,
name|rp
operator|->
name|dn_attr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_cook_op2
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_node_t
modifier|*
name|lp
init|=
name|dnp
operator|->
name|dn_left
decl_stmt|;
name|dt_node_t
modifier|*
name|rp
init|=
name|dnp
operator|->
name|dn_right
decl_stmt|;
name|int
name|op
init|=
name|dnp
operator|->
name|dn_op
decl_stmt|;
name|ctf_membinfo_t
name|m
decl_stmt|;
name|ctf_file_t
modifier|*
name|ctfp
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|int
name|kind
decl_stmt|,
name|val
decl_stmt|,
name|uref
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|char
name|n1
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|char
name|n2
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
comment|/* 	 * The expression E1[E2] is identical by definition to *((E1)+(E2)) so 	 * we convert "[" to "+" and glue on "*" at the end (see K&R[A7.3.1]) 	 * unless the left-hand side is an untyped D scalar, associative array, 	 * or aggregation.  In these cases, we proceed to case DT_TOK_LBRAC and 	 * handle associative array and aggregation references there. 	 */
if|if
condition|(
name|op
operator|==
name|DT_TOK_LBRAC
condition|)
block|{
if|if
condition|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_IDENT
condition|)
block|{
name|dt_idhash_t
modifier|*
name|dhp
decl_stmt|;
name|uint_t
name|idkind
decl_stmt|;
if|if
condition|(
name|lp
operator|->
name|dn_op
operator|==
name|DT_TOK_AGG
condition|)
block|{
name|dhp
operator|=
name|dtp
operator|->
name|dt_aggs
expr_stmt|;
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|dhp
argument_list|,
name|lp
operator|->
name|dn_string
operator|+
literal|1
argument_list|)
expr_stmt|;
name|idkind
operator|=
name|DT_IDENT_AGG
expr_stmt|;
block|}
else|else
block|{
name|dhp
operator|=
name|dtp
operator|->
name|dt_globals
expr_stmt|;
name|idp
operator|=
name|dt_idstack_lookup
argument_list|(
operator|&
name|yypcb
operator|->
name|pcb_globals
argument_list|,
name|lp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
name|idkind
operator|=
name|DT_IDENT_ARRAY
expr_stmt|;
block|}
if|if
condition|(
name|idp
operator|==
name|NULL
operator|||
name|dt_ident_unref
argument_list|(
name|idp
argument_list|)
condition|)
name|dt_xcook_ident
argument_list|(
name|lp
argument_list|,
name|dhp
argument_list|,
name|idkind
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
else|else
name|dt_xcook_ident
argument_list|(
name|lp
argument_list|,
name|dhp
argument_list|,
name|idp
operator|->
name|di_kind
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Switch op to '+' for *(E1 + E2) array mode in these cases: 		 * (a) lp is a DT_IDENT_ARRAY variable that has already been 		 *	referenced using [] notation (dn_args != NULL). 		 * (b) lp is a non-ARRAY variable that has already been given 		 *	a type by assignment or declaration (!dt_ident_unref()) 		 * (c) lp is neither a variable nor an aggregation 		 */
if|if
condition|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
condition|)
block|{
if|if
condition|(
name|lp
operator|->
name|dn_ident
operator|->
name|di_kind
operator|==
name|DT_IDENT_ARRAY
condition|)
block|{
if|if
condition|(
name|lp
operator|->
name|dn_args
operator|!=
name|NULL
condition|)
name|op
operator|=
name|DT_TOK_ADD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|dt_ident_unref
argument_list|(
name|lp
operator|->
name|dn_ident
argument_list|)
condition|)
name|op
operator|=
name|DT_TOK_ADD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_AGG
condition|)
name|op
operator|=
name|DT_TOK_ADD
expr_stmt|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DT_TOK_BAND
case|:
case|case
name|DT_TOK_XOR
case|:
case|case
name|DT_TOK_BOR
case|:
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dt_node_is_integer
argument_list|(
name|lp
argument_list|)
operator|||
operator|!
name|dt_node_is_integer
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_INT
argument_list|,
literal|"operator %s requires operands of "
literal|"integral type\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
comment|/* see K&R[A7.11-13] */
break|break;
case|case
name|DT_TOK_LSH
case|:
case|case
name|DT_TOK_RSH
case|:
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dt_node_is_integer
argument_list|(
name|lp
argument_list|)
operator|||
operator|!
name|dt_node_is_integer
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_INT
argument_list|,
literal|"operator %s requires operands of "
literal|"integral type\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_propagate
argument_list|(
name|lp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
comment|/* see K&R[A7.8] */
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_attr_min
argument_list|(
name|lp
operator|->
name|dn_attr
argument_list|,
name|rp
operator|->
name|dn_attr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_MOD
case|:
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dt_node_is_integer
argument_list|(
name|lp
argument_list|)
operator|||
operator|!
name|dt_node_is_integer
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_INT
argument_list|,
literal|"operator %s requires operands of "
literal|"integral type\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
comment|/* see K&R[A7.6] */
break|break;
case|case
name|DT_TOK_MUL
case|:
case|case
name|DT_TOK_DIV
case|:
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dt_node_is_arith
argument_list|(
name|lp
argument_list|)
operator|||
operator|!
name|dt_node_is_arith
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_ARITH
argument_list|,
literal|"operator %s requires operands of "
literal|"arithmetic type\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
comment|/* see K&R[A7.6] */
break|break;
case|case
name|DT_TOK_LAND
case|:
case|case
name|DT_TOK_LXOR
case|:
case|case
name|DT_TOK_LOR
case|:
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dt_node_is_scalar
argument_list|(
name|lp
argument_list|)
operator|||
operator|!
name|dt_node_is_scalar
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_SCALAR
argument_list|,
literal|"operator %s requires operands "
literal|"of scalar type\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_INT_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_INT_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_attr_min
argument_list|(
name|lp
operator|->
name|dn_attr
argument_list|,
name|rp
operator|->
name|dn_attr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_LT
case|:
case|case
name|DT_TOK_LE
case|:
case|case
name|DT_TOK_GT
case|:
case|case
name|DT_TOK_GE
case|:
case|case
name|DT_TOK_EQU
case|:
case|case
name|DT_TOK_NEQ
case|:
comment|/* 		 * The D comparison operators provide the ability to transform 		 * a right-hand identifier into a corresponding enum tag value 		 * if the left-hand side is an enum type.  To do this, we cook 		 * the left-hand side, and then see if the right-hand side is 		 * an unscoped identifier defined in the enum.  If so, we 		 * convert into an integer constant node with the tag's value. 		 */
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|lp
operator|->
name|dn_ctfp
argument_list|,
name|ctf_type_resolve
argument_list|(
name|lp
operator|->
name|dn_ctfp
argument_list|,
name|lp
operator|->
name|dn_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_ENUM
operator|&&
name|rp
operator|->
name|dn_kind
operator|==
name|DT_NODE_IDENT
operator|&&
name|strchr
argument_list|(
name|rp
operator|->
name|dn_string
argument_list|,
literal|'`'
argument_list|)
operator|==
name|NULL
operator|&&
name|ctf_enum_value
argument_list|(
name|lp
operator|->
name|dn_ctfp
argument_list|,
name|lp
operator|->
name|dn_type
argument_list|,
name|rp
operator|->
name|dn_string
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_idstack_lookup
argument_list|(
operator|&
name|yypcb
operator|->
name|pcb_globals
argument_list|,
name|rp
operator|->
name|dn_string
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_IDENT_AMBIG
argument_list|,
literal|"ambiguous use of operator %s: %s is "
literal|"both a %s enum tag and a global %s\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|,
name|rp
operator|->
name|dn_string
argument_list|,
name|dt_node_type_name
argument_list|(
name|lp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dt_idkind_name
argument_list|(
name|idp
operator|->
name|di_kind
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
name|rp
operator|->
name|dn_string
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|dn_kind
operator|=
name|DT_NODE_INT
expr_stmt|;
name|rp
operator|->
name|dn_flags
operator||=
name|DT_NF_COOKED
expr_stmt|;
name|rp
operator|->
name|dn_op
operator|=
name|DT_TOK_INT
expr_stmt|;
name|rp
operator|->
name|dn_value
operator|=
operator|(
name|intmax_t
operator|)
name|val
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|rp
argument_list|,
name|lp
operator|->
name|dn_ctfp
argument_list|,
name|lp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|rp
argument_list|,
name|_dtrace_symattr
argument_list|)
expr_stmt|;
block|}
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
comment|/* 		 * The rules for type checking for the relational operators are 		 * described in the ANSI-C spec (see K&R[A7.9-10]).  We perform 		 * the various tests in order from least to most expensive.  We 		 * also allow derived strings to be compared as a first-class 		 * type (resulting in a strcmp(3C)-style comparison), and we 		 * slightly relax the A7.9 rules to permit void pointer 		 * comparisons as in A7.10.  Our users won't be confused by 		 * this since they understand pointers are just numbers, and 		 * relaxing this constraint simplifies the implementation. 		 */
if|if
condition|(
name|ctf_type_compat
argument_list|(
name|lp
operator|->
name|dn_ctfp
argument_list|,
name|lp
operator|->
name|dn_type
argument_list|,
name|rp
operator|->
name|dn_ctfp
argument_list|,
name|rp
operator|->
name|dn_type
argument_list|)
condition|)
comment|/*EMPTY*/
empty_stmt|;
elseif|else
if|if
condition|(
name|dt_node_is_integer
argument_list|(
name|lp
argument_list|)
operator|&&
name|dt_node_is_integer
argument_list|(
name|rp
argument_list|)
condition|)
comment|/*EMPTY*/
empty_stmt|;
elseif|else
if|if
condition|(
name|dt_node_is_strcompat
argument_list|(
name|lp
argument_list|)
operator|&&
name|dt_node_is_strcompat
argument_list|(
name|rp
argument_list|)
operator|&&
operator|(
name|dt_node_is_string
argument_list|(
name|lp
argument_list|)
operator|||
name|dt_node_is_string
argument_list|(
name|rp
argument_list|)
operator|)
condition|)
comment|/*EMPTY*/
empty_stmt|;
elseif|else
if|if
condition|(
name|dt_node_is_ptrcompat
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_INCOMPAT
argument_list|,
literal|"operands have "
literal|"incompatible types: \"%s\" %s \"%s\"\n"
argument_list|,
name|dt_node_type_name
argument_list|(
name|lp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
name|rp
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_INT_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_INT_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_attr_min
argument_list|(
name|lp
operator|->
name|dn_attr
argument_list|,
name|rp
operator|->
name|dn_attr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_ADD
case|:
case|case
name|DT_TOK_SUB
case|:
block|{
comment|/* 		 * The rules for type checking for the additive operators are 		 * described in the ANSI-C spec (see K&R[A7.7]).  Pointers and 		 * integers may be manipulated according to specific rules.  In 		 * these cases D permits strings to be treated as pointers. 		 */
name|int
name|lp_is_ptr
decl_stmt|,
name|lp_is_int
decl_stmt|,
name|rp_is_ptr
decl_stmt|,
name|rp_is_int
decl_stmt|;
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|lp_is_ptr
operator|=
name|dt_node_is_string
argument_list|(
name|lp
argument_list|)
operator|||
operator|(
name|dt_node_is_pointer
argument_list|(
name|lp
argument_list|)
operator|&&
operator|!
name|dt_node_is_vfptr
argument_list|(
name|lp
argument_list|)
operator|)
expr_stmt|;
name|lp_is_int
operator|=
name|dt_node_is_integer
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|rp_is_ptr
operator|=
name|dt_node_is_string
argument_list|(
name|rp
argument_list|)
operator|||
operator|(
name|dt_node_is_pointer
argument_list|(
name|rp
argument_list|)
operator|&&
operator|!
name|dt_node_is_vfptr
argument_list|(
name|rp
argument_list|)
operator|)
expr_stmt|;
name|rp_is_int
operator|=
name|dt_node_is_integer
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp_is_int
operator|&&
name|rp_is_int
condition|)
block|{
name|dt_type_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
operator|&
name|ctfp
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|uref
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lp_is_ptr
operator|&&
name|rp_is_int
condition|)
block|{
name|ctfp
operator|=
name|lp
operator|->
name|dn_ctfp
expr_stmt|;
name|type
operator|=
name|lp
operator|->
name|dn_type
expr_stmt|;
name|uref
operator|=
name|lp
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lp_is_int
operator|&&
name|rp_is_ptr
operator|&&
name|op
operator|==
name|DT_TOK_ADD
condition|)
block|{
name|ctfp
operator|=
name|rp
operator|->
name|dn_ctfp
expr_stmt|;
name|type
operator|=
name|rp
operator|->
name|dn_type
expr_stmt|;
name|uref
operator|=
name|rp
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lp_is_ptr
operator|&&
name|rp_is_ptr
operator|&&
name|op
operator|==
name|DT_TOK_SUB
operator|&&
name|dt_node_is_ptrcompat
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ctfp
operator|=
name|dtp
operator|->
name|dt_ddefs
operator|->
name|dm_ctfp
expr_stmt|;
name|type
operator|=
name|ctf_lookup_by_name
argument_list|(
name|ctfp
argument_list|,
literal|"ptrdiff_t"
argument_list|)
expr_stmt|;
name|uref
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|xyerror
argument_list|(
name|D_OP_INCOMPAT
argument_list|,
literal|"operands have incompatible "
literal|"types: \"%s\" %s \"%s\"\n"
argument_list|,
name|dt_node_type_name
argument_list|(
name|lp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
name|rp
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_attr_min
argument_list|(
name|lp
operator|->
name|dn_attr
argument_list|,
name|rp
operator|->
name|dn_attr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uref
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_USERLAND
expr_stmt|;
break|break;
block|}
case|case
name|DT_TOK_OR_EQ
case|:
case|case
name|DT_TOK_XOR_EQ
case|:
case|case
name|DT_TOK_AND_EQ
case|:
case|case
name|DT_TOK_LSH_EQ
case|:
case|case
name|DT_TOK_RSH_EQ
case|:
case|case
name|DT_TOK_MOD_EQ
case|:
if|if
condition|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_IDENT
condition|)
block|{
name|dt_xcook_ident
argument_list|(
name|lp
argument_list|,
name|dtp
operator|->
name|dt_globals
argument_list|,
name|DT_IDENT_SCALAR
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
name|DT_IDFLG_REF
operator||
name|DT_IDFLG_MOD
argument_list|)
expr_stmt|;
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|DT_IDFLG_REF
operator||
name|DT_IDFLG_MOD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dt_node_is_integer
argument_list|(
name|lp
argument_list|)
operator|||
operator|!
name|dt_node_is_integer
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_INT
argument_list|,
literal|"operator %s requires operands of "
literal|"integral type\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|asgn_common
goto|;
case|case
name|DT_TOK_MUL_EQ
case|:
case|case
name|DT_TOK_DIV_EQ
case|:
if|if
condition|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_IDENT
condition|)
block|{
name|dt_xcook_ident
argument_list|(
name|lp
argument_list|,
name|dtp
operator|->
name|dt_globals
argument_list|,
name|DT_IDENT_SCALAR
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
name|DT_IDFLG_REF
operator||
name|DT_IDFLG_MOD
argument_list|)
expr_stmt|;
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|DT_IDFLG_REF
operator||
name|DT_IDFLG_MOD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dt_node_is_arith
argument_list|(
name|lp
argument_list|)
operator|||
operator|!
name|dt_node_is_arith
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_ARITH
argument_list|,
literal|"operator %s requires operands of "
literal|"arithmetic type\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|asgn_common
goto|;
case|case
name|DT_TOK_ASGN
case|:
comment|/* 		 * If the left-hand side is an identifier, attempt to resolve 		 * it as either an aggregation or scalar variable.  We pass 		 * B_TRUE to dt_xcook_ident to indicate that a new variable can 		 * be created if no matching variable exists in the namespace. 		 */
if|if
condition|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_IDENT
condition|)
block|{
if|if
condition|(
name|lp
operator|->
name|dn_op
operator|==
name|DT_TOK_AGG
condition|)
block|{
name|dt_xcook_ident
argument_list|(
name|lp
argument_list|,
name|dtp
operator|->
name|dt_aggs
argument_list|,
name|DT_IDENT_AGG
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dt_xcook_ident
argument_list|(
name|lp
argument_list|,
name|dtp
operator|->
name|dt_globals
argument_list|,
name|DT_IDENT_SCALAR
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* don't set mod yet */
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
comment|/* 		 * If the left-hand side is an aggregation, verify that we are 		 * assigning it the result of an aggregating function.  Once 		 * we've done so, hide the func node in the aggregation and 		 * return the aggregation itself up to the parse tree parent. 		 * This transformation is legal since the assigned function 		 * cannot change identity across disjoint cooking passes and 		 * the argument list subtree is retained for later cooking. 		 */
if|if
condition|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_AGG
condition|)
block|{
specifier|const
name|char
modifier|*
name|aname
init|=
name|lp
operator|->
name|dn_ident
operator|->
name|di_name
decl_stmt|;
name|dt_ident_t
modifier|*
name|oid
init|=
name|lp
operator|->
name|dn_ident
operator|->
name|di_iarg
decl_stmt|;
if|if
condition|(
name|rp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_FUNC
operator|||
name|rp
operator|->
name|dn_ident
operator|->
name|di_kind
operator|!=
name|DT_IDENT_AGGFUNC
condition|)
block|{
name|xyerror
argument_list|(
name|D_AGG_FUNC
argument_list|,
literal|"@%s must be assigned the result of "
literal|"an aggregating function\n"
argument_list|,
name|aname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oid
operator|!=
name|NULL
operator|&&
name|oid
operator|!=
name|rp
operator|->
name|dn_ident
condition|)
block|{
name|xyerror
argument_list|(
name|D_AGG_REDEF
argument_list|,
literal|"aggregation redefined: @%s\n\t "
literal|"current: @%s = %s( )\n\tprevious: @%s = "
literal|"%s( ) : line %d\n"
argument_list|,
name|aname
argument_list|,
name|aname
argument_list|,
name|rp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|aname
argument_list|,
name|oid
operator|->
name|di_name
argument_list|,
name|lp
operator|->
name|dn_ident
operator|->
name|di_lineno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oid
operator|==
name|NULL
condition|)
name|lp
operator|->
name|dn_ident
operator|->
name|di_iarg
operator|=
name|rp
operator|->
name|dn_ident
expr_stmt|;
comment|/* 			 * Do not allow multiple aggregation assignments in a 			 * single statement, e.g. (@a = count()) = count(); 			 * We produce a message as if the result of aggregating 			 * function does not propagate DT_NF_LVALUE. 			 */
if|if
condition|(
name|lp
operator|->
name|dn_aggfun
operator|!=
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_LVAL
argument_list|,
literal|"operator = requires "
literal|"modifiable lvalue as an operand\n"
argument_list|)
expr_stmt|;
block|}
name|lp
operator|->
name|dn_aggfun
operator|=
name|rp
expr_stmt|;
name|lp
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
name|DT_IDFLG_MOD
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_left
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|NULL
expr_stmt|;
name|dt_node_free
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
comment|/* 		 * If the right-hand side is a dynamic variable that is the 		 * output of a translator, our result is the translated type. 		 */
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_node_resolve
argument_list|(
name|rp
argument_list|,
name|DT_IDENT_XLSOU
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ctfp
operator|=
name|idp
operator|->
name|di_ctfp
expr_stmt|;
name|type
operator|=
name|idp
operator|->
name|di_type
expr_stmt|;
name|uref
operator|=
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_USER
expr_stmt|;
block|}
else|else
block|{
name|ctfp
operator|=
name|rp
operator|->
name|dn_ctfp
expr_stmt|;
name|type
operator|=
name|rp
operator|->
name|dn_type
expr_stmt|;
name|uref
operator|=
name|rp
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
expr_stmt|;
block|}
comment|/* 		 * If the left-hand side of an assignment statement is a virgin 		 * variable created by this compilation pass, reset the type of 		 * this variable to the type of the right-hand side. 		 */
if|if
condition|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
operator|&&
name|dt_ident_unref
argument_list|(
name|lp
operator|->
name|dn_ident
argument_list|)
condition|)
block|{
name|dt_node_type_assign
argument_list|(
name|lp
argument_list|,
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|dt_ident_type_assign
argument_list|(
name|lp
operator|->
name|dn_ident
argument_list|,
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|uref
condition|)
block|{
name|lp
operator|->
name|dn_flags
operator||=
name|DT_NF_USERLAND
expr_stmt|;
name|lp
operator|->
name|dn_ident
operator|->
name|di_flags
operator||=
name|DT_IDFLG_USER
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
condition|)
name|lp
operator|->
name|dn_ident
operator|->
name|di_flags
operator||=
name|DT_IDFLG_MOD
expr_stmt|;
comment|/* 		 * The rules for type checking for the assignment operators are 		 * described in the ANSI-C spec (see K&R[A7.17]).  We share 		 * most of this code with the argument list checking code. 		 */
if|if
condition|(
operator|!
name|dt_node_is_string
argument_list|(
name|lp
argument_list|)
condition|)
block|{
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|lp
operator|->
name|dn_ctfp
argument_list|,
name|ctf_type_resolve
argument_list|(
name|lp
operator|->
name|dn_ctfp
argument_list|,
name|lp
operator|->
name|dn_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_ARRAY
operator|||
name|kind
operator|==
name|CTF_K_FUNCTION
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_ARRFUN
argument_list|,
literal|"operator %s may not be "
literal|"applied to operand of type \"%s\"\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
name|lp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|idp
operator|!=
name|NULL
operator|&&
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_XLSOU
operator|&&
name|ctf_type_compat
argument_list|(
name|lp
operator|->
name|dn_ctfp
argument_list|,
name|lp
operator|->
name|dn_type
argument_list|,
name|ctfp
argument_list|,
name|type
argument_list|)
condition|)
goto|goto
name|asgn_common
goto|;
if|if
condition|(
name|dt_node_is_argcompat
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|)
condition|)
goto|goto
name|asgn_common
goto|;
name|xyerror
argument_list|(
name|D_OP_INCOMPAT
argument_list|,
literal|"operands have incompatible types: \"%s\" %s \"%s\"\n"
argument_list|,
name|dt_node_type_name
argument_list|(
name|lp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
name|rp
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
name|DT_TOK_ADD_EQ
case|:
case|case
name|DT_TOK_SUB_EQ
case|:
if|if
condition|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_IDENT
condition|)
block|{
name|dt_xcook_ident
argument_list|(
name|lp
argument_list|,
name|dtp
operator|->
name|dt_globals
argument_list|,
name|DT_IDENT_SCALAR
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
name|DT_IDFLG_REF
operator||
name|DT_IDFLG_MOD
argument_list|)
expr_stmt|;
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|DT_IDFLG_REF
operator||
name|DT_IDFLG_MOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_node_is_string
argument_list|(
name|lp
argument_list|)
operator|||
name|dt_node_is_string
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_INCOMPAT
argument_list|,
literal|"operands have "
literal|"incompatible types: \"%s\" %s \"%s\"\n"
argument_list|,
name|dt_node_type_name
argument_list|(
name|lp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
name|rp
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * The rules for type checking for the assignment operators are 		 * described in the ANSI-C spec (see K&R[A7.17]).  To these 		 * rules we add that only writable D nodes can be modified. 		 */
if|if
condition|(
name|dt_node_is_integer
argument_list|(
name|lp
argument_list|)
operator|==
literal|0
operator|||
name|dt_node_is_integer
argument_list|(
name|rp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|dt_node_is_pointer
argument_list|(
name|lp
argument_list|)
operator|||
name|dt_node_is_vfptr
argument_list|(
name|lp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_VFPTR
argument_list|,
literal|"operator %s requires left-hand scalar "
literal|"operand of known size\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dt_node_is_integer
argument_list|(
name|rp
argument_list|)
operator|==
literal|0
operator|&&
name|dt_node_is_ptrcompat
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_INCOMPAT
argument_list|,
literal|"operands have "
literal|"incompatible types: \"%s\" %s \"%s\"\n"
argument_list|,
name|dt_node_type_name
argument_list|(
name|lp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
name|rp
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|asgn_common
label|:
name|dt_assign_common
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_PTR
case|:
comment|/* 		 * If the left-hand side of operator -> is the name "self", 		 * then we permit a TLS variable to be created or referenced. 		 */
if|if
condition|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_IDENT
operator|&&
name|strcmp
argument_list|(
name|lp
operator|->
name|dn_string
argument_list|,
literal|"self"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_VAR
condition|)
block|{
name|dt_xcook_ident
argument_list|(
name|rp
argument_list|,
name|dtp
operator|->
name|dt_tls
argument_list|,
name|DT_IDENT_SCALAR
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idflags
operator|!=
literal|0
condition|)
name|rp
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|idflags
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_right
operator|=
name|dnp
operator|->
name|dn_left
expr_stmt|;
comment|/* avoid freeing rp */
name|dt_node_free
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rp
operator|)
return|;
block|}
comment|/* 		 * If the left-hand side of operator -> is the name "this", 		 * then we permit a local variable to be created or referenced. 		 */
if|if
condition|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_IDENT
operator|&&
name|strcmp
argument_list|(
name|lp
operator|->
name|dn_string
argument_list|,
literal|"this"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_VAR
condition|)
block|{
name|dt_xcook_ident
argument_list|(
name|rp
argument_list|,
name|yypcb
operator|->
name|pcb_locals
argument_list|,
name|DT_IDENT_SCALAR
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idflags
operator|!=
literal|0
condition|)
name|rp
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|idflags
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_right
operator|=
name|dnp
operator|->
name|dn_left
expr_stmt|;
comment|/* avoid freeing rp */
name|dt_node_free
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rp
operator|)
return|;
block|}
comment|/*FALLTHRU*/
case|case
name|DT_TOK_DOT
case|:
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_IDENT
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_IDENT
argument_list|,
literal|"operator %s must be followed by "
literal|"an identifier\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_node_resolve
argument_list|(
name|lp
argument_list|,
name|DT_IDENT_XLSOU
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|idp
operator|=
name|dt_node_resolve
argument_list|(
name|lp
argument_list|,
name|DT_IDENT_XLPTR
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If the left-hand side is a translated struct or ptr, 			 * the type of the left is the translation output type. 			 */
name|dt_xlator_t
modifier|*
name|dxp
init|=
name|idp
operator|->
name|di_data
decl_stmt|;
if|if
condition|(
name|dt_xlator_member
argument_list|(
name|dxp
argument_list|,
name|rp
operator|->
name|dn_string
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_XLATE_NOCONV
argument_list|,
literal|"translator does not define conversion "
literal|"for member: %s\n"
argument_list|,
name|rp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
block|}
name|ctfp
operator|=
name|idp
operator|->
name|di_ctfp
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|idp
operator|->
name|di_type
argument_list|)
expr_stmt|;
name|uref
operator|=
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_USER
expr_stmt|;
block|}
else|else
block|{
name|ctfp
operator|=
name|lp
operator|->
name|dn_ctfp
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|lp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|uref
operator|=
name|lp
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
expr_stmt|;
block|}
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|DT_TOK_PTR
condition|)
block|{
if|if
condition|(
name|kind
operator|!=
name|CTF_K_POINTER
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_PTR
argument_list|,
literal|"operator %s must be "
literal|"applied to a pointer\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|ctf_type_reference
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we follow a reference to a forward declaration tag, 		 * search the entire type space for the actual definition. 		 */
while|while
condition|(
name|kind
operator|==
name|CTF_K_FORWARD
condition|)
block|{
name|char
modifier|*
name|tag
init|=
name|ctf_type_name
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
decl_stmt|;
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
operator|&&
name|dt_type_lookup
argument_list|(
name|tag
argument_list|,
operator|&
name|dtt
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|dtt
operator|.
name|dtt_ctfp
operator|!=
name|ctfp
operator|||
name|dtt
operator|.
name|dtt_type
operator|!=
name|type
operator|)
condition|)
block|{
name|ctfp
operator|=
name|dtt
operator|.
name|dtt_ctfp
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xyerror
argument_list|(
name|D_OP_INCOMPLETE
argument_list|,
literal|"operator %s cannot be applied to a "
literal|"forward declaration: no %s definition "
literal|"is available\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|kind
operator|!=
name|CTF_K_STRUCT
operator|&&
name|kind
operator|!=
name|CTF_K_UNION
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|DT_TOK_PTR
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_SOU
argument_list|,
literal|"operator -> cannot be "
literal|"applied to pointer to type \"%s\"; must "
literal|"be applied to a struct or union pointer\n"
argument_list|,
name|ctf_type_name
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xyerror
argument_list|(
name|D_OP_SOU
argument_list|,
literal|"operator %s cannot be "
literal|"applied to type \"%s\"; must be applied "
literal|"to a struct or union\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|,
name|ctf_type_name
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ctf_member_info
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|,
name|rp
operator|->
name|dn_string
argument_list|,
operator|&
name|m
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_TYPE_MEMBER
argument_list|,
literal|"%s is not a member of %s\n"
argument_list|,
name|rp
operator|->
name|dn_string
argument_list|,
name|ctf_type_name
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|m
operator|.
name|ctm_type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|ctfp
argument_list|,
name|m
operator|.
name|ctm_type
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|lp
operator|->
name|dn_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|DT_TOK_PTR
operator|&&
operator|(
name|kind
operator|!=
name|CTF_K_ARRAY
operator|||
name|dt_node_is_string
argument_list|(
name|dnp
argument_list|)
operator|)
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_LVALUE
expr_stmt|;
comment|/* see K&R[A7.3.3] */
if|if
condition|(
name|op
operator|==
name|DT_TOK_DOT
operator|&&
operator|(
name|lp
operator|->
name|dn_flags
operator|&
name|DT_NF_LVALUE
operator|)
operator|&&
operator|(
name|kind
operator|!=
name|CTF_K_ARRAY
operator|||
name|dt_node_is_string
argument_list|(
name|dnp
argument_list|)
operator|)
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_LVALUE
expr_stmt|;
comment|/* see K&R[A7.3.3] */
if|if
condition|(
name|lp
operator|->
name|dn_flags
operator|&
name|DT_NF_WRITABLE
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_WRITABLE
expr_stmt|;
if|if
condition|(
name|uref
operator|&&
operator|(
name|kind
operator|==
name|CTF_K_POINTER
operator|||
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_REF
operator|)
operator|)
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_USERLAND
expr_stmt|;
break|break;
case|case
name|DT_TOK_LBRAC
case|:
block|{
comment|/* 		 * If op is DT_TOK_LBRAC, we know from the special-case code at 		 * the top that lp is either a D variable or an aggregation. 		 */
name|dt_node_t
modifier|*
name|lnp
decl_stmt|;
comment|/* 		 * If the left-hand side is an aggregation, just set dn_aggtup 		 * to the right-hand side and return the cooked aggregation. 		 * This transformation is legal since we are just collapsing 		 * nodes to simplify later processing, and the entire aggtup 		 * parse subtree is retained for subsequent cooking passes. 		 */
if|if
condition|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_AGG
condition|)
block|{
if|if
condition|(
name|lp
operator|->
name|dn_aggtup
operator|!=
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_AGG_MDIM
argument_list|,
literal|"improper attempt to "
literal|"reference @%s as a multi-dimensional "
literal|"array\n"
argument_list|,
name|lp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
name|lp
operator|->
name|dn_aggtup
operator|=
name|rp
expr_stmt|;
name|lp
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_left
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|NULL
expr_stmt|;
name|dt_node_free
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
name|assert
argument_list|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
argument_list|)
expr_stmt|;
name|idp
operator|=
name|lp
operator|->
name|dn_ident
expr_stmt|;
comment|/* 		 * If the left-hand side is a non-global scalar that hasn't yet 		 * been referenced or modified, it was just created by self-> 		 * or this-> and we can convert it from scalar to assoc array. 		 */
if|if
condition|(
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_SCALAR
operator|&&
name|dt_ident_unref
argument_list|(
name|idp
argument_list|)
operator|&&
operator|(
name|idp
operator|->
name|di_flags
operator|&
operator|(
name|DT_IDFLG_LOCAL
operator||
name|DT_IDFLG_TLS
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_LOCAL
condition|)
block|{
name|xyerror
argument_list|(
name|D_ARR_LOCAL
argument_list|,
literal|"local variables may not be used as "
literal|"associative arrays: %s\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
name|dt_dprintf
argument_list|(
literal|"morph variable %s (id %u) from scalar to "
literal|"array\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|idp
operator|->
name|di_id
argument_list|)
expr_stmt|;
name|dt_ident_morph
argument_list|(
name|idp
argument_list|,
name|DT_IDENT_ARRAY
argument_list|,
operator|&
name|dt_idops_assc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idp
operator|->
name|di_kind
operator|!=
name|DT_IDENT_ARRAY
condition|)
block|{
name|xyerror
argument_list|(
name|D_IDENT_BADREF
argument_list|,
literal|"%s '%s' may not be referenced "
literal|"as %s\n"
argument_list|,
name|dt_idkind_name
argument_list|(
name|idp
operator|->
name|di_kind
argument_list|)
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|dt_idkind_name
argument_list|(
name|DT_IDENT_ARRAY
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now that we've confirmed our left-hand side is a DT_NODE_VAR 		 * of idkind DT_IDENT_ARRAY, we need to splice the [ node from 		 * the parse tree and leave a cooked DT_NODE_VAR in its place 		 * where dn_args for the VAR node is the right-hand 'rp' tree, 		 * as shown in the parse tree diagram below: 		 * 		 *	  /			    / 		 * [ OP2 "[" ]=dnp		[ VAR ]=dnp 		 *	 /	\	  =>	   | 		 *	/	 \		   +- dn_args -> [ ??? ]=rp 		 * [ VAR ]=lp  [ ??? ]=rp 		 * 		 * Since the final dt_node_cook(dnp) can fail using longjmp we 		 * must perform the transformations as a group first by over- 		 * writing 'dnp' to become the VAR node, so that the parse tree 		 * is guaranteed to be in a consistent state if the cook fails. 		 */
name|assert
argument_list|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lp
operator|->
name|dn_args
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|lnp
operator|=
name|dnp
operator|->
name|dn_link
expr_stmt|;
name|bcopy
argument_list|(
name|lp
argument_list|,
name|dnp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_link
operator|=
name|lnp
expr_stmt|;
name|dnp
operator|->
name|dn_args
operator|=
name|rp
expr_stmt|;
name|dnp
operator|->
name|dn_list
operator|=
name|NULL
expr_stmt|;
name|dt_node_free
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_node_cook
argument_list|(
name|dnp
argument_list|,
name|idflags
argument_list|)
operator|)
return|;
block|}
case|case
name|DT_TOK_XLATE
case|:
block|{
name|dt_xlator_t
modifier|*
name|dxp
decl_stmt|;
name|assert
argument_list|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_TYPE
argument_list|)
expr_stmt|;
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|dxp
operator|=
name|dt_xlator_lookup
argument_list|(
name|dtp
argument_list|,
name|rp
argument_list|,
name|lp
argument_list|,
name|DT_XLATE_FUZZY
argument_list|)
expr_stmt|;
if|if
condition|(
name|dxp
operator|==
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_XLATE_NONE
argument_list|,
literal|"cannot translate from \"%s\" to \"%s\"\n"
argument_list|,
name|dt_node_type_name
argument_list|(
name|rp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
name|lp
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dnp
operator|->
name|dn_ident
operator|=
name|dt_xlator_ident
argument_list|(
name|dxp
argument_list|,
name|lp
operator|->
name|dn_ctfp
argument_list|,
name|lp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_DYN_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_DYN_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_attr_min
argument_list|(
name|rp
operator|->
name|dn_attr
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_attr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DT_TOK_LPAR
case|:
block|{
name|ctf_id_t
name|ltype
decl_stmt|,
name|rtype
decl_stmt|;
name|uint_t
name|lkind
decl_stmt|,
name|rkind
decl_stmt|;
name|assert
argument_list|(
name|lp
operator|->
name|dn_kind
operator|==
name|DT_NODE_TYPE
argument_list|)
expr_stmt|;
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|ltype
operator|=
name|ctf_type_resolve
argument_list|(
name|lp
operator|->
name|dn_ctfp
argument_list|,
name|lp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|lkind
operator|=
name|ctf_type_kind
argument_list|(
name|lp
operator|->
name|dn_ctfp
argument_list|,
name|ltype
argument_list|)
expr_stmt|;
name|rtype
operator|=
name|ctf_type_resolve
argument_list|(
name|rp
operator|->
name|dn_ctfp
argument_list|,
name|rp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|rkind
operator|=
name|ctf_type_kind
argument_list|(
name|rp
operator|->
name|dn_ctfp
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
comment|/* 		 * The rules for casting are loosely explained in K&R[A7.5] 		 * and K&R[A6].  Basically, we can cast to the same type or 		 * same base type, between any kind of scalar values, from 		 * arrays to pointers, and we can cast anything to void. 		 * To these rules D adds casts from scalars to strings. 		 */
if|if
condition|(
name|ctf_type_compat
argument_list|(
name|lp
operator|->
name|dn_ctfp
argument_list|,
name|lp
operator|->
name|dn_type
argument_list|,
name|rp
operator|->
name|dn_ctfp
argument_list|,
name|rp
operator|->
name|dn_type
argument_list|)
condition|)
comment|/*EMPTY*/
empty_stmt|;
elseif|else
if|if
condition|(
name|dt_node_is_scalar
argument_list|(
name|lp
argument_list|)
operator|&&
operator|(
name|dt_node_is_scalar
argument_list|(
name|rp
argument_list|)
operator|||
name|rkind
operator|==
name|CTF_K_FUNCTION
operator|)
condition|)
comment|/*EMPTY*/
empty_stmt|;
elseif|else
if|if
condition|(
name|dt_node_is_void
argument_list|(
name|lp
argument_list|)
condition|)
comment|/*EMPTY*/
empty_stmt|;
elseif|else
if|if
condition|(
name|lkind
operator|==
name|CTF_K_POINTER
operator|&&
name|dt_node_is_pointer
argument_list|(
name|rp
argument_list|)
condition|)
comment|/*EMPTY*/
empty_stmt|;
elseif|else
if|if
condition|(
name|dt_node_is_string
argument_list|(
name|lp
argument_list|)
operator|&&
operator|(
name|dt_node_is_scalar
argument_list|(
name|rp
argument_list|)
operator|||
name|dt_node_is_pointer
argument_list|(
name|rp
argument_list|)
operator|||
name|dt_node_is_strcompat
argument_list|(
name|rp
argument_list|)
operator|)
condition|)
comment|/*EMPTY*/
empty_stmt|;
else|else
block|{
name|xyerror
argument_list|(
name|D_CAST_INVAL
argument_list|,
literal|"invalid cast expression: \"%s\" to \"%s\"\n"
argument_list|,
name|dt_node_type_name
argument_list|(
name|rp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
name|lp
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_propagate
argument_list|(
name|lp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
comment|/* see K&R[A7.5] */
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_attr_min
argument_list|(
name|lp
operator|->
name|dn_attr
argument_list|,
name|rp
operator|->
name|dn_attr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If it's a pointer then should be able to (attempt to) 		 * assign to it. 		 */
if|if
condition|(
name|lkind
operator|==
name|CTF_K_POINTER
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_WRITABLE
expr_stmt|;
break|break;
block|}
case|case
name|DT_TOK_COMMA
case|:
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|lp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|rp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_node_is_dynamic
argument_list|(
name|lp
argument_list|)
operator|||
name|dt_node_is_dynamic
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_DYN
argument_list|,
literal|"operator %s operands "
literal|"cannot be of dynamic type\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_node_is_actfunc
argument_list|(
name|lp
argument_list|)
operator|||
name|dt_node_is_actfunc
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_ACT
argument_list|,
literal|"operator %s operands "
literal|"cannot be actions\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_propagate
argument_list|(
name|rp
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
comment|/* see K&R[A7.18] */
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_attr_min
argument_list|(
name|lp
operator|->
name|dn_attr
argument_list|,
name|rp
operator|->
name|dn_attr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"invalid binary op %s\n"
argument_list|,
name|opstr
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Complete the conversion of E1[E2] to *((E1)+(E2)) that we started 	 * at the top of our switch() above (see K&R[A7.3.1]).  Since E2 is 	 * parsed as an argument_expression_list by dt_grammar.y, we can 	 * end up with a comma-separated list inside of a non-associative 	 * array reference.  We check for this and report an appropriate error. 	 */
if|if
condition|(
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_LBRAC
operator|&&
name|op
operator|==
name|DT_TOK_ADD
condition|)
block|{
name|dt_node_t
modifier|*
name|pnp
decl_stmt|;
if|if
condition|(
name|rp
operator|->
name|dn_list
operator|!=
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_ARR_BADREF
argument_list|,
literal|"cannot access %s as an associative array\n"
argument_list|,
name|dt_node_name
argument_list|(
name|lp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dnp
operator|->
name|dn_op
operator|=
name|DT_TOK_ADD
expr_stmt|;
name|pnp
operator|=
name|dt_node_op1
argument_list|(
name|DT_TOK_DEREF
argument_list|,
name|dnp
argument_list|)
expr_stmt|;
comment|/* 		 * Cook callbacks are not typically permitted to allocate nodes. 		 * When we do, we must insert them in the middle of an existing 		 * allocation list rather than having them appended to the pcb 		 * list because the sub-expression may be part of a definition. 		 */
name|assert
argument_list|(
name|yypcb
operator|->
name|pcb_list
operator|==
name|pnp
argument_list|)
expr_stmt|;
name|yypcb
operator|->
name|pcb_list
operator|=
name|pnp
operator|->
name|dn_link
expr_stmt|;
name|pnp
operator|->
name|dn_link
operator|=
name|dnp
operator|->
name|dn_link
expr_stmt|;
name|dnp
operator|->
name|dn_link
operator|=
name|pnp
expr_stmt|;
return|return
operator|(
name|dt_node_cook
argument_list|(
name|pnp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_cook_op3
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|lp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|ctf_file_t
modifier|*
name|ctfp
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|dnp
operator|->
name|dn_expr
operator|=
name|dt_node_cook
argument_list|(
name|dnp
operator|->
name|dn_expr
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|lp
operator|=
name|dnp
operator|->
name|dn_left
operator|=
name|dt_node_cook
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|rp
operator|=
name|dnp
operator|->
name|dn_right
operator|=
name|dt_node_cook
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dt_node_is_scalar
argument_list|(
name|dnp
operator|->
name|dn_expr
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_SCALAR
argument_list|,
literal|"operator ?: expression must be of scalar type\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_node_is_dynamic
argument_list|(
name|lp
argument_list|)
operator|||
name|dt_node_is_dynamic
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_DYN
argument_list|,
literal|"operator ?: operands cannot be of dynamic type\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The rules for type checking for the ternary operator are complex and 	 * are described in the ANSI-C spec (see K&R[A7.16]).  We implement 	 * the various tests in order from least to most expensive. 	 */
if|if
condition|(
name|ctf_type_compat
argument_list|(
name|lp
operator|->
name|dn_ctfp
argument_list|,
name|lp
operator|->
name|dn_type
argument_list|,
name|rp
operator|->
name|dn_ctfp
argument_list|,
name|rp
operator|->
name|dn_type
argument_list|)
condition|)
block|{
name|ctfp
operator|=
name|lp
operator|->
name|dn_ctfp
expr_stmt|;
name|type
operator|=
name|lp
operator|->
name|dn_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dt_node_is_integer
argument_list|(
name|lp
argument_list|)
operator|&&
name|dt_node_is_integer
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|dt_type_promote
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
operator|&
name|ctfp
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dt_node_is_strcompat
argument_list|(
name|lp
argument_list|)
operator|&&
name|dt_node_is_strcompat
argument_list|(
name|rp
argument_list|)
operator|&&
operator|(
name|dt_node_is_string
argument_list|(
name|lp
argument_list|)
operator|||
name|dt_node_is_string
argument_list|(
name|rp
argument_list|)
operator|)
condition|)
block|{
name|ctfp
operator|=
name|DT_STR_CTFP
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
expr_stmt|;
name|type
operator|=
name|DT_STR_TYPE
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dt_node_is_ptrcompat
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|,
operator|&
name|ctfp
argument_list|,
operator|&
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_INCOMPAT
argument_list|,
literal|"operator ?: operands must have compatible types\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_node_is_actfunc
argument_list|(
name|lp
argument_list|)
operator|||
name|dt_node_is_actfunc
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_OP_ACT
argument_list|,
literal|"action cannot be "
literal|"used in a conditional context\n"
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_attr_min
argument_list|(
name|dnp
operator|->
name|dn_expr
operator|->
name|dn_attr
argument_list|,
name|dt_attr_min
argument_list|(
name|lp
operator|->
name|dn_attr
argument_list|,
name|rp
operator|->
name|dn_attr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_cook_statement
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
name|dnp
operator|->
name|dn_expr
operator|=
name|dt_node_cook
argument_list|(
name|dnp
operator|->
name|dn_expr
argument_list|,
name|idflags
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dnp
operator|->
name|dn_expr
operator|->
name|dn_attr
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If dn_aggfun is set, this node is a collapsed aggregation assignment (see  * the special case code for DT_TOK_ASGN in dt_cook_op2() above), in which  * case we cook both the tuple and the function call.  If dn_aggfun is NULL,  * this node is just a reference to the aggregation's type and attributes.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_cook_aggregation
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_aggfun
operator|!=
name|NULL
condition|)
block|{
name|dnp
operator|->
name|dn_aggfun
operator|=
name|dt_node_cook
argument_list|(
name|dnp
operator|->
name|dn_aggfun
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_ident_cook
argument_list|(
name|dnp
argument_list|,
name|dnp
operator|->
name|dn_ident
argument_list|,
operator|&
name|dnp
operator|->
name|dn_aggtup
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_DYN_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_DYN_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_attr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Since D permits new variable identifiers to be instantiated in any program  * expression, we may need to cook a clause's predicate either before or after  * the action list depending on the program code in question.  Consider:  *  * probe-description-list	probe-description-list  * /x++/			/x == 0/  * {				{  *     trace(x);		    trace(x++);  * }				}  *  * In the left-hand example, the predicate uses operator ++ to instantiate 'x'  * as a variable of type int64_t.  The predicate must be cooked first because  * otherwise the statement trace(x) refers to an unknown identifier.  In the  * right-hand example, the action list uses ++ to instantiate 'x'; the action  * list must be cooked first because otherwise the predicate x == 0 refers to  * an unknown identifier.  In order to simplify programming, we support both.  *  * When cooking a clause, we cook the action statements before the predicate by  * default, since it seems more common to create or modify identifiers in the  * action list.  If cooking fails due to an unknown identifier, we attempt to  * cook the predicate (i.e. do it first) and then go back and cook the actions.  * If this, too, fails (or if we get an error other than D_IDENT_UNDEF) we give  * up and report failure back to the user.  There are five possible paths:  *  * cook actions = OK, cook predicate = OK -> OK  * cook actions = OK, cook predicate = ERR -> ERR  * cook actions = ERR, cook predicate = ERR -> ERR  * cook actions = ERR, cook predicate = OK, cook actions = OK -> OK  * cook actions = ERR, cook predicate = OK, cook actions = ERR -> ERR  *  * The programmer can still defeat our scheme by creating circular definition  * dependencies between predicates and actions, as in this example clause:  *  * probe-description-list  * /x++&& y == 0/  * {  * 	trace(x + y++);  * }  *  * but it doesn't seem worth the complexity to handle such rare cases.  The  * user can simply use the D variable declaration syntax to work around them.  */
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_cook_clause
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
specifier|volatile
name|int
name|err
decl_stmt|,
name|tries
decl_stmt|;
name|jmp_buf
name|ojb
decl_stmt|;
comment|/* 	 * Before assigning dn_ctxattr, temporarily assign the probe attribute 	 * to 'dnp' itself to force an attribute check and minimum violation. 	 */
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|yypcb
operator|->
name|pcb_pinfo
operator|.
name|dtp_attr
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_ctxattr
operator|=
name|yypcb
operator|->
name|pcb_pinfo
operator|.
name|dtp_attr
expr_stmt|;
name|bcopy
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|ojb
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|tries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_pred
operator|!=
name|NULL
operator|&&
operator|(
name|err
operator|=
name|setjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|ojb
argument_list|,
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tries
operator|++
operator|!=
literal|0
operator|||
name|err
operator|!=
name|EDT_COMPILER
operator|||
operator|(
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_errtag
operator|!=
name|dt_errtag
argument_list|(
name|D_IDENT_UNDEF
argument_list|)
operator|&&
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_errtag
operator|!=
name|dt_errtag
argument_list|(
name|D_VAR_UNDEF
argument_list|)
operator|)
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tries
operator|==
literal|0
condition|)
block|{
name|yylabel
argument_list|(
literal|"action list"
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_node_list_cook
argument_list|(
operator|&
name|dnp
operator|->
name|dn_acts
argument_list|,
name|idflags
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ojb
argument_list|,
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|yylabel
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dnp
operator|->
name|dn_pred
operator|!=
name|NULL
condition|)
block|{
name|yylabel
argument_list|(
literal|"predicate"
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_pred
operator|=
name|dt_node_cook
argument_list|(
name|dnp
operator|->
name|dn_pred
argument_list|,
name|idflags
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_attr_min
argument_list|(
name|dnp
operator|->
name|dn_attr
argument_list|,
name|dnp
operator|->
name|dn_pred
operator|->
name|dn_attr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dt_node_is_scalar
argument_list|(
name|dnp
operator|->
name|dn_pred
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_PRED_SCALAR
argument_list|,
literal|"predicate result must be of scalar type\n"
argument_list|)
expr_stmt|;
block|}
name|yylabel
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tries
operator|!=
literal|0
condition|)
block|{
name|yylabel
argument_list|(
literal|"action list"
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dt_node_list_cook
argument_list|(
operator|&
name|dnp
operator|->
name|dn_acts
argument_list|,
name|idflags
argument_list|)
argument_list|)
expr_stmt|;
name|yylabel
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_cook_inline
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
name|dt_idnode_t
modifier|*
name|inp
init|=
name|dnp
operator|->
name|dn_ident
operator|->
name|di_iarg
decl_stmt|;
name|dt_ident_t
modifier|*
name|rdp
decl_stmt|;
name|char
name|n1
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|char
name|n2
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator|&
name|DT_IDFLG_INLINE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|inp
operator|->
name|din_root
operator|->
name|dn_flags
operator|&
name|DT_NF_COOKED
argument_list|)
expr_stmt|;
comment|/* 	 * If we are inlining a translation, verify that the inline declaration 	 * type exactly matches the type that is returned by the translation. 	 * Otherwise just use dt_node_is_argcompat() to check the types. 	 */
if|if
condition|(
operator|(
name|rdp
operator|=
name|dt_node_resolve
argument_list|(
name|inp
operator|->
name|din_root
argument_list|,
name|DT_IDENT_XLSOU
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|rdp
operator|=
name|dt_node_resolve
argument_list|(
name|inp
operator|->
name|din_root
argument_list|,
name|DT_IDENT_XLPTR
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ctf_file_t
modifier|*
name|lctfp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_id_t
name|ltype
init|=
name|ctf_type_resolve
argument_list|(
name|lctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
decl_stmt|;
name|dt_xlator_t
modifier|*
name|dxp
init|=
name|rdp
operator|->
name|di_data
decl_stmt|;
name|ctf_file_t
modifier|*
name|rctfp
init|=
name|dxp
operator|->
name|dx_dst_ctfp
decl_stmt|;
name|ctf_id_t
name|rtype
init|=
name|dxp
operator|->
name|dx_dst_base
decl_stmt|;
if|if
condition|(
name|ctf_type_kind
argument_list|(
name|lctfp
argument_list|,
name|ltype
argument_list|)
operator|==
name|CTF_K_POINTER
condition|)
block|{
name|ltype
operator|=
name|ctf_type_reference
argument_list|(
name|lctfp
argument_list|,
name|ltype
argument_list|)
expr_stmt|;
name|ltype
operator|=
name|ctf_type_resolve
argument_list|(
name|lctfp
argument_list|,
name|ltype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctf_type_compat
argument_list|(
name|lctfp
argument_list|,
name|ltype
argument_list|,
name|rctfp
argument_list|,
name|rtype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_OP_INCOMPAT
argument_list|,
literal|"inline %s definition uses incompatible types: "
literal|"\"%s\" = \"%s\"\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|dt_type_name
argument_list|(
name|lctfp
argument_list|,
name|ltype
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dt_type_name
argument_list|(
name|rctfp
argument_list|,
name|rtype
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dt_node_is_argcompat
argument_list|(
name|dnp
argument_list|,
name|inp
operator|->
name|din_root
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_OP_INCOMPAT
argument_list|,
literal|"inline %s definition uses incompatible types: "
literal|"\"%s\" = \"%s\"\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|dt_node_type_name
argument_list|(
name|dnp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
name|inp
operator|->
name|din_root
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_cook_member
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
name|dnp
operator|->
name|dn_membexpr
operator|=
name|dt_node_cook
argument_list|(
name|dnp
operator|->
name|dn_membexpr
argument_list|,
name|idflags
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|dnp
operator|->
name|dn_membexpr
operator|->
name|dn_attr
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_cook_xlator
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_xlator_t
modifier|*
name|dxp
init|=
name|dnp
operator|->
name|dn_xlator
decl_stmt|;
name|dt_node_t
modifier|*
name|mnp
decl_stmt|;
name|char
name|n1
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|char
name|n2
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|dtrace_attribute_t
name|attr
init|=
name|_dtrace_maxattr
decl_stmt|;
name|ctf_membinfo_t
name|ctm
decl_stmt|;
comment|/* 	 * Before cooking each translator member, we push a reference to the 	 * hash containing translator-local identifiers on to pcb_globals to 	 * temporarily interpose these identifiers in front of other globals. 	 */
name|dt_idstack_push
argument_list|(
operator|&
name|yypcb
operator|->
name|pcb_globals
argument_list|,
name|dxp
operator|->
name|dx_locals
argument_list|)
expr_stmt|;
for|for
control|(
name|mnp
operator|=
name|dnp
operator|->
name|dn_members
init|;
name|mnp
operator|!=
name|NULL
condition|;
name|mnp
operator|=
name|mnp
operator|->
name|dn_list
control|)
block|{
if|if
condition|(
name|ctf_member_info
argument_list|(
name|dxp
operator|->
name|dx_dst_ctfp
argument_list|,
name|dxp
operator|->
name|dx_dst_type
argument_list|,
name|mnp
operator|->
name|dn_membname
argument_list|,
operator|&
name|ctm
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_XLATE_MEMB
argument_list|,
literal|"translator member %s is not a member of %s\n"
argument_list|,
name|mnp
operator|->
name|dn_membname
argument_list|,
name|ctf_type_name
argument_list|(
name|dxp
operator|->
name|dx_dst_ctfp
argument_list|,
name|dxp
operator|->
name|dx_dst_type
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dt_node_cook
argument_list|(
name|mnp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|mnp
argument_list|,
name|dxp
operator|->
name|dx_dst_ctfp
argument_list|,
name|ctm
operator|.
name|ctm_type
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dt_attr_min
argument_list|(
name|attr
argument_list|,
name|mnp
operator|->
name|dn_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_node_is_argcompat
argument_list|(
name|mnp
argument_list|,
name|mnp
operator|->
name|dn_membexpr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_XLATE_INCOMPAT
argument_list|,
literal|"translator member %s definition uses "
literal|"incompatible types: \"%s\" = \"%s\"\n"
argument_list|,
name|mnp
operator|->
name|dn_membname
argument_list|,
name|dt_node_type_name
argument_list|(
name|mnp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
name|mnp
operator|->
name|dn_membexpr
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dt_idstack_pop
argument_list|(
operator|&
name|yypcb
operator|->
name|pcb_globals
argument_list|,
name|dxp
operator|->
name|dx_locals
argument_list|)
expr_stmt|;
name|dxp
operator|->
name|dx_souid
operator|.
name|di_attr
operator|=
name|attr
expr_stmt|;
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_attr
operator|=
name|attr
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_DYN_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_DYN_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
name|dt_node_attr_assign
argument_list|(
name|dnp
argument_list|,
name|_dtrace_defattr
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_node_provider_cmp_argv
parameter_list|(
name|dt_provider_t
modifier|*
name|pvp
parameter_list|,
name|dt_node_t
modifier|*
name|pnp
parameter_list|,
specifier|const
name|char
modifier|*
name|kind
parameter_list|,
name|uint_t
name|old_argc
parameter_list|,
name|dt_node_t
modifier|*
name|old_argv
parameter_list|,
name|uint_t
name|new_argc
parameter_list|,
name|dt_node_t
modifier|*
name|new_argv
parameter_list|)
block|{
name|dt_probe_t
modifier|*
name|prp
init|=
name|pnp
operator|->
name|dn_ident
operator|->
name|di_data
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
name|char
name|n1
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|char
name|n2
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|old_argc
operator|!=
name|new_argc
condition|)
block|{
name|dnerror
argument_list|(
name|pnp
argument_list|,
name|D_PROV_INCOMPAT
argument_list|,
literal|"probe %s:%s %s prototype mismatch:\n"
literal|"\t current: %u arg%s\n\tprevious: %u arg%s\n"
argument_list|,
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|prp
operator|->
name|pr_ident
operator|->
name|di_name
argument_list|,
name|kind
argument_list|,
name|new_argc
argument_list|,
name|new_argc
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|old_argc
argument_list|,
name|old_argc
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_argc
condition|;
name|i
operator|++
operator|,
name|old_argv
operator|=
name|old_argv
operator|->
name|dn_list
operator|,
name|new_argv
operator|=
name|new_argv
operator|->
name|dn_list
control|)
block|{
if|if
condition|(
name|ctf_type_cmp
argument_list|(
name|old_argv
operator|->
name|dn_ctfp
argument_list|,
name|old_argv
operator|->
name|dn_type
argument_list|,
name|new_argv
operator|->
name|dn_ctfp
argument_list|,
name|new_argv
operator|->
name|dn_type
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|dnerror
argument_list|(
name|pnp
argument_list|,
name|D_PROV_INCOMPAT
argument_list|,
literal|"probe %s:%s %s prototype argument #%u mismatch:\n"
literal|"\t current: %s\n\tprevious: %s\n"
argument_list|,
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|prp
operator|->
name|pr_ident
operator|->
name|di_name
argument_list|,
name|kind
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|dt_node_type_name
argument_list|(
name|new_argv
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
name|old_argv
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compare a new probe declaration with an existing probe definition (either  * from a previous declaration or cached from the kernel).  If the existing  * definition and declaration both have an input and output parameter list,  * compare both lists.  Otherwise compare only the output parameter lists.  */
end_comment

begin_function
specifier|static
name|void
name|dt_node_provider_cmp
parameter_list|(
name|dt_provider_t
modifier|*
name|pvp
parameter_list|,
name|dt_node_t
modifier|*
name|pnp
parameter_list|,
name|dt_probe_t
modifier|*
name|old
parameter_list|,
name|dt_probe_t
modifier|*
name|new
parameter_list|)
block|{
name|dt_node_provider_cmp_argv
argument_list|(
name|pvp
argument_list|,
name|pnp
argument_list|,
literal|"output"
argument_list|,
name|old
operator|->
name|pr_xargc
argument_list|,
name|old
operator|->
name|pr_xargs
argument_list|,
name|new
operator|->
name|pr_xargc
argument_list|,
name|new
operator|->
name|pr_xargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|pr_nargs
operator|!=
name|old
operator|->
name|pr_xargs
operator|&&
name|new
operator|->
name|pr_nargs
operator|!=
name|new
operator|->
name|pr_xargs
condition|)
block|{
name|dt_node_provider_cmp_argv
argument_list|(
name|pvp
argument_list|,
name|pnp
argument_list|,
literal|"input"
argument_list|,
name|old
operator|->
name|pr_nargc
argument_list|,
name|old
operator|->
name|pr_nargs
argument_list|,
name|new
operator|->
name|pr_nargc
argument_list|,
name|new
operator|->
name|pr_nargs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old
operator|->
name|pr_nargs
operator|==
name|old
operator|->
name|pr_xargs
operator|&&
name|new
operator|->
name|pr_nargs
operator|!=
name|new
operator|->
name|pr_xargs
condition|)
block|{
if|if
condition|(
name|pvp
operator|->
name|pv_flags
operator|&
name|DT_PROVIDER_IMPL
condition|)
block|{
name|dnerror
argument_list|(
name|pnp
argument_list|,
name|D_PROV_INCOMPAT
argument_list|,
literal|"provider interface mismatch: %s\n"
literal|"\t current: probe %s:%s has an output prototype\n"
literal|"\tprevious: probe %s:%s has no output prototype\n"
argument_list|,
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|new
operator|->
name|pr_ident
operator|->
name|di_name
argument_list|,
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|old
operator|->
name|pr_ident
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old
operator|->
name|pr_ident
operator|->
name|di_gen
operator|==
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_gen
condition|)
name|old
operator|->
name|pr_ident
operator|->
name|di_flags
operator||=
name|DT_IDFLG_ORPHAN
expr_stmt|;
name|dt_idhash_delete
argument_list|(
name|pvp
operator|->
name|pv_probes
argument_list|,
name|old
operator|->
name|pr_ident
argument_list|)
expr_stmt|;
name|dt_probe_declare
argument_list|(
name|pvp
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cook_probe
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_provider_t
modifier|*
name|pvp
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_probe_t
modifier|*
name|prp
init|=
name|dnp
operator|->
name|dn_ident
operator|->
name|di_data
decl_stmt|;
name|dt_xlator_t
modifier|*
name|dxp
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
name|char
name|n1
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|char
name|n2
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|prp
operator|->
name|pr_nargs
operator|==
name|prp
operator|->
name|pr_xargs
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prp
operator|->
name|pr_xargc
condition|;
name|i
operator|++
control|)
block|{
name|dt_node_t
modifier|*
name|xnp
init|=
name|prp
operator|->
name|pr_xargv
index|[
name|i
index|]
decl_stmt|;
name|dt_node_t
modifier|*
name|nnp
init|=
name|prp
operator|->
name|pr_nargv
index|[
name|prp
operator|->
name|pr_mapping
index|[
name|i
index|]
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|dxp
operator|=
name|dt_xlator_lookup
argument_list|(
name|dtp
argument_list|,
name|nnp
argument_list|,
name|xnp
argument_list|,
name|DT_XLATE_FUZZY
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dt_provider_xref
argument_list|(
name|dtp
argument_list|,
name|pvp
argument_list|,
name|dxp
operator|->
name|dx_id
argument_list|)
operator|!=
literal|0
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dt_node_is_argcompat
argument_list|(
name|nnp
argument_list|,
name|xnp
argument_list|)
condition|)
continue|continue;
comment|/* no translator defined and none required */
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_PROV_PRXLATOR
argument_list|,
literal|"translator for %s:%s output "
literal|"argument #%u from %s to %s is not defined\n"
argument_list|,
name|pvp
operator|->
name|pv_desc
operator|.
name|dtvd_name
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|dt_node_type_name
argument_list|(
name|nnp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
name|xnp
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_cook_provider
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
name|dt_provider_t
modifier|*
name|pvp
init|=
name|dnp
operator|->
name|dn_provider
decl_stmt|;
name|dt_node_t
modifier|*
name|pnp
decl_stmt|;
comment|/* 	 * If we're declaring a provider for the first time and it is unknown 	 * to dtrace(7D), insert the probe definitions into the provider's hash. 	 * If we're redeclaring a known provider, verify the interface matches. 	 */
for|for
control|(
name|pnp
operator|=
name|dnp
operator|->
name|dn_probes
init|;
name|pnp
operator|!=
name|NULL
condition|;
name|pnp
operator|=
name|pnp
operator|->
name|dn_list
control|)
block|{
specifier|const
name|char
modifier|*
name|probename
init|=
name|pnp
operator|->
name|dn_ident
operator|->
name|di_name
decl_stmt|;
name|dt_probe_t
modifier|*
name|prp
init|=
name|dt_probe_lookup
argument_list|(
name|pvp
argument_list|,
name|probename
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_PROBE
argument_list|)
expr_stmt|;
if|if
condition|(
name|prp
operator|!=
name|NULL
operator|&&
name|dnp
operator|->
name|dn_provred
condition|)
block|{
name|dt_node_provider_cmp
argument_list|(
name|pvp
argument_list|,
name|pnp
argument_list|,
name|prp
argument_list|,
name|pnp
operator|->
name|dn_ident
operator|->
name|di_data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prp
operator|==
name|NULL
operator|&&
name|dnp
operator|->
name|dn_provred
condition|)
block|{
name|dnerror
argument_list|(
name|pnp
argument_list|,
name|D_PROV_INCOMPAT
argument_list|,
literal|"provider interface mismatch: %s\n"
literal|"\t current: probe %s:%s defined\n"
literal|"\tprevious: probe %s:%s not defined\n"
argument_list|,
name|dnp
operator|->
name|dn_provname
argument_list|,
name|dnp
operator|->
name|dn_provname
argument_list|,
name|probename
argument_list|,
name|dnp
operator|->
name|dn_provname
argument_list|,
name|probename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prp
operator|!=
name|NULL
condition|)
block|{
name|dnerror
argument_list|(
name|pnp
argument_list|,
name|D_PROV_PRDUP
argument_list|,
literal|"probe redeclared: %s:%s\n"
argument_list|,
name|dnp
operator|->
name|dn_provname
argument_list|,
name|probename
argument_list|)
expr_stmt|;
block|}
else|else
name|dt_probe_declare
argument_list|(
name|pvp
argument_list|,
name|pnp
operator|->
name|dn_ident
operator|->
name|di_data
argument_list|)
expr_stmt|;
name|dt_cook_probe
argument_list|(
name|pnp
argument_list|,
name|pvp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|dt_node_t
modifier|*
name|dt_cook_none
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|dt_node_t
modifier|*
function_decl|(
modifier|*
name|dt_cook_funcs
index|[]
function_decl|)
parameter_list|(
name|dt_node_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|)
init|=
block|{
name|dt_cook_none
operator|,
comment|/* DT_NODE_FREE */
function_decl|dt_cook_none
operator|,
comment|/* DT_NODE_INT */
function_decl|dt_cook_none
operator|,
comment|/* DT_NODE_STRING */
function_decl|dt_cook_ident
operator|,
comment|/* DT_NODE_IDENT */
function_decl|dt_cook_var
operator|,
comment|/* DT_NODE_VAR */
function_decl|dt_cook_none
operator|,
comment|/* DT_NODE_SYM */
function_decl|dt_cook_none
operator|,
comment|/* DT_NODE_TYPE */
function_decl|dt_cook_func
operator|,
comment|/* DT_NODE_FUNC */
function_decl|dt_cook_op1
operator|,
comment|/* DT_NODE_OP1 */
function_decl|dt_cook_op2
operator|,
comment|/* DT_NODE_OP2 */
function_decl|dt_cook_op3
operator|,
comment|/* DT_NODE_OP3 */
function_decl|dt_cook_statement
operator|,
comment|/* DT_NODE_DEXPR */
function_decl|dt_cook_statement
operator|,
comment|/* DT_NODE_DFUNC */
function_decl|dt_cook_aggregation
operator|,
comment|/* DT_NODE_AGG */
function_decl|dt_cook_none
operator|,
comment|/* DT_NODE_PDESC */
function_decl|dt_cook_clause
operator|,
comment|/* DT_NODE_CLAUSE */
function_decl|dt_cook_inline
operator|,
comment|/* DT_NODE_INLINE */
function_decl|dt_cook_member
operator|,
comment|/* DT_NODE_MEMBER */
function_decl|dt_cook_xlator
operator|,
comment|/* DT_NODE_XLATOR */
function_decl|dt_cook_none
operator|,
comment|/* DT_NODE_PROBE */
function_decl|dt_cook_provider
operator|,
comment|/* DT_NODE_PROVIDER */
function_decl|dt_cook_none
end_function_decl

begin_comment
comment|/* DT_NODE_PROG */
end_comment

begin_comment
unit|};
comment|/*  * Recursively cook the parse tree starting at the specified node.  The idflags  * parameter is used to indicate the type of reference (r/w) and is applied to  * the resulting identifier if it is a D variable or D aggregation.  */
end_comment

begin_function
name|dt_node_t
modifier|*
name|dt_node_cook
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
name|int
name|oldlineno
init|=
name|yylineno
decl_stmt|;
name|yylineno
operator|=
name|dnp
operator|->
name|dn_line
expr_stmt|;
name|dnp
operator|=
name|dt_cook_funcs
index|[
name|dnp
operator|->
name|dn_kind
index|]
operator|(
name|dnp
operator|,
name|idflags
operator|)
expr_stmt|;
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_COOKED
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
operator|||
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_AGG
condition|)
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator||=
name|idflags
expr_stmt|;
name|yylineno
operator|=
name|oldlineno
expr_stmt|;
return|return
operator|(
name|dnp
operator|)
return|;
block|}
end_function

begin_function
name|dtrace_attribute_t
name|dt_node_list_cook
parameter_list|(
name|dt_node_t
modifier|*
modifier|*
name|pnp
parameter_list|,
name|uint_t
name|idflags
parameter_list|)
block|{
name|dtrace_attribute_t
name|attr
init|=
name|_dtrace_defattr
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|,
modifier|*
name|nnp
decl_stmt|;
for|for
control|(
name|dnp
operator|=
operator|(
name|pnp
operator|!=
name|NULL
condition|?
operator|*
name|pnp
else|:
name|NULL
operator|)
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|nnp
control|)
block|{
name|nnp
operator|=
name|dnp
operator|->
name|dn_list
expr_stmt|;
name|dnp
operator|=
operator|*
name|pnp
operator|=
name|dt_node_cook
argument_list|(
name|dnp
argument_list|,
name|idflags
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dt_attr_min
argument_list|(
name|attr
argument_list|,
name|dnp
operator|->
name|dn_attr
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_list
operator|=
name|nnp
expr_stmt|;
name|pnp
operator|=
operator|&
name|dnp
operator|->
name|dn_list
expr_stmt|;
block|}
return|return
operator|(
name|attr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_node_list_free
parameter_list|(
name|dt_node_t
modifier|*
modifier|*
name|pnp
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
decl_stmt|,
modifier|*
name|nnp
decl_stmt|;
for|for
control|(
name|dnp
operator|=
operator|(
name|pnp
operator|!=
name|NULL
condition|?
operator|*
name|pnp
else|:
name|NULL
operator|)
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|nnp
control|)
block|{
name|nnp
operator|=
name|dnp
operator|->
name|dn_list
expr_stmt|;
name|dt_node_free
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pnp
operator|!=
name|NULL
condition|)
operator|*
name|pnp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_node_link_free
parameter_list|(
name|dt_node_t
modifier|*
modifier|*
name|pnp
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
decl_stmt|,
modifier|*
name|nnp
decl_stmt|;
for|for
control|(
name|dnp
operator|=
operator|(
name|pnp
operator|!=
name|NULL
condition|?
operator|*
name|pnp
else|:
name|NULL
operator|)
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|nnp
control|)
block|{
name|nnp
operator|=
name|dnp
operator|->
name|dn_link
expr_stmt|;
name|dt_node_free
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|dnp
operator|=
operator|(
name|pnp
operator|!=
name|NULL
condition|?
operator|*
name|pnp
else|:
name|NULL
operator|)
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|nnp
control|)
block|{
name|nnp
operator|=
name|dnp
operator|->
name|dn_link
expr_stmt|;
name|free
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pnp
operator|!=
name|NULL
condition|)
operator|*
name|pnp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_node_link
parameter_list|(
name|dt_node_t
modifier|*
name|lp
parameter_list|,
name|dt_node_t
modifier|*
name|rp
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
return|return
operator|(
name|rp
operator|)
return|;
elseif|else
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
return|return
operator|(
name|lp
operator|)
return|;
for|for
control|(
name|dnp
operator|=
name|lp
init|;
name|dnp
operator|->
name|dn_list
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
control|)
continue|continue;
name|dnp
operator|->
name|dn_list
operator|=
name|rp
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the DOF dtrace_diftype_t representation of a node's type.  This is  * called from a variety of places in the library so it cannot assume yypcb  * is valid: any references to handle-specific data must be made through 'dtp'.  */
end_comment

begin_function
name|void
name|dt_node_diftype
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dtrace_diftype_t
modifier|*
name|tp
parameter_list|)
block|{
if|if
condition|(
name|dnp
operator|->
name|dn_ctfp
operator|==
name|DT_STR_CTFP
argument_list|(
name|dtp
argument_list|)
operator|&&
name|dnp
operator|->
name|dn_type
operator|==
name|DT_STR_TYPE
argument_list|(
name|dtp
argument_list|)
condition|)
block|{
name|tp
operator|->
name|dtdt_kind
operator|=
name|DIF_TYPE_STRING
expr_stmt|;
name|tp
operator|->
name|dtdt_ckind
operator|=
name|CTF_K_UNKNOWN
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|dtdt_kind
operator|=
name|DIF_TYPE_CTF
expr_stmt|;
name|tp
operator|->
name|dtdt_ckind
operator|=
name|ctf_type_kind
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|ctf_type_resolve
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|dtdt_flags
operator|=
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_REF
operator|)
condition|?
name|DIF_TF_BYREF
else|:
literal|0
expr_stmt|;
name|tp
operator|->
name|dtdt_pad
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|dtdt_size
operator|=
name|ctf_type_size
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_node_printr
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|a
index|[
literal|8
index|]
decl_stmt|;
specifier|const
name|dtrace_syminfo_t
modifier|*
name|dts
decl_stmt|;
specifier|const
name|dt_idnode_t
modifier|*
name|inp
decl_stmt|;
name|dt_node_t
modifier|*
name|arg
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s"
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_attr_str
argument_list|(
name|dnp
operator|->
name|dn_attr
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_ctfp
operator|!=
name|NULL
operator|&&
name|dnp
operator|->
name|dn_type
operator|!=
name|CTF_ERR
operator|&&
name|ctf_type_name
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
literal|"type=<%s> attr=%s flags="
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
literal|"type=<%ld> attr=%s flags="
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|!=
literal|0
condition|)
block|{
name|n
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|n
argument_list|,
literal|",SIGN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_COOKED
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|n
argument_list|,
literal|",COOK"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_REF
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|n
argument_list|,
literal|",REF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_LVALUE
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|n
argument_list|,
literal|",LVAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_WRITABLE
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|n
argument_list|,
literal|",WRITE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_BITFIELD
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|n
argument_list|,
literal|",BITF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|n
argument_list|,
literal|",USER"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dnp
operator|->
name|dn_kind
condition|)
block|{
case|case
name|DT_NODE_FREE
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"FREE<node %p>\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dnp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_INT
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"INT 0x%llx (%s)\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|dnp
operator|->
name|dn_value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_STRING
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"STRING \"%s\" (%s)\n"
argument_list|,
name|dnp
operator|->
name|dn_string
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_IDENT
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"IDENT %s (%s)\n"
argument_list|,
name|dnp
operator|->
name|dn_string
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_VAR
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"VARIABLE %s%s (%s)\n"
argument_list|,
operator|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator|&
name|DT_IDFLG_LOCAL
operator|)
condition|?
literal|"this->"
else|:
operator|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator|&
name|DT_IDFLG_TLS
operator|)
condition|?
literal|"self->"
else|:
literal|""
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_args
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s[\n"
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
block|{
name|dt_node_printr
argument_list|(
name|arg
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|dn_list
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s,\n"
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dnp
operator|->
name|dn_args
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s]\n"
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_SYM
case|:
name|dts
operator|=
name|dnp
operator|->
name|dn_ident
operator|->
name|di_data
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"SYMBOL %s`%s (%s)\n"
argument_list|,
name|dts
operator|->
name|dts_object
argument_list|,
name|dts
operator|->
name|dts_name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_TYPE
case|:
if|if
condition|(
name|dnp
operator|->
name|dn_string
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"TYPE (%s) %s\n"
argument_list|,
name|buf
argument_list|,
name|dnp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"TYPE (%s)\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_FUNC
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"FUNC %s (%s)\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
block|{
name|dt_node_printr
argument_list|(
name|arg
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|dn_list
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s,\n"
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_NODE_OP1
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"OP1 %s (%s)\n"
argument_list|,
name|opstr
argument_list|(
name|dnp
operator|->
name|dn_op
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|dt_node_printr
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_OP2
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"OP2 %s (%s)\n"
argument_list|,
name|opstr
argument_list|(
name|dnp
operator|->
name|dn_op
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|dt_node_printr
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dt_node_printr
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_OP3
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"OP3 (%s)\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|dt_node_printr
argument_list|(
name|dnp
operator|->
name|dn_expr
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s?\n"
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|dt_node_printr
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s:\n"
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|dt_node_printr
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_DEXPR
case|:
case|case
name|DT_NODE_DFUNC
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"D EXPRESSION attr=%s\n"
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|dt_node_printr
argument_list|(
name|dnp
operator|->
name|dn_expr
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_AGG
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"AGGREGATE @%s attr=%s [\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|a
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_aggtup
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
block|{
name|dt_node_printr
argument_list|(
name|arg
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|dn_list
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s,\n"
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dnp
operator|->
name|dn_aggfun
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s] = "
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|dt_node_printr
argument_list|(
name|dnp
operator|->
name|dn_aggfun
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s]\n"
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_aggfun
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s)\n"
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_PDESC
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"PDESC %s:%s:%s:%s [%u]\n"
argument_list|,
name|dnp
operator|->
name|dn_desc
operator|->
name|dtpd_provider
argument_list|,
name|dnp
operator|->
name|dn_desc
operator|->
name|dtpd_mod
argument_list|,
name|dnp
operator|->
name|dn_desc
operator|->
name|dtpd_func
argument_list|,
name|dnp
operator|->
name|dn_desc
operator|->
name|dtpd_name
argument_list|,
name|dnp
operator|->
name|dn_desc
operator|->
name|dtpd_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_CLAUSE
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"CLAUSE attr=%s\n"
argument_list|,
name|a
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_pdescs
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
name|dt_node_printr
argument_list|(
name|arg
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*sCTXATTR %s\n"
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|,
name|dt_attr_str
argument_list|(
name|dnp
operator|->
name|dn_ctxattr
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_pred
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*sPREDICATE /\n"
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|dt_node_printr
argument_list|(
name|dnp
operator|->
name|dn_pred
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%*s/\n"
argument_list|,
name|depth
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_acts
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
name|dt_node_printr
argument_list|(
name|arg
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_INLINE
case|:
name|inp
operator|=
name|dnp
operator|->
name|dn_ident
operator|->
name|di_iarg
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"INLINE %s (%s)\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|dt_node_printr
argument_list|(
name|inp
operator|->
name|din_root
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_MEMBER
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"MEMBER %s (%s)\n"
argument_list|,
name|dnp
operator|->
name|dn_membname
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_membexpr
condition|)
name|dt_node_printr
argument_list|(
name|dnp
operator|->
name|dn_membexpr
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_XLATOR
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"XLATOR (%s)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctf_type_name
argument_list|(
name|dnp
operator|->
name|dn_xlator
operator|->
name|dx_src_ctfp
argument_list|,
name|dnp
operator|->
name|dn_xlator
operator|->
name|dx_src_type
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" from<%s>"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctf_type_name
argument_list|(
name|dnp
operator|->
name|dn_xlator
operator|->
name|dx_dst_ctfp
argument_list|,
name|dnp
operator|->
name|dn_xlator
operator|->
name|dx_dst_type
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" to<%s>"
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_members
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
name|dt_node_printr
argument_list|(
name|arg
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_PROBE
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"PROBE %s\n"
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_PROVIDER
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"PROVIDER %s (%s)\n"
argument_list|,
name|dnp
operator|->
name|dn_provname
argument_list|,
name|dnp
operator|->
name|dn_provred
condition|?
literal|"redecl"
else|:
literal|"decl"
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_probes
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
name|dt_node_printr
argument_list|(
name|arg
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_PROG
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"PROGRAM attr=%s\n"
argument_list|,
name|a
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|dnp
operator|->
name|dn_list
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|dn_list
control|)
name|dt_node_printr
argument_list|(
name|arg
argument_list|,
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"<bad node %p, kind %d>\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dnp
argument_list|,
name|dnp
operator|->
name|dn_kind
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|dt_node_root
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|yypcb
operator|->
name|pcb_root
operator|=
name|dnp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE3*/
end_comment

begin_function
name|void
name|dnerror
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_errtag_t
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|oldlineno
init|=
name|yylineno
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|yylineno
operator|=
name|dnp
operator|->
name|dn_line
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|xyvwarn
argument_list|(
name|tag
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|yylineno
operator|=
name|oldlineno
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE3*/
end_comment

begin_function
name|void
name|dnwarn
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_errtag_t
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|oldlineno
init|=
name|yylineno
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|yylineno
operator|=
name|dnp
operator|->
name|dn_line
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|xyvwarn
argument_list|(
name|tag
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|yylineno
operator|=
name|oldlineno
expr_stmt|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE2*/
end_comment

begin_function
name|void
name|xyerror
parameter_list|(
name|dt_errtag_t
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|xyvwarn
argument_list|(
name|tag
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE2*/
end_comment

begin_function
name|void
name|xywarn
parameter_list|(
name|dt_errtag_t
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|xyvwarn
argument_list|(
name|tag
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xyvwarn
parameter_list|(
name|dt_errtag_t
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
if|if
condition|(
name|yypcb
operator|==
name|NULL
condition|)
return|return;
comment|/* compiler is not currently active: act as a no-op */
name|dt_set_errmsg
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|,
name|dt_errtag
argument_list|(
name|tag
argument_list|)
argument_list|,
name|yypcb
operator|->
name|pcb_region
argument_list|,
name|yypcb
operator|->
name|pcb_filetag
argument_list|,
name|yypcb
operator|->
name|pcb_fileptr
condition|?
name|yylineno
else|:
literal|0
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE1*/
end_comment

begin_function
name|void
name|yyerror
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|yyvwarn
argument_list|(
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE1*/
end_comment

begin_function
name|void
name|yywarn
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|yyvwarn
argument_list|(
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|yyvwarn
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
if|if
condition|(
name|yypcb
operator|==
name|NULL
condition|)
return|return;
comment|/* compiler is not currently active: act as a no-op */
name|dt_set_errmsg
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|,
name|dt_errtag
argument_list|(
name|D_SYNTAX
argument_list|)
argument_list|,
name|yypcb
operator|->
name|pcb_region
argument_list|,
name|yypcb
operator|->
name|pcb_filetag
argument_list|,
name|yypcb
operator|->
name|pcb_fileptr
condition|?
name|yylineno
else|:
literal|0
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|format
argument_list|,
literal|'\n'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|dtp
operator|->
name|dt_errmsg
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
init|=
name|dtp
operator|->
name|dt_errmsg
operator|+
name|len
decl_stmt|;
name|size_t
name|n
init|=
sizeof|sizeof
argument_list|(
name|dtp
operator|->
name|dt_errmsg
argument_list|)
operator|-
name|len
decl_stmt|;
if|if
condition|(
name|yytext
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
literal|" near end of input"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yytext
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
literal|" near end of line"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|yytext
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* crop at newline */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
literal|" near \"%s\""
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|yylabel
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
name|dt_dprintf
argument_list|(
literal|"set label to<%s>\n"
argument_list|,
name|label
condition|?
name|label
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
name|yypcb
operator|->
name|pcb_region
operator|=
name|label
expr_stmt|;
block|}
end_function

begin_function
name|int
name|yywrap
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* indicate that lex should return a zero token for EOF */
block|}
end_function

end_unit

