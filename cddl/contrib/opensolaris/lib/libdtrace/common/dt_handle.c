begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_include
include|#
directive|include
file|<dt_program.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|_dt_errprog
index|[]
init|=
literal|"dtrace:::ERROR"
literal|"{"
literal|"	trace(arg1);"
literal|"	trace(arg2);"
literal|"	trace(arg3);"
literal|"	trace(arg4);"
literal|"	trace(arg5);"
literal|"}"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|dtrace_handle_err
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_handle_err_f
modifier|*
name|hdlr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_prog_t
modifier|*
name|pgp
init|=
name|NULL
decl_stmt|;
name|dt_stmt_t
modifier|*
name|stp
decl_stmt|;
name|dtrace_ecbdesc_t
modifier|*
name|edp
decl_stmt|;
comment|/* 	 * We don't currently support multiple error handlers. 	 */
if|if
condition|(
name|dtp
operator|->
name|dt_errhdlr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EALREADY
argument_list|)
operator|)
return|;
comment|/* 	 * If the DTRACEOPT_GRABANON is enabled, the anonymous enabling will 	 * already have a dtrace:::ERROR probe enabled; save 'hdlr' and 'arg' 	 * but do not bother compiling and enabling _dt_errprog. 	 */
if|if
condition|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_GRABANON
index|]
operator|!=
name|DTRACEOPT_UNSET
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|pgp
operator|=
name|dtrace_program_strcompile
argument_list|(
name|dtp
argument_list|,
name|_dt_errprog
argument_list|,
name|DTRACE_PROBESPEC_NAME
argument_list|,
name|DTRACE_C_ZDEFS
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
operator|)
return|;
name|stp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|pgp
operator|->
name|dp_stmts
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|stp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|edp
operator|=
name|stp
operator|->
name|ds_desc
operator|->
name|dtsd_ecbdesc
expr_stmt|;
name|assert
argument_list|(
name|edp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|edp
operator|->
name|dted_uarg
operator|=
name|DT_ECB_ERROR
expr_stmt|;
name|out
label|:
name|dtp
operator|->
name|dt_errhdlr
operator|=
name|hdlr
expr_stmt|;
name|dtp
operator|->
name|dt_errarg
operator|=
name|arg
expr_stmt|;
name|dtp
operator|->
name|dt_errprog
operator|=
name|pgp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_handle_drop
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_handle_drop_f
modifier|*
name|hdlr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|dtp
operator|->
name|dt_drophdlr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EALREADY
argument_list|)
operator|)
return|;
name|dtp
operator|->
name|dt_drophdlr
operator|=
name|hdlr
expr_stmt|;
name|dtp
operator|->
name|dt_droparg
operator|=
name|arg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_handle_proc
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_handle_proc_f
modifier|*
name|hdlr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|dtp
operator|->
name|dt_prochdlr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EALREADY
argument_list|)
operator|)
return|;
name|dtp
operator|->
name|dt_prochdlr
operator|=
name|hdlr
expr_stmt|;
name|dtp
operator|->
name|dt_procarg
operator|=
name|arg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_handle_buffered
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_handle_buffered_f
modifier|*
name|hdlr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|dtp
operator|->
name|dt_bufhdlr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EALREADY
argument_list|)
operator|)
return|;
if|if
condition|(
name|hdlr
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
name|dtp
operator|->
name|dt_bufhdlr
operator|=
name|hdlr
expr_stmt|;
name|dtp
operator|->
name|dt_bufarg
operator|=
name|arg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_handle_setopt
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_handle_setopt_f
modifier|*
name|hdlr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|hdlr
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
name|dtp
operator|->
name|dt_setopthdlr
operator|=
name|hdlr
expr_stmt|;
name|dtp
operator|->
name|dt_setoptarg
operator|=
name|arg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DT_REC
parameter_list|(
name|type
parameter_list|,
name|ndx
parameter_list|)
value|*((type *)((uintptr_t)data->dtpda_data + \     epd->dtepd_rec[(ndx)].dtrd_offset))
end_define

begin_function
specifier|static
name|int
name|dt_handle_err
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_probedata_t
modifier|*
name|data
parameter_list|)
block|{
name|dtrace_eprobedesc_t
modifier|*
name|epd
init|=
name|data
operator|->
name|dtpda_edesc
decl_stmt|,
modifier|*
name|errepd
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
name|pd
init|=
name|data
operator|->
name|dtpda_pdesc
decl_stmt|,
modifier|*
name|errpd
decl_stmt|;
name|dtrace_errdata_t
name|err
decl_stmt|;
name|dtrace_epid_t
name|epid
decl_stmt|;
name|char
name|where
index|[
literal|30
index|]
decl_stmt|;
name|char
name|details
index|[
literal|30
index|]
decl_stmt|;
name|char
name|offinfo
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|int
name|slop
init|=
literal|80
decl_stmt|;
specifier|const
name|char
modifier|*
name|faultstr
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
name|assert
argument_list|(
name|epd
operator|->
name|dtepd_uarg
operator|==
name|DT_ECB_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|epd
operator|->
name|dtepd_nrecs
operator|!=
literal|5
operator|||
name|strcmp
argument_list|(
name|pd
operator|->
name|dtpd_provider
argument_list|,
literal|"dtrace"
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|pd
operator|->
name|dtpd_name
argument_list|,
literal|"ERROR"
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADERROR
argument_list|)
operator|)
return|;
comment|/* 	 * This is an error.  We have the following items here:  EPID, 	 * faulting action, DIF offset, fault code and faulting address. 	 */
name|epid
operator|=
operator|(
name|uint32_t
operator|)
name|DT_REC
argument_list|(
name|uint64_t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_epid_lookup
argument_list|(
name|dtp
argument_list|,
name|epid
argument_list|,
operator|&
name|errepd
argument_list|,
operator|&
name|errpd
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADERROR
argument_list|)
operator|)
return|;
name|err
operator|.
name|dteda_edesc
operator|=
name|errepd
expr_stmt|;
name|err
operator|.
name|dteda_pdesc
operator|=
name|errpd
expr_stmt|;
name|err
operator|.
name|dteda_cpu
operator|=
name|data
operator|->
name|dtpda_cpu
expr_stmt|;
name|err
operator|.
name|dteda_action
operator|=
operator|(
name|int
operator|)
name|DT_REC
argument_list|(
name|uint64_t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|err
operator|.
name|dteda_offset
operator|=
operator|(
name|int
operator|)
name|DT_REC
argument_list|(
name|uint64_t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|err
operator|.
name|dteda_fault
operator|=
operator|(
name|int
operator|)
name|DT_REC
argument_list|(
name|uint64_t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|err
operator|.
name|dteda_addr
operator|=
name|DT_REC
argument_list|(
name|uint64_t
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|faultstr
operator|=
name|dtrace_faultstr
argument_list|(
name|dtp
argument_list|,
name|err
operator|.
name|dteda_fault
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|where
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|offinfo
argument_list|)
operator|+
name|strlen
argument_list|(
name|faultstr
argument_list|)
operator|+
name|strlen
argument_list|(
name|errpd
operator|->
name|dtpd_provider
argument_list|)
operator|+
name|strlen
argument_list|(
name|errpd
operator|->
name|dtpd_mod
argument_list|)
operator|+
name|strlen
argument_list|(
name|errpd
operator|->
name|dtpd_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|errpd
operator|->
name|dtpd_func
argument_list|)
operator|+
name|slop
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|dteda_action
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|where
argument_list|,
literal|"predicate"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|where
argument_list|,
literal|"action #%d"
argument_list|,
name|err
operator|.
name|dteda_action
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|.
name|dteda_offset
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|offinfo
argument_list|,
literal|" at DIF offset %d"
argument_list|,
name|err
operator|.
name|dteda_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offinfo
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|err
operator|.
name|dteda_fault
condition|)
block|{
case|case
name|DTRACEFLT_BADADDR
case|:
case|case
name|DTRACEFLT_BADALIGN
case|:
case|case
name|DTRACEFLT_BADSTACK
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|details
argument_list|,
literal|" (0x%llx)"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|err
operator|.
name|dteda_addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|details
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
literal|"error on enabled probe ID %u "
literal|"(ID %u: %s:%s:%s:%s): %s%s in %s%s\n"
argument_list|,
name|epid
argument_list|,
name|errpd
operator|->
name|dtpd_id
argument_list|,
name|errpd
operator|->
name|dtpd_provider
argument_list|,
name|errpd
operator|->
name|dtpd_mod
argument_list|,
name|errpd
operator|->
name|dtpd_func
argument_list|,
name|errpd
operator|->
name|dtpd_name
argument_list|,
name|dtrace_faultstr
argument_list|(
name|dtp
argument_list|,
name|err
operator|.
name|dteda_fault
argument_list|)
argument_list|,
name|details
argument_list|,
name|where
argument_list|,
name|offinfo
argument_list|)
expr_stmt|;
name|err
operator|.
name|dteda_msg
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_errhdlr
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_ERRABORT
argument_list|)
operator|)
return|;
if|if
condition|(
call|(
modifier|*
name|dtp
operator|->
name|dt_errhdlr
call|)
argument_list|(
operator|&
name|err
argument_list|,
name|dtp
operator|->
name|dt_errarg
argument_list|)
operator|==
name|DTRACE_HANDLE_ABORT
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_ERRABORT
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_handle_liberr
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dtrace_probedata_t
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|faultstr
parameter_list|)
block|{
name|dtrace_probedesc_t
modifier|*
name|errpd
init|=
name|data
operator|->
name|dtpda_pdesc
decl_stmt|;
name|dtrace_errdata_t
name|err
decl_stmt|;
specifier|const
name|int
name|slop
init|=
literal|80
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
name|err
operator|.
name|dteda_edesc
operator|=
name|data
operator|->
name|dtpda_edesc
expr_stmt|;
name|err
operator|.
name|dteda_pdesc
operator|=
name|errpd
expr_stmt|;
name|err
operator|.
name|dteda_cpu
operator|=
name|data
operator|->
name|dtpda_cpu
expr_stmt|;
name|err
operator|.
name|dteda_action
operator|=
operator|-
literal|1
expr_stmt|;
name|err
operator|.
name|dteda_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|err
operator|.
name|dteda_fault
operator|=
name|DTRACEFLT_LIBRARY
expr_stmt|;
name|err
operator|.
name|dteda_addr
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|faultstr
argument_list|)
operator|+
name|strlen
argument_list|(
name|errpd
operator|->
name|dtpd_provider
argument_list|)
operator|+
name|strlen
argument_list|(
name|errpd
operator|->
name|dtpd_mod
argument_list|)
operator|+
name|strlen
argument_list|(
name|errpd
operator|->
name|dtpd_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|errpd
operator|->
name|dtpd_func
argument_list|)
operator|+
name|slop
expr_stmt|;
name|str
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
literal|"error on enabled probe ID %u "
literal|"(ID %u: %s:%s:%s:%s): %s\n"
argument_list|,
name|data
operator|->
name|dtpda_edesc
operator|->
name|dtepd_epid
argument_list|,
name|errpd
operator|->
name|dtpd_id
argument_list|,
name|errpd
operator|->
name|dtpd_provider
argument_list|,
name|errpd
operator|->
name|dtpd_mod
argument_list|,
name|errpd
operator|->
name|dtpd_func
argument_list|,
name|errpd
operator|->
name|dtpd_name
argument_list|,
name|faultstr
argument_list|)
expr_stmt|;
name|err
operator|.
name|dteda_msg
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_errhdlr
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_ERRABORT
argument_list|)
operator|)
return|;
if|if
condition|(
call|(
modifier|*
name|dtp
operator|->
name|dt_errhdlr
call|)
argument_list|(
operator|&
name|err
argument_list|,
name|dtp
operator|->
name|dt_errarg
argument_list|)
operator|==
name|DTRACE_HANDLE_ABORT
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_ERRABORT
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DROPTAG
parameter_list|(
name|x
parameter_list|)
value|x, #x
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|dtrace_dropkind_t
name|dtdrg_kind
decl_stmt|;
name|char
modifier|*
name|dtdrg_tag
decl_stmt|;
block|}
name|_dt_droptags
index|[]
init|=
block|{
block|{
name|DROPTAG
argument_list|(
argument|DTRACEDROP_PRINCIPAL
argument_list|)
block|}
block|,
block|{
name|DROPTAG
argument_list|(
argument|DTRACEDROP_AGGREGATION
argument_list|)
block|}
block|,
block|{
name|DROPTAG
argument_list|(
argument|DTRACEDROP_DYNAMIC
argument_list|)
block|}
block|,
block|{
name|DROPTAG
argument_list|(
argument|DTRACEDROP_DYNRINSE
argument_list|)
block|}
block|,
block|{
name|DROPTAG
argument_list|(
argument|DTRACEDROP_DYNDIRTY
argument_list|)
block|}
block|,
block|{
name|DROPTAG
argument_list|(
argument|DTRACEDROP_SPEC
argument_list|)
block|}
block|,
block|{
name|DROPTAG
argument_list|(
argument|DTRACEDROP_SPECBUSY
argument_list|)
block|}
block|,
block|{
name|DROPTAG
argument_list|(
argument|DTRACEDROP_SPECUNAVAIL
argument_list|)
block|}
block|,
block|{
name|DROPTAG
argument_list|(
argument|DTRACEDROP_DBLERROR
argument_list|)
block|}
block|,
block|{
name|DROPTAG
argument_list|(
argument|DTRACEDROP_STKSTROVERFLOW
argument_list|)
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dt_droptag
parameter_list|(
name|dtrace_dropkind_t
name|kind
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|_dt_droptags
index|[
name|i
index|]
operator|.
name|dtdrg_tag
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_dt_droptags
index|[
name|i
index|]
operator|.
name|dtdrg_kind
operator|==
name|kind
condition|)
return|return
operator|(
name|_dt_droptags
index|[
name|i
index|]
operator|.
name|dtdrg_tag
operator|)
return|;
block|}
return|return
operator|(
literal|"DTRACEDROP_UNKNOWN"
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_handle_cpudrop
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|processorid_t
name|cpu
parameter_list|,
name|dtrace_dropkind_t
name|what
parameter_list|,
name|uint64_t
name|howmany
parameter_list|)
block|{
name|dtrace_dropdata_t
name|drop
decl_stmt|;
name|char
name|str
index|[
literal|80
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|size
decl_stmt|;
name|assert
argument_list|(
name|what
operator|==
name|DTRACEDROP_PRINCIPAL
operator|||
name|what
operator|==
name|DTRACEDROP_AGGREGATION
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|drop
argument_list|,
sizeof|sizeof
argument_list|(
name|drop
argument_list|)
argument_list|)
expr_stmt|;
name|drop
operator|.
name|dtdda_handle
operator|=
name|dtp
expr_stmt|;
name|drop
operator|.
name|dtdda_cpu
operator|=
name|cpu
expr_stmt|;
name|drop
operator|.
name|dtdda_kind
operator|=
name|what
expr_stmt|;
name|drop
operator|.
name|dtdda_drops
operator|=
name|howmany
expr_stmt|;
name|drop
operator|.
name|dtdda_msg
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_droptags
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"[%s] "
argument_list|,
name|dt_droptag
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
operator|&
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
index|]
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|str
argument_list|)
operator|-
operator|(
name|s
operator|-
name|str
operator|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|str
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|size
argument_list|,
literal|"%llu %sdrop%s on CPU %d\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|howmany
argument_list|,
name|what
operator|==
name|DTRACEDROP_PRINCIPAL
condition|?
literal|""
else|:
literal|"aggregation "
argument_list|,
name|howmany
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_drophdlr
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DROPABORT
argument_list|)
operator|)
return|;
if|if
condition|(
call|(
modifier|*
name|dtp
operator|->
name|dt_drophdlr
call|)
argument_list|(
operator|&
name|drop
argument_list|,
name|dtp
operator|->
name|dt_droparg
argument_list|)
operator|==
name|DTRACE_HANDLE_ABORT
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DROPABORT
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|dtrace_dropkind_t
name|dtdrt_kind
decl_stmt|;
name|uintptr_t
name|dtdrt_offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|dtdrt_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|dtdrt_msg
decl_stmt|;
block|}
name|_dt_droptab
index|[]
init|=
block|{
block|{
name|DTRACEDROP_DYNAMIC
block|,
name|offsetof
argument_list|(
name|dtrace_status_t
argument_list|,
name|dtst_dyndrops
argument_list|)
block|,
literal|"dynamic variable drop"
block|}
block|,
block|{
name|DTRACEDROP_DYNRINSE
block|,
name|offsetof
argument_list|(
name|dtrace_status_t
argument_list|,
name|dtst_dyndrops_rinsing
argument_list|)
block|,
literal|"dynamic variable drop"
block|,
literal|" with non-empty rinsing list"
block|}
block|,
block|{
name|DTRACEDROP_DYNDIRTY
block|,
name|offsetof
argument_list|(
name|dtrace_status_t
argument_list|,
name|dtst_dyndrops_dirty
argument_list|)
block|,
literal|"dynamic variable drop"
block|,
literal|" with non-empty dirty list"
block|}
block|,
block|{
name|DTRACEDROP_SPEC
block|,
name|offsetof
argument_list|(
name|dtrace_status_t
argument_list|,
name|dtst_specdrops
argument_list|)
block|,
literal|"speculative drop"
block|}
block|,
block|{
name|DTRACEDROP_SPECBUSY
block|,
name|offsetof
argument_list|(
name|dtrace_status_t
argument_list|,
name|dtst_specdrops_busy
argument_list|)
block|,
literal|"failed speculation"
block|,
literal|" (available buffer(s) still busy)"
block|}
block|,
block|{
name|DTRACEDROP_SPECUNAVAIL
block|,
name|offsetof
argument_list|(
name|dtrace_status_t
argument_list|,
name|dtst_specdrops_unavail
argument_list|)
block|,
literal|"failed speculation"
block|,
literal|" (no speculative buffer available)"
block|}
block|,
block|{
name|DTRACEDROP_STKSTROVERFLOW
block|,
name|offsetof
argument_list|(
name|dtrace_status_t
argument_list|,
name|dtst_stkstroverflows
argument_list|)
block|,
literal|"jstack()/ustack() string table overflow"
block|}
block|,
block|{
name|DTRACEDROP_DBLERROR
block|,
name|offsetof
argument_list|(
name|dtrace_status_t
argument_list|,
name|dtst_dblerrors
argument_list|)
block|,
literal|"error"
block|,
literal|" in ERROR probe enabling"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
name|int
name|dt_handle_status
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_status_t
modifier|*
name|old
parameter_list|,
name|dtrace_status_t
modifier|*
name|new
parameter_list|)
block|{
name|dtrace_dropdata_t
name|drop
decl_stmt|;
name|char
name|str
index|[
literal|80
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|uintptr_t
name|base
init|=
operator|(
name|uintptr_t
operator|)
name|new
decl_stmt|,
name|obase
init|=
operator|(
name|uintptr_t
operator|)
name|old
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|drop
argument_list|,
sizeof|sizeof
argument_list|(
name|drop
argument_list|)
argument_list|)
expr_stmt|;
name|drop
operator|.
name|dtdda_handle
operator|=
name|dtp
expr_stmt|;
name|drop
operator|.
name|dtdda_cpu
operator|=
name|DTRACE_CPUALL
expr_stmt|;
name|drop
operator|.
name|dtdda_msg
operator|=
name|str
expr_stmt|;
comment|/* 	 * First, check to see if we've been killed -- in which case we abort. 	 */
if|if
condition|(
name|new
operator|->
name|dtst_killed
operator|&&
operator|!
name|old
operator|->
name|dtst_killed
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BRICKED
argument_list|)
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|_dt_droptab
index|[
name|i
index|]
operator|.
name|dtdrt_str
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|uintptr_t
name|naddr
init|=
name|base
operator|+
name|_dt_droptab
index|[
name|i
index|]
operator|.
name|dtdrt_offset
decl_stmt|;
name|uintptr_t
name|oaddr
init|=
name|obase
operator|+
name|_dt_droptab
index|[
name|i
index|]
operator|.
name|dtdrt_offset
decl_stmt|;
name|uint64_t
name|nval
init|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|naddr
operator|)
decl_stmt|;
name|uint64_t
name|oval
init|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|oaddr
operator|)
decl_stmt|;
if|if
condition|(
name|nval
operator|==
name|oval
condition|)
continue|continue;
if|if
condition|(
name|dtp
operator|->
name|dt_droptags
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"[%s] "
argument_list|,
name|dt_droptag
argument_list|(
name|_dt_droptab
index|[
name|i
index|]
operator|.
name|dtdrt_kind
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
operator|&
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
index|]
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|str
argument_list|)
operator|-
operator|(
name|s
operator|-
name|str
operator|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|str
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|size
argument_list|,
literal|"%llu %s%s%s\n"
argument_list|,
call|(
name|u_longlong_t
call|)
argument_list|(
name|nval
operator|-
name|oval
argument_list|)
argument_list|,
name|_dt_droptab
index|[
name|i
index|]
operator|.
name|dtdrt_str
argument_list|,
operator|(
name|nval
operator|-
name|oval
operator|>
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|_dt_droptab
index|[
name|i
index|]
operator|.
name|dtdrt_msg
operator|!=
name|NULL
condition|?
name|_dt_droptab
index|[
name|i
index|]
operator|.
name|dtdrt_msg
else|:
literal|""
argument_list|)
expr_stmt|;
name|drop
operator|.
name|dtdda_kind
operator|=
name|_dt_droptab
index|[
name|i
index|]
operator|.
name|dtdrt_kind
expr_stmt|;
name|drop
operator|.
name|dtdda_total
operator|=
name|nval
expr_stmt|;
name|drop
operator|.
name|dtdda_drops
operator|=
name|nval
operator|-
name|oval
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_drophdlr
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DROPABORT
argument_list|)
operator|)
return|;
if|if
condition|(
call|(
modifier|*
name|dtp
operator|->
name|dt_drophdlr
call|)
argument_list|(
operator|&
name|drop
argument_list|,
name|dtp
operator|->
name|dt_droparg
argument_list|)
operator|==
name|DTRACE_HANDLE_ABORT
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DROPABORT
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_handle_setopt
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_setoptdata_t
modifier|*
name|data
parameter_list|)
block|{
name|void
modifier|*
name|arg
init|=
name|dtp
operator|->
name|dt_setoptarg
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_setopthdlr
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
call|(
modifier|*
name|dtp
operator|->
name|dt_setopthdlr
call|)
argument_list|(
name|data
argument_list|,
name|arg
argument_list|)
operator|==
name|DTRACE_HANDLE_ABORT
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DIRABORT
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_handle
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_probedata_t
modifier|*
name|data
parameter_list|)
block|{
name|dtrace_eprobedesc_t
modifier|*
name|epd
init|=
name|data
operator|->
name|dtpda_edesc
decl_stmt|;
name|int
name|rval
decl_stmt|;
switch|switch
condition|(
name|epd
operator|->
name|dtepd_uarg
condition|)
block|{
case|case
name|DT_ECB_ERROR
case|:
name|rval
operator|=
name|dt_handle_err
argument_list|(
name|dtp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|DTRACE_CONSUME_THIS
operator|)
return|;
block|}
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
return|return
operator|(
name|DTRACE_CONSUME_NEXT
operator|)
return|;
return|return
operator|(
name|DTRACE_CONSUME_ERROR
operator|)
return|;
block|}
end_function

end_unit

