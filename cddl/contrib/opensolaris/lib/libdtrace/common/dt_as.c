begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_include
include|#
directive|include
file|<dt_parser.h>
end_include

begin_include
include|#
directive|include
file|<dt_as.h>
end_include

begin_function
name|void
name|dt_irlist_create
parameter_list|(
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|)
block|{
name|bzero
argument_list|(
name|dlp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_irlist_t
argument_list|)
argument_list|)
expr_stmt|;
name|dlp
operator|->
name|dl_label
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_irlist_destroy
parameter_list|(
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|)
block|{
name|dt_irnode_t
modifier|*
name|dip
decl_stmt|,
modifier|*
name|nip
decl_stmt|;
for|for
control|(
name|dip
operator|=
name|dlp
operator|->
name|dl_list
init|;
name|dip
operator|!=
name|NULL
condition|;
name|dip
operator|=
name|nip
control|)
block|{
name|nip
operator|=
name|dip
operator|->
name|di_next
expr_stmt|;
name|free
argument_list|(
name|dip
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dt_irlist_append
parameter_list|(
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_irnode_t
modifier|*
name|dip
parameter_list|)
block|{
if|if
condition|(
name|dlp
operator|->
name|dl_last
operator|!=
name|NULL
condition|)
name|dlp
operator|->
name|dl_last
operator|->
name|di_next
operator|=
name|dip
expr_stmt|;
else|else
name|dlp
operator|->
name|dl_list
operator|=
name|dip
expr_stmt|;
name|dlp
operator|->
name|dl_last
operator|=
name|dip
expr_stmt|;
if|if
condition|(
name|dip
operator|->
name|di_label
operator|==
name|DT_LBL_NONE
operator|||
name|dip
operator|->
name|di_instr
operator|!=
name|DIF_INSTR_NOP
condition|)
name|dlp
operator|->
name|dl_len
operator|++
expr_stmt|;
comment|/* don't count forward refs in instr count */
block|}
end_function

begin_function
name|uint_t
name|dt_irlist_label
parameter_list|(
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|)
block|{
return|return
operator|(
name|dlp
operator|->
name|dl_label
operator|++
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_countvar
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|size_t
modifier|*
name|np
init|=
name|data
decl_stmt|;
if|if
condition|(
name|idp
operator|->
name|di_flags
operator|&
operator|(
name|DT_IDFLG_DIFR
operator||
name|DT_IDFLG_DIFW
operator|)
condition|)
operator|(
operator|*
name|np
operator|)
operator|++
expr_stmt|;
comment|/* include variable in vartab */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_copyvar
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|dt_pcb_t
modifier|*
name|pcb
init|=
name|data
decl_stmt|;
name|dtrace_difv_t
modifier|*
name|dvp
decl_stmt|;
name|ssize_t
name|stroff
decl_stmt|;
name|dt_node_t
name|dn
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|idp
operator|->
name|di_flags
operator|&
operator|(
name|DT_IDFLG_DIFR
operator||
name|DT_IDFLG_DIFW
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* omit variable from vartab */
name|dvp
operator|=
operator|&
name|pcb
operator|->
name|pcb_difo
operator|->
name|dtdo_vartab
index|[
name|pcb
operator|->
name|pcb_asvidx
operator|++
index|]
expr_stmt|;
name|stroff
operator|=
name|dt_strtab_insert
argument_list|(
name|pcb
operator|->
name|pcb_strtab
argument_list|,
name|idp
operator|->
name|di_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stroff
operator|==
operator|-
literal|1L
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|stroff
operator|>
name|DIF_STROFF_MAX
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_STR2BIG
argument_list|)
expr_stmt|;
name|dvp
operator|->
name|dtdv_name
operator|=
operator|(
name|uint_t
operator|)
name|stroff
expr_stmt|;
name|dvp
operator|->
name|dtdv_id
operator|=
name|idp
operator|->
name|di_id
expr_stmt|;
name|dvp
operator|->
name|dtdv_flags
operator|=
literal|0
expr_stmt|;
name|dvp
operator|->
name|dtdv_kind
operator|=
operator|(
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_ARRAY
operator|)
condition|?
name|DIFV_KIND_ARRAY
else|:
name|DIFV_KIND_SCALAR
expr_stmt|;
if|if
condition|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_LOCAL
condition|)
name|dvp
operator|->
name|dtdv_scope
operator|=
name|DIFV_SCOPE_LOCAL
expr_stmt|;
elseif|else
if|if
condition|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_TLS
condition|)
name|dvp
operator|->
name|dtdv_scope
operator|=
name|DIFV_SCOPE_THREAD
expr_stmt|;
else|else
name|dvp
operator|->
name|dtdv_scope
operator|=
name|DIFV_SCOPE_GLOBAL
expr_stmt|;
if|if
condition|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_DIFR
condition|)
name|dvp
operator|->
name|dtdv_flags
operator||=
name|DIFV_F_REF
expr_stmt|;
if|if
condition|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_DIFW
condition|)
name|dvp
operator|->
name|dtdv_flags
operator||=
name|DIFV_F_MOD
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dn
argument_list|,
sizeof|sizeof
argument_list|(
name|dn
argument_list|)
argument_list|)
expr_stmt|;
name|dt_node_type_assign
argument_list|(
operator|&
name|dn
argument_list|,
name|idp
operator|->
name|di_ctfp
argument_list|,
name|idp
operator|->
name|di_type
argument_list|)
expr_stmt|;
name|dt_node_diftype
argument_list|(
name|pcb
operator|->
name|pcb_hdl
argument_list|,
operator|&
name|dn
argument_list|,
operator|&
name|dvp
operator|->
name|dtdv_type
argument_list|)
expr_stmt|;
name|idp
operator|->
name|di_flags
operator|&=
operator|~
operator|(
name|DT_IDFLG_DIFR
operator||
name|DT_IDFLG_DIFW
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|dt_copystr
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|,
name|size_t
name|off
parameter_list|,
name|dt_pcb_t
modifier|*
name|pcb
parameter_list|)
block|{
name|bcopy
argument_list|(
name|s
argument_list|,
name|pcb
operator|->
name|pcb_difo
operator|->
name|dtdo_strtab
operator|+
name|off
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rewrite the xlate/xlarg instruction at dtdo_buf[i] so that the instruction's  * xltab index reflects the offset 'xi' of the assigned dtdo_xlmtab[] location.  * We track the cumulative references to translators and members in the pcb's  * pcb_asxrefs[] array, a two-dimensional array of bitmaps indexed by the  * global translator id and then by the corresponding translator member id.  */
end_comment

begin_function
specifier|static
name|void
name|dt_as_xlate
parameter_list|(
name|dt_pcb_t
modifier|*
name|pcb
parameter_list|,
name|dtrace_difo_t
modifier|*
name|dp
parameter_list|,
name|uint_t
name|i
parameter_list|,
name|uint_t
name|xi
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|pcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_xlator_t
modifier|*
name|dxp
init|=
name|dnp
operator|->
name|dn_membexpr
operator|->
name|dn_xlator
decl_stmt|;
name|assert
argument_list|(
name|i
operator|<
name|dp
operator|->
name|dtdo_len
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|xi
operator|<
name|dp
operator|->
name|dtdo_xlmlen
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_MEMBER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_membexpr
operator|->
name|dn_kind
operator|==
name|DT_NODE_XLATOR
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dxp
operator|->
name|dx_id
operator|<
name|dtp
operator|->
name|dt_xlatorid
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_membid
operator|<
name|dxp
operator|->
name|dx_nmembers
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|pcb_asxrefs
operator|==
name|NULL
condition|)
block|{
name|pcb
operator|->
name|pcb_asxreflen
operator|=
name|dtp
operator|->
name|dt_xlatorid
expr_stmt|;
name|pcb
operator|->
name|pcb_asxrefs
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|ulong_t
operator|*
argument_list|)
operator|*
name|pcb
operator|->
name|pcb_asxreflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|pcb_asxrefs
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pcb
operator|->
name|pcb_asxrefs
index|[
name|dxp
operator|->
name|dx_id
index|]
operator|==
name|NULL
condition|)
block|{
name|pcb
operator|->
name|pcb_asxrefs
index|[
name|dxp
operator|->
name|dx_id
index|]
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
name|BT_SIZEOFMAP
argument_list|(
name|dxp
operator|->
name|dx_nmembers
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|pcb_asxrefs
index|[
name|dxp
operator|->
name|dx_id
index|]
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
block|}
name|dp
operator|->
name|dtdo_buf
index|[
name|i
index|]
operator|=
name|DIF_INSTR_XLATE
argument_list|(
name|DIF_INSTR_OP
argument_list|(
name|dp
operator|->
name|dtdo_buf
index|[
name|i
index|]
argument_list|)
argument_list|,
name|xi
argument_list|,
name|DIF_INSTR_RD
argument_list|(
name|dp
operator|->
name|dtdo_buf
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|BT_SET
argument_list|(
name|pcb
operator|->
name|pcb_asxrefs
index|[
name|dxp
operator|->
name|dx_id
index|]
argument_list|,
name|dnp
operator|->
name|dn_membid
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dtdo_xlmtab
index|[
name|xi
index|]
operator|=
name|dnp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_as_undef
parameter_list|(
specifier|const
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|uint_t
name|offset
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|kind
decl_stmt|,
modifier|*
name|mark
init|=
operator|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_USER
operator|)
condition|?
literal|"``"
else|:
literal|"`"
decl_stmt|;
specifier|const
name|dtrace_syminfo_t
modifier|*
name|dts
init|=
name|idp
operator|->
name|di_data
decl_stmt|;
if|if
condition|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_USER
condition|)
name|kind
operator|=
literal|"user"
expr_stmt|;
elseif|else
if|if
condition|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_PRIM
condition|)
name|kind
operator|=
literal|"primary kernel"
expr_stmt|;
else|else
name|kind
operator|=
literal|"loadable kernel"
expr_stmt|;
name|yylineno
operator|=
name|idp
operator|->
name|di_lineno
expr_stmt|;
name|xyerror
argument_list|(
name|D_ASRELO
argument_list|,
literal|"relocation remains against %s symbol %s%s%s (offset "
literal|"0x%x)\n"
argument_list|,
name|kind
argument_list|,
name|dts
operator|->
name|dts_object
argument_list|,
name|mark
argument_list|,
name|dts
operator|->
name|dts_name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dtrace_difo_t
modifier|*
name|dt_as
parameter_list|(
name|dt_pcb_t
modifier|*
name|pcb
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|pcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_irlist_t
modifier|*
name|dlp
init|=
operator|&
name|pcb
operator|->
name|pcb_ir
decl_stmt|;
name|uint_t
modifier|*
name|labels
init|=
name|NULL
decl_stmt|;
name|dt_irnode_t
modifier|*
name|dip
decl_stmt|;
name|dtrace_difo_t
modifier|*
name|dp
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|size_t
name|n
init|=
literal|0
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
name|uint_t
name|kmask
decl_stmt|,
name|kbits
decl_stmt|,
name|umask
decl_stmt|,
name|ubits
decl_stmt|;
name|uint_t
name|krel
init|=
literal|0
decl_stmt|,
name|urel
init|=
literal|0
decl_stmt|,
name|xlrefs
init|=
literal|0
decl_stmt|;
comment|/* 	 * Select bitmasks based upon the desired symbol linking policy.  We 	 * test (di_extern->di_flags& xmask) == xbits to determine if the 	 * symbol should have a relocation entry generated in the loop below. 	 * 	 * DT_LINK_KERNEL = kernel symbols static, user symbols dynamic 	 * DT_LINK_PRIMARY = primary kernel symbols static, others dynamic 	 * DT_LINK_DYNAMIC = all symbols dynamic 	 * DT_LINK_STATIC = all symbols static 	 * 	 * By 'static' we mean that we use the symbol's value at compile-time 	 * in the final DIF.  By 'dynamic' we mean that we create a relocation 	 * table entry for the symbol's value so it can be relocated later. 	 */
switch|switch
condition|(
name|dtp
operator|->
name|dt_linkmode
condition|)
block|{
case|case
name|DT_LINK_KERNEL
case|:
name|kmask
operator|=
literal|0
expr_stmt|;
name|kbits
operator|=
operator|-
literal|1u
expr_stmt|;
name|umask
operator|=
name|DT_IDFLG_USER
expr_stmt|;
name|ubits
operator|=
name|DT_IDFLG_USER
expr_stmt|;
break|break;
case|case
name|DT_LINK_PRIMARY
case|:
name|kmask
operator|=
name|DT_IDFLG_USER
operator||
name|DT_IDFLG_PRIM
expr_stmt|;
name|kbits
operator|=
literal|0
expr_stmt|;
name|umask
operator|=
name|DT_IDFLG_USER
expr_stmt|;
name|ubits
operator|=
name|DT_IDFLG_USER
expr_stmt|;
break|break;
case|case
name|DT_LINK_DYNAMIC
case|:
name|kmask
operator|=
name|DT_IDFLG_USER
expr_stmt|;
name|kbits
operator|=
literal|0
expr_stmt|;
name|umask
operator|=
name|DT_IDFLG_USER
expr_stmt|;
name|ubits
operator|=
name|DT_IDFLG_USER
expr_stmt|;
break|break;
case|case
name|DT_LINK_STATIC
case|:
name|kmask
operator|=
name|umask
operator|=
literal|0
expr_stmt|;
name|kbits
operator|=
name|ubits
operator|=
operator|-
literal|1u
expr_stmt|;
break|break;
default|default:
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"internal error -- invalid link mode %u\n"
argument_list|,
name|dtp
operator|->
name|dt_linkmode
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|pcb
operator|->
name|pcb_difo
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|pcb_difo
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_difo_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|pcb
operator|->
name|pcb_difo
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dtdo_buf
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dif_instr_t
argument_list|)
operator|*
name|dlp
operator|->
name|dl_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dtdo_buf
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|labels
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
operator|*
name|dlp
operator|->
name|dl_label
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
comment|/* 	 * Make an initial pass through the instruction list, filling in the 	 * instruction buffer with valid instructions and skipping labeled nops. 	 * While doing this, we also fill in our labels[] translation table 	 * and we count up the number of relocation table entries we will need. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dip
operator|=
name|dlp
operator|->
name|dl_list
init|;
name|dip
operator|!=
name|NULL
condition|;
name|dip
operator|=
name|dip
operator|->
name|di_next
control|)
block|{
if|if
condition|(
name|dip
operator|->
name|di_label
operator|!=
name|DT_LBL_NONE
condition|)
name|labels
index|[
name|dip
operator|->
name|di_label
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|dip
operator|->
name|di_label
operator|==
name|DT_LBL_NONE
operator|||
name|dip
operator|->
name|di_instr
operator|!=
name|DIF_INSTR_NOP
condition|)
name|dp
operator|->
name|dtdo_buf
index|[
name|i
operator|++
index|]
operator|=
name|dip
operator|->
name|di_instr
expr_stmt|;
if|if
condition|(
name|dip
operator|->
name|di_extern
operator|==
name|NULL
condition|)
continue|continue;
comment|/* no external references needed */
switch|switch
condition|(
name|DIF_INSTR_OP
argument_list|(
name|dip
operator|->
name|di_instr
argument_list|)
condition|)
block|{
case|case
name|DIF_OP_SETX
case|:
name|idp
operator|=
name|dip
operator|->
name|di_extern
expr_stmt|;
if|if
condition|(
operator|(
name|idp
operator|->
name|di_flags
operator|&
name|kmask
operator|)
operator|==
name|kbits
condition|)
name|krel
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|idp
operator|->
name|di_flags
operator|&
name|umask
operator|)
operator|==
name|ubits
condition|)
name|urel
operator|++
expr_stmt|;
break|break;
case|case
name|DIF_OP_XLATE
case|:
case|case
name|DIF_OP_XLARG
case|:
name|xlrefs
operator|++
expr_stmt|;
break|break;
default|default:
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"unexpected assembler relocation "
literal|"for opcode 0x%x\n"
argument_list|,
name|DIF_INSTR_OP
argument_list|(
name|dip
operator|->
name|di_instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|i
operator|==
name|dlp
operator|->
name|dl_len
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dtdo_len
operator|=
name|dlp
operator|->
name|dl_len
expr_stmt|;
comment|/* 	 * Make a second pass through the instructions, relocating each branch 	 * label to the index of the final instruction in the buffer and noting 	 * any other instruction-specific DIFO flags such as dtdo_destructive. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|dtdo_len
condition|;
name|i
operator|++
control|)
block|{
name|dif_instr_t
name|instr
init|=
name|dp
operator|->
name|dtdo_buf
index|[
name|i
index|]
decl_stmt|;
name|uint_t
name|op
init|=
name|DIF_INSTR_OP
argument_list|(
name|instr
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|DIF_OP_CALL
condition|)
block|{
if|if
condition|(
name|DIF_INSTR_SUBR
argument_list|(
name|instr
argument_list|)
operator|==
name|DIF_SUBR_COPYOUT
operator|||
name|DIF_INSTR_SUBR
argument_list|(
name|instr
argument_list|)
operator|==
name|DIF_SUBR_COPYOUTSTR
condition|)
name|dp
operator|->
name|dtdo_destructive
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|op
operator|>=
name|DIF_OP_BA
operator|&&
name|op
operator|<=
name|DIF_OP_BLEU
condition|)
block|{
name|assert
argument_list|(
name|DIF_INSTR_LABEL
argument_list|(
name|instr
argument_list|)
operator|<
name|dlp
operator|->
name|dl_label
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dtdo_buf
index|[
name|i
index|]
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|op
argument_list|,
name|labels
index|[
name|DIF_INSTR_LABEL
argument_list|(
name|instr
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|labels
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|pcb_asvidx
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Allocate memory for the appropriate number of variable records and 	 * then fill in each variable record.  As we populate the variable 	 * table we insert the corresponding variable names into the strtab. 	 */
operator|(
name|void
operator|)
name|dt_idhash_iter
argument_list|(
name|dtp
operator|->
name|dt_tls
argument_list|,
name|dt_countvar
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_idhash_iter
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|,
name|dt_countvar
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_idhash_iter
argument_list|(
name|pcb
operator|->
name|pcb_locals
argument_list|,
name|dt_countvar
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|dp
operator|->
name|dtdo_vartab
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_difv_t
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dtdo_varlen
operator|=
operator|(
name|uint32_t
operator|)
name|n
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dtdo_vartab
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_idhash_iter
argument_list|(
name|dtp
operator|->
name|dt_tls
argument_list|,
name|dt_copyvar
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_idhash_iter
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|,
name|dt_copyvar
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_idhash_iter
argument_list|(
name|pcb
operator|->
name|pcb_locals
argument_list|,
name|dt_copyvar
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate memory for the appropriate number of relocation table 	 * entries based upon our kernel and user counts from the first pass. 	 */
if|if
condition|(
name|krel
operator|!=
literal|0
condition|)
block|{
name|dp
operator|->
name|dtdo_kreltab
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|krel
operator|*
sizeof|sizeof
argument_list|(
name|dof_relodesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dtdo_krelen
operator|=
name|krel
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dtdo_kreltab
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|urel
operator|!=
literal|0
condition|)
block|{
name|dp
operator|->
name|dtdo_ureltab
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|urel
operator|*
sizeof|sizeof
argument_list|(
name|dof_relodesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dtdo_urelen
operator|=
name|urel
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dtdo_ureltab
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xlrefs
operator|!=
literal|0
condition|)
block|{
name|dp
operator|->
name|dtdo_xlmtab
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_node_t
operator|*
argument_list|)
operator|*
name|xlrefs
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dtdo_xlmlen
operator|=
name|xlrefs
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dtdo_xlmtab
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If any relocations are needed, make another pass through the 	 * instruction list and fill in the relocation table entries. 	 */
if|if
condition|(
name|krel
operator|+
name|urel
operator|+
name|xlrefs
operator|!=
literal|0
condition|)
block|{
name|uint_t
name|knodef
init|=
name|pcb
operator|->
name|pcb_cflags
operator|&
name|DTRACE_C_KNODEF
decl_stmt|;
name|uint_t
name|unodef
init|=
name|pcb
operator|->
name|pcb_cflags
operator|&
name|DTRACE_C_UNODEF
decl_stmt|;
name|dof_relodesc_t
modifier|*
name|krp
init|=
name|dp
operator|->
name|dtdo_kreltab
decl_stmt|;
name|dof_relodesc_t
modifier|*
name|urp
init|=
name|dp
operator|->
name|dtdo_ureltab
decl_stmt|;
name|dt_node_t
modifier|*
modifier|*
name|xlp
init|=
name|dp
operator|->
name|dtdo_xlmtab
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* dtdo_buf[] index */
for|for
control|(
name|dip
operator|=
name|dlp
operator|->
name|dl_list
init|;
name|dip
operator|!=
name|NULL
condition|;
name|dip
operator|=
name|dip
operator|->
name|di_next
control|)
block|{
name|dof_relodesc_t
modifier|*
name|rp
decl_stmt|;
name|ssize_t
name|soff
decl_stmt|;
name|uint_t
name|nodef
decl_stmt|;
if|if
condition|(
name|dip
operator|->
name|di_label
operator|!=
name|DT_LBL_NONE
operator|&&
name|dip
operator|->
name|di_instr
operator|==
name|DIF_INSTR_NOP
condition|)
continue|continue;
comment|/* skip label declarations */
name|i
operator|++
expr_stmt|;
comment|/* advance dtdo_buf[] index */
if|if
condition|(
name|DIF_INSTR_OP
argument_list|(
name|dip
operator|->
name|di_instr
argument_list|)
operator|==
name|DIF_OP_XLATE
operator|||
name|DIF_INSTR_OP
argument_list|(
name|dip
operator|->
name|di_instr
argument_list|)
operator|==
name|DIF_OP_XLARG
condition|)
block|{
name|assert
argument_list|(
name|dp
operator|->
name|dtdo_buf
index|[
name|i
operator|-
literal|1
index|]
operator|==
name|dip
operator|->
name|di_instr
argument_list|)
expr_stmt|;
name|dt_as_xlate
argument_list|(
name|pcb
argument_list|,
name|dp
argument_list|,
name|i
operator|-
literal|1
argument_list|,
call|(
name|uint_t
call|)
argument_list|(
name|xlp
operator|++
operator|-
name|dp
operator|->
name|dtdo_xlmtab
argument_list|)
argument_list|,
name|dip
operator|->
name|di_extern
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|idp
operator|=
name|dip
operator|->
name|di_extern
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* no relocation entry needed */
if|if
condition|(
operator|(
name|idp
operator|->
name|di_flags
operator|&
name|kmask
operator|)
operator|==
name|kbits
condition|)
block|{
name|nodef
operator|=
name|knodef
expr_stmt|;
name|rp
operator|=
name|krp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|idp
operator|->
name|di_flags
operator|&
name|umask
operator|)
operator|==
name|ubits
condition|)
block|{
name|nodef
operator|=
name|unodef
expr_stmt|;
name|rp
operator|=
name|urp
operator|++
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
operator|!
name|nodef
condition|)
name|dt_as_undef
argument_list|(
name|idp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|DIF_INSTR_OP
argument_list|(
name|dip
operator|->
name|di_instr
argument_list|)
operator|==
name|DIF_OP_SETX
argument_list|)
expr_stmt|;
name|soff
operator|=
name|dt_strtab_insert
argument_list|(
name|pcb
operator|->
name|pcb_strtab
argument_list|,
name|idp
operator|->
name|di_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|soff
operator|==
operator|-
literal|1L
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|soff
operator|>
name|DIF_STROFF_MAX
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_STR2BIG
argument_list|)
expr_stmt|;
name|rp
operator|->
name|dofr_name
operator|=
operator|(
name|dof_stridx_t
operator|)
name|soff
expr_stmt|;
name|rp
operator|->
name|dofr_type
operator|=
name|DOF_RELO_SETX
expr_stmt|;
name|rp
operator|->
name|dofr_offset
operator|=
name|DIF_INSTR_INTEGER
argument_list|(
name|dip
operator|->
name|di_instr
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|rp
operator|->
name|dofr_data
operator|=
literal|0
expr_stmt|;
block|}
name|assert
argument_list|(
name|krp
operator|==
name|dp
operator|->
name|dtdo_kreltab
operator|+
name|dp
operator|->
name|dtdo_krelen
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|urp
operator|==
name|dp
operator|->
name|dtdo_ureltab
operator|+
name|dp
operator|->
name|dtdo_urelen
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|xlp
operator|==
name|dp
operator|->
name|dtdo_xlmtab
operator|+
name|dp
operator|->
name|dtdo_xlmlen
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|i
operator|==
name|dp
operator|->
name|dtdo_len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate memory for the compiled string table and then copy the 	 * chunks from the string table into the final string buffer. 	 */
if|if
condition|(
operator|(
name|n
operator|=
name|dt_strtab_size
argument_list|(
name|pcb
operator|->
name|pcb_strtab
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|dtdo_strtab
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|n
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_strtab_write
argument_list|(
name|pcb
operator|->
name|pcb_strtab
argument_list|,
operator|(
name|dt_strtab_write_f
operator|*
operator|)
name|dt_copystr
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dtdo_strlen
operator|=
operator|(
name|uint32_t
operator|)
name|n
expr_stmt|;
block|}
comment|/* 	 * Allocate memory for the compiled integer table and then copy the 	 * integer constants from the table into the final integer buffer. 	 */
if|if
condition|(
operator|(
name|n
operator|=
name|dt_inttab_size
argument_list|(
name|pcb
operator|->
name|pcb_inttab
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|dtdo_inttab
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|dt_inttab_write
argument_list|(
name|pcb
operator|->
name|pcb_inttab
argument_list|,
name|dp
operator|->
name|dtdo_inttab
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dtdo_intlen
operator|=
operator|(
name|uint32_t
operator|)
name|n
expr_stmt|;
block|}
comment|/* 	 * Fill in the DIFO return type from the type associated with the 	 * node saved in pcb_dret, and then clear pcb_difo and pcb_dret 	 * now that the assembler has completed successfully. 	 */
name|dt_node_diftype
argument_list|(
name|dtp
argument_list|,
name|pcb
operator|->
name|pcb_dret
argument_list|,
operator|&
name|dp
operator|->
name|dtdo_rtype
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|pcb_difo
operator|=
name|NULL
expr_stmt|;
name|pcb
operator|->
name|pcb_dret
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|pcb_cflags
operator|&
name|DTRACE_C_DIFV
condition|)
name|dt_dis
argument_list|(
name|dp
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

end_unit

