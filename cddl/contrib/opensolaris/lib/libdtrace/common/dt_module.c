begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013, Joyent, Inc.  All rights reserved.  * Copyright (c) 2016, Pedro Giffuni.  All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<sys/modctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/elf.h>
end_include

begin_include
include|#
directive|include
file|<sys/task.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<project.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<libelf.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|illumos
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libproc_compat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dt_strtab.h>
end_include

begin_include
include|#
directive|include
file|<dt_module.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dt_module_strtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* active strtab for qsort callbacks */
end_comment

begin_function
specifier|static
name|void
name|dt_module_symhash_insert
parameter_list|(
name|dt_module_t
modifier|*
name|dmp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint_t
name|id
parameter_list|)
block|{
name|dt_sym_t
modifier|*
name|dsp
init|=
operator|&
name|dmp
operator|->
name|dm_symchains
index|[
name|dmp
operator|->
name|dm_symfree
index|]
decl_stmt|;
name|uint_t
name|h
decl_stmt|;
name|assert
argument_list|(
name|dmp
operator|->
name|dm_symfree
operator|<
name|dmp
operator|->
name|dm_nsymelems
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dsp
operator|->
name|ds_symid
operator|=
name|id
expr_stmt|;
name|h
operator|=
name|dt_strtab_hash
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
operator|%
name|dmp
operator|->
name|dm_nsymbuckets
expr_stmt|;
name|dsp
operator|->
name|ds_next
operator|=
name|dmp
operator|->
name|dm_symbuckets
index|[
name|h
index|]
expr_stmt|;
name|dmp
operator|->
name|dm_symbuckets
index|[
name|h
index|]
operator|=
name|dmp
operator|->
name|dm_symfree
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint_t
name|dt_module_syminit32
parameter_list|(
name|dt_module_t
modifier|*
name|dmp
parameter_list|)
block|{
if|#
directive|if
name|STT_NUM
operator|!=
operator|(
name|STT_TLS
operator|+
literal|1
operator|)
error|#
directive|error
literal|"STT_NUM has grown. update dt_module_syminit32()"
endif|#
directive|endif
name|Elf32_Sym
modifier|*
name|sym
init|=
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|base
init|=
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_data
decl_stmt|;
name|size_t
name|ss_size
init|=
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_size
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|n
init|=
name|dmp
operator|->
name|dm_nsymelems
decl_stmt|;
name|uint_t
name|asrsv
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|GElf_Ehdr
name|ehdr
decl_stmt|;
name|int
name|is_elf_obj
decl_stmt|;
name|gelf_getehdr
argument_list|(
name|dmp
operator|->
name|dm_elf
argument_list|,
operator|&
name|ehdr
argument_list|)
expr_stmt|;
name|is_elf_obj
operator|=
operator|(
name|ehdr
operator|.
name|e_type
operator|==
name|ET_REL
operator|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|sym
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|base
operator|+
name|sym
operator|->
name|st_name
decl_stmt|;
name|uchar_t
name|type
init|=
name|ELF32_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|>=
name|STT_NUM
operator|||
name|type
operator|==
name|STT_SECTION
condition|)
continue|continue;
comment|/* skip sections and unknown types */
if|if
condition|(
name|sym
operator|->
name|st_name
operator|==
literal|0
operator|||
name|sym
operator|->
name|st_name
operator|>=
name|ss_size
condition|)
continue|continue;
comment|/* skip null or invalid names */
if|if
condition|(
name|sym
operator|->
name|st_value
operator|!=
literal|0
operator|&&
operator|(
name|ELF32_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
operator|||
name|sym
operator|->
name|st_size
operator|)
condition|)
block|{
name|asrsv
operator|++
expr_stmt|;
comment|/* reserve space in the address map */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sym
operator|->
name|st_value
operator|+=
operator|(
name|Elf_Addr
operator|)
name|dmp
operator|->
name|dm_reloc_offset
expr_stmt|;
if|if
condition|(
name|is_elf_obj
operator|&&
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|<
name|ehdr
operator|.
name|e_shnum
condition|)
name|sym
operator|->
name|st_value
operator|+=
name|dmp
operator|->
name|dm_sec_offsets
index|[
name|sym
operator|->
name|st_shndx
index|]
expr_stmt|;
endif|#
directive|endif
block|}
name|dt_module_symhash_insert
argument_list|(
name|dmp
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|asrsv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint_t
name|dt_module_syminit64
parameter_list|(
name|dt_module_t
modifier|*
name|dmp
parameter_list|)
block|{
if|#
directive|if
name|STT_NUM
operator|!=
operator|(
name|STT_TLS
operator|+
literal|1
operator|)
error|#
directive|error
literal|"STT_NUM has grown. update dt_module_syminit64()"
endif|#
directive|endif
name|Elf64_Sym
modifier|*
name|sym
init|=
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|base
init|=
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_data
decl_stmt|;
name|size_t
name|ss_size
init|=
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_size
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|n
init|=
name|dmp
operator|->
name|dm_nsymelems
decl_stmt|;
name|uint_t
name|asrsv
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|GElf_Ehdr
name|ehdr
decl_stmt|;
name|int
name|is_elf_obj
decl_stmt|;
name|gelf_getehdr
argument_list|(
name|dmp
operator|->
name|dm_elf
argument_list|,
operator|&
name|ehdr
argument_list|)
expr_stmt|;
name|is_elf_obj
operator|=
operator|(
name|ehdr
operator|.
name|e_type
operator|==
name|ET_REL
operator|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|sym
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|base
operator|+
name|sym
operator|->
name|st_name
decl_stmt|;
name|uchar_t
name|type
init|=
name|ELF64_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|>=
name|STT_NUM
operator|||
name|type
operator|==
name|STT_SECTION
condition|)
continue|continue;
comment|/* skip sections and unknown types */
if|if
condition|(
name|sym
operator|->
name|st_name
operator|==
literal|0
operator|||
name|sym
operator|->
name|st_name
operator|>=
name|ss_size
condition|)
continue|continue;
comment|/* skip null or invalid names */
if|if
condition|(
name|sym
operator|->
name|st_value
operator|!=
literal|0
operator|&&
operator|(
name|ELF64_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
operator|||
name|sym
operator|->
name|st_size
operator|)
condition|)
block|{
name|asrsv
operator|++
expr_stmt|;
comment|/* reserve space in the address map */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sym
operator|->
name|st_value
operator|+=
operator|(
name|Elf_Addr
operator|)
name|dmp
operator|->
name|dm_reloc_offset
expr_stmt|;
if|if
condition|(
name|is_elf_obj
operator|&&
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|<
name|ehdr
operator|.
name|e_shnum
condition|)
name|sym
operator|->
name|st_value
operator|+=
name|dmp
operator|->
name|dm_sec_offsets
index|[
name|sym
operator|->
name|st_shndx
index|]
expr_stmt|;
endif|#
directive|endif
block|}
name|dt_module_symhash_insert
argument_list|(
name|dmp
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|asrsv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sort comparison function for 32-bit symbol address-to-name lookups.  We sort  * symbols by value.  If values are equal, we prefer the symbol that is  * non-zero sized, typed, not weak, or lexically first, in that order.  */
end_comment

begin_function
specifier|static
name|int
name|dt_module_symcomp32
parameter_list|(
specifier|const
name|void
modifier|*
name|lp
parameter_list|,
specifier|const
name|void
modifier|*
name|rp
parameter_list|)
block|{
name|Elf32_Sym
modifier|*
name|lhs
init|=
operator|*
operator|(
operator|(
name|Elf32_Sym
operator|*
operator|*
operator|)
name|lp
operator|)
decl_stmt|;
name|Elf32_Sym
modifier|*
name|rhs
init|=
operator|*
operator|(
operator|(
name|Elf32_Sym
operator|*
operator|*
operator|)
name|rp
operator|)
decl_stmt|;
if|if
condition|(
name|lhs
operator|->
name|st_value
operator|!=
name|rhs
operator|->
name|st_value
condition|)
return|return
operator|(
name|lhs
operator|->
name|st_value
operator|>
name|rhs
operator|->
name|st_value
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|lhs
operator|->
name|st_size
operator|==
literal|0
operator|)
operator|!=
operator|(
name|rhs
operator|->
name|st_size
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|lhs
operator|->
name|st_size
operator|==
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|ELF32_ST_TYPE
argument_list|(
name|lhs
operator|->
name|st_info
argument_list|)
operator|==
name|STT_NOTYPE
operator|)
operator|!=
operator|(
name|ELF32_ST_TYPE
argument_list|(
name|rhs
operator|->
name|st_info
argument_list|)
operator|==
name|STT_NOTYPE
operator|)
condition|)
return|return
operator|(
name|ELF32_ST_TYPE
argument_list|(
name|lhs
operator|->
name|st_info
argument_list|)
operator|==
name|STT_NOTYPE
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|ELF32_ST_BIND
argument_list|(
name|lhs
operator|->
name|st_info
argument_list|)
operator|==
name|STB_WEAK
operator|)
operator|!=
operator|(
name|ELF32_ST_BIND
argument_list|(
name|rhs
operator|->
name|st_info
argument_list|)
operator|==
name|STB_WEAK
operator|)
condition|)
return|return
operator|(
name|ELF32_ST_BIND
argument_list|(
name|lhs
operator|->
name|st_info
argument_list|)
operator|==
name|STB_WEAK
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|strcmp
argument_list|(
name|dt_module_strtab
operator|+
name|lhs
operator|->
name|st_name
argument_list|,
name|dt_module_strtab
operator|+
name|rhs
operator|->
name|st_name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sort comparison function for 64-bit symbol address-to-name lookups.  We sort  * symbols by value.  If values are equal, we prefer the symbol that is  * non-zero sized, typed, not weak, or lexically first, in that order.  */
end_comment

begin_function
specifier|static
name|int
name|dt_module_symcomp64
parameter_list|(
specifier|const
name|void
modifier|*
name|lp
parameter_list|,
specifier|const
name|void
modifier|*
name|rp
parameter_list|)
block|{
name|Elf64_Sym
modifier|*
name|lhs
init|=
operator|*
operator|(
operator|(
name|Elf64_Sym
operator|*
operator|*
operator|)
name|lp
operator|)
decl_stmt|;
name|Elf64_Sym
modifier|*
name|rhs
init|=
operator|*
operator|(
operator|(
name|Elf64_Sym
operator|*
operator|*
operator|)
name|rp
operator|)
decl_stmt|;
if|if
condition|(
name|lhs
operator|->
name|st_value
operator|!=
name|rhs
operator|->
name|st_value
condition|)
return|return
operator|(
name|lhs
operator|->
name|st_value
operator|>
name|rhs
operator|->
name|st_value
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|lhs
operator|->
name|st_size
operator|==
literal|0
operator|)
operator|!=
operator|(
name|rhs
operator|->
name|st_size
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|lhs
operator|->
name|st_size
operator|==
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|ELF64_ST_TYPE
argument_list|(
name|lhs
operator|->
name|st_info
argument_list|)
operator|==
name|STT_NOTYPE
operator|)
operator|!=
operator|(
name|ELF64_ST_TYPE
argument_list|(
name|rhs
operator|->
name|st_info
argument_list|)
operator|==
name|STT_NOTYPE
operator|)
condition|)
return|return
operator|(
name|ELF64_ST_TYPE
argument_list|(
name|lhs
operator|->
name|st_info
argument_list|)
operator|==
name|STT_NOTYPE
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|ELF64_ST_BIND
argument_list|(
name|lhs
operator|->
name|st_info
argument_list|)
operator|==
name|STB_WEAK
operator|)
operator|!=
operator|(
name|ELF64_ST_BIND
argument_list|(
name|rhs
operator|->
name|st_info
argument_list|)
operator|==
name|STB_WEAK
operator|)
condition|)
return|return
operator|(
name|ELF64_ST_BIND
argument_list|(
name|lhs
operator|->
name|st_info
argument_list|)
operator|==
name|STB_WEAK
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|strcmp
argument_list|(
name|dt_module_strtab
operator|+
name|lhs
operator|->
name|st_name
argument_list|,
name|dt_module_strtab
operator|+
name|rhs
operator|->
name|st_name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_module_symsort32
parameter_list|(
name|dt_module_t
modifier|*
name|dmp
parameter_list|)
block|{
name|Elf32_Sym
modifier|*
name|symtab
init|=
operator|(
name|Elf32_Sym
operator|*
operator|)
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_data
decl_stmt|;
name|Elf32_Sym
modifier|*
modifier|*
name|sympp
init|=
operator|(
name|Elf32_Sym
operator|*
operator|*
operator|)
name|dmp
operator|->
name|dm_asmap
decl_stmt|;
specifier|const
name|dt_sym_t
modifier|*
name|dsp
init|=
name|dmp
operator|->
name|dm_symchains
operator|+
literal|1
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|n
init|=
name|dmp
operator|->
name|dm_symfree
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|dsp
operator|++
control|)
block|{
name|Elf32_Sym
modifier|*
name|sym
init|=
name|symtab
operator|+
name|dsp
operator|->
name|ds_symid
decl_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_value
operator|!=
literal|0
operator|&&
operator|(
name|ELF32_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
operator|||
name|sym
operator|->
name|st_size
operator|)
condition|)
operator|*
name|sympp
operator|++
operator|=
name|sym
expr_stmt|;
block|}
name|dmp
operator|->
name|dm_aslen
operator|=
call|(
name|uint_t
call|)
argument_list|(
name|sympp
operator|-
operator|(
name|Elf32_Sym
operator|*
operator|*
operator|)
name|dmp
operator|->
name|dm_asmap
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dmp
operator|->
name|dm_aslen
operator|<=
name|dmp
operator|->
name|dm_asrsv
argument_list|)
expr_stmt|;
name|dt_module_strtab
operator|=
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_data
expr_stmt|;
name|qsort
argument_list|(
name|dmp
operator|->
name|dm_asmap
argument_list|,
name|dmp
operator|->
name|dm_aslen
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_Sym
operator|*
argument_list|)
argument_list|,
name|dt_module_symcomp32
argument_list|)
expr_stmt|;
name|dt_module_strtab
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_module_symsort64
parameter_list|(
name|dt_module_t
modifier|*
name|dmp
parameter_list|)
block|{
name|Elf64_Sym
modifier|*
name|symtab
init|=
operator|(
name|Elf64_Sym
operator|*
operator|)
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_data
decl_stmt|;
name|Elf64_Sym
modifier|*
modifier|*
name|sympp
init|=
operator|(
name|Elf64_Sym
operator|*
operator|*
operator|)
name|dmp
operator|->
name|dm_asmap
decl_stmt|;
specifier|const
name|dt_sym_t
modifier|*
name|dsp
init|=
name|dmp
operator|->
name|dm_symchains
operator|+
literal|1
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|n
init|=
name|dmp
operator|->
name|dm_symfree
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|dsp
operator|++
control|)
block|{
name|Elf64_Sym
modifier|*
name|sym
init|=
name|symtab
operator|+
name|dsp
operator|->
name|ds_symid
decl_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_value
operator|!=
literal|0
operator|&&
operator|(
name|ELF64_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
operator|||
name|sym
operator|->
name|st_size
operator|)
condition|)
operator|*
name|sympp
operator|++
operator|=
name|sym
expr_stmt|;
block|}
name|dmp
operator|->
name|dm_aslen
operator|=
call|(
name|uint_t
call|)
argument_list|(
name|sympp
operator|-
operator|(
name|Elf64_Sym
operator|*
operator|*
operator|)
name|dmp
operator|->
name|dm_asmap
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dmp
operator|->
name|dm_aslen
operator|<=
name|dmp
operator|->
name|dm_asrsv
argument_list|)
expr_stmt|;
name|dt_module_strtab
operator|=
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_data
expr_stmt|;
name|qsort
argument_list|(
name|dmp
operator|->
name|dm_asmap
argument_list|,
name|dmp
operator|->
name|dm_aslen
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_Sym
operator|*
argument_list|)
argument_list|,
name|dt_module_symcomp64
argument_list|)
expr_stmt|;
name|dt_module_strtab
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|GElf_Sym
modifier|*
name|dt_module_symgelf32
parameter_list|(
specifier|const
name|Elf32_Sym
modifier|*
name|src
parameter_list|,
name|GElf_Sym
modifier|*
name|dst
parameter_list|)
block|{
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
name|dst
operator|->
name|st_name
operator|=
name|src
operator|->
name|st_name
expr_stmt|;
name|dst
operator|->
name|st_info
operator|=
name|src
operator|->
name|st_info
expr_stmt|;
name|dst
operator|->
name|st_other
operator|=
name|src
operator|->
name|st_other
expr_stmt|;
name|dst
operator|->
name|st_shndx
operator|=
name|src
operator|->
name|st_shndx
expr_stmt|;
name|dst
operator|->
name|st_value
operator|=
name|src
operator|->
name|st_value
expr_stmt|;
name|dst
operator|->
name|st_size
operator|=
name|src
operator|->
name|st_size
expr_stmt|;
block|}
return|return
operator|(
name|dst
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|GElf_Sym
modifier|*
name|dt_module_symgelf64
parameter_list|(
specifier|const
name|Elf64_Sym
modifier|*
name|src
parameter_list|,
name|GElf_Sym
modifier|*
name|dst
parameter_list|)
block|{
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|GElf_Sym
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dst
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|GElf_Sym
modifier|*
name|dt_module_symname32
parameter_list|(
name|dt_module_t
modifier|*
name|dmp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GElf_Sym
modifier|*
name|symp
parameter_list|,
name|uint_t
modifier|*
name|idp
parameter_list|)
block|{
specifier|const
name|Elf32_Sym
modifier|*
name|symtab
init|=
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|strtab
init|=
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_data
decl_stmt|;
specifier|const
name|Elf32_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|dt_sym_t
modifier|*
name|dsp
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|h
decl_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_nsymelems
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|h
operator|=
name|dt_strtab_hash
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
operator|%
name|dmp
operator|->
name|dm_nsymbuckets
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dmp
operator|->
name|dm_symbuckets
index|[
name|h
index|]
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|=
name|dsp
operator|->
name|ds_next
control|)
block|{
name|dsp
operator|=
operator|&
name|dmp
operator|->
name|dm_symchains
index|[
name|i
index|]
expr_stmt|;
name|sym
operator|=
name|symtab
operator|+
name|dsp
operator|->
name|ds_symid
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|strtab
operator|+
name|sym
operator|->
name|st_name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|idp
operator|!=
name|NULL
condition|)
operator|*
name|idp
operator|=
name|dsp
operator|->
name|ds_symid
expr_stmt|;
return|return
operator|(
name|dt_module_symgelf32
argument_list|(
name|sym
argument_list|,
name|symp
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|GElf_Sym
modifier|*
name|dt_module_symname64
parameter_list|(
name|dt_module_t
modifier|*
name|dmp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GElf_Sym
modifier|*
name|symp
parameter_list|,
name|uint_t
modifier|*
name|idp
parameter_list|)
block|{
specifier|const
name|Elf64_Sym
modifier|*
name|symtab
init|=
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|strtab
init|=
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_data
decl_stmt|;
specifier|const
name|Elf64_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|dt_sym_t
modifier|*
name|dsp
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|h
decl_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_nsymelems
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|h
operator|=
name|dt_strtab_hash
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
operator|%
name|dmp
operator|->
name|dm_nsymbuckets
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dmp
operator|->
name|dm_symbuckets
index|[
name|h
index|]
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|=
name|dsp
operator|->
name|ds_next
control|)
block|{
name|dsp
operator|=
operator|&
name|dmp
operator|->
name|dm_symchains
index|[
name|i
index|]
expr_stmt|;
name|sym
operator|=
name|symtab
operator|+
name|dsp
operator|->
name|ds_symid
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|strtab
operator|+
name|sym
operator|->
name|st_name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|idp
operator|!=
name|NULL
condition|)
operator|*
name|idp
operator|=
name|dsp
operator|->
name|ds_symid
expr_stmt|;
return|return
operator|(
name|dt_module_symgelf64
argument_list|(
name|sym
argument_list|,
name|symp
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|GElf_Sym
modifier|*
name|dt_module_symaddr32
parameter_list|(
name|dt_module_t
modifier|*
name|dmp
parameter_list|,
name|GElf_Addr
name|addr
parameter_list|,
name|GElf_Sym
modifier|*
name|symp
parameter_list|,
name|uint_t
modifier|*
name|idp
parameter_list|)
block|{
specifier|const
name|Elf32_Sym
modifier|*
modifier|*
name|asmap
init|=
operator|(
specifier|const
name|Elf32_Sym
operator|*
operator|*
operator|)
name|dmp
operator|->
name|dm_asmap
decl_stmt|;
specifier|const
name|Elf32_Sym
modifier|*
name|symtab
init|=
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_data
decl_stmt|;
specifier|const
name|Elf32_Sym
modifier|*
name|sym
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|mid
decl_stmt|,
name|lo
init|=
literal|0
decl_stmt|,
name|hi
init|=
name|dmp
operator|->
name|dm_aslen
operator|-
literal|1
decl_stmt|;
name|Elf32_Addr
name|v
decl_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_aslen
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
name|hi
operator|-
name|lo
operator|>
literal|1
condition|)
block|{
name|mid
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
name|asmap
index|[
name|mid
index|]
operator|->
name|st_value
condition|)
name|lo
operator|=
name|mid
expr_stmt|;
else|else
name|hi
operator|=
name|mid
expr_stmt|;
block|}
name|i
operator|=
name|addr
operator|<
name|asmap
index|[
name|hi
index|]
operator|->
name|st_value
condition|?
name|lo
else|:
name|hi
expr_stmt|;
name|sym
operator|=
name|asmap
index|[
name|i
index|]
expr_stmt|;
name|v
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
comment|/* 	 * If the previous entry has the same value, improve our choice.  The 	 * order of equal-valued symbols is determined by the comparison func. 	 */
while|while
condition|(
name|i
operator|--
operator|!=
literal|0
operator|&&
name|asmap
index|[
name|i
index|]
operator|->
name|st_value
operator|==
name|v
condition|)
name|sym
operator|=
name|asmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|addr
operator|-
name|sym
operator|->
name|st_value
operator|<
name|MAX
argument_list|(
name|sym
operator|->
name|st_size
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|idp
operator|!=
name|NULL
condition|)
operator|*
name|idp
operator|=
call|(
name|uint_t
call|)
argument_list|(
name|sym
operator|-
name|symtab
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_module_symgelf32
argument_list|(
name|sym
argument_list|,
name|symp
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|GElf_Sym
modifier|*
name|dt_module_symaddr64
parameter_list|(
name|dt_module_t
modifier|*
name|dmp
parameter_list|,
name|GElf_Addr
name|addr
parameter_list|,
name|GElf_Sym
modifier|*
name|symp
parameter_list|,
name|uint_t
modifier|*
name|idp
parameter_list|)
block|{
specifier|const
name|Elf64_Sym
modifier|*
modifier|*
name|asmap
init|=
operator|(
specifier|const
name|Elf64_Sym
operator|*
operator|*
operator|)
name|dmp
operator|->
name|dm_asmap
decl_stmt|;
specifier|const
name|Elf64_Sym
modifier|*
name|symtab
init|=
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_data
decl_stmt|;
specifier|const
name|Elf64_Sym
modifier|*
name|sym
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|mid
decl_stmt|,
name|lo
init|=
literal|0
decl_stmt|,
name|hi
init|=
name|dmp
operator|->
name|dm_aslen
operator|-
literal|1
decl_stmt|;
name|Elf64_Addr
name|v
decl_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_aslen
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
name|hi
operator|-
name|lo
operator|>
literal|1
condition|)
block|{
name|mid
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
name|asmap
index|[
name|mid
index|]
operator|->
name|st_value
condition|)
name|lo
operator|=
name|mid
expr_stmt|;
else|else
name|hi
operator|=
name|mid
expr_stmt|;
block|}
name|i
operator|=
name|addr
operator|<
name|asmap
index|[
name|hi
index|]
operator|->
name|st_value
condition|?
name|lo
else|:
name|hi
expr_stmt|;
name|sym
operator|=
name|asmap
index|[
name|i
index|]
expr_stmt|;
name|v
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
comment|/* 	 * If the previous entry has the same value, improve our choice.  The 	 * order of equal-valued symbols is determined by the comparison func. 	 */
while|while
condition|(
name|i
operator|--
operator|!=
literal|0
operator|&&
name|asmap
index|[
name|i
index|]
operator|->
name|st_value
operator|==
name|v
condition|)
name|sym
operator|=
name|asmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|addr
operator|-
name|sym
operator|->
name|st_value
operator|<
name|MAX
argument_list|(
name|sym
operator|->
name|st_size
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|idp
operator|!=
name|NULL
condition|)
operator|*
name|idp
operator|=
call|(
name|uint_t
call|)
argument_list|(
name|sym
operator|-
name|symtab
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_module_symgelf64
argument_list|(
name|sym
argument_list|,
name|symp
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|dt_modops_t
name|dt_modops_32
init|=
block|{
name|dt_module_syminit32
block|,
name|dt_module_symsort32
block|,
name|dt_module_symname32
block|,
name|dt_module_symaddr32
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|dt_modops_t
name|dt_modops_64
init|=
block|{
name|dt_module_syminit64
block|,
name|dt_module_symsort64
block|,
name|dt_module_symname64
block|,
name|dt_module_symaddr64
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|dt_module_t
modifier|*
name|dt_module_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|long
name|pid
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|uint_t
name|h
init|=
name|dt_strtab_hash
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
operator|%
name|dtp
operator|->
name|dt_modbuckets
decl_stmt|;
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
for|for
control|(
name|dmp
operator|=
name|dtp
operator|->
name|dt_mods
index|[
name|h
index|]
init|;
name|dmp
operator|!=
name|NULL
condition|;
name|dmp
operator|=
name|dmp
operator|->
name|dm_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dmp
operator|->
name|dm_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|dmp
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_module_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* caller must handle allocation failure */
name|bzero
argument_list|(
name|dmp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_module_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dmp
operator|->
name|dm_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|dmp
operator|->
name|dm_name
argument_list|)
argument_list|)
expr_stmt|;
name|dt_list_append
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_next
operator|=
name|dtp
operator|->
name|dt_mods
index|[
name|h
index|]
expr_stmt|;
name|dtp
operator|->
name|dt_mods
index|[
name|h
index|]
operator|=
name|dmp
expr_stmt|;
name|dtp
operator|->
name|dt_nmods
operator|++
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_ctfmodel
operator|==
name|CTF_MODEL_LP64
condition|)
name|dmp
operator|->
name|dm_ops
operator|=
operator|&
name|dt_modops_64
expr_stmt|;
else|else
name|dmp
operator|->
name|dm_ops
operator|=
operator|&
name|dt_modops_32
expr_stmt|;
comment|/* 	 * Modules for userland processes are special. They always refer to a 	 * specific process and have a copy of their CTF data from a specific 	 * instant in time. Any dt_module_t that begins with 'pid' is a module 	 * for a specific process, much like how any probe description that 	 * begins with 'pid' is special. pid123 refers to process 123. A module 	 * that is just 'pid' refers specifically to pid$target. This is 	 * generally done as D does not currently allow for macros to be 	 * evaluated when working with types. 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|dmp
operator|->
name|dm_name
argument_list|,
literal|"pid"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_name
index|[
literal|3
index|]
operator|==
literal|'\0'
condition|)
block|{
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"target"
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|!=
name|NULL
operator|&&
name|idp
operator|->
name|di_id
operator|!=
literal|0
condition|)
name|dmp
operator|->
name|dm_pid
operator|=
name|idp
operator|->
name|di_id
expr_stmt|;
block|}
else|else
block|{
name|pid
operator|=
name|strtol
argument_list|(
name|dmp
operator|->
name|dm_name
operator|+
literal|3
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
operator|&&
operator|*
name|eptr
operator|==
literal|'\0'
condition|)
name|dmp
operator|->
name|dm_pid
operator|=
operator|(
name|pid_t
operator|)
name|pid
expr_stmt|;
else|else
name|dt_dprintf
argument_list|(
literal|"encountered malformed pid "
literal|"module: %s\n"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|dmp
operator|)
return|;
block|}
end_function

begin_function
name|dt_module_t
modifier|*
name|dt_module_lookup_by_name
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|uint_t
name|h
init|=
name|dt_strtab_hash
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
operator|%
name|dtp
operator|->
name|dt_modbuckets
decl_stmt|;
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
for|for
control|(
name|dmp
operator|=
name|dtp
operator|->
name|dt_mods
index|[
name|h
index|]
init|;
name|dmp
operator|!=
name|NULL
condition|;
name|dmp
operator|=
name|dmp
operator|->
name|dm_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dmp
operator|->
name|dm_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|dmp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|dt_module_t
modifier|*
name|dt_module_lookup_by_ctf
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|ctf_file_t
modifier|*
name|ctfp
parameter_list|)
block|{
return|return
operator|(
name|ctfp
condition|?
name|ctf_getspecific
argument_list|(
name|ctfp
argument_list|)
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
name|dt_kmodule_t
modifier|*
name|dt_kmodule_lookup
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|uint_t
name|h
init|=
name|dt_strtab_hash
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
operator|%
name|dtp
operator|->
name|dt_modbuckets
decl_stmt|;
name|dt_kmodule_t
modifier|*
name|dkmp
decl_stmt|;
for|for
control|(
name|dkmp
operator|=
name|dtp
operator|->
name|dt_kmods
index|[
name|h
index|]
init|;
name|dkmp
operator|!=
name|NULL
condition|;
name|dkmp
operator|=
name|dkmp
operator|->
name|dkm_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dkmp
operator|->
name|dkm_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|dkmp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|dt_module_load_sect
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_module_t
modifier|*
name|dmp
parameter_list|,
name|ctf_sect_t
modifier|*
name|ctsp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|shstrs
decl_stmt|;
name|GElf_Shdr
name|sh
decl_stmt|;
name|Elf_Data
modifier|*
name|dp
decl_stmt|;
name|Elf_Scn
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|elf_getshdrstrndx
argument_list|(
name|dmp
operator|->
name|dm_elf
argument_list|,
operator|&
name|shstrs
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOTLOADED
argument_list|)
operator|)
return|;
for|for
control|(
name|sp
operator|=
name|NULL
init|;
operator|(
name|sp
operator|=
name|elf_nextscn
argument_list|(
name|dmp
operator|->
name|dm_elf
argument_list|,
name|sp
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|sp
argument_list|,
operator|&
name|sh
argument_list|)
operator|==
name|NULL
operator|||
name|sh
operator|.
name|sh_type
operator|==
name|SHT_NULL
operator|||
operator|(
name|s
operator|=
name|elf_strptr
argument_list|(
name|dmp
operator|->
name|dm_elf
argument_list|,
name|shstrs
argument_list|,
name|sh
operator|.
name|sh_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* skip any malformed sections */
if|if
condition|(
name|sh
operator|.
name|sh_type
operator|==
name|ctsp
operator|->
name|cts_type
operator|&&
name|sh
operator|.
name|sh_entsize
operator|==
name|ctsp
operator|->
name|cts_entsize
operator|&&
name|strcmp
argument_list|(
name|s
argument_list|,
name|ctsp
operator|->
name|cts_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* section matches specification */
block|}
comment|/* 	 * If the section isn't found, return success but leave cts_data set 	 * to NULL and cts_size set to zero for our caller. 	 */
if|if
condition|(
name|sp
operator|==
name|NULL
operator|||
operator|(
name|dp
operator|=
name|elf_getdata
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
name|ctsp
operator|->
name|cts_data
operator|=
name|dp
operator|->
name|d_buf
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|ctsp
operator|->
name|cts_data
operator|=
name|malloc
argument_list|(
name|dp
operator|->
name|d_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memcpy
argument_list|(
name|ctsp
operator|->
name|cts_data
argument_list|,
name|dp
operator|->
name|d_buf
argument_list|,
name|dp
operator|->
name|d_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ctsp
operator|->
name|cts_size
operator|=
name|dp
operator|->
name|d_size
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"loaded %s [%s] (%lu bytes)\n"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
name|ctsp
operator|->
name|cts_name
argument_list|,
operator|(
name|ulong_t
operator|)
name|ctsp
operator|->
name|cts_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dt_module_cb_arg
block|{
name|struct
name|ps_prochandle
modifier|*
name|dpa_proc
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dpa_dtp
decl_stmt|;
name|dt_module_t
modifier|*
name|dpa_dmp
decl_stmt|;
name|uint_t
name|dpa_count
decl_stmt|;
block|}
name|dt_module_cb_arg_t
typedef|;
end_typedef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dt_module_load_proc_count
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|prmap_t
modifier|*
name|prmap
parameter_list|,
specifier|const
name|char
modifier|*
name|obj
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fp
decl_stmt|;
name|dt_module_cb_arg_t
modifier|*
name|dcp
init|=
name|arg
decl_stmt|;
comment|/* Try to grab a ctf container if it exists */
name|fp
operator|=
name|Pname_to_ctf
argument_list|(
name|dcp
operator|->
name|dpa_proc
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|dcp
operator|->
name|dpa_count
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dt_module_load_proc_build
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|prmap_t
modifier|*
name|prmap
parameter_list|,
specifier|const
name|char
modifier|*
name|obj
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|dt_module_cb_arg_t
modifier|*
name|dcp
init|=
name|arg
decl_stmt|;
name|int
name|count
init|=
name|dcp
operator|->
name|dpa_count
decl_stmt|;
name|Lmid_t
name|lmid
decl_stmt|;
name|fp
operator|=
name|Pname_to_ctf
argument_list|(
name|dcp
operator|->
name|dpa_proc
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fp
operator|=
name|ctf_dup
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dcp
operator|->
name|dpa_dmp
operator|->
name|dm_libctfp
index|[
name|count
index|]
operator|=
name|fp
expr_stmt|;
comment|/* 	 * While it'd be nice to simply use objname here, because of our prior 	 * actions we'll always get a resolved object name to its on disk file. 	 * Like the pid provider, we need to tell a bit of a lie here. The type 	 * that the user thinks of is in terms of the libraries they requested, 	 * eg. libc.so.1, they don't care about the fact that it's 	 * libc_hwcap.so.1. 	 */
operator|(
name|void
operator|)
name|Pobjname
argument_list|(
name|dcp
operator|->
name|dpa_proc
argument_list|,
name|prmap
operator|->
name|pr_vaddr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
name|buf
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
comment|/* 	 * If for some reason we can't find a link map id for this module, which 	 * would be really quite weird. We instead just say the link map id is 	 * zero. 	 */
if|if
condition|(
name|Plmid
argument_list|(
name|dcp
operator|->
name|dpa_proc
argument_list|,
name|prmap
operator|->
name|pr_vaddr
argument_list|,
operator|&
name|lmid
argument_list|)
operator|!=
literal|0
condition|)
name|lmid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lmid
operator|==
literal|0
condition|)
name|dcp
operator|->
name|dpa_dmp
operator|->
name|dm_libctfn
index|[
name|count
index|]
operator|=
name|strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|asprintf
argument_list|(
operator|&
name|dcp
operator|->
name|dpa_dmp
operator|->
name|dm_libctfn
index|[
name|count
index|]
argument_list|,
literal|"LM%x`%s"
argument_list|,
name|lmid
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcp
operator|->
name|dpa_dmp
operator|->
name|dm_libctfn
index|[
name|count
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ctf_setspecific
argument_list|(
name|fp
argument_list|,
name|dcp
operator|->
name|dpa_dmp
argument_list|)
expr_stmt|;
name|dcp
operator|->
name|dpa_count
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We've been asked to load data that belongs to another process. As such we're  * going to pgrab it at this instant, load everything that we might ever care  * about, and then drive on. The reason for this is that the process that we're  * interested in might be changing. As long as we have grabbed it, then this  * can't be a problem for us.  *  * For now, we're actually going to punt on most things and just try to get CTF  * data, nothing else. Basically this is only useful as a source of type  * information, we can't go and do the stacktrace lookups, etc.  */
end_comment

begin_function
specifier|static
name|int
name|dt_module_load_proc
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_module_t
modifier|*
name|dmp
parameter_list|)
block|{
name|struct
name|ps_prochandle
modifier|*
name|p
decl_stmt|;
name|dt_module_cb_arg_t
name|arg
decl_stmt|;
comment|/* 	 * Note that on success we do not release this hold. We must hold this 	 * for our life time. 	 */
name|p
operator|=
name|dt_proc_grab
argument_list|(
name|dtp
argument_list|,
name|dmp
operator|->
name|dm_pid
argument_list|,
literal|0
argument_list|,
name|PGRAB_RDONLY
operator||
name|PGRAB_FORCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to grab pid: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|dmp
operator|->
name|dm_pid
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_CANTLOAD
argument_list|)
operator|)
return|;
block|}
name|dt_proc_lock
argument_list|(
name|dtp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|arg
operator|.
name|dpa_proc
operator|=
name|p
expr_stmt|;
name|arg
operator|.
name|dpa_dtp
operator|=
name|dtp
expr_stmt|;
name|arg
operator|.
name|dpa_dmp
operator|=
name|dmp
expr_stmt|;
name|arg
operator|.
name|dpa_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Pobject_iter_resolved
argument_list|(
name|p
argument_list|,
name|dt_module_load_proc_count
argument_list|,
operator|&
name|arg
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to iterate objects\n"
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_CANTLOAD
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|arg
operator|.
name|dpa_count
operator|==
literal|0
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"no ctf data present\n"
argument_list|)
expr_stmt|;
name|dt_proc_unlock
argument_list|(
name|dtp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_CANTLOAD
argument_list|)
operator|)
return|;
block|}
name|dmp
operator|->
name|dm_libctfp
operator|=
name|calloc
argument_list|(
name|arg
operator|.
name|dpa_count
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_file_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_libctfp
operator|==
name|NULL
condition|)
block|{
name|dt_proc_unlock
argument_list|(
name|dtp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|dmp
operator|->
name|dm_libctfn
operator|=
name|calloc
argument_list|(
name|arg
operator|.
name|dpa_count
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_libctfn
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dmp
operator|->
name|dm_libctfp
argument_list|)
expr_stmt|;
name|dt_proc_unlock
argument_list|(
name|dtp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|dmp
operator|->
name|dm_nctflibs
operator|=
name|arg
operator|.
name|dpa_count
expr_stmt|;
name|arg
operator|.
name|dpa_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Pobject_iter_resolved
argument_list|(
name|p
argument_list|,
name|dt_module_load_proc_build
argument_list|,
operator|&
name|arg
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dt_proc_unlock
argument_list|(
name|dtp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|dt_module_unload
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_CANTLOAD
argument_list|)
operator|)
return|;
block|}
name|assert
argument_list|(
name|arg
operator|.
name|dpa_count
operator|==
name|dmp
operator|->
name|dm_nctflibs
argument_list|)
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"loaded %d ctf modules for pid %d\n"
argument_list|,
name|arg
operator|.
name|dpa_count
argument_list|,
operator|(
name|int
operator|)
name|dmp
operator|->
name|dm_pid
argument_list|)
expr_stmt|;
name|dt_proc_unlock
argument_list|(
name|dtp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_flags
operator||=
name|DT_DM_LOADED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_module_load
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_module_t
modifier|*
name|dmp
parameter_list|)
block|{
if|if
condition|(
name|dmp
operator|->
name|dm_flags
operator|&
name|DT_DM_LOADED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* module is already loaded */
if|if
condition|(
name|dmp
operator|->
name|dm_pid
operator|!=
literal|0
condition|)
return|return
operator|(
name|dt_module_load_proc
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
operator|)
return|;
name|dmp
operator|->
name|dm_ctdata
operator|.
name|cts_name
operator|=
literal|".SUNW_ctf"
expr_stmt|;
name|dmp
operator|->
name|dm_ctdata
operator|.
name|cts_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|dmp
operator|->
name|dm_ctdata
operator|.
name|cts_flags
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_ctdata
operator|.
name|cts_data
operator|=
name|NULL
expr_stmt|;
name|dmp
operator|->
name|dm_ctdata
operator|.
name|cts_size
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_ctdata
operator|.
name|cts_entsize
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_ctdata
operator|.
name|cts_offset
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_name
operator|=
literal|".symtab"
expr_stmt|;
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_type
operator|=
name|SHT_SYMTAB
expr_stmt|;
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_flags
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_data
operator|=
name|NULL
expr_stmt|;
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_size
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_entsize
operator|=
name|dmp
operator|->
name|dm_ops
operator|==
operator|&
name|dt_modops_64
condition|?
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_offset
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_name
operator|=
literal|".strtab"
expr_stmt|;
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_flags
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_data
operator|=
name|NULL
expr_stmt|;
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_size
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_entsize
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_offset
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Attempt to load the module's CTF section, symbol table section, and 	 * string table section.  Note that modules may not contain CTF data: 	 * this will result in a successful load_sect but data of size zero. 	 * We will then fail if dt_module_getctf() is called, as shown below. 	 */
if|if
condition|(
name|dt_module_load_sect
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|,
operator|&
name|dmp
operator|->
name|dm_ctdata
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|dt_module_load_sect
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|,
operator|&
name|dmp
operator|->
name|dm_symtab
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|dt_module_load_sect
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|,
operator|&
name|dmp
operator|->
name|dm_strtab
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|dt_module_unload
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dt_errno is set for us */
block|}
comment|/* 	 * Allocate the hash chains and hash buckets for symbol name lookup. 	 * This is relatively simple since the symbol table is of fixed size 	 * and is known in advance.  We allocate one extra element since we 	 * use element indices instead of pointers and zero is our sentinel. 	 */
name|dmp
operator|->
name|dm_nsymelems
operator|=
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_size
operator|/
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_entsize
expr_stmt|;
name|dmp
operator|->
name|dm_nsymbuckets
operator|=
name|_dtrace_strbuckets
expr_stmt|;
name|dmp
operator|->
name|dm_symfree
operator|=
literal|1
expr_stmt|;
comment|/* first free element is index 1 */
name|dmp
operator|->
name|dm_symbuckets
operator|=
name|calloc
argument_list|(
name|dmp
operator|->
name|dm_nsymbuckets
argument_list|,
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_symchains
operator|=
name|calloc
argument_list|(
name|dmp
operator|->
name|dm_nsymelems
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_sym_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_symbuckets
operator|==
name|NULL
operator|||
name|dmp
operator|->
name|dm_symchains
operator|==
name|NULL
condition|)
block|{
name|dt_module_unload
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Iterate over the symbol table data buffer and insert each symbol 	 * name into the name hash if the name and type are valid.  Then 	 * allocate the address map, fill it in, and sort it. 	 */
name|dmp
operator|->
name|dm_asrsv
operator|=
name|dmp
operator|->
name|dm_ops
operator|->
name|do_syminit
argument_list|(
name|dmp
argument_list|)
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"hashed %s [%s] (%u symbols)\n"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_name
argument_list|,
name|dmp
operator|->
name|dm_symfree
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dmp
operator|->
name|dm_asmap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|dmp
operator|->
name|dm_asrsv
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_module_unload
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|dmp
operator|->
name|dm_ops
operator|->
name|do_symsort
argument_list|(
name|dmp
argument_list|)
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"sorted %s [%s] (%u symbols)\n"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_name
argument_list|,
name|dmp
operator|->
name|dm_aslen
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_flags
operator||=
name|DT_DM_LOADED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_module_hasctf
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_module_t
modifier|*
name|dmp
parameter_list|)
block|{
if|if
condition|(
name|dmp
operator|->
name|dm_pid
operator|!=
literal|0
operator|&&
name|dmp
operator|->
name|dm_nctflibs
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|dt_module_getctf
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|ctf_file_t
modifier|*
name|dt_module_getctf
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_module_t
modifier|*
name|dmp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|parent
decl_stmt|;
name|dt_module_t
modifier|*
name|pmp
decl_stmt|;
name|ctf_file_t
modifier|*
name|pfp
decl_stmt|;
name|int
name|model
decl_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_ctfp
operator|!=
name|NULL
operator|||
name|dt_module_load
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|dmp
operator|->
name|dm_ctfp
operator|)
return|;
if|if
condition|(
name|dmp
operator|->
name|dm_ops
operator|==
operator|&
name|dt_modops_64
condition|)
name|model
operator|=
name|CTF_MODEL_LP64
expr_stmt|;
else|else
name|model
operator|=
name|CTF_MODEL_ILP32
expr_stmt|;
comment|/* 	 * If the data model of the module does not match our program data 	 * model, then do not permit CTF from this module to be opened and 	 * returned to the compiler.  If we support mixed data models in the 	 * future for combined kernel/user tracing, this can be removed. 	 */
if|if
condition|(
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_ctfmodel
operator|!=
name|model
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DATAMODEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|dmp
operator|->
name|dm_ctdata
operator|.
name|cts_size
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOCTF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dmp
operator|->
name|dm_ctfp
operator|=
name|ctf_bufopen
argument_list|(
operator|&
name|dmp
operator|->
name|dm_ctdata
argument_list|,
operator|&
name|dmp
operator|->
name|dm_symtab
argument_list|,
operator|&
name|dmp
operator|->
name|dm_strtab
argument_list|,
operator|&
name|dtp
operator|->
name|dt_ctferr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_ctfp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_CTF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ctf_setmodel
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|model
argument_list|)
expr_stmt|;
name|ctf_setspecific
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|parent
operator|=
name|ctf_parent_name
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pmp
operator|=
name|dt_module_create
argument_list|(
name|dtp
argument_list|,
name|parent
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|pfp
operator|=
name|dt_module_getctf
argument_list|(
name|dtp
argument_list|,
name|pmp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pmp
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|ctf_import
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|pfp
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|dtp
operator|->
name|dt_ctferr
operator|=
name|ctf_errno
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_CTF
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|dt_dprintf
argument_list|(
literal|"loaded CTF container for %s (%p)\n"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dmp
operator|->
name|dm_ctfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dmp
operator|->
name|dm_ctfp
operator|)
return|;
name|err
label|:
name|ctf_close
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_ctfp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|dt_module_unload
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_module_t
modifier|*
name|dmp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ctf_close
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_ctfp
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|illumos
if|if
condition|(
name|dmp
operator|->
name|dm_ctdata
operator|.
name|cts_data
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dmp
operator|->
name|dm_ctdata
operator|.
name|cts_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_data
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dmp
operator|->
name|dm_symtab
operator|.
name|cts_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_data
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_data
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|dmp
operator|->
name|dm_libctfp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dmp
operator|->
name|dm_nctflibs
condition|;
name|i
operator|++
control|)
block|{
name|ctf_close
argument_list|(
name|dmp
operator|->
name|dm_libctfp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dmp
operator|->
name|dm_libctfn
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dmp
operator|->
name|dm_libctfp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dmp
operator|->
name|dm_libctfn
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_libctfp
operator|=
name|NULL
expr_stmt|;
name|dmp
operator|->
name|dm_nctflibs
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|dmp
operator|->
name|dm_ctdata
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_sect_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dmp
operator|->
name|dm_symtab
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_sect_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dmp
operator|->
name|dm_strtab
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_sect_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_symbuckets
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dmp
operator|->
name|dm_symbuckets
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_symbuckets
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dmp
operator|->
name|dm_symchains
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dmp
operator|->
name|dm_symchains
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_symchains
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dmp
operator|->
name|dm_asmap
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dmp
operator|->
name|dm_asmap
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_asmap
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|dmp
operator|->
name|dm_sec_offsets
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dmp
operator|->
name|dm_sec_offsets
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_sec_offsets
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|dmp
operator|->
name|dm_symfree
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_nsymbuckets
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_nsymelems
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_asrsv
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_aslen
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_text_va
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_text_size
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_data_va
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_data_size
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_bss_va
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_bss_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_extern
operator|!=
name|NULL
condition|)
block|{
name|dt_idhash_destroy
argument_list|(
name|dmp
operator|->
name|dm_extern
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_extern
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|dmp
operator|->
name|dm_elf
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_elf
operator|=
name|NULL
expr_stmt|;
name|dmp
operator|->
name|dm_pid
operator|=
literal|0
expr_stmt|;
name|dmp
operator|->
name|dm_flags
operator|&=
operator|~
name|DT_DM_LOADED
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_module_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_module_t
modifier|*
name|dmp
parameter_list|)
block|{
name|uint_t
name|h
init|=
name|dt_strtab_hash
argument_list|(
name|dmp
operator|->
name|dm_name
argument_list|,
name|NULL
argument_list|)
operator|%
name|dtp
operator|->
name|dt_modbuckets
decl_stmt|;
name|dt_module_t
modifier|*
modifier|*
name|dmpp
init|=
operator|&
name|dtp
operator|->
name|dt_mods
index|[
name|h
index|]
decl_stmt|;
name|dt_list_delete
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dtp
operator|->
name|dt_nmods
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_nmods
operator|--
expr_stmt|;
comment|/* 	 * Now remove this module from its hash chain.  We expect to always 	 * find the module on its hash chain, so in this loop we assert that 	 * we don't run off the end of the list. 	 */
while|while
condition|(
operator|*
name|dmpp
operator|!=
name|dmp
condition|)
block|{
name|dmpp
operator|=
operator|&
operator|(
operator|(
operator|*
name|dmpp
operator|)
operator|->
name|dm_next
operator|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|dmpp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|dmpp
operator|=
name|dmp
operator|->
name|dm_next
expr_stmt|;
name|dt_module_unload
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert a new external symbol reference into the specified module.  The new  * symbol will be marked as undefined and is assigned a symbol index beyond  * any existing cached symbols from this module.  We use the ident's di_data  * field to store a pointer to a copy of the dtrace_syminfo_t for this symbol.  */
end_comment

begin_function
name|dt_ident_t
modifier|*
name|dt_module_extern
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_module_t
modifier|*
name|dmp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|dtrace_typeinfo_t
modifier|*
name|tip
parameter_list|)
block|{
name|dtrace_syminfo_t
modifier|*
name|sip
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|uint_t
name|id
decl_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_extern
operator|==
name|NULL
operator|&&
operator|(
name|dmp
operator|->
name|dm_extern
operator|=
name|dt_idhash_create
argument_list|(
literal|"extern"
argument_list|,
name|NULL
argument_list|,
name|dmp
operator|->
name|dm_nsymelems
argument_list|,
name|UINT_MAX
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|dt_idhash_nextid
argument_list|(
name|dmp
operator|->
name|dm_extern
argument_list|,
operator|&
name|id
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_SYMOFLOW
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sip
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_syminfo_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|idp
operator|=
name|dt_idhash_insert
argument_list|(
name|dmp
operator|->
name|dm_extern
argument_list|,
name|name
argument_list|,
name|DT_IDENT_SYMBOL
argument_list|,
literal|0
argument_list|,
name|id
argument_list|,
name|_dtrace_symattr
argument_list|,
literal|0
argument_list|,
operator|&
name|dt_idops_thaw
argument_list|,
name|NULL
argument_list|,
name|dtp
operator|->
name|dt_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sip
operator|->
name|dts_object
operator|=
name|dmp
operator|->
name|dm_name
expr_stmt|;
name|sip
operator|->
name|dts_name
operator|=
name|idp
operator|->
name|di_name
expr_stmt|;
name|sip
operator|->
name|dts_id
operator|=
name|idp
operator|->
name|di_id
expr_stmt|;
name|idp
operator|->
name|di_data
operator|=
name|sip
expr_stmt|;
name|idp
operator|->
name|di_ctfp
operator|=
name|tip
operator|->
name|dtt_ctfp
expr_stmt|;
name|idp
operator|->
name|di_type
operator|=
name|tip
operator|->
name|dtt_type
expr_stmt|;
return|return
operator|(
name|idp
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|dt_module_modelname
parameter_list|(
name|dt_module_t
modifier|*
name|dmp
parameter_list|)
block|{
if|if
condition|(
name|dmp
operator|->
name|dm_ops
operator|==
operator|&
name|dt_modops_64
condition|)
return|return
operator|(
literal|"64-bit"
operator|)
return|;
else|else
return|return
operator|(
literal|"32-bit"
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|dt_module_getlibid
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_module_t
modifier|*
name|dmp
parameter_list|,
specifier|const
name|ctf_file_t
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dmp
operator|->
name|dm_nctflibs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dmp
operator|->
name|dm_libctfp
index|[
name|i
index|]
operator|==
name|fp
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|ctf_file_t
modifier|*
name|dt_module_getctflib
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_module_t
modifier|*
name|dmp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dmp
operator|->
name|dm_nctflibs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dmp
operator|->
name|dm_libctfn
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|dmp
operator|->
name|dm_libctfp
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update our module cache by adding an entry for the specified module 'name'.  * We create the dt_module_t and populate it using /system/object/<name>/.  *  * On FreeBSD, the module name is passed as the full module file name,   * including the path.  */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|illumos
name|dt_module_update
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
else|#
directive|else
function|dt_module_update
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|struct
name|kld_file_stat
modifier|*
name|k_stat
parameter_list|)
endif|#
directive|endif
block|{
name|char
name|fname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat64
name|st
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|err
decl_stmt|,
name|bits
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|module_stat
name|ms
decl_stmt|;
name|dt_kmodule_t
modifier|*
name|dkmp
decl_stmt|;
name|uint_t
name|h
decl_stmt|;
name|int
name|modid
decl_stmt|;
endif|#
directive|endif
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|shstrs
decl_stmt|;
name|GElf_Shdr
name|sh
decl_stmt|;
name|Elf_Data
modifier|*
name|dp
decl_stmt|;
name|Elf_Scn
modifier|*
name|sp
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|fname
argument_list|,
sizeof|sizeof
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|"%s/%s/object"
argument_list|,
name|OBJFS_ROOT
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|GElf_Ehdr
name|ehdr
decl_stmt|;
name|GElf_Phdr
name|ph
decl_stmt|;
name|char
name|name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|uintptr_t
name|mapbase
decl_stmt|,
name|alignmask
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|is_elf_obj
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|name
argument_list|,
name|k_stat
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|fname
argument_list|,
name|k_stat
operator|->
name|pathname
argument_list|,
sizeof|sizeof
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
name|fstat64
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|dmp
operator|=
name|dt_module_create
argument_list|(
name|dtp
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to open %s: %s\n"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Since the module can unload out from under us (and /system/object 	 * will return ENOENT), tell libelf to cook the entire file now and 	 * then close the underlying file descriptor immediately.  If this 	 * succeeds, we know that we can continue safely using dmp->dm_elf. 	 */
name|dmp
operator|->
name|dm_elf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|ELF_C_READ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|elf_cntl
argument_list|(
name|dmp
operator|->
name|dm_elf
argument_list|,
name|ELF_C_FDREAD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_elf
operator|==
name|NULL
operator|||
name|err
operator|==
operator|-
literal|1
operator|||
name|elf_getshdrstrndx
argument_list|(
name|dmp
operator|->
name|dm_elf
argument_list|,
operator|&
name|shstrs
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to load %s: %s\n"
argument_list|,
name|fname
argument_list|,
name|elf_errmsg
argument_list|(
name|elf_errno
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dt_module_destroy
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|gelf_getclass
argument_list|(
name|dmp
operator|->
name|dm_elf
argument_list|)
condition|)
block|{
case|case
name|ELFCLASS32
case|:
name|dmp
operator|->
name|dm_ops
operator|=
operator|&
name|dt_modops_32
expr_stmt|;
name|bits
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|ELFCLASS64
case|:
name|dmp
operator|->
name|dm_ops
operator|=
operator|&
name|dt_modops_64
expr_stmt|;
name|bits
operator|=
literal|64
expr_stmt|;
break|break;
default|default:
name|dt_dprintf
argument_list|(
literal|"failed to load %s: unknown ELF class\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|dt_module_destroy
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mapbase
operator|=
operator|(
name|uintptr_t
operator|)
name|k_stat
operator|->
name|address
expr_stmt|;
name|gelf_getehdr
argument_list|(
name|dmp
operator|->
name|dm_elf
argument_list|,
operator|&
name|ehdr
argument_list|)
expr_stmt|;
name|is_elf_obj
operator|=
operator|(
name|ehdr
operator|.
name|e_type
operator|==
name|ET_REL
operator|)
expr_stmt|;
if|if
condition|(
name|is_elf_obj
condition|)
block|{
name|dmp
operator|->
name|dm_sec_offsets
operator|=
name|malloc
argument_list|(
name|ehdr
operator|.
name|e_shnum
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dmp
operator|->
name|dm_sec_offsets
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_sec_offsets
operator|==
name|NULL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to allocate memory\n"
argument_list|)
expr_stmt|;
name|dt_module_destroy
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Iterate over the section headers locating various sections of 	 * interest and use their attributes to flesh out the dt_module_t. 	 */
for|for
control|(
name|sp
operator|=
name|NULL
init|;
operator|(
name|sp
operator|=
name|elf_nextscn
argument_list|(
name|dmp
operator|->
name|dm_elf
argument_list|,
name|sp
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|sp
argument_list|,
operator|&
name|sh
argument_list|)
operator|==
name|NULL
operator|||
name|sh
operator|.
name|sh_type
operator|==
name|SHT_NULL
operator|||
operator|(
name|s
operator|=
name|elf_strptr
argument_list|(
name|dmp
operator|->
name|dm_elf
argument_list|,
name|shstrs
argument_list|,
name|sh
operator|.
name|sh_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* skip any malformed sections */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|sh
operator|.
name|sh_size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sh
operator|.
name|sh_type
operator|==
name|SHT_PROGBITS
operator|||
name|sh
operator|.
name|sh_type
operator|==
name|SHT_NOBITS
condition|)
block|{
name|alignmask
operator|=
name|sh
operator|.
name|sh_addralign
operator|-
literal|1
expr_stmt|;
name|mapbase
operator|+=
name|alignmask
expr_stmt|;
name|mapbase
operator|&=
operator|~
name|alignmask
expr_stmt|;
name|sh
operator|.
name|sh_addr
operator|=
name|mapbase
expr_stmt|;
if|if
condition|(
name|is_elf_obj
condition|)
name|dmp
operator|->
name|dm_sec_offsets
index|[
name|elf_ndxscn
argument_list|(
name|sp
argument_list|)
index|]
operator|=
name|sh
operator|.
name|sh_addr
expr_stmt|;
name|mapbase
operator|+=
name|sh
operator|.
name|sh_size
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dmp
operator|->
name|dm_text_size
operator|=
name|sh
operator|.
name|sh_size
expr_stmt|;
name|dmp
operator|->
name|dm_text_va
operator|=
name|sh
operator|.
name|sh_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dmp
operator|->
name|dm_data_size
operator|=
name|sh
operator|.
name|sh_size
expr_stmt|;
name|dmp
operator|->
name|dm_data_va
operator|=
name|sh
operator|.
name|sh_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dmp
operator|->
name|dm_bss_size
operator|=
name|sh
operator|.
name|sh_size
expr_stmt|;
name|dmp
operator|->
name|dm_bss_va
operator|=
name|sh
operator|.
name|sh_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|".info"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|dp
operator|=
name|elf_getdata
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|dp
operator|->
name|d_buf
argument_list|,
operator|&
name|dmp
operator|->
name|dm_info
argument_list|,
name|MIN
argument_list|(
name|sh
operator|.
name|sh_size
argument_list|,
sizeof|sizeof
argument_list|(
name|dmp
operator|->
name|dm_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|".filename"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|dp
operator|=
name|elf_getdata
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dmp
operator|->
name|dm_file
argument_list|,
name|dp
operator|->
name|d_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|dmp
operator|->
name|dm_file
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dmp
operator|->
name|dm_flags
operator||=
name|DT_DM_KERNEL
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|dmp
operator|->
name|dm_modid
operator|=
operator|(
name|int
operator|)
name|OBJFS_MODID
argument_list|(
name|st
operator|.
name|st_ino
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Include .rodata and special sections into .text. 	 * This depends on default section layout produced by GNU ld 	 * for ELF objects and libraries: 	 * [Text][R/O data][R/W data][Dynamic][BSS][Non loadable] 	 */
name|dmp
operator|->
name|dm_text_size
operator|=
name|dmp
operator|->
name|dm_data_va
operator|-
name|dmp
operator|->
name|dm_text_va
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
comment|/* 	 * Find the first load section and figure out the relocation 	 * offset for the symbols. The kernel module will not need 	 * relocation, but the kernel linker modules will. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|gelf_getphdr
argument_list|(
name|dmp
operator|->
name|dm_elf
argument_list|,
name|i
argument_list|,
operator|&
name|ph
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ph
operator|.
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|dmp
operator|->
name|dm_reloc_offset
operator|=
name|k_stat
operator|->
name|address
operator|-
name|ph
operator|.
name|p_vaddr
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* illumos */
if|if
condition|(
name|dmp
operator|->
name|dm_info
operator|.
name|objfs_info_primary
condition|)
name|dmp
operator|->
name|dm_flags
operator||=
name|DT_DM_PRIMARY
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|ms
operator|.
name|version
operator|=
sizeof|sizeof
argument_list|(
name|ms
argument_list|)
expr_stmt|;
for|for
control|(
name|modid
operator|=
name|kldfirstmod
argument_list|(
name|k_stat
operator|->
name|id
argument_list|)
init|;
name|modid
operator|>
literal|0
condition|;
name|modid
operator|=
name|modnext
argument_list|(
name|modid
argument_list|)
control|)
block|{
if|if
condition|(
name|modstat
argument_list|(
name|modid
argument_list|,
operator|&
name|ms
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"modstat failed for id %d in %s: %s\n"
argument_list|,
name|modid
argument_list|,
name|k_stat
operator|->
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dt_kmodule_lookup
argument_list|(
name|dtp
argument_list|,
name|ms
operator|.
name|name
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
name|dkmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dkmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dkmp
operator|==
name|NULL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to allocate memory\n"
argument_list|)
expr_stmt|;
name|dt_module_destroy
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
return|return;
block|}
name|h
operator|=
name|dt_strtab_hash
argument_list|(
name|ms
operator|.
name|name
argument_list|,
name|NULL
argument_list|)
operator|%
name|dtp
operator|->
name|dt_modbuckets
expr_stmt|;
name|dkmp
operator|->
name|dkm_next
operator|=
name|dtp
operator|->
name|dt_kmods
index|[
name|h
index|]
expr_stmt|;
name|dkmp
operator|->
name|dkm_name
operator|=
name|strdup
argument_list|(
name|ms
operator|.
name|name
argument_list|)
expr_stmt|;
name|dkmp
operator|->
name|dkm_module
operator|=
name|dmp
expr_stmt|;
name|dtp
operator|->
name|dt_kmods
index|[
name|h
index|]
operator|=
name|dkmp
expr_stmt|;
block|}
endif|#
directive|endif
name|dt_dprintf
argument_list|(
literal|"opened %d-bit module %s (%s) [%d]\n"
argument_list|,
name|bits
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
name|dmp
operator|->
name|dm_file
argument_list|,
name|dmp
operator|->
name|dm_modid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unload all the loaded modules and then refresh the module cache with the  * latest list of loaded modules and their address ranges.  */
end_comment

begin_function
name|void
name|dtrace_update
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|int
name|fileid
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|dmp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|)
init|;
name|dmp
operator|!=
name|NULL
condition|;
name|dmp
operator|=
name|dt_list_next
argument_list|(
name|dmp
argument_list|)
control|)
name|dt_module_unload
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
comment|/* 	 * Open /system/object and attempt to create a libdtrace module for 	 * each kernel module that is loaded on the current system. 	 */
if|if
condition|(
operator|!
operator|(
name|dtp
operator|->
name|dt_oflags
operator|&
name|DTRACE_O_NOSYS
operator|)
operator|&&
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|OBJFS_ROOT
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
name|dt_module_update
argument_list|(
name|dtp
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* 	 * Use FreeBSD's kernel loader interface to discover what kernel 	 * modules are loaded and create a libdtrace module for each one. 	 */
for|for
control|(
name|fileid
operator|=
name|kldnext
argument_list|(
literal|0
argument_list|)
init|;
name|fileid
operator|>
literal|0
condition|;
name|fileid
operator|=
name|kldnext
argument_list|(
name|fileid
argument_list|)
control|)
block|{
name|struct
name|kld_file_stat
name|k_stat
decl_stmt|;
name|k_stat
operator|.
name|version
operator|=
sizeof|sizeof
argument_list|(
name|k_stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|kldstat
argument_list|(
name|fileid
argument_list|,
operator|&
name|k_stat
argument_list|)
operator|==
literal|0
condition|)
name|dt_module_update
argument_list|(
name|dtp
argument_list|,
operator|&
name|k_stat
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Look up all the macro identifiers and set di_id to the latest value. 	 * This code collaborates with dt_lex.l on the use of di_id.  We will 	 * need to implement something fancier if we need to support non-ints. 	 */
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"egid"
argument_list|)
operator|->
name|di_id
operator|=
name|getegid
argument_list|()
expr_stmt|;
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"euid"
argument_list|)
operator|->
name|di_id
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"gid"
argument_list|)
operator|->
name|di_id
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"pid"
argument_list|)
operator|->
name|di_id
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"pgid"
argument_list|)
operator|->
name|di_id
operator|=
name|getpgid
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"ppid"
argument_list|)
operator|->
name|di_id
operator|=
name|getppid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"projid"
argument_list|)
operator|->
name|di_id
operator|=
name|getprojid
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"sid"
argument_list|)
operator|->
name|di_id
operator|=
name|getsid
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"taskid"
argument_list|)
operator|->
name|di_id
operator|=
name|gettaskid
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"uid"
argument_list|)
operator|->
name|di_id
operator|=
name|getuid
argument_list|()
expr_stmt|;
comment|/* 	 * Cache the pointers to the modules representing the base executable 	 * and the run-time linker in the dtrace client handle. Note that on 	 * x86 krtld is folded into unix, so if we don't find it, use unix 	 * instead. 	 */
name|dtp
operator|->
name|dt_exec
operator|=
name|dt_module_lookup_by_name
argument_list|(
name|dtp
argument_list|,
literal|"genunix"
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_rtld
operator|=
name|dt_module_lookup_by_name
argument_list|(
name|dtp
argument_list|,
literal|"krtld"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_rtld
operator|==
name|NULL
condition|)
name|dtp
operator|->
name|dt_rtld
operator|=
name|dt_module_lookup_by_name
argument_list|(
name|dtp
argument_list|,
literal|"unix"
argument_list|)
expr_stmt|;
comment|/* 	 * If this is the first time we are initializing the module list, 	 * remove the module for genunix from the module list and then move it 	 * to the front of the module list.  We do this so that type and symbol 	 * queries encounter genunix and thereby optimize for the common case 	 * in dtrace_lookup_by_name() and dtrace_lookup_by_type(), below. 	 */
if|if
condition|(
name|dtp
operator|->
name|dt_exec
operator|!=
name|NULL
operator|&&
name|dtp
operator|->
name|dt_cdefs
operator|==
name|NULL
operator|&&
name|dtp
operator|->
name|dt_ddefs
operator|==
name|NULL
condition|)
block|{
name|dt_list_delete
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|,
name|dtp
operator|->
name|dt_exec
argument_list|)
expr_stmt|;
name|dt_list_prepend
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|,
name|dtp
operator|->
name|dt_exec
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|dt_module_t
modifier|*
name|dt_module_from_object
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|object
parameter_list|)
block|{
name|int
name|err
init|=
name|EDT_NOMOD
decl_stmt|;
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
switch|switch
condition|(
operator|(
name|uintptr_t
operator|)
name|object
condition|)
block|{
case|case
operator|(
name|uintptr_t
operator|)
name|DTRACE_OBJ_EXEC
case|:
name|dmp
operator|=
name|dtp
operator|->
name|dt_exec
expr_stmt|;
break|break;
case|case
operator|(
name|uintptr_t
operator|)
name|DTRACE_OBJ_RTLD
case|:
name|dmp
operator|=
name|dtp
operator|->
name|dt_rtld
expr_stmt|;
break|break;
case|case
operator|(
name|uintptr_t
operator|)
name|DTRACE_OBJ_CDEFS
case|:
name|dmp
operator|=
name|dtp
operator|->
name|dt_cdefs
expr_stmt|;
break|break;
case|case
operator|(
name|uintptr_t
operator|)
name|DTRACE_OBJ_DDEFS
case|:
name|dmp
operator|=
name|dtp
operator|->
name|dt_ddefs
expr_stmt|;
break|break;
default|default:
name|dmp
operator|=
name|dt_module_create
argument_list|(
name|dtp
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|err
operator|=
name|EDT_NOMEM
expr_stmt|;
block|}
if|if
condition|(
name|dmp
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|dmp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Exported interface to look up a symbol by name.  We return the GElf_Sym and  * complete symbol information for the matching symbol.  */
end_comment

begin_function
name|int
name|dtrace_lookup_by_name
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GElf_Sym
modifier|*
name|symp
parameter_list|,
name|dtrace_syminfo_t
modifier|*
name|sip
parameter_list|)
block|{
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|uint_t
name|n
decl_stmt|,
name|id
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|uint_t
name|mask
init|=
literal|0
decl_stmt|;
comment|/* mask of dt_module flags to match */
name|uint_t
name|bits
init|=
literal|0
decl_stmt|;
comment|/* flag bits that must be present */
if|if
condition|(
name|object
operator|!=
name|DTRACE_OBJ_EVERY
operator|&&
name|object
operator|!=
name|DTRACE_OBJ_KMODS
operator|&&
name|object
operator|!=
name|DTRACE_OBJ_UMODS
condition|)
block|{
if|if
condition|(
operator|(
name|dmp
operator|=
name|dt_module_from_object
argument_list|(
name|dtp
argument_list|,
name|object
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dt_errno is set for us */
if|if
condition|(
name|dt_module_load
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dt_errno is set for us */
name|n
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|object
operator|==
name|DTRACE_OBJ_KMODS
condition|)
name|mask
operator|=
name|bits
operator|=
name|DT_DM_KERNEL
expr_stmt|;
elseif|else
if|if
condition|(
name|object
operator|==
name|DTRACE_OBJ_UMODS
condition|)
name|mask
operator|=
name|DT_DM_KERNEL
expr_stmt|;
name|dmp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|)
expr_stmt|;
name|n
operator|=
name|dtp
operator|->
name|dt_nmods
expr_stmt|;
block|}
if|if
condition|(
name|symp
operator|==
name|NULL
condition|)
name|symp
operator|=
operator|&
name|sym
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
operator|,
name|dmp
operator|=
name|dt_list_next
argument_list|(
name|dmp
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|dmp
operator|->
name|dm_flags
operator|&
name|mask
operator|)
operator|!=
name|bits
condition|)
continue|continue;
comment|/* failed to match required attributes */
if|if
condition|(
name|dt_module_load
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* failed to load symbol table */
if|if
condition|(
name|dmp
operator|->
name|dm_ops
operator|->
name|do_symname
argument_list|(
name|dmp
argument_list|,
name|name
argument_list|,
name|symp
argument_list|,
operator|&
name|id
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sip
operator|!=
name|NULL
condition|)
block|{
name|sip
operator|->
name|dts_object
operator|=
name|dmp
operator|->
name|dm_name
expr_stmt|;
name|sip
operator|->
name|dts_name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_data
operator|+
name|symp
operator|->
name|st_name
expr_stmt|;
name|sip
operator|->
name|dts_id
operator|=
name|id
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|dmp
operator|->
name|dm_extern
operator|!=
name|NULL
operator|&&
operator|(
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|dmp
operator|->
name|dm_extern
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|symp
operator|!=
operator|&
name|sym
condition|)
block|{
name|symp
operator|->
name|st_name
operator|=
operator|(
name|uintptr_t
operator|)
name|idp
operator|->
name|di_name
expr_stmt|;
name|symp
operator|->
name|st_info
operator|=
name|GELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_NOTYPE
argument_list|)
expr_stmt|;
name|symp
operator|->
name|st_other
operator|=
literal|0
expr_stmt|;
name|symp
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|symp
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
name|symp
operator|->
name|st_size
operator|=
name|ctf_type_size
argument_list|(
name|idp
operator|->
name|di_ctfp
argument_list|,
name|idp
operator|->
name|di_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sip
operator|!=
name|NULL
condition|)
block|{
name|sip
operator|->
name|dts_object
operator|=
name|dmp
operator|->
name|dm_name
expr_stmt|;
name|sip
operator|->
name|dts_name
operator|=
name|idp
operator|->
name|di_name
expr_stmt|;
name|sip
operator|->
name|dts_id
operator|=
name|idp
operator|->
name|di_id
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOSYM
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Exported interface to look up a symbol by address.  We return the GElf_Sym  * and complete symbol information for the matching symbol.  */
end_comment

begin_function
name|int
name|dtrace_lookup_by_addr
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|GElf_Addr
name|addr
parameter_list|,
name|GElf_Sym
modifier|*
name|symp
parameter_list|,
name|dtrace_syminfo_t
modifier|*
name|sip
parameter_list|)
block|{
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
name|uint_t
name|id
decl_stmt|;
specifier|const
name|dtrace_vector_t
modifier|*
name|v
init|=
name|dtp
operator|->
name|dt_vector
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
return|return
operator|(
name|v
operator|->
name|dtv_lookup_by_addr
argument_list|(
name|dtp
operator|->
name|dt_varg
argument_list|,
name|addr
argument_list|,
name|symp
argument_list|,
name|sip
argument_list|)
operator|)
return|;
for|for
control|(
name|dmp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|)
init|;
name|dmp
operator|!=
name|NULL
condition|;
name|dmp
operator|=
name|dt_list_next
argument_list|(
name|dmp
argument_list|)
control|)
block|{
if|if
condition|(
name|addr
operator|-
name|dmp
operator|->
name|dm_text_va
operator|<
name|dmp
operator|->
name|dm_text_size
operator|||
name|addr
operator|-
name|dmp
operator|->
name|dm_data_va
operator|<
name|dmp
operator|->
name|dm_data_size
operator|||
name|addr
operator|-
name|dmp
operator|->
name|dm_bss_va
operator|<
name|dmp
operator|->
name|dm_bss_size
condition|)
break|break;
block|}
if|if
condition|(
name|dmp
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOSYMADDR
argument_list|)
operator|)
return|;
if|if
condition|(
name|dt_module_load
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dt_errno is set for us */
if|if
condition|(
name|symp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dmp
operator|->
name|dm_ops
operator|->
name|do_symaddr
argument_list|(
name|dmp
argument_list|,
name|addr
argument_list|,
name|symp
argument_list|,
operator|&
name|id
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOSYMADDR
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|sip
operator|!=
name|NULL
condition|)
block|{
name|sip
operator|->
name|dts_object
operator|=
name|dmp
operator|->
name|dm_name
expr_stmt|;
if|if
condition|(
name|symp
operator|!=
name|NULL
condition|)
block|{
name|sip
operator|->
name|dts_name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dmp
operator|->
name|dm_strtab
operator|.
name|cts_data
operator|+
name|symp
operator|->
name|st_name
expr_stmt|;
name|sip
operator|->
name|dts_id
operator|=
name|id
expr_stmt|;
block|}
else|else
block|{
name|sip
operator|->
name|dts_name
operator|=
name|NULL
expr_stmt|;
name|sip
operator|->
name|dts_id
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_lookup_by_type
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dtrace_typeinfo_t
modifier|*
name|tip
parameter_list|)
block|{
name|dtrace_typeinfo_t
name|ti
decl_stmt|;
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|ctf_id_t
name|id
decl_stmt|;
name|uint_t
name|n
decl_stmt|,
name|i
decl_stmt|;
name|int
name|justone
decl_stmt|;
name|ctf_file_t
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|uint_t
name|mask
init|=
literal|0
decl_stmt|;
comment|/* mask of dt_module flags to match */
name|uint_t
name|bits
init|=
literal|0
decl_stmt|;
comment|/* flag bits that must be present */
if|if
condition|(
name|object
operator|!=
name|DTRACE_OBJ_EVERY
operator|&&
name|object
operator|!=
name|DTRACE_OBJ_KMODS
operator|&&
name|object
operator|!=
name|DTRACE_OBJ_UMODS
condition|)
block|{
if|if
condition|(
operator|(
name|dmp
operator|=
name|dt_module_from_object
argument_list|(
name|dtp
argument_list|,
name|object
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dt_errno is set for us */
if|if
condition|(
name|dt_module_load
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dt_errno is set for us */
name|n
operator|=
literal|1
expr_stmt|;
name|justone
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|object
operator|==
name|DTRACE_OBJ_KMODS
condition|)
name|mask
operator|=
name|bits
operator|=
name|DT_DM_KERNEL
expr_stmt|;
elseif|else
if|if
condition|(
name|object
operator|==
name|DTRACE_OBJ_UMODS
condition|)
name|mask
operator|=
name|DT_DM_KERNEL
expr_stmt|;
name|dmp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|)
expr_stmt|;
name|n
operator|=
name|dtp
operator|->
name|dt_nmods
expr_stmt|;
name|justone
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tip
operator|==
name|NULL
condition|)
name|tip
operator|=
operator|&
name|ti
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
operator|,
name|dmp
operator|=
name|dt_list_next
argument_list|(
name|dmp
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|dmp
operator|->
name|dm_flags
operator|&
name|mask
operator|)
operator|!=
name|bits
condition|)
continue|continue;
comment|/* failed to match required attributes */
comment|/* 		 * If we can't load the CTF container, continue on to the next 		 * module.  If our search was scoped to only one module then 		 * return immediately leaving dt_errno unmodified. 		 */
if|if
condition|(
name|dt_module_hasctf
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|justone
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
continue|continue;
block|}
comment|/* 		 * Look up the type in the module's CTF container.  If our 		 * match is a forward declaration tag, save this choice in 		 * 'tip' and keep going in the hope that we will locate the 		 * underlying structure definition.  Otherwise just return. 		 */
if|if
condition|(
name|dmp
operator|->
name|dm_pid
operator|==
literal|0
condition|)
block|{
name|id
operator|=
name|ctf_lookup_by_name
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fp
operator|=
name|dmp
operator|->
name|dm_ctfp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'`'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|buf
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'`'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|'`'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|p
operator|=
name|q
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|fp
operator|=
name|dt_module_getctflib
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
operator|||
operator|(
name|id
operator|=
name|ctf_lookup_by_name
argument_list|(
name|fp
argument_list|,
name|p
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
name|id
operator|=
name|CTF_ERR
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dmp
operator|->
name|dm_nctflibs
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
name|dmp
operator|->
name|dm_libctfp
index|[
name|i
index|]
expr_stmt|;
name|id
operator|=
name|ctf_lookup_by_name
argument_list|(
name|fp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|CTF_ERR
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|id
operator|!=
name|CTF_ERR
condition|)
block|{
name|tip
operator|->
name|dtt_object
operator|=
name|dmp
operator|->
name|dm_name
expr_stmt|;
name|tip
operator|->
name|dtt_ctfp
operator|=
name|fp
expr_stmt|;
name|tip
operator|->
name|dtt_type
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|id
argument_list|)
argument_list|)
operator|!=
name|CTF_K_FORWARD
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|found
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOTYPE
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_symbol_type
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|symp
parameter_list|,
specifier|const
name|dtrace_syminfo_t
modifier|*
name|sip
parameter_list|,
name|dtrace_typeinfo_t
modifier|*
name|tip
parameter_list|)
block|{
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
name|tip
operator|->
name|dtt_object
operator|=
name|NULL
expr_stmt|;
name|tip
operator|->
name|dtt_ctfp
operator|=
name|NULL
expr_stmt|;
name|tip
operator|->
name|dtt_type
operator|=
name|CTF_ERR
expr_stmt|;
name|tip
operator|->
name|dtt_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|dmp
operator|=
name|dt_module_lookup_by_name
argument_list|(
name|dtp
argument_list|,
name|sip
operator|->
name|dts_object
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMOD
argument_list|)
operator|)
return|;
if|if
condition|(
name|symp
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
operator|&&
name|dmp
operator|->
name|dm_extern
operator|!=
name|NULL
condition|)
block|{
name|dt_ident_t
modifier|*
name|idp
init|=
name|dt_idhash_lookup
argument_list|(
name|dmp
operator|->
name|dm_extern
argument_list|,
name|sip
operator|->
name|dts_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|idp
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOSYM
argument_list|)
operator|)
return|;
name|tip
operator|->
name|dtt_ctfp
operator|=
name|idp
operator|->
name|di_ctfp
expr_stmt|;
name|tip
operator|->
name|dtt_type
operator|=
name|idp
operator|->
name|di_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
condition|)
block|{
if|if
condition|(
name|dt_module_getctf
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
name|tip
operator|->
name|dtt_ctfp
operator|=
name|dmp
operator|->
name|dm_ctfp
expr_stmt|;
name|tip
operator|->
name|dtt_type
operator|=
name|ctf_lookup_by_symbol
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|sip
operator|->
name|dts_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|->
name|dtt_type
operator|==
name|CTF_ERR
condition|)
block|{
name|dtp
operator|->
name|dt_ctferr
operator|=
name|ctf_errno
argument_list|(
name|tip
operator|->
name|dtt_ctfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_CTF
argument_list|)
operator|)
return|;
block|}
block|}
else|else
block|{
name|tip
operator|->
name|dtt_ctfp
operator|=
name|DT_FPTR_CTFP
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|tip
operator|->
name|dtt_type
operator|=
name|DT_FPTR_TYPE
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
block|}
name|tip
operator|->
name|dtt_object
operator|=
name|dmp
operator|->
name|dm_name
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dtrace_objinfo_t
modifier|*
name|dt_module_info
parameter_list|(
specifier|const
name|dt_module_t
modifier|*
name|dmp
parameter_list|,
name|dtrace_objinfo_t
modifier|*
name|dto
parameter_list|)
block|{
name|dto
operator|->
name|dto_name
operator|=
name|dmp
operator|->
name|dm_name
expr_stmt|;
name|dto
operator|->
name|dto_file
operator|=
name|dmp
operator|->
name|dm_file
expr_stmt|;
name|dto
operator|->
name|dto_id
operator|=
name|dmp
operator|->
name|dm_modid
expr_stmt|;
name|dto
operator|->
name|dto_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_flags
operator|&
name|DT_DM_KERNEL
condition|)
name|dto
operator|->
name|dto_flags
operator||=
name|DTRACE_OBJ_F_KERNEL
expr_stmt|;
if|if
condition|(
name|dmp
operator|->
name|dm_flags
operator|&
name|DT_DM_PRIMARY
condition|)
name|dto
operator|->
name|dto_flags
operator||=
name|DTRACE_OBJ_F_PRIMARY
expr_stmt|;
name|dto
operator|->
name|dto_text_va
operator|=
name|dmp
operator|->
name|dm_text_va
expr_stmt|;
name|dto
operator|->
name|dto_text_size
operator|=
name|dmp
operator|->
name|dm_text_size
expr_stmt|;
name|dto
operator|->
name|dto_data_va
operator|=
name|dmp
operator|->
name|dm_data_va
expr_stmt|;
name|dto
operator|->
name|dto_data_size
operator|=
name|dmp
operator|->
name|dm_data_size
expr_stmt|;
name|dto
operator|->
name|dto_bss_va
operator|=
name|dmp
operator|->
name|dm_bss_va
expr_stmt|;
name|dto
operator|->
name|dto_bss_size
operator|=
name|dmp
operator|->
name|dm_bss_size
expr_stmt|;
return|return
operator|(
name|dto
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_object_iter
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_obj_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|dt_module_t
modifier|*
name|dmp
init|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|)
decl_stmt|;
name|dtrace_objinfo_t
name|dto
decl_stmt|;
name|int
name|rv
decl_stmt|;
for|for
control|(
init|;
name|dmp
operator|!=
name|NULL
condition|;
name|dmp
operator|=
name|dt_list_next
argument_list|(
name|dmp
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|rv
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|dtp
argument_list|,
name|dt_module_info
argument_list|(
name|dmp
argument_list|,
operator|&
name|dto
argument_list|)
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_object_info
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|object
parameter_list|,
name|dtrace_objinfo_t
modifier|*
name|dto
parameter_list|)
block|{
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
if|if
condition|(
name|object
operator|==
name|DTRACE_OBJ_EVERY
operator|||
name|object
operator|==
name|DTRACE_OBJ_KMODS
operator|||
name|object
operator|==
name|DTRACE_OBJ_UMODS
operator|||
name|dto
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|dmp
operator|=
name|dt_module_from_object
argument_list|(
name|dtp
argument_list|,
name|object
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dt_errno is set for us */
if|if
condition|(
name|dt_module_load
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dt_errno is set for us */
operator|(
name|void
operator|)
name|dt_module_info
argument_list|(
name|dmp
argument_list|,
name|dto
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

