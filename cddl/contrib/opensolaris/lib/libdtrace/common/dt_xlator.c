begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013 by Delphix. All rights reserved.  * Copyright (c) 2013 Joyent, Inc. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<dt_xlator.h>
end_include

begin_include
include|#
directive|include
file|<dt_parser.h>
end_include

begin_include
include|#
directive|include
file|<dt_grammar.h>
end_include

begin_include
include|#
directive|include
file|<dt_module.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_comment
comment|/*  * Create a member node corresponding to one of the output members of a dynamic  * translator.  We set the member's dn_membexpr to a DT_NODE_XLATOR node that  * has dn_op set to DT_TOK_XLATE and refers back to the translator itself.  The  * code generator will then use this as the indicator for dynamic translation.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_xlator_create_member
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|ulong_t
name|off
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dt_xlator_t
modifier|*
name|dxp
init|=
name|arg
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|dxp
operator|->
name|dx_hdl
decl_stmt|;
name|dt_node_t
modifier|*
name|enp
decl_stmt|,
modifier|*
name|mnp
decl_stmt|;
if|if
condition|(
operator|(
name|enp
operator|=
name|dt_node_xalloc
argument_list|(
name|dtp
argument_list|,
name|DT_NODE_XLATOR
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
name|enp
operator|->
name|dn_link
operator|=
name|dxp
operator|->
name|dx_nodes
expr_stmt|;
name|dxp
operator|->
name|dx_nodes
operator|=
name|enp
expr_stmt|;
if|if
condition|(
operator|(
name|mnp
operator|=
name|dt_node_xalloc
argument_list|(
name|dtp
argument_list|,
name|DT_NODE_MEMBER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
name|mnp
operator|->
name|dn_link
operator|=
name|dxp
operator|->
name|dx_nodes
expr_stmt|;
name|dxp
operator|->
name|dx_nodes
operator|=
name|mnp
expr_stmt|;
comment|/* 	 * For the member expression, we use a DT_NODE_XLATOR/TOK_XLATE whose 	 * xlator refers back to the translator and whose dn_xmember refers to 	 * the current member.  These refs will be used by dt_cg.c and dt_as.c. 	 */
name|enp
operator|->
name|dn_op
operator|=
name|DT_TOK_XLATE
expr_stmt|;
name|enp
operator|->
name|dn_xlator
operator|=
name|dxp
expr_stmt|;
name|enp
operator|->
name|dn_xmember
operator|=
name|mnp
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|enp
argument_list|,
name|dxp
operator|->
name|dx_dst_ctfp
argument_list|,
name|type
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * For the member itself, we use a DT_NODE_MEMBER as usual with the 	 * appropriate name, output type, and member expression set to 'enp'. 	 */
if|if
condition|(
name|dxp
operator|->
name|dx_members
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|enp
operator|->
name|dn_link
operator|->
name|dn_kind
operator|==
name|DT_NODE_MEMBER
argument_list|)
expr_stmt|;
name|enp
operator|->
name|dn_link
operator|->
name|dn_list
operator|=
name|mnp
expr_stmt|;
block|}
else|else
name|dxp
operator|->
name|dx_members
operator|=
name|mnp
expr_stmt|;
name|mnp
operator|->
name|dn_membname
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|mnp
operator|->
name|dn_membexpr
operator|=
name|enp
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|mnp
argument_list|,
name|dxp
operator|->
name|dx_dst_ctfp
argument_list|,
name|type
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnp
operator|->
name|dn_membname
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|dt_xlator_t
modifier|*
name|dt_xlator_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dtrace_typeinfo_t
modifier|*
name|src
parameter_list|,
specifier|const
name|dtrace_typeinfo_t
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dt_node_t
modifier|*
name|members
parameter_list|,
name|dt_node_t
modifier|*
name|nodes
parameter_list|)
block|{
name|dt_xlator_t
modifier|*
name|dxp
init|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_xlator_t
argument_list|)
argument_list|)
decl_stmt|;
name|dtrace_typeinfo_t
name|ptr
init|=
operator|*
name|dst
decl_stmt|;
name|dt_xlator_t
modifier|*
modifier|*
name|map
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
name|uint_t
name|kind
decl_stmt|;
if|if
condition|(
name|dxp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dxp
operator|->
name|dx_hdl
operator|=
name|dtp
expr_stmt|;
name|dxp
operator|->
name|dx_id
operator|=
name|dtp
operator|->
name|dt_xlatorid
operator|++
expr_stmt|;
name|dxp
operator|->
name|dx_gen
operator|=
name|dtp
operator|->
name|dt_gen
expr_stmt|;
name|dxp
operator|->
name|dx_arg
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|map
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|dxp
operator|->
name|dx_id
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dxp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dt_list_append
argument_list|(
operator|&
name|dtp
operator|->
name|dt_xlators
argument_list|,
name|dxp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dtp
operator|->
name|dt_xlatormap
argument_list|,
name|map
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|dxp
operator|->
name|dx_id
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dtp
operator|->
name|dt_xlatormap
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_xlatormap
operator|=
name|map
expr_stmt|;
name|dtp
operator|->
name|dt_xlatormap
index|[
name|dxp
operator|->
name|dx_id
index|]
operator|=
name|dxp
expr_stmt|;
if|if
condition|(
name|dt_type_pointer
argument_list|(
operator|&
name|ptr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ptr
operator|.
name|dtt_ctfp
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|.
name|dtt_type
operator|=
name|CTF_ERR
expr_stmt|;
block|}
name|dxp
operator|->
name|dx_ident
operator|=
name|dt_ident_create
argument_list|(
name|name
condition|?
name|name
else|:
literal|"T"
argument_list|,
name|DT_IDENT_SCALAR
argument_list|,
name|DT_IDFLG_REF
operator||
name|DT_IDFLG_ORPHAN
argument_list|,
literal|0
argument_list|,
name|_dtrace_defattr
argument_list|,
literal|0
argument_list|,
operator|&
name|dt_idops_thaw
argument_list|,
name|NULL
argument_list|,
name|dtp
operator|->
name|dt_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|dxp
operator|->
name|dx_ident
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* no memory for identifier */
name|dxp
operator|->
name|dx_ident
operator|->
name|di_ctfp
operator|=
name|src
operator|->
name|dtt_ctfp
expr_stmt|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_type
operator|=
name|src
operator|->
name|dtt_type
expr_stmt|;
comment|/* 	 * If an input parameter name is given, this is a static translator 	 * definition: create an idhash and identifier for the parameter. 	 */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|dxp
operator|->
name|dx_locals
operator|=
name|dt_idhash_create
argument_list|(
literal|"xlparams"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dxp
operator|->
name|dx_locals
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* no memory for identifier hash */
name|dt_idhash_xinsert
argument_list|(
name|dxp
operator|->
name|dx_locals
argument_list|,
name|dxp
operator|->
name|dx_ident
argument_list|)
expr_stmt|;
block|}
name|dxp
operator|->
name|dx_souid
operator|.
name|di_name
operator|=
literal|"translator"
expr_stmt|;
name|dxp
operator|->
name|dx_souid
operator|.
name|di_kind
operator|=
name|DT_IDENT_XLSOU
expr_stmt|;
name|dxp
operator|->
name|dx_souid
operator|.
name|di_flags
operator|=
name|DT_IDFLG_REF
expr_stmt|;
name|dxp
operator|->
name|dx_souid
operator|.
name|di_id
operator|=
name|dxp
operator|->
name|dx_id
expr_stmt|;
name|dxp
operator|->
name|dx_souid
operator|.
name|di_attr
operator|=
name|_dtrace_defattr
expr_stmt|;
name|dxp
operator|->
name|dx_souid
operator|.
name|di_ops
operator|=
operator|&
name|dt_idops_thaw
expr_stmt|;
name|dxp
operator|->
name|dx_souid
operator|.
name|di_data
operator|=
name|dxp
expr_stmt|;
name|dxp
operator|->
name|dx_souid
operator|.
name|di_ctfp
operator|=
name|dst
operator|->
name|dtt_ctfp
expr_stmt|;
name|dxp
operator|->
name|dx_souid
operator|.
name|di_type
operator|=
name|dst
operator|->
name|dtt_type
expr_stmt|;
name|dxp
operator|->
name|dx_souid
operator|.
name|di_gen
operator|=
name|dtp
operator|->
name|dt_gen
expr_stmt|;
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_name
operator|=
literal|"translator"
expr_stmt|;
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_kind
operator|=
name|DT_IDENT_XLPTR
expr_stmt|;
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_flags
operator|=
name|DT_IDFLG_REF
expr_stmt|;
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_id
operator|=
name|dxp
operator|->
name|dx_id
expr_stmt|;
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_attr
operator|=
name|_dtrace_defattr
expr_stmt|;
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_ops
operator|=
operator|&
name|dt_idops_thaw
expr_stmt|;
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_data
operator|=
name|dxp
expr_stmt|;
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_ctfp
operator|=
name|ptr
operator|.
name|dtt_ctfp
expr_stmt|;
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_type
operator|=
name|ptr
operator|.
name|dtt_type
expr_stmt|;
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_gen
operator|=
name|dtp
operator|->
name|dt_gen
expr_stmt|;
comment|/* 	 * If a deferred pragma is pending on the keyword "translator", run all 	 * the deferred pragmas on dx_souid and then copy results to dx_ptrid. 	 * See the code in dt_pragma.c for details on deferred ident pragmas. 	 */
if|if
condition|(
name|dtp
operator|->
name|dt_globals
operator|->
name|dh_defer
operator|!=
name|NULL
operator|&&
name|yypcb
operator|->
name|pcb_pragmas
operator|!=
name|NULL
operator|&&
name|dt_idhash_lookup
argument_list|(
name|yypcb
operator|->
name|pcb_pragmas
argument_list|,
literal|"translator"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|dtp
operator|->
name|dt_globals
operator|->
name|dh_defer
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|,
operator|&
name|dxp
operator|->
name|dx_souid
argument_list|)
expr_stmt|;
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_attr
operator|=
name|dxp
operator|->
name|dx_souid
operator|.
name|di_attr
expr_stmt|;
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_vers
operator|=
name|dxp
operator|->
name|dx_souid
operator|.
name|di_vers
expr_stmt|;
block|}
name|dxp
operator|->
name|dx_src_ctfp
operator|=
name|src
operator|->
name|dtt_ctfp
expr_stmt|;
name|dxp
operator|->
name|dx_src_type
operator|=
name|src
operator|->
name|dtt_type
expr_stmt|;
name|dxp
operator|->
name|dx_src_base
operator|=
name|ctf_type_resolve
argument_list|(
name|src
operator|->
name|dtt_ctfp
argument_list|,
name|src
operator|->
name|dtt_type
argument_list|)
expr_stmt|;
name|dxp
operator|->
name|dx_dst_ctfp
operator|=
name|dst
operator|->
name|dtt_ctfp
expr_stmt|;
name|dxp
operator|->
name|dx_dst_type
operator|=
name|dst
operator|->
name|dtt_type
expr_stmt|;
name|dxp
operator|->
name|dx_dst_base
operator|=
name|ctf_type_resolve
argument_list|(
name|dst
operator|->
name|dtt_ctfp
argument_list|,
name|dst
operator|->
name|dtt_type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|dst
operator|->
name|dtt_ctfp
argument_list|,
name|dxp
operator|->
name|dx_dst_base
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|kind
operator|==
name|CTF_K_STRUCT
operator|||
name|kind
operator|==
name|CTF_K_UNION
argument_list|)
expr_stmt|;
comment|/* 	 * If no input parameter is given, we're making a dynamic translator: 	 * create member nodes for every member of the output type.  Otherwise 	 * retain the member and allocation node lists presented by the parser. 	 */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ctf_member_iter
argument_list|(
name|dxp
operator|->
name|dx_dst_ctfp
argument_list|,
name|dxp
operator|->
name|dx_dst_base
argument_list|,
name|dt_xlator_create_member
argument_list|,
name|dxp
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|dxp
operator|->
name|dx_members
operator|=
name|members
expr_stmt|;
name|dxp
operator|->
name|dx_nodes
operator|=
name|nodes
expr_stmt|;
block|}
comment|/* 	 * Assign member IDs to each member and allocate space for DIFOs 	 * if and when this translator is eventually compiled. 	 */
for|for
control|(
name|dnp
operator|=
name|dxp
operator|->
name|dx_members
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
control|)
block|{
name|dnp
operator|->
name|dn_membxlator
operator|=
name|dxp
expr_stmt|;
name|dnp
operator|->
name|dn_membid
operator|=
name|dxp
operator|->
name|dx_nmembers
operator|++
expr_stmt|;
block|}
name|dxp
operator|->
name|dx_membdif
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_difo_t
operator|*
argument_list|)
operator|*
name|dxp
operator|->
name|dx_nmembers
argument_list|)
expr_stmt|;
if|if
condition|(
name|dxp
operator|->
name|dx_membdif
operator|==
name|NULL
condition|)
block|{
name|dxp
operator|->
name|dx_nmembers
operator|=
literal|0
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
operator|(
name|dxp
operator|)
return|;
name|err
label|:
name|dt_xlator_destroy
argument_list|(
name|dtp
argument_list|,
name|dxp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_xlator_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_xlator_t
modifier|*
name|dxp
parameter_list|)
block|{
name|uint_t
name|i
decl_stmt|;
name|dt_node_link_free
argument_list|(
operator|&
name|dxp
operator|->
name|dx_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|dxp
operator|->
name|dx_locals
operator|!=
name|NULL
condition|)
name|dt_idhash_destroy
argument_list|(
name|dxp
operator|->
name|dx_locals
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dxp
operator|->
name|dx_ident
operator|!=
name|NULL
condition|)
name|dt_ident_destroy
argument_list|(
name|dxp
operator|->
name|dx_ident
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dxp
operator|->
name|dx_nmembers
condition|;
name|i
operator|++
control|)
name|dt_difo_free
argument_list|(
name|dtp
argument_list|,
name|dxp
operator|->
name|dx_membdif
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dxp
operator|->
name|dx_membdif
argument_list|)
expr_stmt|;
name|dt_list_delete
argument_list|(
operator|&
name|dtp
operator|->
name|dt_xlators
argument_list|,
name|dxp
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dxp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dt_xlator_t
modifier|*
name|dt_xlator_lookup
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_node_t
modifier|*
name|src
parameter_list|,
name|dt_node_t
modifier|*
name|dst
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|src_ctfp
init|=
name|src
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_id_t
name|src_type
init|=
name|src
operator|->
name|dn_type
decl_stmt|;
name|ctf_id_t
name|src_base
init|=
name|ctf_type_resolve
argument_list|(
name|src_ctfp
argument_list|,
name|src_type
argument_list|)
decl_stmt|;
name|ctf_file_t
modifier|*
name|dst_ctfp
init|=
name|dst
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_id_t
name|dst_type
init|=
name|dst
operator|->
name|dn_type
decl_stmt|;
name|ctf_id_t
name|dst_base
init|=
name|ctf_type_resolve
argument_list|(
name|dst_ctfp
argument_list|,
name|dst_type
argument_list|)
decl_stmt|;
name|uint_t
name|dst_kind
init|=
name|ctf_type_kind
argument_list|(
name|dst_ctfp
argument_list|,
name|dst_base
argument_list|)
decl_stmt|;
name|int
name|ptr
init|=
name|dst_kind
operator|==
name|CTF_K_POINTER
decl_stmt|;
name|dtrace_typeinfo_t
name|src_dtt
decl_stmt|,
name|dst_dtt
decl_stmt|;
name|dt_node_t
name|xn
init|=
block|{
literal|0
block|}
decl_stmt|;
name|dt_xlator_t
modifier|*
name|dxp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|src_base
operator|==
name|CTF_ERR
operator|||
name|dst_base
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* fail if these are unresolvable types */
comment|/* 	 * Translators are always defined using a struct or union type, so if 	 * we are attempting to translate to type "T *", we internally look 	 * for a translation to type "T" by following the pointer reference. 	 */
if|if
condition|(
name|ptr
condition|)
block|{
name|dst_type
operator|=
name|ctf_type_reference
argument_list|(
name|dst_ctfp
argument_list|,
name|dst_type
argument_list|)
expr_stmt|;
name|dst_base
operator|=
name|ctf_type_resolve
argument_list|(
name|dst_ctfp
argument_list|,
name|dst_type
argument_list|)
expr_stmt|;
name|dst_kind
operator|=
name|ctf_type_kind
argument_list|(
name|dst_ctfp
argument_list|,
name|dst_base
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst_kind
operator|!=
name|CTF_K_UNION
operator|&&
name|dst_kind
operator|!=
name|CTF_K_STRUCT
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* fail if the output isn't a struct or union */
comment|/* 	 * In order to find a matching translator, we iterate over the set of 	 * available translators in three passes.  First, we look for a 	 * translation from the exact source type to the resolved destination. 	 * Second, we look for a translation from the resolved source type to 	 * the resolved destination.  Third, we look for a translation from a 	 * compatible source type (using the same rules as parameter formals) 	 * to the resolved destination.  If all passes fail, return NULL. 	 */
for|for
control|(
name|dxp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_xlators
argument_list|)
init|;
name|dxp
operator|!=
name|NULL
condition|;
name|dxp
operator|=
name|dt_list_next
argument_list|(
name|dxp
argument_list|)
control|)
block|{
if|if
condition|(
name|ctf_type_compat
argument_list|(
name|dxp
operator|->
name|dx_src_ctfp
argument_list|,
name|dxp
operator|->
name|dx_src_type
argument_list|,
name|src_ctfp
argument_list|,
name|src_type
argument_list|)
operator|&&
name|ctf_type_compat
argument_list|(
name|dxp
operator|->
name|dx_dst_ctfp
argument_list|,
name|dxp
operator|->
name|dx_dst_base
argument_list|,
name|dst_ctfp
argument_list|,
name|dst_base
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|flags
operator|&
name|DT_XLATE_EXACT
condition|)
goto|goto
name|out
goto|;
comment|/* skip remaining passes if exact match required */
for|for
control|(
name|dxp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_xlators
argument_list|)
init|;
name|dxp
operator|!=
name|NULL
condition|;
name|dxp
operator|=
name|dt_list_next
argument_list|(
name|dxp
argument_list|)
control|)
block|{
if|if
condition|(
name|ctf_type_compat
argument_list|(
name|dxp
operator|->
name|dx_src_ctfp
argument_list|,
name|dxp
operator|->
name|dx_src_base
argument_list|,
name|src_ctfp
argument_list|,
name|src_type
argument_list|)
operator|&&
name|ctf_type_compat
argument_list|(
name|dxp
operator|->
name|dx_dst_ctfp
argument_list|,
name|dxp
operator|->
name|dx_dst_base
argument_list|,
name|dst_ctfp
argument_list|,
name|dst_base
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|dxp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_xlators
argument_list|)
init|;
name|dxp
operator|!=
name|NULL
condition|;
name|dxp
operator|=
name|dt_list_next
argument_list|(
name|dxp
argument_list|)
control|)
block|{
name|dt_node_type_assign
argument_list|(
operator|&
name|xn
argument_list|,
name|dxp
operator|->
name|dx_src_ctfp
argument_list|,
name|dxp
operator|->
name|dx_src_type
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctf_type_compat
argument_list|(
name|dxp
operator|->
name|dx_dst_ctfp
argument_list|,
name|dxp
operator|->
name|dx_dst_base
argument_list|,
name|dst_ctfp
argument_list|,
name|dst_base
argument_list|)
operator|&&
name|dt_node_is_argcompat
argument_list|(
name|src
argument_list|,
operator|&
name|xn
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|ptr
operator|&&
name|dxp
operator|!=
name|NULL
operator|&&
name|dxp
operator|->
name|dx_ptrid
operator|.
name|di_type
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* no translation available to pointer type */
if|if
condition|(
name|dxp
operator|!=
name|NULL
operator|||
operator|!
operator|(
name|flags
operator|&
name|DT_XLATE_EXTERN
operator|)
operator|||
name|dtp
operator|->
name|dt_xlatemode
operator|==
name|DT_XL_STATIC
condition|)
return|return
operator|(
name|dxp
operator|)
return|;
comment|/* we succeeded or not allowed to extern */
comment|/* 	 * If we get here, then we didn't find an existing translator, but the 	 * caller and xlatemode permit us to create an extern to a dynamic one. 	 */
name|src_dtt
operator|.
name|dtt_object
operator|=
name|dt_module_lookup_by_ctf
argument_list|(
name|dtp
argument_list|,
name|src_ctfp
argument_list|)
operator|->
name|dm_name
expr_stmt|;
name|src_dtt
operator|.
name|dtt_ctfp
operator|=
name|src_ctfp
expr_stmt|;
name|src_dtt
operator|.
name|dtt_type
operator|=
name|src_type
expr_stmt|;
name|dst_dtt
operator|.
name|dtt_object
operator|=
name|dt_module_lookup_by_ctf
argument_list|(
name|dtp
argument_list|,
name|dst_ctfp
argument_list|)
operator|->
name|dm_name
expr_stmt|;
name|dst_dtt
operator|.
name|dtt_ctfp
operator|=
name|dst_ctfp
expr_stmt|;
name|dst_dtt
operator|.
name|dtt_type
operator|=
name|dst_type
expr_stmt|;
return|return
operator|(
name|dt_xlator_create
argument_list|(
name|dtp
argument_list|,
operator|&
name|src_dtt
argument_list|,
operator|&
name|dst_dtt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|dt_xlator_t
modifier|*
name|dt_xlator_lookup_id
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|id_t
name|id
parameter_list|)
block|{
name|assert
argument_list|(
name|id
operator|>=
literal|0
operator|&&
name|id
operator|<
name|dtp
operator|->
name|dt_xlatorid
argument_list|)
expr_stmt|;
return|return
operator|(
name|dtp
operator|->
name|dt_xlatormap
index|[
name|id
index|]
operator|)
return|;
block|}
end_function

begin_function
name|dt_ident_t
modifier|*
name|dt_xlator_ident
parameter_list|(
name|dt_xlator_t
modifier|*
name|dxp
parameter_list|,
name|ctf_file_t
modifier|*
name|ctfp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
if|if
condition|(
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
argument_list|)
operator|==
name|CTF_K_POINTER
condition|)
return|return
operator|(
operator|&
name|dxp
operator|->
name|dx_ptrid
operator|)
return|;
else|else
return|return
operator|(
operator|&
name|dxp
operator|->
name|dx_souid
operator|)
return|;
block|}
end_function

begin_function
name|dt_node_t
modifier|*
name|dt_xlator_member
parameter_list|(
name|dt_xlator_t
modifier|*
name|dxp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
for|for
control|(
name|dnp
operator|=
name|dxp
operator|->
name|dx_members
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dnp
operator|->
name|dn_membname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|dnp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_xlator_dynamic
parameter_list|(
specifier|const
name|dt_xlator_t
modifier|*
name|dxp
parameter_list|)
block|{
return|return
operator|(
name|dxp
operator|->
name|dx_locals
operator|==
name|NULL
operator|)
return|;
block|}
end_function

end_unit

