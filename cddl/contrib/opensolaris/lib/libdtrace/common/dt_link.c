begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_define
define|#
directive|define
name|ELF_TARGET_ALL
end_define

begin_include
include|#
directive|include
file|<elf.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|P2ROUNDUP
parameter_list|(
name|x
parameter_list|,
name|align
parameter_list|)
value|(-(-(x)& -(align)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<wait.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<libelf.h>
end_include

begin_include
include|#
directive|include
file|<gelf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<sys/ipc.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_include
include|#
directive|include
file|<dt_provider.h>
end_include

begin_include
include|#
directive|include
file|<dt_program.h>
end_include

begin_include
include|#
directive|include
file|<dt_string.h>
end_include

begin_define
define|#
directive|define
name|ESHDR_NULL
value|0
end_define

begin_define
define|#
directive|define
name|ESHDR_SHSTRTAB
value|1
end_define

begin_define
define|#
directive|define
name|ESHDR_DOF
value|2
end_define

begin_define
define|#
directive|define
name|ESHDR_STRTAB
value|3
end_define

begin_define
define|#
directive|define
name|ESHDR_SYMTAB
value|4
end_define

begin_define
define|#
directive|define
name|ESHDR_REL
value|5
end_define

begin_define
define|#
directive|define
name|ESHDR_NUM
value|6
end_define

begin_define
define|#
directive|define
name|PWRITE_SCN
parameter_list|(
name|index
parameter_list|,
name|data
parameter_list|)
define|\
value|(lseek64(fd, (off64_t)elf_file.shdr[(index)].sh_offset, SEEK_SET) != \ 	(off64_t)elf_file.shdr[(index)].sh_offset || \ 	dt_write(dtp, fd, (data), elf_file.shdr[(index)].sh_size) != \ 	elf_file.shdr[(index)].sh_size)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|DTRACE_SHSTRTAB32
index|[]
init|=
literal|"\0"
literal|".shstrtab\0"
comment|/* 1 */
literal|".SUNW_dof\0"
comment|/* 11 */
literal|".strtab\0"
comment|/* 21 */
literal|".symtab\0"
comment|/* 29 */
ifdef|#
directive|ifdef
name|__sparc
literal|".rela.SUNW_dof"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 37 */
end_comment

begin_else
else|#
directive|else
end_else

begin_expr_stmt
literal|".rel.SUNW_dof"
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 37 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|DTRACE_SHSTRTAB64
index|[]
init|=
literal|"\0"
literal|".shstrtab\0"
comment|/* 1 */
literal|".SUNW_dof\0"
comment|/* 11 */
literal|".strtab\0"
comment|/* 21 */
literal|".symtab\0"
comment|/* 29 */
literal|".rela.SUNW_dof"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 37 */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|DOFSTR
index|[]
init|=
literal|"__SUNW_dof"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|DOFLAZYSTR
index|[]
init|=
literal|"___SUNW_dof"
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|dt_link_pair
block|{
name|struct
name|dt_link_pair
modifier|*
name|dlp_next
decl_stmt|;
comment|/* next pair in linked list */
name|void
modifier|*
name|dlp_str
decl_stmt|;
comment|/* buffer for string table */
name|void
modifier|*
name|dlp_sym
decl_stmt|;
comment|/* buffer for symbol table */
block|}
name|dt_link_pair_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|dof_elf32
block|{
name|uint32_t
name|de_nrel
decl_stmt|;
comment|/* relocation count */
ifdef|#
directive|ifdef
name|__sparc
name|Elf32_Rela
modifier|*
name|de_rel
decl_stmt|;
comment|/* array of relocations for sparc */
else|#
directive|else
name|Elf32_Rel
modifier|*
name|de_rel
decl_stmt|;
comment|/* array of relocations for x86 */
endif|#
directive|endif
name|uint32_t
name|de_nsym
decl_stmt|;
comment|/* symbol count */
name|Elf32_Sym
modifier|*
name|de_sym
decl_stmt|;
comment|/* array of symbols */
name|uint32_t
name|de_strlen
decl_stmt|;
comment|/* size of of string table */
name|char
modifier|*
name|de_strtab
decl_stmt|;
comment|/* string table */
name|uint32_t
name|de_global
decl_stmt|;
comment|/* index of the first global symbol */
block|}
name|dof_elf32_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|prepare_elf32
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|dof_elf32_t
modifier|*
name|dep
parameter_list|)
block|{
name|dof_sec_t
modifier|*
name|dofs
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|dof_relohdr_t
modifier|*
name|dofrh
decl_stmt|;
name|dof_relodesc_t
modifier|*
name|dofr
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nrel
decl_stmt|;
name|size_t
name|strtabsz
init|=
literal|1
decl_stmt|;
name|uint32_t
name|count
init|=
literal|0
decl_stmt|;
name|size_t
name|base
decl_stmt|;
name|Elf32_Sym
modifier|*
name|sym
decl_stmt|;
ifdef|#
directive|ifdef
name|__sparc
name|Elf32_Rela
modifier|*
name|rel
decl_stmt|;
else|#
directive|else
name|Elf32_Rel
modifier|*
name|rel
decl_stmt|;
endif|#
directive|endif
comment|/*LINTED*/
name|dofs
operator|=
operator|(
name|dof_sec_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dof
operator|+
name|dof
operator|->
name|dofh_secoff
operator|)
expr_stmt|;
comment|/* 	 * First compute the size of the string table and the number of 	 * relocations present in the DOF. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dof
operator|->
name|dofh_secnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dofs
index|[
name|i
index|]
operator|.
name|dofs_type
operator|!=
name|DOF_SECT_URELHDR
condition|)
continue|continue;
comment|/*LINTED*/
name|dofrh
operator|=
operator|(
name|dof_relohdr_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dof
operator|+
name|dofs
index|[
name|i
index|]
operator|.
name|dofs_offset
operator|)
expr_stmt|;
name|s
operator|=
operator|&
name|dofs
index|[
name|dofrh
operator|->
name|dofr_strtab
index|]
expr_stmt|;
name|strtab
operator|=
operator|(
name|char
operator|*
operator|)
name|dof
operator|+
name|s
operator|->
name|dofs_offset
expr_stmt|;
name|assert
argument_list|(
name|strtab
index|[
literal|0
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|strtabsz
operator|+=
name|s
operator|->
name|dofs_size
operator|-
literal|1
expr_stmt|;
name|s
operator|=
operator|&
name|dofs
index|[
name|dofrh
operator|->
name|dofr_relsec
index|]
expr_stmt|;
comment|/*LINTED*/
name|dofr
operator|=
operator|(
name|dof_relodesc_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dof
operator|+
name|s
operator|->
name|dofs_offset
operator|)
expr_stmt|;
name|count
operator|+=
name|s
operator|->
name|dofs_size
operator|/
name|s
operator|->
name|dofs_entsize
expr_stmt|;
block|}
name|dep
operator|->
name|de_strlen
operator|=
name|strtabsz
expr_stmt|;
name|dep
operator|->
name|de_nrel
operator|=
name|count
expr_stmt|;
name|dep
operator|->
name|de_nsym
operator|=
name|count
operator|+
literal|1
expr_stmt|;
comment|/* the first symbol is always null */
if|if
condition|(
name|dtp
operator|->
name|dt_lazyload
condition|)
block|{
name|dep
operator|->
name|de_strlen
operator|+=
sizeof|sizeof
argument_list|(
name|DOFLAZYSTR
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_nsym
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dep
operator|->
name|de_strlen
operator|+=
sizeof|sizeof
argument_list|(
name|DOFSTR
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_nsym
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dep
operator|->
name|de_rel
operator|=
name|calloc
argument_list|(
name|dep
operator|->
name|de_nrel
argument_list|,
sizeof|sizeof
argument_list|(
name|dep
operator|->
name|de_rel
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dep
operator|->
name|de_sym
operator|=
name|calloc
argument_list|(
name|dep
operator|->
name|de_nsym
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dep
operator|->
name|de_rel
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dep
operator|->
name|de_strtab
operator|=
name|calloc
argument_list|(
name|dep
operator|->
name|de_strlen
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dep
operator|->
name|de_rel
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dep
operator|->
name|de_sym
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|strtabsz
operator|=
literal|1
expr_stmt|;
name|dep
operator|->
name|de_strtab
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rel
operator|=
name|dep
operator|->
name|de_rel
expr_stmt|;
name|sym
operator|=
name|dep
operator|->
name|de_sym
expr_stmt|;
name|dep
operator|->
name|de_global
operator|=
literal|1
expr_stmt|;
comment|/* 	 * The first symbol table entry must be zeroed and is always ignored. 	 */
name|bzero
argument_list|(
name|sym
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|++
expr_stmt|;
comment|/* 	 * Take a second pass through the DOF sections filling in the 	 * memory we allocated. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dof
operator|->
name|dofh_secnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dofs
index|[
name|i
index|]
operator|.
name|dofs_type
operator|!=
name|DOF_SECT_URELHDR
condition|)
continue|continue;
comment|/*LINTED*/
name|dofrh
operator|=
operator|(
name|dof_relohdr_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dof
operator|+
name|dofs
index|[
name|i
index|]
operator|.
name|dofs_offset
operator|)
expr_stmt|;
name|s
operator|=
operator|&
name|dofs
index|[
name|dofrh
operator|->
name|dofr_strtab
index|]
expr_stmt|;
name|strtab
operator|=
operator|(
name|char
operator|*
operator|)
name|dof
operator|+
name|s
operator|->
name|dofs_offset
expr_stmt|;
name|bcopy
argument_list|(
name|strtab
operator|+
literal|1
argument_list|,
name|dep
operator|->
name|de_strtab
operator|+
name|strtabsz
argument_list|,
name|s
operator|->
name|dofs_size
argument_list|)
expr_stmt|;
name|base
operator|=
name|strtabsz
expr_stmt|;
name|strtabsz
operator|+=
name|s
operator|->
name|dofs_size
operator|-
literal|1
expr_stmt|;
name|s
operator|=
operator|&
name|dofs
index|[
name|dofrh
operator|->
name|dofr_relsec
index|]
expr_stmt|;
comment|/*LINTED*/
name|dofr
operator|=
operator|(
name|dof_relodesc_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dof
operator|+
name|s
operator|->
name|dofs_offset
operator|)
expr_stmt|;
name|nrel
operator|=
name|s
operator|->
name|dofs_size
operator|/
name|s
operator|->
name|dofs_entsize
expr_stmt|;
name|s
operator|=
operator|&
name|dofs
index|[
name|dofrh
operator|->
name|dofr_tgtsec
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nrel
condition|;
name|j
operator|++
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
comment|/* XXX */
name|printf
argument_list|(
literal|"%s:%s(%d): DOODAD\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__ia64__
argument_list|)
comment|/* XXX */
name|printf
argument_list|(
literal|"%s:%s(%d): DOODAD\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64
argument_list|)
name|rel
operator|->
name|r_offset
operator|=
name|s
operator|->
name|dofs_offset
operator|+
name|dofr
index|[
name|j
index|]
operator|.
name|dofr_offset
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|count
operator|+
name|dep
operator|->
name|de_global
argument_list|,
name|R_386_32
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__mips__
argument_list|)
comment|/* XXX */
name|printf
argument_list|(
literal|"%s:%s(%d): DOODAD\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__powerpc__
argument_list|)
comment|/* 			 * Add 4 bytes to hit the low half of this 64-bit 			 * big-endian address. 			 */
name|rel
operator|->
name|r_offset
operator|=
name|s
operator|->
name|dofs_offset
operator|+
name|dofr
index|[
name|j
index|]
operator|.
name|dofr_offset
operator|+
literal|4
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|count
operator|+
name|dep
operator|->
name|de_global
argument_list|,
name|R_PPC_REL32
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__sparc
argument_list|)
comment|/* 			 * Add 4 bytes to hit the low half of this 64-bit 			 * big-endian address. 			 */
name|rel
operator|->
name|r_offset
operator|=
name|s
operator|->
name|dofs_offset
operator|+
name|dofr
index|[
name|j
index|]
operator|.
name|dofr_offset
operator|+
literal|4
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|count
operator|+
name|dep
operator|->
name|de_global
argument_list|,
name|R_SPARC_32
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|unknown ISA
endif|#
directive|endif
name|sym
operator|->
name|st_name
operator|=
name|base
operator|+
name|dofr
index|[
name|j
index|]
operator|.
name|dofr_name
operator|-
literal|1
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_size
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|ELF32_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_other
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|rel
operator|++
expr_stmt|;
name|sym
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Add a symbol for the DOF itself. We use a different symbol for 	 * lazily and actively loaded DOF to make them easy to distinguish. 	 */
name|sym
operator|->
name|st_name
operator|=
name|strtabsz
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_size
operator|=
name|dof
operator|->
name|dofh_filesz
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|ELF32_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_OBJECT
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_other
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|ESHDR_DOF
expr_stmt|;
name|sym
operator|++
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_lazyload
condition|)
block|{
name|bcopy
argument_list|(
name|DOFLAZYSTR
argument_list|,
name|dep
operator|->
name|de_strtab
operator|+
name|strtabsz
argument_list|,
sizeof|sizeof
argument_list|(
name|DOFLAZYSTR
argument_list|)
argument_list|)
expr_stmt|;
name|strtabsz
operator|+=
sizeof|sizeof
argument_list|(
name|DOFLAZYSTR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|DOFSTR
argument_list|,
name|dep
operator|->
name|de_strtab
operator|+
name|strtabsz
argument_list|,
sizeof|sizeof
argument_list|(
name|DOFSTR
argument_list|)
argument_list|)
expr_stmt|;
name|strtabsz
operator|+=
sizeof|sizeof
argument_list|(
name|DOFSTR
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|count
operator|==
name|dep
operator|->
name|de_nrel
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strtabsz
operator|==
name|dep
operator|->
name|de_strlen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dof_elf64
block|{
name|uint32_t
name|de_nrel
decl_stmt|;
name|Elf64_Rela
modifier|*
name|de_rel
decl_stmt|;
name|uint32_t
name|de_nsym
decl_stmt|;
name|Elf64_Sym
modifier|*
name|de_sym
decl_stmt|;
name|uint32_t
name|de_strlen
decl_stmt|;
name|char
modifier|*
name|de_strtab
decl_stmt|;
name|uint32_t
name|de_global
decl_stmt|;
block|}
name|dof_elf64_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|prepare_elf64
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|dof_elf64_t
modifier|*
name|dep
parameter_list|)
block|{
name|dof_sec_t
modifier|*
name|dofs
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|dof_relohdr_t
modifier|*
name|dofrh
decl_stmt|;
name|dof_relodesc_t
modifier|*
name|dofr
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nrel
decl_stmt|;
name|size_t
name|strtabsz
init|=
literal|1
decl_stmt|;
name|uint32_t
name|count
init|=
literal|0
decl_stmt|;
name|size_t
name|base
decl_stmt|;
name|Elf64_Sym
modifier|*
name|sym
decl_stmt|;
name|Elf64_Rela
modifier|*
name|rel
decl_stmt|;
comment|/*LINTED*/
name|dofs
operator|=
operator|(
name|dof_sec_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dof
operator|+
name|dof
operator|->
name|dofh_secoff
operator|)
expr_stmt|;
comment|/* 	 * First compute the size of the string table and the number of 	 * relocations present in the DOF. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dof
operator|->
name|dofh_secnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dofs
index|[
name|i
index|]
operator|.
name|dofs_type
operator|!=
name|DOF_SECT_URELHDR
condition|)
continue|continue;
comment|/*LINTED*/
name|dofrh
operator|=
operator|(
name|dof_relohdr_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dof
operator|+
name|dofs
index|[
name|i
index|]
operator|.
name|dofs_offset
operator|)
expr_stmt|;
name|s
operator|=
operator|&
name|dofs
index|[
name|dofrh
operator|->
name|dofr_strtab
index|]
expr_stmt|;
name|strtab
operator|=
operator|(
name|char
operator|*
operator|)
name|dof
operator|+
name|s
operator|->
name|dofs_offset
expr_stmt|;
name|assert
argument_list|(
name|strtab
index|[
literal|0
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|strtabsz
operator|+=
name|s
operator|->
name|dofs_size
operator|-
literal|1
expr_stmt|;
name|s
operator|=
operator|&
name|dofs
index|[
name|dofrh
operator|->
name|dofr_relsec
index|]
expr_stmt|;
comment|/*LINTED*/
name|dofr
operator|=
operator|(
name|dof_relodesc_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dof
operator|+
name|s
operator|->
name|dofs_offset
operator|)
expr_stmt|;
name|count
operator|+=
name|s
operator|->
name|dofs_size
operator|/
name|s
operator|->
name|dofs_entsize
expr_stmt|;
block|}
name|dep
operator|->
name|de_strlen
operator|=
name|strtabsz
expr_stmt|;
name|dep
operator|->
name|de_nrel
operator|=
name|count
expr_stmt|;
name|dep
operator|->
name|de_nsym
operator|=
name|count
operator|+
literal|1
expr_stmt|;
comment|/* the first symbol is always null */
if|if
condition|(
name|dtp
operator|->
name|dt_lazyload
condition|)
block|{
name|dep
operator|->
name|de_strlen
operator|+=
sizeof|sizeof
argument_list|(
name|DOFLAZYSTR
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_nsym
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dep
operator|->
name|de_strlen
operator|+=
sizeof|sizeof
argument_list|(
name|DOFSTR
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_nsym
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dep
operator|->
name|de_rel
operator|=
name|calloc
argument_list|(
name|dep
operator|->
name|de_nrel
argument_list|,
sizeof|sizeof
argument_list|(
name|dep
operator|->
name|de_rel
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dep
operator|->
name|de_sym
operator|=
name|calloc
argument_list|(
name|dep
operator|->
name|de_nsym
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dep
operator|->
name|de_rel
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dep
operator|->
name|de_strtab
operator|=
name|calloc
argument_list|(
name|dep
operator|->
name|de_strlen
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dep
operator|->
name|de_rel
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dep
operator|->
name|de_sym
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|strtabsz
operator|=
literal|1
expr_stmt|;
name|dep
operator|->
name|de_strtab
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rel
operator|=
name|dep
operator|->
name|de_rel
expr_stmt|;
name|sym
operator|=
name|dep
operator|->
name|de_sym
expr_stmt|;
name|dep
operator|->
name|de_global
operator|=
literal|1
expr_stmt|;
comment|/* 	 * The first symbol table entry must be zeroed and is always ignored. 	 */
name|bzero
argument_list|(
name|sym
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|++
expr_stmt|;
comment|/* 	 * Take a second pass through the DOF sections filling in the 	 * memory we allocated. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dof
operator|->
name|dofh_secnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dofs
index|[
name|i
index|]
operator|.
name|dofs_type
operator|!=
name|DOF_SECT_URELHDR
condition|)
continue|continue;
comment|/*LINTED*/
name|dofrh
operator|=
operator|(
name|dof_relohdr_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dof
operator|+
name|dofs
index|[
name|i
index|]
operator|.
name|dofs_offset
operator|)
expr_stmt|;
name|s
operator|=
operator|&
name|dofs
index|[
name|dofrh
operator|->
name|dofr_strtab
index|]
expr_stmt|;
name|strtab
operator|=
operator|(
name|char
operator|*
operator|)
name|dof
operator|+
name|s
operator|->
name|dofs_offset
expr_stmt|;
name|bcopy
argument_list|(
name|strtab
operator|+
literal|1
argument_list|,
name|dep
operator|->
name|de_strtab
operator|+
name|strtabsz
argument_list|,
name|s
operator|->
name|dofs_size
argument_list|)
expr_stmt|;
name|base
operator|=
name|strtabsz
expr_stmt|;
name|strtabsz
operator|+=
name|s
operator|->
name|dofs_size
operator|-
literal|1
expr_stmt|;
name|s
operator|=
operator|&
name|dofs
index|[
name|dofrh
operator|->
name|dofr_relsec
index|]
expr_stmt|;
comment|/*LINTED*/
name|dofr
operator|=
operator|(
name|dof_relodesc_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dof
operator|+
name|s
operator|->
name|dofs_offset
operator|)
expr_stmt|;
name|nrel
operator|=
name|s
operator|->
name|dofs_size
operator|/
name|s
operator|->
name|dofs_entsize
expr_stmt|;
name|s
operator|=
operator|&
name|dofs
index|[
name|dofrh
operator|->
name|dofr_tgtsec
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nrel
condition|;
name|j
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DOODAD
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
comment|/* XXX */
elif|#
directive|elif
name|defined
argument_list|(
name|__ia64__
argument_list|)
comment|/* XXX */
elif|#
directive|elif
name|defined
argument_list|(
name|__mips__
argument_list|)
comment|/* XXX */
elif|#
directive|elif
name|defined
argument_list|(
name|__powerpc__
argument_list|)
name|rel
operator|->
name|r_offset
operator|=
name|s
operator|->
name|dofs_offset
operator|+
name|dofr
index|[
name|j
index|]
operator|.
name|dofr_offset
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|count
operator|+
name|dep
operator|->
name|de_global
argument_list|,
name|R_PPC64_REL64
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64
argument_list|)
name|rel
operator|->
name|r_offset
operator|=
name|s
operator|->
name|dofs_offset
operator|+
name|dofr
index|[
name|j
index|]
operator|.
name|dofr_offset
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|count
operator|+
name|dep
operator|->
name|de_global
argument_list|,
name|R_AMD64_64
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__sparc
argument_list|)
name|rel
operator|->
name|r_offset
operator|=
name|s
operator|->
name|dofs_offset
operator|+
name|dofr
index|[
name|j
index|]
operator|.
name|dofr_offset
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|count
operator|+
name|dep
operator|->
name|de_global
argument_list|,
name|R_SPARC_64
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|unknown ISA
endif|#
directive|endif
endif|#
directive|endif
name|sym
operator|->
name|st_name
operator|=
name|base
operator|+
name|dofr
index|[
name|j
index|]
operator|.
name|dofr_name
operator|-
literal|1
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_size
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|GELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_other
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|rel
operator|++
expr_stmt|;
name|sym
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Add a symbol for the DOF itself. We use a different symbol for 	 * lazily and actively loaded DOF to make them easy to distinguish. 	 */
name|sym
operator|->
name|st_name
operator|=
name|strtabsz
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_size
operator|=
name|dof
operator|->
name|dofh_filesz
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|GELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_OBJECT
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_other
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|ESHDR_DOF
expr_stmt|;
name|sym
operator|++
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_lazyload
condition|)
block|{
name|bcopy
argument_list|(
name|DOFLAZYSTR
argument_list|,
name|dep
operator|->
name|de_strtab
operator|+
name|strtabsz
argument_list|,
sizeof|sizeof
argument_list|(
name|DOFLAZYSTR
argument_list|)
argument_list|)
expr_stmt|;
name|strtabsz
operator|+=
sizeof|sizeof
argument_list|(
name|DOFLAZYSTR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|DOFSTR
argument_list|,
name|dep
operator|->
name|de_strtab
operator|+
name|strtabsz
argument_list|,
sizeof|sizeof
argument_list|(
name|DOFSTR
argument_list|)
argument_list|)
expr_stmt|;
name|strtabsz
operator|+=
sizeof|sizeof
argument_list|(
name|DOFSTR
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|count
operator|==
name|dep
operator|->
name|de_nrel
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strtabsz
operator|==
name|dep
operator|->
name|de_strlen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write out an ELF32 file prologue consisting of a header, section headers,  * and a section header string table.  The DOF data will follow this prologue  * and complete the contents of the given ELF file.  */
end_comment

begin_function
specifier|static
name|int
name|dump_elf32
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
struct|struct
block|{
name|Elf32_Ehdr
name|ehdr
decl_stmt|;
name|Elf32_Shdr
name|shdr
index|[
name|ESHDR_NUM
index|]
decl_stmt|;
block|}
name|elf_file
struct|;
name|Elf32_Shdr
modifier|*
name|shp
decl_stmt|;
name|Elf32_Off
name|off
decl_stmt|;
name|dof_elf32_t
name|de
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|uint_t
name|nshdr
decl_stmt|;
if|if
condition|(
name|prepare_elf32
argument_list|(
name|dtp
argument_list|,
name|dof
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
comment|/* 	 * If there are no relocations, we only need enough sections for 	 * the shstrtab and the DOF. 	 */
name|nshdr
operator|=
name|de
operator|.
name|de_nrel
operator|==
literal|0
condition|?
name|ESHDR_SYMTAB
operator|+
literal|1
else|:
name|ESHDR_NUM
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|elf_file
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_file
argument_list|)
argument_list|)
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_MAG0
index|]
operator|=
name|ELFMAG0
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_MAG1
index|]
operator|=
name|ELFMAG1
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_MAG2
index|]
operator|=
name|ELFMAG2
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_MAG3
index|]
operator|=
name|ELFMAG3
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
operator|=
name|EV_CURRENT
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|ELFCLASS32
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|_BIG_ENDIAN
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|ELFDATA2MSB
expr_stmt|;
else|#
directive|else
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|ELFDATA2LSB
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_FREEBSD
expr_stmt|;
endif|#
directive|endif
name|elf_file
operator|.
name|ehdr
operator|.
name|e_type
operator|=
name|ET_REL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
name|elf_file
operator|.
name|ehdr
operator|.
name|e_machine
operator|=
name|EM_ARM
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__ia64__
argument_list|)
name|elf_file
operator|.
name|ehdr
operator|.
name|e_machine
operator|=
name|EM_IA_64
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__mips__
argument_list|)
name|elf_file
operator|.
name|ehdr
operator|.
name|e_machine
operator|=
name|EM_MIPS
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__powerpc__
argument_list|)
name|elf_file
operator|.
name|ehdr
operator|.
name|e_machine
operator|=
name|EM_PPC
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__sparc
argument_list|)
name|elf_file
operator|.
name|ehdr
operator|.
name|e_machine
operator|=
name|EM_SPARC
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64
argument_list|)
name|elf_file
operator|.
name|ehdr
operator|.
name|e_machine
operator|=
name|EM_386
expr_stmt|;
endif|#
directive|endif
name|elf_file
operator|.
name|ehdr
operator|.
name|e_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_shoff
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Ehdr
argument_list|)
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ehsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Ehdr
argument_list|)
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_phentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Phdr
argument_list|)
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_shentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Shdr
argument_list|)
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_shnum
operator|=
name|nshdr
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_shstrndx
operator|=
name|ESHDR_SHSTRTAB
expr_stmt|;
name|off
operator|=
sizeof|sizeof
argument_list|(
name|elf_file
argument_list|)
operator|+
name|nshdr
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_Shdr
argument_list|)
expr_stmt|;
name|shp
operator|=
operator|&
name|elf_file
operator|.
name|shdr
index|[
name|ESHDR_SHSTRTAB
index|]
expr_stmt|;
name|shp
operator|->
name|sh_name
operator|=
literal|1
expr_stmt|;
comment|/* DTRACE_SHSTRTAB32[1] = ".shstrtab" */
name|shp
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|shp
operator|->
name|sh_offset
operator|=
name|off
expr_stmt|;
name|shp
operator|->
name|sh_size
operator|=
sizeof|sizeof
argument_list|(
name|DTRACE_SHSTRTAB32
argument_list|)
expr_stmt|;
name|shp
operator|->
name|sh_addralign
operator|=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
name|off
operator|=
name|P2ROUNDUP
argument_list|(
name|shp
operator|->
name|sh_offset
operator|+
name|shp
operator|->
name|sh_size
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|shp
operator|=
operator|&
name|elf_file
operator|.
name|shdr
index|[
name|ESHDR_DOF
index|]
expr_stmt|;
name|shp
operator|->
name|sh_name
operator|=
literal|11
expr_stmt|;
comment|/* DTRACE_SHSTRTAB32[11] = ".SUNW_dof" */
name|shp
operator|->
name|sh_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|shp
operator|->
name|sh_type
operator|=
name|SHT_SUNW_dof
expr_stmt|;
name|shp
operator|->
name|sh_offset
operator|=
name|off
expr_stmt|;
name|shp
operator|->
name|sh_size
operator|=
name|dof
operator|->
name|dofh_filesz
expr_stmt|;
name|shp
operator|->
name|sh_addralign
operator|=
literal|8
expr_stmt|;
name|off
operator|=
name|shp
operator|->
name|sh_offset
operator|+
name|shp
operator|->
name|sh_size
expr_stmt|;
name|shp
operator|=
operator|&
name|elf_file
operator|.
name|shdr
index|[
name|ESHDR_STRTAB
index|]
expr_stmt|;
name|shp
operator|->
name|sh_name
operator|=
literal|21
expr_stmt|;
comment|/* DTRACE_SHSTRTAB32[21] = ".strtab" */
name|shp
operator|->
name|sh_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|shp
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|shp
operator|->
name|sh_offset
operator|=
name|off
expr_stmt|;
name|shp
operator|->
name|sh_size
operator|=
name|de
operator|.
name|de_strlen
expr_stmt|;
name|shp
operator|->
name|sh_addralign
operator|=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
name|off
operator|=
name|P2ROUNDUP
argument_list|(
name|shp
operator|->
name|sh_offset
operator|+
name|shp
operator|->
name|sh_size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|shp
operator|=
operator|&
name|elf_file
operator|.
name|shdr
index|[
name|ESHDR_SYMTAB
index|]
expr_stmt|;
name|shp
operator|->
name|sh_name
operator|=
literal|29
expr_stmt|;
comment|/* DTRACE_SHSTRTAB32[29] = ".symtab" */
name|shp
operator|->
name|sh_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|shp
operator|->
name|sh_type
operator|=
name|SHT_SYMTAB
expr_stmt|;
name|shp
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
expr_stmt|;
name|shp
operator|->
name|sh_link
operator|=
name|ESHDR_STRTAB
expr_stmt|;
name|shp
operator|->
name|sh_offset
operator|=
name|off
expr_stmt|;
name|shp
operator|->
name|sh_info
operator|=
name|de
operator|.
name|de_global
expr_stmt|;
name|shp
operator|->
name|sh_size
operator|=
name|de
operator|.
name|de_nsym
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
expr_stmt|;
name|shp
operator|->
name|sh_addralign
operator|=
literal|4
expr_stmt|;
name|off
operator|=
name|P2ROUNDUP
argument_list|(
name|shp
operator|->
name|sh_offset
operator|+
name|shp
operator|->
name|sh_size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|de
operator|.
name|de_nrel
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dt_write
argument_list|(
name|dtp
argument_list|,
name|fd
argument_list|,
operator|&
name|elf_file
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_file
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|elf_file
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_SHSTRTAB
argument_list|,
name|DTRACE_SHSTRTAB32
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_STRTAB
argument_list|,
name|de
operator|.
name|de_strtab
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_SYMTAB
argument_list|,
name|de
operator|.
name|de_sym
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_DOF
argument_list|,
name|dof
argument_list|)
condition|)
block|{
name|ret
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|shp
operator|=
operator|&
name|elf_file
operator|.
name|shdr
index|[
name|ESHDR_REL
index|]
expr_stmt|;
name|shp
operator|->
name|sh_name
operator|=
literal|37
expr_stmt|;
comment|/* DTRACE_SHSTRTAB32[37] = ".rel.SUNW_dof" */
name|shp
operator|->
name|sh_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
ifdef|#
directive|ifdef
name|__sparc
name|shp
operator|->
name|sh_type
operator|=
name|SHT_RELA
expr_stmt|;
else|#
directive|else
name|shp
operator|->
name|sh_type
operator|=
name|SHT_REL
expr_stmt|;
endif|#
directive|endif
name|shp
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|de
operator|.
name|de_rel
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|shp
operator|->
name|sh_link
operator|=
name|ESHDR_SYMTAB
expr_stmt|;
name|shp
operator|->
name|sh_info
operator|=
name|ESHDR_DOF
expr_stmt|;
name|shp
operator|->
name|sh_offset
operator|=
name|off
expr_stmt|;
name|shp
operator|->
name|sh_size
operator|=
name|de
operator|.
name|de_nrel
operator|*
sizeof|sizeof
argument_list|(
name|de
operator|.
name|de_rel
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|shp
operator|->
name|sh_addralign
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|dt_write
argument_list|(
name|dtp
argument_list|,
name|fd
argument_list|,
operator|&
name|elf_file
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_file
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|elf_file
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_SHSTRTAB
argument_list|,
name|DTRACE_SHSTRTAB32
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_STRTAB
argument_list|,
name|de
operator|.
name|de_strtab
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_SYMTAB
argument_list|,
name|de
operator|.
name|de_sym
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_REL
argument_list|,
name|de
operator|.
name|de_rel
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_DOF
argument_list|,
name|dof
argument_list|)
condition|)
block|{
name|ret
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|de
operator|.
name|de_strtab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|de
operator|.
name|de_sym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|de
operator|.
name|de_rel
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write out an ELF64 file prologue consisting of a header, section headers,  * and a section header string table.  The DOF data will follow this prologue  * and complete the contents of the given ELF file.  */
end_comment

begin_function
specifier|static
name|int
name|dump_elf64
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
struct|struct
block|{
name|Elf64_Ehdr
name|ehdr
decl_stmt|;
name|Elf64_Shdr
name|shdr
index|[
name|ESHDR_NUM
index|]
decl_stmt|;
block|}
name|elf_file
struct|;
name|Elf64_Shdr
modifier|*
name|shp
decl_stmt|;
name|Elf64_Off
name|off
decl_stmt|;
name|dof_elf64_t
name|de
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|uint_t
name|nshdr
decl_stmt|;
if|if
condition|(
name|prepare_elf64
argument_list|(
name|dtp
argument_list|,
name|dof
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
comment|/* 	 * If there are no relocations, we only need enough sections for 	 * the shstrtab and the DOF. 	 */
name|nshdr
operator|=
name|de
operator|.
name|de_nrel
operator|==
literal|0
condition|?
name|ESHDR_SYMTAB
operator|+
literal|1
else|:
name|ESHDR_NUM
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|elf_file
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_file
argument_list|)
argument_list|)
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_MAG0
index|]
operator|=
name|ELFMAG0
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_MAG1
index|]
operator|=
name|ELFMAG1
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_MAG2
index|]
operator|=
name|ELFMAG2
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_MAG3
index|]
operator|=
name|ELFMAG3
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
operator|=
name|EV_CURRENT
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|ELFCLASS64
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|_BIG_ENDIAN
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|ELFDATA2MSB
expr_stmt|;
else|#
directive|else
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|ELFDATA2LSB
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_FREEBSD
expr_stmt|;
endif|#
directive|endif
name|elf_file
operator|.
name|ehdr
operator|.
name|e_type
operator|=
name|ET_REL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
name|elf_file
operator|.
name|ehdr
operator|.
name|e_machine
operator|=
name|EM_ARM
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__ia64__
argument_list|)
name|elf_file
operator|.
name|ehdr
operator|.
name|e_machine
operator|=
name|EM_IA_64
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__mips__
argument_list|)
name|elf_file
operator|.
name|ehdr
operator|.
name|e_machine
operator|=
name|EM_MIPS
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__powerpc__
argument_list|)
name|elf_file
operator|.
name|ehdr
operator|.
name|e_machine
operator|=
name|EM_PPC
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__sparc
argument_list|)
name|elf_file
operator|.
name|ehdr
operator|.
name|e_machine
operator|=
name|EM_SPARCV9
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64
argument_list|)
name|elf_file
operator|.
name|ehdr
operator|.
name|e_machine
operator|=
name|EM_AMD64
expr_stmt|;
endif|#
directive|endif
name|elf_file
operator|.
name|ehdr
operator|.
name|e_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_shoff
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_Ehdr
argument_list|)
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_ehsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_Ehdr
argument_list|)
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_phentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_Phdr
argument_list|)
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_shentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_Shdr
argument_list|)
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_shnum
operator|=
name|nshdr
expr_stmt|;
name|elf_file
operator|.
name|ehdr
operator|.
name|e_shstrndx
operator|=
name|ESHDR_SHSTRTAB
expr_stmt|;
name|off
operator|=
sizeof|sizeof
argument_list|(
name|elf_file
argument_list|)
operator|+
name|nshdr
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_Shdr
argument_list|)
expr_stmt|;
name|shp
operator|=
operator|&
name|elf_file
operator|.
name|shdr
index|[
name|ESHDR_SHSTRTAB
index|]
expr_stmt|;
name|shp
operator|->
name|sh_name
operator|=
literal|1
expr_stmt|;
comment|/* DTRACE_SHSTRTAB64[1] = ".shstrtab" */
name|shp
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|shp
operator|->
name|sh_offset
operator|=
name|off
expr_stmt|;
name|shp
operator|->
name|sh_size
operator|=
sizeof|sizeof
argument_list|(
name|DTRACE_SHSTRTAB64
argument_list|)
expr_stmt|;
name|shp
operator|->
name|sh_addralign
operator|=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
name|off
operator|=
name|P2ROUNDUP
argument_list|(
name|shp
operator|->
name|sh_offset
operator|+
name|shp
operator|->
name|sh_size
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|shp
operator|=
operator|&
name|elf_file
operator|.
name|shdr
index|[
name|ESHDR_DOF
index|]
expr_stmt|;
name|shp
operator|->
name|sh_name
operator|=
literal|11
expr_stmt|;
comment|/* DTRACE_SHSTRTAB64[11] = ".SUNW_dof" */
name|shp
operator|->
name|sh_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|shp
operator|->
name|sh_type
operator|=
name|SHT_SUNW_dof
expr_stmt|;
name|shp
operator|->
name|sh_offset
operator|=
name|off
expr_stmt|;
name|shp
operator|->
name|sh_size
operator|=
name|dof
operator|->
name|dofh_filesz
expr_stmt|;
name|shp
operator|->
name|sh_addralign
operator|=
literal|8
expr_stmt|;
name|off
operator|=
name|shp
operator|->
name|sh_offset
operator|+
name|shp
operator|->
name|sh_size
expr_stmt|;
name|shp
operator|=
operator|&
name|elf_file
operator|.
name|shdr
index|[
name|ESHDR_STRTAB
index|]
expr_stmt|;
name|shp
operator|->
name|sh_name
operator|=
literal|21
expr_stmt|;
comment|/* DTRACE_SHSTRTAB64[21] = ".strtab" */
name|shp
operator|->
name|sh_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|shp
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|shp
operator|->
name|sh_offset
operator|=
name|off
expr_stmt|;
name|shp
operator|->
name|sh_size
operator|=
name|de
operator|.
name|de_strlen
expr_stmt|;
name|shp
operator|->
name|sh_addralign
operator|=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
name|off
operator|=
name|P2ROUNDUP
argument_list|(
name|shp
operator|->
name|sh_offset
operator|+
name|shp
operator|->
name|sh_size
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|shp
operator|=
operator|&
name|elf_file
operator|.
name|shdr
index|[
name|ESHDR_SYMTAB
index|]
expr_stmt|;
name|shp
operator|->
name|sh_name
operator|=
literal|29
expr_stmt|;
comment|/* DTRACE_SHSTRTAB64[29] = ".symtab" */
name|shp
operator|->
name|sh_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|shp
operator|->
name|sh_type
operator|=
name|SHT_SYMTAB
expr_stmt|;
name|shp
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
expr_stmt|;
name|shp
operator|->
name|sh_link
operator|=
name|ESHDR_STRTAB
expr_stmt|;
name|shp
operator|->
name|sh_offset
operator|=
name|off
expr_stmt|;
name|shp
operator|->
name|sh_info
operator|=
name|de
operator|.
name|de_global
expr_stmt|;
name|shp
operator|->
name|sh_size
operator|=
name|de
operator|.
name|de_nsym
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
expr_stmt|;
name|shp
operator|->
name|sh_addralign
operator|=
literal|8
expr_stmt|;
name|off
operator|=
name|P2ROUNDUP
argument_list|(
name|shp
operator|->
name|sh_offset
operator|+
name|shp
operator|->
name|sh_size
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|de
operator|.
name|de_nrel
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dt_write
argument_list|(
name|dtp
argument_list|,
name|fd
argument_list|,
operator|&
name|elf_file
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_file
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|elf_file
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_SHSTRTAB
argument_list|,
name|DTRACE_SHSTRTAB64
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_STRTAB
argument_list|,
name|de
operator|.
name|de_strtab
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_SYMTAB
argument_list|,
name|de
operator|.
name|de_sym
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_DOF
argument_list|,
name|dof
argument_list|)
condition|)
block|{
name|ret
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|shp
operator|=
operator|&
name|elf_file
operator|.
name|shdr
index|[
name|ESHDR_REL
index|]
expr_stmt|;
name|shp
operator|->
name|sh_name
operator|=
literal|37
expr_stmt|;
comment|/* DTRACE_SHSTRTAB64[37] = ".rel.SUNW_dof" */
name|shp
operator|->
name|sh_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|shp
operator|->
name|sh_type
operator|=
name|SHT_RELA
expr_stmt|;
name|shp
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|de
operator|.
name|de_rel
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|shp
operator|->
name|sh_link
operator|=
name|ESHDR_SYMTAB
expr_stmt|;
name|shp
operator|->
name|sh_info
operator|=
name|ESHDR_DOF
expr_stmt|;
name|shp
operator|->
name|sh_offset
operator|=
name|off
expr_stmt|;
name|shp
operator|->
name|sh_size
operator|=
name|de
operator|.
name|de_nrel
operator|*
sizeof|sizeof
argument_list|(
name|de
operator|.
name|de_rel
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|shp
operator|->
name|sh_addralign
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|dt_write
argument_list|(
name|dtp
argument_list|,
name|fd
argument_list|,
operator|&
name|elf_file
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_file
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|elf_file
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_SHSTRTAB
argument_list|,
name|DTRACE_SHSTRTAB64
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_STRTAB
argument_list|,
name|de
operator|.
name|de_strtab
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_SYMTAB
argument_list|,
name|de
operator|.
name|de_sym
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_REL
argument_list|,
name|de
operator|.
name|de_rel
argument_list|)
operator|||
name|PWRITE_SCN
argument_list|(
name|ESHDR_DOF
argument_list|,
name|dof
argument_list|)
condition|)
block|{
name|ret
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|de
operator|.
name|de_strtab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|de
operator|.
name|de_sym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|de
operator|.
name|de_rel
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_symtab_lookup
parameter_list|(
name|Elf_Data
modifier|*
name|data_sym
parameter_list|,
name|int
name|nsym
parameter_list|,
name|uintptr_t
name|addr
parameter_list|,
name|uint_t
name|shn
parameter_list|,
name|GElf_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|GElf_Sym
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsym
operator|&&
name|gelf_getsym
argument_list|(
name|data_sym
argument_list|,
name|i
argument_list|,
name|sym
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
operator|&&
name|shn
operator|==
name|sym
operator|->
name|st_shndx
operator|&&
name|sym
operator|->
name|st_value
operator|<=
name|addr
operator|&&
name|addr
operator|<
name|sym
operator|->
name|st_value
operator|+
name|sym
operator|->
name|st_size
condition|)
block|{
if|if
condition|(
name|GELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STB_GLOBAL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ret
operator|=
literal|0
expr_stmt|;
name|s
operator|=
operator|*
name|sym
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
operator|*
name|sym
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
end_if

begin_comment
comment|/* XXX */
end_comment

begin_function
specifier|static
name|int
name|dt_modtext
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|int
name|isenabled
parameter_list|,
name|GElf_Rela
modifier|*
name|rela
parameter_list|,
name|uint32_t
modifier|*
name|off
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s:%s(%d): DOODAD\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__ia64__
argument_list|)
end_elif

begin_comment
comment|/* XXX */
end_comment

begin_function
specifier|static
name|int
name|dt_modtext
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|int
name|isenabled
parameter_list|,
name|GElf_Rela
modifier|*
name|rela
parameter_list|,
name|uint32_t
modifier|*
name|off
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s:%s(%d): DOODAD\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__mips__
argument_list|)
end_elif

begin_comment
comment|/* XXX */
end_comment

begin_function
specifier|static
name|int
name|dt_modtext
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|int
name|isenabled
parameter_list|,
name|GElf_Rela
modifier|*
name|rela
parameter_list|,
name|uint32_t
modifier|*
name|off
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s:%s(%d): DOODAD\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__powerpc__
argument_list|)
end_elif

begin_comment
comment|/* The sentinel is 'xor r3,r3,r3'. */
end_comment

begin_define
define|#
directive|define
name|DT_OP_XOR_R3
value|0x7c631a78
end_define

begin_define
define|#
directive|define
name|DT_OP_NOP
value|0x60000000
end_define

begin_define
define|#
directive|define
name|DT_OP_BLR
value|0x4e800020
end_define

begin_comment
comment|/* This captures all forms of branching to address. */
end_comment

begin_define
define|#
directive|define
name|DT_IS_BRANCH
parameter_list|(
name|inst
parameter_list|)
value|((inst& 0xfc000000) == 0x48000000)
end_define

begin_define
define|#
directive|define
name|DT_IS_BL
parameter_list|(
name|inst
parameter_list|)
value|(DT_IS_BRANCH(inst)&& (inst& 0x01))
end_define

begin_comment
comment|/* XXX */
end_comment

begin_function
specifier|static
name|int
name|dt_modtext
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|int
name|isenabled
parameter_list|,
name|GElf_Rela
modifier|*
name|rela
parameter_list|,
name|uint32_t
modifier|*
name|off
parameter_list|)
block|{
name|uint32_t
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
operator|(
name|rela
operator|->
name|r_offset
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*LINTED*/
name|ip
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|p
operator|+
name|rela
operator|->
name|r_offset
operator|)
expr_stmt|;
comment|/* 	 * We only know about some specific relocation types. 	 */
if|if
condition|(
name|GELF_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
operator|!=
name|R_PPC_REL24
operator|&&
name|GELF_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
operator|!=
name|R_PPC_PLTREL24
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * We may have already processed this object file in an earlier linker 	 * invocation. Check to see if the present instruction sequence matches 	 * the one we would install below. 	 */
if|if
condition|(
name|isenabled
condition|)
block|{
if|if
condition|(
name|ip
index|[
literal|0
index|]
operator|==
name|DT_OP_XOR_R3
condition|)
block|{
operator|(
operator|*
name|off
operator|)
operator|+=
sizeof|sizeof
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ip
index|[
literal|0
index|]
operator|==
name|DT_OP_NOP
condition|)
block|{
operator|(
operator|*
name|off
operator|)
operator|+=
sizeof|sizeof
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * We only expect branch to address instructions. 	 */
if|if
condition|(
operator|!
name|DT_IS_BRANCH
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"found %x instead of a branch instruction at %llx\n"
argument_list|,
name|ip
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|rela
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|isenabled
condition|)
block|{
comment|/* 		 * It would necessarily indicate incorrect usage if an is- 		 * enabled probe were tail-called so flag that as an error. 		 * It's also potentially (very) tricky to handle gracefully, 		 * but could be done if this were a desired use scenario. 		 */
if|if
condition|(
operator|!
name|DT_IS_BL
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"tail call to is-enabled probe at %llx\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|rela
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ip
index|[
literal|0
index|]
operator|=
name|DT_OP_XOR_R3
expr_stmt|;
operator|(
operator|*
name|off
operator|)
operator|+=
sizeof|sizeof
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DT_IS_BL
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
condition|)
name|ip
index|[
literal|0
index|]
operator|=
name|DT_OP_NOP
expr_stmt|;
else|else
name|ip
index|[
literal|0
index|]
operator|=
name|DT_OP_BLR
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__sparc
argument_list|)
end_elif

begin_define
define|#
directive|define
name|DT_OP_RET
value|0x81c7e008
end_define

begin_define
define|#
directive|define
name|DT_OP_NOP
value|0x01000000
end_define

begin_define
define|#
directive|define
name|DT_OP_CALL
value|0x40000000
end_define

begin_define
define|#
directive|define
name|DT_OP_CLR_O0
value|0x90102000
end_define

begin_define
define|#
directive|define
name|DT_IS_MOV_O7
parameter_list|(
name|inst
parameter_list|)
value|(((inst)& 0xffffe000) == 0x9e100000)
end_define

begin_define
define|#
directive|define
name|DT_IS_RESTORE
parameter_list|(
name|inst
parameter_list|)
value|(((inst)& 0xc1f80000) == 0x81e80000)
end_define

begin_define
define|#
directive|define
name|DT_IS_RETL
parameter_list|(
name|inst
parameter_list|)
value|(((inst)& 0xfff83fff) == 0x81c02008)
end_define

begin_define
define|#
directive|define
name|DT_RS2
parameter_list|(
name|inst
parameter_list|)
value|((inst)& 0x1f)
end_define

begin_define
define|#
directive|define
name|DT_MAKE_RETL
parameter_list|(
name|reg
parameter_list|)
value|(0x81c02008 | ((reg)<< 14))
end_define

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_modtext
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|int
name|isenabled
parameter_list|,
name|GElf_Rela
modifier|*
name|rela
parameter_list|,
name|uint32_t
modifier|*
name|off
parameter_list|)
block|{
name|uint32_t
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
operator|(
name|rela
operator|->
name|r_offset
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*LINTED*/
name|ip
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|p
operator|+
name|rela
operator|->
name|r_offset
operator|)
expr_stmt|;
comment|/* 	 * We only know about some specific relocation types. 	 */
if|if
condition|(
name|GELF_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
operator|!=
name|R_SPARC_WDISP30
operator|&&
name|GELF_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
operator|!=
name|R_SPARC_WPLT30
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * We may have already processed this object file in an earlier linker 	 * invocation. Check to see if the present instruction sequence matches 	 * the one we would install below. 	 */
if|if
condition|(
name|isenabled
condition|)
block|{
if|if
condition|(
name|ip
index|[
literal|0
index|]
operator|==
name|DT_OP_NOP
condition|)
block|{
operator|(
operator|*
name|off
operator|)
operator|+=
sizeof|sizeof
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DT_IS_RESTORE
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|ip
index|[
literal|0
index|]
operator|==
name|DT_OP_RET
condition|)
block|{
operator|(
operator|*
name|off
operator|)
operator|+=
sizeof|sizeof
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|DT_IS_MOV_O7
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|DT_IS_RETL
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|ip
index|[
literal|0
index|]
operator|==
name|DT_OP_NOP
condition|)
block|{
operator|(
operator|*
name|off
operator|)
operator|+=
sizeof|sizeof
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * We only expect call instructions with a displacement of 0. 	 */
if|if
condition|(
name|ip
index|[
literal|0
index|]
operator|!=
name|DT_OP_CALL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"found %x instead of a call instruction at %llx\n"
argument_list|,
name|ip
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|rela
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|isenabled
condition|)
block|{
comment|/* 		 * It would necessarily indicate incorrect usage if an is- 		 * enabled probe were tail-called so flag that as an error. 		 * It's also potentially (very) tricky to handle gracefully, 		 * but could be done if this were a desired use scenario. 		 */
if|if
condition|(
name|DT_IS_RESTORE
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
operator|||
name|DT_IS_MOV_O7
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"tail call to is-enabled probe at %llx\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|rela
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * On SPARC, we take advantage of the fact that the first 		 * argument shares the same register as for the return value. 		 * The macro handles the work of zeroing that register so we 		 * don't need to do anything special here. We instrument the 		 * instruction in the delay slot as we'll need to modify the 		 * return register after that instruction has been emulated. 		 */
name|ip
index|[
literal|0
index|]
operator|=
name|DT_OP_NOP
expr_stmt|;
operator|(
operator|*
name|off
operator|)
operator|+=
sizeof|sizeof
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If the call is followed by a restore, it's a tail call so 		 * change the call to a ret. If the call if followed by a mov 		 * of a register into %o7, it's a tail call in leaf context 		 * so change the call to a retl-like instruction that returns 		 * to that register value + 8 (rather than the typical %o7 + 		 * 8); the delay slot instruction is left, but should have no 		 * effect. Otherwise we change the call to be a nop. We 		 * identify the subsequent instruction as the probe point in 		 * all but the leaf tail-call case to ensure that arguments to 		 * the probe are complete and consistent. An astute, though 		 * largely hypothetical, observer would note that there is the 		 * possibility of a false-positive probe firing if the function 		 * contained a branch to the instruction in the delay slot of 		 * the call. Fixing this would require significant in-kernel 		 * modifications, and isn't worth doing until we see it in the 		 * wild. 		 */
if|if
condition|(
name|DT_IS_RESTORE
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|ip
index|[
literal|0
index|]
operator|=
name|DT_OP_RET
expr_stmt|;
operator|(
operator|*
name|off
operator|)
operator|+=
sizeof|sizeof
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DT_IS_MOV_O7
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|ip
index|[
literal|0
index|]
operator|=
name|DT_MAKE_RETL
argument_list|(
name|DT_RS2
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip
index|[
literal|0
index|]
operator|=
name|DT_OP_NOP
expr_stmt|;
operator|(
operator|*
name|off
operator|)
operator|+=
sizeof|sizeof
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64
argument_list|)
end_elif

begin_define
define|#
directive|define
name|DT_OP_NOP
value|0x90
end_define

begin_define
define|#
directive|define
name|DT_OP_RET
value|0xc3
end_define

begin_define
define|#
directive|define
name|DT_OP_CALL
value|0xe8
end_define

begin_define
define|#
directive|define
name|DT_OP_JMP32
value|0xe9
end_define

begin_define
define|#
directive|define
name|DT_OP_REX_RAX
value|0x48
end_define

begin_define
define|#
directive|define
name|DT_OP_XOR_EAX_0
value|0x33
end_define

begin_define
define|#
directive|define
name|DT_OP_XOR_EAX_1
value|0xc0
end_define

begin_function
specifier|static
name|int
name|dt_modtext
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|int
name|isenabled
parameter_list|,
name|GElf_Rela
modifier|*
name|rela
parameter_list|,
name|uint32_t
modifier|*
name|off
parameter_list|)
block|{
name|uint8_t
modifier|*
name|ip
init|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|p
operator|+
name|rela
operator|->
name|r_offset
operator|-
literal|1
operator|)
decl_stmt|;
name|uint8_t
name|ret
decl_stmt|;
comment|/* 	 * On x86, the first byte of the instruction is the call opcode and 	 * the next four bytes are the 32-bit address; the relocation is for 	 * the address operand. We back up the offset to the first byte of 	 * the instruction. For is-enabled probes, we later advance the offset 	 * so that it hits the first nop in the instruction sequence. 	 */
operator|(
operator|*
name|off
operator|)
operator|-=
literal|1
expr_stmt|;
comment|/* 	 * We only know about some specific relocation types. Luckily 	 * these types have the same values on both 32-bit and 64-bit 	 * x86 architectures. 	 */
if|if
condition|(
name|GELF_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
operator|!=
name|R_386_PC32
operator|&&
name|GELF_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
operator|!=
name|R_386_PLT32
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * We may have already processed this object file in an earlier linker 	 * invocation. Check to see if the present instruction sequence matches 	 * the one we would install. For is-enabled probes, we advance the 	 * offset to the first nop instruction in the sequence to match the 	 * text modification code below. 	 */
if|if
condition|(
operator|!
name|isenabled
condition|)
block|{
if|if
condition|(
operator|(
name|ip
index|[
literal|0
index|]
operator|==
name|DT_OP_NOP
operator|||
name|ip
index|[
literal|0
index|]
operator|==
name|DT_OP_RET
operator|)
operator|&&
name|ip
index|[
literal|1
index|]
operator|==
name|DT_OP_NOP
operator|&&
name|ip
index|[
literal|2
index|]
operator|==
name|DT_OP_NOP
operator|&&
name|ip
index|[
literal|3
index|]
operator|==
name|DT_OP_NOP
operator|&&
name|ip
index|[
literal|4
index|]
operator|==
name|DT_OP_NOP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|dtp
operator|->
name|dt_oflags
operator|&
name|DTRACE_O_LP64
condition|)
block|{
if|if
condition|(
name|ip
index|[
literal|0
index|]
operator|==
name|DT_OP_REX_RAX
operator|&&
name|ip
index|[
literal|1
index|]
operator|==
name|DT_OP_XOR_EAX_0
operator|&&
name|ip
index|[
literal|2
index|]
operator|==
name|DT_OP_XOR_EAX_1
operator|&&
operator|(
name|ip
index|[
literal|3
index|]
operator|==
name|DT_OP_NOP
operator|||
name|ip
index|[
literal|3
index|]
operator|==
name|DT_OP_RET
operator|)
operator|&&
name|ip
index|[
literal|4
index|]
operator|==
name|DT_OP_NOP
condition|)
block|{
operator|(
operator|*
name|off
operator|)
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ip
index|[
literal|0
index|]
operator|==
name|DT_OP_XOR_EAX_0
operator|&&
name|ip
index|[
literal|1
index|]
operator|==
name|DT_OP_XOR_EAX_1
operator|&&
operator|(
name|ip
index|[
literal|2
index|]
operator|==
name|DT_OP_NOP
operator|||
name|ip
index|[
literal|2
index|]
operator|==
name|DT_OP_RET
operator|)
operator|&&
name|ip
index|[
literal|3
index|]
operator|==
name|DT_OP_NOP
operator|&&
name|ip
index|[
literal|4
index|]
operator|==
name|DT_OP_NOP
condition|)
block|{
operator|(
operator|*
name|off
operator|)
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * We expect either a call instrution with a 32-bit displacement or a 	 * jmp instruction with a 32-bit displacement acting as a tail-call. 	 */
if|if
condition|(
name|ip
index|[
literal|0
index|]
operator|!=
name|DT_OP_CALL
operator|&&
name|ip
index|[
literal|0
index|]
operator|!=
name|DT_OP_JMP32
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"found %x instead of a call or jmp instruction at "
literal|"%llx\n"
argument_list|,
name|ip
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|rela
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
operator|(
name|ip
index|[
literal|0
index|]
operator|==
name|DT_OP_JMP32
operator|)
condition|?
name|DT_OP_RET
else|:
name|DT_OP_NOP
expr_stmt|;
comment|/* 	 * Establish the instruction sequence -- all nops for probes, and an 	 * instruction to clear the return value register (%eax/%rax) followed 	 * by nops for is-enabled probes. For is-enabled probes, we advance 	 * the offset to the first nop. This isn't stricly necessary but makes 	 * for more readable disassembly when the probe is enabled. 	 */
if|if
condition|(
operator|!
name|isenabled
condition|)
block|{
name|ip
index|[
literal|0
index|]
operator|=
name|ret
expr_stmt|;
name|ip
index|[
literal|1
index|]
operator|=
name|DT_OP_NOP
expr_stmt|;
name|ip
index|[
literal|2
index|]
operator|=
name|DT_OP_NOP
expr_stmt|;
name|ip
index|[
literal|3
index|]
operator|=
name|DT_OP_NOP
expr_stmt|;
name|ip
index|[
literal|4
index|]
operator|=
name|DT_OP_NOP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dtp
operator|->
name|dt_oflags
operator|&
name|DTRACE_O_LP64
condition|)
block|{
name|ip
index|[
literal|0
index|]
operator|=
name|DT_OP_REX_RAX
expr_stmt|;
name|ip
index|[
literal|1
index|]
operator|=
name|DT_OP_XOR_EAX_0
expr_stmt|;
name|ip
index|[
literal|2
index|]
operator|=
name|DT_OP_XOR_EAX_1
expr_stmt|;
name|ip
index|[
literal|3
index|]
operator|=
name|ret
expr_stmt|;
name|ip
index|[
literal|4
index|]
operator|=
name|DT_OP_NOP
expr_stmt|;
operator|(
operator|*
name|off
operator|)
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|ip
index|[
literal|0
index|]
operator|=
name|DT_OP_XOR_EAX_0
expr_stmt|;
name|ip
index|[
literal|1
index|]
operator|=
name|DT_OP_XOR_EAX_1
expr_stmt|;
name|ip
index|[
literal|2
index|]
operator|=
name|ret
expr_stmt|;
name|ip
index|[
literal|3
index|]
operator|=
name|DT_OP_NOP
expr_stmt|;
name|ip
index|[
literal|4
index|]
operator|=
name|DT_OP_NOP
expr_stmt|;
operator|(
operator|*
name|off
operator|)
operator|+=
literal|2
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|unknown ISA
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*PRINTFLIKE5*/
end_comment

begin_function
specifier|static
name|int
name|dt_link_error
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|Elf
modifier|*
name|elf
parameter_list|,
name|int
name|fd
parameter_list|,
name|dt_link_pair_t
modifier|*
name|bufs
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|dt_link_pair_t
modifier|*
name|pair
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|dt_set_errmsg
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|elf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pair
operator|=
name|bufs
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bufs
operator|=
name|pair
operator|->
name|dlp_next
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pair
operator|->
name|dlp_str
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pair
operator|->
name|dlp_sym
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pair
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_COMPILER
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_obj
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|obj
parameter_list|,
name|int
modifier|*
name|eprobesp
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|dt_prefix
index|[]
init|=
literal|"__dtrace"
decl_stmt|;
specifier|static
specifier|const
name|char
name|dt_enabled
index|[]
init|=
literal|"enabled"
decl_stmt|;
specifier|static
specifier|const
name|char
name|dt_symprefix
index|[]
init|=
literal|"$dtrace"
decl_stmt|;
specifier|static
specifier|const
name|char
name|dt_symfmt
index|[]
init|=
literal|"%s%ld.%s"
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|ndx
decl_stmt|,
name|eprobe
decl_stmt|,
name|mod
init|=
literal|0
decl_stmt|;
name|Elf
modifier|*
name|elf
init|=
name|NULL
decl_stmt|;
name|GElf_Ehdr
name|ehdr
decl_stmt|;
name|Elf_Scn
modifier|*
name|scn_rel
decl_stmt|,
modifier|*
name|scn_sym
decl_stmt|,
modifier|*
name|scn_str
decl_stmt|,
modifier|*
name|scn_tgt
decl_stmt|;
name|Elf_Data
modifier|*
name|data_rel
decl_stmt|,
modifier|*
name|data_sym
decl_stmt|,
modifier|*
name|data_str
decl_stmt|,
modifier|*
name|data_tgt
decl_stmt|;
name|GElf_Shdr
name|shdr_rel
decl_stmt|,
name|shdr_sym
decl_stmt|,
name|shdr_str
decl_stmt|,
name|shdr_tgt
decl_stmt|;
name|GElf_Sym
name|rsym
decl_stmt|,
name|fsym
decl_stmt|,
name|dsym
decl_stmt|;
name|GElf_Rela
name|rela
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|char
name|pname
index|[
name|DTRACE_PROVNAMELEN
index|]
decl_stmt|;
name|dt_provider_t
modifier|*
name|pvp
decl_stmt|;
name|dt_probe_t
modifier|*
name|prp
decl_stmt|;
name|uint32_t
name|off
decl_stmt|,
name|eclass
decl_stmt|,
name|emachine1
decl_stmt|,
name|emachine2
decl_stmt|;
name|size_t
name|symsize
decl_stmt|,
name|nsym
decl_stmt|,
name|isym
decl_stmt|,
name|istr
decl_stmt|,
name|len
decl_stmt|;
name|key_t
name|objkey
decl_stmt|;
name|dt_link_pair_t
modifier|*
name|pair
decl_stmt|,
modifier|*
name|bufs
init|=
name|NULL
decl_stmt|;
name|dt_strtab_t
modifier|*
name|strtab
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open64
argument_list|(
name|obj
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|elf
argument_list|,
name|fd
argument_list|,
name|bufs
argument_list|,
literal|"failed to open %s: %s"
argument_list|,
name|obj
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|elf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|ELF_C_RDWR
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|elf
argument_list|,
name|fd
argument_list|,
name|bufs
argument_list|,
literal|"failed to process %s: %s"
argument_list|,
name|obj
argument_list|,
name|elf_errmsg
argument_list|(
name|elf_errno
argument_list|()
argument_list|)
argument_list|)
operator|)
return|;
block|}
switch|switch
condition|(
name|elf_kind
argument_list|(
name|elf
argument_list|)
condition|)
block|{
case|case
name|ELF_K_ELF
case|:
break|break;
case|case
name|ELF_K_AR
case|:
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|elf
argument_list|,
name|fd
argument_list|,
name|bufs
argument_list|,
literal|"archives are not "
literal|"permitted; use the contents of the archive instead: %s"
argument_list|,
name|obj
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|elf
argument_list|,
name|fd
argument_list|,
name|bufs
argument_list|,
literal|"invalid file type: %s"
argument_list|,
name|obj
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|gelf_getehdr
argument_list|(
name|elf
argument_list|,
operator|&
name|ehdr
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|elf
argument_list|,
name|fd
argument_list|,
name|bufs
argument_list|,
literal|"corrupt file: %s"
argument_list|,
name|obj
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|dtp
operator|->
name|dt_oflags
operator|&
name|DTRACE_O_LP64
condition|)
block|{
name|eclass
operator|=
name|ELFCLASS64
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__ia64__
argument_list|)
name|emachine1
operator|=
name|emachine2
operator|=
name|EM_IA_64
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__mips__
argument_list|)
name|emachine1
operator|=
name|emachine2
operator|=
name|EM_MIPS
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__powerpc__
argument_list|)
name|emachine1
operator|=
name|emachine2
operator|=
name|EM_PPC64
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__sparc
argument_list|)
name|emachine1
operator|=
name|emachine2
operator|=
name|EM_SPARCV9
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64
argument_list|)
name|emachine1
operator|=
name|emachine2
operator|=
name|EM_AMD64
expr_stmt|;
endif|#
directive|endif
name|symsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eclass
operator|=
name|ELFCLASS32
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
name|emachine1
operator|=
name|emachine2
operator|=
name|EM_ARM
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__mips__
argument_list|)
name|emachine1
operator|=
name|emachine2
operator|=
name|EM_MIPS
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__powerpc__
argument_list|)
name|emachine1
operator|=
name|emachine2
operator|=
name|EM_PPC
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__sparc
argument_list|)
name|emachine1
operator|=
name|EM_SPARC
expr_stmt|;
name|emachine2
operator|=
name|EM_SPARC32PLUS
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64
argument_list|)
operator|||
name|defined
argument_list|(
name|__ia64__
argument_list|)
name|emachine1
operator|=
name|emachine2
operator|=
name|EM_386
expr_stmt|;
endif|#
directive|endif
name|symsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|eclass
condition|)
block|{
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|elf
argument_list|,
name|fd
argument_list|,
name|bufs
argument_list|,
literal|"incorrect ELF class for object file: %s"
argument_list|,
name|obj
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ehdr
operator|.
name|e_machine
operator|!=
name|emachine1
operator|&&
name|ehdr
operator|.
name|e_machine
operator|!=
name|emachine2
condition|)
block|{
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|elf
argument_list|,
name|fd
argument_list|,
name|bufs
argument_list|,
literal|"incorrect ELF machine type for object file: %s"
argument_list|,
name|obj
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * We use this token as a relatively unique handle for this file on the 	 * system in order to disambiguate potential conflicts between files of 	 * the same name which contain identially named local symbols. 	 */
if|if
condition|(
operator|(
name|objkey
operator|=
name|ftok
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|(
name|key_t
operator|)
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|elf
argument_list|,
name|fd
argument_list|,
name|bufs
argument_list|,
literal|"failed to generate unique key for object file: %s"
argument_list|,
name|obj
argument_list|)
operator|)
return|;
block|}
name|scn_rel
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|scn_rel
operator|=
name|elf_nextscn
argument_list|(
name|elf
argument_list|,
name|scn_rel
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|scn_rel
argument_list|,
operator|&
name|shdr_rel
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * Skip any non-relocation sections. 		 */
if|if
condition|(
name|shdr_rel
operator|.
name|sh_type
operator|!=
name|SHT_RELA
operator|&&
name|shdr_rel
operator|.
name|sh_type
operator|!=
name|SHT_REL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|data_rel
operator|=
name|elf_getdata
argument_list|(
name|scn_rel
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * Grab the section, section header and section data for the 		 * symbol table that this relocation section references. 		 */
if|if
condition|(
operator|(
name|scn_sym
operator|=
name|elf_getscn
argument_list|(
name|elf
argument_list|,
name|shdr_rel
operator|.
name|sh_link
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|gelf_getshdr
argument_list|(
name|scn_sym
argument_list|,
operator|&
name|shdr_sym
argument_list|)
operator|==
name|NULL
operator|||
operator|(
name|data_sym
operator|=
name|elf_getdata
argument_list|(
name|scn_sym
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * Ditto for that symbol table's string table. 		 */
if|if
condition|(
operator|(
name|scn_str
operator|=
name|elf_getscn
argument_list|(
name|elf
argument_list|,
name|shdr_sym
operator|.
name|sh_link
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|gelf_getshdr
argument_list|(
name|scn_str
argument_list|,
operator|&
name|shdr_str
argument_list|)
operator|==
name|NULL
operator|||
operator|(
name|data_str
operator|=
name|elf_getdata
argument_list|(
name|scn_str
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * Grab the section, section header and section data for the 		 * target section for the relocations. For the relocations 		 * we're looking for -- this will typically be the text of the 		 * object file. 		 */
if|if
condition|(
operator|(
name|scn_tgt
operator|=
name|elf_getscn
argument_list|(
name|elf
argument_list|,
name|shdr_rel
operator|.
name|sh_info
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|gelf_getshdr
argument_list|(
name|scn_tgt
argument_list|,
operator|&
name|shdr_tgt
argument_list|)
operator|==
name|NULL
operator|||
operator|(
name|data_tgt
operator|=
name|elf_getdata
argument_list|(
name|scn_tgt
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * We're looking for relocations to symbols matching this form: 		 * 		 *   __dtrace[enabled]_<prov>___<probe> 		 * 		 * For the generated object, we need to record the location 		 * identified by the relocation, and create a new relocation 		 * in the generated object that will be resolved at link time 		 * to the location of the function in which the probe is 		 * embedded. In the target object, we change the matched symbol 		 * so that it will be ignored at link time, and we modify the 		 * target (text) section to replace the call instruction with 		 * one or more nops. 		 * 		 * If the function containing the probe is locally scoped 		 * (static), we create an alias used by the relocation in the 		 * generated object. The alias, a new symbol, will be global 		 * (so that the relocation from the generated object can be 		 * resolved), and hidden (so that it is converted to a local 		 * symbol at link time). Such aliases have this form: 		 * 		 *   $dtrace<key>.<function> 		 * 		 * We take a first pass through all the relocations to 		 * populate our string table and count the number of extra 		 * symbols we'll require. 		 */
name|strtab
operator|=
name|dt_strtab_create
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nsym
operator|=
literal|0
expr_stmt|;
name|isym
operator|=
name|data_sym
operator|->
name|d_size
operator|/
name|symsize
expr_stmt|;
name|istr
operator|=
name|data_str
operator|->
name|d_size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shdr_rel
operator|.
name|sh_size
operator|/
name|shdr_rel
operator|.
name|sh_entsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|shdr_rel
operator|.
name|sh_type
operator|==
name|SHT_RELA
condition|)
block|{
if|if
condition|(
name|gelf_getrela
argument_list|(
name|data_rel
argument_list|,
name|i
argument_list|,
operator|&
name|rela
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
block|}
else|else
block|{
name|GElf_Rel
name|rel
decl_stmt|;
if|if
condition|(
name|gelf_getrel
argument_list|(
name|data_rel
argument_list|,
name|i
argument_list|,
operator|&
name|rel
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|rela
operator|.
name|r_offset
operator|=
name|rel
operator|.
name|r_offset
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|rel
operator|.
name|r_info
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|gelf_getsym
argument_list|(
name|data_sym
argument_list|,
name|GELF_R_SYM
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
argument_list|,
operator|&
name|rsym
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|dt_strtab_destroy
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|data_str
operator|->
name|d_buf
operator|+
name|rsym
operator|.
name|st_name
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|dt_prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_prefix
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dt_symtab_lookup
argument_list|(
name|data_sym
argument_list|,
name|isym
argument_list|,
name|rela
operator|.
name|r_offset
argument_list|,
name|shdr_rel
operator|.
name|sh_info
argument_list|,
operator|&
name|fsym
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dt_strtab_destroy
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|GELF_ST_BIND
argument_list|(
name|fsym
operator|.
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
condition|)
continue|continue;
if|if
condition|(
name|fsym
operator|.
name|st_name
operator|>
name|data_str
operator|->
name|d_size
condition|)
block|{
name|dt_strtab_destroy
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|data_str
operator|->
name|d_buf
operator|+
name|fsym
operator|.
name|st_name
expr_stmt|;
comment|/* 			 * If this symbol isn't of type function, we've really 			 * driven off the rails or the object file is corrupt. 			 */
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|fsym
operator|.
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
condition|)
block|{
name|dt_strtab_destroy
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|elf
argument_list|,
name|fd
argument_list|,
name|bufs
argument_list|,
literal|"expected %s to be of type function"
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
name|len
operator|=
name|snprintf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|dt_symfmt
argument_list|,
name|dt_symprefix
argument_list|,
name|objkey
argument_list|,
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_strtab_destroy
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|dt_symfmt
argument_list|,
name|dt_symprefix
argument_list|,
name|objkey
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_strtab_index
argument_list|(
name|strtab
argument_list|,
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|nsym
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|dt_strtab_insert
argument_list|(
name|strtab
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If needed, allocate the additional space for the symbol 		 * table and string table copying the old data into the new 		 * buffers, and marking the buffers as dirty. We inject those 		 * newly allocated buffers into the libelf data structures, but 		 * are still responsible for freeing them once we're done with 		 * the elf handle. 		 */
if|if
condition|(
name|nsym
operator|>
literal|0
condition|)
block|{
comment|/* 			 * The first byte of the string table is reserved for 			 * the \0 entry. 			 */
name|len
operator|=
name|dt_strtab_size
argument_list|(
name|strtab
argument_list|)
operator|-
literal|1
expr_stmt|;
name|assert
argument_list|(
name|len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dt_strtab_index
argument_list|(
name|strtab
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dt_strtab_destroy
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pair
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pair
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|(
name|pair
operator|->
name|dlp_str
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|data_str
operator|->
name|d_size
operator|+
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pair
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|pair
operator|->
name|dlp_sym
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|data_sym
operator|->
name|d_size
operator|+
name|nsym
operator|*
name|symsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pair
operator|->
name|dlp_str
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pair
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|pair
operator|->
name|dlp_next
operator|=
name|bufs
expr_stmt|;
name|bufs
operator|=
name|pair
expr_stmt|;
name|bcopy
argument_list|(
name|data_str
operator|->
name|d_buf
argument_list|,
name|pair
operator|->
name|dlp_str
argument_list|,
name|data_str
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|data_str
operator|->
name|d_buf
operator|=
name|pair
operator|->
name|dlp_str
expr_stmt|;
name|data_str
operator|->
name|d_size
operator|+=
name|len
expr_stmt|;
operator|(
name|void
operator|)
name|elf_flagdata
argument_list|(
name|data_str
argument_list|,
name|ELF_C_SET
argument_list|,
name|ELF_F_DIRTY
argument_list|)
expr_stmt|;
name|shdr_str
operator|.
name|sh_size
operator|+=
name|len
expr_stmt|;
operator|(
name|void
operator|)
name|gelf_update_shdr
argument_list|(
name|scn_str
argument_list|,
operator|&
name|shdr_str
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data_sym
operator|->
name|d_buf
argument_list|,
name|pair
operator|->
name|dlp_sym
argument_list|,
name|data_sym
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|data_sym
operator|->
name|d_buf
operator|=
name|pair
operator|->
name|dlp_sym
expr_stmt|;
name|data_sym
operator|->
name|d_size
operator|+=
name|nsym
operator|*
name|symsize
expr_stmt|;
operator|(
name|void
operator|)
name|elf_flagdata
argument_list|(
name|data_sym
argument_list|,
name|ELF_C_SET
argument_list|,
name|ELF_F_DIRTY
argument_list|)
expr_stmt|;
name|shdr_sym
operator|.
name|sh_size
operator|+=
name|nsym
operator|*
name|symsize
expr_stmt|;
operator|(
name|void
operator|)
name|gelf_update_shdr
argument_list|(
name|scn_sym
argument_list|,
operator|&
name|shdr_sym
argument_list|)
expr_stmt|;
name|nsym
operator|+=
name|isym
expr_stmt|;
block|}
else|else
block|{
name|dt_strtab_destroy
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now that the tables have been allocated, perform the 		 * modifications described above. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shdr_rel
operator|.
name|sh_size
operator|/
name|shdr_rel
operator|.
name|sh_entsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|shdr_rel
operator|.
name|sh_type
operator|==
name|SHT_RELA
condition|)
block|{
if|if
condition|(
name|gelf_getrela
argument_list|(
name|data_rel
argument_list|,
name|i
argument_list|,
operator|&
name|rela
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
block|}
else|else
block|{
name|GElf_Rel
name|rel
decl_stmt|;
if|if
condition|(
name|gelf_getrel
argument_list|(
name|data_rel
argument_list|,
name|i
argument_list|,
operator|&
name|rel
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|rela
operator|.
name|r_offset
operator|=
name|rel
operator|.
name|r_offset
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|rel
operator|.
name|r_info
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|ndx
operator|=
name|GELF_R_SYM
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|gelf_getsym
argument_list|(
name|data_sym
argument_list|,
name|ndx
argument_list|,
operator|&
name|rsym
argument_list|)
operator|==
name|NULL
operator|||
name|rsym
operator|.
name|st_name
operator|>
name|data_str
operator|->
name|d_size
condition|)
goto|goto
name|err
goto|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|data_str
operator|->
name|d_buf
operator|+
name|rsym
operator|.
name|st_name
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|dt_prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_prefix
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|dt_prefix
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 			 * Check to see if this is an 'is-enabled' check as 			 * opposed to a normal probe. 			 */
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|dt_enabled
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_enabled
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|dt_enabled
argument_list|)
operator|-
literal|1
expr_stmt|;
name|eprobe
operator|=
literal|1
expr_stmt|;
operator|*
name|eprobesp
operator|=
literal|1
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"is-enabled probe\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eprobe
operator|=
literal|0
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"normal probe\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'_'
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|(
name|p
operator|=
name|strstr
argument_list|(
name|s
argument_list|,
literal|"___"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|p
operator|-
name|s
operator|>=
sizeof|sizeof
argument_list|(
name|pname
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|bcopy
argument_list|(
name|s
argument_list|,
name|pname
argument_list|,
name|p
operator|-
name|s
argument_list|)
expr_stmt|;
name|pname
index|[
name|p
operator|-
name|s
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|strhyphenate
argument_list|(
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* strlen("___") */
if|if
condition|(
name|dt_symtab_lookup
argument_list|(
name|data_sym
argument_list|,
name|isym
argument_list|,
name|rela
operator|.
name|r_offset
argument_list|,
name|shdr_rel
operator|.
name|sh_info
argument_list|,
operator|&
name|fsym
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|fsym
operator|.
name|st_name
operator|>
name|data_str
operator|->
name|d_size
condition|)
goto|goto
name|err
goto|;
name|assert
argument_list|(
name|GELF_ST_TYPE
argument_list|(
name|fsym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_FUNC
argument_list|)
expr_stmt|;
comment|/* 			 * If a NULL relocation name is passed to 			 * dt_probe_define(), the function name is used for the 			 * relocation. The relocation needs to use a mangled 			 * name if the symbol is locally scoped; the function 			 * name may need to change if we've found the global 			 * alias for the locally scoped symbol (we prefer 			 * global symbols to locals in dt_symtab_lookup()). 			 */
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|data_str
operator|->
name|d_buf
operator|+
name|fsym
operator|.
name|st_name
expr_stmt|;
name|r
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|GELF_ST_BIND
argument_list|(
name|fsym
operator|.
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
condition|)
block|{
name|dsym
operator|=
name|fsym
expr_stmt|;
name|dsym
operator|.
name|st_name
operator|=
name|istr
expr_stmt|;
name|dsym
operator|.
name|st_info
operator|=
name|GELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
name|dsym
operator|.
name|st_other
operator|=
name|ELF64_ST_VISIBILITY
argument_list|(
name|STV_ELIMINATE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gelf_update_sym
argument_list|(
name|data_sym
argument_list|,
name|isym
argument_list|,
operator|&
name|dsym
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|char
operator|*
operator|)
name|data_str
operator|->
name|d_buf
operator|+
name|istr
expr_stmt|;
name|istr
operator|+=
literal|1
operator|+
name|sprintf
argument_list|(
name|r
argument_list|,
name|dt_symfmt
argument_list|,
name|dt_symprefix
argument_list|,
name|objkey
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|isym
operator|++
expr_stmt|;
name|assert
argument_list|(
name|isym
operator|<=
name|nsym
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|dt_symprefix
argument_list|,
name|strlen
argument_list|(
name|dt_symprefix
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pvp
operator|=
name|dt_provider_lookup
argument_list|(
name|dtp
argument_list|,
name|pname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|elf
argument_list|,
name|fd
argument_list|,
name|bufs
argument_list|,
literal|"no such provider %s"
argument_list|,
name|pname
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|prp
operator|=
name|dt_probe_lookup
argument_list|(
name|pvp
argument_list|,
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|elf
argument_list|,
name|fd
argument_list|,
name|bufs
argument_list|,
literal|"no such probe %s"
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
name|assert
argument_list|(
name|fsym
operator|.
name|st_value
operator|<=
name|rela
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|off
operator|=
name|rela
operator|.
name|r_offset
operator|-
name|fsym
operator|.
name|st_value
expr_stmt|;
if|if
condition|(
name|dt_modtext
argument_list|(
name|dtp
argument_list|,
name|data_tgt
operator|->
name|d_buf
argument_list|,
name|eprobe
argument_list|,
operator|&
name|rela
argument_list|,
operator|&
name|off
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|dt_probe_define
argument_list|(
name|pvp
argument_list|,
name|prp
argument_list|,
name|s
argument_list|,
name|r
argument_list|,
name|off
argument_list|,
name|eprobe
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|elf
argument_list|,
name|fd
argument_list|,
name|bufs
argument_list|,
literal|"failed to allocate space for probe"
argument_list|)
operator|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
comment|/* 			 * Our linker doesn't understand the SUNW_IGNORE ndx and 			 * will try to use this relocation when we build the 			 * final executable. Since we are done processing this 			 * relocation, mark it as inexistant and let libelf 			 * remove it from the file. 			 * If this wasn't done, we would have garbage added to 			 * the executable file as the symbol is going to be 			 * change from UND to ABS. 			 */
if|if
condition|(
name|shdr_rel
operator|.
name|sh_type
operator|==
name|SHT_RELA
condition|)
block|{
name|rela
operator|.
name|r_offset
operator|=
literal|0
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
literal|0
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|gelf_update_rela
argument_list|(
name|data_rel
argument_list|,
name|i
argument_list|,
operator|&
name|rela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GElf_Rel
name|rel
decl_stmt|;
name|rel
operator|.
name|r_offset
operator|=
literal|0
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|gelf_update_rel
argument_list|(
name|data_rel
argument_list|,
name|i
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mod
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|elf_flagdata
argument_list|(
name|data_tgt
argument_list|,
name|ELF_C_SET
argument_list|,
name|ELF_F_DIRTY
argument_list|)
expr_stmt|;
comment|/* 			 * This symbol may already have been marked to 			 * be ignored by another relocation referencing 			 * the same symbol or if this object file has 			 * already been processed by an earlier link 			 * invocation. 			 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
define|#
directive|define
name|SHN_SUNW_IGNORE
value|SHN_ABS
endif|#
directive|endif
if|if
condition|(
name|rsym
operator|.
name|st_shndx
operator|!=
name|SHN_SUNW_IGNORE
condition|)
block|{
name|rsym
operator|.
name|st_shndx
operator|=
name|SHN_SUNW_IGNORE
expr_stmt|;
operator|(
name|void
operator|)
name|gelf_update_sym
argument_list|(
name|data_sym
argument_list|,
name|ndx
argument_list|,
operator|&
name|rsym
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mod
operator|&&
name|elf_update
argument_list|(
name|elf
argument_list|,
name|ELF_C_WRITE
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|elf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|nsym
operator|>
literal|0
condition|)
endif|#
directive|endif
while|while
condition|(
operator|(
name|pair
operator|=
name|bufs
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bufs
operator|=
name|pair
operator|->
name|dlp_next
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pair
operator|->
name|dlp_str
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pair
operator|->
name|dlp_sym
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|pair
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|elf
argument_list|,
name|fd
argument_list|,
name|bufs
argument_list|,
literal|"an error was encountered while processing %s"
argument_list|,
name|obj
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_program_link
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_prog_t
modifier|*
name|pgp
parameter_list|,
name|uint_t
name|dflags
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|objc
parameter_list|,
name|char
modifier|*
specifier|const
name|objv
index|[]
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|char
name|tfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|Elf
modifier|*
name|e
decl_stmt|;
name|Elf_Scn
modifier|*
name|scn
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|GElf_Shdr
name|shdr
decl_stmt|;
name|int
name|efd
decl_stmt|;
name|size_t
name|stridx
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|loc
decl_stmt|;
name|GElf_Ehdr
name|ehdr
decl_stmt|;
name|Elf_Scn
modifier|*
name|scn0
decl_stmt|;
name|GElf_Shdr
name|shdr0
decl_stmt|;
name|uint64_t
name|off
decl_stmt|,
name|rc
decl_stmt|;
endif|#
directive|endif
name|char
name|drti
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|dof_hdr_t
modifier|*
name|dof
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|status
decl_stmt|,
name|i
decl_stmt|,
name|cur
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|,
name|tmp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|eprobes
init|=
literal|0
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dtrace: target object (%s) already exists. "
literal|"Please remove the target\ndtrace: object and rebuild all "
literal|"the source objects if you wish to run the DTrace\n"
literal|"dtrace: linking process again\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 		 * Several build infrastructures run DTrace twice (e.g. 		 * postgres) and we don't want the build to fail. Return 		 * 0 here since this isn't really a fatal error. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* XXX Should get a temp file name here. */
name|snprintf
argument_list|(
name|tfile
argument_list|,
sizeof|sizeof
argument_list|(
name|tfile
argument_list|)
argument_list|,
literal|"%s.tmp"
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * A NULL program indicates a special use in which we just link 	 * together a bunch of object files specified in objv and then 	 * unlink(2) those object files. 	 */
if|if
condition|(
name|pgp
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
literal|"%s -o %s -r"
decl_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
operator|&
name|tmp
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|,
name|dtp
operator|->
name|dt_ld_path
argument_list|,
name|file
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
name|len
operator|+=
name|strlen
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cmd
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|cur
operator|=
name|snprintf
argument_list|(
name|cmd
argument_list|,
name|len
argument_list|,
name|fmt
argument_list|,
name|dtp
operator|->
name|dt_ld_path
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
name|cur
operator|+=
name|snprintf
argument_list|(
name|cmd
operator|+
name|cur
argument_list|,
name|len
operator|-
name|cur
argument_list|,
literal|" %s"
argument_list|,
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|system
argument_list|(
name|cmd
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"failed to run %s: %s"
argument_list|,
name|dtp
operator|->
name|dt_ld_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"failed to link %s: %s failed due to signal %d"
argument_list|,
name|file
argument_list|,
name|dtp
operator|->
name|dt_ld_path
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"failed to link %s: %s exited with status %d\n"
argument_list|,
name|file
argument_list|,
name|dtp
operator|->
name|dt_ld_path
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|,
name|file
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|process_obj
argument_list|(
name|dtp
argument_list|,
name|objv
index|[
name|i
index|]
argument_list|,
operator|&
name|eprobes
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
block|}
comment|/* 	 * If there are is-enabled probes then we need to force use of DOF 	 * version 2. 	 */
if|if
condition|(
name|eprobes
operator|&&
name|pgp
operator|->
name|dp_dofversion
operator|<
name|DOF_VERSION_2
condition|)
name|pgp
operator|->
name|dp_dofversion
operator|=
name|DOF_VERSION_2
expr_stmt|;
if|if
condition|(
operator|(
name|dof
operator|=
name|dtrace_dof_create
argument_list|(
name|dtp
argument_list|,
name|pgp
argument_list|,
name|dflags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
comment|/* 	 * Create a temporary file and then unlink it if we're going to 	 * combine it with drti.o later.  We can still refer to it in child 	 * processes as /dev/fd/<fd>. 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open64
argument_list|(
name|file
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"failed to open %s: %s"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|tfile
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"failed to open %s: %s"
argument_list|,
name|tfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * If -xlinktype=DOF has been selected, just write out the DOF. 	 * Otherwise proceed to the default of generating and linking ELF. 	 */
switch|switch
condition|(
name|dtp
operator|->
name|dt_linktype
condition|)
block|{
case|case
name|DT_LTYP_DOF
case|:
if|if
condition|(
name|dt_write
argument_list|(
name|dtp
argument_list|,
name|fd
argument_list|,
name|dof
argument_list|,
name|dof
operator|->
name|dofh_filesz
argument_list|)
operator|<
name|dof
operator|->
name|dofh_filesz
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|!=
literal|0
operator|&&
name|ret
operator|==
literal|0
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"failed to write %s: %s"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|ret
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|DT_LTYP_ELF
case|:
break|break;
comment|/* fall through to the rest of dtrace_program_link() */
default|default:
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"invalid link type %u\n"
argument_list|,
name|dtp
operator|->
name|dt_linktype
argument_list|)
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
operator|!
name|dtp
operator|->
name|dt_lazyload
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|dtp
operator|->
name|dt_oflags
operator|&
name|DTRACE_O_LP64
condition|)
name|status
operator|=
name|dump_elf64
argument_list|(
name|dtp
argument_list|,
name|dof
argument_list|,
name|fd
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|dump_elf32
argument_list|(
name|dtp
argument_list|,
name|dof
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|||
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
else|#
directive|else
comment|/* We don't write the ELF header, just the DOF section */
if|if
condition|(
name|dt_write
argument_list|(
name|dtp
argument_list|,
name|fd
argument_list|,
name|dof
argument_list|,
name|dof
operator|->
name|dofh_filesz
argument_list|)
operator|<
name|dof
operator|->
name|dofh_filesz
condition|)
block|{
endif|#
directive|endif
return|return
operator|(
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"failed to write %s: %s"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|dtp
operator|->
name|dt_lazyload
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
specifier|const
name|char
modifier|*
name|fmt
init|=
literal|"%s -o %s -r -Blocal -Breduce /dev/fd/%d %s"
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_oflags
operator|&
name|DTRACE_O_LP64
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|drti
argument_list|,
sizeof|sizeof
argument_list|(
name|drti
argument_list|)
argument_list|,
literal|"%s/64/drti.o"
argument_list|,
name|_dtrace_libdir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|drti
argument_list|,
sizeof|sizeof
argument_list|(
name|drti
argument_list|)
argument_list|,
literal|"%s/drti.o"
argument_list|,
name|_dtrace_libdir
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|snprintf
argument_list|(
operator|&
name|tmp
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|,
name|dtp
operator|->
name|dt_ld_path
argument_list|,
name|file
argument_list|,
name|fd
argument_list|,
name|drti
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cmd
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|cmd
argument_list|,
name|len
argument_list|,
name|fmt
argument_list|,
name|dtp
operator|->
name|dt_ld_path
argument_list|,
name|file
argument_list|,
name|fd
argument_list|,
name|drti
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|const
name|char
modifier|*
name|fmt
init|=
literal|"%s -o %s -r %s"
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
comment|/* 		 * Arches which default to 64-bit need to explicitly use 		 * the 32-bit library path. 		 */
name|int
name|use_32
init|=
operator|(
name|dtp
operator|->
name|dt_oflags
operator|&
name|DTRACE_O_ILP32
operator|)
decl_stmt|;
else|#
directive|else
comment|/* 		 * Arches which are 32-bit only just use the normal 		 * library path. 		 */
name|int
name|use_32
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|drti
argument_list|,
sizeof|sizeof
argument_list|(
name|drti
argument_list|)
argument_list|,
literal|"/usr/lib%s/dtrace/drti.o"
argument_list|,
name|use_32
condition|?
literal|"32"
else|:
literal|""
argument_list|)
expr_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
operator|&
name|tmp
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|,
name|dtp
operator|->
name|dt_ld_path
argument_list|,
name|file
argument_list|,
name|tfile
argument_list|,
name|drti
argument_list|)
operator|+
literal|1
expr_stmt|;
name|len
operator|*=
literal|2
expr_stmt|;
name|cmd
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|cmd
argument_list|,
name|len
argument_list|,
name|fmt
argument_list|,
name|dtp
operator|->
name|dt_ld_path
argument_list|,
name|file
argument_list|,
name|drti
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|status
operator|=
name|system
argument_list|(
name|cmd
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"failed to run %s: %s"
argument_list|,
name|dtp
operator|->
name|dt_ld_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|ret
operator|=
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"failed to link %s: %s failed due to signal %d"
argument_list|,
name|file
argument_list|,
name|dtp
operator|->
name|dt_ld_path
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"failed to link %s: %s exited with status %d\n"
argument_list|,
name|file
argument_list|,
name|dtp
operator|->
name|dt_ld_path
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
comment|/* 		 * FreeBSD's ld(1) is not instructed to interpret and add 		 * correctly the SUNW_dof section present in tfile. 		 * We use libelf to add this section manually and hope the next 		 * ld invocation won't remove it. 		 */
name|elf_version
argument_list|(
name|EV_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|efd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"failed to open file %s: %s"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|e
operator|=
name|elf_begin
argument_list|(
name|efd
argument_list|,
name|ELF_C_RDWR
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|efd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"failed to open elf file: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elf_errno
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * Add the string '.SUWN_dof' to the shstrtab section. 		 */
name|elf_getshdrstrndx
argument_list|(
name|e
argument_list|,
operator|&
name|stridx
argument_list|)
expr_stmt|;
name|scn
operator|=
name|elf_getscn
argument_list|(
name|e
argument_list|,
name|stridx
argument_list|)
expr_stmt|;
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|shdr
argument_list|)
expr_stmt|;
name|data
operator|=
name|elf_newdata
argument_list|(
name|scn
argument_list|)
expr_stmt|;
name|data
operator|->
name|d_off
operator|=
name|shdr
operator|.
name|sh_size
expr_stmt|;
name|data
operator|->
name|d_buf
operator|=
literal|".SUNW_dof"
expr_stmt|;
name|data
operator|->
name|d_size
operator|=
literal|10
expr_stmt|;
name|data
operator|->
name|d_type
operator|=
name|ELF_T_BYTE
expr_stmt|;
name|loc
operator|=
name|shdr
operator|.
name|sh_size
expr_stmt|;
name|shdr
operator|.
name|sh_size
operator|+=
name|data
operator|->
name|d_size
expr_stmt|;
name|gelf_update_shdr
argument_list|(
name|scn
argument_list|,
operator|&
name|shdr
argument_list|)
expr_stmt|;
comment|/* 		 * Construct the .SUNW_dof section. 		 */
name|scn
operator|=
name|elf_newscn
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|data
operator|=
name|elf_newdata
argument_list|(
name|scn
argument_list|)
expr_stmt|;
name|buf
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|dof
operator|->
name|dofh_filesz
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|MAP_FAILED
condition|)
block|{
name|ret
operator|=
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"failed to mmap buffer %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|efd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|data
operator|->
name|d_buf
operator|=
name|buf
expr_stmt|;
name|data
operator|->
name|d_align
operator|=
literal|4
expr_stmt|;
name|data
operator|->
name|d_size
operator|=
name|dof
operator|->
name|dofh_filesz
expr_stmt|;
name|data
operator|->
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|shdr
argument_list|)
expr_stmt|;
name|shdr
operator|.
name|sh_name
operator|=
name|loc
expr_stmt|;
name|shdr
operator|.
name|sh_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
comment|/* 		 * Actually this should be SHT_SUNW_dof, but FreeBSD's ld(1) 		 * will remove this 'unknown' section when we try to create an 		 * executable using the object we are modifying, so we stop 		 * playing by the rules and use SHT_PROGBITS. 		 * Also, note that our drti has modifications to handle this. 		 */
name|shdr
operator|.
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|shdr
operator|.
name|sh_addralign
operator|=
literal|4
expr_stmt|;
name|gelf_update_shdr
argument_list|(
name|scn
argument_list|,
operator|&
name|shdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_update
argument_list|(
name|e
argument_list|,
name|ELF_C_WRITE
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|dt_link_error
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|"failed to add the SUNW_dof section: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elf_errno
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|buf
argument_list|,
name|dof
operator|->
name|dofh_filesz
argument_list|)
expr_stmt|;
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|efd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|munmap
argument_list|(
name|buf
argument_list|,
name|dof
operator|->
name|dofh_filesz
argument_list|)
expr_stmt|;
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|efd
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* release temporary file */
block|}
else|else
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|dtrace_dof_destroy
argument_list|(
name|dtp
argument_list|,
name|dof
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|unlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

