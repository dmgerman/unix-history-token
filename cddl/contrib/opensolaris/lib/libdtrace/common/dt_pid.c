begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_include
include|#
directive|include
file|<dt_program.h>
end_include

begin_include
include|#
directive|include
file|<dt_pid.h>
end_include

begin_include
include|#
directive|include
file|<dt_string.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<libproc_compat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|dt_pid_probe
block|{
name|dtrace_hdl_t
modifier|*
name|dpp_dtp
decl_stmt|;
name|dt_pcb_t
modifier|*
name|dpp_pcb
decl_stmt|;
name|dt_proc_t
modifier|*
name|dpp_dpr
decl_stmt|;
name|struct
name|ps_prochandle
modifier|*
name|dpp_pr
decl_stmt|;
specifier|const
name|char
modifier|*
name|dpp_mod
decl_stmt|;
name|char
modifier|*
name|dpp_func
decl_stmt|;
specifier|const
name|char
modifier|*
name|dpp_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|dpp_obj
decl_stmt|;
name|uintptr_t
name|dpp_pc
decl_stmt|;
name|size_t
name|dpp_size
decl_stmt|;
name|Lmid_t
name|dpp_lmid
decl_stmt|;
name|uint_t
name|dpp_nmatches
decl_stmt|;
name|uint64_t
name|dpp_stret
index|[
literal|4
index|]
decl_stmt|;
name|GElf_Sym
name|dpp_last
decl_stmt|;
name|uint_t
name|dpp_last_taken
decl_stmt|;
block|}
name|dt_pid_probe_t
typedef|;
end_typedef

begin_comment
comment|/*  * Compose the lmid and object name into the canonical representation. We  * omit the lmid for the default link map for convenience.  */
end_comment

begin_function
specifier|static
name|void
name|dt_pid_objname
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|Lmid_t
name|lmid
parameter_list|,
specifier|const
name|char
modifier|*
name|obj
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|lmid
operator|==
name|LM_ID_BASE
condition|)
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|obj
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"LM%lx`%s"
argument_list|,
name|lmid
argument_list|,
name|obj
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|obj
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|dt_pid_error
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_pcb_t
modifier|*
name|pcb
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|,
name|fasttrap_probe_spec_t
modifier|*
name|ftp
parameter_list|,
name|dt_errtag_t
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|ftp
operator|!=
name|NULL
condition|)
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|ftp
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|dpr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|vsnprintf
argument_list|(
name|dpr
operator|->
name|dpr_errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|dpr
operator|->
name|dpr_errmsg
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|len
operator|>=
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpr
operator|->
name|dpr_errmsg
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|dpr
operator|->
name|dpr_errmsg
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|dt_set_errmsg
argument_list|(
name|dtp
argument_list|,
name|dt_errtag
argument_list|(
name|tag
argument_list|)
argument_list|,
name|pcb
operator|->
name|pcb_region
argument_list|,
name|pcb
operator|->
name|pcb_filetag
argument_list|,
name|pcb
operator|->
name|pcb_fileptr
condition|?
name|yylineno
else|:
literal|0
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_pid_per_sym
parameter_list|(
name|dt_pid_probe_t
modifier|*
name|pp
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|symp
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|pp
operator|->
name|dpp_dtp
decl_stmt|;
name|dt_pcb_t
modifier|*
name|pcb
init|=
name|pp
operator|->
name|dpp_pcb
decl_stmt|;
name|dt_proc_t
modifier|*
name|dpr
init|=
name|pp
operator|->
name|dpp_dpr
decl_stmt|;
name|fasttrap_probe_spec_t
modifier|*
name|ftp
decl_stmt|;
name|uint64_t
name|off
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|uint_t
name|nmatches
init|=
literal|0
decl_stmt|;
name|ulong_t
name|sz
decl_stmt|;
name|int
name|glob
decl_stmt|,
name|err
decl_stmt|;
name|int
name|isdash
init|=
name|strcmp
argument_list|(
literal|"-"
argument_list|,
name|func
argument_list|)
operator|==
literal|0
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|pid
operator|=
name|Pstatus
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|)
operator|->
name|pr_pid
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|proc_getpid
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dt_dprintf
argument_list|(
literal|"creating probe pid%d:%s:%s:%s\n"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|,
name|pp
operator|->
name|dpp_obj
argument_list|,
name|func
argument_list|,
name|pp
operator|->
name|dpp_name
argument_list|)
expr_stmt|;
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|fasttrap_probe_spec_t
argument_list|)
operator|+
operator|(
name|isdash
condition|?
literal|4
else|:
operator|(
name|symp
operator|->
name|st_size
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ftp
operator|->
name|ftps_offs
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ftp
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|sz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"proc_per_sym: dt_alloc(%lu) failed\n"
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* errno is set for us */
block|}
name|ftp
operator|->
name|ftps_pid
operator|=
name|pid
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ftp
operator|->
name|ftps_func
argument_list|,
name|func
argument_list|,
sizeof|sizeof
argument_list|(
name|ftp
operator|->
name|ftps_func
argument_list|)
argument_list|)
expr_stmt|;
name|dt_pid_objname
argument_list|(
name|ftp
operator|->
name|ftps_mod
argument_list|,
sizeof|sizeof
argument_list|(
name|ftp
operator|->
name|ftps_mod
argument_list|)
argument_list|,
name|pp
operator|->
name|dpp_lmid
argument_list|,
name|pp
operator|->
name|dpp_obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdash
operator|&&
name|gmatch
argument_list|(
literal|"return"
argument_list|,
name|pp
operator|->
name|dpp_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|dt_pid_create_return_probe
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|dtp
argument_list|,
name|ftp
argument_list|,
name|symp
argument_list|,
name|pp
operator|->
name|dpp_stret
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|ftp
argument_list|,
name|D_PROC_CREATEFAIL
argument_list|,
literal|"failed to create return probe "
literal|"for '%s': %s"
argument_list|,
name|func
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
name|nmatches
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdash
operator|&&
name|gmatch
argument_list|(
literal|"entry"
argument_list|,
name|pp
operator|->
name|dpp_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|dt_pid_create_entry_probe
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|dtp
argument_list|,
name|ftp
argument_list|,
name|symp
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|ftp
argument_list|,
name|D_PROC_CREATEFAIL
argument_list|,
literal|"failed to create entry probe "
literal|"for '%s': %s"
argument_list|,
name|func
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
name|nmatches
operator|++
expr_stmt|;
block|}
name|glob
operator|=
name|strisglob
argument_list|(
name|pp
operator|->
name|dpp_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glob
operator|&&
name|nmatches
operator|==
literal|0
condition|)
block|{
name|off
operator|=
name|strtoull
argument_list|(
name|pp
operator|->
name|dpp_name
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|ftp
argument_list|,
name|D_PROC_NAME
argument_list|,
literal|"'%s' is an invalid probe name"
argument_list|,
name|pp
operator|->
name|dpp_name
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|off
operator|>=
name|symp
operator|->
name|st_size
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|ftp
argument_list|,
name|D_PROC_OFF
argument_list|,
literal|"offset 0x%llx outside of function '%s'"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|off
argument_list|,
name|func
argument_list|)
operator|)
return|;
block|}
name|err
operator|=
name|dt_pid_create_offset_probe
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pp
operator|->
name|dpp_dtp
argument_list|,
name|ftp
argument_list|,
name|symp
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|DT_PROC_ERR
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|ftp
argument_list|,
name|D_PROC_CREATEFAIL
argument_list|,
literal|"failed to create probe at "
literal|"'%s+0x%llx': %s"
argument_list|,
name|func
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|off
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|err
operator|==
name|DT_PROC_ALIGN
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|ftp
argument_list|,
name|D_PROC_ALIGN
argument_list|,
literal|"offset 0x%llx is not aligned on an instruction"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|off
argument_list|)
operator|)
return|;
block|}
name|nmatches
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|glob
operator|&&
operator|!
name|isdash
condition|)
block|{
if|if
condition|(
name|dt_pid_create_glob_offset_probes
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pp
operator|->
name|dpp_dtp
argument_list|,
name|ftp
argument_list|,
name|symp
argument_list|,
name|pp
operator|->
name|dpp_name
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|ftp
argument_list|,
name|D_PROC_CREATEFAIL
argument_list|,
literal|"failed to create offset probes in '%s': %s"
argument_list|,
name|func
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
name|nmatches
operator|++
expr_stmt|;
block|}
name|pp
operator|->
name|dpp_nmatches
operator|+=
name|nmatches
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|ftp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_pid_sym_filt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|symp
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|dt_pid_probe_t
modifier|*
name|pp
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|symp
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|symp
operator|->
name|st_size
operator|==
literal|0
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"st_size of %s is zero\n"
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pp
operator|->
name|dpp_last_taken
operator|==
literal|0
operator|||
name|symp
operator|->
name|st_value
operator|!=
name|pp
operator|->
name|dpp_last
operator|.
name|st_value
operator|||
name|symp
operator|->
name|st_size
operator|!=
name|pp
operator|->
name|dpp_last
operator|.
name|st_size
condition|)
block|{
comment|/* 		 * Due to 4524008, _init and _fini may have a bloated st_size. 		 * While this bug has been fixed for a while, old binaries 		 * may exist that still exhibit this problem. As a result, we 		 * don't match _init and _fini though we allow users to 		 * specify them explicitly. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|func
argument_list|,
literal|"_init"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|func
argument_list|,
literal|"_fini"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|pp
operator|->
name|dpp_last_taken
operator|=
name|gmatch
argument_list|(
name|func
argument_list|,
name|pp
operator|->
name|dpp_func
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|pp
operator|->
name|dpp_last
operator|=
operator|*
name|symp
expr_stmt|;
return|return
operator|(
name|dt_pid_per_sym
argument_list|(
name|pp
argument_list|,
name|symp
argument_list|,
name|func
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_pid_per_mod
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|prmap_t
modifier|*
name|pmp
parameter_list|,
specifier|const
name|char
modifier|*
name|obj
parameter_list|)
block|{
name|dt_pid_probe_t
modifier|*
name|pp
init|=
name|arg
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|pp
operator|->
name|dpp_dtp
decl_stmt|;
name|dt_pcb_t
modifier|*
name|pcb
init|=
name|pp
operator|->
name|dpp_pcb
decl_stmt|;
name|dt_proc_t
modifier|*
name|dpr
init|=
name|pp
operator|->
name|dpp_dpr
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|(
name|void
operator|)
name|Plmid
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pmp
operator|->
name|pr_vaddr
argument_list|,
operator|&
name|pp
operator|->
name|dpp_lmid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|pp
operator|->
name|dpp_obj
operator|=
name|strrchr
argument_list|(
name|obj
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|pp
operator|->
name|dpp_obj
operator|=
name|obj
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_obj
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|Pxlookup_by_name
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pp
operator|->
name|dpp_lmid
argument_list|,
name|obj
argument_list|,
literal|".stret1"
argument_list|,
operator|&
name|sym
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|pp
operator|->
name|dpp_stret
index|[
literal|0
index|]
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_stret
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Pxlookup_by_name
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pp
operator|->
name|dpp_lmid
argument_list|,
name|obj
argument_list|,
literal|".stret2"
argument_list|,
operator|&
name|sym
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|pp
operator|->
name|dpp_stret
index|[
literal|1
index|]
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_stret
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Pxlookup_by_name
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pp
operator|->
name|dpp_lmid
argument_list|,
name|obj
argument_list|,
literal|".stret4"
argument_list|,
operator|&
name|sym
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|pp
operator|->
name|dpp_stret
index|[
literal|2
index|]
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_stret
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Pxlookup_by_name
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pp
operator|->
name|dpp_lmid
argument_list|,
name|obj
argument_list|,
literal|".stret8"
argument_list|,
operator|&
name|sym
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|pp
operator|->
name|dpp_stret
index|[
literal|3
index|]
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_stret
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|pp
operator|->
name|dpp_stret
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|dpp_stret
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|dpp_stret
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|dpp_stret
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|dt_dprintf
argument_list|(
literal|"%s stret %llx %llx %llx %llx\n"
argument_list|,
name|obj
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|pp
operator|->
name|dpp_stret
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|pp
operator|->
name|dpp_stret
index|[
literal|1
index|]
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|pp
operator|->
name|dpp_stret
index|[
literal|2
index|]
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|pp
operator|->
name|dpp_stret
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * If pp->dpp_func contains any globbing meta-characters, we need 	 * to iterate over the symbol table and compare each function name 	 * against the pattern. 	 */
if|if
condition|(
operator|!
name|strisglob
argument_list|(
name|pp
operator|->
name|dpp_func
argument_list|)
condition|)
block|{
comment|/* 		 * If we fail to lookup the symbol, try interpreting the 		 * function as the special "-" function that indicates that the 		 * probe name should be interpreted as a absolute virtual 		 * address. If that fails and we were matching a specific 		 * function in a specific module, report the error, otherwise 		 * just fail silently in the hopes that some other object will 		 * contain the desired symbol. 		 */
if|if
condition|(
name|Pxlookup_by_name
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pp
operator|->
name|dpp_lmid
argument_list|,
name|obj
argument_list|,
name|pp
operator|->
name|dpp_func
argument_list|,
operator|&
name|sym
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"-"
argument_list|,
name|pp
operator|->
name|dpp_func
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|GELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|sym
operator|.
name|st_size
operator|=
name|Pstatus
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|)
operator|->
name|pr_dmodel
operator|==
name|PR_MODEL_ILP32
condition|?
operator|-
literal|1U
else|:
operator|-
literal|1ULL
expr_stmt|;
else|#
directive|else
name|sym
operator|.
name|st_size
operator|=
operator|~
operator|(
operator|(
name|Elf64_Xword
operator|)
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|strisglob
argument_list|(
name|pp
operator|->
name|dpp_mod
argument_list|)
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|NULL
argument_list|,
name|D_PROC_FUNC
argument_list|,
literal|"failed to lookup '%s' in module '%s'"
argument_list|,
name|pp
operator|->
name|dpp_func
argument_list|,
name|pp
operator|->
name|dpp_mod
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 		 * Only match defined functions of non-zero size. 		 */
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
operator|||
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
operator|||
name|sym
operator|.
name|st_size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * We don't instrument PLTs -- they're dynamically rewritten, 		 * and, so, inherently dicey to instrument. 		 */
ifdef|#
directive|ifdef
name|DOODAD
if|if
condition|(
name|Ppltdest
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|sym
operator|.
name|st_value
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|Plookup_by_addr
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|sym
operator|.
name|st_value
argument_list|,
name|pp
operator|->
name|dpp_func
argument_list|,
name|DTRACE_FUNCNAMELEN
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_pid_per_sym
argument_list|(
name|pp
argument_list|,
operator|&
name|sym
argument_list|,
name|pp
operator|->
name|dpp_func
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|uint_t
name|nmatches
init|=
name|pp
operator|->
name|dpp_nmatches
decl_stmt|;
if|if
condition|(
name|Psymbol_iter_by_addr
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|obj
argument_list|,
name|PR_SYMTAB
argument_list|,
name|BIND_ANY
operator||
name|TYPE_FUNC
argument_list|,
name|dt_pid_sym_filt
argument_list|,
name|pp
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|nmatches
operator|==
name|pp
operator|->
name|dpp_nmatches
condition|)
block|{
comment|/* 			 * If we didn't match anything in the PR_SYMTAB, try 			 * the PR_DYNSYM. 			 */
if|if
condition|(
name|Psymbol_iter_by_addr
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|obj
argument_list|,
name|PR_DYNSYM
argument_list|,
name|BIND_ANY
operator||
name|TYPE_FUNC
argument_list|,
name|dt_pid_sym_filt
argument_list|,
name|pp
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_pid_mod_filt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|prmap_t
modifier|*
name|pmp
parameter_list|,
specifier|const
name|char
modifier|*
name|obj
parameter_list|)
block|{
name|char
name|name
index|[
name|DTRACE_MODNAMELEN
index|]
decl_stmt|;
name|dt_pid_probe_t
modifier|*
name|pp
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|gmatch
argument_list|(
name|obj
argument_list|,
name|pp
operator|->
name|dpp_mod
argument_list|)
condition|)
return|return
operator|(
name|dt_pid_per_mod
argument_list|(
name|pp
argument_list|,
name|pmp
argument_list|,
name|obj
argument_list|)
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|(
name|void
operator|)
name|Plmid
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pmp
operator|->
name|pr_vaddr
argument_list|,
operator|&
name|pp
operator|->
name|dpp_lmid
argument_list|)
expr_stmt|;
else|#
directive|else
name|pp
operator|->
name|dpp_lmid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|pp
operator|->
name|dpp_obj
operator|=
name|strrchr
argument_list|(
name|obj
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|pp
operator|->
name|dpp_obj
operator|=
name|obj
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_obj
operator|++
expr_stmt|;
if|if
condition|(
name|gmatch
argument_list|(
name|pp
operator|->
name|dpp_obj
argument_list|,
name|pp
operator|->
name|dpp_mod
argument_list|)
condition|)
return|return
operator|(
name|dt_pid_per_mod
argument_list|(
name|pp
argument_list|,
name|pmp
argument_list|,
name|obj
argument_list|)
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|(
name|void
operator|)
name|Plmid
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pmp
operator|->
name|pr_vaddr
argument_list|,
operator|&
name|pp
operator|->
name|dpp_lmid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dt_pid_objname
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|pp
operator|->
name|dpp_lmid
argument_list|,
name|pp
operator|->
name|dpp_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmatch
argument_list|(
name|name
argument_list|,
name|pp
operator|->
name|dpp_mod
argument_list|)
condition|)
return|return
operator|(
name|dt_pid_per_mod
argument_list|(
name|pp
argument_list|,
name|pmp
argument_list|,
name|obj
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|prmap_t
modifier|*
name|dt_pid_fix_mod
parameter_list|(
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|struct
name|ps_prochandle
modifier|*
name|P
parameter_list|)
block|{
name|char
name|m
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|Lmid_t
name|lmid
init|=
name|PR_LMID_EVERY
decl_stmt|;
else|#
directive|else
name|Lmid_t
name|lmid
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
specifier|const
name|char
modifier|*
name|obj
decl_stmt|;
specifier|const
name|prmap_t
modifier|*
name|pmp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
comment|/* 	 * Pick apart the link map from the library name. 	 */
if|if
condition|(
name|strchr
argument_list|(
name|pdp
operator|->
name|dtpd_mod
argument_list|,
literal|'`'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pdp
operator|->
name|dtpd_mod
argument_list|,
literal|"LM"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|isdigit
argument_list|(
name|pdp
operator|->
name|dtpd_mod
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|lmid
operator|=
name|strtoul
argument_list|(
operator|&
name|pdp
operator|->
name|dtpd_mod
index|[
literal|2
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|obj
operator|=
name|end
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'`'
operator|||
name|strchr
argument_list|(
name|obj
argument_list|,
literal|'`'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|obj
operator|=
name|pdp
operator|->
name|dtpd_mod
expr_stmt|;
block|}
else|#
directive|else
name|obj
operator|=
name|pdp
operator|->
name|dtpd_mod
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|pmp
operator|=
name|Plmid_to_map
argument_list|(
name|P
argument_list|,
name|lmid
argument_list|,
name|obj
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|(
name|void
operator|)
name|Pobjname
argument_list|(
name|P
argument_list|,
name|pmp
operator|->
name|pr_vaddr
argument_list|,
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|obj
operator|=
name|strrchr
argument_list|(
name|m
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|obj
operator|=
operator|&
name|m
index|[
literal|0
index|]
expr_stmt|;
else|else
name|obj
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|Plmid
argument_list|(
name|P
argument_list|,
name|pmp
operator|->
name|pr_vaddr
argument_list|,
operator|&
name|lmid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dt_pid_objname
argument_list|(
name|pdp
operator|->
name|dtpd_mod
argument_list|,
sizeof|sizeof
argument_list|(
name|pdp
operator|->
name|dtpd_mod
argument_list|)
argument_list|,
name|lmid
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|pmp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_pid_create_pid_probes
parameter_list|(
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_pcb_t
modifier|*
name|pcb
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|)
block|{
name|dt_pid_probe_t
name|pp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|pp
operator|.
name|dpp_dtp
operator|=
name|dtp
expr_stmt|;
name|pp
operator|.
name|dpp_dpr
operator|=
name|dpr
expr_stmt|;
name|pp
operator|.
name|dpp_pr
operator|=
name|dpr
operator|->
name|dpr_proc
expr_stmt|;
name|pp
operator|.
name|dpp_pcb
operator|=
name|pcb
expr_stmt|;
ifdef|#
directive|ifdef
name|DOODAD
comment|/* 	 * We can only trace dynamically-linked executables (since we've 	 * hidden some magic in ld.so.1 as well as libc.so.1). 	 */
if|if
condition|(
name|Pname_to_map
argument_list|(
name|pp
operator|.
name|dpp_pr
argument_list|,
name|PR_OBJ_LDSO
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|NULL
argument_list|,
name|D_PROC_DYN
argument_list|,
literal|"process %s is not a dynamically-linked executable"
argument_list|,
operator|&
name|pdp
operator|->
name|dtpd_provider
index|[
literal|3
index|]
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
name|pp
operator|.
name|dpp_mod
operator|=
name|pdp
operator|->
name|dtpd_mod
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|pdp
operator|->
name|dtpd_mod
else|:
literal|"*"
expr_stmt|;
name|pp
operator|.
name|dpp_func
operator|=
name|pdp
operator|->
name|dtpd_func
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|pdp
operator|->
name|dtpd_func
else|:
literal|"*"
expr_stmt|;
name|pp
operator|.
name|dpp_name
operator|=
name|pdp
operator|->
name|dtpd_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|pdp
operator|->
name|dtpd_name
else|:
literal|"*"
expr_stmt|;
name|pp
operator|.
name|dpp_last_taken
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pp
operator|.
name|dpp_func
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|prmap_t
modifier|*
name|aout
decl_stmt|,
modifier|*
name|pmp
decl_stmt|;
if|if
condition|(
name|pdp
operator|->
name|dtpd_mod
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|pp
operator|.
name|dpp_mod
operator|=
name|pdp
operator|->
name|dtpd_mod
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pdp
operator|->
name|dtpd_mod
argument_list|,
literal|"a.out"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strisglob
argument_list|(
name|pp
operator|.
name|dpp_mod
argument_list|)
operator|||
operator|(
name|aout
operator|=
name|Pname_to_map
argument_list|(
name|pp
operator|.
name|dpp_pr
argument_list|,
literal|"a.out"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|pmp
operator|=
name|Pname_to_map
argument_list|(
name|pp
operator|.
name|dpp_pr
argument_list|,
name|pp
operator|.
name|dpp_mod
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|aout
operator|->
name|pr_vaddr
operator|!=
name|pmp
operator|->
name|pr_vaddr
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|NULL
argument_list|,
name|D_PROC_LIB
argument_list|,
literal|"only the a.out module is valid with the "
literal|"'-' function"
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|strisglob
argument_list|(
name|pp
operator|.
name|dpp_name
argument_list|)
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|NULL
argument_list|,
name|D_PROC_NAME
argument_list|,
literal|"only individual addresses may be specified "
literal|"with the '-' function"
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* 	 * If pp.dpp_mod contains any globbing meta-characters, we need 	 * to iterate over each module and compare its name against the 	 * pattern. An empty module name is treated as '*'. 	 */
if|if
condition|(
name|strisglob
argument_list|(
name|pp
operator|.
name|dpp_mod
argument_list|)
condition|)
block|{
name|ret
operator|=
name|Pobject_iter
argument_list|(
name|pp
operator|.
name|dpp_pr
argument_list|,
name|dt_pid_mod_filt
argument_list|,
operator|&
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|prmap_t
modifier|*
name|pmp
decl_stmt|;
name|char
modifier|*
name|obj
decl_stmt|;
comment|/* 		 * If we can't find a matching module, don't sweat it -- either 		 * we'll fail the enabling because the probes don't exist or 		 * we'll wait for that module to come along. 		 */
if|if
condition|(
operator|(
name|pmp
operator|=
name|dt_pid_fix_mod
argument_list|(
name|pdp
argument_list|,
name|pp
operator|.
name|dpp_pr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|obj
operator|=
name|strchr
argument_list|(
name|pdp
operator|->
name|dtpd_mod
argument_list|,
literal|'`'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|obj
operator|=
name|pdp
operator|->
name|dtpd_mod
expr_stmt|;
else|else
name|obj
operator|++
expr_stmt|;
name|ret
operator|=
name|dt_pid_per_mod
argument_list|(
operator|&
name|pp
argument_list|,
name|pmp
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_pid_usdt_mapping
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|prmap_t
modifier|*
name|pmp
parameter_list|,
specifier|const
name|char
modifier|*
name|oname
parameter_list|)
block|{
name|struct
name|ps_prochandle
modifier|*
name|P
init|=
name|data
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|prsyminfo_t
name|sip
decl_stmt|;
endif|#
directive|endif
name|dof_helper_t
name|dh
decl_stmt|;
name|GElf_Half
name|e_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|mname
decl_stmt|;
specifier|const
name|char
modifier|*
name|syms
index|[]
init|=
block|{
literal|"___SUNW_dof"
block|,
literal|"__SUNW_dof"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fd
init|=
operator|-
literal|1
decl_stmt|;
comment|/* 	 * The symbol ___SUNW_dof is for lazy-loaded DOF sections, and 	 * __SUNW_dof is for actively-loaded DOF sections. We try to force 	 * in both types of DOF section since the process may not yet have 	 * run the code to instantiate these providers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Pxlookup_by_name
argument_list|(
name|P
argument_list|,
name|PR_LMID_EVERY
argument_list|,
name|oname
argument_list|,
name|syms
index|[
name|i
index|]
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sip
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|mname
operator|=
name|strrchr
argument_list|(
name|oname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|mname
operator|=
name|oname
expr_stmt|;
else|else
name|mname
operator|++
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"lookup of %s succeeded for %s\n"
argument_list|,
name|syms
index|[
name|i
index|]
argument_list|,
name|mname
argument_list|)
expr_stmt|;
if|if
condition|(
name|Pread
argument_list|(
name|P
argument_list|,
operator|&
name|e_type
argument_list|,
sizeof|sizeof
argument_list|(
name|e_type
argument_list|)
argument_list|,
name|pmp
operator|->
name|pr_vaddr
operator|+
name|offsetof
argument_list|(
name|Elf64_Ehdr
argument_list|,
name|e_type
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|e_type
argument_list|)
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"read of ELF header failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dh
operator|.
name|dofhp_dof
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
name|dh
operator|.
name|dofhp_addr
operator|=
operator|(
name|e_type
operator|==
name|ET_EXEC
operator|)
condition|?
literal|0
else|:
name|pmp
operator|->
name|pr_vaddr
expr_stmt|;
name|dt_pid_objname
argument_list|(
name|dh
operator|.
name|dofhp_mod
argument_list|,
sizeof|sizeof
argument_list|(
name|dh
operator|.
name|dofhp_mod
argument_list|)
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|sip
operator|.
name|prs_lmid
argument_list|,
name|mname
argument_list|)
expr_stmt|;
else|#
directive|else
literal|0
operator|,
name|mname
block|)
empty_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
operator|&&
operator|(
name|fd
operator|=
name|pr_open
argument_list|(
name|P
argument_list|,
literal|"/dev/dtrace/helper"
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"pr_open of helper device failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
block|}
if|if
condition|(
name|pr_ioctl
argument_list|(
name|P
argument_list|,
name|fd
argument_list|,
name|DTRACEHIOC_ADDDOF
argument_list|,
operator|&
name|dh
argument_list|,
sizeof|sizeof
argument_list|(
name|dh
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|dt_dprintf
argument_list|(
literal|"DOF was rejected for %s\n"
argument_list|,
name|dh
operator|.
name|dofhp_mod
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_if
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|pr_close
argument_list|(
name|P
argument_list|,
name|fd
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_function
unit|}  static
name|int
name|dt_pid_create_usdt_probes
parameter_list|(
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_pcb_t
modifier|*
name|pcb
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|)
block|{
name|struct
name|ps_prochandle
modifier|*
name|P
init|=
name|dpr
operator|->
name|dpr_proc
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|DT_MUTEX_HELD
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|(
name|void
operator|)
name|Pupdate_maps
argument_list|(
name|P
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|Pobject_iter
argument_list|(
name|P
argument_list|,
name|dt_pid_usdt_mapping
argument_list|,
name|P
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|NULL
argument_list|,
name|D_PROC_USDT
argument_list|,
literal|"failed to instantiate probes for pid %d: %s"
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|(
name|int
operator|)
name|Pstatus
argument_list|(
name|P
argument_list|)
operator|->
name|pr_pid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|int
operator|)
name|proc_getpid
argument_list|(
name|P
argument_list|)
operator|,
name|strerror
argument_list|(
name|errno
argument_list|)
block|)
empty_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* 	 * Put the module name in its canonical form. 	 */
end_comment

begin_expr_stmt
operator|(
name|void
operator|)
name|dt_pid_fix_mod
argument_list|(
name|pdp
argument_list|,
name|P
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ret
operator|)
return|;
end_return

begin_function
unit|}  static
name|pid_t
name|dt_pid_get_pid
parameter_list|(
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_pcb_t
modifier|*
name|pcb
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|,
modifier|*
name|last
init|=
name|NULL
decl_stmt|,
modifier|*
name|end
decl_stmt|;
for|for
control|(
name|c
operator|=
operator|&
name|pdp
operator|->
name|dtpd_provider
index|[
literal|0
index|]
init|;
operator|*
name|c
operator|!=
literal|'\0'
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|c
argument_list|)
condition|)
name|last
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|==
name|NULL
operator|||
operator|(
operator|*
operator|(
operator|++
name|last
operator|)
operator|==
literal|'\0'
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|NULL
argument_list|,
name|D_PROC_BADPROV
argument_list|,
literal|"'%s' is not a valid provider"
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|pid
operator|=
name|strtol
argument_list|(
name|last
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
name|end
operator|==
name|last
operator|||
name|end
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|pid
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|NULL
argument_list|,
name|D_PROC_BADPID
argument_list|,
literal|"'%s' does not contain a valid pid"
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|pid
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_pid_create_probes
parameter_list|(
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_pcb_t
modifier|*
name|pcb
parameter_list|)
block|{
name|char
name|provname
index|[
name|DTRACE_PROVNAMELEN
index|]
decl_stmt|;
name|struct
name|ps_prochandle
modifier|*
name|P
decl_stmt|;
name|dt_proc_t
modifier|*
name|dpr
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|pcb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|dt_pid_get_pid
argument_list|(
name|pdp
argument_list|,
name|dtp
argument_list|,
name|pcb
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dtp
operator|->
name|dt_ftfd
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|dtp
operator|->
name|dt_fterr
operator|==
name|ENOENT
condition|)
block|{
operator|(
name|void
operator|)
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|D_PROC_NODEV
argument_list|,
literal|"pid provider is not installed on this system"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|D_PROC_NODEV
argument_list|,
literal|"pid provider is not available: %s"
argument_list|,
name|strerror
argument_list|(
name|dtp
operator|->
name|dt_fterr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|provname
argument_list|,
sizeof|sizeof
argument_list|(
name|provname
argument_list|)
argument_list|,
literal|"pid%d"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmatch
argument_list|(
name|provname
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|P
operator|=
name|dt_proc_grab
argument_list|(
name|dtp
argument_list|,
name|pid
argument_list|,
name|PGRAB_RDONLY
operator||
name|PGRAB_FORCE
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|D_PROC_GRAB
argument_list|,
literal|"failed to grab process %d"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dpr
operator|=
name|dt_proc_lookup
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dpr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|dt_pid_create_pid_probes
argument_list|(
name|pdp
argument_list|,
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Alert other retained enablings which may match 			 * against the newly created probes. 			 */
operator|(
name|void
operator|)
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_ENABLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If it's not strictly a pid provider, we might match a USDT provider. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|provname
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|P
operator|=
name|dt_proc_grab
argument_list|(
name|dtp
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|D_PROC_GRAB
argument_list|,
literal|"failed to grab process %d"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dpr
operator|=
name|dt_proc_lookup
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dpr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dpr
operator|->
name|dpr_usdt
condition|)
block|{
name|err
operator|=
name|dt_pid_create_usdt_probes
argument_list|(
name|pdp
argument_list|,
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|)
expr_stmt|;
name|dpr
operator|->
name|dpr_usdt
operator|=
name|B_TRUE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_pid_create_probes_module
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|)
block|{
name|dtrace_enable_io_t
name|args
decl_stmt|;
name|dtrace_prog_t
modifier|*
name|pgp
decl_stmt|;
name|dt_stmt_t
modifier|*
name|stp
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
name|pdp
decl_stmt|,
name|pd
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|found
init|=
name|B_FALSE
decl_stmt|;
name|char
name|provname
index|[
name|DTRACE_PROVNAMELEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|provname
argument_list|,
sizeof|sizeof
argument_list|(
name|provname
argument_list|)
argument_list|,
literal|"pid%d"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|)
expr_stmt|;
for|for
control|(
name|pgp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_programs
argument_list|)
init|;
name|pgp
operator|!=
name|NULL
condition|;
name|pgp
operator|=
name|dt_list_next
argument_list|(
name|pgp
argument_list|)
control|)
block|{
for|for
control|(
name|stp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|pgp
operator|->
name|dp_stmts
argument_list|)
init|;
name|stp
operator|!=
name|NULL
condition|;
name|stp
operator|=
name|dt_list_next
argument_list|(
name|stp
argument_list|)
control|)
block|{
name|pdp
operator|=
operator|&
name|stp
operator|->
name|ds_desc
operator|->
name|dtsd_ecbdesc
operator|->
name|dted_probe
expr_stmt|;
name|pid
operator|=
name|dt_pid_get_pid
argument_list|(
name|pdp
argument_list|,
name|dtp
argument_list|,
name|NULL
argument_list|,
name|dpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
name|dpr
operator|->
name|dpr_pid
condition|)
continue|continue;
name|found
operator|=
name|B_TRUE
expr_stmt|;
name|pd
operator|=
operator|*
name|pdp
expr_stmt|;
if|if
condition|(
name|gmatch
argument_list|(
name|provname
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
operator|!=
literal|0
operator|&&
name|dt_pid_create_pid_probes
argument_list|(
operator|&
name|pd
argument_list|,
name|dtp
argument_list|,
name|NULL
argument_list|,
name|dpr
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* 			 * If it's not strictly a pid provider, we might match 			 * a USDT provider. 			 */
if|if
condition|(
name|strcmp
argument_list|(
name|provname
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
operator|!=
literal|0
operator|&&
name|dt_pid_create_usdt_probes
argument_list|(
operator|&
name|pd
argument_list|,
name|dtp
argument_list|,
name|NULL
argument_list|,
name|dpr
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
comment|/* 		 * Give DTrace a shot to the ribs to get it to check 		 * out the newly created probes. 		 */
name|args
operator|.
name|dof
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|n_matched
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_ENABLE
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

