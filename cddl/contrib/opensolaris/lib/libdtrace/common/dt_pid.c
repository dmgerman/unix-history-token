begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_include
include|#
directive|include
file|<dt_program.h>
end_include

begin_include
include|#
directive|include
file|<dt_pid.h>
end_include

begin_include
include|#
directive|include
file|<dt_string.h>
end_include

begin_typedef
typedef|typedef
struct|struct
name|dt_pid_probe
block|{
name|dtrace_hdl_t
modifier|*
name|dpp_dtp
decl_stmt|;
name|dt_pcb_t
modifier|*
name|dpp_pcb
decl_stmt|;
name|dt_proc_t
modifier|*
name|dpp_dpr
decl_stmt|;
name|struct
name|ps_prochandle
modifier|*
name|dpp_pr
decl_stmt|;
specifier|const
name|char
modifier|*
name|dpp_mod
decl_stmt|;
name|char
modifier|*
name|dpp_func
decl_stmt|;
specifier|const
name|char
modifier|*
name|dpp_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|dpp_obj
decl_stmt|;
name|uintptr_t
name|dpp_pc
decl_stmt|;
name|size_t
name|dpp_size
decl_stmt|;
name|Lmid_t
name|dpp_lmid
decl_stmt|;
name|uint_t
name|dpp_nmatches
decl_stmt|;
name|uint64_t
name|dpp_stret
index|[
literal|4
index|]
decl_stmt|;
name|GElf_Sym
name|dpp_last
decl_stmt|;
name|uint_t
name|dpp_last_taken
decl_stmt|;
block|}
name|dt_pid_probe_t
typedef|;
end_typedef

begin_comment
comment|/*  * Compose the lmid and object name into the canonical representation. We  * omit the lmid for the default link map for convenience.  */
end_comment

begin_function
specifier|static
name|void
name|dt_pid_objname
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|Lmid_t
name|lmid
parameter_list|,
specifier|const
name|char
modifier|*
name|obj
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|lmid
operator|==
name|LM_ID_BASE
condition|)
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|obj
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"LM%lx`%s"
argument_list|,
name|lmid
argument_list|,
name|obj
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|obj
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|dt_pid_error
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_pcb_t
modifier|*
name|pcb
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|,
name|fasttrap_probe_spec_t
modifier|*
name|ftp
parameter_list|,
name|dt_errtag_t
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|ftp
operator|!=
name|NULL
condition|)
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|ftp
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|dpr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|vsnprintf
argument_list|(
name|dpr
operator|->
name|dpr_errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|dpr
operator|->
name|dpr_errmsg
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|len
operator|>=
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpr
operator|->
name|dpr_errmsg
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|dpr
operator|->
name|dpr_errmsg
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|dt_set_errmsg
argument_list|(
name|dtp
argument_list|,
name|dt_errtag
argument_list|(
name|tag
argument_list|)
argument_list|,
name|pcb
operator|->
name|pcb_region
argument_list|,
name|pcb
operator|->
name|pcb_filetag
argument_list|,
name|pcb
operator|->
name|pcb_fileptr
condition|?
name|yylineno
else|:
literal|0
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_pid_per_sym
parameter_list|(
name|dt_pid_probe_t
modifier|*
name|pp
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|symp
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|pp
operator|->
name|dpp_dtp
decl_stmt|;
name|dt_pcb_t
modifier|*
name|pcb
init|=
name|pp
operator|->
name|dpp_pcb
decl_stmt|;
name|dt_proc_t
modifier|*
name|dpr
init|=
name|pp
operator|->
name|dpp_dpr
decl_stmt|;
name|fasttrap_probe_spec_t
modifier|*
name|ftp
decl_stmt|;
name|uint64_t
name|off
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|uint_t
name|nmatches
init|=
literal|0
decl_stmt|;
name|ulong_t
name|sz
decl_stmt|;
name|int
name|glob
decl_stmt|,
name|err
decl_stmt|;
name|int
name|isdash
init|=
name|strcmp
argument_list|(
literal|"-"
argument_list|,
name|func
argument_list|)
operator|==
literal|0
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|pid
operator|=
name|Pstatus
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|)
operator|->
name|pr_pid
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|proc_getpid
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dt_dprintf
argument_list|(
literal|"creating probe pid%d:%s:%s:%s\n"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|,
name|pp
operator|->
name|dpp_obj
argument_list|,
name|func
argument_list|,
name|pp
operator|->
name|dpp_name
argument_list|)
expr_stmt|;
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|fasttrap_probe_spec_t
argument_list|)
operator|+
operator|(
name|isdash
condition|?
literal|4
else|:
operator|(
name|symp
operator|->
name|st_size
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ftp
operator|->
name|ftps_offs
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ftp
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|sz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"proc_per_sym: dt_alloc(%lu) failed\n"
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* errno is set for us */
block|}
name|ftp
operator|->
name|ftps_pid
operator|=
name|pid
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ftp
operator|->
name|ftps_func
argument_list|,
name|func
argument_list|,
sizeof|sizeof
argument_list|(
name|ftp
operator|->
name|ftps_func
argument_list|)
argument_list|)
expr_stmt|;
name|dt_pid_objname
argument_list|(
name|ftp
operator|->
name|ftps_mod
argument_list|,
sizeof|sizeof
argument_list|(
name|ftp
operator|->
name|ftps_mod
argument_list|)
argument_list|,
name|pp
operator|->
name|dpp_lmid
argument_list|,
name|pp
operator|->
name|dpp_obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdash
operator|&&
name|gmatch
argument_list|(
literal|"return"
argument_list|,
name|pp
operator|->
name|dpp_name
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DOODAD
if|if
condition|(
name|dt_pid_create_return_probe
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|dtp
argument_list|,
name|ftp
argument_list|,
name|symp
argument_list|,
name|pp
operator|->
name|dpp_stret
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|ftp
argument_list|,
name|D_PROC_CREATEFAIL
argument_list|,
literal|"failed to create return probe "
literal|"for '%s': %s"
argument_list|,
name|func
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
name|nmatches
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdash
operator|&&
name|gmatch
argument_list|(
literal|"entry"
argument_list|,
name|pp
operator|->
name|dpp_name
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DOODAD
if|if
condition|(
name|dt_pid_create_entry_probe
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|dtp
argument_list|,
name|ftp
argument_list|,
name|symp
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|ftp
argument_list|,
name|D_PROC_CREATEFAIL
argument_list|,
literal|"failed to create entry probe "
literal|"for '%s': %s"
argument_list|,
name|func
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
name|nmatches
operator|++
expr_stmt|;
block|}
name|glob
operator|=
name|strisglob
argument_list|(
name|pp
operator|->
name|dpp_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glob
operator|&&
name|nmatches
operator|==
literal|0
condition|)
block|{
name|off
operator|=
name|strtoull
argument_list|(
name|pp
operator|->
name|dpp_name
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|ftp
argument_list|,
name|D_PROC_NAME
argument_list|,
literal|"'%s' is an invalid probe name"
argument_list|,
name|pp
operator|->
name|dpp_name
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|off
operator|>=
name|symp
operator|->
name|st_size
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|ftp
argument_list|,
name|D_PROC_OFF
argument_list|,
literal|"offset 0x%llx outside of function '%s'"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|off
argument_list|,
name|func
argument_list|)
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DOODAD
name|err
operator|=
name|dt_pid_create_offset_probe
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pp
operator|->
name|dpp_dtp
argument_list|,
name|ftp
argument_list|,
name|symp
argument_list|,
name|off
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err
operator|==
name|DT_PROC_ERR
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|ftp
argument_list|,
name|D_PROC_CREATEFAIL
argument_list|,
literal|"failed to create probe at "
literal|"'%s+0x%llx': %s"
argument_list|,
name|func
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|off
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|err
operator|==
name|DT_PROC_ALIGN
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|ftp
argument_list|,
name|D_PROC_ALIGN
argument_list|,
literal|"offset 0x%llx is not aligned on an instruction"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|off
argument_list|)
operator|)
return|;
block|}
name|nmatches
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|glob
operator|&&
operator|!
name|isdash
condition|)
block|{
ifdef|#
directive|ifdef
name|DOODAD
if|if
condition|(
name|dt_pid_create_glob_offset_probes
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pp
operator|->
name|dpp_dtp
argument_list|,
name|ftp
argument_list|,
name|symp
argument_list|,
name|pp
operator|->
name|dpp_name
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|ftp
argument_list|,
name|D_PROC_CREATEFAIL
argument_list|,
literal|"failed to create offset probes in '%s': %s"
argument_list|,
name|func
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
name|nmatches
operator|++
expr_stmt|;
block|}
name|pp
operator|->
name|dpp_nmatches
operator|+=
name|nmatches
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|ftp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_pid_sym_filt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|symp
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|dt_pid_probe_t
modifier|*
name|pp
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|symp
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|symp
operator|->
name|st_size
operator|==
literal|0
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"st_size of %s is zero\n"
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pp
operator|->
name|dpp_last_taken
operator|==
literal|0
operator|||
name|symp
operator|->
name|st_value
operator|!=
name|pp
operator|->
name|dpp_last
operator|.
name|st_value
operator|||
name|symp
operator|->
name|st_size
operator|!=
name|pp
operator|->
name|dpp_last
operator|.
name|st_size
condition|)
block|{
comment|/* 		 * Due to 4524008, _init and _fini may have a bloated st_size. 		 * While this bug has been fixed for a while, old binaries 		 * may exist that still exhibit this problem. As a result, we 		 * don't match _init and _fini though we allow users to 		 * specify them explicitly. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|func
argument_list|,
literal|"_init"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|func
argument_list|,
literal|"_fini"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|pp
operator|->
name|dpp_last_taken
operator|=
name|gmatch
argument_list|(
name|func
argument_list|,
name|pp
operator|->
name|dpp_func
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|pp
operator|->
name|dpp_last
operator|=
operator|*
name|symp
expr_stmt|;
return|return
operator|(
name|dt_pid_per_sym
argument_list|(
name|pp
argument_list|,
name|symp
argument_list|,
name|func
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_pid_per_mod
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|prmap_t
modifier|*
name|pmp
parameter_list|,
specifier|const
name|char
modifier|*
name|obj
parameter_list|)
block|{
name|dt_pid_probe_t
modifier|*
name|pp
init|=
name|arg
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|pp
operator|->
name|dpp_dtp
decl_stmt|;
name|dt_pcb_t
modifier|*
name|pcb
init|=
name|pp
operator|->
name|dpp_pcb
decl_stmt|;
name|dt_proc_t
modifier|*
name|dpr
init|=
name|pp
operator|->
name|dpp_dpr
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|(
name|void
operator|)
name|Plmid
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pmp
operator|->
name|pr_vaddr
argument_list|,
operator|&
name|pp
operator|->
name|dpp_lmid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|pp
operator|->
name|dpp_obj
operator|=
name|strrchr
argument_list|(
name|obj
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|pp
operator|->
name|dpp_obj
operator|=
name|obj
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_obj
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|Pxlookup_by_name
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pp
operator|->
name|dpp_lmid
argument_list|,
name|obj
argument_list|,
literal|".stret1"
argument_list|,
operator|&
name|sym
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|pp
operator|->
name|dpp_stret
index|[
literal|0
index|]
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_stret
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Pxlookup_by_name
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pp
operator|->
name|dpp_lmid
argument_list|,
name|obj
argument_list|,
literal|".stret2"
argument_list|,
operator|&
name|sym
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|pp
operator|->
name|dpp_stret
index|[
literal|1
index|]
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_stret
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Pxlookup_by_name
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pp
operator|->
name|dpp_lmid
argument_list|,
name|obj
argument_list|,
literal|".stret4"
argument_list|,
operator|&
name|sym
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|pp
operator|->
name|dpp_stret
index|[
literal|2
index|]
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_stret
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Pxlookup_by_name
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pp
operator|->
name|dpp_lmid
argument_list|,
name|obj
argument_list|,
literal|".stret8"
argument_list|,
operator|&
name|sym
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|pp
operator|->
name|dpp_stret
index|[
literal|3
index|]
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_stret
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|proc_name2sym
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|obj
argument_list|,
literal|".stret1"
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
literal|0
condition|)
name|pp
operator|->
name|dpp_stret
index|[
literal|0
index|]
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_stret
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|proc_name2sym
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|obj
argument_list|,
literal|".stret2"
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
literal|0
condition|)
name|pp
operator|->
name|dpp_stret
index|[
literal|1
index|]
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_stret
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|proc_name2sym
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|obj
argument_list|,
literal|".stret4"
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
literal|0
condition|)
name|pp
operator|->
name|dpp_stret
index|[
literal|2
index|]
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_stret
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|proc_name2sym
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|obj
argument_list|,
literal|".stret8"
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
literal|0
condition|)
name|pp
operator|->
name|dpp_stret
index|[
literal|3
index|]
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
else|else
name|pp
operator|->
name|dpp_stret
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|dt_dprintf
argument_list|(
literal|"%s stret %llx %llx %llx %llx\n"
argument_list|,
name|obj
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|pp
operator|->
name|dpp_stret
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|pp
operator|->
name|dpp_stret
index|[
literal|1
index|]
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|pp
operator|->
name|dpp_stret
index|[
literal|2
index|]
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|pp
operator|->
name|dpp_stret
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * If pp->dpp_func contains any globbing meta-characters, we need 	 * to iterate over the symbol table and compare each function name 	 * against the pattern. 	 */
if|if
condition|(
operator|!
name|strisglob
argument_list|(
name|pp
operator|->
name|dpp_func
argument_list|)
condition|)
block|{
comment|/* 		 * If we fail to lookup the symbol, try interpreting the 		 * function as the special "-" function that indicates that the 		 * probe name should be interpreted as a absolute virtual 		 * address. If that fails and we were matching a specific 		 * function in a specific module, report the error, otherwise 		 * just fail silently in the hopes that some other object will 		 * contain the desired symbol. 		 */
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|Pxlookup_by_name
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|pp
operator|->
name|dpp_lmid
argument_list|,
name|obj
argument_list|,
name|pp
operator|->
name|dpp_func
argument_list|,
operator|&
name|sym
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|proc_name2sym
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|obj
argument_list|,
name|pp
operator|->
name|dpp_func
argument_list|,
operator|&
name|sym
argument_list|)
operator|!=
literal|0
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
literal|"-"
argument_list|,
name|pp
operator|->
name|dpp_func
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|GELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|sym
operator|.
name|st_size
operator|=
name|Pstatus
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|)
operator|->
name|pr_dmodel
operator|==
name|PR_MODEL_ILP32
condition|?
operator|-
literal|1U
else|:
operator|-
literal|1ULL
expr_stmt|;
else|#
directive|else
name|sym
operator|.
name|st_size
operator|=
operator|~
operator|(
operator|(
name|Elf64_Xword
operator|)
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|strisglob
argument_list|(
name|pp
operator|->
name|dpp_mod
argument_list|)
condition|)
block|{
return|return
operator|(
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|NULL
argument_list|,
name|D_PROC_FUNC
argument_list|,
literal|"failed to lookup '%s' in module '%s'"
argument_list|,
name|pp
operator|->
name|dpp_func
argument_list|,
name|pp
operator|->
name|dpp_mod
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 		 * Only match defined functions of non-zero size. 		 */
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
operator|||
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
operator|||
name|sym
operator|.
name|st_size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * We don't instrument PLTs -- they're dynamically rewritten, 		 * and, so, inherently dicey to instrument. 		 */
ifdef|#
directive|ifdef
name|DOODAD
if|if
condition|(
name|Ppltdest
argument_list|(
name|pp
operator|->
name|dpp_pr
argument_list|,
name|sym
operator|.
name|st_value
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|(
name|void
operator|)
name|Plookup_by_addr
argument_list|(
argument|pp->dpp_pr
argument_list|,
argument|sym.st_value
argument_list|,
argument|pp->dpp_func
argument_list|,
else|#
directive|else
argument|(void) proc_addr2sym(pp->dpp_pr, sym.st_value, pp->dpp_func,
endif|#
directive|endif
argument|DTRACE_FUNCNAMELEN,&sym);  		return (dt_pid_per_sym(pp,&sym, pp->dpp_func)); 	} else {
ifdef|#
directive|ifdef
name|DOODAD
argument|uint_t nmatches = pp->dpp_nmatches;  		if (Psymbol_iter_by_addr(pp->dpp_pr, obj, PR_SYMTAB, 		    BIND_ANY | TYPE_FUNC, dt_pid_sym_filt, pp) ==
literal|1
argument|) 			return (
literal|1
argument|);  		if (nmatches == pp->dpp_nmatches) {
comment|/* 			 * If we didn't match anything in the PR_SYMTAB, try 			 * the PR_DYNSYM. 			 */
argument|if (Psymbol_iter_by_addr(pp->dpp_pr, obj, PR_DYNSYM, 			    BIND_ANY | TYPE_FUNC, dt_pid_sym_filt, pp) ==
literal|1
argument|) 				return (
literal|1
argument|); 		}
endif|#
directive|endif
argument|}  	return (
literal|0
argument|); }  static int dt_pid_mod_filt(void *arg, const prmap_t *pmp, const char *obj) { 	char name[DTRACE_MODNAMELEN]; 	dt_pid_probe_t *pp = arg;  	if (gmatch(obj, pp->dpp_mod)) 		return (dt_pid_per_mod(pp, pmp, obj));
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
argument|(void) Plmid(pp->dpp_pr, pmp->pr_vaddr,&pp->dpp_lmid);
else|#
directive|else
argument|pp->dpp_lmid =
literal|0
argument|;
endif|#
directive|endif
argument|if ((pp->dpp_obj = strrchr(obj,
literal|'/'
argument|)) == NULL) 		pp->dpp_obj = obj; 	else 		pp->dpp_obj++;  	dt_pid_objname(name, sizeof (name), pp->dpp_lmid, obj);  	if (gmatch(name, pp->dpp_mod)) 		return (dt_pid_per_mod(pp, pmp, obj));  	return (
literal|0
argument|); }  static const prmap_t * dt_pid_fix_mod(dtrace_probedesc_t *pdp, struct ps_prochandle *P) {
ifdef|#
directive|ifdef
name|DOODAD
argument|char m[MAXPATHLEN]; 	Lmid_t lmid = PR_LMID_EVERY; 	const char *obj;
endif|#
directive|endif
argument|const prmap_t *pmp;
ifdef|#
directive|ifdef
name|DOODAD
comment|/* 	 * Pick apart the link map from the library name. 	 */
argument|if (strchr(pdp->dtpd_mod,
literal|'`'
argument|) != NULL) { 		char *end;  		if (strncmp(pdp->dtpd_mod,
literal|"LM"
argument|,
literal|2
argument|) !=
literal|0
argument||| 		    !isdigit(pdp->dtpd_mod[
literal|2
argument|])) 			return (NULL);  		lmid = strtoul(&pdp->dtpd_mod[
literal|2
argument|],&end,
literal|16
argument|);  		obj = end +
literal|1
argument|;  		if (*end !=
literal|'`'
argument||| strchr(obj,
literal|'`'
argument|) != NULL) 			return (NULL);  	} else { 		obj = pdp->dtpd_mod; 	}  	if ((pmp = Plmid_to_map(P, lmid, obj)) == NULL) 		return (NULL);  	(void) Pobjname(P, pmp->pr_vaddr, m, sizeof (m)); 	if ((obj = strrchr(m,
literal|'/'
argument|)) == NULL) 		obj =&m[
literal|0
argument|]; 	else 		obj++;  	(void) Plmid(P, pmp->pr_vaddr,&lmid);  	dt_pid_objname(pdp->dtpd_mod, sizeof (pdp->dtpd_mod), lmid, obj);
else|#
directive|else
argument|pmp = NULL;
endif|#
directive|endif
argument|return (pmp); }   static int dt_pid_create_pid_probes(dtrace_probedesc_t *pdp, dtrace_hdl_t *dtp,     dt_pcb_t *pcb, dt_proc_t *dpr) { 	dt_pid_probe_t pp; 	int ret =
literal|0
argument|;  	pp.dpp_dtp = dtp; 	pp.dpp_dpr = dpr; 	pp.dpp_pr = dpr->dpr_proc; 	pp.dpp_pcb = pcb;
ifdef|#
directive|ifdef
name|DOODAD
comment|/* 	 * We can only trace dynamically-linked executables (since we've 	 * hidden some magic in ld.so.1 as well as libc.so.1). 	 */
argument|if (Pname_to_map(pp.dpp_pr, PR_OBJ_LDSO) == NULL) { 		return (dt_pid_error(dtp, pcb, dpr, NULL, D_PROC_DYN,
literal|"process %s is not a dynamically-linked executable"
argument|,&pdp->dtpd_provider[
literal|3
argument|])); 	}
endif|#
directive|endif
argument|pp.dpp_mod = pdp->dtpd_mod[
literal|0
argument|] !=
literal|'\0'
argument|? pdp->dtpd_mod :
literal|"*"
argument|; 	pp.dpp_func = pdp->dtpd_func[
literal|0
argument|] !=
literal|'\0'
argument|? pdp->dtpd_func :
literal|"*"
argument|; 	pp.dpp_name = pdp->dtpd_name[
literal|0
argument|] !=
literal|'\0'
argument|? pdp->dtpd_name :
literal|"*"
argument|; 	pp.dpp_last_taken =
literal|0
argument|;  	if (strcmp(pp.dpp_func,
literal|"-"
argument|) ==
literal|0
argument|) { 		const prmap_t *aout
argument_list|,
argument|*pmp;  		if (pdp->dtpd_mod[
literal|0
argument|] ==
literal|'\0'
argument|) { 			pp.dpp_mod = pdp->dtpd_mod; 			(void) strcpy(pdp->dtpd_mod,
literal|"a.out"
argument|); 		} else if (strisglob(pp.dpp_mod) ||
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
argument|(aout = Pname_to_map(pp.dpp_pr,
literal|"a.out"
argument|)) == NULL || 		    (pmp = Pname_to_map(pp.dpp_pr, pp.dpp_mod)) == NULL ||
else|#
directive|else
argument|(aout = proc_name2map(pp.dpp_pr,
literal|"a.out"
argument|)) == NULL || 		    (pmp = proc_name2map(pp.dpp_pr, pp.dpp_mod)) == NULL ||
endif|#
directive|endif
argument|aout->pr_vaddr != pmp->pr_vaddr) { 			return (dt_pid_error(dtp, pcb, dpr, NULL, D_PROC_LIB,
literal|"only the a.out module is valid with the "
literal|"'-' function"
argument|)); 		}  		if (strisglob(pp.dpp_name)) { 			return (dt_pid_error(dtp, pcb, dpr, NULL, D_PROC_NAME,
literal|"only individual addresses may be specified "
literal|"with the '-' function"
argument|)); 		} 	}
comment|/* 	 * If pp.dpp_mod contains any globbing meta-characters, we need 	 * to iterate over each module and compare its name against the 	 * pattern. An empty module name is treated as '*'. 	 */
ifdef|#
directive|ifdef
name|DOODAD
argument|if (strisglob(pp.dpp_mod)) { 		ret = Pobject_iter(pp.dpp_pr, dt_pid_mod_filt,&pp); 	} else { 		const prmap_t *pmp; 		char *obj;
comment|/* 		 * If we can't find a matching module, don't sweat it -- either 		 * we'll fail the enabling because the probes don't exist or 		 * we'll wait for that module to come along. 		 */
argument|if ((pmp = dt_pid_fix_mod(pdp, pp.dpp_pr)) != NULL) { 			if ((obj = strchr(pdp->dtpd_mod,
literal|'`'
argument|)) == NULL) 				obj = pdp->dtpd_mod; 			else 				obj++;  			ret = dt_pid_per_mod(&pp, pmp, obj); 		} 	}
endif|#
directive|endif
argument|return (ret); }  static int dt_pid_usdt_mapping(void *data, const prmap_t *pmp, const char *oname) { 	struct ps_prochandle *P = data; 	GElf_Sym sym;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
argument|prsyminfo_t sip;
endif|#
directive|endif
argument|dof_helper_t dh; 	GElf_Half e_type; 	const char *mname; 	const char *syms[] = {
literal|"___SUNW_dof"
argument_list|,
literal|"__SUNW_dof"
argument|}; 	int i
argument_list|,
argument|fd = -
literal|1
argument|;
comment|/* 	 * The symbol ___SUNW_dof is for lazy-loaded DOF sections, and 	 * __SUNW_dof is for actively-loaded DOF sections. We try to force 	 * in both types of DOF section since the process may not yet have 	 * run the code to instantiate these providers. 	 */
argument|for (i =
literal|0
argument|; i<
literal|2
argument|; i++) {
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
argument|if (Pxlookup_by_name(P, PR_LMID_EVERY, oname, syms[i],&sym,&sip) !=
literal|0
argument|) {
else|#
directive|else
argument|if (proc_name2sym(P, oname, syms[i],&sym) !=
literal|0
argument|) {
endif|#
directive|endif
argument|continue; 		}  		if ((mname = strrchr(oname,
literal|'/'
argument|)) == NULL) 			mname = oname; 		else 			mname++;  		dt_dprintf(
literal|"lookup of %s succeeded for %s\n"
argument|, syms[i], mname);
ifdef|#
directive|ifdef
name|DOODAD
argument|if (Pread(P,&e_type, sizeof (e_type), pmp->pr_vaddr + 		    offsetof(Elf64_Ehdr, e_type)) != sizeof (e_type)) { 			dt_dprintf(
literal|"read of ELF header failed"
argument|); 			continue; 		}
endif|#
directive|endif
argument|dh.dofhp_dof = sym.st_value; 		dh.dofhp_addr = (e_type == ET_EXEC) ?
literal|0
argument|: pmp->pr_vaddr;  		dt_pid_objname(dh.dofhp_mod, sizeof (dh.dofhp_mod),
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
argument|sip.prs_lmid, mname);
else|#
directive|else
literal|0
argument_list|,
argument|mname
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DOODAD
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
operator|&&
operator|(
name|fd
operator|=
name|pr_open
argument_list|(
name|P
argument_list|,
literal|"/dev/dtrace/helper"
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"pr_open of helper device failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
block|}
if|if
condition|(
name|pr_ioctl
argument_list|(
name|P
argument_list|,
name|fd
argument_list|,
name|DTRACEHIOC_ADDDOF
argument_list|,
operator|&
name|dh
argument_list|,
sizeof|sizeof
argument_list|(
name|dh
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|dt_dprintf
argument_list|(
literal|"DOF was rejected for %s\n"
argument_list|,
name|dh
operator|.
name|dofhp_mod
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DOODAD
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|pr_close
argument_list|(
name|P
argument_list|,
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|dt_pid_create_usdt_probes
parameter_list|(
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_pcb_t
modifier|*
name|pcb
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|)
block|{
name|struct
name|ps_prochandle
modifier|*
name|P
init|=
name|dpr
operator|->
name|dpr_proc
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|DT_MUTEX_HELD
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOODAD
operator|(
name|void
operator|)
name|Pupdate_maps
argument_list|(
name|P
argument_list|)
expr_stmt|;
if|if
condition|(
name|Pobject_iter
argument_list|(
name|P
argument_list|,
name|dt_pid_usdt_mapping
argument_list|,
name|P
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|NULL
argument_list|,
name|D_PROC_USDT
argument_list|,
literal|"failed to instantiate probes for pid %d: %s"
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|(
name|int
operator|)
name|Pstatus
argument_list|(
name|P
argument_list|)
operator|->
name|pr_pid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|int
operator|)
name|proc_getpid
argument_list|(
name|P
argument_list|)
operator|,
name|strerror
argument_list|(
name|errno
argument_list|)
block|)
empty_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* 	 * Put the module name in its canonical form. 	 */
operator|(
name|void
operator|)
name|dt_pid_fix_mod
argument_list|(
name|pdp
argument_list|,
name|P
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|pid_t
name|dt_pid_get_pid
parameter_list|(
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_pcb_t
modifier|*
name|pcb
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|,
modifier|*
name|last
init|=
name|NULL
decl_stmt|,
modifier|*
name|end
decl_stmt|;
for|for
control|(
name|c
operator|=
operator|&
name|pdp
operator|->
name|dtpd_provider
index|[
literal|0
index|]
init|;
operator|*
name|c
operator|!=
literal|'\0'
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|c
argument_list|)
condition|)
name|last
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|==
name|NULL
operator|||
operator|(
operator|*
operator|(
operator|++
name|last
operator|)
operator|==
literal|'\0'
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|NULL
argument_list|,
name|D_PROC_BADPROV
argument_list|,
literal|"'%s' is not a valid provider"
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|pid
operator|=
name|strtol
argument_list|(
name|last
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
name|end
operator|==
name|last
operator|||
name|end
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|pid
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|,
name|NULL
argument_list|,
name|D_PROC_BADPID
argument_list|,
literal|"'%s' does not contain a valid pid"
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|pid
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_pid_create_probes
parameter_list|(
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_pcb_t
modifier|*
name|pcb
parameter_list|)
block|{
name|char
name|provname
index|[
name|DTRACE_PROVNAMELEN
index|]
decl_stmt|;
name|struct
name|ps_prochandle
modifier|*
name|P
decl_stmt|;
name|dt_proc_t
modifier|*
name|dpr
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|pcb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|dt_pid_get_pid
argument_list|(
name|pdp
argument_list|,
name|dtp
argument_list|,
name|pcb
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dtp
operator|->
name|dt_ftfd
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|dtp
operator|->
name|dt_fterr
operator|==
name|ENOENT
condition|)
block|{
operator|(
name|void
operator|)
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|D_PROC_NODEV
argument_list|,
literal|"pid provider is not installed on this system"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|D_PROC_NODEV
argument_list|,
literal|"pid provider is not available: %s"
argument_list|,
name|strerror
argument_list|(
name|dtp
operator|->
name|dt_fterr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|provname
argument_list|,
sizeof|sizeof
argument_list|(
name|provname
argument_list|)
argument_list|,
literal|"pid%d"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmatch
argument_list|(
name|provname
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|P
operator|=
name|dt_proc_grab
argument_list|(
name|dtp
argument_list|,
name|pid
argument_list|,
name|PGRAB_RDONLY
operator||
name|PGRAB_FORCE
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|D_PROC_GRAB
argument_list|,
literal|"failed to grab process %d"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dpr
operator|=
name|dt_proc_lookup
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dpr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|dt_pid_create_pid_probes
argument_list|(
name|pdp
argument_list|,
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Alert other retained enablings which may match 			 * against the newly created probes. 			 */
operator|(
name|void
operator|)
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_ENABLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If it's not strictly a pid provider, we might match a USDT provider. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|provname
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|P
operator|=
name|dt_proc_grab
argument_list|(
name|dtp
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|dt_pid_error
argument_list|(
name|dtp
argument_list|,
name|pcb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|D_PROC_GRAB
argument_list|,
literal|"failed to grab process %d"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dpr
operator|=
name|dt_proc_lookup
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dpr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dpr
operator|->
name|dpr_usdt
condition|)
block|{
name|err
operator|=
name|dt_pid_create_usdt_probes
argument_list|(
name|pdp
argument_list|,
name|dtp
argument_list|,
name|pcb
argument_list|,
name|dpr
argument_list|)
expr_stmt|;
name|dpr
operator|->
name|dpr_usdt
operator|=
name|B_TRUE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_pid_create_probes_module
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|)
block|{
name|dtrace_enable_io_t
name|args
decl_stmt|;
name|dtrace_prog_t
modifier|*
name|pgp
decl_stmt|;
name|dt_stmt_t
modifier|*
name|stp
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
name|pdp
decl_stmt|,
name|pd
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|found
init|=
name|B_FALSE
decl_stmt|;
name|char
name|provname
index|[
name|DTRACE_PROVNAMELEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|provname
argument_list|,
sizeof|sizeof
argument_list|(
name|provname
argument_list|)
argument_list|,
literal|"pid%d"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|)
expr_stmt|;
for|for
control|(
name|pgp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_programs
argument_list|)
init|;
name|pgp
operator|!=
name|NULL
condition|;
name|pgp
operator|=
name|dt_list_next
argument_list|(
name|pgp
argument_list|)
control|)
block|{
for|for
control|(
name|stp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|pgp
operator|->
name|dp_stmts
argument_list|)
init|;
name|stp
operator|!=
name|NULL
condition|;
name|stp
operator|=
name|dt_list_next
argument_list|(
name|stp
argument_list|)
control|)
block|{
name|pdp
operator|=
operator|&
name|stp
operator|->
name|ds_desc
operator|->
name|dtsd_ecbdesc
operator|->
name|dted_probe
expr_stmt|;
name|pid
operator|=
name|dt_pid_get_pid
argument_list|(
name|pdp
argument_list|,
name|dtp
argument_list|,
name|NULL
argument_list|,
name|dpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
name|dpr
operator|->
name|dpr_pid
condition|)
continue|continue;
name|found
operator|=
name|B_TRUE
expr_stmt|;
name|pd
operator|=
operator|*
name|pdp
expr_stmt|;
if|if
condition|(
name|gmatch
argument_list|(
name|provname
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
operator|!=
literal|0
operator|&&
name|dt_pid_create_pid_probes
argument_list|(
operator|&
name|pd
argument_list|,
name|dtp
argument_list|,
name|NULL
argument_list|,
name|dpr
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* 			 * If it's not strictly a pid provider, we might match 			 * a USDT provider. 			 */
if|if
condition|(
name|strcmp
argument_list|(
name|provname
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|)
operator|!=
literal|0
operator|&&
name|dt_pid_create_usdt_probes
argument_list|(
operator|&
name|pd
argument_list|,
name|dtp
argument_list|,
name|NULL
argument_list|,
name|dpr
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
comment|/* 		 * Give DTrace a shot to the ribs to get it to check 		 * out the newly created probes. 		 */
name|args
operator|.
name|dof
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|n_matched
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_ENABLE
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

