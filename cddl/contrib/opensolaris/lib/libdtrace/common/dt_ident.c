begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  * Copyright (c) 2013 by Delphix. All rights reserved.  * Copyright (c) 2013 Joyent, Inc. All rights reserved.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<sys/procfs_isa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<dt_ident.h>
end_include

begin_include
include|#
directive|include
file|<dt_parser.h>
end_include

begin_include
include|#
directive|include
file|<dt_provider.h>
end_include

begin_include
include|#
directive|include
file|<dt_strtab.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_comment
comment|/*  * Common code for cooking an identifier that uses a typed signature list (we  * use this for associative arrays and functions).  If the argument list is  * of the same length and types, then return the return type.  Otherwise  * print an appropriate compiler error message and abort the compile.  */
end_comment

begin_function
specifier|static
name|void
name|dt_idcook_sign
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|int
name|argc
parameter_list|,
name|dt_node_t
modifier|*
name|args
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|)
block|{
name|dt_idsig_t
modifier|*
name|isp
init|=
name|idp
operator|->
name|di_data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|compat
decl_stmt|,
name|mismatch
decl_stmt|,
name|arglimit
decl_stmt|,
name|iskey
decl_stmt|;
name|char
name|n1
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|char
name|n2
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|iskey
operator|=
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_ARRAY
operator|||
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_AGG
expr_stmt|;
if|if
condition|(
name|isp
operator|->
name|dis_varargs
operator|>=
literal|0
condition|)
block|{
name|mismatch
operator|=
name|argc
operator|<
name|isp
operator|->
name|dis_varargs
expr_stmt|;
name|arglimit
operator|=
name|isp
operator|->
name|dis_varargs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isp
operator|->
name|dis_optargs
operator|>=
literal|0
condition|)
block|{
name|mismatch
operator|=
operator|(
name|argc
operator|<
name|isp
operator|->
name|dis_optargs
operator|||
name|argc
operator|>
name|isp
operator|->
name|dis_argc
operator|)
expr_stmt|;
name|arglimit
operator|=
name|argc
expr_stmt|;
block|}
else|else
block|{
name|mismatch
operator|=
name|argc
operator|!=
name|isp
operator|->
name|dis_argc
expr_stmt|;
name|arglimit
operator|=
name|isp
operator|->
name|dis_argc
expr_stmt|;
block|}
if|if
condition|(
name|mismatch
condition|)
block|{
name|xyerror
argument_list|(
name|D_PROTO_LEN
argument_list|,
literal|"%s%s%s prototype mismatch: %d %s%s"
literal|"passed, %s%d expected\n"
argument_list|,
name|prefix
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|suffix
argument_list|,
name|argc
argument_list|,
name|iskey
condition|?
literal|"key"
else|:
literal|"arg"
argument_list|,
name|argc
operator|==
literal|1
condition|?
literal|" "
else|:
literal|"s "
argument_list|,
name|isp
operator|->
name|dis_optargs
operator|>=
literal|0
condition|?
literal|"at least "
else|:
literal|""
argument_list|,
name|isp
operator|->
name|dis_optargs
operator|>=
literal|0
condition|?
name|isp
operator|->
name|dis_optargs
else|:
name|arglimit
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arglimit
condition|;
name|i
operator|++
operator|,
name|args
operator|=
name|args
operator|->
name|dn_list
control|)
block|{
if|if
condition|(
name|isp
operator|->
name|dis_args
index|[
name|i
index|]
operator|.
name|dn_ctfp
operator|!=
name|NULL
condition|)
name|compat
operator|=
name|dt_node_is_argcompat
argument_list|(
operator|&
name|isp
operator|->
name|dis_args
index|[
name|i
index|]
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|compat
operator|=
literal|1
expr_stmt|;
comment|/* "@" matches any type */
if|if
condition|(
operator|!
name|compat
condition|)
block|{
name|xyerror
argument_list|(
name|D_PROTO_ARG
argument_list|,
literal|"%s%s%s %s #%d is incompatible with "
literal|"prototype:\n\tprototype: %s\n\t%9s: %s\n"
argument_list|,
name|prefix
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|suffix
argument_list|,
name|iskey
condition|?
literal|"key"
else|:
literal|"argument"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|dt_node_type_name
argument_list|(
operator|&
name|isp
operator|->
name|dis_args
index|[
name|i
index|]
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|iskey
condition|?
literal|"key"
else|:
literal|"argument"
argument_list|,
name|dt_node_type_name
argument_list|(
name|args
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|idp
operator|->
name|di_ctfp
argument_list|,
name|idp
operator|->
name|di_type
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cook an associative array identifier.  If this is the first time we are  * cooking this array, create its signature based on the argument list.  * Otherwise validate the argument list against the existing signature.  */
end_comment

begin_function
specifier|static
name|void
name|dt_idcook_assc
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|int
name|argc
parameter_list|,
name|dt_node_t
modifier|*
name|args
parameter_list|)
block|{
if|if
condition|(
name|idp
operator|->
name|di_data
operator|==
name|NULL
condition|)
block|{
name|dt_idsig_t
modifier|*
name|isp
init|=
name|idp
operator|->
name|di_data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_idsig_t
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|isp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|isp
operator|->
name|dis_varargs
operator|=
operator|-
literal|1
expr_stmt|;
name|isp
operator|->
name|dis_optargs
operator|=
operator|-
literal|1
expr_stmt|;
name|isp
operator|->
name|dis_argc
operator|=
name|argc
expr_stmt|;
name|isp
operator|->
name|dis_args
operator|=
name|NULL
expr_stmt|;
name|isp
operator|->
name|dis_auxinfo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|0
operator|&&
operator|(
name|isp
operator|->
name|dis_args
operator|=
name|calloc
argument_list|(
name|argc
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_node_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|idp
operator|->
name|di_data
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If this identifier has not been explicitly declared earlier, 		 * set the identifier's base type to be our special type<DYN>. 		 * If this ident is an aggregation, it will remain as is.  If 		 * this ident is an associative array, it will be reassigned 		 * based on the result type of the first assignment statement. 		 */
if|if
condition|(
operator|!
operator|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_DECL
operator|)
condition|)
block|{
name|idp
operator|->
name|di_ctfp
operator|=
name|DT_DYN_CTFP
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
expr_stmt|;
name|idp
operator|->
name|di_type
operator|=
name|DT_DYN_TYPE
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
operator|,
name|args
operator|=
name|args
operator|->
name|dn_list
control|)
block|{
if|if
condition|(
name|dt_node_is_dynamic
argument_list|(
name|args
argument_list|)
operator|||
name|dt_node_is_void
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_KEY_TYPE
argument_list|,
literal|"%s expression may not be "
literal|"used as %s index: key #%d\n"
argument_list|,
name|dt_node_type_name
argument_list|(
name|args
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|,
name|dt_idkind_name
argument_list|(
name|idp
operator|->
name|di_kind
argument_list|)
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_propagate
argument_list|(
name|args
argument_list|,
operator|&
name|isp
operator|->
name|dis_args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isp
operator|->
name|dis_args
index|[
name|i
index|]
operator|.
name|dn_list
operator|=
operator|&
name|isp
operator|->
name|dis_args
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
name|isp
operator|->
name|dis_args
index|[
name|argc
operator|-
literal|1
index|]
operator|.
name|dn_list
operator|=
name|NULL
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|idp
operator|->
name|di_ctfp
argument_list|,
name|idp
operator|->
name|di_type
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dt_idcook_sign
argument_list|(
name|dnp
argument_list|,
name|idp
argument_list|,
name|argc
argument_list|,
name|args
argument_list|,
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_AGG
condition|?
literal|"@"
else|:
literal|""
argument_list|,
literal|"[ ]"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Cook a function call.  If this is the first time we are cooking this  * identifier, create its type signature based on predefined prototype stored  * in di_iarg.  We then validate the argument list against this signature.  */
end_comment

begin_function
specifier|static
name|void
name|dt_idcook_func
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|int
name|argc
parameter_list|,
name|dt_node_t
modifier|*
name|args
parameter_list|)
block|{
if|if
condition|(
name|idp
operator|->
name|di_data
operator|==
name|NULL
condition|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
name|dt_idsig_t
modifier|*
name|isp
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|idp
operator|->
name|di_iarg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|idp
operator|->
name|di_iarg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s
argument_list|,
name|idp
operator|->
name|di_iarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p2
operator|=
name|strrchr
argument_list|(
name|s
argument_list|,
literal|')'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p2
operator|=
literal|'\0'
expr_stmt|;
comment|/* mark end of parameter list string */
if|if
condition|(
operator|(
name|p1
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'('
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p1
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* mark end of return type string */
if|if
condition|(
name|p1
operator|==
name|NULL
operator|||
name|p2
operator|==
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"internal error: malformed entry "
literal|"for built-in function %s\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p2
operator|=
name|p1
init|;
operator|*
name|p2
operator|!=
literal|'\0'
condition|;
name|p2
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p2
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|p2
operator|=
name|strchr
argument_list|(
name|p2
argument_list|,
literal|','
argument_list|)
init|;
name|p2
operator|++
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|p2
operator|=
name|strchr
argument_list|(
name|p2
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* 		 * We first allocate a new ident signature structure with the 		 * appropriate number of argument entries, and then look up 		 * the return type and store its CTF data in di_ctfp/type. 		 */
if|if
condition|(
operator|(
name|isp
operator|=
name|idp
operator|->
name|di_data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_idsig_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|isp
operator|->
name|dis_varargs
operator|=
operator|-
literal|1
expr_stmt|;
name|isp
operator|->
name|dis_optargs
operator|=
operator|-
literal|1
expr_stmt|;
name|isp
operator|->
name|dis_argc
operator|=
name|i
expr_stmt|;
name|isp
operator|->
name|dis_args
operator|=
name|NULL
expr_stmt|;
name|isp
operator|->
name|dis_auxinfo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
operator|(
name|isp
operator|->
name|dis_args
operator|=
name|calloc
argument_list|(
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_node_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|idp
operator|->
name|di_data
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|isp
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_type_lookup
argument_list|(
name|s
argument_list|,
operator|&
name|dtt
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to resolve type of %s (%s):"
literal|" %s\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|s
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_AGGFUNC
condition|)
block|{
name|idp
operator|->
name|di_ctfp
operator|=
name|DT_DYN_CTFP
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|idp
operator|->
name|di_type
operator|=
name|DT_DYN_TYPE
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idp
operator|->
name|di_ctfp
operator|=
name|dtt
operator|.
name|dtt_ctfp
expr_stmt|;
name|idp
operator|->
name|di_type
operator|=
name|dtt
operator|.
name|dtt_type
expr_stmt|;
block|}
comment|/* 		 * For each comma-delimited parameter in the prototype string, 		 * we look up the corresponding type and store its CTF data in 		 * the corresponding location in dis_args[].  We also recognize 		 * the special type string "@" to indicate that the specified 		 * parameter may be a D expression of *any* type (represented 		 * as a dis_args[] element with ctfp = NULL, type == CTF_ERR). 		 * If a varargs "..." is present, we record the argument index 		 * in dis_varargs for the benefit of dt_idcook_sign(), above. 		 * If the type of an argument is enclosed in square brackets 		 * (e.g. "[int]"), the argument is considered optional:  the 		 * argument may be absent, but if it is present, it must be of 		 * the specified type.  Note that varargs may not optional, 		 * optional arguments may not follow varargs, and non-optional 		 * arguments may not follow optional arguments. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isp
operator|->
name|dis_argc
condition|;
name|i
operator|++
operator|,
name|p1
operator|=
name|p2
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p1
argument_list|)
condition|)
name|p1
operator|++
expr_stmt|;
comment|/* skip leading whitespace */
if|if
condition|(
operator|(
name|p2
operator|=
name|strchr
argument_list|(
name|p1
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p2
operator|=
name|p1
operator|+
name|strlen
argument_list|(
name|p1
argument_list|)
expr_stmt|;
else|else
operator|*
name|p2
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p1
argument_list|,
literal|"@"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|p1
argument_list|,
literal|"..."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isp
operator|->
name|dis_args
index|[
name|i
index|]
operator|.
name|dn_ctfp
operator|=
name|NULL
expr_stmt|;
name|isp
operator|->
name|dis_args
index|[
name|i
index|]
operator|.
name|dn_type
operator|=
name|CTF_ERR
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|==
literal|'.'
condition|)
name|isp
operator|->
name|dis_varargs
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|p1
operator|==
literal|'['
operator|&&
name|p1
index|[
name|strlen
argument_list|(
name|p1
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
block|{
if|if
condition|(
name|isp
operator|->
name|dis_varargs
operator|!=
operator|-
literal|1
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"optional arg#%d "
literal|"may not follow variable arg#%d\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|isp
operator|->
name|dis_varargs
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isp
operator|->
name|dis_optargs
operator|==
operator|-
literal|1
condition|)
name|isp
operator|->
name|dis_optargs
operator|=
name|i
expr_stmt|;
name|p1
index|[
name|strlen
argument_list|(
name|p1
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isp
operator|->
name|dis_optargs
operator|!=
operator|-
literal|1
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"required arg#%d may not "
literal|"follow optional arg#%d\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|isp
operator|->
name|dis_optargs
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_type_lookup
argument_list|(
name|p1
argument_list|,
operator|&
name|dtt
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to resolve type of "
literal|"%s arg#%d (%s): %s\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|p1
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_node_type_assign
argument_list|(
operator|&
name|isp
operator|->
name|dis_args
index|[
name|i
index|]
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|dt_idcook_sign
argument_list|(
name|dnp
argument_list|,
name|idp
argument_list|,
name|argc
argument_list|,
name|args
argument_list|,
literal|""
argument_list|,
literal|"( )"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cook a reference to the dynamically typed args[] array.  We verify that the  * reference is using a single integer constant, and then construct a new ident  * representing the appropriate type or translation specifically for this node.  */
end_comment

begin_function
specifier|static
name|void
name|dt_idcook_args
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|int
name|argc
parameter_list|,
name|dt_node_t
modifier|*
name|ap
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_probe_t
modifier|*
name|prp
init|=
name|yypcb
operator|->
name|pcb_probe
decl_stmt|;
name|dt_node_t
name|tag
decl_stmt|,
modifier|*
name|nnp
decl_stmt|,
modifier|*
name|xnp
decl_stmt|;
name|dt_xlator_t
modifier|*
name|dxp
decl_stmt|;
name|dt_ident_t
modifier|*
name|xidp
decl_stmt|;
name|char
name|n1
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|char
name|n2
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|xyerror
argument_list|(
name|D_PROTO_LEN
argument_list|,
literal|"%s[ ] prototype mismatch: %d arg%s"
literal|"passed, 1 expected\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|argc
argument_list|,
name|argc
operator|==
literal|1
condition|?
literal|" "
else|:
literal|"s "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|dn_kind
operator|!=
name|DT_NODE_INT
condition|)
block|{
name|xyerror
argument_list|(
name|D_PROTO_ARG
argument_list|,
literal|"%s[ ] argument #1 is incompatible with "
literal|"prototype:\n\tprototype: %s\n\t argument: %s\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
literal|"integer constant"
argument_list|,
name|dt_type_name
argument_list|(
name|ap
operator|->
name|dn_ctfp
argument_list|,
name|ap
operator|->
name|dn_type
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yypcb
operator|->
name|pcb_pdesc
operator|==
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_ARGS_NONE
argument_list|,
literal|"%s[ ] may not be referenced outside "
literal|"of a probe clause\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prp
operator|==
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_ARGS_MULTI
argument_list|,
literal|"%s[ ] may not be referenced because probe description %s "
literal|"matches an unstable set of probes\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|dtrace_desc2str
argument_list|(
name|yypcb
operator|->
name|pcb_pdesc
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|dn_value
operator|>=
name|prp
operator|->
name|pr_argc
condition|)
block|{
name|xyerror
argument_list|(
name|D_ARGS_IDX
argument_list|,
literal|"index %lld is out of range for %s %s[ ]\n"
argument_list|,
operator|(
name|longlong_t
operator|)
name|ap
operator|->
name|dn_value
argument_list|,
name|dtrace_desc2str
argument_list|(
name|yypcb
operator|->
name|pcb_pdesc
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|idp
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Look up the native and translated argument types for the probe. 	 * If no translation is needed, these will be the same underlying node. 	 * If translation is needed, look up the appropriate translator.  Once 	 * we have the appropriate node, create a new dt_ident_t for this node, 	 * assign it the appropriate attributes, and set the type of 'dnp'. 	 */
name|xnp
operator|=
name|prp
operator|->
name|pr_xargv
index|[
name|ap
operator|->
name|dn_value
index|]
expr_stmt|;
name|nnp
operator|=
name|prp
operator|->
name|pr_nargv
index|[
name|prp
operator|->
name|pr_mapping
index|[
name|ap
operator|->
name|dn_value
index|]
index|]
expr_stmt|;
if|if
condition|(
name|xnp
operator|->
name|dn_type
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_ARGS_TYPE
argument_list|,
literal|"failed to resolve translated type for "
literal|"%s[%lld]\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
operator|(
name|longlong_t
operator|)
name|ap
operator|->
name|dn_value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nnp
operator|->
name|dn_type
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_ARGS_TYPE
argument_list|,
literal|"failed to resolve native type for "
literal|"%s[%lld]\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
operator|(
name|longlong_t
operator|)
name|ap
operator|->
name|dn_value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dtp
operator|->
name|dt_xlatemode
operator|==
name|DT_XL_STATIC
operator|&&
operator|(
name|nnp
operator|==
name|xnp
operator|||
name|dt_node_is_argcompat
argument_list|(
name|nnp
argument_list|,
name|xnp
argument_list|)
operator|)
condition|)
block|{
name|dnp
operator|->
name|dn_ident
operator|=
name|dt_ident_create
argument_list|(
name|idp
operator|->
name|di_name
argument_list|,
name|idp
operator|->
name|di_kind
argument_list|,
name|idp
operator|->
name|di_flags
operator||
name|DT_IDFLG_ORPHAN
argument_list|,
name|idp
operator|->
name|di_id
argument_list|,
name|idp
operator|->
name|di_attr
argument_list|,
name|idp
operator|->
name|di_vers
argument_list|,
name|idp
operator|->
name|di_ops
argument_list|,
name|idp
operator|->
name|di_iarg
argument_list|,
name|idp
operator|->
name|di_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_ident
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|prp
operator|->
name|pr_argv
index|[
name|ap
operator|->
name|dn_value
index|]
operator|.
name|dtt_ctfp
argument_list|,
name|prp
operator|->
name|pr_argv
index|[
name|ap
operator|->
name|dn_value
index|]
operator|.
name|dtt_type
argument_list|,
name|prp
operator|->
name|pr_argv
index|[
name|ap
operator|->
name|dn_value
index|]
operator|.
name|dtt_flags
operator|&
name|DTT_FL_USER
condition|?
name|B_TRUE
else|:
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dxp
operator|=
name|dt_xlator_lookup
argument_list|(
name|dtp
argument_list|,
name|nnp
argument_list|,
name|xnp
argument_list|,
name|DT_XLATE_FUZZY
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|dxp
operator|=
name|dt_xlator_lookup
argument_list|(
name|dtp
argument_list|,
name|dt_probe_tag
argument_list|(
name|prp
argument_list|,
name|ap
operator|->
name|dn_value
argument_list|,
operator|&
name|tag
argument_list|)
argument_list|,
name|xnp
argument_list|,
name|DT_XLATE_EXACT
operator||
name|DT_XLATE_EXTERN
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|xidp
operator|=
name|dt_xlator_ident
argument_list|(
name|dxp
argument_list|,
name|xnp
operator|->
name|dn_ctfp
argument_list|,
name|xnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_ident
operator|=
name|dt_ident_create
argument_list|(
name|idp
operator|->
name|di_name
argument_list|,
name|xidp
operator|->
name|di_kind
argument_list|,
name|xidp
operator|->
name|di_flags
operator||
name|DT_IDFLG_ORPHAN
argument_list|,
name|idp
operator|->
name|di_id
argument_list|,
name|idp
operator|->
name|di_attr
argument_list|,
name|idp
operator|->
name|di_vers
argument_list|,
name|idp
operator|->
name|di_ops
argument_list|,
name|idp
operator|->
name|di_iarg
argument_list|,
name|idp
operator|->
name|di_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_ident
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_xlator_dynamic
argument_list|(
name|dxp
argument_list|)
condition|)
name|dxp
operator|->
name|dx_arg
operator|=
operator|(
name|int
operator|)
name|ap
operator|->
name|dn_value
expr_stmt|;
comment|/* 		 * Propagate relevant members from the translator's internal 		 * dt_ident_t.  This code must be kept in sync with the state 		 * that is initialized for idents in dt_xlator_create(). 		 */
name|dnp
operator|->
name|dn_ident
operator|->
name|di_data
operator|=
name|xidp
operator|->
name|di_data
expr_stmt|;
name|dnp
operator|->
name|dn_ident
operator|->
name|di_ctfp
operator|=
name|xidp
operator|->
name|di_ctfp
expr_stmt|;
name|dnp
operator|->
name|dn_ident
operator|->
name|di_type
operator|=
name|xidp
operator|->
name|di_type
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|DT_DYN_CTFP
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|DT_DYN_TYPE
argument_list|(
name|dtp
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xyerror
argument_list|(
name|D_ARGS_XLATOR
argument_list|,
literal|"translator for %s[%lld] from %s to %s "
literal|"is not defined\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
operator|(
name|longlong_t
operator|)
name|ap
operator|->
name|dn_value
argument_list|,
name|dt_node_type_name
argument_list|(
name|nnp
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|dt_node_type_name
argument_list|(
name|xnp
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator|&
name|DT_IDFLG_ORPHAN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
operator|==
name|idp
operator|->
name|di_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_idcook_regs
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|int
name|argc
parameter_list|,
name|dt_node_t
modifier|*
name|ap
parameter_list|)
block|{
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|xyerror
argument_list|(
name|D_PROTO_LEN
argument_list|,
literal|"%s[ ] prototype mismatch: %d arg%s"
literal|"passed, 1 expected\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|argc
argument_list|,
name|argc
operator|==
literal|1
condition|?
literal|" "
else|:
literal|"s "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|dn_kind
operator|!=
name|DT_NODE_INT
condition|)
block|{
name|xyerror
argument_list|(
name|D_PROTO_ARG
argument_list|,
literal|"%s[ ] argument #1 is incompatible with "
literal|"prototype:\n\tprototype: %s\n\t argument: %s\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
literal|"integer constant"
argument_list|,
name|dt_type_name
argument_list|(
name|ap
operator|->
name|dn_ctfp
argument_list|,
name|ap
operator|->
name|dn_type
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ap
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
operator|&&
operator|(
name|int64_t
operator|)
name|ap
operator|->
name|dn_value
operator|<
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_REGS_IDX
argument_list|,
literal|"index %lld is out of range for array %s\n"
argument_list|,
operator|(
name|longlong_t
operator|)
name|ap
operator|->
name|dn_value
argument_list|,
name|idp
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_type_lookup
argument_list|(
literal|"uint64_t"
argument_list|,
operator|&
name|dtt
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to resolve type of %s: %s\n"
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|idp
operator|->
name|di_ctfp
operator|=
name|dtt
operator|.
name|dtt_ctfp
expr_stmt|;
name|idp
operator|->
name|di_type
operator|=
name|dtt
operator|.
name|dtt_type
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|idp
operator|->
name|di_ctfp
argument_list|,
name|idp
operator|->
name|di_type
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dt_idcook_type
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|int
name|argc
parameter_list|,
name|dt_node_t
modifier|*
name|args
parameter_list|)
block|{
if|if
condition|(
name|idp
operator|->
name|di_type
operator|==
name|CTF_ERR
condition|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
if|if
condition|(
name|dt_type_lookup
argument_list|(
name|idp
operator|->
name|di_iarg
argument_list|,
operator|&
name|dtt
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to resolve type %s for identifier %s: %s\n"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|idp
operator|->
name|di_iarg
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|idp
operator|->
name|di_ctfp
operator|=
name|dtt
operator|.
name|dtt_ctfp
expr_stmt|;
name|idp
operator|->
name|di_type
operator|=
name|dtt
operator|.
name|dtt_type
expr_stmt|;
block|}
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|idp
operator|->
name|di_ctfp
argument_list|,
name|idp
operator|->
name|di_type
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dt_idcook_thaw
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|int
name|argc
parameter_list|,
name|dt_node_t
modifier|*
name|args
parameter_list|)
block|{
if|if
condition|(
name|idp
operator|->
name|di_ctfp
operator|!=
name|NULL
operator|&&
name|idp
operator|->
name|di_type
operator|!=
name|CTF_ERR
condition|)
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|idp
operator|->
name|di_ctfp
argument_list|,
name|idp
operator|->
name|di_type
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_idcook_inline
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|int
name|argc
parameter_list|,
name|dt_node_t
modifier|*
name|args
parameter_list|)
block|{
if|if
condition|(
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_ARRAY
condition|)
name|dt_idcook_assc
argument_list|(
name|dnp
argument_list|,
name|idp
argument_list|,
name|argc
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|dt_idcook_thaw
argument_list|(
name|dnp
argument_list|,
name|idp
argument_list|,
name|argc
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_iddtor_sign
parameter_list|(
name|dt_ident_t
modifier|*
name|idp
parameter_list|)
block|{
if|if
condition|(
name|idp
operator|->
name|di_data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
operator|(
name|dt_idsig_t
operator|*
operator|)
name|idp
operator|->
name|di_data
operator|)
operator|->
name|dis_args
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|idp
operator|->
name|di_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_iddtor_free
parameter_list|(
name|dt_ident_t
modifier|*
name|idp
parameter_list|)
block|{
name|free
argument_list|(
name|idp
operator|->
name|di_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_iddtor_inline
parameter_list|(
name|dt_ident_t
modifier|*
name|idp
parameter_list|)
block|{
name|dt_idnode_t
modifier|*
name|inp
init|=
name|idp
operator|->
name|di_iarg
decl_stmt|;
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
block|{
name|dt_node_link_free
argument_list|(
operator|&
name|inp
operator|->
name|din_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|din_hash
operator|!=
name|NULL
condition|)
name|dt_idhash_destroy
argument_list|(
name|inp
operator|->
name|din_hash
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inp
operator|->
name|din_argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_ARRAY
condition|)
name|dt_iddtor_sign
argument_list|(
name|idp
argument_list|)
expr_stmt|;
else|else
name|dt_iddtor_free
argument_list|(
name|idp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dt_iddtor_none
parameter_list|(
name|dt_ident_t
modifier|*
name|idp
parameter_list|)
block|{
comment|/* do nothing */
block|}
end_function

begin_function
specifier|static
name|void
name|dt_iddtor_probe
parameter_list|(
name|dt_ident_t
modifier|*
name|idp
parameter_list|)
block|{
if|if
condition|(
name|idp
operator|->
name|di_data
operator|!=
name|NULL
condition|)
name|dt_probe_destroy
argument_list|(
name|idp
operator|->
name|di_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|dt_idsize_type
parameter_list|(
name|dt_ident_t
modifier|*
name|idp
parameter_list|)
block|{
return|return
operator|(
name|ctf_type_size
argument_list|(
name|idp
operator|->
name|di_ctfp
argument_list|,
name|idp
operator|->
name|di_type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|size_t
name|dt_idsize_none
parameter_list|(
name|dt_ident_t
modifier|*
name|idp
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|dt_idops_t
name|dt_idops_assc
init|=
block|{
name|dt_idcook_assc
block|,
name|dt_iddtor_sign
block|,
name|dt_idsize_none
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|dt_idops_t
name|dt_idops_func
init|=
block|{
name|dt_idcook_func
block|,
name|dt_iddtor_sign
block|,
name|dt_idsize_none
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|dt_idops_t
name|dt_idops_args
init|=
block|{
name|dt_idcook_args
block|,
name|dt_iddtor_none
block|,
name|dt_idsize_none
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|dt_idops_t
name|dt_idops_regs
init|=
block|{
name|dt_idcook_regs
block|,
name|dt_iddtor_free
block|,
name|dt_idsize_none
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|dt_idops_t
name|dt_idops_type
init|=
block|{
name|dt_idcook_type
block|,
name|dt_iddtor_free
block|,
name|dt_idsize_type
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|dt_idops_t
name|dt_idops_thaw
init|=
block|{
name|dt_idcook_thaw
block|,
name|dt_iddtor_free
block|,
name|dt_idsize_type
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|dt_idops_t
name|dt_idops_inline
init|=
block|{
name|dt_idcook_inline
block|,
name|dt_iddtor_inline
block|,
name|dt_idsize_type
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|dt_idops_t
name|dt_idops_probe
init|=
block|{
name|dt_idcook_thaw
block|,
name|dt_iddtor_probe
block|,
name|dt_idsize_none
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dt_idhash_populate
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|)
block|{
specifier|const
name|dt_ident_t
modifier|*
name|idp
init|=
name|dhp
operator|->
name|dh_tmpl
decl_stmt|;
name|dhp
operator|->
name|dh_tmpl
operator|=
name|NULL
expr_stmt|;
comment|/* clear dh_tmpl first to avoid recursion */
name|dt_dprintf
argument_list|(
literal|"populating %s idhash from %p\n"
argument_list|,
name|dhp
operator|->
name|dh_name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|idp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|idp
operator|->
name|di_name
operator|!=
name|NULL
condition|;
name|idp
operator|++
control|)
block|{
if|if
condition|(
name|dt_idhash_insert
argument_list|(
name|dhp
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|idp
operator|->
name|di_kind
argument_list|,
name|idp
operator|->
name|di_flags
argument_list|,
name|idp
operator|->
name|di_id
argument_list|,
name|idp
operator|->
name|di_attr
argument_list|,
name|idp
operator|->
name|di_vers
argument_list|,
name|idp
operator|->
name|di_ops
condition|?
name|idp
operator|->
name|di_ops
else|:
operator|&
name|dt_idops_thaw
argument_list|,
name|idp
operator|->
name|di_iarg
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|dt_idhash_t
modifier|*
name|dt_idhash_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|dt_ident_t
modifier|*
name|tmpl
parameter_list|,
name|uint_t
name|min
parameter_list|,
name|uint_t
name|max
parameter_list|)
block|{
name|dt_idhash_t
modifier|*
name|dhp
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|assert
argument_list|(
name|min
operator|<=
name|max
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|dt_idhash_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dt_ident_t
operator|*
argument_list|)
operator|*
operator|(
name|_dtrace_strbuckets
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|dhp
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|dhp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|dhp
operator|->
name|dh_name
operator|=
name|name
expr_stmt|;
name|dhp
operator|->
name|dh_tmpl
operator|=
name|tmpl
expr_stmt|;
name|dhp
operator|->
name|dh_nextid
operator|=
name|min
expr_stmt|;
name|dhp
operator|->
name|dh_minid
operator|=
name|min
expr_stmt|;
name|dhp
operator|->
name|dh_maxid
operator|=
name|max
expr_stmt|;
name|dhp
operator|->
name|dh_hashsz
operator|=
name|_dtrace_strbuckets
expr_stmt|;
return|return
operator|(
name|dhp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy an entire identifier hash.  This must be done using two passes with  * an inlined version of dt_ident_destroy() to avoid referencing freed memory.  * In the first pass di_dtor() is called for all identifiers; then the second  * pass frees the actual dt_ident_t's.  These must be done separately because  * a di_dtor() may operate on data structures which contain references to other  * identifiers inside of this hash itself (e.g. a global inline definition  * which contains a parse tree that refers to another global variable).  */
end_comment

begin_function
name|void
name|dt_idhash_destroy
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|idp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|ulong_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dhp
operator|->
name|dh_hashsz
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|idp
operator|=
name|dhp
operator|->
name|dh_hash
index|[
name|i
index|]
init|;
name|idp
operator|!=
name|NULL
condition|;
name|idp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|idp
operator|->
name|di_next
expr_stmt|;
name|idp
operator|->
name|di_ops
operator|->
name|di_dtor
argument_list|(
name|idp
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dhp
operator|->
name|dh_hashsz
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|idp
operator|=
name|dhp
operator|->
name|dh_hash
index|[
name|i
index|]
init|;
name|idp
operator|!=
name|NULL
condition|;
name|idp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|idp
operator|->
name|di_next
expr_stmt|;
name|free
argument_list|(
name|idp
operator|->
name|di_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|idp
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|dhp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_idhash_update
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|)
block|{
name|uint_t
name|nextid
init|=
name|dhp
operator|->
name|dh_minid
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|ulong_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dhp
operator|->
name|dh_hashsz
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|idp
operator|=
name|dhp
operator|->
name|dh_hash
index|[
name|i
index|]
init|;
name|idp
operator|!=
name|NULL
condition|;
name|idp
operator|=
name|idp
operator|->
name|di_next
control|)
block|{
comment|/* 			 * Right now we're hard coding which types need to be 			 * reset, but ideally this would be done dynamically. 			 */
if|if
condition|(
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_ARRAY
operator|||
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_SCALAR
operator|||
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_AGG
condition|)
name|nextid
operator|=
name|MAX
argument_list|(
name|nextid
argument_list|,
name|idp
operator|->
name|di_id
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|dhp
operator|->
name|dh_nextid
operator|=
name|nextid
expr_stmt|;
block|}
end_function

begin_function
name|dt_ident_t
modifier|*
name|dt_idhash_lookup
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|ulong_t
name|h
init|=
name|dt_strtab_hash
argument_list|(
name|name
argument_list|,
operator|&
name|len
argument_list|)
operator|%
name|dhp
operator|->
name|dh_hashsz
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
if|if
condition|(
name|dhp
operator|->
name|dh_tmpl
operator|!=
name|NULL
condition|)
name|dt_idhash_populate
argument_list|(
name|dhp
argument_list|)
expr_stmt|;
comment|/* fill hash w/ initial population */
for|for
control|(
name|idp
operator|=
name|dhp
operator|->
name|dh_hash
index|[
name|h
index|]
init|;
name|idp
operator|!=
name|NULL
condition|;
name|idp
operator|=
name|idp
operator|->
name|di_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|idp
operator|->
name|di_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|idp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_idhash_nextid
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
name|uint_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|dhp
operator|->
name|dh_nextid
operator|>=
name|dhp
operator|->
name|dh_maxid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* no more id's are free to allocate */
operator|*
name|p
operator|=
name|dhp
operator|->
name|dh_nextid
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|ulong_t
name|dt_idhash_size
parameter_list|(
specifier|const
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|)
block|{
return|return
operator|(
name|dhp
operator|->
name|dh_nelems
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|dt_idhash_name
parameter_list|(
specifier|const
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|)
block|{
return|return
operator|(
name|dhp
operator|->
name|dh_name
operator|)
return|;
block|}
end_function

begin_function
name|dt_ident_t
modifier|*
name|dt_idhash_insert
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ushort_t
name|kind
parameter_list|,
name|ushort_t
name|flags
parameter_list|,
name|uint_t
name|id
parameter_list|,
name|dtrace_attribute_t
name|attr
parameter_list|,
name|uint_t
name|vers
parameter_list|,
specifier|const
name|dt_idops_t
modifier|*
name|ops
parameter_list|,
name|void
modifier|*
name|iarg
parameter_list|,
name|ulong_t
name|gen
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|ulong_t
name|h
decl_stmt|;
if|if
condition|(
name|dhp
operator|->
name|dh_tmpl
operator|!=
name|NULL
condition|)
name|dt_idhash_populate
argument_list|(
name|dhp
argument_list|)
expr_stmt|;
comment|/* fill hash w/ initial population */
name|idp
operator|=
name|dt_ident_create
argument_list|(
name|name
argument_list|,
name|kind
argument_list|,
name|flags
argument_list|,
name|id
argument_list|,
name|attr
argument_list|,
name|vers
argument_list|,
name|ops
argument_list|,
name|iarg
argument_list|,
name|gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|h
operator|=
name|dt_strtab_hash
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
operator|%
name|dhp
operator|->
name|dh_hashsz
expr_stmt|;
name|idp
operator|->
name|di_next
operator|=
name|dhp
operator|->
name|dh_hash
index|[
name|h
index|]
expr_stmt|;
name|dhp
operator|->
name|dh_hash
index|[
name|h
index|]
operator|=
name|idp
expr_stmt|;
name|dhp
operator|->
name|dh_nelems
operator|++
expr_stmt|;
if|if
condition|(
name|dhp
operator|->
name|dh_defer
operator|!=
name|NULL
condition|)
name|dhp
operator|->
name|dh_defer
argument_list|(
name|dhp
argument_list|,
name|idp
argument_list|)
expr_stmt|;
return|return
operator|(
name|idp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_idhash_xinsert
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|)
block|{
name|ulong_t
name|h
decl_stmt|;
if|if
condition|(
name|dhp
operator|->
name|dh_tmpl
operator|!=
name|NULL
condition|)
name|dt_idhash_populate
argument_list|(
name|dhp
argument_list|)
expr_stmt|;
comment|/* fill hash w/ initial population */
name|h
operator|=
name|dt_strtab_hash
argument_list|(
name|idp
operator|->
name|di_name
argument_list|,
name|NULL
argument_list|)
operator|%
name|dhp
operator|->
name|dh_hashsz
expr_stmt|;
name|idp
operator|->
name|di_next
operator|=
name|dhp
operator|->
name|dh_hash
index|[
name|h
index|]
expr_stmt|;
name|idp
operator|->
name|di_flags
operator|&=
operator|~
name|DT_IDFLG_ORPHAN
expr_stmt|;
name|dhp
operator|->
name|dh_hash
index|[
name|h
index|]
operator|=
name|idp
expr_stmt|;
name|dhp
operator|->
name|dh_nelems
operator|++
expr_stmt|;
if|if
condition|(
name|dhp
operator|->
name|dh_defer
operator|!=
name|NULL
condition|)
name|dhp
operator|->
name|dh_defer
argument_list|(
name|dhp
argument_list|,
name|idp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_idhash_delete
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
name|dt_ident_t
modifier|*
name|key
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|ulong_t
name|h
init|=
name|dt_strtab_hash
argument_list|(
name|key
operator|->
name|di_name
argument_list|,
operator|&
name|len
argument_list|)
operator|%
name|dhp
operator|->
name|dh_hashsz
decl_stmt|;
name|dt_ident_t
modifier|*
modifier|*
name|pp
init|=
operator|&
name|dhp
operator|->
name|dh_hash
index|[
name|h
index|]
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
for|for
control|(
name|idp
operator|=
name|dhp
operator|->
name|dh_hash
index|[
name|h
index|]
init|;
name|idp
operator|!=
name|NULL
condition|;
name|idp
operator|=
name|idp
operator|->
name|di_next
control|)
block|{
if|if
condition|(
name|idp
operator|==
name|key
condition|)
break|break;
else|else
name|pp
operator|=
operator|&
name|idp
operator|->
name|di_next
expr_stmt|;
block|}
name|assert
argument_list|(
name|idp
operator|==
name|key
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|idp
operator|->
name|di_next
expr_stmt|;
name|assert
argument_list|(
name|dhp
operator|->
name|dh_nelems
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dhp
operator|->
name|dh_nelems
operator|--
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_ORPHAN
operator|)
condition|)
name|dt_ident_destroy
argument_list|(
name|idp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_idhash_comp
parameter_list|(
specifier|const
name|void
modifier|*
name|lp
parameter_list|,
specifier|const
name|void
modifier|*
name|rp
parameter_list|)
block|{
specifier|const
name|dt_ident_t
modifier|*
name|lhs
init|=
operator|*
operator|(
operator|(
specifier|const
name|dt_ident_t
operator|*
operator|*
operator|)
name|lp
operator|)
decl_stmt|;
specifier|const
name|dt_ident_t
modifier|*
name|rhs
init|=
operator|*
operator|(
operator|(
specifier|const
name|dt_ident_t
operator|*
operator|*
operator|)
name|rp
operator|)
decl_stmt|;
if|if
condition|(
name|lhs
operator|->
name|di_id
operator|!=
name|rhs
operator|->
name|di_id
condition|)
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|lhs
operator|->
name|di_id
operator|-
name|rhs
operator|->
name|di_id
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|strcmp
argument_list|(
name|lhs
operator|->
name|di_name
argument_list|,
name|rhs
operator|->
name|di_name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_idhash_iter
parameter_list|(
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|,
name|dt_idhash_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|dt_ident_t
modifier|*
modifier|*
name|ids
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|ulong_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|dhp
operator|->
name|dh_tmpl
operator|!=
name|NULL
condition|)
name|dt_idhash_populate
argument_list|(
name|dhp
argument_list|)
expr_stmt|;
comment|/* fill hash w/ initial population */
name|n
operator|=
name|dhp
operator|->
name|dh_nelems
expr_stmt|;
name|ids
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_ident_t
operator|*
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|dhp
operator|->
name|dh_hashsz
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|idp
operator|=
name|dhp
operator|->
name|dh_hash
index|[
name|i
index|]
init|;
name|idp
operator|!=
name|NULL
condition|;
name|idp
operator|=
name|idp
operator|->
name|di_next
control|)
name|ids
index|[
name|j
operator|++
index|]
operator|=
name|idp
expr_stmt|;
block|}
name|qsort
argument_list|(
name|ids
argument_list|,
name|dhp
operator|->
name|dh_nelems
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_ident_t
operator|*
argument_list|)
argument_list|,
name|dt_idhash_comp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rv
operator|=
name|func
argument_list|(
name|dhp
argument_list|,
name|ids
index|[
name|i
index|]
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|dt_ident_t
modifier|*
name|dt_idstack_lookup
parameter_list|(
name|dt_idstack_t
modifier|*
name|sp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dt_idhash_t
modifier|*
name|dhp
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
for|for
control|(
name|dhp
operator|=
name|dt_list_prev
argument_list|(
operator|&
name|sp
operator|->
name|dids_list
argument_list|)
init|;
name|dhp
operator|!=
name|NULL
condition|;
name|dhp
operator|=
name|dt_list_prev
argument_list|(
name|dhp
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|dhp
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|idp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_idstack_push
parameter_list|(
name|dt_idstack_t
modifier|*
name|sp
parameter_list|,
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|)
block|{
name|dt_list_append
argument_list|(
operator|&
name|sp
operator|->
name|dids_list
argument_list|,
name|dhp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_idstack_pop
parameter_list|(
name|dt_idstack_t
modifier|*
name|sp
parameter_list|,
name|dt_idhash_t
modifier|*
name|dhp
parameter_list|)
block|{
name|assert
argument_list|(
name|dt_list_prev
argument_list|(
operator|&
name|sp
operator|->
name|dids_list
argument_list|)
operator|==
name|dhp
argument_list|)
expr_stmt|;
name|dt_list_delete
argument_list|(
operator|&
name|sp
operator|->
name|dids_list
argument_list|,
name|dhp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dt_ident_t
modifier|*
name|dt_ident_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ushort_t
name|kind
parameter_list|,
name|ushort_t
name|flags
parameter_list|,
name|uint_t
name|id
parameter_list|,
name|dtrace_attribute_t
name|attr
parameter_list|,
name|uint_t
name|vers
parameter_list|,
specifier|const
name|dt_idops_t
modifier|*
name|ops
parameter_list|,
name|void
modifier|*
name|iarg
parameter_list|,
name|ulong_t
name|gen
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|idp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_ident_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|idp
operator|->
name|di_name
operator|=
name|s
expr_stmt|;
name|idp
operator|->
name|di_kind
operator|=
name|kind
expr_stmt|;
name|idp
operator|->
name|di_flags
operator|=
name|flags
expr_stmt|;
name|idp
operator|->
name|di_id
operator|=
name|id
expr_stmt|;
name|idp
operator|->
name|di_attr
operator|=
name|attr
expr_stmt|;
name|idp
operator|->
name|di_vers
operator|=
name|vers
expr_stmt|;
name|idp
operator|->
name|di_ops
operator|=
name|ops
expr_stmt|;
name|idp
operator|->
name|di_iarg
operator|=
name|iarg
expr_stmt|;
name|idp
operator|->
name|di_data
operator|=
name|NULL
expr_stmt|;
name|idp
operator|->
name|di_ctfp
operator|=
name|NULL
expr_stmt|;
name|idp
operator|->
name|di_type
operator|=
name|CTF_ERR
expr_stmt|;
name|idp
operator|->
name|di_next
operator|=
name|NULL
expr_stmt|;
name|idp
operator|->
name|di_gen
operator|=
name|gen
expr_stmt|;
name|idp
operator|->
name|di_lineno
operator|=
name|yylineno
expr_stmt|;
return|return
operator|(
name|idp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy an individual identifier.  This code must be kept in sync with the  * dt_idhash_destroy() function below, which separates out the call to di_dtor.  */
end_comment

begin_function
name|void
name|dt_ident_destroy
parameter_list|(
name|dt_ident_t
modifier|*
name|idp
parameter_list|)
block|{
name|idp
operator|->
name|di_ops
operator|->
name|di_dtor
argument_list|(
name|idp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|idp
operator|->
name|di_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|idp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_ident_morph
parameter_list|(
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|ushort_t
name|kind
parameter_list|,
specifier|const
name|dt_idops_t
modifier|*
name|ops
parameter_list|,
name|void
modifier|*
name|iarg
parameter_list|)
block|{
name|idp
operator|->
name|di_ops
operator|->
name|di_dtor
argument_list|(
name|idp
argument_list|)
expr_stmt|;
name|idp
operator|->
name|di_kind
operator|=
name|kind
expr_stmt|;
name|idp
operator|->
name|di_ops
operator|=
name|ops
expr_stmt|;
name|idp
operator|->
name|di_iarg
operator|=
name|iarg
expr_stmt|;
name|idp
operator|->
name|di_data
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|dtrace_attribute_t
name|dt_ident_cook
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|dt_node_t
modifier|*
modifier|*
name|pargp
parameter_list|)
block|{
name|dtrace_attribute_t
name|attr
decl_stmt|;
name|dt_node_t
modifier|*
name|args
decl_stmt|,
modifier|*
name|argp
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
name|attr
operator|=
name|dt_node_list_cook
argument_list|(
name|pargp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
name|args
operator|=
name|pargp
condition|?
operator|*
name|pargp
else|:
name|NULL
expr_stmt|;
for|for
control|(
name|argp
operator|=
name|args
init|;
name|argp
operator|!=
name|NULL
condition|;
name|argp
operator|=
name|argp
operator|->
name|dn_list
control|)
name|argc
operator|++
expr_stmt|;
name|idp
operator|->
name|di_ops
operator|->
name|di_cook
argument_list|(
name|dnp
argument_list|,
name|idp
argument_list|,
name|argc
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_USER
condition|)
name|dnp
operator|->
name|dn_flags
operator||=
name|DT_NF_USERLAND
expr_stmt|;
return|return
operator|(
name|dt_attr_min
argument_list|(
name|attr
argument_list|,
name|idp
operator|->
name|di_attr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_ident_type_assign
parameter_list|(
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
name|idp
operator|->
name|di_ctfp
operator|=
name|fp
expr_stmt|;
name|idp
operator|->
name|di_type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
name|dt_ident_t
modifier|*
name|dt_ident_resolve
parameter_list|(
name|dt_ident_t
modifier|*
name|idp
parameter_list|)
block|{
while|while
condition|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_INLINE
condition|)
block|{
specifier|const
name|dt_node_t
modifier|*
name|dnp
init|=
operator|(
operator|(
name|dt_idnode_t
operator|*
operator|)
name|idp
operator|->
name|di_iarg
operator|)
operator|->
name|din_root
decl_stmt|;
if|if
condition|(
name|dnp
operator|==
name|NULL
condition|)
break|break;
comment|/* can't resolve any further yet */
switch|switch
condition|(
name|dnp
operator|->
name|dn_kind
condition|)
block|{
case|case
name|DT_NODE_VAR
case|:
case|case
name|DT_NODE_SYM
case|:
case|case
name|DT_NODE_FUNC
case|:
case|case
name|DT_NODE_AGG
case|:
case|case
name|DT_NODE_INLINE
case|:
case|case
name|DT_NODE_PROBE
case|:
name|idp
operator|=
name|dnp
operator|->
name|dn_ident
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dt_node_is_dynamic
argument_list|(
name|dnp
argument_list|)
condition|)
name|idp
operator|=
name|dnp
operator|->
name|dn_ident
expr_stmt|;
else|else
break|break;
block|}
return|return
operator|(
name|idp
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|dt_ident_size
parameter_list|(
name|dt_ident_t
modifier|*
name|idp
parameter_list|)
block|{
name|idp
operator|=
name|dt_ident_resolve
argument_list|(
name|idp
argument_list|)
expr_stmt|;
return|return
operator|(
name|idp
operator|->
name|di_ops
operator|->
name|di_size
argument_list|(
name|idp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_ident_unref
parameter_list|(
specifier|const
name|dt_ident_t
modifier|*
name|idp
parameter_list|)
block|{
return|return
operator|(
name|idp
operator|->
name|di_gen
operator|==
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_gen
operator|&&
operator|(
name|idp
operator|->
name|di_flags
operator|&
operator|(
name|DT_IDFLG_REF
operator||
name|DT_IDFLG_MOD
operator||
name|DT_IDFLG_DECL
operator|)
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|dt_idkind_name
parameter_list|(
name|uint_t
name|kind
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|DT_IDENT_ARRAY
case|:
return|return
operator|(
literal|"associative array"
operator|)
return|;
case|case
name|DT_IDENT_SCALAR
case|:
return|return
operator|(
literal|"scalar"
operator|)
return|;
case|case
name|DT_IDENT_PTR
case|:
return|return
operator|(
literal|"pointer"
operator|)
return|;
case|case
name|DT_IDENT_FUNC
case|:
return|return
operator|(
literal|"function"
operator|)
return|;
case|case
name|DT_IDENT_AGG
case|:
return|return
operator|(
literal|"aggregation"
operator|)
return|;
case|case
name|DT_IDENT_AGGFUNC
case|:
return|return
operator|(
literal|"aggregating function"
operator|)
return|;
case|case
name|DT_IDENT_ACTFUNC
case|:
return|return
operator|(
literal|"tracing function"
operator|)
return|;
case|case
name|DT_IDENT_XLSOU
case|:
return|return
operator|(
literal|"translated data"
operator|)
return|;
case|case
name|DT_IDENT_XLPTR
case|:
return|return
operator|(
literal|"pointer to translated data"
operator|)
return|;
case|case
name|DT_IDENT_SYMBOL
case|:
return|return
operator|(
literal|"external symbol reference"
operator|)
return|;
case|case
name|DT_IDENT_ENUM
case|:
return|return
operator|(
literal|"enumerator"
operator|)
return|;
case|case
name|DT_IDENT_PRAGAT
case|:
return|return
operator|(
literal|"#pragma attributes"
operator|)
return|;
case|case
name|DT_IDENT_PRAGBN
case|:
return|return
operator|(
literal|"#pragma binding"
operator|)
return|;
case|case
name|DT_IDENT_PROBE
case|:
return|return
operator|(
literal|"probe definition"
operator|)
return|;
default|default:
return|return
operator|(
literal|"<?>"
operator|)
return|;
block|}
block|}
end_function

end_unit

