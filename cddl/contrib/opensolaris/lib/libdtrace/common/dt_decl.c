begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.  * Copyright (c) 2013 by Delphix. All rights reserved.  * Copyright (c) 2013 Joyent, Inc. All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<dt_decl.h>
end_include

begin_include
include|#
directive|include
file|<dt_parser.h>
end_include

begin_include
include|#
directive|include
file|<dt_module.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_function
specifier|static
name|dt_decl_t
modifier|*
name|dt_decl_check
parameter_list|(
name|dt_decl_t
modifier|*
name|ddp
parameter_list|)
block|{
if|if
condition|(
name|ddp
operator|->
name|dd_kind
operator|==
name|CTF_K_UNKNOWN
condition|)
return|return
operator|(
name|ddp
operator|)
return|;
comment|/* nothing to check if the type is not yet set */
if|if
condition|(
name|ddp
operator|->
name|dd_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|ddp
operator|->
name|dd_name
argument_list|,
literal|"char"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ddp
operator|->
name|dd_attr
operator|&
operator|(
name|DT_DA_SHORT
operator||
name|DT_DA_LONG
operator||
name|DT_DA_LONGLONG
operator|)
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_CHARATTR
argument_list|,
literal|"invalid type declaration: short and "
literal|"long may not be used with char type\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ddp
operator|->
name|dd_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|ddp
operator|->
name|dd_name
argument_list|,
literal|"void"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ddp
operator|->
name|dd_attr
operator|&
operator|(
name|DT_DA_SHORT
operator||
name|DT_DA_LONG
operator||
name|DT_DA_LONGLONG
operator||
operator|(
name|DT_DA_SIGNED
operator||
name|DT_DA_UNSIGNED
operator|)
operator|)
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_VOIDATTR
argument_list|,
literal|"invalid type declaration: attributes "
literal|"may not be used with void type\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ddp
operator|->
name|dd_kind
operator|!=
name|CTF_K_INTEGER
operator|&&
operator|(
name|ddp
operator|->
name|dd_attr
operator|&
operator|(
name|DT_DA_SIGNED
operator||
name|DT_DA_UNSIGNED
operator|)
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_SIGNINT
argument_list|,
literal|"invalid type declaration: signed and "
literal|"unsigned may only be used with integer type\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ddp
operator|->
name|dd_kind
operator|!=
name|CTF_K_INTEGER
operator|&&
name|ddp
operator|->
name|dd_kind
operator|!=
name|CTF_K_FLOAT
operator|&&
operator|(
name|ddp
operator|->
name|dd_attr
operator|&
operator|(
name|DT_DA_LONG
operator||
name|DT_DA_LONGLONG
operator|)
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_LONGINT
argument_list|,
literal|"invalid type declaration: long and "
literal|"long long may only be used with integer or "
literal|"floating-point type\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ddp
operator|)
return|;
block|}
end_function

begin_function
name|dt_decl_t
modifier|*
name|dt_decl_alloc
parameter_list|(
name|ushort_t
name|kind
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dt_decl_t
modifier|*
name|ddp
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_decl_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ddp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|ddp
operator|->
name|dd_kind
operator|=
name|kind
expr_stmt|;
name|ddp
operator|->
name|dd_attr
operator|=
literal|0
expr_stmt|;
name|ddp
operator|->
name|dd_ctfp
operator|=
name|NULL
expr_stmt|;
name|ddp
operator|->
name|dd_type
operator|=
name|CTF_ERR
expr_stmt|;
name|ddp
operator|->
name|dd_name
operator|=
name|name
expr_stmt|;
name|ddp
operator|->
name|dd_node
operator|=
name|NULL
expr_stmt|;
name|ddp
operator|->
name|dd_next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ddp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_decl_free
parameter_list|(
name|dt_decl_t
modifier|*
name|ddp
parameter_list|)
block|{
name|dt_decl_t
modifier|*
name|ndp
decl_stmt|;
for|for
control|(
init|;
name|ddp
operator|!=
name|NULL
condition|;
name|ddp
operator|=
name|ndp
control|)
block|{
name|ndp
operator|=
name|ddp
operator|->
name|dd_next
expr_stmt|;
name|free
argument_list|(
name|ddp
operator|->
name|dd_name
argument_list|)
expr_stmt|;
name|dt_node_list_free
argument_list|(
operator|&
name|ddp
operator|->
name|dd_node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dt_decl_reset
parameter_list|(
name|void
parameter_list|)
block|{
name|dt_scope_t
modifier|*
name|dsp
init|=
operator|&
name|yypcb
operator|->
name|pcb_dstack
decl_stmt|;
name|dt_decl_t
modifier|*
name|ddp
init|=
name|dsp
operator|->
name|ds_decl
decl_stmt|;
while|while
condition|(
name|ddp
operator|->
name|dd_next
operator|!=
name|NULL
condition|)
block|{
name|dsp
operator|->
name|ds_decl
operator|=
name|ddp
operator|->
name|dd_next
expr_stmt|;
name|ddp
operator|->
name|dd_next
operator|=
name|NULL
expr_stmt|;
name|dt_decl_free
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
name|ddp
operator|=
name|dsp
operator|->
name|ds_decl
expr_stmt|;
block|}
block|}
end_function

begin_function
name|dt_decl_t
modifier|*
name|dt_decl_push
parameter_list|(
name|dt_decl_t
modifier|*
name|ddp
parameter_list|)
block|{
name|dt_scope_t
modifier|*
name|dsp
init|=
operator|&
name|yypcb
operator|->
name|pcb_dstack
decl_stmt|;
name|dt_decl_t
modifier|*
name|top
init|=
name|dsp
operator|->
name|ds_decl
decl_stmt|;
if|if
condition|(
name|top
operator|!=
name|NULL
operator|&&
name|top
operator|->
name|dd_kind
operator|==
name|CTF_K_UNKNOWN
operator|&&
name|top
operator|->
name|dd_name
operator|==
name|NULL
condition|)
block|{
name|top
operator|->
name|dd_kind
operator|=
name|CTF_K_INTEGER
expr_stmt|;
operator|(
name|void
operator|)
name|dt_decl_check
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|ddp
operator|->
name|dd_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ddp
operator|->
name|dd_next
operator|=
name|top
expr_stmt|;
name|dsp
operator|->
name|ds_decl
operator|=
name|ddp
expr_stmt|;
return|return
operator|(
name|ddp
operator|)
return|;
block|}
end_function

begin_function
name|dt_decl_t
modifier|*
name|dt_decl_pop
parameter_list|(
name|void
parameter_list|)
block|{
name|dt_scope_t
modifier|*
name|dsp
init|=
operator|&
name|yypcb
operator|->
name|pcb_dstack
decl_stmt|;
name|dt_decl_t
modifier|*
name|ddp
init|=
name|dt_decl_top
argument_list|()
decl_stmt|;
name|dsp
operator|->
name|ds_decl
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
name|dsp
operator|->
name|ds_ident
operator|=
name|NULL
expr_stmt|;
name|dsp
operator|->
name|ds_ctfp
operator|=
name|NULL
expr_stmt|;
name|dsp
operator|->
name|ds_type
operator|=
name|CTF_ERR
expr_stmt|;
name|dsp
operator|->
name|ds_class
operator|=
name|DT_DC_DEFAULT
expr_stmt|;
name|dsp
operator|->
name|ds_enumval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|ddp
operator|)
return|;
block|}
end_function

begin_function
name|dt_decl_t
modifier|*
name|dt_decl_pop_param
parameter_list|(
name|char
modifier|*
modifier|*
name|idp
parameter_list|)
block|{
name|dt_scope_t
modifier|*
name|dsp
init|=
operator|&
name|yypcb
operator|->
name|pcb_dstack
decl_stmt|;
if|if
condition|(
name|dsp
operator|->
name|ds_class
operator|!=
name|DT_DC_DEFAULT
operator|&&
name|dsp
operator|->
name|ds_class
operator|!=
name|DT_DC_REGISTER
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_PARMCLASS
argument_list|,
literal|"inappropriate storage class "
literal|"for function or associative array parameter\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idp
operator|!=
name|NULL
operator|&&
name|dt_decl_top
argument_list|()
operator|!=
name|NULL
condition|)
block|{
operator|*
name|idp
operator|=
name|dsp
operator|->
name|ds_ident
expr_stmt|;
name|dsp
operator|->
name|ds_ident
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|dt_decl_pop
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|dt_decl_t
modifier|*
name|dt_decl_top
parameter_list|(
name|void
parameter_list|)
block|{
name|dt_decl_t
modifier|*
name|ddp
init|=
name|yypcb
operator|->
name|pcb_dstack
operator|.
name|ds_decl
decl_stmt|;
if|if
condition|(
name|ddp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NODECL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddp
operator|->
name|dd_kind
operator|==
name|CTF_K_UNKNOWN
operator|&&
name|ddp
operator|->
name|dd_name
operator|==
name|NULL
condition|)
block|{
name|ddp
operator|->
name|dd_kind
operator|=
name|CTF_K_INTEGER
expr_stmt|;
operator|(
name|void
operator|)
name|dt_decl_check
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ddp
operator|)
return|;
block|}
end_function

begin_function
name|dt_decl_t
modifier|*
name|dt_decl_ident
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dt_scope_t
modifier|*
name|dsp
init|=
operator|&
name|yypcb
operator|->
name|pcb_dstack
decl_stmt|;
name|dt_decl_t
modifier|*
name|ddp
init|=
name|dsp
operator|->
name|ds_decl
decl_stmt|;
if|if
condition|(
name|dsp
operator|->
name|ds_ident
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|xyerror
argument_list|(
name|D_DECL_IDENT
argument_list|,
literal|"old-style declaration or "
literal|"incorrect type specified\n"
argument_list|)
expr_stmt|;
block|}
name|dsp
operator|->
name|ds_ident
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|ddp
operator|==
name|NULL
condition|)
name|ddp
operator|=
name|dt_decl_push
argument_list|(
name|dt_decl_alloc
argument_list|(
name|CTF_K_UNKNOWN
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ddp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_decl_class
parameter_list|(
name|dt_dclass_t
name|class
parameter_list|)
block|{
name|dt_scope_t
modifier|*
name|dsp
init|=
operator|&
name|yypcb
operator|->
name|pcb_dstack
decl_stmt|;
if|if
condition|(
name|dsp
operator|->
name|ds_class
operator|!=
name|DT_DC_DEFAULT
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_CLASS
argument_list|,
literal|"only one storage class allowed "
literal|"in a declaration\n"
argument_list|)
expr_stmt|;
block|}
name|dsp
operator|->
name|ds_class
operator|=
name|class
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the kind and name of the current declaration.  If none is allocated,  * make a new decl and push it on to the top of our stack.  If the name or kind  * is already set for the current decl, then we need to fail this declaration.  * This can occur because too many types were given (e.g. "int int"), etc.  */
end_comment

begin_function
name|dt_decl_t
modifier|*
name|dt_decl_spec
parameter_list|(
name|ushort_t
name|kind
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dt_decl_t
modifier|*
name|ddp
init|=
name|yypcb
operator|->
name|pcb_dstack
operator|.
name|ds_decl
decl_stmt|;
if|if
condition|(
name|ddp
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_decl_push
argument_list|(
name|dt_decl_alloc
argument_list|(
name|kind
argument_list|,
name|name
argument_list|)
argument_list|)
operator|)
return|;
comment|/* 	 * If we already have a type name specified and we see another type 	 * name, this is an error if the declaration is a typedef.  If the 	 * declaration is not a typedef, then the user may be trying to declare 	 * a variable whose name has been returned by lex as a TNAME token: 	 * call dt_decl_ident() as if the grammar's IDENT rule was matched. 	 */
if|if
condition|(
name|ddp
operator|->
name|dd_name
operator|!=
name|NULL
operator|&&
name|kind
operator|==
name|CTF_K_TYPEDEF
condition|)
block|{
if|if
condition|(
name|yypcb
operator|->
name|pcb_dstack
operator|.
name|ds_class
operator|!=
name|DT_DC_TYPEDEF
condition|)
return|return
operator|(
name|dt_decl_ident
argument_list|(
name|name
argument_list|)
operator|)
return|;
name|xyerror
argument_list|(
name|D_DECL_IDRED
argument_list|,
literal|"identifier redeclared: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ddp
operator|->
name|dd_name
operator|!=
name|NULL
operator|||
name|ddp
operator|->
name|dd_kind
operator|!=
name|CTF_K_UNKNOWN
condition|)
name|xyerror
argument_list|(
name|D_DECL_COMBO
argument_list|,
literal|"invalid type combination\n"
argument_list|)
expr_stmt|;
name|ddp
operator|->
name|dd_kind
operator|=
name|kind
expr_stmt|;
name|ddp
operator|->
name|dd_name
operator|=
name|name
expr_stmt|;
return|return
operator|(
name|dt_decl_check
argument_list|(
name|ddp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|dt_decl_t
modifier|*
name|dt_decl_attr
parameter_list|(
name|ushort_t
name|attr
parameter_list|)
block|{
name|dt_decl_t
modifier|*
name|ddp
init|=
name|yypcb
operator|->
name|pcb_dstack
operator|.
name|ds_decl
decl_stmt|;
if|if
condition|(
name|ddp
operator|==
name|NULL
condition|)
block|{
name|ddp
operator|=
name|dt_decl_push
argument_list|(
name|dt_decl_alloc
argument_list|(
name|CTF_K_UNKNOWN
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ddp
operator|->
name|dd_attr
operator|=
name|attr
expr_stmt|;
return|return
operator|(
name|ddp
operator|)
return|;
block|}
if|if
condition|(
name|attr
operator|==
name|DT_DA_LONG
operator|&&
operator|(
name|ddp
operator|->
name|dd_attr
operator|&
name|DT_DA_LONG
operator|)
condition|)
block|{
name|ddp
operator|->
name|dd_attr
operator|&=
operator|~
name|DT_DA_LONG
expr_stmt|;
name|attr
operator|=
name|DT_DA_LONGLONG
expr_stmt|;
block|}
name|ddp
operator|->
name|dd_attr
operator||=
name|attr
expr_stmt|;
return|return
operator|(
name|dt_decl_check
argument_list|(
name|ddp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Examine the list of formal parameters 'flist' and determine if the formal  * name fnp->dn_string is defined in this list (B_TRUE) or not (B_FALSE).  * If 'fnp' is in 'flist', do not search beyond 'fnp' itself in 'flist'.  */
end_comment

begin_function
specifier|static
name|int
name|dt_decl_protoform
parameter_list|(
name|dt_node_t
modifier|*
name|fnp
parameter_list|,
name|dt_node_t
modifier|*
name|flist
parameter_list|)
block|{
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
for|for
control|(
name|dnp
operator|=
name|flist
init|;
name|dnp
operator|!=
name|fnp
operator|&&
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
control|)
block|{
if|if
condition|(
name|dnp
operator|->
name|dn_string
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|dnp
operator|->
name|dn_string
argument_list|,
name|fnp
operator|->
name|dn_string
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common code for parsing array, function, and probe definition prototypes.  * The prototype node list is specified as 'plist'.  The formal prototype  * against which to compare the prototype is specified as 'flist'.  If plist  * and flist are the same, we require that named parameters are unique.  If  * plist and flist are different, we require that named parameters in plist  * match a name that is present in flist.  */
end_comment

begin_function
name|int
name|dt_decl_prototype
parameter_list|(
name|dt_node_t
modifier|*
name|plist
parameter_list|,
name|dt_node_t
modifier|*
name|flist
parameter_list|,
specifier|const
name|char
modifier|*
name|kind
parameter_list|,
name|uint_t
name|flags
parameter_list|)
block|{
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|int
name|is_void
decl_stmt|,
name|v
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|1
decl_stmt|;
name|int
name|form
init|=
name|plist
operator|!=
name|flist
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
for|for
control|(
name|dnp
operator|=
name|plist
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dnp
operator|->
name|dn_type
operator|==
name|CTF_ERR
operator|&&
operator|!
operator|(
name|flags
operator|&
name|DT_DP_VARARGS
operator|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_DECL_PROTO_VARARGS
argument_list|,
literal|"%s prototype may "
literal|"not use a variable-length argument list\n"
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_node_is_dynamic
argument_list|(
name|dnp
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|DT_DP_DYNAMIC
operator|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_DECL_PROTO_TYPE
argument_list|,
literal|"%s prototype may not "
literal|"use parameter of type %s: %s, parameter #%d\n"
argument_list|,
name|kind
argument_list|,
name|dt_node_type_name
argument_list|(
name|dnp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|,
name|dnp
operator|->
name|dn_string
condition|?
name|dnp
operator|->
name|dn_string
else|:
literal|"(anonymous)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|is_void
operator|=
name|dt_node_is_void
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|v
operator|+=
name|is_void
expr_stmt|;
if|if
condition|(
name|is_void
operator|&&
operator|!
operator|(
name|flags
operator|&
name|DT_DP_VOID
operator|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_DECL_PROTO_TYPE
argument_list|,
literal|"%s prototype may not "
literal|"use parameter of type %s: %s, parameter #%d\n"
argument_list|,
name|kind
argument_list|,
name|dt_node_type_name
argument_list|(
name|dnp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|,
name|dnp
operator|->
name|dn_string
condition|?
name|dnp
operator|->
name|dn_string
else|:
literal|"(anonymous)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_void
operator|&&
name|dnp
operator|->
name|dn_string
operator|!=
name|NULL
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_DECL_PROTO_NAME
argument_list|,
literal|"void parameter may "
literal|"not have a name: %s\n"
argument_list|,
name|dnp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dnp
operator|->
name|dn_string
operator|!=
name|NULL
operator|&&
name|dt_decl_protoform
argument_list|(
name|dnp
argument_list|,
name|flist
argument_list|)
operator|!=
name|form
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_DECL_PROTO_FORM
argument_list|,
literal|"parameter is "
literal|"%s declared in %s prototype: %s, parameter #%d\n"
argument_list|,
name|form
condition|?
literal|"not"
else|:
literal|"already"
argument_list|,
name|kind
argument_list|,
name|dnp
operator|->
name|dn_string
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dnp
operator|->
name|dn_string
operator|==
name|NULL
operator|&&
operator|!
name|is_void
operator|&&
operator|!
operator|(
name|flags
operator|&
name|DT_DP_ANON
operator|)
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_DECL_PROTO_NAME
argument_list|,
literal|"parameter declaration "
literal|"requires a name: parameter #%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v
operator|!=
literal|0
operator|&&
name|plist
operator|->
name|dn_list
operator|!=
name|NULL
condition|)
name|xyerror
argument_list|(
name|D_DECL_PROTO_VOID
argument_list|,
literal|"void must be sole parameter\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
condition|?
literal|0
else|:
name|i
operator|-
literal|1
operator|)
return|;
comment|/* return zero if sole parameter is 'void' */
block|}
end_function

begin_function
name|dt_decl_t
modifier|*
name|dt_decl_array
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dt_decl_t
modifier|*
name|ddp
init|=
name|dt_decl_push
argument_list|(
name|dt_decl_alloc
argument_list|(
name|CTF_K_ARRAY
argument_list|,
name|NULL
argument_list|)
argument_list|)
decl_stmt|;
name|dt_scope_t
modifier|*
name|dsp
init|=
operator|&
name|yypcb
operator|->
name|pcb_dstack
decl_stmt|;
name|dt_decl_t
modifier|*
name|ndp
init|=
name|ddp
decl_stmt|;
comment|/* 	 * After pushing the array on to the decl stack, scan ahead for multi- 	 * dimensional array declarations and push the current decl to the 	 * bottom to match the resulting CTF type tree and data layout.  Refer 	 * to the comments in dt_decl_type() and ISO C 6.5.2.1 for more info. 	 */
while|while
condition|(
name|ndp
operator|->
name|dd_next
operator|!=
name|NULL
operator|&&
name|ndp
operator|->
name|dd_next
operator|->
name|dd_kind
operator|==
name|CTF_K_ARRAY
condition|)
name|ndp
operator|=
name|ndp
operator|->
name|dd_next
expr_stmt|;
comment|/* skip to bottom-most array declaration */
if|if
condition|(
name|ndp
operator|!=
name|ddp
condition|)
block|{
if|if
condition|(
name|dnp
operator|!=
name|NULL
operator|&&
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_TYPE
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_DYNOBJ
argument_list|,
literal|"cannot declare array of associative arrays\n"
argument_list|)
expr_stmt|;
block|}
name|dsp
operator|->
name|ds_decl
operator|=
name|ddp
operator|->
name|dd_next
expr_stmt|;
name|ddp
operator|->
name|dd_next
operator|=
name|ndp
operator|->
name|dd_next
expr_stmt|;
name|ndp
operator|->
name|dd_next
operator|=
name|ddp
expr_stmt|;
block|}
if|if
condition|(
name|ddp
operator|->
name|dd_next
operator|->
name|dd_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|ddp
operator|->
name|dd_next
operator|->
name|dd_name
argument_list|,
literal|"void"
argument_list|)
operator|==
literal|0
condition|)
name|xyerror
argument_list|(
name|D_DECL_VOIDOBJ
argument_list|,
literal|"cannot declare array of void\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|!=
name|NULL
operator|&&
name|dnp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_TYPE
condition|)
block|{
name|dnp
operator|=
name|ddp
operator|->
name|dd_node
operator|=
name|dt_node_cook
argument_list|(
name|dnp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_node_is_posconst
argument_list|(
name|dnp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_ARRSUB
argument_list|,
literal|"positive integral constant "
literal|"expression or tuple signature expected as "
literal|"array declaration subscript\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dnp
operator|->
name|dn_value
operator|>
name|UINT_MAX
condition|)
name|xyerror
argument_list|(
name|D_DECL_ARRBIG
argument_list|,
literal|"array dimension too big\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dnp
operator|!=
name|NULL
condition|)
block|{
name|ddp
operator|->
name|dd_node
operator|=
name|dnp
expr_stmt|;
operator|(
name|void
operator|)
name|dt_decl_prototype
argument_list|(
name|dnp
argument_list|,
name|dnp
argument_list|,
literal|"array"
argument_list|,
name|DT_DP_ANON
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ddp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When a function is declared, we need to fudge the decl stack a bit if the  * declaration uses the function pointer (*)() syntax.  In this case, the  * dt_decl_func() call occurs *after* the dt_decl_ptr() call, even though the  * resulting type is "pointer to function".  To make the pointer land on top,  * we check to see if 'pdp' is non-NULL and a pointer.  If it is, we search  * backward for a decl tagged with DT_DA_PAREN, and if one is found, the func  * decl is inserted behind this node in the decl list instead of at the top.  * In all cases, the func decl's dd_next pointer is set to the decl chain  * for the function's return type and the function parameter list is discarded.  */
end_comment

begin_function
name|dt_decl_t
modifier|*
name|dt_decl_func
parameter_list|(
name|dt_decl_t
modifier|*
name|pdp
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dt_decl_t
modifier|*
name|ddp
init|=
name|dt_decl_alloc
argument_list|(
name|CTF_K_FUNCTION
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|ddp
operator|->
name|dd_node
operator|=
name|dnp
expr_stmt|;
operator|(
name|void
operator|)
name|dt_decl_prototype
argument_list|(
name|dnp
argument_list|,
name|dnp
argument_list|,
literal|"function"
argument_list|,
name|DT_DP_VARARGS
operator||
name|DT_DP_VOID
operator||
name|DT_DP_ANON
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdp
operator|==
name|NULL
operator|||
name|pdp
operator|->
name|dd_kind
operator|!=
name|CTF_K_POINTER
condition|)
return|return
operator|(
name|dt_decl_push
argument_list|(
name|ddp
argument_list|)
operator|)
return|;
while|while
condition|(
name|pdp
operator|->
name|dd_next
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|pdp
operator|->
name|dd_next
operator|->
name|dd_attr
operator|&
name|DT_DA_PAREN
operator|)
condition|)
name|pdp
operator|=
name|pdp
operator|->
name|dd_next
expr_stmt|;
if|if
condition|(
name|pdp
operator|->
name|dd_next
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_decl_push
argument_list|(
name|ddp
argument_list|)
operator|)
return|;
name|ddp
operator|->
name|dd_next
operator|=
name|pdp
operator|->
name|dd_next
expr_stmt|;
name|pdp
operator|->
name|dd_next
operator|=
name|ddp
expr_stmt|;
return|return
operator|(
name|pdp
operator|)
return|;
block|}
end_function

begin_function
name|dt_decl_t
modifier|*
name|dt_decl_ptr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|dt_decl_push
argument_list|(
name|dt_decl_alloc
argument_list|(
name|CTF_K_POINTER
argument_list|,
name|NULL
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|dt_decl_t
modifier|*
name|dt_decl_sou
parameter_list|(
name|uint_t
name|kind
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dt_decl_t
modifier|*
name|ddp
init|=
name|dt_decl_spec
argument_list|(
name|kind
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|ctf_file_t
modifier|*
name|ctfp
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|uint_t
name|flag
decl_stmt|;
if|if
condition|(
name|yypcb
operator|->
name|pcb_idepth
operator|!=
literal|0
condition|)
name|ctfp
operator|=
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_cdefs
operator|->
name|dm_ctfp
expr_stmt|;
else|else
name|ctfp
operator|=
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_ddefs
operator|->
name|dm_ctfp
expr_stmt|;
if|if
condition|(
name|yypcb
operator|->
name|pcb_dstack
operator|.
name|ds_next
operator|!=
name|NULL
condition|)
name|flag
operator|=
name|CTF_ADD_NONROOT
expr_stmt|;
else|else
name|flag
operator|=
name|CTF_ADD_ROOT
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|,
literal|"%s %s"
argument_list|,
name|kind
operator|==
name|CTF_K_STRUCT
condition|?
literal|"struct"
else|:
literal|"union"
argument_list|,
name|name
operator|==
name|NULL
condition|?
literal|"(anon)"
else|:
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
operator|(
name|type
operator|=
name|ctf_lookup_by_name
argument_list|(
name|ctfp
argument_list|,
name|n
argument_list|)
operator|)
operator|!=
name|CTF_ERR
operator|&&
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
operator|!=
name|CTF_K_FORWARD
condition|)
name|xyerror
argument_list|(
name|D_DECL_TYPERED
argument_list|,
literal|"type redeclared: %s\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_STRUCT
condition|)
name|type
operator|=
name|ctf_add_struct
argument_list|(
name|ctfp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|ctf_add_union
argument_list|(
name|ctfp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CTF_ERR
operator|||
name|ctf_update
argument_list|(
name|ctfp
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to define %s: %s\n"
argument_list|,
name|n
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ddp
operator|->
name|dd_ctfp
operator|=
name|ctfp
expr_stmt|;
name|ddp
operator|->
name|dd_type
operator|=
name|type
expr_stmt|;
name|dt_scope_push
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ddp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_decl_member
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dt_scope_t
modifier|*
name|dsp
init|=
name|yypcb
operator|->
name|pcb_dstack
operator|.
name|ds_next
decl_stmt|;
name|dt_decl_t
modifier|*
name|ddp
init|=
name|yypcb
operator|->
name|pcb_dstack
operator|.
name|ds_decl
decl_stmt|;
name|char
modifier|*
name|ident
init|=
name|yypcb
operator|->
name|pcb_dstack
operator|.
name|ds_ident
decl_stmt|;
specifier|const
name|char
modifier|*
name|idname
init|=
name|ident
condition|?
name|ident
else|:
literal|"(anon)"
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
name|ctf_encoding_t
name|cte
decl_stmt|;
name|ctf_id_t
name|base
decl_stmt|;
name|uint_t
name|kind
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
if|if
condition|(
name|dsp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOSCOPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NODECL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|==
name|NULL
operator|&&
name|ident
operator|==
name|NULL
condition|)
name|xyerror
argument_list|(
name|D_DECL_MNAME
argument_list|,
literal|"member declaration requires a name\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddp
operator|->
name|dd_kind
operator|==
name|CTF_K_UNKNOWN
operator|&&
name|ddp
operator|->
name|dd_name
operator|==
name|NULL
condition|)
block|{
name|ddp
operator|->
name|dd_kind
operator|=
name|CTF_K_INTEGER
expr_stmt|;
operator|(
name|void
operator|)
name|dt_decl_check
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_decl_type
argument_list|(
name|ddp
argument_list|,
operator|&
name|dtt
argument_list|)
operator|!=
literal|0
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident
operator|!=
name|NULL
operator|&&
name|strchr
argument_list|(
name|ident
argument_list|,
literal|'`'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_SCOPE
argument_list|,
literal|"D scoping operator may not be used "
literal|"in a member name (%s)\n"
argument_list|,
name|ident
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dtt
operator|.
name|dtt_ctfp
operator|==
name|DT_DYN_CTFP
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
operator|&&
name|dtt
operator|.
name|dtt_type
operator|==
name|DT_DYN_TYPE
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_DYNOBJ
argument_list|,
literal|"cannot have dynamic member: %s\n"
argument_list|,
name|ident
argument_list|)
expr_stmt|;
block|}
name|base
operator|=
name|ctf_type_resolve
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|size
operator|=
name|ctf_type_size
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_FORWARD
operator|||
operator|(
operator|(
name|kind
operator|==
name|CTF_K_STRUCT
operator|||
name|kind
operator|==
name|CTF_K_UNION
operator|)
operator|&&
name|size
operator|==
literal|0
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_INCOMPLETE
argument_list|,
literal|"incomplete struct/union/enum %s: "
literal|"%s\n"
argument_list|,
name|dt_type_name
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|,
name|ident
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|xyerror
argument_list|(
name|D_DECL_VOIDOBJ
argument_list|,
literal|"cannot have void member: %s\n"
argument_list|,
name|ident
argument_list|)
expr_stmt|;
comment|/* 	 * If a bit-field qualifier was part of the member declaration, create 	 * a new integer type of the same name and attributes as the base type 	 * and size equal to the specified number of bits.  We reset 'dtt' to 	 * refer to this new bit-field type and continue on to add the member. 	 */
if|if
condition|(
name|dnp
operator|!=
name|NULL
condition|)
block|{
name|dnp
operator|=
name|dt_node_cook
argument_list|(
name|dnp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
comment|/* 		 * A bit-field member with no declarator is permitted to have 		 * size zero and indicates that no more fields are to be packed 		 * into the current storage unit.  We ignore these directives 		 * as the underlying ctf code currently does so for all fields. 		 */
if|if
condition|(
name|ident
operator|==
name|NULL
operator|&&
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_INT
operator|&&
name|dnp
operator|->
name|dn_value
operator|==
literal|0
condition|)
block|{
name|dt_node_free
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|dt_node_is_posconst
argument_list|(
name|dnp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_BFCONST
argument_list|,
literal|"positive integral constant "
literal|"expression expected as bit-field size\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctf_type_kind
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|base
argument_list|)
operator|!=
name|CTF_K_INTEGER
operator|||
name|ctf_type_encoding
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|base
argument_list|,
operator|&
name|cte
argument_list|)
operator|==
name|CTF_ERR
operator|||
name|IS_VOID
argument_list|(
name|cte
argument_list|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_BFTYPE
argument_list|,
literal|"invalid type for "
literal|"bit-field: %s\n"
argument_list|,
name|idname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dnp
operator|->
name|dn_value
operator|>
name|cte
operator|.
name|cte_bits
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_BFSIZE
argument_list|,
literal|"bit-field too big "
literal|"for type: %s\n"
argument_list|,
name|idname
argument_list|)
expr_stmt|;
block|}
name|cte
operator|.
name|cte_offset
operator|=
literal|0
expr_stmt|;
name|cte
operator|.
name|cte_bits
operator|=
operator|(
name|uint_t
operator|)
name|dnp
operator|->
name|dn_value
expr_stmt|;
name|dtt
operator|.
name|dtt_type
operator|=
name|ctf_add_integer
argument_list|(
name|dsp
operator|->
name|ds_ctfp
argument_list|,
name|CTF_ADD_NONROOT
argument_list|,
name|ctf_type_name
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|,
operator|&
name|cte
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtt
operator|.
name|dtt_type
operator|==
name|CTF_ERR
operator|||
name|ctf_update
argument_list|(
name|dsp
operator|->
name|ds_ctfp
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to create type for "
literal|"member '%s': %s\n"
argument_list|,
name|idname
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dsp
operator|->
name|ds_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dtt
operator|.
name|dtt_ctfp
operator|=
name|dsp
operator|->
name|ds_ctfp
expr_stmt|;
name|dt_node_free
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the member type is not defined in the same CTF container as the 	 * one associated with the current scope (i.e. the container for the 	 * struct or union itself) or its parent, copy the member type into 	 * this container and reset dtt to refer to the copied type. 	 */
if|if
condition|(
name|dtt
operator|.
name|dtt_ctfp
operator|!=
name|dsp
operator|->
name|ds_ctfp
operator|&&
name|dtt
operator|.
name|dtt_ctfp
operator|!=
name|ctf_parent_file
argument_list|(
name|dsp
operator|->
name|ds_ctfp
argument_list|)
condition|)
block|{
name|dtt
operator|.
name|dtt_type
operator|=
name|ctf_add_type
argument_list|(
name|dsp
operator|->
name|ds_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
name|dtt
operator|.
name|dtt_ctfp
operator|=
name|dsp
operator|->
name|ds_ctfp
expr_stmt|;
if|if
condition|(
name|dtt
operator|.
name|dtt_type
operator|==
name|CTF_ERR
operator|||
name|ctf_update
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to copy type of '%s': %s\n"
argument_list|,
name|idname
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dtt
operator|.
name|dtt_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ctf_add_member
argument_list|(
name|dsp
operator|->
name|ds_ctfp
argument_list|,
name|dsp
operator|->
name|ds_type
argument_list|,
name|ident
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to define member '%s': %s\n"
argument_list|,
name|idname
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dsp
operator|->
name|ds_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|free
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|yypcb
operator|->
name|pcb_dstack
operator|.
name|ds_ident
operator|=
name|NULL
expr_stmt|;
name|dt_decl_reset
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_decl_hasmembers
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* abort search and return true if a member exists */
block|}
end_function

begin_function
name|dt_decl_t
modifier|*
name|dt_decl_enum
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dt_decl_t
modifier|*
name|ddp
init|=
name|dt_decl_spec
argument_list|(
name|CTF_K_ENUM
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|ctf_file_t
modifier|*
name|ctfp
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|uint_t
name|flag
decl_stmt|;
if|if
condition|(
name|yypcb
operator|->
name|pcb_idepth
operator|!=
literal|0
condition|)
name|ctfp
operator|=
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_cdefs
operator|->
name|dm_ctfp
expr_stmt|;
else|else
name|ctfp
operator|=
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_ddefs
operator|->
name|dm_ctfp
expr_stmt|;
if|if
condition|(
name|yypcb
operator|->
name|pcb_dstack
operator|.
name|ds_next
operator|!=
name|NULL
condition|)
name|flag
operator|=
name|CTF_ADD_NONROOT
expr_stmt|;
else|else
name|flag
operator|=
name|CTF_ADD_ROOT
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|,
literal|"enum %s"
argument_list|,
name|name
condition|?
name|name
else|:
literal|"(anon)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
operator|(
name|type
operator|=
name|ctf_lookup_by_name
argument_list|(
name|ctfp
argument_list|,
name|n
argument_list|)
operator|)
operator|!=
name|CTF_ERR
condition|)
block|{
if|if
condition|(
name|ctf_enum_iter
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|,
name|dt_decl_hasmembers
argument_list|,
name|NULL
argument_list|)
condition|)
name|xyerror
argument_list|(
name|D_DECL_TYPERED
argument_list|,
literal|"type redeclared: %s\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_add_enum
argument_list|(
name|ctfp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to define %s: %s\n"
argument_list|,
name|n
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ddp
operator|->
name|dd_ctfp
operator|=
name|ctfp
expr_stmt|;
name|ddp
operator|->
name|dd_type
operator|=
name|type
expr_stmt|;
name|dt_scope_push
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ddp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_decl_enumerator
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dt_scope_t
modifier|*
name|dsp
init|=
name|yypcb
operator|->
name|pcb_dstack
operator|.
name|ds_next
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_idnode_t
modifier|*
name|inp
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
name|name
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOSCOPE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dsp
operator|->
name|ds_decl
operator|->
name|dd_kind
operator|==
name|CTF_K_ENUM
argument_list|)
expr_stmt|;
name|value
operator|=
name|dsp
operator|->
name|ds_enumval
operator|+
literal|1
expr_stmt|;
comment|/* default is previous value plus one */
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'`'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_SCOPE
argument_list|,
literal|"D scoping operator may not be used in "
literal|"an enumerator name (%s)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the enumerator is being assigned a value, cook and check the node 	 * and then free it after we get the value.  We also permit references 	 * to identifiers which are previously defined enumerators in the type. 	 */
if|if
condition|(
name|dnp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dnp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_IDENT
operator|||
name|ctf_enum_value
argument_list|(
name|dsp
operator|->
name|ds_ctfp
argument_list|,
name|dsp
operator|->
name|ds_type
argument_list|,
name|dnp
operator|->
name|dn_string
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dnp
operator|=
name|dt_node_cook
argument_list|(
name|dnp
argument_list|,
name|DT_IDFLG_REF
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_kind
operator|!=
name|DT_NODE_INT
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_ENCONST
argument_list|,
literal|"enumerator '%s' must "
literal|"be assigned to an integral constant "
literal|"expression\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intmax_t
operator|)
name|dnp
operator|->
name|dn_value
operator|>
name|INT_MAX
operator|||
operator|(
name|intmax_t
operator|)
name|dnp
operator|->
name|dn_value
operator|<
name|INT_MIN
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_ENOFLOW
argument_list|,
literal|"enumerator '%s' value "
literal|"overflows INT_MAX (%d)\n"
argument_list|,
name|name
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
operator|(
name|int
operator|)
name|dnp
operator|->
name|dn_value
expr_stmt|;
block|}
name|dt_node_free
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctf_add_enumerator
argument_list|(
name|dsp
operator|->
name|ds_ctfp
argument_list|,
name|dsp
operator|->
name|ds_type
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
operator|==
name|CTF_ERR
operator|||
name|ctf_update
argument_list|(
name|dsp
operator|->
name|ds_ctfp
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to define enumerator '%s': %s\n"
argument_list|,
name|name
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dsp
operator|->
name|ds_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dsp
operator|->
name|ds_enumval
operator|=
name|value
expr_stmt|;
comment|/* save most recent value */
comment|/* 	 * If the enumerator name matches an identifier in the global scope, 	 * flag this as an error.  We only do this for "D" enumerators to 	 * prevent "C" header file enumerators from conflicting with the ever- 	 * growing list of D built-in global variables and inlines.  If a "C" 	 * enumerator conflicts with a global identifier, we add the enumerator 	 * but do not insert a corresponding inline (i.e. the D variable wins). 	 */
if|if
condition|(
name|dt_idstack_lookup
argument_list|(
operator|&
name|yypcb
operator|->
name|pcb_globals
argument_list|,
name|name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dsp
operator|->
name|ds_ctfp
operator|==
name|dtp
operator|->
name|dt_ddefs
operator|->
name|dm_ctfp
condition|)
block|{
name|xyerror
argument_list|(
name|D_DECL_IDRED
argument_list|,
literal|"identifier redeclared: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
block|}
name|dt_dprintf
argument_list|(
literal|"add global enumerator %s = %d\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|idp
operator|=
name|dt_idhash_insert
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|,
name|name
argument_list|,
name|DT_IDENT_ENUM
argument_list|,
name|DT_IDFLG_INLINE
operator||
name|DT_IDFLG_REF
argument_list|,
literal|0
argument_list|,
name|_dtrace_defattr
argument_list|,
literal|0
argument_list|,
operator|&
name|dt_idops_inline
argument_list|,
name|NULL
argument_list|,
name|dtp
operator|->
name|dt_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|yyintprefix
operator|=
literal|0
expr_stmt|;
name|yyintsuffix
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|yyintdecimal
operator|=
literal|0
expr_stmt|;
name|dnp
operator|=
name|dt_node_int
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|dt_node_type_assign
argument_list|(
name|dnp
argument_list|,
name|dsp
operator|->
name|ds_ctfp
argument_list|,
name|dsp
operator|->
name|ds_type
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_idnode_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the INT node from the node allocation list and store it in 	 * din_list and din_root so it persists with and is freed by the ident. 	 */
name|assert
argument_list|(
name|yypcb
operator|->
name|pcb_list
operator|==
name|dnp
argument_list|)
expr_stmt|;
name|yypcb
operator|->
name|pcb_list
operator|=
name|dnp
operator|->
name|dn_link
expr_stmt|;
name|dnp
operator|->
name|dn_link
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|inp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_idnode_t
argument_list|)
argument_list|)
expr_stmt|;
name|inp
operator|->
name|din_list
operator|=
name|dnp
expr_stmt|;
name|inp
operator|->
name|din_root
operator|=
name|dnp
expr_stmt|;
name|idp
operator|->
name|di_iarg
operator|=
name|inp
expr_stmt|;
name|idp
operator|->
name|di_ctfp
operator|=
name|dsp
operator|->
name|ds_ctfp
expr_stmt|;
name|idp
operator|->
name|di_type
operator|=
name|dsp
operator|->
name|ds_type
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up the type corresponding to the specified decl stack.  The scoping of  * the underlying type names is handled by dt_type_lookup().  We build up the  * name from the specified string and prefixes and then lookup the type.  If  * we fail, an errmsg is saved and the caller must abort with EDT_COMPILER.  */
end_comment

begin_function
name|int
name|dt_decl_type
parameter_list|(
name|dt_decl_t
modifier|*
name|ddp
parameter_list|,
name|dtrace_typeinfo_t
modifier|*
name|tip
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
name|ctf_arinfo_t
name|r
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|uint_t
name|flag
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|tip
operator|->
name|dtt_flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Based on our current #include depth and decl stack depth, determine 	 * which dynamic CTF module and scope to use when adding any new types. 	 */
name|dmp
operator|=
name|yypcb
operator|->
name|pcb_idepth
condition|?
name|dtp
operator|->
name|dt_cdefs
else|:
name|dtp
operator|->
name|dt_ddefs
expr_stmt|;
name|flag
operator|=
name|yypcb
operator|->
name|pcb_dstack
operator|.
name|ds_next
condition|?
name|CTF_ADD_NONROOT
else|:
name|CTF_ADD_ROOT
expr_stmt|;
if|if
condition|(
name|ddp
operator|->
name|dd_attr
operator|&
name|DT_DA_USER
condition|)
name|tip
operator|->
name|dtt_flags
operator|=
name|DTT_FL_USER
expr_stmt|;
comment|/* 	 * If we have already cached a CTF type for this decl, then we just 	 * return the type information for the cached type. 	 */
if|if
condition|(
name|ddp
operator|->
name|dd_ctfp
operator|!=
name|NULL
operator|&&
operator|(
name|dmp
operator|=
name|dt_module_lookup_by_ctf
argument_list|(
name|dtp
argument_list|,
name|ddp
operator|->
name|dd_ctfp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|tip
operator|->
name|dtt_object
operator|=
name|dmp
operator|->
name|dm_name
expr_stmt|;
name|tip
operator|->
name|dtt_ctfp
operator|=
name|ddp
operator|->
name|dd_ctfp
expr_stmt|;
name|tip
operator|->
name|dtt_type
operator|=
name|ddp
operator|->
name|dd_type
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Currently CTF treats all function pointers identically.  We cache a 	 * representative ID of kind CTF_K_FUNCTION and just return that type. 	 * If we want to support full function declarations, dd_next refers to 	 * the declaration of the function return type, and the parameter list 	 * should be parsed and hung off a new pointer inside of this decl. 	 */
if|if
condition|(
name|ddp
operator|->
name|dd_kind
operator|==
name|CTF_K_FUNCTION
condition|)
block|{
name|tip
operator|->
name|dtt_object
operator|=
name|dtp
operator|->
name|dt_ddefs
operator|->
name|dm_name
expr_stmt|;
name|tip
operator|->
name|dtt_ctfp
operator|=
name|DT_FUNC_CTFP
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|tip
operator|->
name|dtt_type
operator|=
name|DT_FUNC_TYPE
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the decl is a pointer, resolve the rest of the stack by calling 	 * dt_decl_type() recursively and then compute a pointer to the result. 	 * Similar to the code above, we return a cached id for function ptrs. 	 */
if|if
condition|(
name|ddp
operator|->
name|dd_kind
operator|==
name|CTF_K_POINTER
condition|)
block|{
if|if
condition|(
name|ddp
operator|->
name|dd_next
operator|->
name|dd_kind
operator|==
name|CTF_K_FUNCTION
condition|)
block|{
name|tip
operator|->
name|dtt_object
operator|=
name|dtp
operator|->
name|dt_ddefs
operator|->
name|dm_name
expr_stmt|;
name|tip
operator|->
name|dtt_ctfp
operator|=
name|DT_FPTR_CTFP
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|tip
operator|->
name|dtt_type
operator|=
name|DT_FPTR_TYPE
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|dt_decl_type
argument_list|(
name|ddp
operator|->
name|dd_next
argument_list|,
name|tip
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|rv
operator|=
name|dt_type_pointer
argument_list|(
name|tip
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|xywarn
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"cannot find type: %s*: %s\n"
argument_list|,
name|dt_type_name
argument_list|(
name|tip
operator|->
name|dtt_ctfp
argument_list|,
name|tip
operator|->
name|dtt_type
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|,
name|ctf_errmsg
argument_list|(
name|dtp
operator|->
name|dt_ctferr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
comment|/* 	 * If the decl is an array, we must find the base type and then call 	 * dt_decl_type() recursively and then build an array of the result. 	 * The C and D multi-dimensional array syntax requires that consecutive 	 * array declarations be processed from right-to-left (i.e. top-down 	 * from the perspective of the declaration stack).  For example, an 	 * array declaration such as int x[3][5] is stored on the stack as: 	 * 	 * (bottom) NULL<- ( INT "int" )<- ( ARR [3] )<- ( ARR [5] ) (top) 	 * 	 * but means that x is declared to be an array of 3 objects each of 	 * which is an array of 5 integers, or in CTF representation: 	 * 	 * type T1:( content=int, nelems=5 ) type T2:( content=T1, nelems=3 ) 	 * 	 * For more details, refer to K&R[5.7] and ISO C 6.5.2.1.  Rather than 	 * overcomplicate the implementation of dt_decl_type(), we push array 	 * declarations down into the stack in dt_decl_array(), above, so that 	 * by the time dt_decl_type() is called, the decl stack looks like: 	 * 	 * (bottom) NULL<- ( INT "int" )<- ( ARR [5] )<- ( ARR [3] ) (top) 	 * 	 * which permits a straightforward recursive descent of the decl stack 	 * to build the corresponding CTF type tree in the appropriate order. 	 */
if|if
condition|(
name|ddp
operator|->
name|dd_kind
operator|==
name|CTF_K_ARRAY
condition|)
block|{
comment|/* 		 * If the array decl has a parameter list associated with it, 		 * this is an associative array declaration: return<DYN>. 		 */
if|if
condition|(
name|ddp
operator|->
name|dd_node
operator|!=
name|NULL
operator|&&
name|ddp
operator|->
name|dd_node
operator|->
name|dn_kind
operator|==
name|DT_NODE_TYPE
condition|)
block|{
name|tip
operator|->
name|dtt_object
operator|=
name|dtp
operator|->
name|dt_ddefs
operator|->
name|dm_name
expr_stmt|;
name|tip
operator|->
name|dtt_ctfp
operator|=
name|DT_DYN_CTFP
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|tip
operator|->
name|dtt_type
operator|=
name|DT_DYN_TYPE
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|dt_decl_type
argument_list|(
name|ddp
operator|->
name|dd_next
argument_list|,
name|tip
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
comment|/* 		 * If the array base type is not defined in the target 		 * container or its parent, copy the type to the target 		 * container and reset dtt_ctfp and dtt_type to the copy. 		 */
if|if
condition|(
name|tip
operator|->
name|dtt_ctfp
operator|!=
name|dmp
operator|->
name|dm_ctfp
operator|&&
name|tip
operator|->
name|dtt_ctfp
operator|!=
name|ctf_parent_file
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
condition|)
block|{
name|tip
operator|->
name|dtt_type
operator|=
name|ctf_add_type
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|tip
operator|->
name|dtt_ctfp
argument_list|,
name|tip
operator|->
name|dtt_type
argument_list|)
expr_stmt|;
name|tip
operator|->
name|dtt_ctfp
operator|=
name|dmp
operator|->
name|dm_ctfp
expr_stmt|;
if|if
condition|(
name|tip
operator|->
name|dtt_type
operator|==
name|CTF_ERR
operator|||
name|ctf_update
argument_list|(
name|tip
operator|->
name|dtt_ctfp
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xywarn
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to copy type: %s\n"
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|tip
operator|->
name|dtt_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 		 * The array index type is irrelevant in C and D: just set it 		 * to "long" for all array types that we create on-the-fly. 		 */
name|r
operator|.
name|ctr_contents
operator|=
name|tip
operator|->
name|dtt_type
expr_stmt|;
name|r
operator|.
name|ctr_index
operator|=
name|ctf_lookup_by_name
argument_list|(
name|tip
operator|->
name|dtt_ctfp
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
name|r
operator|.
name|ctr_nelems
operator|=
name|ddp
operator|->
name|dd_node
condition|?
operator|(
name|uint_t
operator|)
name|ddp
operator|->
name|dd_node
operator|->
name|dn_value
else|:
literal|0
expr_stmt|;
name|tip
operator|->
name|dtt_object
operator|=
name|dmp
operator|->
name|dm_name
expr_stmt|;
name|tip
operator|->
name|dtt_ctfp
operator|=
name|dmp
operator|->
name|dm_ctfp
expr_stmt|;
name|tip
operator|->
name|dtt_type
operator|=
name|ctf_add_array
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|->
name|dtt_type
operator|==
name|CTF_ERR
operator|||
name|ctf_update
argument_list|(
name|tip
operator|->
name|dtt_ctfp
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xywarn
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to create array type: %s\n"
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|tip
operator|->
name|dtt_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Allocate space for the type name and enough space for the maximum 	 * additional text ("unsigned long long \0" requires 20 more bytes). 	 */
name|name
operator|=
name|alloca
argument_list|(
name|ddp
operator|->
name|dd_name
condition|?
name|strlen
argument_list|(
name|ddp
operator|->
name|dd_name
argument_list|)
operator|+
literal|20
else|:
literal|20
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|ddp
operator|->
name|dd_kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
if|if
condition|(
name|ddp
operator|->
name|dd_attr
operator|&
name|DT_DA_SIGNED
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"signed "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddp
operator|->
name|dd_attr
operator|&
name|DT_DA_UNSIGNED
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"unsigned "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddp
operator|->
name|dd_attr
operator|&
name|DT_DA_SHORT
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"short "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddp
operator|->
name|dd_attr
operator|&
name|DT_DA_LONG
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"long "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddp
operator|->
name|dd_attr
operator|&
name|DT_DA_LONGLONG
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"long long "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddp
operator|->
name|dd_attr
operator|==
literal|0
operator|&&
name|ddp
operator|->
name|dd_name
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_UNION
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ENUM
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"enum "
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_TYPEDEF
case|:
break|break;
default|default:
name|xywarn
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"internal error -- "
literal|"bad decl kind %u\n"
argument_list|,
name|ddp
operator|->
name|dd_kind
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Add dd_name unless a short, long, or long long is explicitly 	 * suffixed by int.  We use the C/CTF canonical names for integers. 	 */
if|if
condition|(
name|ddp
operator|->
name|dd_name
operator|!=
name|NULL
operator|&&
operator|(
name|ddp
operator|->
name|dd_kind
operator|!=
name|CTF_K_INTEGER
operator|||
operator|(
name|ddp
operator|->
name|dd_attr
operator|&
operator|(
name|DT_DA_SHORT
operator||
name|DT_DA_LONG
operator||
name|DT_DA_LONGLONG
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
name|ddp
operator|->
name|dd_name
argument_list|)
expr_stmt|;
comment|/* 	 * Lookup the type.  If we find it, we're done.  Otherwise create a 	 * forward tag for the type if it is a struct, union, or enum.  If 	 * we can't find it and we can't create a tag, return failure. 	 */
if|if
condition|(
operator|(
name|rv
operator|=
name|dt_type_lookup
argument_list|(
name|name
argument_list|,
name|tip
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
switch|switch
condition|(
name|ddp
operator|->
name|dd_kind
condition|)
block|{
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
case|case
name|CTF_K_ENUM
case|:
name|type
operator|=
name|ctf_add_forward
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|flag
argument_list|,
name|ddp
operator|->
name|dd_name
argument_list|,
name|ddp
operator|->
name|dd_kind
argument_list|)
expr_stmt|;
break|break;
default|default:
name|xywarn
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to resolve type %s: %s\n"
argument_list|,
name|name
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|CTF_ERR
operator|||
name|ctf_update
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xywarn
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to add forward tag for %s: %s\n"
argument_list|,
name|name
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ddp
operator|->
name|dd_ctfp
operator|=
name|dmp
operator|->
name|dm_ctfp
expr_stmt|;
name|ddp
operator|->
name|dd_type
operator|=
name|type
expr_stmt|;
name|tip
operator|->
name|dtt_object
operator|=
name|dmp
operator|->
name|dm_name
expr_stmt|;
name|tip
operator|->
name|dtt_ctfp
operator|=
name|dmp
operator|->
name|dm_ctfp
expr_stmt|;
name|tip
operator|->
name|dtt_type
operator|=
name|type
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_scope_create
parameter_list|(
name|dt_scope_t
modifier|*
name|dsp
parameter_list|)
block|{
name|dsp
operator|->
name|ds_decl
operator|=
name|NULL
expr_stmt|;
name|dsp
operator|->
name|ds_next
operator|=
name|NULL
expr_stmt|;
name|dsp
operator|->
name|ds_ident
operator|=
name|NULL
expr_stmt|;
name|dsp
operator|->
name|ds_ctfp
operator|=
name|NULL
expr_stmt|;
name|dsp
operator|->
name|ds_type
operator|=
name|CTF_ERR
expr_stmt|;
name|dsp
operator|->
name|ds_class
operator|=
name|DT_DC_DEFAULT
expr_stmt|;
name|dsp
operator|->
name|ds_enumval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_scope_destroy
parameter_list|(
name|dt_scope_t
modifier|*
name|dsp
parameter_list|)
block|{
name|dt_scope_t
modifier|*
name|nsp
decl_stmt|;
for|for
control|(
init|;
name|dsp
operator|!=
name|NULL
condition|;
name|dsp
operator|=
name|nsp
control|)
block|{
name|dt_decl_free
argument_list|(
name|dsp
operator|->
name|ds_decl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
name|nsp
operator|=
name|dsp
operator|->
name|ds_next
expr_stmt|;
if|if
condition|(
name|dsp
operator|!=
operator|&
name|yypcb
operator|->
name|pcb_dstack
condition|)
name|free
argument_list|(
name|dsp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dt_scope_push
parameter_list|(
name|ctf_file_t
modifier|*
name|ctfp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
name|dt_scope_t
modifier|*
name|rsp
init|=
operator|&
name|yypcb
operator|->
name|pcb_dstack
decl_stmt|;
name|dt_scope_t
modifier|*
name|dsp
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_scope_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dsp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|dsp
operator|->
name|ds_decl
operator|=
name|rsp
operator|->
name|ds_decl
expr_stmt|;
name|dsp
operator|->
name|ds_next
operator|=
name|rsp
operator|->
name|ds_next
expr_stmt|;
name|dsp
operator|->
name|ds_ident
operator|=
name|rsp
operator|->
name|ds_ident
expr_stmt|;
name|dsp
operator|->
name|ds_ctfp
operator|=
name|ctfp
expr_stmt|;
name|dsp
operator|->
name|ds_type
operator|=
name|type
expr_stmt|;
name|dsp
operator|->
name|ds_class
operator|=
name|rsp
operator|->
name|ds_class
expr_stmt|;
name|dsp
operator|->
name|ds_enumval
operator|=
name|rsp
operator|->
name|ds_enumval
expr_stmt|;
name|dt_scope_create
argument_list|(
name|rsp
argument_list|)
expr_stmt|;
name|rsp
operator|->
name|ds_next
operator|=
name|dsp
expr_stmt|;
block|}
end_function

begin_function
name|dt_decl_t
modifier|*
name|dt_scope_pop
parameter_list|(
name|void
parameter_list|)
block|{
name|dt_scope_t
modifier|*
name|rsp
init|=
operator|&
name|yypcb
operator|->
name|pcb_dstack
decl_stmt|;
name|dt_scope_t
modifier|*
name|dsp
init|=
name|rsp
operator|->
name|ds_next
decl_stmt|;
if|if
condition|(
name|dsp
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOSCOPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsp
operator|->
name|ds_ctfp
operator|!=
name|NULL
operator|&&
name|ctf_update
argument_list|(
name|dsp
operator|->
name|ds_ctfp
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"failed to update type definitions: %s\n"
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dsp
operator|->
name|ds_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_decl_free
argument_list|(
name|rsp
operator|->
name|ds_decl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rsp
operator|->
name|ds_ident
argument_list|)
expr_stmt|;
name|rsp
operator|->
name|ds_decl
operator|=
name|dsp
operator|->
name|ds_decl
expr_stmt|;
name|rsp
operator|->
name|ds_next
operator|=
name|dsp
operator|->
name|ds_next
expr_stmt|;
name|rsp
operator|->
name|ds_ident
operator|=
name|dsp
operator|->
name|ds_ident
expr_stmt|;
name|rsp
operator|->
name|ds_ctfp
operator|=
name|dsp
operator|->
name|ds_ctfp
expr_stmt|;
name|rsp
operator|->
name|ds_type
operator|=
name|dsp
operator|->
name|ds_type
expr_stmt|;
name|rsp
operator|->
name|ds_class
operator|=
name|dsp
operator|->
name|ds_class
expr_stmt|;
name|rsp
operator|->
name|ds_enumval
operator|=
name|dsp
operator|->
name|ds_enumval
expr_stmt|;
name|free
argument_list|(
name|dsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rsp
operator|->
name|ds_decl
operator|)
return|;
block|}
end_function

end_unit

