begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  * Copyright (c) 2013 by Delphix. All rights reserved.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ABS
parameter_list|(
name|a
parameter_list|)
value|((a)< 0 ? -(a) : (a))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<dt_printf.h>
end_include

begin_include
include|#
directive|include
file|<dt_string.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_addr
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dt_node_is_pointer
argument_list|(
name|dnp
argument_list|)
operator|||
name|dt_node_is_integer
argument_list|(
name|dnp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_kaddr
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dt_node_is_pointer
argument_list|(
name|dnp
argument_list|)
operator|||
name|dt_node_is_integer
argument_list|(
name|dnp
argument_list|)
operator|||
name|dt_node_is_symaddr
argument_list|(
name|dnp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_uaddr
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|pfv
operator|->
name|pfv_dtp
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
init|=
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"target"
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt_node_is_usymaddr
argument_list|(
name|dnp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|idp
operator|==
name|NULL
operator|||
name|idp
operator|->
name|di_id
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|dt_node_is_pointer
argument_list|(
name|dnp
argument_list|)
operator|||
name|dt_node_is_integer
argument_list|(
name|dnp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_stack
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dt_node_is_stack
argument_list|(
name|dnp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_time
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dt_node_is_integer
argument_list|(
name|dnp
argument_list|)
operator|&&
name|dt_node_type_size
argument_list|(
name|dnp
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_str
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ctfp
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|ctf_arinfo_t
name|r
decl_stmt|;
name|ctf_id_t
name|base
decl_stmt|;
name|uint_t
name|kind
decl_stmt|;
if|if
condition|(
name|dt_node_is_string
argument_list|(
name|dnp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ctfp
operator|=
name|dnp
operator|->
name|dn_ctfp
expr_stmt|;
name|base
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|kind
operator|==
name|CTF_K_ARRAY
operator|&&
name|ctf_array_info
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|,
operator|&
name|r
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|base
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|r
operator|.
name|ctr_contents
argument_list|)
operator|)
operator|!=
name|CTF_ERR
operator|&&
name|ctf_type_encoding
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
operator|&&
name|IS_CHAR
argument_list|(
name|e
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_wstr
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_id_t
name|base
init|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
decl_stmt|;
name|uint_t
name|kind
init|=
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|ctf_arinfo_t
name|r
decl_stmt|;
return|return
operator|(
name|kind
operator|==
name|CTF_K_ARRAY
operator|&&
name|ctf_array_info
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|,
operator|&
name|r
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|base
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|r
operator|.
name|ctr_contents
argument_list|)
operator|)
operator|!=
name|CTF_ERR
operator|&&
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|)
operator|==
name|CTF_K_INTEGER
operator|&&
name|ctf_type_encoding
argument_list|(
name|ctfp
argument_list|,
name|base
argument_list|,
operator|&
name|e
argument_list|)
operator|==
literal|0
operator|&&
name|e
operator|.
name|cte_bits
operator|==
literal|32
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_csi
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dt_node_is_integer
argument_list|(
name|dnp
argument_list|)
operator|&&
name|dt_node_type_size
argument_list|(
name|dnp
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_fp
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dt_node_is_float
argument_list|(
name|dnp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_xint
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dt_node_is_integer
argument_list|(
name|dnp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_dint
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
condition|)
name|pfd
operator|->
name|pfd_fmt
index|[
name|strlen
argument_list|(
name|pfd
operator|->
name|pfd_fmt
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'i'
expr_stmt|;
else|else
name|pfd
operator|->
name|pfd_fmt
index|[
name|strlen
argument_list|(
name|pfd
operator|->
name|pfd_fmt
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'u'
expr_stmt|;
return|return
operator|(
name|dt_node_is_integer
argument_list|(
name|dnp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_xshort
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_id_t
name|type
init|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
return|return
operator|(
name|ctf_type_name
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"short"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"signed short"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"unsigned short"
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_xlong
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_id_t
name|type
init|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
return|return
operator|(
name|ctf_type_name
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"long"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"signed long"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"unsigned long"
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_xlonglong
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_id_t
name|type
init|=
name|dnp
operator|->
name|dn_type
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|ctf_type_name
argument_list|(
name|ctfp
argument_list|,
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"long long"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"signed long long"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"unsigned long long"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If the type used for %llx or %llX is not an [unsigned] long long, we 	 * also permit it to be a [u]int64_t or any typedef thereof.  We know 	 * that these typedefs are guaranteed to work with %ll[xX] in either 	 * compilation environment even though they alias to "long" in LP64. 	 */
while|while
condition|(
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
operator|==
name|CTF_K_TYPEDEF
condition|)
block|{
if|if
condition|(
name|ctf_type_name
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"int64_t"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"uint64_t"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|type
operator|=
name|ctf_type_reference
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfcheck_type
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|ctf_type_compat
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|ctf_type_resolve
argument_list|(
name|dnp
operator|->
name|dn_ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
argument_list|,
name|pfd
operator|->
name|pfd_conv
operator|->
name|pfc_dctfp
argument_list|,
name|pfd
operator|->
name|pfd_conv
operator|->
name|pfc_dtype
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_sint
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|unormal
parameter_list|)
block|{
name|int64_t
name|normal
init|=
operator|(
name|int64_t
operator|)
name|unormal
decl_stmt|;
name|int32_t
name|n
init|=
operator|(
name|int32_t
operator|)
name|normal
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
case|:
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
operator|(
name|int32_t
operator|)
operator|*
operator|(
operator|(
name|int8_t
operator|*
operator|)
name|addr
operator|)
operator|/
name|n
argument_list|)
operator|)
return|;
case|case
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
case|:
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
operator|(
name|int32_t
operator|)
operator|*
operator|(
operator|(
name|int16_t
operator|*
operator|)
name|addr
operator|)
operator|/
name|n
argument_list|)
operator|)
return|;
case|case
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
case|:
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
operator|*
operator|(
operator|(
name|int32_t
operator|*
operator|)
name|addr
operator|)
operator|/
name|n
argument_list|)
operator|)
return|;
case|case
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
case|:
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
operator|*
operator|(
operator|(
name|int64_t
operator|*
operator|)
name|addr
operator|)
operator|/
name|normal
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_uint
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|uint32_t
name|n
init|=
operator|(
name|uint32_t
operator|)
name|normal
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
case|:
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
operator|(
name|uint32_t
operator|)
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|addr
operator|)
operator|/
name|n
argument_list|)
operator|)
return|;
case|case
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
case|:
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
operator|(
name|uint32_t
operator|)
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|addr
operator|)
operator|/
name|n
argument_list|)
operator|)
return|;
case|case
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
case|:
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|addr
operator|)
operator|/
name|n
argument_list|)
operator|)
return|;
case|case
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
case|:
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
operator|/
name|normal
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pfprint_dint
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_SIGNED
condition|)
return|return
operator|(
name|pfprint_sint
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|pfd
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|normal
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|pfprint_uint
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|pfd
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|normal
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_fp
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|double
name|n
init|=
operator|(
name|double
operator|)
name|normal
decl_stmt|;
name|long
name|double
name|ldn
init|=
operator|(
name|long
name|double
operator|)
name|normal
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|float
argument_list|)
case|:
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
operator|(
name|double
operator|)
operator|*
operator|(
operator|(
name|float
operator|*
operator|)
name|addr
operator|)
operator|/
name|n
argument_list|)
operator|)
return|;
case|case
sizeof|sizeof
argument_list|(
name|double
argument_list|)
case|:
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
operator|*
operator|(
operator|(
name|double
operator|*
operator|)
name|addr
operator|)
operator|/
name|n
argument_list|)
operator|)
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__arm__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__powerpc__
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|__mips__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__riscv
argument_list|)
case|case
expr|sizeof
operator|(
name|long
name|double
operator|)
case|:
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
operator|*
operator|(
operator|(
name|long
name|double
operator|*
operator|)
name|addr
operator|)
operator|/
name|ldn
argument_list|)
operator|)
return|;
endif|#
directive|endif
default|default:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_addr
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
init|=
literal|256
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
case|:
name|val
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
case|:
name|val
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
block|}
do|do
block|{
name|n
operator|=
name|len
expr_stmt|;
name|s
operator|=
name|alloca
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|len
operator|=
name|dtrace_addr2str
argument_list|(
name|dtp
argument_list|,
name|val
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
operator|)
operator|>
name|n
condition|)
do|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_mod
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
return|return
operator|(
name|dt_print_mod
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
operator|(
name|caddr_t
operator|)
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_umod
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
return|return
operator|(
name|dt_print_umod
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
operator|(
name|caddr_t
operator|)
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_uaddr
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
init|=
literal|256
decl_stmt|;
name|uint64_t
name|val
decl_stmt|,
name|pid
init|=
literal|0
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
init|=
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"target"
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
case|:
name|val
operator|=
operator|(
name|u_longlong_t
operator|)
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
case|:
name|val
operator|=
operator|(
name|u_longlong_t
operator|)
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|2
case|:
name|pid
operator|=
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|addr
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|addr
operator|)
index|[
literal|1
index|]
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
operator|&&
name|dtp
operator|->
name|dt_vector
operator|==
name|NULL
operator|&&
name|idp
operator|!=
name|NULL
condition|)
name|pid
operator|=
name|idp
operator|->
name|di_id
expr_stmt|;
do|do
block|{
name|n
operator|=
name|len
expr_stmt|;
name|s
operator|=
name|alloca
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|len
operator|=
name|dtrace_uaddr2str
argument_list|(
name|dtp
argument_list|,
name|pid
argument_list|,
name|val
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
operator|)
operator|>
name|n
condition|)
do|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_stack
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|vaddr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|int
name|width
decl_stmt|;
name|dtrace_optval_t
name|saved
init|=
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_STACKINDENT
index|]
decl_stmt|;
specifier|const
name|dtrace_recdesc_t
modifier|*
name|rec
init|=
name|pfd
operator|->
name|pfd_rec
decl_stmt|;
name|caddr_t
name|addr
init|=
operator|(
name|caddr_t
operator|)
name|vaddr
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* 	 * We have stashed the value of the STACKINDENT option, and we will 	 * now override it for the purposes of formatting the stack.  If the 	 * field has been specified as left-aligned (i.e. (%-#), we set the 	 * indentation to be the width.  This is a slightly odd semantic, but 	 * it's useful functionality -- and it's slightly odd to begin with to 	 * be using a single format specifier to be formatting multiple lines 	 * of text... 	 */
if|if
condition|(
name|pfd
operator|->
name|pfd_dynwidth
operator|<
literal|0
condition|)
block|{
name|assert
argument_list|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_DYNWIDTH
argument_list|)
expr_stmt|;
name|width
operator|=
operator|-
name|pfd
operator|->
name|pfd_dynwidth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_LEFT
condition|)
block|{
name|width
operator|=
name|pfd
operator|->
name|pfd_dynwidth
condition|?
name|pfd
operator|->
name|pfd_dynwidth
else|:
name|pfd
operator|->
name|pfd_width
expr_stmt|;
block|}
else|else
block|{
name|width
operator|=
literal|0
expr_stmt|;
block|}
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_STACKINDENT
index|]
operator|=
name|width
expr_stmt|;
switch|switch
condition|(
name|rec
operator|->
name|dtrd_action
condition|)
block|{
case|case
name|DTRACEACT_USTACK
case|:
case|case
name|DTRACEACT_JSTACK
case|:
name|err
operator|=
name|dt_print_ustack
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|addr
argument_list|,
name|rec
operator|->
name|dtrd_arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTRACEACT_STACK
case|:
name|err
operator|=
name|dt_print_stack
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|addr
argument_list|,
name|rec
operator|->
name|dtrd_arg
argument_list|,
name|rec
operator|->
name|dtrd_size
operator|/
name|rec
operator|->
name|dtrd_arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_STACKINDENT
index|]
operator|=
name|saved
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_time
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|char
name|src
index|[
literal|32
index|]
decl_stmt|,
name|buf
index|[
literal|32
index|]
decl_stmt|,
modifier|*
name|dst
init|=
name|buf
decl_stmt|;
name|hrtime_t
name|time
init|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
decl_stmt|;
name|time_t
name|sec
init|=
call|(
name|time_t
call|)
argument_list|(
name|time
operator|/
name|NANOSEC
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * ctime(3C) returns a string of the form "Dec  3 17:20:00 1973\n\0". 	 * Below, we turn this into the canonical adb/mdb /[yY] format, 	 * "1973 Dec  3 17:20:00". 	 */
ifdef|#
directive|ifdef
name|illumos
operator|(
name|void
operator|)
name|ctime_r
argument_list|(
operator|&
name|sec
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|ctime_r
argument_list|(
operator|&
name|sec
argument_list|,
name|src
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Place the 4-digit year at the head of the string... 	 */
for|for
control|(
name|i
operator|=
literal|20
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
operator|*
name|dst
operator|++
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * ...and follow it with the remainder (month, day, hh:mm:ss). 	 */
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
literal|19
condition|;
name|i
operator|++
control|)
operator|*
name|dst
operator|++
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This prints the time in RFC 822 standard form.  This is useful for emitting  * notions of time that are consumed by standard tools (e.g., as part of an  * RSS feed).  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_time822
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|hrtime_t
name|time
init|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
decl_stmt|;
name|time_t
name|sec
init|=
call|(
name|time_t
call|)
argument_list|(
name|time
operator|/
name|NANOSEC
argument_list|)
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|localtime_r
argument_list|(
operator|&
name|sec
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%a, %d %b %G %T %Z"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_port
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|uint16_t
name|port
init|=
name|htons
argument_list|(
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|addr
operator|)
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|servent
modifier|*
name|sv
decl_stmt|,
name|res
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
operator|(
name|sv
operator|=
name|getservbyport_r
argument_list|(
name|port
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
else|#
directive|else
if|if
condition|(
name|getservbyport_r
argument_list|(
name|port
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|sv
argument_list|)
operator|>
literal|0
condition|)
endif|#
directive|endif
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|sv
operator|->
name|s_name
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|addr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_inetaddr
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|alloca
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|struct
name|hostent
modifier|*
name|host
decl_stmt|,
name|res
decl_stmt|;
name|char
name|inetaddr
index|[
name|NS_IN6ADDRSZ
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|e
decl_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|s
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
operator|&&
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|s
argument_list|,
name|inetaddr
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
operator|(
name|host
operator|=
name|gethostbyaddr_r
argument_list|(
name|inetaddr
argument_list|,
name|NS_INADDRSZ
argument_list|,
name|AF_INET
argument_list|,
operator|&
name|res
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|e
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
else|#
directive|else
if|if
condition|(
name|gethostbyaddr_r
argument_list|(
name|inetaddr
argument_list|,
name|NS_INADDRSZ
argument_list|,
name|AF_INET
argument_list|,
operator|&
name|res
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|host
argument_list|,
operator|&
name|e
argument_list|)
operator|>
literal|0
condition|)
endif|#
directive|endif
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|host
operator|->
name|h_name
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|s
argument_list|,
name|inetaddr
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|host
operator|=
name|getipnodebyaddr
argument_list|(
name|inetaddr
argument_list|,
name|NS_IN6ADDRSZ
argument_list|,
name|AF_INET6
argument_list|,
operator|&
name|e
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|host
operator|->
name|h_name
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_cstr
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|alloca
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|s
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_wstr
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|wchar_t
modifier|*
name|ws
init|=
name|alloca
argument_list|(
name|size
operator|+
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
name|ws
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ws
index|[
name|size
operator|/
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|ws
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_estr
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|strchr2esc
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
name|n
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pfprint_echr
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
case|:
name|c
operator|=
operator|*
operator|(
name|int8_t
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
case|:
name|c
operator|=
operator|*
operator|(
name|int16_t
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
case|:
name|c
operator|=
operator|*
operator|(
name|int32_t
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|pfprint_estr
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|pfd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|,
name|normal
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_pct
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%%"
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pfproto_xint
index|[]
init|=
literal|"char, short, int, long, or long long"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pfproto_csi
index|[]
init|=
literal|"char, short, or int"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pfproto_fp
index|[]
init|=
literal|"float, double, or long double"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pfproto_addr
index|[]
init|=
literal|"pointer or integer"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pfproto_uaddr
index|[]
init|=
literal|"pointer or integer (with -p/-c) or _usymaddr (without -p/-c)"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pfproto_cstr
index|[]
init|=
literal|"char [] or string (or use stringof)"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pfproto_wstr
index|[]
init|=
literal|"wchar_t []"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Printf format conversion dictionary.  This table should match the set of  * conversions offered by printf(3C), as well as some additional extensions.  * The second parameter is an ASCII string which is either an actual type  * name we should look up (if pfcheck_type is specified), or just a descriptive  * string of the types expected for use in error messages.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|dt_pfconv_t
name|_dtrace_conversions
index|[]
init|=
block|{
block|{
literal|"a"
block|,
literal|"s"
block|,
name|pfproto_addr
block|,
name|pfcheck_kaddr
block|,
name|pfprint_addr
block|}
block|,
block|{
literal|"A"
block|,
literal|"s"
block|,
name|pfproto_uaddr
block|,
name|pfcheck_uaddr
block|,
name|pfprint_uaddr
block|}
block|,
block|{
literal|"c"
block|,
literal|"c"
block|,
name|pfproto_csi
block|,
name|pfcheck_csi
block|,
name|pfprint_sint
block|}
block|,
block|{
literal|"C"
block|,
literal|"s"
block|,
name|pfproto_csi
block|,
name|pfcheck_csi
block|,
name|pfprint_echr
block|}
block|,
block|{
literal|"d"
block|,
literal|"d"
block|,
name|pfproto_xint
block|,
name|pfcheck_dint
block|,
name|pfprint_dint
block|}
block|,
block|{
literal|"e"
block|,
literal|"e"
block|,
name|pfproto_fp
block|,
name|pfcheck_fp
block|,
name|pfprint_fp
block|}
block|,
block|{
literal|"E"
block|,
literal|"E"
block|,
name|pfproto_fp
block|,
name|pfcheck_fp
block|,
name|pfprint_fp
block|}
block|,
block|{
literal|"f"
block|,
literal|"f"
block|,
name|pfproto_fp
block|,
name|pfcheck_fp
block|,
name|pfprint_fp
block|}
block|,
block|{
literal|"g"
block|,
literal|"g"
block|,
name|pfproto_fp
block|,
name|pfcheck_fp
block|,
name|pfprint_fp
block|}
block|,
block|{
literal|"G"
block|,
literal|"G"
block|,
name|pfproto_fp
block|,
name|pfcheck_fp
block|,
name|pfprint_fp
block|}
block|,
block|{
literal|"hd"
block|,
literal|"d"
block|,
literal|"short"
block|,
name|pfcheck_type
block|,
name|pfprint_sint
block|}
block|,
block|{
literal|"hi"
block|,
literal|"i"
block|,
literal|"short"
block|,
name|pfcheck_type
block|,
name|pfprint_sint
block|}
block|,
block|{
literal|"ho"
block|,
literal|"o"
block|,
literal|"unsigned short"
block|,
name|pfcheck_type
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"hu"
block|,
literal|"u"
block|,
literal|"unsigned short"
block|,
name|pfcheck_type
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"hx"
block|,
literal|"x"
block|,
literal|"short"
block|,
name|pfcheck_xshort
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"hX"
block|,
literal|"X"
block|,
literal|"short"
block|,
name|pfcheck_xshort
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"i"
block|,
literal|"i"
block|,
name|pfproto_xint
block|,
name|pfcheck_xint
block|,
name|pfprint_sint
block|}
block|,
block|{
literal|"I"
block|,
literal|"s"
block|,
name|pfproto_cstr
block|,
name|pfcheck_str
block|,
name|pfprint_inetaddr
block|}
block|,
block|{
literal|"k"
block|,
literal|"s"
block|,
literal|"stack"
block|,
name|pfcheck_stack
block|,
name|pfprint_stack
block|}
block|,
block|{
literal|"lc"
block|,
literal|"lc"
block|,
literal|"int"
block|,
name|pfcheck_type
block|,
name|pfprint_sint
block|}
block|,
comment|/* a.k.a. wint_t */
block|{
literal|"ld"
block|,
literal|"d"
block|,
literal|"long"
block|,
name|pfcheck_type
block|,
name|pfprint_sint
block|}
block|,
block|{
literal|"li"
block|,
literal|"i"
block|,
literal|"long"
block|,
name|pfcheck_type
block|,
name|pfprint_sint
block|}
block|,
block|{
literal|"lo"
block|,
literal|"o"
block|,
literal|"unsigned long"
block|,
name|pfcheck_type
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"lu"
block|,
literal|"u"
block|,
literal|"unsigned long"
block|,
name|pfcheck_type
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"ls"
block|,
literal|"ls"
block|,
name|pfproto_wstr
block|,
name|pfcheck_wstr
block|,
name|pfprint_wstr
block|}
block|,
block|{
literal|"lx"
block|,
literal|"x"
block|,
literal|"long"
block|,
name|pfcheck_xlong
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"lX"
block|,
literal|"X"
block|,
literal|"long"
block|,
name|pfcheck_xlong
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"lld"
block|,
literal|"d"
block|,
literal|"long long"
block|,
name|pfcheck_type
block|,
name|pfprint_sint
block|}
block|,
block|{
literal|"lli"
block|,
literal|"i"
block|,
literal|"long long"
block|,
name|pfcheck_type
block|,
name|pfprint_sint
block|}
block|,
block|{
literal|"llo"
block|,
literal|"o"
block|,
literal|"unsigned long long"
block|,
name|pfcheck_type
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"llu"
block|,
literal|"u"
block|,
literal|"unsigned long long"
block|,
name|pfcheck_type
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"llx"
block|,
literal|"x"
block|,
literal|"long long"
block|,
name|pfcheck_xlonglong
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"llX"
block|,
literal|"X"
block|,
literal|"long long"
block|,
name|pfcheck_xlonglong
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"Le"
block|,
literal|"e"
block|,
literal|"long double"
block|,
name|pfcheck_type
block|,
name|pfprint_fp
block|}
block|,
block|{
literal|"LE"
block|,
literal|"E"
block|,
literal|"long double"
block|,
name|pfcheck_type
block|,
name|pfprint_fp
block|}
block|,
block|{
literal|"Lf"
block|,
literal|"f"
block|,
literal|"long double"
block|,
name|pfcheck_type
block|,
name|pfprint_fp
block|}
block|,
block|{
literal|"Lg"
block|,
literal|"g"
block|,
literal|"long double"
block|,
name|pfcheck_type
block|,
name|pfprint_fp
block|}
block|,
block|{
literal|"LG"
block|,
literal|"G"
block|,
literal|"long double"
block|,
name|pfcheck_type
block|,
name|pfprint_fp
block|}
block|,
block|{
literal|"o"
block|,
literal|"o"
block|,
name|pfproto_xint
block|,
name|pfcheck_xint
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"p"
block|,
literal|"x"
block|,
name|pfproto_addr
block|,
name|pfcheck_addr
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"P"
block|,
literal|"s"
block|,
literal|"uint16_t"
block|,
name|pfcheck_type
block|,
name|pfprint_port
block|}
block|,
block|{
literal|"s"
block|,
literal|"s"
block|,
literal|"char [] or string (or use stringof)"
block|,
name|pfcheck_str
block|,
name|pfprint_cstr
block|}
block|,
block|{
literal|"S"
block|,
literal|"s"
block|,
name|pfproto_cstr
block|,
name|pfcheck_str
block|,
name|pfprint_estr
block|}
block|,
block|{
literal|"T"
block|,
literal|"s"
block|,
literal|"int64_t"
block|,
name|pfcheck_time
block|,
name|pfprint_time822
block|}
block|,
block|{
literal|"u"
block|,
literal|"u"
block|,
name|pfproto_xint
block|,
name|pfcheck_xint
block|,
name|pfprint_uint
block|}
block|,
ifdef|#
directive|ifdef
name|illumos
block|{
literal|"wc"
block|,
literal|"wc"
block|,
literal|"int"
block|,
name|pfcheck_type
block|,
name|pfprint_sint
block|}
block|,
comment|/* a.k.a. wchar_t */
block|{
literal|"ws"
block|,
literal|"ws"
block|,
name|pfproto_wstr
block|,
name|pfcheck_wstr
block|,
name|pfprint_wstr
block|}
block|,
else|#
directive|else
block|{
literal|"wc"
block|,
literal|"lc"
block|,
literal|"int"
block|,
name|pfcheck_type
block|,
name|pfprint_sint
block|}
block|,
comment|/* a.k.a. wchar_t */
block|{
literal|"ws"
block|,
literal|"ls"
block|,
name|pfproto_wstr
block|,
name|pfcheck_wstr
block|,
name|pfprint_wstr
block|}
block|,
endif|#
directive|endif
block|{
literal|"x"
block|,
literal|"x"
block|,
name|pfproto_xint
block|,
name|pfcheck_xint
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"X"
block|,
literal|"X"
block|,
name|pfproto_xint
block|,
name|pfcheck_xint
block|,
name|pfprint_uint
block|}
block|,
block|{
literal|"Y"
block|,
literal|"s"
block|,
literal|"int64_t"
block|,
name|pfcheck_time
block|,
name|pfprint_time
block|}
block|,
block|{
literal|"%"
block|,
literal|"%"
block|,
literal|"void"
block|,
name|pfcheck_type
block|,
name|pfprint_pct
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|dt_pfdict_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|uint_t
name|n
init|=
name|_dtrace_strbuckets
decl_stmt|;
specifier|const
name|dt_pfconv_t
modifier|*
name|pfd
decl_stmt|;
name|dt_pfdict_t
modifier|*
name|pdi
decl_stmt|;
if|if
condition|(
operator|(
name|pdi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_pfdict_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|pdi
operator|->
name|pdi_buckets
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_pfconv_t
operator|*
argument_list|)
operator|*
name|n
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pdi
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|dtp
operator|->
name|dt_pfdict
operator|=
name|pdi
expr_stmt|;
name|bzero
argument_list|(
name|pdi
operator|->
name|pdi_buckets
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_pfconv_t
operator|*
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
name|pdi
operator|->
name|pdi_nbuckets
operator|=
name|n
expr_stmt|;
for|for
control|(
name|pfd
operator|=
name|_dtrace_conversions
init|;
name|pfd
operator|->
name|pfc_name
operator|!=
name|NULL
condition|;
name|pfd
operator|++
control|)
block|{
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
name|dt_pfconv_t
modifier|*
name|pfc
decl_stmt|;
name|uint_t
name|h
decl_stmt|;
if|if
condition|(
operator|(
name|pfc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_pfconv_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_pfdict_destroy
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|pfd
argument_list|,
name|pfc
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_pfconv_t
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|=
name|dt_strtab_hash
argument_list|(
name|pfc
operator|->
name|pfc_name
argument_list|,
name|NULL
argument_list|)
operator|%
name|n
expr_stmt|;
name|pfc
operator|->
name|pfc_next
operator|=
name|pdi
operator|->
name|pdi_buckets
index|[
name|h
index|]
expr_stmt|;
name|pdi
operator|->
name|pdi_buckets
index|[
name|h
index|]
operator|=
name|pfc
expr_stmt|;
name|dtt
operator|.
name|dtt_ctfp
operator|=
name|NULL
expr_stmt|;
name|dtt
operator|.
name|dtt_type
operator|=
name|CTF_ERR
expr_stmt|;
comment|/* 		 * The "D" container or its parent must contain a definition of 		 * any type referenced by a printf conversion.  If none can be 		 * found, we fail to initialize the printf dictionary. 		 */
if|if
condition|(
name|pfc
operator|->
name|pfc_check
operator|==
operator|&
name|pfcheck_type
operator|&&
name|dtrace_lookup_by_type
argument_list|(
name|dtp
argument_list|,
name|DTRACE_OBJ_DDEFS
argument_list|,
name|pfc
operator|->
name|pfc_tstr
argument_list|,
operator|&
name|dtt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dt_pfdict_destroy
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOCONV
argument_list|)
operator|)
return|;
block|}
name|pfc
operator|->
name|pfc_dctfp
operator|=
name|dtt
operator|.
name|dtt_ctfp
expr_stmt|;
name|pfc
operator|->
name|pfc_dtype
operator|=
name|dtt
operator|.
name|dtt_type
expr_stmt|;
comment|/* 		 * The "C" container may contain an alternate definition of an 		 * explicit conversion type.  If it does, use it; otherwise 		 * just set pfc_ctype to pfc_dtype so it is always valid. 		 */
if|if
condition|(
name|pfc
operator|->
name|pfc_check
operator|==
operator|&
name|pfcheck_type
operator|&&
name|dtrace_lookup_by_type
argument_list|(
name|dtp
argument_list|,
name|DTRACE_OBJ_CDEFS
argument_list|,
name|pfc
operator|->
name|pfc_tstr
argument_list|,
operator|&
name|dtt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pfc
operator|->
name|pfc_cctfp
operator|=
name|dtt
operator|.
name|dtt_ctfp
expr_stmt|;
name|pfc
operator|->
name|pfc_ctype
operator|=
name|dtt
operator|.
name|dtt_type
expr_stmt|;
block|}
else|else
block|{
name|pfc
operator|->
name|pfc_cctfp
operator|=
name|pfc
operator|->
name|pfc_dctfp
expr_stmt|;
name|pfc
operator|->
name|pfc_ctype
operator|=
name|pfc
operator|->
name|pfc_dtype
expr_stmt|;
block|}
if|if
condition|(
name|pfc
operator|->
name|pfc_check
operator|==
name|NULL
operator|||
name|pfc
operator|->
name|pfc_print
operator|==
name|NULL
operator|||
name|pfc
operator|->
name|pfc_ofmt
operator|==
name|NULL
operator|||
name|pfc
operator|->
name|pfc_tstr
operator|==
name|NULL
condition|)
block|{
name|dt_pfdict_destroy
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADCONV
argument_list|)
operator|)
return|;
block|}
name|dt_dprintf
argument_list|(
literal|"loaded printf conversion %%%s\n"
argument_list|,
name|pfc
operator|->
name|pfc_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_pfdict_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dt_pfdict_t
modifier|*
name|pdi
init|=
name|dtp
operator|->
name|dt_pfdict
decl_stmt|;
name|dt_pfconv_t
modifier|*
name|pfc
decl_stmt|,
modifier|*
name|nfc
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
if|if
condition|(
name|pdi
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdi
operator|->
name|pdi_nbuckets
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|pfc
operator|=
name|pdi
operator|->
name|pdi_buckets
index|[
name|i
index|]
init|;
name|pfc
operator|!=
name|NULL
condition|;
name|pfc
operator|=
name|nfc
control|)
block|{
name|nfc
operator|=
name|pfc
operator|->
name|pfc_next
expr_stmt|;
name|free
argument_list|(
name|pfc
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|pdi
operator|->
name|pdi_buckets
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pdi
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_pfdict
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|dt_pfconv_t
modifier|*
name|dt_pfdict_lookup
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dt_pfdict_t
modifier|*
name|pdi
init|=
name|dtp
operator|->
name|dt_pfdict
decl_stmt|;
name|uint_t
name|h
init|=
name|dt_strtab_hash
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
operator|%
name|pdi
operator|->
name|pdi_nbuckets
decl_stmt|;
specifier|const
name|dt_pfconv_t
modifier|*
name|pfc
decl_stmt|;
for|for
control|(
name|pfc
operator|=
name|pdi
operator|->
name|pdi_buckets
index|[
name|h
index|]
init|;
name|pfc
operator|!=
name|NULL
condition|;
name|pfc
operator|=
name|pfc
operator|->
name|pfc_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pfc
operator|->
name|pfc_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|pfc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dt_pfargv_t
modifier|*
name|dt_printf_error
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|int
name|err
parameter_list|)
block|{
if|if
condition|(
name|yypcb
operator|!=
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|err
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|dt_pfargv_t
modifier|*
name|dt_printf_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dt_pfargd_t
modifier|*
name|pfd
decl_stmt|,
modifier|*
name|nfd
init|=
name|NULL
decl_stmt|;
name|dt_pfargv_t
modifier|*
name|pfv
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
if|if
condition|(
operator|(
name|pfv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_pfargv_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|format
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pfv
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_printf_error
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|pfv
operator|->
name|pfv_format
operator|=
name|format
expr_stmt|;
name|pfv
operator|->
name|pfv_argv
operator|=
name|NULL
expr_stmt|;
name|pfv
operator|->
name|pfv_argc
operator|=
literal|0
expr_stmt|;
name|pfv
operator|->
name|pfv_flags
operator|=
literal|0
expr_stmt|;
name|pfv
operator|->
name|pfv_dtp
operator|=
name|dtp
expr_stmt|;
for|for
control|(
name|q
operator|=
name|format
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|'%'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|q
operator|=
operator|*
name|p
condition|?
name|p
operator|+
literal|1
else|:
name|p
control|)
block|{
name|uint_t
name|namelen
init|=
literal|0
decl_stmt|;
name|int
name|digits
init|=
literal|0
decl_stmt|;
name|int
name|dot
init|=
literal|0
decl_stmt|;
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|pfd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_pfargd_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_printf_destroy
argument_list|(
name|pfv
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_printf_error
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|pfv
operator|->
name|pfv_argv
operator|!=
name|NULL
condition|)
name|nfd
operator|->
name|pfd_next
operator|=
name|pfd
expr_stmt|;
else|else
name|pfv
operator|->
name|pfv_argv
operator|=
name|pfd
expr_stmt|;
name|bzero
argument_list|(
name|pfd
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_pfargd_t
argument_list|)
argument_list|)
expr_stmt|;
name|pfv
operator|->
name|pfv_argc
operator|++
expr_stmt|;
name|nfd
operator|=
name|pfd
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|q
condition|)
block|{
name|pfd
operator|->
name|pfd_preflen
operator|=
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
name|pfd
operator|->
name|pfd_prefix
operator|=
name|q
expr_stmt|;
block|}
name|fmt_switch
label|:
switch|switch
condition|(
name|c
operator|=
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|dot
operator|==
literal|0
operator|&&
name|digits
operator|==
literal|0
operator|&&
name|c
operator|==
literal|'0'
condition|)
block|{
name|pfd
operator|->
name|pfd_flags
operator||=
name|DT_PFCONV_ZPAD
expr_stmt|;
name|pfd
operator|->
name|pfd_flags
operator|&=
operator|~
name|DT_PFCONV_LEFT
expr_stmt|;
goto|goto
name|fmt_switch
goto|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|isdigit
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
operator|*
operator|++
name|p
control|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|dot
condition|)
name|pfd
operator|->
name|pfd_prec
operator|=
name|n
expr_stmt|;
else|else
name|pfd
operator|->
name|pfd_width
operator|=
name|n
expr_stmt|;
name|p
operator|--
expr_stmt|;
name|digits
operator|++
expr_stmt|;
goto|goto
name|fmt_switch
goto|;
case|case
literal|'#'
case|:
name|pfd
operator|->
name|pfd_flags
operator||=
name|DT_PFCONV_ALT
expr_stmt|;
goto|goto
name|fmt_switch
goto|;
case|case
literal|'*'
case|:
name|n
operator|=
name|dot
condition|?
name|DT_PFCONV_DYNPREC
else|:
name|DT_PFCONV_DYNWIDTH
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|n
condition|)
block|{
name|yywarn
argument_list|(
literal|"format conversion #%u has more than "
literal|"one '*' specified for the output %s\n"
argument_list|,
name|pfv
operator|->
name|pfv_argc
argument_list|,
name|n
condition|?
literal|"precision"
else|:
literal|"width"
argument_list|)
expr_stmt|;
name|dt_printf_destroy
argument_list|(
name|pfv
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_printf_error
argument_list|(
name|dtp
argument_list|,
name|EDT_COMPILER
argument_list|)
operator|)
return|;
block|}
name|pfd
operator|->
name|pfd_flags
operator||=
name|n
expr_stmt|;
goto|goto
name|fmt_switch
goto|;
case|case
literal|'+'
case|:
name|pfd
operator|->
name|pfd_flags
operator||=
name|DT_PFCONV_SPOS
expr_stmt|;
goto|goto
name|fmt_switch
goto|;
case|case
literal|'-'
case|:
name|pfd
operator|->
name|pfd_flags
operator||=
name|DT_PFCONV_LEFT
expr_stmt|;
name|pfd
operator|->
name|pfd_flags
operator|&=
operator|~
name|DT_PFCONV_ZPAD
expr_stmt|;
goto|goto
name|fmt_switch
goto|;
case|case
literal|'.'
case|:
if|if
condition|(
name|dot
operator|++
operator|!=
literal|0
condition|)
block|{
name|yywarn
argument_list|(
literal|"format conversion #%u has more than "
literal|"one '.' specified\n"
argument_list|,
name|pfv
operator|->
name|pfv_argc
argument_list|)
expr_stmt|;
name|dt_printf_destroy
argument_list|(
name|pfv
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_printf_error
argument_list|(
name|dtp
argument_list|,
name|EDT_COMPILER
argument_list|)
operator|)
return|;
block|}
name|digits
operator|=
literal|0
expr_stmt|;
goto|goto
name|fmt_switch
goto|;
case|case
literal|'?'
case|:
if|if
condition|(
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_ctfmodel
operator|==
name|CTF_MODEL_LP64
condition|)
name|pfd
operator|->
name|pfd_width
operator|=
literal|16
expr_stmt|;
else|else
name|pfd
operator|->
name|pfd_width
operator|=
literal|8
expr_stmt|;
goto|goto
name|fmt_switch
goto|;
case|case
literal|'@'
case|:
name|pfd
operator|->
name|pfd_flags
operator||=
name|DT_PFCONV_AGG
expr_stmt|;
goto|goto
name|fmt_switch
goto|;
case|case
literal|'\''
case|:
name|pfd
operator|->
name|pfd_flags
operator||=
name|DT_PFCONV_GROUP
expr_stmt|;
goto|goto
name|fmt_switch
goto|;
case|case
literal|' '
case|:
name|pfd
operator|->
name|pfd_flags
operator||=
name|DT_PFCONV_SPACE
expr_stmt|;
goto|goto
name|fmt_switch
goto|;
case|case
literal|'$'
case|:
name|yywarn
argument_list|(
literal|"format conversion #%u uses unsupported "
literal|"positional format (%%n$)\n"
argument_list|,
name|pfv
operator|->
name|pfv_argc
argument_list|)
expr_stmt|;
name|dt_printf_destroy
argument_list|(
name|pfv
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_printf_error
argument_list|(
name|dtp
argument_list|,
name|EDT_COMPILER
argument_list|)
operator|)
return|;
case|case
literal|'%'
case|:
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'%'
condition|)
goto|goto
name|default_lbl
goto|;
comment|/* if %% then use "%" conv */
name|yywarn
argument_list|(
literal|"format conversion #%u cannot be combined "
literal|"with other format flags: %%%%\n"
argument_list|,
name|pfv
operator|->
name|pfv_argc
argument_list|)
expr_stmt|;
name|dt_printf_destroy
argument_list|(
name|pfv
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_printf_error
argument_list|(
name|dtp
argument_list|,
name|EDT_COMPILER
argument_list|)
operator|)
return|;
case|case
literal|'\0'
case|:
name|yywarn
argument_list|(
literal|"format conversion #%u name expected before "
literal|"end of format string\n"
argument_list|,
name|pfv
operator|->
name|pfv_argc
argument_list|)
expr_stmt|;
name|dt_printf_destroy
argument_list|(
name|pfv
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_printf_error
argument_list|(
name|dtp
argument_list|,
name|EDT_COMPILER
argument_list|)
operator|)
return|;
case|case
literal|'h'
case|:
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
case|case
literal|'w'
case|:
if|if
condition|(
name|namelen
operator|<
sizeof|sizeof
argument_list|(
name|name
argument_list|)
operator|-
literal|2
condition|)
name|name
index|[
name|namelen
operator|++
index|]
operator|=
name|c
expr_stmt|;
goto|goto
name|fmt_switch
goto|;
name|default_lbl
label|:
default|default:
name|name
index|[
name|namelen
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|name
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|pfd
operator|->
name|pfd_conv
operator|=
name|dt_pfdict_lookup
argument_list|(
name|dtp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_conv
operator|==
name|NULL
condition|)
block|{
name|yywarn
argument_list|(
literal|"format conversion #%u is undefined: %%%s\n"
argument_list|,
name|pfv
operator|->
name|pfv_argc
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dt_printf_destroy
argument_list|(
name|pfv
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_printf_error
argument_list|(
name|dtp
argument_list|,
name|EDT_COMPILER
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|*
name|q
operator|!=
literal|'\0'
operator|||
operator|*
name|format
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|pfd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_pfargd_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_printf_destroy
argument_list|(
name|pfv
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_printf_error
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|pfv
operator|->
name|pfv_argv
operator|!=
name|NULL
condition|)
name|nfd
operator|->
name|pfd_next
operator|=
name|pfd
expr_stmt|;
else|else
name|pfv
operator|->
name|pfv_argv
operator|=
name|pfd
expr_stmt|;
name|bzero
argument_list|(
name|pfd
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_pfargd_t
argument_list|)
argument_list|)
expr_stmt|;
name|pfv
operator|->
name|pfv_argc
operator|++
expr_stmt|;
name|pfd
operator|->
name|pfd_prefix
operator|=
name|q
expr_stmt|;
name|pfd
operator|->
name|pfd_preflen
operator|=
name|strlen
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pfv
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_printf_destroy
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|)
block|{
name|dt_pfargd_t
modifier|*
name|pfd
decl_stmt|,
modifier|*
name|nfd
decl_stmt|;
for|for
control|(
name|pfd
operator|=
name|pfv
operator|->
name|pfv_argv
init|;
name|pfd
operator|!=
name|NULL
condition|;
name|pfd
operator|=
name|nfd
control|)
block|{
name|nfd
operator|=
name|pfd
operator|->
name|pfd_next
expr_stmt|;
name|free
argument_list|(
name|pfd
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pfv
operator|->
name|pfv_format
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_printf_validate
parameter_list|(
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
name|uint_t
name|flags
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|int
name|foff
parameter_list|,
name|dtrace_actkind_t
name|kind
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dt_pfargd_t
modifier|*
name|pfd
init|=
name|pfv
operator|->
name|pfv_argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|func
init|=
name|idp
operator|->
name|di_name
decl_stmt|;
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
specifier|const
name|char
modifier|*
name|aggtype
decl_stmt|;
name|dt_node_t
name|aggnode
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|pfv
operator|->
name|pfv_format
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|xyerror
argument_list|(
name|D_PRINTF_FMT_EMPTY
argument_list|,
literal|"%s( ) format string is empty\n"
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
name|pfv
operator|->
name|pfv_flags
operator|=
name|flags
expr_stmt|;
comment|/* 	 * We fake up a parse node representing the type that can be used with 	 * an aggregation result conversion, which -- for all but count() -- 	 * is a signed quantity. 	 */
if|if
condition|(
name|kind
operator|!=
name|DTRACEAGG_COUNT
condition|)
name|aggtype
operator|=
literal|"int64_t"
expr_stmt|;
else|else
name|aggtype
operator|=
literal|"uint64_t"
expr_stmt|;
if|if
condition|(
name|dt_type_lookup
argument_list|(
name|aggtype
argument_list|,
operator|&
name|dtt
argument_list|)
operator|!=
literal|0
condition|)
name|xyerror
argument_list|(
name|D_TYPE_ERR
argument_list|,
literal|"failed to lookup agg type %s\n"
argument_list|,
name|aggtype
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|aggnode
argument_list|,
sizeof|sizeof
argument_list|(
name|aggnode
argument_list|)
argument_list|)
expr_stmt|;
name|dt_node_type_assign
argument_list|(
operator|&
name|aggnode
argument_list|,
name|dtt
operator|.
name|dtt_ctfp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|pfv
operator|->
name|pfv_argc
condition|;
name|i
operator|++
operator|,
name|pfd
operator|=
name|pfd
operator|->
name|pfd_next
control|)
block|{
specifier|const
name|dt_pfconv_t
modifier|*
name|pfc
init|=
name|pfd
operator|->
name|pfd_conv
decl_stmt|;
specifier|const
name|char
modifier|*
name|dyns
index|[
literal|2
index|]
decl_stmt|;
name|int
name|dync
init|=
literal|0
decl_stmt|;
name|char
name|vname
index|[
literal|64
index|]
decl_stmt|;
name|dt_node_t
modifier|*
name|vnp
decl_stmt|;
if|if
condition|(
name|pfc
operator|==
name|NULL
condition|)
continue|continue;
comment|/* no checking if argd is just a prefix */
if|if
condition|(
name|pfc
operator|->
name|pfc_print
operator|==
operator|&
name|pfprint_pct
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|pfd
operator|->
name|pfd_fmt
argument_list|,
name|pfc
operator|->
name|pfc_ofmt
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_DYNPREC
condition|)
name|dyns
index|[
name|dync
operator|++
index|]
operator|=
literal|".*"
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_DYNWIDTH
condition|)
name|dyns
index|[
name|dync
operator|++
index|]
operator|=
literal|"*"
expr_stmt|;
for|for
control|(
init|;
name|dync
operator|!=
literal|0
condition|;
name|dync
operator|--
control|)
block|{
if|if
condition|(
name|dnp
operator|==
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_PRINTF_DYN_PROTO
argument_list|,
literal|"%s( ) prototype mismatch: conversion "
literal|"#%d (%%%s) is missing a corresponding "
literal|"\"%s\" argument\n"
argument_list|,
name|func
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|pfc
operator|->
name|pfc_name
argument_list|,
name|dyns
index|[
name|dync
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_node_is_integer
argument_list|(
name|dnp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_PRINTF_DYN_TYPE
argument_list|,
literal|"%s( ) argument #%d is incompatible "
literal|"with conversion #%d prototype:\n"
literal|"\tconversion: %% %s %s\n"
literal|"\t prototype: int\n\t  argument: %s\n"
argument_list|,
name|func
argument_list|,
name|j
operator|+
name|foff
operator|+
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|dyns
index|[
name|dync
operator|-
literal|1
index|]
argument_list|,
name|pfc
operator|->
name|pfc_name
argument_list|,
name|dt_node_type_name
argument_list|(
name|dnp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
comment|/* 		 * If this conversion is consuming the aggregation data, set 		 * the value node pointer (vnp) to a fake node based on the 		 * aggregating function result type.  Otherwise assign vnp to 		 * the next parse node in the argument list, if there is one. 		 */
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_AGG
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DT_PRINTF_AGGREGATION
operator|)
condition|)
block|{
name|xyerror
argument_list|(
name|D_PRINTF_AGG_CONV
argument_list|,
literal|"%%@ conversion requires an aggregation"
literal|" and is not for use with %s( )\n"
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|vname
argument_list|,
literal|"aggregating action"
argument_list|,
sizeof|sizeof
argument_list|(
name|vname
argument_list|)
argument_list|)
expr_stmt|;
name|vnp
operator|=
operator|&
name|aggnode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dnp
operator|==
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_PRINTF_ARG_PROTO
argument_list|,
literal|"%s( ) prototype mismatch: conversion #%d (%%"
literal|"%s) is missing a corresponding value argument\n"
argument_list|,
name|func
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|pfc
operator|->
name|pfc_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|vname
argument_list|,
sizeof|sizeof
argument_list|(
name|vname
argument_list|)
argument_list|,
literal|"argument #%d"
argument_list|,
name|j
operator|+
name|foff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|vnp
operator|=
name|dnp
expr_stmt|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
comment|/* 		 * Fill in the proposed final format string by prepending any 		 * size-related prefixes to the pfconv's format string.  The 		 * pfc_check() function below may optionally modify the format 		 * as part of validating the type of the input argument. 		 */
if|if
condition|(
name|pfc
operator|->
name|pfc_print
operator|==
operator|&
name|pfprint_sint
operator|||
name|pfc
operator|->
name|pfc_print
operator|==
operator|&
name|pfprint_uint
operator|||
name|pfc
operator|->
name|pfc_print
operator|==
operator|&
name|pfprint_dint
condition|)
block|{
if|if
condition|(
name|dt_node_type_size
argument_list|(
name|vnp
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pfd
operator|->
name|pfd_fmt
argument_list|,
literal|"ll"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pfc
operator|->
name|pfc_print
operator|==
operator|&
name|pfprint_fp
condition|)
block|{
if|if
condition|(
name|dt_node_type_size
argument_list|(
name|vnp
argument_list|)
operator|==
expr|sizeof
operator|(
name|long
name|double
operator|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pfd
operator|->
name|pfd_fmt
argument_list|,
literal|"L"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|pfd
operator|->
name|pfd_fmt
argument_list|,
name|pfc
operator|->
name|pfc_ofmt
argument_list|)
expr_stmt|;
comment|/* 		 * Validate the format conversion against the value node type. 		 * If the conversion is good, create the descriptor format 		 * string by concatenating together any required printf(3C) 		 * size prefixes with the conversion's native format string. 		 */
if|if
condition|(
name|pfc
operator|->
name|pfc_check
argument_list|(
name|pfv
argument_list|,
name|pfd
argument_list|,
name|vnp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_PRINTF_ARG_TYPE
argument_list|,
literal|"%s( ) %s is incompatible with "
literal|"conversion #%d prototype:\n\tconversion: %%%s\n"
literal|"\t prototype: %s\n\t  argument: %s\n"
argument_list|,
name|func
argument_list|,
name|vname
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|pfc
operator|->
name|pfc_name
argument_list|,
name|pfc
operator|->
name|pfc_tstr
argument_list|,
name|dt_node_type_name
argument_list|(
name|vnp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DT_PRINTF_EXACTLEN
operator|)
operator|&&
name|dnp
operator|!=
name|NULL
condition|)
block|{
name|xyerror
argument_list|(
name|D_PRINTF_ARG_EXTRA
argument_list|,
literal|"%s( ) prototype mismatch: only %d arguments "
literal|"required by this format string\n"
argument_list|,
name|func
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dt_printa_validate
parameter_list|(
name|dt_node_t
modifier|*
name|lhs
parameter_list|,
name|dt_node_t
modifier|*
name|rhs
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|lid
decl_stmt|,
modifier|*
name|rid
decl_stmt|;
name|dt_node_t
modifier|*
name|lproto
decl_stmt|,
modifier|*
name|rproto
decl_stmt|;
name|int
name|largc
decl_stmt|,
name|rargc
decl_stmt|,
name|argn
decl_stmt|;
name|char
name|n1
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|char
name|n2
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|assert
argument_list|(
name|lhs
operator|->
name|dn_kind
operator|==
name|DT_NODE_AGG
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rhs
operator|->
name|dn_kind
operator|==
name|DT_NODE_AGG
argument_list|)
expr_stmt|;
name|lid
operator|=
name|lhs
operator|->
name|dn_ident
expr_stmt|;
name|rid
operator|=
name|rhs
operator|->
name|dn_ident
expr_stmt|;
name|lproto
operator|=
operator|(
operator|(
name|dt_idsig_t
operator|*
operator|)
name|lid
operator|->
name|di_data
operator|)
operator|->
name|dis_args
expr_stmt|;
name|rproto
operator|=
operator|(
operator|(
name|dt_idsig_t
operator|*
operator|)
name|rid
operator|->
name|di_data
operator|)
operator|->
name|dis_args
expr_stmt|;
comment|/* 	 * First, get an argument count on each side.  These must match. 	 */
for|for
control|(
name|largc
operator|=
literal|0
init|;
name|lproto
operator|!=
name|NULL
condition|;
name|lproto
operator|=
name|lproto
operator|->
name|dn_list
control|)
name|largc
operator|++
expr_stmt|;
for|for
control|(
name|rargc
operator|=
literal|0
init|;
name|rproto
operator|!=
name|NULL
condition|;
name|rproto
operator|=
name|rproto
operator|->
name|dn_list
control|)
name|rargc
operator|++
expr_stmt|;
if|if
condition|(
name|largc
operator|!=
name|rargc
condition|)
block|{
name|xyerror
argument_list|(
name|D_PRINTA_AGGKEY
argument_list|,
literal|"printa( ): @%s and @%s do not have "
literal|"matching key signatures: @%s has %d key%s, @%s has %d "
literal|"key%s"
argument_list|,
name|lid
operator|->
name|di_name
argument_list|,
name|rid
operator|->
name|di_name
argument_list|,
name|lid
operator|->
name|di_name
argument_list|,
name|largc
argument_list|,
name|largc
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|rid
operator|->
name|di_name
argument_list|,
name|rargc
argument_list|,
name|rargc
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now iterate over the keys to verify that each type matches. 	 */
name|lproto
operator|=
operator|(
operator|(
name|dt_idsig_t
operator|*
operator|)
name|lid
operator|->
name|di_data
operator|)
operator|->
name|dis_args
expr_stmt|;
name|rproto
operator|=
operator|(
operator|(
name|dt_idsig_t
operator|*
operator|)
name|rid
operator|->
name|di_data
operator|)
operator|->
name|dis_args
expr_stmt|;
for|for
control|(
name|argn
operator|=
literal|1
init|;
name|lproto
operator|!=
name|NULL
condition|;
name|argn
operator|++
operator|,
name|lproto
operator|=
name|lproto
operator|->
name|dn_list
operator|,
name|rproto
operator|=
name|rproto
operator|->
name|dn_list
control|)
block|{
name|assert
argument_list|(
name|rproto
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_node_is_argcompat
argument_list|(
name|lproto
argument_list|,
name|rproto
argument_list|)
condition|)
continue|continue;
name|xyerror
argument_list|(
name|D_PRINTA_AGGPROTO
argument_list|,
literal|"printa( ): @%s[ ] key #%d is "
literal|"incompatible with @%s:\n%9s key #%d: %s\n"
literal|"%9s key #%d: %s\n"
argument_list|,
name|rid
operator|->
name|di_name
argument_list|,
name|argn
argument_list|,
name|lid
operator|->
name|di_name
argument_list|,
name|lid
operator|->
name|di_name
argument_list|,
name|argn
argument_list|,
name|dt_node_type_name
argument_list|(
name|lproto
argument_list|,
name|n1
argument_list|,
sizeof|sizeof
argument_list|(
name|n1
argument_list|)
argument_list|)
argument_list|,
name|rid
operator|->
name|di_name
argument_list|,
name|argn
argument_list|,
name|dt_node_type_name
argument_list|(
name|rproto
argument_list|,
name|n2
argument_list|,
sizeof|sizeof
argument_list|(
name|n2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dt_printf_getint
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
name|recp
parameter_list|,
name|uint_t
name|nrecs
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
modifier|*
name|ip
parameter_list|)
block|{
name|uintptr_t
name|addr
decl_stmt|;
if|if
condition|(
name|nrecs
operator|==
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
name|addr
operator|=
operator|(
name|uintptr_t
operator|)
name|buf
operator|+
name|recp
operator|->
name|dtrd_offset
expr_stmt|;
if|if
condition|(
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|>
operator|(
name|uintptr_t
operator|)
name|buf
operator|+
name|len
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DOFFSET
argument_list|)
operator|)
return|;
if|if
condition|(
name|addr
operator|&
operator|(
name|recp
operator|->
name|dtrd_alignment
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DALIGN
argument_list|)
operator|)
return|;
switch|switch
condition|(
name|recp
operator|->
name|dtrd_size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
case|:
operator|*
name|ip
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
operator|(
name|int8_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
case|:
operator|*
name|ip
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
operator|(
name|int16_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
case|:
operator|*
name|ip
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
operator|(
name|int32_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
case|:
operator|*
name|ip
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
operator|(
name|int64_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_average
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
specifier|const
name|uint64_t
modifier|*
name|data
init|=
name|addr
decl_stmt|;
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|2
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|data
index|[
literal|0
index|]
condition|?
name|data
index|[
literal|1
index|]
operator|/
name|normal
operator|/
name|data
index|[
literal|0
index|]
else|:
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_stddev
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
specifier|const
name|uint64_t
modifier|*
name|data
init|=
name|addr
decl_stmt|;
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|4
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|dt_stddev
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
name|data
argument_list|,
name|normal
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_quantize
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
return|return
operator|(
name|dt_print_quantize
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|normal
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_lquantize
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
return|return
operator|(
name|dt_print_lquantize
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|normal
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|pfprint_llquantize
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|dt_pfargd_t
modifier|*
name|pfd
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
return|return
operator|(
name|dt_print_llquantize
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|normal
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_printf_format
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|dt_pfargv_t
modifier|*
name|pfv
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
name|recs
parameter_list|,
name|uint_t
name|nrecs
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|dtrace_aggdata_t
modifier|*
modifier|*
name|aggsdata
parameter_list|,
name|int
name|naggvars
parameter_list|)
block|{
name|dt_pfargd_t
modifier|*
name|pfd
init|=
name|pfv
operator|->
name|pfv_argv
decl_stmt|;
specifier|const
name|dtrace_recdesc_t
modifier|*
name|recp
init|=
name|recs
decl_stmt|;
specifier|const
name|dtrace_aggdata_t
modifier|*
name|aggdata
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|agg
decl_stmt|;
name|caddr_t
name|lim
init|=
operator|(
name|caddr_t
operator|)
name|buf
operator|+
name|len
decl_stmt|,
name|limit
decl_stmt|;
name|char
name|format
index|[
literal|64
index|]
init|=
literal|"%"
decl_stmt|;
name|size_t
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|,
name|aggrec
decl_stmt|,
name|curagg
init|=
operator|-
literal|1
decl_stmt|;
name|uint64_t
name|normal
decl_stmt|;
comment|/* 	 * If we are formatting an aggregation, set 'aggrec' to the index of 	 * the final record description (the aggregation result) so we can use 	 * this record index with any conversion where DT_PFCONV_AGG is set. 	 * (The actual aggregation used will vary as we increment through the 	 * aggregation variables that we have been passed.)  Finally, we 	 * decrement nrecs to prevent this record from being used with any 	 * other conversion. 	 */
if|if
condition|(
name|pfv
operator|->
name|pfv_flags
operator|&
name|DT_PRINTF_AGGREGATION
condition|)
block|{
name|assert
argument_list|(
name|aggsdata
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|naggvars
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrecs
operator|==
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
name|curagg
operator|=
name|naggvars
operator|>
literal|1
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|aggdata
operator|=
name|aggsdata
index|[
literal|0
index|]
expr_stmt|;
name|aggrec
operator|=
name|aggdata
operator|->
name|dtada_desc
operator|->
name|dtagd_nrecs
operator|-
literal|1
expr_stmt|;
name|nrecs
operator|--
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pfv
operator|->
name|pfv_argc
condition|;
name|i
operator|++
operator|,
name|pfd
operator|=
name|pfd
operator|->
name|pfd_next
control|)
block|{
specifier|const
name|dt_pfconv_t
modifier|*
name|pfc
init|=
name|pfd
operator|->
name|pfd_conv
decl_stmt|;
name|int
name|width
init|=
name|pfd
operator|->
name|pfd_width
decl_stmt|;
name|int
name|prec
init|=
name|pfd
operator|->
name|pfd_prec
decl_stmt|;
name|int
name|rval
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|f
init|=
name|format
operator|+
literal|1
decl_stmt|;
comment|/* skip initial '%' */
name|size_t
name|fmtsz
init|=
sizeof|sizeof
argument_list|(
name|format
argument_list|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|dtrace_recdesc_t
modifier|*
name|rec
decl_stmt|;
name|dt_pfprint_f
modifier|*
name|func
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_preflen
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|alloca
argument_list|(
name|pfd
operator|->
name|pfd_preflen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|pfd
operator|->
name|pfd_prefix
argument_list|,
name|tmp
argument_list|,
name|pfd
operator|->
name|pfd_preflen
argument_list|)
expr_stmt|;
name|tmp
index|[
name|pfd
operator|->
name|pfd_preflen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|tmp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
if|if
condition|(
name|pfv
operator|->
name|pfv_flags
operator|&
name|DT_PRINTF_AGGREGATION
condition|)
block|{
comment|/* 				 * For printa(), we flush the buffer after each 				 * prefix, setting the flags to indicate that 				 * this is part of the printa() format string. 				 */
name|flags
operator|=
name|DTRACE_BUFDATA_AGGFORMAT
expr_stmt|;
if|if
condition|(
name|pfc
operator|==
name|NULL
operator|&&
name|i
operator|==
name|pfv
operator|->
name|pfv_argc
operator|-
literal|1
condition|)
name|flags
operator||=
name|DTRACE_BUFDATA_AGGLAST
expr_stmt|;
if|if
condition|(
name|dt_buffered_flush
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|aggdata
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|pfc
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pfv
operator|->
name|pfv_argc
operator|==
literal|1
condition|)
return|return
operator|(
name|nrecs
operator|!=
literal|0
operator|)
return|;
continue|continue;
block|}
comment|/* 		 * If the conversion is %%, just invoke the print callback 		 * with no data record and continue; it consumes no record. 		 */
if|if
condition|(
name|pfc
operator|->
name|pfc_print
operator|==
operator|&
name|pfprint_pct
condition|)
block|{
if|if
condition|(
name|pfc
operator|->
name|pfc_print
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|,
name|pfd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|>=
literal|0
condition|)
continue|continue;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
block|}
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_DYNWIDTH
condition|)
block|{
if|if
condition|(
name|dt_printf_getint
argument_list|(
name|dtp
argument_list|,
name|recp
operator|++
argument_list|,
name|nrecs
operator|--
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|width
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
name|pfd
operator|->
name|pfd_dynwidth
operator|=
name|width
expr_stmt|;
block|}
else|else
block|{
name|pfd
operator|->
name|pfd_dynwidth
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_DYNPREC
operator|)
operator|&&
name|dt_printf_getint
argument_list|(
name|dtp
argument_list|,
name|recp
operator|++
argument_list|,
name|nrecs
operator|--
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|prec
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_AGG
condition|)
block|{
comment|/* 			 * This should be impossible -- the compiler shouldn't 			 * create a DT_PFCONV_AGG conversion without an 			 * aggregation present.  Still, we'd rather fail 			 * gracefully than blow up... 			 */
if|if
condition|(
name|aggsdata
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
name|aggdata
operator|=
name|aggsdata
index|[
name|curagg
index|]
expr_stmt|;
name|agg
operator|=
name|aggdata
operator|->
name|dtada_desc
expr_stmt|;
comment|/* 			 * We increment the current aggregation variable, but 			 * not beyond the number of aggregation variables that 			 * we're printing. This has the (desired) effect that 			 * DT_PFCONV_AGG conversions beyond the number of 			 * aggregation variables (re-)convert the aggregation 			 * value of the last aggregation variable. 			 */
if|if
condition|(
name|curagg
operator|<
name|naggvars
operator|-
literal|1
condition|)
name|curagg
operator|++
expr_stmt|;
name|rec
operator|=
operator|&
name|agg
operator|->
name|dtagd_rec
index|[
name|aggrec
index|]
expr_stmt|;
name|addr
operator|=
name|aggdata
operator|->
name|dtada_data
operator|+
name|rec
operator|->
name|dtrd_offset
expr_stmt|;
name|limit
operator|=
name|addr
operator|+
name|aggdata
operator|->
name|dtada_size
expr_stmt|;
name|normal
operator|=
name|aggdata
operator|->
name|dtada_normal
expr_stmt|;
name|flags
operator|=
name|DTRACE_BUFDATA_AGGVAL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nrecs
operator|==
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
if|if
condition|(
name|pfv
operator|->
name|pfv_flags
operator|&
name|DT_PRINTF_AGGREGATION
condition|)
block|{
comment|/* 				 * When printing aggregation keys, we always 				 * set the aggdata to be the representative 				 * (zeroth) aggregation.  The aggdata isn't 				 * actually used here in this case, but it is 				 * passed to the buffer handler and must 				 * therefore still be correct. 				 */
name|aggdata
operator|=
name|aggsdata
index|[
literal|0
index|]
expr_stmt|;
name|flags
operator|=
name|DTRACE_BUFDATA_AGGKEY
expr_stmt|;
block|}
name|rec
operator|=
name|recp
operator|++
expr_stmt|;
name|nrecs
operator|--
expr_stmt|;
name|addr
operator|=
operator|(
name|caddr_t
operator|)
name|buf
operator|+
name|rec
operator|->
name|dtrd_offset
expr_stmt|;
name|limit
operator|=
name|lim
expr_stmt|;
name|normal
operator|=
literal|1
expr_stmt|;
block|}
name|size
operator|=
name|rec
operator|->
name|dtrd_size
expr_stmt|;
if|if
condition|(
name|addr
operator|+
name|size
operator|>
name|limit
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"bad size: addr=%p size=0x%x lim=%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|rec
operator|->
name|dtrd_size
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lim
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DOFFSET
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|rec
operator|->
name|dtrd_alignment
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|uintptr_t
operator|)
name|addr
operator|&
operator|(
name|rec
operator|->
name|dtrd_alignment
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"bad align: addr=%p size=0x%x align=0x%x\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|rec
operator|->
name|dtrd_size
argument_list|,
name|rec
operator|->
name|dtrd_alignment
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DALIGN
argument_list|)
operator|)
return|;
block|}
switch|switch
condition|(
name|rec
operator|->
name|dtrd_action
condition|)
block|{
case|case
name|DTRACEAGG_AVG
case|:
name|func
operator|=
name|pfprint_average
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_STDDEV
case|:
name|func
operator|=
name|pfprint_stddev
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_QUANTIZE
case|:
name|func
operator|=
name|pfprint_quantize
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_LQUANTIZE
case|:
name|func
operator|=
name|pfprint_lquantize
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_LLQUANTIZE
case|:
name|func
operator|=
name|pfprint_llquantize
expr_stmt|;
break|break;
case|case
name|DTRACEACT_MOD
case|:
name|func
operator|=
name|pfprint_mod
expr_stmt|;
break|break;
case|case
name|DTRACEACT_UMOD
case|:
name|func
operator|=
name|pfprint_umod
expr_stmt|;
break|break;
default|default:
name|func
operator|=
name|pfc
operator|->
name|pfc_print
expr_stmt|;
break|break;
block|}
name|start
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_ALT
condition|)
operator|*
name|f
operator|++
operator|=
literal|'#'
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_ZPAD
condition|)
operator|*
name|f
operator|++
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
operator|||
operator|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_LEFT
operator|)
condition|)
operator|*
name|f
operator|++
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_SPOS
condition|)
operator|*
name|f
operator|++
operator|=
literal|'+'
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_GROUP
condition|)
operator|*
name|f
operator|++
operator|=
literal|'\''
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_SPACE
condition|)
operator|*
name|f
operator|++
operator|=
literal|' '
expr_stmt|;
name|fmtsz
operator|-=
name|f
operator|-
name|start
expr_stmt|;
comment|/* 		 * If we're printing a stack and DT_PFCONV_LEFT is set, we 		 * don't add the width to the format string.  See the block 		 * comment in pfprint_stack() for a description of the 		 * behavior in this case. 		 */
if|if
condition|(
name|func
operator|==
name|pfprint_stack
operator|&&
operator|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_LEFT
operator|)
condition|)
name|width
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|width
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|snprintf
argument_list|(
name|f
argument_list|,
name|fmtsz
argument_list|,
literal|"%d"
argument_list|,
name|ABS
argument_list|(
name|width
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|+=
name|ret
expr_stmt|;
name|fmtsz
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|fmtsz
operator|-
name|ret
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prec
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
name|snprintf
argument_list|(
name|f
argument_list|,
name|fmtsz
argument_list|,
literal|".%d"
argument_list|,
name|prec
argument_list|)
expr_stmt|;
name|f
operator|+=
name|ret
expr_stmt|;
name|fmtsz
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|fmtsz
operator|-
name|ret
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlcpy
argument_list|(
name|f
argument_list|,
name|pfd
operator|->
name|pfd_fmt
argument_list|,
name|fmtsz
argument_list|)
operator|>=
name|fmtsz
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_COMPILER
argument_list|)
operator|)
return|;
name|pfd
operator|->
name|pfd_rec
operator|=
name|rec
expr_stmt|;
if|if
condition|(
name|func
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|pfd
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|normal
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
name|pfv
operator|->
name|pfv_flags
operator|&
name|DT_PRINTF_AGGREGATION
condition|)
block|{
comment|/* 			 * For printa(), we flush the buffer after each tuple 			 * element, inidicating that this is the last record 			 * as appropriate. 			 */
if|if
condition|(
name|i
operator|==
name|pfv
operator|->
name|pfv_argc
operator|-
literal|1
condition|)
name|flags
operator||=
name|DTRACE_BUFDATA_AGGLAST
expr_stmt|;
if|if
condition|(
name|dt_buffered_flush
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
name|rec
argument_list|,
name|aggdata
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|recp
operator|-
name|recs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_sprintf
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|void
modifier|*
name|fmtdata
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
name|recp
parameter_list|,
name|uint_t
name|nrecs
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|dtrace_optval_t
name|size
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|rval
operator|=
name|dtrace_getopt
argument_list|(
name|dtp
argument_list|,
literal|"strsize"
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rval
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dtp
operator|->
name|dt_sprintf_buflen
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_sprintf_buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dtp
operator|->
name|dt_sprintf_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dtp
operator|->
name|dt_sprintf_buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
name|bzero
argument_list|(
name|dtp
operator|->
name|dt_sprintf_buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_sprintf_buflen
operator|=
name|size
expr_stmt|;
name|rval
operator|=
name|dt_printf_format
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|fmtdata
argument_list|,
name|recp
argument_list|,
name|nrecs
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_sprintf_buflen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
condition|)
name|free
argument_list|(
name|dtp
operator|->
name|dt_sprintf_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|dtrace_system
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|void
modifier|*
name|fmtdata
parameter_list|,
specifier|const
name|dtrace_probedata_t
modifier|*
name|data
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
name|recp
parameter_list|,
name|uint_t
name|nrecs
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|rval
init|=
name|dtrace_sprintf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|fmtdata
argument_list|,
name|recp
argument_list|,
name|nrecs
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|rval
operator|)
return|;
comment|/* 	 * Before we execute the specified command, flush fp to assure that 	 * any prior dt_printf()'s appear before the output of the command 	 * not after it. 	 */
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|dtp
operator|->
name|dt_sprintf_buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_freopen
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|void
modifier|*
name|fmtdata
parameter_list|,
specifier|const
name|dtrace_probedata_t
modifier|*
name|data
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
name|recp
parameter_list|,
name|uint_t
name|nrecs
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|selfbuf
index|[
literal|40
index|]
decl_stmt|,
name|restorebuf
index|[
literal|40
index|]
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|nfp
decl_stmt|;
name|int
name|rval
decl_stmt|,
name|errval
decl_stmt|;
name|dt_pfargv_t
modifier|*
name|pfv
init|=
name|fmtdata
decl_stmt|;
name|dt_pfargd_t
modifier|*
name|pfd
init|=
name|pfv
operator|->
name|pfv_argv
decl_stmt|;
name|rval
operator|=
name|dtrace_sprintf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|fmtdata
argument_list|,
name|recp
argument_list|,
name|nrecs
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
operator|||
name|fp
operator|==
name|NULL
condition|)
return|return
operator|(
name|rval
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|pfd
operator|->
name|pfd_preflen
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|pfd
operator|->
name|pfd_prefix
argument_list|,
name|DT_FREOPEN_RESTORE
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The only way to have the format string set to the value 		 * DT_FREOPEN_RESTORE is via the empty freopen() string -- 		 * denoting that we should restore the old stdout. 		 */
name|assert
argument_list|(
name|strcmp
argument_list|(
name|dtp
operator|->
name|dt_sprintf_buf
argument_list|,
name|DT_FREOPEN_RESTORE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_stdout_fd
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * We could complain here by generating an error, 			 * but it seems like overkill:  it seems that calling 			 * freopen() to restore stdout when freopen() has 			 * never before been called should just be a no-op, 			 * so we just return in this case. 			 */
return|return
operator|(
name|rval
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|restorebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|restorebuf
argument_list|)
argument_list|,
literal|"/dev/fd/%d"
argument_list|,
name|dtp
operator|->
name|dt_stdout_fd
argument_list|)
expr_stmt|;
name|filename
operator|=
name|restorebuf
expr_stmt|;
block|}
else|else
block|{
name|filename
operator|=
name|dtp
operator|->
name|dt_sprintf_buf
expr_stmt|;
block|}
comment|/* 	 * freopen(3C) will always close the specified stream and underlying 	 * file descriptor -- even if the specified file can't be opened. 	 * Even for the semantic cesspool that is standard I/O, this is 	 * surprisingly brain-dead behavior:  it means that any failure to 	 * open the specified file destroys the specified stream in the 	 * process -- which is particularly relevant when the specified stream 	 * happens (or rather, happened) to be stdout.  This could be resolved 	 * were there an "fdreopen()" equivalent of freopen() that allowed one 	 * to pass a file descriptor instead of the name of a file, but there 	 * is no such thing.  However, we can effect this ourselves by first 	 * fopen()'ing the desired file, and then (assuming that that works), 	 * freopen()'ing "/dev/fd/[fileno]", where [fileno] is the underlying 	 * file descriptor for the fopen()'d file.  This way, if the fopen() 	 * fails, we can fail the operation without destroying stdout. 	 */
if|if
condition|(
operator|(
name|nfp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"aF"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|char
modifier|*
name|faultstr
decl_stmt|;
name|int
name|len
init|=
literal|80
decl_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|faultstr
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|faultstr
argument_list|,
name|len
argument_list|,
literal|"couldn't freopen() \"%s\": %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|errval
operator|=
name|dt_handle_liberr
argument_list|(
name|dtp
argument_list|,
name|data
argument_list|,
name|faultstr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
return|return
operator|(
name|errval
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|selfbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|selfbuf
argument_list|)
argument_list|,
literal|"/dev/fd/%d"
argument_list|,
name|fileno
argument_list|(
name|nfp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_stdout_fd
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * If this is the first time that we're calling freopen(), 		 * we're going to stash away the file descriptor for stdout. 		 * We don't expect the dup(2) to fail, so if it does we must 		 * return failure. 		 */
if|if
condition|(
operator|(
name|dtp
operator|->
name|dt_stdout_fd
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|nfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|freopen
argument_list|(
name|selfbuf
argument_list|,
literal|"aF"
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|nfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|nfp
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !illumos */
comment|/* 	 * The 'standard output' (which is not necessarily stdout) 	 * treatment on FreeBSD is implemented differently than on 	 * Solaris because FreeBSD's freopen() will attempt to re-use 	 * the current file descriptor, causing the previous file to 	 * be closed and thereby preventing it from be re-activated 	 * later. 	 * 	 * For FreeBSD we use the concept of setting an output file 	 * pointer in the DTrace handle if a dtrace_freopen() has  	 * enabled another output file and we leave the caller's 	 * file pointer untouched. If it was actually stdout, then 	 * stdout remains open. If it was another file, then that 	 * file remains open. While a dtrace_freopen() has activated 	 * another file, we keep a pointer to that which we use in 	 * the output functions by preference and only use the caller's 	 * file pointer if no dtrace_freopen() call has been made. 	 * 	 * The check to see if we're re-activating the caller's 	 * output file is much the same as on Solaris. 	 */
if|if
condition|(
name|pfd
operator|->
name|pfd_preflen
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|pfd
operator|->
name|pfd_prefix
argument_list|,
name|DT_FREOPEN_RESTORE
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The only way to have the format string set to the value 		 * DT_FREOPEN_RESTORE is via the empty freopen() string -- 		 * denoting that we should restore the old stdout. 		 */
name|assert
argument_list|(
name|strcmp
argument_list|(
name|dtp
operator|->
name|dt_sprintf_buf
argument_list|,
name|DT_FREOPEN_RESTORE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_freopen_fp
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * We could complain here by generating an error, 			 * but it seems like overkill:  it seems that calling 			 * freopen() to restore stdout when freopen() has 			 * never before been called should just be a no-op, 			 * so we just return in this case. 			 */
return|return
operator|(
name|rval
operator|)
return|;
block|}
comment|/* 		 * At this point, to re-active the original output file, 		 * on FreeBSD we only code the current file that this 		 * function opened previously. 		 */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|dtp
operator|->
name|dt_freopen_fp
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_freopen_fp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|nfp
operator|=
name|fopen
argument_list|(
name|dtp
operator|->
name|dt_sprintf_buf
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|char
modifier|*
name|faultstr
decl_stmt|;
name|int
name|len
init|=
literal|80
decl_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
name|strlen
argument_list|(
name|dtp
operator|->
name|dt_sprintf_buf
argument_list|)
expr_stmt|;
name|faultstr
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|faultstr
argument_list|,
name|len
argument_list|,
literal|"couldn't freopen() \"%s\": %s"
argument_list|,
name|dtp
operator|->
name|dt_sprintf_buf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|errval
operator|=
name|dt_handle_liberr
argument_list|(
name|dtp
argument_list|,
name|data
argument_list|,
name|faultstr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
return|return
operator|(
name|errval
operator|)
return|;
block|}
if|if
condition|(
name|dtp
operator|->
name|dt_freopen_fp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|dtp
operator|->
name|dt_freopen_fp
argument_list|)
expr_stmt|;
comment|/* Remember that the output has been redirected to the new file. */
name|dtp
operator|->
name|dt_freopen_fp
operator|=
name|nfp
expr_stmt|;
endif|#
directive|endif
comment|/* illumos */
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|dtrace_fprintf
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|void
modifier|*
name|fmtdata
parameter_list|,
specifier|const
name|dtrace_probedata_t
modifier|*
name|data
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
name|recp
parameter_list|,
name|uint_t
name|nrecs
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|(
name|dt_printf_format
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|fmtdata
argument_list|,
name|recp
argument_list|,
name|nrecs
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|dtrace_printf_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dt_pfargv_t
modifier|*
name|pfv
init|=
name|dt_printf_create
argument_list|(
name|dtp
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|dt_pfargd_t
modifier|*
name|pfd
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pfv
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* errno has been set for us */
name|pfd
operator|=
name|pfv
operator|->
name|pfv_argv
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pfv
operator|->
name|pfv_argc
condition|;
name|i
operator|++
operator|,
name|pfd
operator|=
name|pfd
operator|->
name|pfd_next
control|)
block|{
specifier|const
name|dt_pfconv_t
modifier|*
name|pfc
init|=
name|pfd
operator|->
name|pfd_conv
decl_stmt|;
if|if
condition|(
name|pfc
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * If the output format is not %s then we assume that we have 		 * been given a correctly-sized format string, so we copy the 		 * true format name including the size modifier.  If the output 		 * format is %s, then either the input format is %s as well or 		 * it is one of our custom formats (e.g. pfprint_addr), so we 		 * must set pfd_fmt to be the output format conversion "s". 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|pfc
operator|->
name|pfc_ofmt
argument_list|,
literal|"s"
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|pfd
operator|->
name|pfd_fmt
argument_list|,
name|pfc
operator|->
name|pfc_name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|pfd
operator|->
name|pfd_fmt
argument_list|,
name|pfc
operator|->
name|pfc_ofmt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pfv
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|dtrace_printa_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dt_pfargv_t
modifier|*
name|pfv
init|=
name|dtrace_printf_create
argument_list|(
name|dtp
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|pfv
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* errno has been set for us */
name|pfv
operator|->
name|pfv_flags
operator||=
name|DT_PRINTF_AGGREGATION
expr_stmt|;
return|return
operator|(
name|pfv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|size_t
name|dtrace_printf_format
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|void
modifier|*
name|fmtdata
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|dt_pfargv_t
modifier|*
name|pfv
init|=
name|fmtdata
decl_stmt|;
name|dt_pfargd_t
modifier|*
name|pfd
init|=
name|pfv
operator|->
name|pfv_argv
decl_stmt|;
comment|/* 	 * An upper bound on the string length is the length of the original 	 * format string, plus three times the number of conversions (each 	 * conversion could add up an additional "ll" and/or pfd_width digit 	 * in the case of converting %? to %16) plus one for a terminating \0. 	 */
name|size_t
name|formatlen
init|=
name|strlen
argument_list|(
name|pfv
operator|->
name|pfv_format
argument_list|)
operator|+
literal|3
operator|*
name|pfv
operator|->
name|pfv_argc
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|format
init|=
name|alloca
argument_list|(
name|formatlen
argument_list|)
decl_stmt|;
name|char
modifier|*
name|f
init|=
name|format
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pfv
operator|->
name|pfv_argc
condition|;
name|i
operator|++
operator|,
name|pfd
operator|=
name|pfd
operator|->
name|pfd_next
control|)
block|{
specifier|const
name|dt_pfconv_t
modifier|*
name|pfc
init|=
name|pfd
operator|->
name|pfd_conv
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|width
init|=
name|pfd
operator|->
name|pfd_width
decl_stmt|;
name|int
name|prec
init|=
name|pfd
operator|->
name|pfd_prec
decl_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_preflen
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pfd
operator|->
name|pfd_preflen
condition|;
name|j
operator|++
control|)
operator|*
name|f
operator|++
operator|=
name|pfd
operator|->
name|pfd_prefix
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
name|pfc
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|f
operator|++
operator|=
literal|'%'
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_ALT
condition|)
operator|*
name|f
operator|++
operator|=
literal|'#'
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_ZPAD
condition|)
operator|*
name|f
operator|++
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_LEFT
condition|)
operator|*
name|f
operator|++
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_SPOS
condition|)
operator|*
name|f
operator|++
operator|=
literal|'+'
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_DYNWIDTH
condition|)
operator|*
name|f
operator|++
operator|=
literal|'*'
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_DYNPREC
condition|)
block|{
operator|*
name|f
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|f
operator|++
operator|=
literal|'*'
expr_stmt|;
block|}
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_GROUP
condition|)
operator|*
name|f
operator|++
operator|=
literal|'\''
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_SPACE
condition|)
operator|*
name|f
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|pfd
operator|->
name|pfd_flags
operator|&
name|DT_PFCONV_AGG
condition|)
operator|*
name|f
operator|++
operator|=
literal|'@'
expr_stmt|;
if|if
condition|(
name|width
operator|!=
literal|0
condition|)
name|f
operator|+=
name|snprintf
argument_list|(
name|f
argument_list|,
sizeof|sizeof
argument_list|(
name|format
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|prec
operator|!=
literal|0
condition|)
name|f
operator|+=
name|snprintf
argument_list|(
name|f
argument_list|,
sizeof|sizeof
argument_list|(
name|format
argument_list|)
argument_list|,
literal|".%d"
argument_list|,
name|prec
argument_list|)
expr_stmt|;
comment|/* 		 * If the output format is %s, then either %s is the underlying 		 * conversion or the conversion is one of our customized ones, 		 * e.g. pfprint_addr.  In these cases, put the original string 		 * name of the conversion (pfc_name) into the pickled format 		 * string rather than the derived conversion (pfd_fmt). 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|pfc
operator|->
name|pfc_ofmt
argument_list|,
literal|"s"
argument_list|)
operator|==
literal|0
condition|)
name|str
operator|=
name|pfc
operator|->
name|pfc_name
expr_stmt|;
else|else
name|str
operator|=
name|pfd
operator|->
name|pfd_fmt
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|str
index|[
name|j
index|]
operator|!=
literal|'\0'
condition|;
name|j
operator|++
control|)
operator|*
name|f
operator|++
operator|=
name|str
index|[
name|j
index|]
expr_stmt|;
block|}
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
comment|/* insert nul byte; do not count in return value */
name|assert
argument_list|(
name|f
operator|<
name|format
operator|+
name|formatlen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|s
argument_list|,
name|format
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|size_t
call|)
argument_list|(
name|f
operator|-
name|format
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_fprinta
parameter_list|(
specifier|const
name|dtrace_aggdata_t
modifier|*
name|adp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|dtrace_aggdesc_t
modifier|*
name|agg
init|=
name|adp
operator|->
name|dtada_desc
decl_stmt|;
specifier|const
name|dtrace_recdesc_t
modifier|*
name|recp
init|=
operator|&
name|agg
operator|->
name|dtagd_rec
index|[
literal|0
index|]
decl_stmt|;
name|uint_t
name|nrecs
init|=
name|agg
operator|->
name|dtagd_nrecs
decl_stmt|;
name|dt_pfwalk_t
modifier|*
name|pfw
init|=
name|arg
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|pfw
operator|->
name|pfw_argv
operator|->
name|pfv_dtp
decl_stmt|;
name|int
name|id
decl_stmt|;
if|if
condition|(
name|dt_printf_getint
argument_list|(
name|dtp
argument_list|,
name|recp
operator|++
argument_list|,
name|nrecs
operator|--
argument_list|,
name|adp
operator|->
name|dtada_data
argument_list|,
name|adp
operator|->
name|dtada_size
argument_list|,
operator|&
name|id
argument_list|)
operator|!=
literal|0
operator|||
name|pfw
operator|->
name|pfw_aid
operator|!=
name|id
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no aggregation id or id does not match */
if|if
condition|(
name|dt_printf_format
argument_list|(
name|dtp
argument_list|,
name|pfw
operator|->
name|pfw_fp
argument_list|,
name|pfw
operator|->
name|pfw_argv
argument_list|,
name|recp
argument_list|,
name|nrecs
argument_list|,
name|adp
operator|->
name|dtada_data
argument_list|,
name|adp
operator|->
name|dtada_size
argument_list|,
operator|&
name|adp
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|pfw
operator|->
name|pfw_err
operator|=
name|dtp
operator|->
name|dt_errno
operator|)
return|;
comment|/* 	 * Cast away the const to set the bit indicating that this aggregation 	 * has been printed. 	 */
operator|(
operator|(
name|dtrace_aggdesc_t
operator|*
operator|)
name|agg
operator|)
operator|->
name|dtagd_flags
operator||=
name|DTRACE_AGD_PRINTED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_fprintas
parameter_list|(
specifier|const
name|dtrace_aggdata_t
modifier|*
modifier|*
name|aggsdata
parameter_list|,
name|int
name|naggvars
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|dtrace_aggdata_t
modifier|*
name|aggdata
init|=
name|aggsdata
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|dtrace_aggdesc_t
modifier|*
name|agg
init|=
name|aggdata
operator|->
name|dtada_desc
decl_stmt|;
specifier|const
name|dtrace_recdesc_t
modifier|*
name|rec
init|=
operator|&
name|agg
operator|->
name|dtagd_rec
index|[
literal|1
index|]
decl_stmt|;
name|uint_t
name|nrecs
init|=
name|agg
operator|->
name|dtagd_nrecs
operator|-
literal|1
decl_stmt|;
name|dt_pfwalk_t
modifier|*
name|pfw
init|=
name|arg
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|pfw
operator|->
name|pfw_argv
operator|->
name|pfv_dtp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dt_printf_format
argument_list|(
name|dtp
argument_list|,
name|pfw
operator|->
name|pfw_fp
argument_list|,
name|pfw
operator|->
name|pfw_argv
argument_list|,
name|rec
argument_list|,
name|nrecs
argument_list|,
name|aggdata
operator|->
name|dtada_data
argument_list|,
name|aggdata
operator|->
name|dtada_size
argument_list|,
name|aggsdata
argument_list|,
name|naggvars
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|pfw
operator|->
name|pfw_err
operator|=
name|dtp
operator|->
name|dt_errno
operator|)
return|;
comment|/* 	 * For each aggregation, indicate that it has been printed, casting 	 * away the const as necessary. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|naggvars
condition|;
name|i
operator|++
control|)
block|{
name|agg
operator|=
name|aggsdata
index|[
name|i
index|]
operator|->
name|dtada_desc
expr_stmt|;
operator|(
operator|(
name|dtrace_aggdesc_t
operator|*
operator|)
name|agg
operator|)
operator|->
name|dtagd_flags
operator||=
name|DTRACE_AGD_PRINTED
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|dtrace_fprinta
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|void
modifier|*
name|fmtdata
parameter_list|,
specifier|const
name|dtrace_probedata_t
modifier|*
name|data
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
name|recs
parameter_list|,
name|uint_t
name|nrecs
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|dt_pfwalk_t
name|pfw
decl_stmt|;
name|int
name|i
decl_stmt|,
name|naggvars
init|=
literal|0
decl_stmt|;
name|dtrace_aggvarid_t
modifier|*
name|aggvars
decl_stmt|;
name|aggvars
operator|=
name|alloca
argument_list|(
name|nrecs
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_aggvarid_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This might be a printa() with multiple aggregation variables.  We 	 * need to scan forward through the records until we find a record from 	 * a different statement. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrecs
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|dtrace_recdesc_t
modifier|*
name|nrec
init|=
operator|&
name|recs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|nrec
operator|->
name|dtrd_uarg
operator|!=
name|recs
operator|->
name|dtrd_uarg
condition|)
break|break;
if|if
condition|(
name|nrec
operator|->
name|dtrd_action
operator|!=
name|recs
operator|->
name|dtrd_action
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADAGG
argument_list|)
operator|)
return|;
name|aggvars
index|[
name|naggvars
operator|++
index|]
operator|=
comment|/* LINTED - alignment */
operator|*
operator|(
operator|(
name|dtrace_aggvarid_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|buf
operator|+
name|nrec
operator|->
name|dtrd_offset
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|naggvars
operator|==
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADAGG
argument_list|)
operator|)
return|;
name|pfw
operator|.
name|pfw_argv
operator|=
name|fmtdata
expr_stmt|;
name|pfw
operator|.
name|pfw_fp
operator|=
name|fp
expr_stmt|;
name|pfw
operator|.
name|pfw_err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|naggvars
operator|==
literal|1
condition|)
block|{
name|pfw
operator|.
name|pfw_aid
operator|=
name|aggvars
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|dtrace_aggregate_walk_sorted
argument_list|(
name|dtp
argument_list|,
name|dt_fprinta
argument_list|,
operator|&
name|pfw
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|pfw
operator|.
name|pfw_err
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
block|}
else|else
block|{
if|if
condition|(
name|dtrace_aggregate_walk_joined
argument_list|(
name|dtp
argument_list|,
name|aggvars
argument_list|,
name|naggvars
argument_list|,
name|dt_fprintas
argument_list|,
operator|&
name|pfw
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|pfw
operator|.
name|pfw_err
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

end_unit

