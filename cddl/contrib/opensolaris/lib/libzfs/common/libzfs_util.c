begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  * Copyright (c) 2011, 2015 by Delphix. All rights reserved.  * Copyright 2016 Igor Kozhukhov<ikozhukhov@gmail.com>  */
end_comment

begin_comment
comment|/*  * Internal utility routines for the ZFS library.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<sys/mnttab.h>
end_include

begin_include
include|#
directive|include
file|<sys/mntent.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|<libzfs_core.h>
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_include
include|#
directive|include
file|"zfs_prop.h"
end_include

begin_include
include|#
directive|include
file|"zfeature_common.h"
end_include

begin_function
name|int
name|libzfs_errno
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
return|return
operator|(
name|hdl
operator|->
name|libzfs_error
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|libzfs_error_action
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
return|return
operator|(
name|hdl
operator|->
name|libzfs_action
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|libzfs_error_description
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
if|if
condition|(
name|hdl
operator|->
name|libzfs_desc
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|hdl
operator|->
name|libzfs_desc
operator|)
return|;
switch|switch
condition|(
name|hdl
operator|->
name|libzfs_error
condition|)
block|{
case|case
name|EZFS_NOMEM
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"out of memory"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADPROP
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid property value"
argument_list|)
operator|)
return|;
case|case
name|EZFS_PROPREADONLY
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"read-only property"
argument_list|)
operator|)
return|;
case|case
name|EZFS_PROPTYPE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property doesn't apply to "
literal|"datasets of this type"
argument_list|)
operator|)
return|;
case|case
name|EZFS_PROPNONINHERIT
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property cannot be inherited"
argument_list|)
operator|)
return|;
case|case
name|EZFS_PROPSPACE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid quota or reservation"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADTYPE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"operation not applicable to "
literal|"datasets of this type"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BUSY
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool or dataset is busy"
argument_list|)
operator|)
return|;
case|case
name|EZFS_EXISTS
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool or dataset exists"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NOENT
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such pool or dataset"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADSTREAM
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid backup stream"
argument_list|)
operator|)
return|;
case|case
name|EZFS_DSREADONLY
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset is read-only"
argument_list|)
operator|)
return|;
case|case
name|EZFS_VOLTOOBIG
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume size exceeds limit for "
literal|"this system"
argument_list|)
operator|)
return|;
case|case
name|EZFS_INVALIDNAME
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid name"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADRESTORE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unable to restore to "
literal|"destination"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADBACKUP
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"backup failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADTARGET
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid target vdev"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NODEVICE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such device in pool"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADDEV
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid device"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NOREPLICAS
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no valid replicas"
argument_list|)
operator|)
return|;
case|case
name|EZFS_RESILVERING
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"currently resilvering"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADVERSION
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unsupported version or "
literal|"feature"
argument_list|)
operator|)
return|;
case|case
name|EZFS_POOLUNAVAIL
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool is unavailable"
argument_list|)
operator|)
return|;
case|case
name|EZFS_DEVOVERFLOW
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"too many devices in one vdev"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADPATH
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"must be an absolute path"
argument_list|)
operator|)
return|;
case|case
name|EZFS_CROSSTARGET
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"operation crosses datasets or "
literal|"pools"
argument_list|)
operator|)
return|;
case|case
name|EZFS_ZONED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset in use by local zone"
argument_list|)
operator|)
return|;
case|case
name|EZFS_MOUNTFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"mount failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_UMOUNTFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"umount failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_UNSHARENFSFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unshare(1M) failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_SHARENFSFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"share(1M) failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_UNSHARESMBFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"smb remove share failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_SHARESMBFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"smb add share failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_PERM
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"permission denied"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NOSPC
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"out of space"
argument_list|)
operator|)
return|;
case|case
name|EZFS_FAULT
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bad address"
argument_list|)
operator|)
return|;
case|case
name|EZFS_IO
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"I/O error"
argument_list|)
operator|)
return|;
case|case
name|EZFS_INTR
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"signal received"
argument_list|)
operator|)
return|;
case|case
name|EZFS_ISSPARE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"device is reserved as a hot "
literal|"spare"
argument_list|)
operator|)
return|;
case|case
name|EZFS_INVALCONFIG
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid vdev configuration"
argument_list|)
operator|)
return|;
case|case
name|EZFS_RECURSIVE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"recursive dataset dependency"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NOHISTORY
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no history available"
argument_list|)
operator|)
return|;
case|case
name|EZFS_POOLPROPS
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"failed to retrieve "
literal|"pool properties"
argument_list|)
operator|)
return|;
case|case
name|EZFS_POOL_NOTSUP
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"operation not supported "
literal|"on this type of pool"
argument_list|)
operator|)
return|;
case|case
name|EZFS_POOL_INVALARG
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid argument for "
literal|"this pool operation"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NAMETOOLONG
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset name is too long"
argument_list|)
operator|)
return|;
case|case
name|EZFS_OPENFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"open failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NOCAP
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"disk capacity information could not be retrieved"
argument_list|)
operator|)
return|;
case|case
name|EZFS_LABELFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"write of label failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADWHO
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid user/group"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADPERM
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid permission"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADPERMSET
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid permission set name"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NODELEGATION
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"delegated administration is "
literal|"disabled on pool"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADCACHE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid or missing cache file"
argument_list|)
operator|)
return|;
case|case
name|EZFS_ISL2CACHE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"device is in use as a cache"
argument_list|)
operator|)
return|;
case|case
name|EZFS_VDEVNOTSUP
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"vdev specification is not "
literal|"supported"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NOTSUP
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"operation not supported "
literal|"on this dataset"
argument_list|)
operator|)
return|;
case|case
name|EZFS_ACTIVE_SPARE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool has active shared spare "
literal|"device"
argument_list|)
operator|)
return|;
case|case
name|EZFS_UNPLAYED_LOGS
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"log device has unplayed intent "
literal|"logs"
argument_list|)
operator|)
return|;
case|case
name|EZFS_REFTAG_RELE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such tag on this dataset"
argument_list|)
operator|)
return|;
case|case
name|EZFS_REFTAG_HOLD
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"tag already exists on this "
literal|"dataset"
argument_list|)
operator|)
return|;
case|case
name|EZFS_TAGTOOLONG
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"tag too long"
argument_list|)
operator|)
return|;
case|case
name|EZFS_PIPEFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pipe create failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_THREADCREATEFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"thread create failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_POSTSPLIT_ONLINE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"disk was split from this pool "
literal|"into a new one"
argument_list|)
operator|)
return|;
case|case
name|EZFS_SCRUBBING
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"currently scrubbing; "
literal|"use 'zpool scrub -s' to cancel current scrub"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NO_SCRUB
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"there is no active scrub"
argument_list|)
operator|)
return|;
case|case
name|EZFS_DIFF
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unable to generate diffs"
argument_list|)
operator|)
return|;
case|case
name|EZFS_DIFFDATA
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid diff data"
argument_list|)
operator|)
return|;
case|case
name|EZFS_POOLREADONLY
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool is read-only"
argument_list|)
operator|)
return|;
case|case
name|EZFS_UNKNOWN
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unknown error"
argument_list|)
operator|)
return|;
default|default:
name|assert
argument_list|(
name|hdl
operator|->
name|libzfs_error
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no error"
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*PRINTFLIKE2*/
end_comment

begin_function
name|void
name|zfs_error_aux
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|hdl
operator|->
name|libzfs_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|hdl
operator|->
name|libzfs_desc
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|hdl
operator|->
name|libzfs_desc_active
operator|=
literal|1
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_verror
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|hdl
operator|->
name|libzfs_action
argument_list|,
sizeof|sizeof
argument_list|(
name|hdl
operator|->
name|libzfs_action
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|hdl
operator|->
name|libzfs_error
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|hdl
operator|->
name|libzfs_desc_active
condition|)
name|hdl
operator|->
name|libzfs_desc_active
operator|=
literal|0
expr_stmt|;
else|else
name|hdl
operator|->
name|libzfs_desc
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|hdl
operator|->
name|libzfs_printerr
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EZFS_UNKNOWN
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"internal "
literal|"error: %s\n"
argument_list|)
argument_list|,
name|libzfs_error_description
argument_list|(
name|hdl
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|hdl
operator|->
name|libzfs_action
argument_list|,
name|libzfs_error_description
argument_list|(
name|hdl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EZFS_NOMEM
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|zfs_error
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
literal|"%s"
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE3*/
end_comment

begin_function
name|int
name|zfs_error_fmt
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_common_error
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EPERM
case|:
case|case
name|EACCES
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_PERM
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|ECANCELED
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODELEGATION
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|EIO
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_IO
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|EFAULT
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_FAULT
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|EINTR
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_INTR
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_standard_error
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
return|return
operator|(
name|zfs_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
literal|"%s"
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE3*/
end_comment

begin_function
name|int
name|zfs_standard_error_fmt
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_common_error
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|ENXIO
case|:
case|case
name|ENODEV
case|:
case|case
name|EPIPE
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_IO
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOENT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset does not exist"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOSPC
case|:
case|case
name|EDQUOT
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOSPC
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|EEXIST
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset already exists"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBUSY
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset is busy"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_BUSY
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|EROFS
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOLREADONLY
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENAMETOOLONG
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_NAMETOOLONG
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOTSUP
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAGAIN
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool I/O is currently suspended"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOLUNAVAIL
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
default|default:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_UNKNOWN
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zpool_standard_error
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
return|return
operator|(
name|zpool_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
literal|"%s"
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE3*/
end_comment

begin_function
name|int
name|zpool_standard_error_fmt
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_common_error
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|ENODEV
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOENT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such pool or dataset"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|EEXIST
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool already exists"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBUSY
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool is busy"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_BUSY
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENXIO
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more devices is currently unavailable"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENAMETOOLONG
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_DEVOVERFLOW
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOTSUP
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOL_NOTSUP
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOL_INVALARG
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOSPC
case|:
case|case
name|EDQUOT
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOSPC
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|EAGAIN
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool I/O is currently suspended"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOLUNAVAIL
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|EROFS
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOLREADONLY
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
default|default:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_UNKNOWN
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Display an out of memory error message and abort the current program.  */
end_comment

begin_function
name|int
name|no_memory
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOMEM
argument_list|,
literal|"internal error"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A safe form of malloc() which will die if the allocation fails.  */
end_comment

begin_function
name|void
modifier|*
name|zfs_alloc
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A safe form of asprintf() which will die if the allocation fails.  */
end_comment

begin_comment
comment|/*PRINTFLIKE2*/
end_comment

begin_function
name|char
modifier|*
name|zfs_asprintf
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|int
name|err
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|err
operator|=
name|vasprintf
argument_list|(
operator|&
name|ret
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A safe form of realloc(), which also zeroes newly allocated space.  */
end_comment

begin_function
name|void
modifier|*
name|zfs_realloc
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|newsize
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|newsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|+
name|oldsize
argument_list|,
operator|(
name|newsize
operator|-
name|oldsize
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A safe form of strdup() which will die if the allocation fails.  */
end_comment

begin_function
name|char
modifier|*
name|zfs_strdup
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a number to an appropriately human-readable output.  */
end_comment

begin_function
name|void
name|zfs_nicenum
parameter_list|(
name|uint64_t
name|num
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|uint64_t
name|n
init|=
name|num
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|char
name|u
decl_stmt|;
while|while
condition|(
name|n
operator|>=
literal|1024
condition|)
block|{
name|n
operator|/=
literal|1024
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
name|u
operator|=
literal|" KMGTPE"
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"%llu"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|num
operator|&
operator|(
operator|(
literal|1ULL
operator|<<
literal|10
operator|*
name|index
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If this is an even multiple of the base, always display 		 * without any decimal precision. 		 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"%llu%c"
argument_list|,
name|n
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We want to choose a precision that reflects the best choice 		 * for fitting in 5 characters.  This can get rather tricky when 		 * we have numbers that are very close to an order of magnitude. 		 * For example, when displaying 10239 (which is really 9.999K), 		 * we want only a single place of precision for 10.0K.  We could 		 * develop some complex heuristics for this, but it's much 		 * easier just to try each combination in turn. 		 */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"%.*f%c"
argument_list|,
name|i
argument_list|,
operator|(
name|double
operator|)
name|num
operator|/
operator|(
literal|1ULL
operator|<<
literal|10
operator|*
name|index
operator|)
argument_list|,
name|u
argument_list|)
operator|<=
literal|5
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|libzfs_print_on_error
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|boolean_t
name|printerr
parameter_list|)
block|{
name|hdl
operator|->
name|libzfs_printerr
operator|=
name|printerr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|libzfs_load
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|modfind
argument_list|(
literal|"zfs"
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Not present in kernel, try loading it. */
if|if
condition|(
name|kldload
argument_list|(
literal|"zfs"
argument_list|)
operator|<
literal|0
operator|||
name|modfind
argument_list|(
literal|"zfs"
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|libzfs_handle_t
modifier|*
name|libzfs_init
parameter_list|(
name|void
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
decl_stmt|;
if|if
condition|(
operator|(
name|hdl
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|libzfs_handle_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|libzfs_load
argument_list|()
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hdl
operator|->
name|libzfs_fd
operator|=
name|open
argument_list|(
name|ZFS_DEV
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hdl
operator|->
name|libzfs_mnttab
operator|=
name|fopen
argument_list|(
name|MNTTAB
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|hdl
operator|->
name|libzfs_sharetab
operator|=
name|fopen
argument_list|(
name|ZFS_EXPORTS_PATH
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|libzfs_core_init
argument_list|()
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hdl
operator|->
name|libzfs_mnttab
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hdl
operator|->
name|libzfs_sharetab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|zfs_prop_init
argument_list|()
expr_stmt|;
name|zpool_prop_init
argument_list|()
expr_stmt|;
name|zpool_feature_init
argument_list|()
expr_stmt|;
name|libzfs_mnttab_init
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|hdl
operator|)
return|;
block|}
end_function

begin_function
name|void
name|libzfs_fini
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdl
operator|->
name|libzfs_mnttab
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hdl
operator|->
name|libzfs_mnttab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdl
operator|->
name|libzfs_sharetab
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hdl
operator|->
name|libzfs_sharetab
argument_list|)
expr_stmt|;
name|zfs_uninit_libshare
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|zpool_free_handles
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|libzfs_fru_clear
argument_list|(
name|hdl
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|namespace_clear
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|libzfs_mnttab_fini
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|libzfs_core_fini
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|libzfs_handle_t
modifier|*
name|zpool_get_handle
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zpool_hdl
operator|)
return|;
block|}
end_function

begin_function
name|libzfs_handle_t
modifier|*
name|zfs_get_handle
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zfs_hdl
operator|)
return|;
block|}
end_function

begin_function
name|zpool_handle_t
modifier|*
name|zfs_get_pool_handle
parameter_list|(
specifier|const
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zpool_hdl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a name, determine whether or not it's a valid path  * (starts with '/' or "./").  If so, walk the mnttab trying  * to match the device number.  If not, treat the path as an  * fs/vol/snap/bkmark name.  */
end_comment

begin_function
name|zfs_handle_t
modifier|*
name|zfs_path_to_zhandle
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|zfs_type_t
name|argtype
parameter_list|)
block|{
name|struct
name|stat64
name|statbuf
decl_stmt|;
name|struct
name|extmnttab
name|entry
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|strncmp
argument_list|(
name|path
argument_list|,
literal|"./"
argument_list|,
name|strlen
argument_list|(
literal|"./"
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * It's not a valid path, assume it's a name of type 'argtype'. 		 */
return|return
operator|(
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|argtype
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|stat64
argument_list|(
name|path
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|illumos
name|rewind
argument_list|(
name|hdl
operator|->
name|libzfs_mnttab
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|getextmntent
argument_list|(
name|hdl
operator|->
name|libzfs_mnttab
argument_list|,
operator|&
name|entry
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|makedevice
argument_list|(
name|entry
operator|.
name|mnt_major
argument_list|,
name|entry
operator|.
name|mnt_minor
argument_list|)
operator|==
name|statbuf
operator|.
name|st_dev
condition|)
block|{
break|break;
block|}
block|}
else|#
directive|else
block|{
name|struct
name|statfs
name|sfs
decl_stmt|;
name|ret
operator|=
name|statfs
argument_list|(
name|path
argument_list|,
operator|&
name|sfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|statfs2mnttab
argument_list|(
operator|&
name|sfs
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* illumos */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|.
name|mnt_fstype
argument_list|,
name|MNTTYPE_ZFS
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"'%s': not a ZFS filesystem\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|entry
operator|.
name|mnt_special
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the zc_nvlist_dst member to prepare for receiving an nvlist from  * an ioctl().  */
end_comment

begin_function
name|int
name|zcmd_alloc_dst_nvlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
literal|16
operator|*
literal|1024
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_dst_size
operator|=
name|len
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_dst
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|zc
operator|->
name|zc_nvlist_dst_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zc
operator|->
name|zc_nvlist_dst
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when an ioctl() which returns an nvlist fails with ENOMEM.  This will  * expand the nvlist to the size specified in 'zc_nvlist_dst_size', which was  * filled in by the kernel to indicate the actual required size.  */
end_comment

begin_function
name|int
name|zcmd_expand_dst_nvlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|->
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_dst
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|zc
operator|->
name|zc_nvlist_dst_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zc
operator|->
name|zc_nvlist_dst
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called to free the src and dst nvlists stored in the command structure.  */
end_comment

begin_function
name|void
name|zcmd_free_nvlists
parameter_list|(
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|->
name|zc_nvlist_conf
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|->
name|zc_nvlist_src
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|->
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_conf
operator|=
name|NULL
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_src
operator|=
name|NULL
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_dst
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zcmd_write_nvlist_com
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|uint64_t
modifier|*
name|outnv
parameter_list|,
name|uint64_t
modifier|*
name|outlen
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|char
modifier|*
name|packed
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|verify
argument_list|(
name|nvlist_size
argument_list|(
name|nvl
argument_list|,
operator|&
name|len
argument_list|,
name|NV_ENCODE_NATIVE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|packed
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|verify
argument_list|(
name|nvlist_pack
argument_list|(
name|nvl
argument_list|,
operator|&
name|packed
argument_list|,
operator|&
name|len
argument_list|,
name|NV_ENCODE_NATIVE
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|outnv
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|packed
expr_stmt|;
operator|*
name|outlen
operator|=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zcmd_write_conf_nvlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
return|return
operator|(
name|zcmd_write_nvlist_com
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
operator|->
name|zc_nvlist_conf
argument_list|,
operator|&
name|zc
operator|->
name|zc_nvlist_conf_size
argument_list|,
name|nvl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zcmd_write_src_nvlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
return|return
operator|(
name|zcmd_write_nvlist_com
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
operator|->
name|zc_nvlist_src
argument_list|,
operator|&
name|zc
operator|->
name|zc_nvlist_src_size
argument_list|,
name|nvl
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unpacks an nvlist from the ZFS ioctl command structure.  */
end_comment

begin_function
name|int
name|zcmd_read_dst_nvlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvlp
parameter_list|)
block|{
if|if
condition|(
name|nvlist_unpack
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|->
name|zc_nvlist_dst
argument_list|,
name|zc
operator|->
name|zc_nvlist_dst_size
argument_list|,
name|nvlp
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|no_memory
argument_list|(
name|hdl
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_ioctl
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|request
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|)
block|{
return|return
operator|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|request
argument_list|,
name|zc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ================================================================  * API shared by zfs and zpool property management  * ================================================================  */
end_comment

begin_function
specifier|static
name|void
name|zprop_print_headers
parameter_list|(
name|zprop_get_cbdata_t
modifier|*
name|cbp
parameter_list|,
name|zfs_type_t
name|type
parameter_list|)
block|{
name|zprop_list_t
modifier|*
name|pl
init|=
name|cbp
operator|->
name|cb_proplist
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|title
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_scripted
condition|)
return|return;
comment|/* 	 * Start with the length of the column headers. 	 */
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_NAME
index|]
operator|=
name|strlen
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"NAME"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_PROPERTY
index|]
operator|=
name|strlen
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"PROPERTY"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_VALUE
index|]
operator|=
name|strlen
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"VALUE"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_RECVD
index|]
operator|=
name|strlen
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"RECEIVED"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_SOURCE
index|]
operator|=
name|strlen
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"SOURCE"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* first property is always NAME */
name|assert
argument_list|(
name|cbp
operator|->
name|cb_proplist
operator|->
name|pl_prop
operator|==
operator|(
operator|(
name|type
operator|==
name|ZFS_TYPE_POOL
operator|)
condition|?
name|ZPOOL_PROP_NAME
else|:
name|ZFS_PROP_NAME
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Go through and calculate the widths for each column.  For the 	 * 'source' column, we kludge it up by taking the worst-case scenario of 	 * inheriting from the longest name.  This is acceptable because in the 	 * majority of cases 'SOURCE' is the last column displayed, and we don't 	 * use the width anyway.  Note that the 'VALUE' column can be oversized, 	 * if the name of the property is much longer than any values we find. 	 */
for|for
control|(
name|pl
operator|=
name|cbp
operator|->
name|cb_proplist
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
comment|/* 		 * 'PROPERTY' column 		 */
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|!=
name|ZPROP_INVAL
condition|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
operator|(
name|type
operator|==
name|ZFS_TYPE_POOL
operator|)
condition|?
name|zpool_prop_to_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
else|:
name|zfs_prop_to_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|propname
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_PROPERTY
index|]
condition|)
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_PROPERTY
index|]
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|pl
operator|->
name|pl_user_prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_PROPERTY
index|]
condition|)
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_PROPERTY
index|]
operator|=
name|len
expr_stmt|;
block|}
comment|/* 		 * 'VALUE' column.  The first property is always the 'name' 		 * property that was tacked on either by /sbin/zfs's 		 * zfs_do_get() or when calling zprop_expand_list(), so we 		 * ignore its width.  If the user specified the name property 		 * to display, then it will be later in the list in any case. 		 */
if|if
condition|(
name|pl
operator|!=
name|cbp
operator|->
name|cb_proplist
operator|&&
name|pl
operator|->
name|pl_width
operator|>
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_VALUE
index|]
condition|)
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_VALUE
index|]
operator|=
name|pl
operator|->
name|pl_width
expr_stmt|;
comment|/* 'RECEIVED' column. */
if|if
condition|(
name|pl
operator|!=
name|cbp
operator|->
name|cb_proplist
operator|&&
name|pl
operator|->
name|pl_recvd_width
operator|>
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_RECVD
index|]
condition|)
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_RECVD
index|]
operator|=
name|pl
operator|->
name|pl_recvd_width
expr_stmt|;
comment|/* 		 * 'NAME' and 'SOURCE' columns 		 */
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|==
operator|(
name|type
operator|==
name|ZFS_TYPE_POOL
condition|?
name|ZPOOL_PROP_NAME
else|:
name|ZFS_PROP_NAME
operator|)
operator|&&
name|pl
operator|->
name|pl_width
operator|>
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_NAME
index|]
condition|)
block|{
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_NAME
index|]
operator|=
name|pl
operator|->
name|pl_width
expr_stmt|;
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_SOURCE
index|]
operator|=
name|pl
operator|->
name|pl_width
operator|+
name|strlen
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"inherited from"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Now go through and print the headers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZFS_GET_NCOLS
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|cbp
operator|->
name|cb_columns
index|[
name|i
index|]
condition|)
block|{
case|case
name|GET_COL_NAME
case|:
name|title
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"NAME"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_COL_PROPERTY
case|:
name|title
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"PROPERTY"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_COL_VALUE
case|:
name|title
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"VALUE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_COL_RECVD
case|:
name|title
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"RECEIVED"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_COL_SOURCE
case|:
name|title
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"SOURCE"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|title
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|title
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|ZFS_GET_NCOLS
operator|-
literal|1
operator|)
operator|||
name|cbp
operator|->
name|cb_columns
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|GET_COL_NONE
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|title
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s  "
argument_list|,
name|cbp
operator|->
name|cb_colwidths
index|[
name|cbp
operator|->
name|cb_columns
index|[
name|i
index|]
index|]
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display a single line of output, according to the settings in the callback  * structure.  */
end_comment

begin_function
name|void
name|zprop_print_one_property
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|zprop_get_cbdata_t
modifier|*
name|cbp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|zprop_source_t
name|sourcetype
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|recvd_value
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
comment|/* 	 * Ignore those source types that the user has chosen to ignore. 	 */
if|if
condition|(
operator|(
name|sourcetype
operator|&
name|cbp
operator|->
name|cb_sources
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
name|zprop_print_headers
argument_list|(
name|cbp
argument_list|,
name|cbp
operator|->
name|cb_type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZFS_GET_NCOLS
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|cbp
operator|->
name|cb_columns
index|[
name|i
index|]
condition|)
block|{
case|case
name|GET_COL_NAME
case|:
name|str
operator|=
name|name
expr_stmt|;
break|break;
case|case
name|GET_COL_PROPERTY
case|:
name|str
operator|=
name|propname
expr_stmt|;
break|break;
case|case
name|GET_COL_VALUE
case|:
name|str
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|GET_COL_SOURCE
case|:
switch|switch
condition|(
name|sourcetype
condition|)
block|{
case|case
name|ZPROP_SRC_NONE
case|:
name|str
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
name|ZPROP_SRC_DEFAULT
case|:
name|str
operator|=
literal|"default"
expr_stmt|;
break|break;
case|case
name|ZPROP_SRC_LOCAL
case|:
name|str
operator|=
literal|"local"
expr_stmt|;
break|break;
case|case
name|ZPROP_SRC_TEMPORARY
case|:
name|str
operator|=
literal|"temporary"
expr_stmt|;
break|break;
case|case
name|ZPROP_SRC_INHERITED
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"inherited from %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|str
operator|=
name|buf
expr_stmt|;
break|break;
case|case
name|ZPROP_SRC_RECEIVED
case|:
name|str
operator|=
literal|"received"
expr_stmt|;
break|break;
default|default:
name|str
operator|=
name|NULL
expr_stmt|;
name|assert
argument_list|(
operator|!
literal|"unhandled zprop_source_t"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GET_COL_RECVD
case|:
name|str
operator|=
operator|(
name|recvd_value
operator|==
name|NULL
condition|?
literal|"-"
else|:
name|recvd_value
operator|)
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
if|if
condition|(
name|cbp
operator|->
name|cb_columns
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|GET_COL_NONE
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cbp
operator|->
name|cb_scripted
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\t"
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s  "
argument_list|,
name|cbp
operator|->
name|cb_colwidths
index|[
name|cbp
operator|->
name|cb_columns
index|[
name|i
index|]
index|]
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a numeric suffix, convert the value into a number of bits that the  * resulting value must be shifted.  */
end_comment

begin_function
specifier|static
name|int
name|str2shift
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ends
init|=
literal|"BKMGTPEZ"
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|ends
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|toupper
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
operator|==
name|ends
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|strlen
argument_list|(
name|ends
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid numeric suffix '%s'"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * We want to allow trailing 'b' characters for 'GB' or 'Mb'.  But don't 	 * allow 'BB' - that's just weird. 	 */
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|toupper
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'B'
operator|&&
name|buf
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
name|toupper
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|'B'
operator|)
condition|)
return|return
operator|(
literal|10
operator|*
name|i
operator|)
return|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid numeric suffix '%s'"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a string of the form '100G' into a real number.  Used when setting  * properties or creating a volume.  'buf' is used to place an extended error  * message for the caller to use.  */
end_comment

begin_function
name|int
name|zfs_nicestrtonum
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|uint64_t
modifier|*
name|num
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|shift
decl_stmt|;
operator|*
name|num
operator|=
literal|0
expr_stmt|;
comment|/* Check to see if this looks like a number.  */
if|if
condition|(
operator|(
name|value
index|[
literal|0
index|]
operator|<
literal|'0'
operator|||
name|value
index|[
literal|0
index|]
operator|>
literal|'9'
operator|)
operator|&&
name|value
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
name|hdl
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bad numeric value '%s'"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Rely on strtoull() to process the numeric portion.  */
name|errno
operator|=
literal|0
expr_stmt|;
operator|*
name|num
operator|=
name|strtoull
argument_list|(
name|value
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* 	 * Check for ERANGE, which indicates that the value is too large to fit 	 * in a 64-bit value. 	 */
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
if|if
condition|(
name|hdl
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"numeric value is too large"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * If we have a decimal value, then do the computation with floating 	 * point arithmetic.  Otherwise, use standard arithmetic. 	 */
if|if
condition|(
operator|*
name|end
operator|==
literal|'.'
condition|)
block|{
name|double
name|fval
init|=
name|strtod
argument_list|(
name|value
argument_list|,
operator|&
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|shift
operator|=
name|str2shift
argument_list|(
name|hdl
argument_list|,
name|end
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fval
operator|*=
name|pow
argument_list|(
literal|2
argument_list|,
name|shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|fval
operator|>
name|UINT64_MAX
condition|)
block|{
if|if
condition|(
name|hdl
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"numeric value is too large"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|num
operator|=
operator|(
name|uint64_t
operator|)
name|fval
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|shift
operator|=
name|str2shift
argument_list|(
name|hdl
argument_list|,
name|end
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Check for overflow */
if|if
condition|(
name|shift
operator|>=
literal|64
operator|||
operator|(
operator|*
name|num
operator|<<
name|shift
operator|)
operator|>>
name|shift
operator|!=
operator|*
name|num
condition|)
block|{
if|if
condition|(
name|hdl
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"numeric value is too large"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|num
operator|<<=
name|shift
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a propname=value nvpair to set, parse any numeric properties  * (index, boolean, etc) if they are specified as strings and add the  * resulting nvpair to the returned nvlist.  *  * At the DSL layer, all properties are either 64-bit numbers or strings.  * We want the user to be able to ignore this fact and specify properties  * as native values (numbers, for example) or as strings (to simplify  * command line utilities).  This also handles converting index types  * (compression, checksum, etc) from strings to their on-disk index.  */
end_comment

begin_function
name|int
name|zprop_parse_value
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|nvpair_t
modifier|*
name|elem
parameter_list|,
name|int
name|prop
parameter_list|,
name|zfs_type_t
name|type
parameter_list|,
name|nvlist_t
modifier|*
name|ret
parameter_list|,
name|char
modifier|*
modifier|*
name|svalp
parameter_list|,
name|uint64_t
modifier|*
name|ivalp
parameter_list|,
specifier|const
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|data_type_t
name|datatype
init|=
name|nvpair_type
argument_list|(
name|elem
argument_list|)
decl_stmt|;
name|zprop_type_t
name|proptype
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|boolean_t
name|isnone
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_POOL
condition|)
block|{
name|proptype
operator|=
name|zpool_prop_get_type
argument_list|(
name|prop
argument_list|)
expr_stmt|;
name|propname
operator|=
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proptype
operator|=
name|zfs_prop_get_type
argument_list|(
name|prop
argument_list|)
expr_stmt|;
name|propname
operator|=
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Convert any properties to the internal DSL value types. 	 */
operator|*
name|svalp
operator|=
name|NULL
expr_stmt|;
operator|*
name|ivalp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|proptype
condition|)
block|{
case|case
name|PROP_TYPE_STRING
case|:
if|if
condition|(
name|datatype
operator|!=
name|DATA_TYPE_STRING
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a string"
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|(
name|void
operator|)
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
name|svalp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|svalp
argument_list|)
operator|>=
name|ZFS_MAXPROPLEN
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is too long"
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|PROP_TYPE_NUMBER
case|:
if|if
condition|(
name|datatype
operator|==
name|DATA_TYPE_STRING
condition|)
block|{
operator|(
name|void
operator|)
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isnone
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_nicestrtonum
argument_list|(
name|hdl
argument_list|,
name|value
argument_list|,
name|ivalp
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|datatype
operator|==
name|DATA_TYPE_UINT64
condition|)
block|{
operator|(
name|void
operator|)
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
name|ivalp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a number"
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 		 * Quota special: force 'none' and don't allow 0. 		 */
if|if
condition|(
operator|(
name|type
operator|&
name|ZFS_TYPE_DATASET
operator|)
operator|&&
operator|*
name|ivalp
operator|==
literal|0
operator|&&
operator|!
name|isnone
operator|&&
operator|(
name|prop
operator|==
name|ZFS_PROP_QUOTA
operator|||
name|prop
operator|==
name|ZFS_PROP_REFQUOTA
operator|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"use 'none' to disable quota/refquota"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 		 * Special handling for "*_limit=none". In this case it's not 		 * 0 but UINT64_MAX. 		 */
if|if
condition|(
operator|(
name|type
operator|&
name|ZFS_TYPE_DATASET
operator|)
operator|&&
name|isnone
operator|&&
operator|(
name|prop
operator|==
name|ZFS_PROP_FILESYSTEM_LIMIT
operator|||
name|prop
operator|==
name|ZFS_PROP_SNAPSHOT_LIMIT
operator|)
condition|)
block|{
operator|*
name|ivalp
operator|=
name|UINT64_MAX
expr_stmt|;
block|}
break|break;
case|case
name|PROP_TYPE_INDEX
case|:
if|if
condition|(
name|datatype
operator|!=
name|DATA_TYPE_STRING
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a string"
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|(
name|void
operator|)
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|zprop_string_to_index
argument_list|(
name|prop
argument_list|,
name|value
argument_list|,
name|ivalp
argument_list|,
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be one of '%s'"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|zprop_values
argument_list|(
name|prop
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Add the result to our return set of properties. 	 */
if|if
condition|(
operator|*
name|svalp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|ret
argument_list|,
name|propname
argument_list|,
operator|*
name|svalp
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|ret
argument_list|,
name|propname
argument_list|,
operator|*
name|ivalp
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|addlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|propname
parameter_list|,
name|zprop_list_t
modifier|*
modifier|*
name|listp
parameter_list|,
name|zfs_type_t
name|type
parameter_list|)
block|{
name|int
name|prop
decl_stmt|;
name|zprop_list_t
modifier|*
name|entry
decl_stmt|;
name|prop
operator|=
name|zprop_name_to_prop
argument_list|(
name|propname
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|!=
name|ZPROP_INVAL
operator|&&
operator|!
name|zprop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|type
argument_list|)
condition|)
name|prop
operator|=
name|ZPROP_INVAL
expr_stmt|;
comment|/* 	 * When no property table entry can be found, return failure if 	 * this is a pool property or if this isn't a user-defined 	 * dataset property, 	 */
if|if
condition|(
name|prop
operator|==
name|ZPROP_INVAL
operator|&&
operator|(
operator|(
name|type
operator|==
name|ZFS_TYPE_POOL
operator|&&
operator|!
name|zpool_prop_feature
argument_list|(
name|propname
argument_list|)
operator|&&
operator|!
name|zpool_prop_unsupported
argument_list|(
name|propname
argument_list|)
operator|)
operator|||
operator|(
name|type
operator|==
name|ZFS_TYPE_DATASET
operator|&&
operator|!
name|zfs_prop_user
argument_list|(
name|propname
argument_list|)
operator|&&
operator|!
name|zfs_prop_userquota
argument_list|(
name|propname
argument_list|)
operator|&&
operator|!
name|zfs_prop_written
argument_list|(
name|propname
argument_list|)
operator|)
operator|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid property '%s'"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bad property list"
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|entry
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zprop_list_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|entry
operator|->
name|pl_prop
operator|=
name|prop
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZPROP_INVAL
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|pl_user_prop
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|propname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|propname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|->
name|pl_width
operator|=
name|zprop_width
argument_list|(
name|prop
argument_list|,
operator|&
name|entry
operator|->
name|pl_fixed
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
operator|*
name|listp
operator|=
name|entry
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a comma-separated list of properties, construct a property list  * containing both user-defined and native properties.  This function will  * return a NULL list if 'all' is specified, which can later be expanded  * by zprop_expand_list().  */
end_comment

begin_function
name|int
name|zprop_get_list
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|props
parameter_list|,
name|zprop_list_t
modifier|*
modifier|*
name|listp
parameter_list|,
name|zfs_type_t
name|type
parameter_list|)
block|{
operator|*
name|listp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If 'all' is specified, return a NULL list. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|props
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If no props were specified, return an error. 	 */
if|if
condition|(
name|props
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no properties specified"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bad property list"
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * It would be nice to use getsubopt() here, but the inclusion of column 	 * aliases makes this more effort than it's worth. 	 */
while|while
condition|(
operator|*
name|props
operator|!=
literal|'\0'
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|props
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|p
operator|=
name|props
operator|+
name|len
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|p
operator|-
name|props
expr_stmt|;
block|}
comment|/* 		 * Check for empty options. 		 */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"empty property name"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bad property list"
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * Check all regular property names. 		 */
name|c
operator|=
name|props
index|[
name|len
index|]
expr_stmt|;
name|props
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|props
argument_list|,
literal|"space"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|static
name|char
modifier|*
name|spaceprops
index|[]
init|=
block|{
literal|"name"
block|,
literal|"avail"
block|,
literal|"used"
block|,
literal|"usedbysnapshots"
block|,
literal|"usedbydataset"
block|,
literal|"usedbyrefreservation"
block|,
literal|"usedbychildren"
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|spaceprops
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addlist
argument_list|(
name|hdl
argument_list|,
name|spaceprops
index|[
name|i
index|]
argument_list|,
name|listp
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|listp
operator|=
operator|&
operator|(
operator|*
name|listp
operator|)
operator|->
name|pl_next
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|addlist
argument_list|(
name|hdl
argument_list|,
name|props
argument_list|,
name|listp
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|listp
operator|=
operator|&
operator|(
operator|*
name|listp
operator|)
operator|->
name|pl_next
expr_stmt|;
block|}
name|props
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|props
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zprop_free_list
parameter_list|(
name|zprop_list_t
modifier|*
name|pl
parameter_list|)
block|{
name|zprop_list_t
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|pl
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|pl
operator|->
name|pl_next
expr_stmt|;
name|free
argument_list|(
name|pl
operator|->
name|pl_user_prop
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pl
argument_list|)
expr_stmt|;
name|pl
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|expand_data
block|{
name|zprop_list_t
modifier|*
modifier|*
name|last
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
decl_stmt|;
name|zfs_type_t
name|type
decl_stmt|;
block|}
name|expand_data_t
typedef|;
end_typedef

begin_function
name|int
name|zprop_expand_list_cb
parameter_list|(
name|int
name|prop
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|zprop_list_t
modifier|*
name|entry
decl_stmt|;
name|expand_data_t
modifier|*
name|edp
init|=
name|cb
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|zfs_alloc
argument_list|(
name|edp
operator|->
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zprop_list_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ZPROP_INVAL
operator|)
return|;
name|entry
operator|->
name|pl_prop
operator|=
name|prop
expr_stmt|;
name|entry
operator|->
name|pl_width
operator|=
name|zprop_width
argument_list|(
name|prop
argument_list|,
operator|&
name|entry
operator|->
name|pl_fixed
argument_list|,
name|edp
operator|->
name|type
argument_list|)
expr_stmt|;
name|entry
operator|->
name|pl_all
operator|=
name|B_TRUE
expr_stmt|;
operator|*
operator|(
name|edp
operator|->
name|last
operator|)
operator|=
name|entry
expr_stmt|;
name|edp
operator|->
name|last
operator|=
operator|&
name|entry
operator|->
name|pl_next
expr_stmt|;
return|return
operator|(
name|ZPROP_CONT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zprop_expand_list
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zprop_list_t
modifier|*
modifier|*
name|plp
parameter_list|,
name|zfs_type_t
name|type
parameter_list|)
block|{
name|zprop_list_t
modifier|*
name|entry
decl_stmt|;
name|zprop_list_t
modifier|*
modifier|*
name|last
decl_stmt|;
name|expand_data_t
name|exp
decl_stmt|;
if|if
condition|(
operator|*
name|plp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If this is the very first time we've been called for an 'all' 		 * specification, expand the list to include all native 		 * properties. 		 */
name|last
operator|=
name|plp
expr_stmt|;
name|exp
operator|.
name|last
operator|=
name|last
expr_stmt|;
name|exp
operator|.
name|hdl
operator|=
name|hdl
expr_stmt|;
name|exp
operator|.
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|zprop_iter_common
argument_list|(
name|zprop_expand_list_cb
argument_list|,
operator|&
name|exp
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|,
name|type
argument_list|)
operator|==
name|ZPROP_INVAL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * Add 'name' to the beginning of the list, which is handled 		 * specially. 		 */
if|if
condition|(
operator|(
name|entry
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zprop_list_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|entry
operator|->
name|pl_prop
operator|=
operator|(
name|type
operator|==
name|ZFS_TYPE_POOL
operator|)
condition|?
name|ZPOOL_PROP_NAME
else|:
name|ZFS_PROP_NAME
expr_stmt|;
name|entry
operator|->
name|pl_width
operator|=
name|zprop_width
argument_list|(
name|entry
operator|->
name|pl_prop
argument_list|,
operator|&
name|entry
operator|->
name|pl_fixed
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|entry
operator|->
name|pl_all
operator|=
name|B_TRUE
expr_stmt|;
name|entry
operator|->
name|pl_next
operator|=
operator|*
name|plp
expr_stmt|;
operator|*
name|plp
operator|=
name|entry
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zprop_iter
parameter_list|(
name|zprop_func
name|func
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|,
name|boolean_t
name|show_all
parameter_list|,
name|boolean_t
name|ordered
parameter_list|,
name|zfs_type_t
name|type
parameter_list|)
block|{
return|return
operator|(
name|zprop_iter_common
argument_list|(
name|func
argument_list|,
name|cb
argument_list|,
name|show_all
argument_list|,
name|ordered
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

