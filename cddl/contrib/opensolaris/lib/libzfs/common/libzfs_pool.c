begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2015 by Delphix. All rights reserved.  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  * Copyright 2016 Nexenta Systems, Inc.  * Copyright 2016 Igor Kozhukhov<ikozhukhov@gmail.com>  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<devid.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|"zfs_namecheck.h"
end_include

begin_include
include|#
directive|include
file|"zfs_prop.h"
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_include
include|#
directive|include
file|"zfs_comutil.h"
end_include

begin_include
include|#
directive|include
file|"zfeature_common.h"
end_include

begin_function_decl
specifier|static
name|int
name|read_efi_label
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|diskaddr_t
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BACKUP_SLICE
value|"s2"
end_define

begin_typedef
typedef|typedef
struct|struct
name|prop_flags
block|{
name|int
name|create
range|:
literal|1
decl_stmt|;
comment|/* Validate property on creation */
name|int
name|import
range|:
literal|1
decl_stmt|;
comment|/* Validate property on import */
block|}
name|prop_flags_t
typedef|;
end_typedef

begin_comment
comment|/*  * ====================================================================  *   zpool property functions  * ====================================================================  */
end_comment

begin_function
specifier|static
name|int
name|zpool_get_all_props
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_alloc_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_GET_PROPS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|zcmd_expand_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|zcmd_read_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
operator|&
name|zhp
operator|->
name|zpool_props
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zpool_props_refresh
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|old_props
decl_stmt|;
name|old_props
operator|=
name|zhp
operator|->
name|zpool_props
expr_stmt|;
if|if
condition|(
name|zpool_get_all_props
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nvlist_free
argument_list|(
name|old_props
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|zpool_get_prop_string
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|zpool_prop_t
name|prop
parameter_list|,
name|zprop_source_t
modifier|*
name|src
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|,
modifier|*
name|nvl
decl_stmt|;
name|uint64_t
name|ival
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|zprop_source_t
name|source
decl_stmt|;
name|nvl
operator|=
name|zhp
operator|->
name|zpool_props
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|nvl
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPROP_SOURCE
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|source
operator|=
name|ival
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|source
operator|=
name|ZPROP_SRC_DEFAULT
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|zpool_prop_default_string
argument_list|(
name|prop
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|value
operator|=
literal|"-"
expr_stmt|;
block|}
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|source
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|zpool_get_prop_int
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|zpool_prop_t
name|prop
parameter_list|,
name|zprop_source_t
modifier|*
name|src
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|,
modifier|*
name|nvl
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|zprop_source_t
name|source
decl_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zpool_props
operator|==
name|NULL
operator|&&
name|zpool_get_all_props
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
comment|/* 		 * zpool_get_all_props() has most likely failed because 		 * the pool is faulted, but if all we need is the top level 		 * vdev's guid then get it from the zhp config nvlist. 		 */
if|if
condition|(
operator|(
name|prop
operator|==
name|ZPOOL_PROP_GUID
operator|)
operator|&&
operator|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|value
operator|)
return|;
block|}
return|return
operator|(
name|zpool_prop_default_numeric
argument_list|(
name|prop
argument_list|)
operator|)
return|;
block|}
name|nvl
operator|=
name|zhp
operator|->
name|zpool_props
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|nvl
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPROP_SOURCE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|source
operator|=
name|value
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|source
operator|=
name|ZPROP_SRC_DEFAULT
expr_stmt|;
name|value
operator|=
name|zpool_prop_default_numeric
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|source
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map VDEV STATE to printed strings.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zpool_state_to_name
parameter_list|(
name|vdev_state_t
name|state
parameter_list|,
name|vdev_aux_t
name|aux
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|VDEV_STATE_CLOSED
case|:
case|case
name|VDEV_STATE_OFFLINE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"OFFLINE"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_REMOVED
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"REMOVED"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_CANT_OPEN
case|:
if|if
condition|(
name|aux
operator|==
name|VDEV_AUX_CORRUPT_DATA
operator|||
name|aux
operator|==
name|VDEV_AUX_BAD_LOG
condition|)
return|return
operator|(
name|gettext
argument_list|(
literal|"FAULTED"
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|aux
operator|==
name|VDEV_AUX_SPLIT_POOL
condition|)
return|return
operator|(
name|gettext
argument_list|(
literal|"SPLIT"
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|gettext
argument_list|(
literal|"UNAVAIL"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_FAULTED
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"FAULTED"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_DEGRADED
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"DEGRADED"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_HEALTHY
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"ONLINE"
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
name|gettext
argument_list|(
literal|"UNKNOWN"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map POOL STATE to printed strings.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zpool_pool_state_to_name
parameter_list|(
name|pool_state_t
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|POOL_STATE_ACTIVE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"ACTIVE"
argument_list|)
operator|)
return|;
case|case
name|POOL_STATE_EXPORTED
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"EXPORTED"
argument_list|)
operator|)
return|;
case|case
name|POOL_STATE_DESTROYED
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"DESTROYED"
argument_list|)
operator|)
return|;
case|case
name|POOL_STATE_SPARE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"SPARE"
argument_list|)
operator|)
return|;
case|case
name|POOL_STATE_L2CACHE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"L2CACHE"
argument_list|)
operator|)
return|;
case|case
name|POOL_STATE_UNINITIALIZED
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"UNINITIALIZED"
argument_list|)
operator|)
return|;
case|case
name|POOL_STATE_UNAVAIL
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"UNAVAIL"
argument_list|)
operator|)
return|;
case|case
name|POOL_STATE_POTENTIALLY_ACTIVE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"POTENTIALLY_ACTIVE"
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|gettext
argument_list|(
literal|"UNKNOWN"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a zpool property value for 'prop' and return the value in  * a pre-allocated buffer.  */
end_comment

begin_function
name|int
name|zpool_get_prop
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|zpool_prop_t
name|prop
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|zprop_source_t
modifier|*
name|srctype
parameter_list|,
name|boolean_t
name|literal
parameter_list|)
block|{
name|uint64_t
name|intval
decl_stmt|;
specifier|const
name|char
modifier|*
name|strval
decl_stmt|;
name|zprop_source_t
name|src
init|=
name|ZPROP_SRC_NONE
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
if|if
condition|(
name|zpool_get_state
argument_list|(
name|zhp
argument_list|)
operator|==
name|POOL_STATE_UNAVAIL
condition|)
block|{
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZPOOL_PROP_NAME
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_HEALTH
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|zpool_pool_state_to_name
argument_list|(
name|POOL_STATE_UNAVAIL
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_GUID
case|:
name|intval
operator|=
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%llu"
argument_list|,
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_ALTROOT
case|:
case|case
name|ZPOOL_PROP_CACHEFILE
case|:
case|case
name|ZPOOL_PROP_COMMENT
case|:
if|if
condition|(
name|zhp
operator|->
name|zpool_props
operator|!=
name|NULL
operator|||
name|zpool_get_all_props
argument_list|(
name|zhp
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|zpool_get_prop_string
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|src
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|srctype
operator|!=
name|NULL
condition|)
operator|*
name|srctype
operator|=
name|src
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zhp
operator|->
name|zpool_props
operator|==
name|NULL
operator|&&
name|zpool_get_all_props
argument_list|(
name|zhp
argument_list|)
operator|&&
name|prop
operator|!=
name|ZPOOL_PROP_NAME
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|zpool_prop_get_type
argument_list|(
name|prop
argument_list|)
condition|)
block|{
case|case
name|PROP_TYPE_STRING
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|zpool_get_prop_string
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|src
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_TYPE_NUMBER
case|:
name|intval
operator|=
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZPOOL_PROP_SIZE
case|:
case|case
name|ZPOOL_PROP_ALLOCATED
case|:
case|case
name|ZPOOL_PROP_FREE
case|:
case|case
name|ZPOOL_PROP_FREEING
case|:
case|case
name|ZPOOL_PROP_LEAKED
case|:
if|if
condition|(
name|literal
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|intval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|zfs_nicenum
argument_list|(
name|intval
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZPOOL_PROP_EXPANDSZ
case|:
if|if
condition|(
name|intval
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|literal
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|intval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|zfs_nicenum
argument_list|(
name|intval
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZPOOL_PROP_CAPACITY
case|:
if|if
condition|(
name|literal
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|intval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%llu%%"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|intval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZPOOL_PROP_FRAGMENTATION
case|:
if|if
condition|(
name|intval
operator|==
name|UINT64_MAX
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%llu%%"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|intval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZPOOL_PROP_DEDUPRATIO
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%llu.%02llux"
argument_list|,
call|(
name|u_longlong_t
call|)
argument_list|(
name|intval
operator|/
literal|100
argument_list|)
argument_list|,
call|(
name|u_longlong_t
call|)
argument_list|(
name|intval
operator|%
literal|100
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_HEALTH
case|:
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|zpool_state_to_name
argument_list|(
name|intval
argument_list|,
name|vs
operator|->
name|vs_aux
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_VERSION
case|:
if|if
condition|(
name|intval
operator|>=
name|SPA_VERSION_FEATURES
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%llu"
argument_list|,
name|intval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_TYPE_INDEX
case|:
name|intval
operator|=
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_prop_index_to_string
argument_list|(
name|prop
argument_list|,
name|intval
argument_list|,
operator|&
name|strval
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|strval
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|srctype
condition|)
operator|*
name|srctype
operator|=
name|src
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the bootfs name has the same pool name as it is set to.  * Assuming bootfs is a valid dataset name.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|bootfs_name_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|char
modifier|*
name|bootfs
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|zfs_name_valid
argument_list|(
name|bootfs
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_SNAPSHOT
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|pool
argument_list|,
name|bootfs
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|bootfs
index|[
name|len
index|]
operator|==
literal|'/'
operator|||
name|bootfs
index|[
name|len
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|zpool_is_bootable
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|char
name|bootfs
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
return|return
operator|(
name|zpool_get_prop
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_BOOTFS
argument_list|,
name|bootfs
argument_list|,
sizeof|sizeof
argument_list|(
name|bootfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|bootfs
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|bootfs
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an nvlist of zpool properties to be set, validate that they are  * correct, and parse any numeric properties (index, boolean, etc) if they are  * specified as strings.  */
end_comment

begin_function
specifier|static
name|nvlist_t
modifier|*
name|zpool_valid_proplist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|poolname
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|uint64_t
name|version
parameter_list|,
name|prop_flags_t
name|flags
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|nvlist_t
modifier|*
name|retprops
decl_stmt|;
name|zpool_prop_t
name|prop
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
name|uint64_t
name|intval
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|,
modifier|*
name|check
decl_stmt|;
name|struct
name|stat64
name|statbuf
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|retprops
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|props
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|nvpair_name
argument_list|(
name|elem
argument_list|)
decl_stmt|;
name|prop
operator|=
name|zpool_name_to_prop
argument_list|(
name|propname
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZPROP_INVAL
operator|&&
name|zpool_prop_feature
argument_list|(
name|propname
argument_list|)
condition|)
block|{
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|fname
init|=
name|strchr
argument_list|(
name|propname
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
decl_stmt|;
name|err
operator|=
name|zfeature_lookup_name
argument_list|(
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid feature '%s'"
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
operator|!=
name|DATA_TYPE_STRING
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a string"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|(
name|void
operator|)
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|strval
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
name|ZFS_FEATURE_ENABLED
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property '%s' can only be set to "
literal|"'enabled'"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|retprops
argument_list|,
name|propname
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
continue|continue;
block|}
comment|/* 		 * Make sure this property is valid and applies to this type. 		 */
if|if
condition|(
name|prop
operator|==
name|ZPROP_INVAL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid property '%s'"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|zpool_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' "
literal|"is readonly"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPREADONLY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|zprop_parse_value
argument_list|(
name|hdl
argument_list|,
name|elem
argument_list|,
name|prop
argument_list|,
name|ZFS_TYPE_POOL
argument_list|,
name|retprops
argument_list|,
operator|&
name|strval
argument_list|,
operator|&
name|intval
argument_list|,
name|errbuf
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* 		 * Perform additional checking for specific properties. 		 */
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZPOOL_PROP_VERSION
case|:
if|if
condition|(
name|intval
operator|<
name|version
operator|||
operator|!
name|SPA_VERSION_IS_SUPPORTED
argument_list|(
name|intval
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property '%s' number %d is invalid."
argument_list|)
argument_list|,
name|propname
argument_list|,
name|intval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|ZPOOL_PROP_BOOTFS
case|:
if|if
condition|(
name|flags
operator|.
name|create
operator|||
name|flags
operator|.
name|import
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property '%s' cannot be set at creation "
literal|"or import time"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|version
operator|<
name|SPA_VERSION_BOOTFS
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgraded to support "
literal|"'%s' property"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 			 * bootfs property value has to be a dataset name and 			 * the dataset has to be in the same pool as it sets to. 			 */
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|bootfs_name_valid
argument_list|(
name|poolname
argument_list|,
name|strval
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' "
literal|"is an invalid name"
argument_list|)
argument_list|,
name|strval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|hdl
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"could not open pool '%s'"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_OPENFAILED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_ALTROOT
case|:
if|if
condition|(
operator|!
name|flags
operator|.
name|create
operator|&&
operator|!
name|flags
operator|.
name|import
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property '%s' can only be set during pool "
literal|"creation or import"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bad alternate root '%s'"
argument_list|)
argument_list|,
name|strval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|ZPOOL_PROP_CACHEFILE
case|:
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property '%s' must be empty, an "
literal|"absolute path, or 'none'"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|slash
operator|=
name|strrchr
argument_list|(
name|strval
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|slash
argument_list|,
literal|"/."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|slash
argument_list|,
literal|"/.."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is not a valid file"
argument_list|)
argument_list|,
name|strval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|stat64
argument_list|(
name|strval
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is not a valid directory"
argument_list|)
argument_list|,
name|strval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_COMMENT
case|:
for|for
control|(
name|check
operator|=
name|strval
init|;
operator|*
name|check
operator|!=
literal|'\0'
condition|;
name|check
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|check
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"comment may only have printable "
literal|"characters"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
name|strlen
argument_list|(
name|strval
argument_list|)
operator|>
name|ZPROP_MAX_COMMENT
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"comment must not exceed %d characters"
argument_list|)
argument_list|,
name|ZPROP_MAX_COMMENT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|ZPOOL_PROP_READONLY
case|:
if|if
condition|(
operator|!
name|flags
operator|.
name|import
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property '%s' can only be set at "
literal|"import time"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
default|default:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property '%s'(%d) not defined"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|prop
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|retprops
operator|)
return|;
name|error
label|:
name|nvlist_free
argument_list|(
name|retprops
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set zpool property : propname=propval.  */
end_comment

begin_function
name|int
name|zpool_set_prop
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|char
modifier|*
name|propval
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|realprops
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
name|prop_flags_t
name|flags
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot set property for '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|no_memory
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|)
operator|)
return|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|nvl
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|no_memory
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|)
operator|)
return|;
block|}
name|version
operator|=
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|realprops
operator|=
name|zpool_valid_proplist
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
name|nvl
argument_list|,
name|version
argument_list|,
name|flags
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|nvl
operator|=
name|realprops
expr_stmt|;
comment|/* 	 * Execute the corresponding ioctl() to set this property. 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|ZFS_IOC_POOL_SET_PROPS
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|zpool_props_refresh
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zpool_expand_proplist
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|zprop_list_t
modifier|*
modifier|*
name|plp
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|zprop_list_t
modifier|*
name|entry
decl_stmt|;
name|char
name|buf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|features
init|=
name|NULL
decl_stmt|;
name|zprop_list_t
modifier|*
modifier|*
name|last
decl_stmt|;
name|boolean_t
name|firstexpand
init|=
operator|(
name|NULL
operator|==
operator|*
name|plp
operator|)
decl_stmt|;
if|if
condition|(
name|zprop_expand_list
argument_list|(
name|hdl
argument_list|,
name|plp
argument_list|,
name|ZFS_TYPE_POOL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|last
operator|=
name|plp
expr_stmt|;
while|while
condition|(
operator|*
name|last
operator|!=
name|NULL
condition|)
name|last
operator|=
operator|&
operator|(
operator|*
name|last
operator|)
operator|->
name|pl_next
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|plp
operator|)
operator|->
name|pl_all
condition|)
name|features
operator|=
name|zpool_get_features
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|plp
operator|)
operator|->
name|pl_all
operator|&&
name|firstexpand
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SPA_FEATURES
condition|;
name|i
operator|++
control|)
block|{
name|zprop_list_t
modifier|*
name|entry
init|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zprop_list_t
argument_list|)
argument_list|)
decl_stmt|;
name|entry
operator|->
name|pl_prop
operator|=
name|ZPROP_INVAL
expr_stmt|;
name|entry
operator|->
name|pl_user_prop
operator|=
name|zfs_asprintf
argument_list|(
name|hdl
argument_list|,
literal|"feature@%s"
argument_list|,
name|spa_feature_table
index|[
name|i
index|]
operator|.
name|fi_uname
argument_list|)
expr_stmt|;
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|entry
operator|->
name|pl_user_prop
argument_list|)
expr_stmt|;
name|entry
operator|->
name|pl_all
operator|=
name|B_TRUE
expr_stmt|;
operator|*
name|last
operator|=
name|entry
expr_stmt|;
name|last
operator|=
operator|&
name|entry
operator|->
name|pl_next
expr_stmt|;
block|}
block|}
comment|/* add any unsupported features */
for|for
control|(
name|nvpair_t
modifier|*
name|nvp
init|=
name|nvlist_next_nvpair
argument_list|(
name|features
argument_list|,
name|NULL
argument_list|)
init|;
name|nvp
operator|!=
name|NULL
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|features
argument_list|,
name|nvp
argument_list|)
control|)
block|{
name|char
modifier|*
name|propname
decl_stmt|;
name|boolean_t
name|found
decl_stmt|;
name|zprop_list_t
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|zfeature_is_supported
argument_list|(
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|)
condition|)
continue|continue;
name|propname
operator|=
name|zfs_asprintf
argument_list|(
name|hdl
argument_list|,
literal|"unsupported@%s"
argument_list|,
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Before adding the property to the list make sure that no 		 * other pool already added the same property. 		 */
name|found
operator|=
name|B_FALSE
expr_stmt|;
name|entry
operator|=
operator|*
name|plp
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|pl_user_prop
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|propname
argument_list|,
name|entry
operator|->
name|pl_user_prop
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
name|entry
operator|=
name|entry
operator|->
name|pl_next
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
name|free
argument_list|(
name|propname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|entry
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zprop_list_t
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|pl_prop
operator|=
name|ZPROP_INVAL
expr_stmt|;
name|entry
operator|->
name|pl_user_prop
operator|=
name|propname
expr_stmt|;
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|entry
operator|->
name|pl_user_prop
argument_list|)
expr_stmt|;
name|entry
operator|->
name|pl_all
operator|=
name|B_TRUE
expr_stmt|;
operator|*
name|last
operator|=
name|entry
expr_stmt|;
name|last
operator|=
operator|&
name|entry
operator|->
name|pl_next
expr_stmt|;
block|}
for|for
control|(
name|entry
operator|=
operator|*
name|plp
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|pl_fixed
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|pl_prop
operator|!=
name|ZPROP_INVAL
operator|&&
name|zpool_get_prop
argument_list|(
name|zhp
argument_list|,
name|entry
operator|->
name|pl_prop
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
name|entry
operator|->
name|pl_width
condition|)
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the state for the given feature on the given ZFS pool.  */
end_comment

begin_function
name|int
name|zpool_prop_get_feature
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|uint64_t
name|refcount
decl_stmt|;
name|boolean_t
name|found
init|=
name|B_FALSE
decl_stmt|;
name|nvlist_t
modifier|*
name|features
init|=
name|zpool_get_features
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
name|boolean_t
name|supported
decl_stmt|;
specifier|const
name|char
modifier|*
name|feature
init|=
name|strchr
argument_list|(
name|propname
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
decl_stmt|;
name|supported
operator|=
name|zpool_prop_feature
argument_list|(
name|propname
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|supported
operator|||
name|zpool_prop_unsupported
argument_list|(
name|propname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Convert from feature name to feature guid. This conversion is 	 * unecessary for unsupported@... properties because they already 	 * use guids. 	 */
if|if
condition|(
name|supported
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|spa_feature_t
name|fid
decl_stmt|;
name|ret
operator|=
name|zfeature_lookup_name
argument_list|(
name|feature
argument_list|,
operator|&
name|fid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|feature
operator|=
name|spa_feature_table
index|[
name|fid
index|]
operator|.
name|fi_guid
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|features
argument_list|,
name|feature
argument_list|,
operator|&
name|refcount
argument_list|)
operator|==
literal|0
condition|)
name|found
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|supported
condition|)
block|{
if|if
condition|(
operator|!
name|found
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|ZFS_FEATURE_DISABLED
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|refcount
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|ZFS_FEATURE_ENABLED
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|ZFS_FEATURE_ACTIVE
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|refcount
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|ZFS_UNSUPPORTED_INACTIVE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|ZFS_UNSUPPORTED_READONLY
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Don't start the slice at the default block of 34; many storage  * devices will use a stripe width of 128k, so start there instead.  */
end_comment

begin_define
define|#
directive|define
name|NEW_START_BLOCK
value|256
end_define

begin_comment
comment|/*  * Validate the given pool name, optionally putting an extended error message in  * 'buf'.  */
end_comment

begin_function
name|boolean_t
name|zpool_name_valid
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|boolean_t
name|isopen
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|)
block|{
name|namecheck_err_t
name|why
decl_stmt|;
name|char
name|what
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|pool_namecheck
argument_list|(
name|pool
argument_list|,
operator|&
name|why
argument_list|,
operator|&
name|what
argument_list|)
expr_stmt|;
comment|/* 	 * The rules for reserved pool names were extended at a later point. 	 * But we need to support users with existing pools that may now be 	 * invalid.  So we only check for this expanded set of names during a 	 * create (or import), and only in userland. 	 */
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|!
name|isopen
operator|&&
operator|(
name|strncmp
argument_list|(
name|pool
argument_list|,
literal|"mirror"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|pool
argument_list|,
literal|"raidz"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|pool
argument_list|,
literal|"spare"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|pool
argument_list|,
literal|"log"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is reserved"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|NAME_ERR_TOOLONG
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is too long"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_INVALCHAR
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid character "
literal|"'%c' in pool name"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_NOLETTER
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name must begin with a letter"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_RESERVED
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is reserved"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_DISKLIKE
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool name is reserved"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_LEADING_SLASH
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"leading slash in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_EMPTY_COMPONENT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"empty component in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_TRAILING_SLASH
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"trailing slash in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_MULTIPLE_DELIMITERS
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"multiple '@' and/or '#' delimiters in "
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"(%d) not defined"
argument_list|)
argument_list|,
name|why
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open a handle to the given pool, even if the pool is currently in the FAULTED  * state.  */
end_comment

begin_function
name|zpool_handle_t
modifier|*
name|zpool_open_canfail
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|boolean_t
name|missing
decl_stmt|;
comment|/* 	 * Make sure the pool name is valid. 	 */
if|if
condition|(
operator|!
name|zpool_name_valid
argument_list|(
name|hdl
argument_list|,
name|B_TRUE
argument_list|,
name|pool
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot open '%s'"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zpool_handle_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zhp
operator|->
name|zpool_hdl
operator|=
name|hdl
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zhp
operator|->
name|zpool_name
argument_list|,
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|zhp
operator|->
name|zpool_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_refresh_stats
argument_list|(
name|zhp
argument_list|,
operator|&
name|missing
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|missing
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such pool"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot open '%s'"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Like the above, but silent on error.  Used when iterating over pools (because  * the configuration cache may be out of date).  */
end_comment

begin_function
name|int
name|zpool_open_silent
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|zpool_handle_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|boolean_t
name|missing
decl_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zpool_handle_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zhp
operator|->
name|zpool_hdl
operator|=
name|hdl
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zhp
operator|->
name|zpool_name
argument_list|,
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|zhp
operator|->
name|zpool_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_refresh_stats
argument_list|(
name|zhp
argument_list|,
operator|&
name|missing
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|missing
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|ret
operator|=
name|zhp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Similar to zpool_open_canfail(), but refuses to open pools in the faulted  * state.  */
end_comment

begin_function
name|zpool_handle_t
modifier|*
name|zpool_open
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|hdl
argument_list|,
name|pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|zhp
operator|->
name|zpool_state
operator|==
name|POOL_STATE_UNAVAIL
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOLUNAVAIL
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot open '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the handle.  Simply frees the memory associated with the handle.  */
end_comment

begin_function
name|void
name|zpool_close
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zpool_old_config
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zpool_props
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the name of the pool.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zpool_get_name
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zpool_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the state of the pool (ACTIVE or UNAVAILABLE)  */
end_comment

begin_function
name|int
name|zpool_get_state
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zpool_state
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the named pool, using the provided vdev list.  It is assumed  * that the consumer has already validated the contents of the nvlist, so we  * don't have to worry about error semantics.  */
end_comment

begin_function
name|int
name|zpool_create
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|nvlist_t
modifier|*
name|fsprops
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|nvlist_t
modifier|*
name|zc_fsprops
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|zc_props
init|=
name|NULL
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create '%s'"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zpool_name_valid
argument_list|(
name|hdl
argument_list|,
name|B_FALSE
argument_list|,
name|pool
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|zcmd_write_conf_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvroot
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|props
condition|)
block|{
name|prop_flags_t
name|flags
init|=
block|{
operator|.
name|create
operator|=
name|B_TRUE
block|,
operator|.
name|import
operator|=
name|B_FALSE
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|zc_props
operator|=
name|zpool_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|pool
argument_list|,
name|props
argument_list|,
name|SPA_VERSION_1
argument_list|,
name|flags
argument_list|,
name|msg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|create_failed
goto|;
block|}
block|}
if|if
condition|(
name|fsprops
condition|)
block|{
name|uint64_t
name|zoned
decl_stmt|;
name|char
modifier|*
name|zonestr
decl_stmt|;
name|zoned
operator|=
operator|(
operator|(
name|nvlist_lookup_string
argument_list|(
name|fsprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_ZONED
argument_list|)
argument_list|,
operator|&
name|zonestr
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strcmp
argument_list|(
name|zonestr
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|zc_fsprops
operator|=
name|zfs_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|,
name|fsprops
argument_list|,
name|zoned
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|msg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|create_failed
goto|;
block|}
if|if
condition|(
operator|!
name|zc_props
operator|&&
operator|(
name|nvlist_alloc
argument_list|(
operator|&
name|zc_props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
goto|goto
name|create_failed
goto|;
block|}
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|zc_props
argument_list|,
name|ZPOOL_ROOTFS_PROPS
argument_list|,
name|zc_fsprops
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|create_failed
goto|;
block|}
block|}
if|if
condition|(
name|zc_props
operator|&&
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|zc_props
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|create_failed
goto|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_POOL_CREATE
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zc_props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zc_fsprops
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EBUSY
case|:
comment|/* 			 * This can happen if the user has specified the same 			 * device multiple times.  We can't reliably detect this 			 * until we try to add it and see we already have a 			 * label. 			 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more vdevs refer to the same device"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
operator|)
return|;
case|case
name|ERANGE
case|:
comment|/* 			 * This happens if the record size is smaller or larger 			 * than the allowed size range, or not a power of 2. 			 * 			 * NOTE: although zfs_valid_proplist is called earlier, 			 * this case may have slipped through since the 			 * pool does not exist yet and it is therefore 			 * impossible to read properties e.g. max blocksize 			 * from the pool. 			 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"record size invalid"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|msg
argument_list|)
operator|)
return|;
case|case
name|EOVERFLOW
case|:
comment|/* 			 * This occurs when one of the devices is below 			 * SPA_MINDEVSIZE.  Unfortunately, we can't detect which 			 * device was the problem device since there's no 			 * reliable way to determine device size from userland. 			 */
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|zfs_nicenum
argument_list|(
name|SPA_MINDEVSIZE
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more devices is less than the "
literal|"minimum size (%s)"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
operator|)
return|;
case|case
name|ENOSPC
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more devices is out of space"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
operator|)
return|;
case|case
name|ENOTBLK
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cache device must be a disk or disk slice"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
block|}
name|create_failed
label|:
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zc_props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zc_fsprops
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy the given pool.  It is up to the caller to ensure that there are no  * datasets left in the pool.  */
end_comment

begin_function
name|int
name|zpool_destroy
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|log_str
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zfp
init|=
name|NULL
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zpool_state
operator|==
name|POOL_STATE_ACTIVE
operator|&&
operator|(
name|zfp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_history
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|log_str
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_POOL_DESTROY
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot destroy '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EROFS
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more devices is read only"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zfp
condition|)
name|zfs_close
argument_list|(
name|zfp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zfp
condition|)
block|{
name|remove_mountpoint
argument_list|(
name|zfp
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zfp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the given vdevs to the pool.  The caller must have already performed the  * necessary verification to ensure that the vdev specification is well-formed.  */
end_comment

begin_function
name|int
name|zpool_add
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|,
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|,
name|nl2cache
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot add to '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|)
operator|<
name|SPA_VERSION_SPARES
operator|&&
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be "
literal|"upgraded to add hot spares"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|)
operator|<
name|SPA_VERSION_L2CACHE
operator|&&
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be "
literal|"upgraded to add cache devices"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zcmd_write_conf_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvroot
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_VDEV_ADD
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EBUSY
case|:
comment|/* 			 * This can happen if the user has specified the same 			 * device multiple times.  We can't reliably detect this 			 * until we try to add it and see we already have a 			 * label. 			 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more vdevs refer to the same device"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOVERFLOW
case|:
comment|/* 			 * This occurrs when one of the devices is below 			 * SPA_MINDEVSIZE.  Unfortunately, we can't detect which 			 * device was the problem device since there's no 			 * reliable way to determine device size from userland. 			 */
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|zfs_nicenum
argument_list|(
name|SPA_MINDEVSIZE
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"device is less than the minimum "
literal|"size (%s)"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOTSUP
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgraded to add these vdevs"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EDOM
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"root pool can not have multiple vdevs"
literal|" or separate logs"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOL_NOTSUP
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOTBLK
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cache device must be a disk or disk slice"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Exports the pool from the system.  The caller must ensure that there are no  * mounted datasets in the pool.  */
end_comment

begin_function
specifier|static
name|int
name|zpool_export_common
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|boolean_t
name|hardforce
parameter_list|,
specifier|const
name|char
modifier|*
name|log_str
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot export '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|force
expr_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
name|hardforce
expr_stmt|;
name|zc
operator|.
name|zc_history
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|log_str
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|ZFS_IOC_POOL_EXPORT
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EXDEV
case|:
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"use '-f' to override the following errors:\n"
literal|"'%s' has an active shared spare which could be"
literal|" used by other pools once '%s' is exported."
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|EZFS_ACTIVE_SPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zpool_standard_error_fmt
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zpool_export
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|boolean_t
name|force
parameter_list|,
specifier|const
name|char
modifier|*
name|log_str
parameter_list|)
block|{
return|return
operator|(
name|zpool_export_common
argument_list|(
name|zhp
argument_list|,
name|force
argument_list|,
name|B_FALSE
argument_list|,
name|log_str
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zpool_export_force
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|log_str
parameter_list|)
block|{
return|return
operator|(
name|zpool_export_common
argument_list|(
name|zhp
argument_list|,
name|B_TRUE
argument_list|,
name|B_TRUE
argument_list|,
name|log_str
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zpool_rewind_exclaim
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|boolean_t
name|dryrun
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|rewindto
decl_stmt|;
name|int64_t
name|loss
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|tm
name|t
decl_stmt|;
name|char
name|timestr
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|hdl
operator|->
name|libzfs_printerr
operator|||
name|config
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_LOAD_INFO
argument_list|,
operator|&
name|nv
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_nvlist
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_REWIND_INFO
argument_list|,
operator|&
name|nv
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_LOAD_TIME
argument_list|,
operator|&
name|rewindto
argument_list|)
operator|!=
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|nvlist_lookup_int64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_REWIND_TIME
argument_list|,
operator|&
name|loss
argument_list|)
expr_stmt|;
if|if
condition|(
name|localtime_r
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|rewindto
argument_list|,
operator|&
name|t
argument_list|)
operator|!=
name|NULL
operator|&&
name|strftime
argument_list|(
name|timestr
argument_list|,
literal|128
argument_list|,
literal|0
argument_list|,
operator|&
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dryrun
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Would be able to return %s "
literal|"to its state as of %s.\n"
argument_list|)
argument_list|,
name|name
argument_list|,
name|timestr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Pool %s returned to its state as of %s.\n"
argument_list|)
argument_list|,
name|name
argument_list|,
name|timestr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loss
operator|>
literal|120
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"%s approximately %lld "
argument_list|)
argument_list|,
name|dryrun
condition|?
literal|"Would discard"
else|:
literal|"Discarded"
argument_list|,
operator|(
name|loss
operator|+
literal|30
operator|)
operator|/
literal|60
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"minutes of transactions.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|loss
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"%s approximately %lld "
argument_list|)
argument_list|,
name|dryrun
condition|?
literal|"Would discard"
else|:
literal|"Discarded"
argument_list|,
name|loss
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"seconds of transactions.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|zpool_explain_recover
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reason
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
init|=
name|NULL
decl_stmt|;
name|int64_t
name|loss
init|=
operator|-
literal|1
decl_stmt|;
name|uint64_t
name|edata
init|=
name|UINT64_MAX
decl_stmt|;
name|uint64_t
name|rewindto
decl_stmt|;
name|struct
name|tm
name|t
decl_stmt|;
name|char
name|timestr
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|hdl
operator|->
name|libzfs_printerr
condition|)
return|return;
if|if
condition|(
name|reason
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"action: "
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"\t"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All attempted rewinds failed if ZPOOL_CONFIG_LOAD_TIME missing */
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_LOAD_INFO
argument_list|,
operator|&
name|nv
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_nvlist
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_REWIND_INFO
argument_list|,
operator|&
name|nv
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_LOAD_TIME
argument_list|,
operator|&
name|rewindto
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|no_info
goto|;
operator|(
name|void
operator|)
name|nvlist_lookup_int64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_REWIND_TIME
argument_list|,
operator|&
name|loss
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_LOAD_DATA_ERRORS
argument_list|,
operator|&
name|edata
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Recovery is possible, but will result in some data loss.\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|localtime_r
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|rewindto
argument_list|,
operator|&
name|t
argument_list|)
operator|!=
name|NULL
operator|&&
name|strftime
argument_list|(
name|timestr
argument_list|,
literal|128
argument_list|,
literal|0
argument_list|,
operator|&
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"\tReturning the pool to its state as of %s\n"
literal|"\tshould correct the problem.  "
argument_list|)
argument_list|,
name|timestr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"\tReverting the pool to an earlier state "
literal|"should correct the problem.\n\t"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loss
operator|>
literal|120
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Approximately %lld minutes of data\n"
literal|"\tmust be discarded, irreversibly.  "
argument_list|)
argument_list|,
operator|(
name|loss
operator|+
literal|30
operator|)
operator|/
literal|60
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|loss
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Approximately %lld seconds of data\n"
literal|"\tmust be discarded, irreversibly.  "
argument_list|)
argument_list|,
name|loss
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|edata
operator|!=
literal|0
operator|&&
name|edata
operator|!=
name|UINT64_MAX
condition|)
block|{
if|if
condition|(
name|edata
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"After rewind, at least\n"
literal|"\tone persistent user-data error will remain.  "
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"After rewind, several\n"
literal|"\tpersistent user-data errors will remain.  "
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Recovery can be attempted\n\tby executing 'zpool %s -F %s'.  "
argument_list|)
argument_list|,
name|reason
operator|>=
literal|0
condition|?
literal|"clear"
else|:
literal|"import"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"A scrub of the pool\n"
literal|"\tis strongly recommended after recovery.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|no_info
label|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Destroy and re-create the pool from\n\ta backup source.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * zpool_import() is a contracted interface. Should be kept the same  * if possible.  *  * Applications should use zpool_import_props() to import a pool with  * new properties value to be set.  */
end_comment

begin_function
name|int
name|zpool_import
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
name|char
modifier|*
name|altroot
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|altroot
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOMEM
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import '%s'"
argument_list|)
argument_list|,
name|newname
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_ALTROOT
argument_list|)
argument_list|,
name|altroot
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_string
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_CACHEFILE
argument_list|)
argument_list|,
literal|"none"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOMEM
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import '%s'"
argument_list|)
argument_list|,
name|newname
argument_list|)
operator|)
return|;
block|}
block|}
name|ret
operator|=
name|zpool_import_props
argument_list|(
name|hdl
argument_list|,
name|config
argument_list|,
name|newname
argument_list|,
name|props
argument_list|,
name|ZFS_IMPORT_NORMAL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_vdev_tree
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|char
modifier|*
name|vname
decl_stmt|;
name|uint64_t
name|is_log
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|is_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%*s%s%s\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|is_log
condition|?
literal|" [log]"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vname
operator|=
name|zpool_vdev_name
argument_list|(
name|hdl
argument_list|,
name|NULL
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|print_vdev_tree
argument_list|(
name|hdl
argument_list|,
name|vname
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|zpool_print_unsup_feat
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvinfo
decl_stmt|,
modifier|*
name|unsup_feat
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_LOAD_INFO
argument_list|,
operator|&
name|nvinfo
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|nvinfo
argument_list|,
name|ZPOOL_CONFIG_UNSUP_FEAT
argument_list|,
operator|&
name|unsup_feat
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|nvpair_t
modifier|*
name|nvp
init|=
name|nvlist_next_nvpair
argument_list|(
name|unsup_feat
argument_list|,
name|NULL
argument_list|)
init|;
name|nvp
operator|!=
name|NULL
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|unsup_feat
argument_list|,
name|nvp
argument_list|)
control|)
block|{
name|char
modifier|*
name|desc
decl_stmt|;
name|verify
argument_list|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
operator|==
name|DATA_TYPE_STRING
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvpair_value_string
argument_list|(
name|nvp
argument_list|,
operator|&
name|desc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|desc
argument_list|)
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s (%s)\n"
argument_list|,
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|desc
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Import the given pool using the known configuration and a list of  * properties to be set. The configuration should have come from  * zpool_find_import(). The 'newname' parameters control whether the pool  * is imported with a different name.  */
end_comment

begin_function
name|int
name|zpool_import_props
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zpool_rewind_policy_t
name|policy
decl_stmt|;
name|nvlist_t
modifier|*
name|nv
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|nvinfo
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|missing
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|thename
decl_stmt|;
name|char
modifier|*
name|origname
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|origname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import pool '%s'"
argument_list|)
argument_list|,
name|origname
argument_list|)
expr_stmt|;
if|if
condition|(
name|newname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|zpool_name_valid
argument_list|(
name|hdl
argument_list|,
name|B_FALSE
argument_list|,
name|newname
argument_list|)
condition|)
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import '%s'"
argument_list|)
argument_list|,
name|newname
argument_list|)
operator|)
return|;
name|thename
operator|=
operator|(
name|char
operator|*
operator|)
name|newname
expr_stmt|;
block|}
else|else
block|{
name|thename
operator|=
name|origname
expr_stmt|;
block|}
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
block|{
name|uint64_t
name|version
decl_stmt|;
name|prop_flags_t
name|flags
init|=
block|{
operator|.
name|create
operator|=
name|B_FALSE
block|,
operator|.
name|import
operator|=
name|B_TRUE
block|}
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|props
operator|=
name|zpool_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|origname
argument_list|,
name|props
argument_list|,
name|version
argument_list|,
name|flags
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|props
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|thename
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_conf_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|config
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zcmd_alloc_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|zc
operator|.
name|zc_nvlist_conf_size
operator|*
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zc
operator|.
name|zc_cookie
operator|=
name|flags
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_POOL_IMPORT
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|zcmd_expand_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|error
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|zcmd_read_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
operator|&
name|nv
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zpool_get_rewind_policy
argument_list|(
name|config
argument_list|,
operator|&
name|policy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|char
name|desc
index|[
literal|1024
index|]
decl_stmt|;
comment|/* 		 * Dry-run failed, but we print out what success 		 * looks like if we found a best txg 		 */
if|if
condition|(
name|policy
operator|.
name|zrp_request
operator|&
name|ZPOOL_TRY_REWIND
condition|)
block|{
name|zpool_rewind_exclaim
argument_list|(
name|hdl
argument_list|,
name|newname
condition|?
name|origname
else|:
name|thename
argument_list|,
name|B_TRUE
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|newname
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import '%s'"
argument_list|)
argument_list|,
name|thename
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import '%s' as '%s'"
argument_list|)
argument_list|,
name|origname
argument_list|,
name|thename
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|ENOTSUP
case|:
if|if
condition|(
name|nv
operator|!=
name|NULL
operator|&&
name|nvlist_lookup_nvlist
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_LOAD_INFO
argument_list|,
operator|&
name|nvinfo
argument_list|)
operator|==
literal|0
operator|&&
name|nvlist_exists
argument_list|(
name|nvinfo
argument_list|,
name|ZPOOL_CONFIG_UNSUP_FEAT
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"This "
literal|"pool uses the following feature(s) not "
literal|"supported by this system:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|zpool_print_unsup_feat
argument_list|(
name|nv
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_exists
argument_list|(
name|nvinfo
argument_list|,
name|ZPOOL_CONFIG_CAN_RDONLY
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"All unsupported features are only "
literal|"required for writing to the pool."
literal|"\nThe pool can be imported using "
literal|"'-o readonly=on'.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * Unsupported version. 			 */
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALCONFIG
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|EROFS
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more devices is read only"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENXIO
case|:
if|if
condition|(
name|nv
operator|&&
name|nvlist_lookup_nvlist
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_LOAD_INFO
argument_list|,
operator|&
name|nvinfo
argument_list|)
operator|==
literal|0
operator|&&
name|nvlist_lookup_nvlist
argument_list|(
name|nvinfo
argument_list|,
name|ZPOOL_CONFIG_MISSING_DEVICES
argument_list|,
operator|&
name|missing
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"The devices below are missing, use "
literal|"'-m' to import the pool anyway:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|print_vdev_tree
argument_list|(
name|hdl
argument_list|,
name|NULL
argument_list|,
name|missing
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|EEXIST
case|:
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENAMETOOLONG
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"new name of at least one dataset is longer than "
literal|"the maximum allowable length"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NAMETOOLONG
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|zpool_explain_recover
argument_list|(
name|hdl
argument_list|,
name|newname
condition|?
name|origname
else|:
name|thename
argument_list|,
operator|-
name|error
argument_list|,
name|nv
argument_list|)
expr_stmt|;
break|break;
block|}
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
comment|/* 		 * This should never fail, but play it safe anyway. 		 */
if|if
condition|(
name|zpool_open_silent
argument_list|(
name|hdl
argument_list|,
name|thename
argument_list|,
operator|&
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|zhp
operator|!=
name|NULL
condition|)
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|policy
operator|.
name|zrp_request
operator|&
operator|(
name|ZPOOL_DO_REWIND
operator||
name|ZPOOL_TRY_REWIND
operator|)
condition|)
block|{
name|zpool_rewind_exclaim
argument_list|(
name|hdl
argument_list|,
name|newname
condition|?
name|origname
else|:
name|thename
argument_list|,
operator|(
operator|(
name|policy
operator|.
name|zrp_request
operator|&
name|ZPOOL_TRY_REWIND
operator|)
operator|!=
literal|0
operator|)
argument_list|,
name|nv
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scan the pool.  */
end_comment

begin_function
name|int
name|zpool_scan
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|pool_scan_func_t
name|func
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|func
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_POOL_SCAN
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|errno
operator|==
name|ENOENT
operator|&&
name|func
operator|!=
name|POOL_SCAN_NONE
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|func
operator|==
name|POOL_SCAN_SCRUB
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot scrub %s"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|func
operator|==
name|POOL_SCAN_NONE
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot cancel scrubbing %s"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
operator|!
literal|"unexpected result"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|==
name|EBUSY
condition|)
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|pool_scan_stat_t
modifier|*
name|ps
init|=
name|NULL
decl_stmt|;
name|uint_t
name|psc
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SCAN_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|ps
argument_list|,
operator|&
name|psc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|&&
name|ps
operator|->
name|pss_func
operator|==
name|POOL_SCAN_SCRUB
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_SCRUBBING
argument_list|,
name|msg
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_RESILVERING
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NO_SCRUB
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_comment
comment|/*  * This provides a very minimal check whether a given string is likely a  * c#t#d# style string.  Users of this are expected to do their own  * verification of the s# part.  */
end_comment

begin_define
define|#
directive|define
name|CTD_CHECK
parameter_list|(
name|str
parameter_list|)
value|(str&& str[0] == 'c'&& isdigit(str[1]))
end_define

begin_comment
comment|/*  * More elaborate version for ones which may start with "/dev/dsk/"  * and the like.  */
end_comment

begin_function
specifier|static
name|int
name|ctd_check_path
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
comment|/* 	 * If it starts with a slash, check the last component. 	 */
if|if
condition|(
name|str
operator|&&
name|str
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|strrchr
argument_list|(
name|str
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
comment|/* 		 * If it ends in "/old", check the second-to-last 		 * component of the string instead. 		 */
if|if
condition|(
name|tmp
operator|!=
name|str
operator|&&
name|strcmp
argument_list|(
name|tmp
argument_list|,
literal|"/old"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|tmp
operator|--
init|;
operator|*
name|tmp
operator|!=
literal|'/'
condition|;
name|tmp
operator|--
control|)
empty_stmt|;
block|}
name|str
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|CTD_CHECK
argument_list|(
name|str
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Find a vdev that matches the search criteria specified. We use the  * the nvpair name to determine how we should look for the device.  * 'avail_spare' is set to TRUE if the provided guid refers to an AVAIL  * spare; but FALSE if its an INUSE spare.  */
end_comment

begin_function
specifier|static
name|nvlist_t
modifier|*
name|vdev_to_nvlist_iter
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|nvlist_t
modifier|*
name|search
parameter_list|,
name|boolean_t
modifier|*
name|avail_spare
parameter_list|,
name|boolean_t
modifier|*
name|l2cache
parameter_list|,
name|boolean_t
modifier|*
name|log
parameter_list|)
block|{
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|nvlist_t
modifier|*
name|ret
decl_stmt|;
name|uint64_t
name|is_log
decl_stmt|;
name|char
modifier|*
name|srchkey
decl_stmt|;
name|nvpair_t
modifier|*
name|pair
init|=
name|nvlist_next_nvpair
argument_list|(
name|search
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
comment|/* Nothing to look for */
if|if
condition|(
name|search
operator|==
name|NULL
operator|||
name|pair
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Obtain the key we will use to search */
name|srchkey
operator|=
name|nvpair_name
argument_list|(
name|pair
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nvpair_type
argument_list|(
name|pair
argument_list|)
condition|)
block|{
case|case
name|DATA_TYPE_UINT64
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|srchkey
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|srchval
decl_stmt|,
name|theguid
decl_stmt|;
name|verify
argument_list|(
name|nvpair_value_uint64
argument_list|(
name|pair
argument_list|,
operator|&
name|srchval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|theguid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|theguid
operator|==
name|srchval
condition|)
return|return
operator|(
name|nv
operator|)
return|;
block|}
break|break;
case|case
name|DATA_TYPE_STRING
case|:
block|{
name|char
modifier|*
name|srchval
decl_stmt|,
modifier|*
name|val
decl_stmt|;
name|verify
argument_list|(
name|nvpair_value_string
argument_list|(
name|pair
argument_list|,
operator|&
name|srchval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|srchkey
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * Search for the requested value. Special cases: 		 * 		 * - ZPOOL_CONFIG_PATH for whole disk entries.  These end in 		 *   "s0" or "s0/old".  The "s0" part is hidden from the user, 		 *   but included in the string, so this matches around it. 		 * - looking for a top-level vdev name (i.e. ZPOOL_CONFIG_TYPE). 		 * 		 * Otherwise, all other searches are simple string compares. 		 */
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|strcmp
argument_list|(
name|srchkey
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|)
operator|==
literal|0
operator|&&
name|ctd_check_path
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|uint64_t
name|wholedisk
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_WHOLE_DISK
argument_list|,
operator|&
name|wholedisk
argument_list|)
expr_stmt|;
if|if
condition|(
name|wholedisk
condition|)
block|{
name|int
name|slen
init|=
name|strlen
argument_list|(
name|srchval
argument_list|)
decl_stmt|;
name|int
name|vlen
init|=
name|strlen
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|slen
operator|!=
name|vlen
operator|-
literal|2
condition|)
break|break;
comment|/* 				 * make_leaf_vdev() should only set 				 * wholedisk for ZPOOL_CONFIG_PATHs which 				 * will include "/dev/dsk/", giving plenty of 				 * room for the indices used next. 				 */
name|ASSERT
argument_list|(
name|vlen
operator|>=
literal|6
argument_list|)
expr_stmt|;
comment|/* 				 * strings identical except trailing "s0" 				 */
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|val
index|[
name|vlen
operator|-
literal|2
index|]
argument_list|,
literal|"s0"
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|srchval
argument_list|,
name|val
argument_list|,
name|slen
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|nv
operator|)
return|;
comment|/* 				 * strings identical except trailing "s0/old" 				 */
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|val
index|[
name|vlen
operator|-
literal|6
index|]
argument_list|,
literal|"s0/old"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
operator|&
name|srchval
index|[
name|slen
operator|-
literal|4
index|]
argument_list|,
literal|"/old"
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|srchval
argument_list|,
name|val
argument_list|,
name|slen
operator|-
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|nv
operator|)
return|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|srchkey
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|)
operator|==
literal|0
operator|&&
name|val
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|strcmp
argument_list|(
name|srchkey
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|)
operator|==
literal|0
operator|&&
name|val
condition|)
block|{
endif|#
directive|endif
name|char
modifier|*
name|type
decl_stmt|,
modifier|*
name|idx
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|uint64_t
name|id
decl_stmt|,
name|vdev_id
decl_stmt|;
comment|/* 			 * Determine our vdev type, keeping in mind 			 * that the srchval is composed of a type and 			 * vdev id pair (i.e. mirror-4). 			 */
if|if
condition|(
operator|(
name|type
operator|=
name|strdup
argument_list|(
name|srchval
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|type
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|idx
operator|=
name|p
operator|+
literal|1
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * If the types don't match then keep looking. 			 */
if|if
condition|(
name|strncmp
argument_list|(
name|val
argument_list|,
name|type
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|verify
argument_list|(
name|strncmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|,
name|strlen
argument_list|(
name|VDEV_TYPE_RAIDZ
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_MIRROR
argument_list|,
name|strlen
argument_list|(
name|VDEV_TYPE_MIRROR
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
operator|&
name|id
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|vdev_id
operator|=
name|strtoull
argument_list|(
name|idx
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 			 * Now verify that we have the correct vdev id. 			 */
if|if
condition|(
name|vdev_id
operator|==
name|id
condition|)
return|return
operator|(
name|nv
operator|)
return|;
block|}
comment|/* 		 * Common case 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|srchval
argument_list|,
name|val
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|nv
operator|)
return|;
break|break;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|vdev_to_nvlist_iter
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|search
argument_list|,
name|avail_spare
argument_list|,
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * The 'is_log' value is only set for the toplevel 			 * vdev, not the leaf vdevs.  So we always lookup the 			 * log device from the root of the vdev tree (where 			 * 'log' is non-NULL). 			 */
if|if
condition|(
name|log
operator|!=
name|NULL
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|is_log
argument_list|)
operator|==
literal|0
operator|&&
name|is_log
condition|)
block|{
operator|*
name|log
operator|=
name|B_TRUE
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|vdev_to_nvlist_iter
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|search
argument_list|,
name|avail_spare
argument_list|,
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|avail_spare
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|vdev_to_nvlist_iter
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|search
argument_list|,
name|avail_spare
argument_list|,
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|l2cache
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  * Given a physical path (minus the "/devices" prefix), find the  * associated vdev.  */
name|nvlist_t
modifier|*
name|zpool_find_vdev_by_physpath
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|ppath
parameter_list|,
name|boolean_t
modifier|*
name|avail_spare
parameter_list|,
name|boolean_t
modifier|*
name|l2cache
parameter_list|,
name|boolean_t
modifier|*
name|log
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|search
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|verify
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|search
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_string
argument_list|(
name|search
argument_list|,
name|ZPOOL_CONFIG_PHYS_PATH
argument_list|,
name|ppath
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|avail_spare
operator|=
name|B_FALSE
expr_stmt|;
operator|*
name|l2cache
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|log
operator|!=
name|NULL
condition|)
operator|*
name|log
operator|=
name|B_FALSE
expr_stmt|;
name|ret
operator|=
name|vdev_to_nvlist_iter
argument_list|(
name|nvroot
argument_list|,
name|search
argument_list|,
name|avail_spare
argument_list|,
name|l2cache
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|search
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/*  * Determine if we have an "interior" top-level vdev (i.e mirror/raidz).  */
name|boolean_t
name|zpool_vdev_is_interior
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|,
name|strlen
argument_list|(
name|VDEV_TYPE_RAIDZ
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
name|VDEV_TYPE_MIRROR
argument_list|,
name|strlen
argument_list|(
name|VDEV_TYPE_MIRROR
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
name|nvlist_t
modifier|*
name|zpool_find_vdev
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|boolean_t
modifier|*
name|avail_spare
parameter_list|,
name|boolean_t
modifier|*
name|l2cache
parameter_list|,
name|boolean_t
modifier|*
name|log
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|,
modifier|*
name|search
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|verify
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|search
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|guid
operator|=
name|strtoull
argument_list|(
name|path
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid
operator|!=
literal|0
operator|&&
operator|*
name|end
operator|==
literal|'\0'
condition|)
block|{
name|verify
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|search
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zpool_vdev_is_interior
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|verify
argument_list|(
name|nvlist_add_string
argument_list|(
name|search
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_string
argument_list|(
name|search
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verify
argument_list|(
name|nvlist_add_string
argument_list|(
name|search
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|avail_spare
operator|=
name|B_FALSE
expr_stmt|;
operator|*
name|l2cache
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|log
operator|!=
name|NULL
condition|)
operator|*
name|log
operator|=
name|B_FALSE
expr_stmt|;
name|ret
operator|=
name|vdev_to_nvlist_iter
argument_list|(
name|nvroot
argument_list|,
name|search
argument_list|,
name|avail_spare
argument_list|,
name|l2cache
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|search
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
specifier|static
name|int
name|vdev_online
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|uint64_t
name|ival
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_OFFLINE
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_FAULTED
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_REMOVED
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * Helper function for zpool_get_physpaths().  */
specifier|static
name|int
name|vdev_get_one_physpath
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|char
modifier|*
name|physpath
parameter_list|,
name|size_t
name|physpath_size
parameter_list|,
name|size_t
modifier|*
name|bytes_written
parameter_list|)
block|{
name|size_t
name|bytes_left
decl_stmt|,
name|pos
decl_stmt|,
name|rsz
decl_stmt|;
name|char
modifier|*
name|tmppath
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_PHYS_PATH
argument_list|,
operator|&
name|tmppath
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EZFS_NODEVICE
operator|)
return|;
name|pos
operator|=
operator|*
name|bytes_written
expr_stmt|;
name|bytes_left
operator|=
name|physpath_size
operator|-
name|pos
expr_stmt|;
name|format
operator|=
operator|(
name|pos
operator|==
literal|0
operator|)
condition|?
literal|"%s"
else|:
literal|" %s"
expr_stmt|;
name|rsz
operator|=
name|snprintf
argument_list|(
name|physpath
operator|+
name|pos
argument_list|,
name|bytes_left
argument_list|,
name|format
argument_list|,
name|tmppath
argument_list|)
expr_stmt|;
operator|*
name|bytes_written
operator|+=
name|rsz
expr_stmt|;
if|if
condition|(
name|rsz
operator|>=
name|bytes_left
condition|)
block|{
comment|/* if physpath was not copied properly, clear it */
if|if
condition|(
name|bytes_left
operator|!=
literal|0
condition|)
block|{
name|physpath
index|[
name|pos
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|EZFS_NOSPC
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|vdev_get_physpaths
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|char
modifier|*
name|physpath
parameter_list|,
name|size_t
name|phypath_size
parameter_list|,
name|size_t
modifier|*
name|rsz
parameter_list|,
name|boolean_t
name|is_spare
parameter_list|)
block|{
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EZFS_INVALCONFIG
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_DISK
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * An active spare device has ZPOOL_CONFIG_IS_SPARE set. 		 * For a spare vdev, we only want to boot from the active 		 * spare device. 		 */
if|if
condition|(
name|is_spare
condition|)
block|{
name|uint64_t
name|spare
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_IS_SPARE
argument_list|,
operator|&
name|spare
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spare
condition|)
return|return
operator|(
name|EZFS_INVALCONFIG
operator|)
return|;
block|}
if|if
condition|(
name|vdev_online
argument_list|(
name|nv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|vdev_get_one_physpath
argument_list|(
name|nv
argument_list|,
name|physpath
argument_list|,
name|phypath_size
argument_list|,
name|rsz
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_MIRROR
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_REPLACING
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|is_spare
operator|=
operator|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_SPARE
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|count
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EZFS_INVALCONFIG
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|vdev_get_physpaths
argument_list|(
name|child
index|[
name|i
index|]
argument_list|,
name|physpath
argument_list|,
name|phypath_size
argument_list|,
name|rsz
argument_list|,
name|is_spare
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EZFS_NOSPC
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EZFS_POOL_INVALARG
operator|)
return|;
block|}
comment|/*  * Get phys_path for a root pool config.  * Return 0 on success; non-zero on failure.  */
specifier|static
name|int
name|zpool_get_config_physpath
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|char
modifier|*
name|physpath
parameter_list|,
name|size_t
name|phypath_size
parameter_list|)
block|{
name|size_t
name|rsz
decl_stmt|;
name|nvlist_t
modifier|*
name|vdev_root
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|count
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|rsz
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|vdev_root
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EZFS_INVALCONFIG
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|vdev_root
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_nvlist_array
argument_list|(
name|vdev_root
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EZFS_INVALCONFIG
operator|)
return|;
comment|/* 	 * root pool can only have a single top-level vdev. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_ROOT
argument_list|)
operator|!=
literal|0
operator|||
name|count
operator|!=
literal|1
condition|)
return|return
operator|(
name|EZFS_POOL_INVALARG
operator|)
return|;
operator|(
name|void
operator|)
name|vdev_get_physpaths
argument_list|(
name|child
index|[
literal|0
index|]
argument_list|,
name|physpath
argument_list|,
name|phypath_size
argument_list|,
operator|&
name|rsz
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* No online devices */
if|if
condition|(
name|rsz
operator|==
literal|0
condition|)
return|return
operator|(
name|EZFS_NODEVICE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Get phys_path for a root pool  * Return 0 on success; non-zero on failure.  */
name|int
name|zpool_get_physpath
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
name|physpath
parameter_list|,
name|size_t
name|phypath_size
parameter_list|)
block|{
return|return
operator|(
name|zpool_get_config_physpath
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|physpath
argument_list|,
name|phypath_size
argument_list|)
operator|)
return|;
block|}
comment|/*  * If the device has being dynamically expanded then we need to relabel  * the disk to use the new unallocated space.  */
specifier|static
name|int
name|zpool_relabel_disk
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|error
decl_stmt|;
name|int
function_decl|(
modifier|*
name|_efi_use_whole_disk
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
if|if
condition|(
operator|(
name|_efi_use_whole_disk
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|dlsym
argument_list|(
name|RTLD_DEFAULT
argument_list|,
literal|"efi_use_whole_disk"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|ZFS_RDISK_ROOT
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot "
literal|"relabel '%s': unable to open device"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_OPENFAILED
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * It's possible that we might encounter an error if the device 	 * does not have any unallocated space left. If so, we simply 	 * ignore that error and continue on. 	 */
name|error
operator|=
name|_efi_use_whole_disk
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|VT_ENOSPC
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot "
literal|"relabel '%s': unable to read disk capacity"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOCAP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* illumos */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Bring the specified vdev online.   The 'flags' parameter is a set of the  * ZFS_ONLINE_* flags.  */
name|int
name|zpool_vdev_online
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|vdev_state_t
modifier|*
name|newstate
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|,
name|l2cache
decl_stmt|,
name|islog
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|ZFS_ONLINE_EXPAND
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot expand %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot online %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|islog
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail_spare
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|ZFS_ONLINE_EXPAND
operator|||
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_AUTOEXPAND
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|char
modifier|*
name|pathname
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|wholedisk
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_WHOLE_DISK
argument_list|,
operator|&
name|wholedisk
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|pathname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * XXX - L2ARC 1.0 devices can't support expansion. 		 */
if|if
condition|(
name|l2cache
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot expand cache devices"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_VDEVNOTSUP
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|wholedisk
condition|)
block|{
name|pathname
operator|+=
name|strlen
argument_list|(
name|ZFS_DISK_ROOT
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|zpool_relabel_disk
argument_list|(
name|hdl
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
block|}
block|}
name|zc
operator|.
name|zc_cookie
operator|=
name|VDEV_STATE_ONLINE
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_VDEV_SET_STATE
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"was split "
literal|"from this pool into a new one.  Use '%s' "
literal|"instead"
argument_list|)
argument_list|,
literal|"zpool detach"
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_POSTSPLIT_ONLINE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
operator|*
name|newstate
operator|=
name|zc
operator|.
name|zc_cookie
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Take the specified vdev offline  */
name|int
name|zpool_vdev_offline
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|boolean_t
name|istmp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|,
name|l2cache
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot offline %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail_spare
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|zc
operator|.
name|zc_cookie
operator|=
name|VDEV_STATE_OFFLINE
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|istmp
condition|?
name|ZFS_OFFLINE_TEMPORARY
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_VDEV_SET_STATE
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EBUSY
case|:
comment|/* 		 * There are no other replicas of this device. 		 */
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOREPLICAS
argument_list|,
name|msg
argument_list|)
operator|)
return|;
case|case
name|EEXIST
case|:
comment|/* 		 * The log device has unplayed logs 		 */
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_UNPLAYED_LOGS
argument_list|,
name|msg
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
block|}
comment|/*  * Mark the given vdev faulted.  */
name|int
name|zpool_vdev_fault
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|vdev_aux_t
name|aux
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot fault %llu"
argument_list|)
argument_list|,
name|guid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
name|guid
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|VDEV_STATE_FAULTED
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|aux
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_VDEV_SET_STATE
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EBUSY
case|:
comment|/* 		 * There are no other replicas of this device. 		 */
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOREPLICAS
argument_list|,
name|msg
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
block|}
comment|/*  * Mark the given vdev degraded.  */
name|int
name|zpool_vdev_degrade
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|vdev_aux_t
name|aux
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot degrade %llu"
argument_list|)
argument_list|,
name|guid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
name|guid
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|VDEV_STATE_DEGRADED
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|aux
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_VDEV_SET_STATE
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
comment|/*  * Returns TRUE if the given nvlist is a vdev that was originally swapped in as  * a hot spare.  */
specifier|static
name|boolean_t
name|is_replacing_spare
parameter_list|(
name|nvlist_t
modifier|*
name|search
parameter_list|,
name|nvlist_t
modifier|*
name|tgt
parameter_list|,
name|int
name|which
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|search
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|search
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_SPARE
argument_list|)
operator|==
literal|0
operator|&&
name|children
operator|==
literal|2
operator|&&
name|child
index|[
name|which
index|]
operator|==
name|tgt
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|is_replacing_spare
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|tgt
argument_list|,
name|which
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
comment|/*  * Attach new_disk (fully described by nvroot) to old_disk.  * If 'replacing' is specified, the new disk will replace the old one.  */
name|int
name|zpool_vdev_attach
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|old_disk
parameter_list|,
specifier|const
name|char
modifier|*
name|new_disk
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|int
name|replacing
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|,
name|l2cache
decl_stmt|,
name|islog
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|children
decl_stmt|;
name|nvlist_t
modifier|*
name|config_root
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|boolean_t
name|rootpool
init|=
name|zpool_is_bootable
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
if|if
condition|(
name|replacing
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot replace %s with %s"
argument_list|)
argument_list|,
name|old_disk
argument_list|,
name|new_disk
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot attach %s to %s"
argument_list|)
argument_list|,
name|new_disk
argument_list|,
name|old_disk
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|old_disk
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|islog
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|avail_spare
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|l2cache
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISL2CACHE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|replacing
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
operator|||
name|children
operator|!=
literal|1
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"new device must be a single disk"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALCONFIG
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|config_root
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newname
operator|=
name|zpool_vdev_name
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|child
index|[
literal|0
index|]
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * If the target is a hot spare that has been swapped in, we can only 	 * replace it with another hot spare. 	 */
if|if
condition|(
name|replacing
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_IS_SPARE
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|newname
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|avail_spare
operator|)
operator|&&
name|is_replacing_spare
argument_list|(
name|config_root
argument_list|,
name|tgt
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"can only be replaced by another hot spare"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTARGET
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_conf_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvroot
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_VDEV_ATTACH
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rootpool
condition|)
block|{
comment|/* 			 * XXX need a better way to prevent user from 			 * booting up a half-baked vdev. 			 */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Make "
literal|"sure to wait until resilver is done "
literal|"before rebooting.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"If "
literal|"you boot from pool '%s', you may need to update\n"
literal|"boot code on newly attached disk '%s'.\n\n"
literal|"Assuming you use GPT partitioning and 'da0' is "
literal|"your new boot disk\n"
literal|"you may use the following command:\n\n"
literal|"\tgpart bootcode -b /boot/pmbr -p "
literal|"/boot/gptzfsboot -i 1 da0\n\n"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
name|new_disk
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOTSUP
case|:
comment|/* 		 * Can't attach to or replace this type of vdev. 		 */
if|if
condition|(
name|replacing
condition|)
block|{
name|uint64_t
name|version
init|=
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|islog
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot replace a log with a spare"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_MULTI_REPLACE
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"already in replacing/spare config; wait "
literal|"for completion or use 'zpool detach'"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot replace a replacing device"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"can only attach to mirrors and top-level "
literal|"disks"
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTARGET
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
comment|/* 		 * The new device must be a single disk. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"new device must be a single disk"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALCONFIG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBUSY
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"%s is busy"
argument_list|)
argument_list|,
name|new_disk
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOVERFLOW
case|:
comment|/* 		 * The new device is too small. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"device is too small"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EDOM
case|:
comment|/* 		 * The new device has a different alignment requirement. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"devices have different sector alignment"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENAMETOOLONG
case|:
comment|/* 		 * The resulting top-level vdev spec won't fit in the label. 		 */
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_DEVOVERFLOW
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  * Detach the specified device.  */
name|int
name|zpool_vdev_detach
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|,
name|l2cache
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot detach %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|avail_spare
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|l2cache
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISL2CACHE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_VDEV_DETACH
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOTSUP
case|:
comment|/* 		 * Can't detach from this type of vdev. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"only "
literal|"applicable to mirror and replacing vdevs"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTARGET
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBUSY
case|:
comment|/* 		 * There are no other replicas of this device. 		 */
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOREPLICAS
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  * Find a mirror vdev in the source nvlist.  *  * The mchild array contains a list of disks in one of the top-level mirrors  * of the source pool.  The schild array contains a list of disks that the  * user specified on the command line.  We loop over the mchild array to  * see if any entry in the schild array matches.  *  * If a disk in the mchild array is found in the schild array, we return  * the index of that entry.  Otherwise we return -1.  */
specifier|static
name|int
name|find_vdev_entry
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|mchild
parameter_list|,
name|uint_t
name|mchildren
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|schild
parameter_list|,
name|uint_t
name|schildren
parameter_list|)
block|{
name|uint_t
name|mc
decl_stmt|;
for|for
control|(
name|mc
operator|=
literal|0
init|;
name|mc
operator|<
name|mchildren
condition|;
name|mc
operator|++
control|)
block|{
name|uint_t
name|sc
decl_stmt|;
name|char
modifier|*
name|mpath
init|=
name|zpool_vdev_name
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|zhp
argument_list|,
name|mchild
index|[
name|mc
index|]
argument_list|,
name|B_FALSE
argument_list|)
decl_stmt|;
for|for
control|(
name|sc
operator|=
literal|0
init|;
name|sc
operator|<
name|schildren
condition|;
name|sc
operator|++
control|)
block|{
name|char
modifier|*
name|spath
init|=
name|zpool_vdev_name
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|zhp
argument_list|,
name|schild
index|[
name|sc
index|]
argument_list|,
name|B_FALSE
argument_list|)
decl_stmt|;
name|boolean_t
name|result
init|=
operator|(
name|strcmp
argument_list|(
name|mpath
argument_list|,
name|spath
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|free
argument_list|(
name|spath
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|free
argument_list|(
name|mpath
argument_list|)
expr_stmt|;
return|return
operator|(
name|mc
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|mpath
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  * Split a mirror pool.  If newroot points to null, then a new nvlist  * is generated and it is the responsibility of the caller to free it.  */
name|int
name|zpool_vdev_split
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|newroot
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|splitflags_t
name|flags
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tree
decl_stmt|,
modifier|*
name|config
decl_stmt|,
modifier|*
modifier|*
name|child
decl_stmt|,
modifier|*
modifier|*
name|newchild
decl_stmt|,
modifier|*
name|newconfig
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|varray
init|=
name|NULL
decl_stmt|,
modifier|*
name|zc_props
init|=
name|NULL
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|,
name|newchildren
decl_stmt|,
name|lastlog
init|=
literal|0
decl_stmt|,
name|vcount
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|uint64_t
name|vers
decl_stmt|;
name|boolean_t
name|freelist
init|=
name|B_FALSE
decl_stmt|,
name|memory_err
init|=
name|B_TRUE
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Unable to split %s"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zpool_name_valid
argument_list|(
name|hdl
argument_list|,
name|B_FALSE
argument_list|,
name|newname
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Internal error: unable to "
literal|"retrieve pool configuration\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|tree
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|vers
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
condition|)
block|{
name|prop_flags_t
name|flags
init|=
block|{
operator|.
name|create
operator|=
name|B_FALSE
block|,
operator|.
name|import
operator|=
name|B_TRUE
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|zc_props
operator|=
name|zpool_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
name|props
argument_list|,
name|vers
argument_list|,
name|flags
argument_list|,
name|msg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|tree
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Source pool is missing vdev tree"
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zc_props
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|varray
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|children
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|vcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|newroot
operator|==
name|NULL
operator|||
name|nvlist_lookup_nvlist_array
argument_list|(
operator|*
name|newroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|newchild
argument_list|,
operator|&
name|newchildren
argument_list|)
operator|!=
literal|0
condition|)
name|newchildren
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|uint64_t
name|is_log
init|=
name|B_FALSE
decl_stmt|,
name|is_hole
init|=
name|B_FALSE
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|mchild
decl_stmt|,
modifier|*
name|vdev
decl_stmt|;
name|uint_t
name|mchildren
decl_stmt|;
name|int
name|entry
decl_stmt|;
comment|/* 		 * Unlike cache& spares, slogs are stored in the 		 * ZPOOL_CONFIG_CHILDREN array.  We filter them out here. 		 */
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|is_log
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_HOLE
argument_list|,
operator|&
name|is_hole
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_log
operator|||
name|is_hole
condition|)
block|{
comment|/* 			 * Create a hole vdev and put it in the config. 			 */
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|vdev
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|vdev
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_HOLE
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|vdev
argument_list|,
name|ZPOOL_CONFIG_IS_HOLE
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|lastlog
operator|==
literal|0
condition|)
name|lastlog
operator|=
name|vcount
expr_stmt|;
name|varray
index|[
name|vcount
operator|++
index|]
operator|=
name|vdev
expr_stmt|;
continue|continue;
block|}
name|lastlog
operator|=
literal|0
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_MIRROR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Source pool must be composed only of mirrors\n"
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALCONFIG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|mchild
argument_list|,
operator|&
name|mchildren
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* find or add an entry for this top-level vdev */
if|if
condition|(
name|newchildren
operator|>
literal|0
operator|&&
operator|(
name|entry
operator|=
name|find_vdev_entry
argument_list|(
name|zhp
argument_list|,
name|mchild
argument_list|,
name|mchildren
argument_list|,
name|newchild
argument_list|,
name|newchildren
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* We found a disk that the user specified. */
name|vdev
operator|=
name|mchild
index|[
name|entry
index|]
expr_stmt|;
operator|++
name|found
expr_stmt|;
block|}
else|else
block|{
comment|/* User didn't specify a disk for this vdev. */
name|vdev
operator|=
name|mchild
index|[
name|mchildren
operator|-
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_dup
argument_list|(
name|vdev
argument_list|,
operator|&
name|varray
index|[
name|vcount
operator|++
index|]
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* did we find every disk the user specified? */
if|if
condition|(
name|found
operator|!=
name|newchildren
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Device list must "
literal|"include at most one disk from each mirror"
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALCONFIG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Prepare the nvlist for populating. */
if|if
condition|(
operator|*
name|newroot
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nvlist_alloc
argument_list|(
name|newroot
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|freelist
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
operator|*
name|newroot
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_ROOT
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|verify
argument_list|(
name|nvlist_remove_all
argument_list|(
operator|*
name|newroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Add all the children we found */
if|if
condition|(
name|nvlist_add_nvlist_array
argument_list|(
operator|*
name|newroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|varray
argument_list|,
name|lastlog
operator|==
literal|0
condition|?
name|vcount
else|:
name|lastlog
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * If we're just doing a dry run, exit now with success. 	 */
if|if
condition|(
name|flags
operator|.
name|dryrun
condition|)
block|{
name|memory_err
operator|=
name|B_FALSE
expr_stmt|;
name|freelist
operator|=
name|B_FALSE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* now build up the config list& call the ioctl */
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|newconfig
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|newconfig
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|*
name|newroot
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_string
argument_list|(
name|newconfig
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
name|newname
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_uint64
argument_list|(
name|newconfig
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
name|vers
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * The new pool is automatically part of the namespace unless we 	 * explicitly export it. 	 */
if|if
condition|(
operator|!
name|flags
operator|.
name|import
condition|)
name|zc
operator|.
name|zc_cookie
operator|=
name|ZPOOL_EXPORT_AFTER_SPLIT
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_string
argument_list|,
name|newname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_string
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_conf_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|newconfig
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|zc_props
operator|!=
name|NULL
operator|&&
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|zc_props
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_VDEV_SPLIT
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|freelist
operator|=
name|B_FALSE
expr_stmt|;
name|memory_err
operator|=
name|B_FALSE
expr_stmt|;
name|out
label|:
if|if
condition|(
name|varray
operator|!=
name|NULL
condition|)
block|{
name|int
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
literal|0
init|;
name|v
operator|<
name|vcount
condition|;
name|v
operator|++
control|)
name|nvlist_free
argument_list|(
name|varray
index|[
name|v
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|varray
argument_list|)
expr_stmt|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zc_props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|newconfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|freelist
condition|)
block|{
name|nvlist_free
argument_list|(
operator|*
name|newroot
argument_list|)
expr_stmt|;
operator|*
name|newroot
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
return|return
operator|(
name|retval
operator|)
return|;
if|if
condition|(
name|memory_err
condition|)
return|return
operator|(
name|no_memory
argument_list|(
name|hdl
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Remove the given device.  Currently, this is supported only for hot spares  * and level 2 cache devices.  */
name|int
name|zpool_vdev_remove
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|,
name|l2cache
decl_stmt|,
name|islog
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot remove %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|islog
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
comment|/* 	 * XXX - this should just go away. 	 */
if|if
condition|(
operator|!
name|avail_spare
operator|&&
operator|!
name|l2cache
operator|&&
operator|!
name|islog
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"only inactive hot spares, cache, top-level, "
literal|"or log devices can be removed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
name|version
operator|=
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|islog
operator|&&
name|version
operator|<
name|SPA_VERSION_HOLES
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgrade to support log removal"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_VDEV_REMOVE
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
comment|/*  * Clear the errors for the pool, or the particular device if specified.  */
name|int
name|zpool_clear
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|nvlist_t
modifier|*
name|rewindnvl
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|zpool_rewind_policy_t
name|policy
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|,
name|l2cache
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|nvlist_t
modifier|*
name|nvi
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|path
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot clear errors for %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot clear errors for %s"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
block|{
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
comment|/* 		 * Don't allow error clearing for hot spares.  Do allow 		 * error clearing for l2cache devices. 		 */
if|if
condition|(
name|avail_spare
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|zpool_get_rewind_policy
argument_list|(
name|rewindnvl
argument_list|,
operator|&
name|policy
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|policy
operator|.
name|zrp_request
expr_stmt|;
if|if
condition|(
name|zcmd_alloc_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|zhp
operator|->
name|zpool_config_size
operator|*
literal|2
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|rewindnvl
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
operator|(
name|error
operator|=
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_CLEAR
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|zcmd_expand_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|error
operator|||
operator|(
operator|(
name|policy
operator|.
name|zrp_request
operator|&
name|ZPOOL_TRY_REWIND
operator|)
operator|&&
name|errno
operator|!=
name|EPERM
operator|&&
name|errno
operator|!=
name|EACCES
operator|)
condition|)
block|{
if|if
condition|(
name|policy
operator|.
name|zrp_request
operator|&
operator|(
name|ZPOOL_DO_REWIND
operator||
name|ZPOOL_TRY_REWIND
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|zcmd_read_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
operator|&
name|nvi
argument_list|)
expr_stmt|;
name|zpool_rewind_exclaim
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
operator|(
operator|(
name|policy
operator|.
name|zrp_request
operator|&
name|ZPOOL_TRY_REWIND
operator|)
operator|!=
literal|0
operator|)
argument_list|,
name|nvi
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvi
argument_list|)
expr_stmt|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
comment|/*  * Similar to zpool_clear(), but takes a GUID (used by fmd).  */
name|int
name|zpool_vdev_clear
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot clear errors for %llx"
argument_list|)
argument_list|,
name|guid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
name|guid
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|ZPOOL_NO_REWIND
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_CLEAR
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
comment|/*  * Change the GUID for a pool.  */
name|int
name|zpool_reguid
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot reguid '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_POOL_REGUID
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
comment|/*  * Reopen the pool.  */
name|int
name|zpool_reopen
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot reopen '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_POOL_REOPEN
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
comment|/*  * Convert from a devid string to a path.  */
specifier|static
name|char
modifier|*
name|devid_to_path
parameter_list|(
name|char
modifier|*
name|devid_str
parameter_list|)
block|{
name|ddi_devid_t
name|devid
decl_stmt|;
name|char
modifier|*
name|minor
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|devid_nmlist_t
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|devid_str_decode
argument_list|(
name|devid_str
argument_list|,
operator|&
name|devid
argument_list|,
operator|&
name|minor
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ret
operator|=
name|devid_deviceid_to_nmlist
argument_list|(
literal|"/dev"
argument_list|,
name|devid
argument_list|,
name|minor
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|devid_str_free
argument_list|(
name|minor
argument_list|)
expr_stmt|;
name|devid_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * In a case the strdup() fails, we will just return NULL below. 	 */
name|path
operator|=
name|strdup
argument_list|(
name|list
index|[
literal|0
index|]
operator|.
name|devname
argument_list|)
expr_stmt|;
name|devid_free_nmlist
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|path
operator|)
return|;
block|}
comment|/*  * Convert from a path to a devid string.  */
specifier|static
name|char
modifier|*
name|path_to_devid
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|have_devid
name|int
name|fd
decl_stmt|;
name|ddi_devid_t
name|devid
decl_stmt|;
name|char
modifier|*
name|minor
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|minor
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|devid_get
argument_list|(
name|fd
argument_list|,
operator|&
name|devid
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|devid_get_minor_name
argument_list|(
name|fd
argument_list|,
operator|&
name|minor
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|devid_str_encode
argument_list|(
name|devid
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|minor
operator|!=
name|NULL
condition|)
name|devid_str_free
argument_list|(
name|minor
argument_list|)
expr_stmt|;
name|devid_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|NULL
operator|)
return|;
endif|#
directive|endif
block|}
comment|/*  * Issue the necessary ioctl() to update the stored path value for the vdev.  We  * ignore any failure here, since a common case is for an unprivileged user to  * type 'zpool status', and we'll display the correct information anyway.  */
specifier|static
name|void
name|set_path
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_VDEV_SETPATH
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
comment|/*  * Given a vdev, return the name to display in iostat.  If the vdev has a path,  * we use that, stripping off any leading "/dev/dsk/"; if not, we use the type.  * We also check if this is a whole disk, in which case we strip off the  * trailing 's0' slice name.  *  * This routine is also responsible for identifying when disks have been  * reconfigured in a new location.  The kernel will have opened the device by  * devid, but the path will still refer to the old location.  To catch this, we  * first do a path -> devid translation (which is fast for the common case).  If  * the devid matches, we're done.  If not, we do a reverse devid -> path  * translation and issue the appropriate ioctl() to update the path of the vdev.  * If 'zhp' is NULL, then this is an exported pool, and we don't need to do any  * of these checks.  */
name|char
modifier|*
name|zpool_vdev_name
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|boolean_t
name|verbose
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|devid
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
name|int
name|have_stats
decl_stmt|;
name|int
name|have_path
decl_stmt|;
name|have_stats
operator|=
name|nvlist_lookup_uint64_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
expr_stmt|;
name|have_path
operator|=
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
expr_stmt|;
comment|/* 	 * If the device is not currently present, assume it will not 	 * come back at the same device path.  Display the device by GUID. 	 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NOT_PRESENT
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
operator|||
name|have_path
operator|&&
name|have_stats
operator|&&
name|vs
operator|->
name|vs_state
operator|<=
name|VDEV_STATE_CANT_OPEN
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|value
argument_list|)
expr_stmt|;
name|path
operator|=
name|buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|have_path
condition|)
block|{
comment|/* 		 * If the device is dead (faulted, offline, etc) then don't 		 * bother opening it.  Otherwise we may be forcing the user to 		 * open a misbehaving device, which can have undesirable 		 * effects. 		 */
if|if
condition|(
operator|(
name|have_stats
operator|==
literal|0
operator|||
name|vs
operator|->
name|vs_state
operator|>=
name|VDEV_STATE_DEGRADED
operator|)
operator|&&
name|zhp
operator|!=
name|NULL
operator|&&
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DEVID
argument_list|,
operator|&
name|devid
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Determine if the current path is correct. 			 */
name|char
modifier|*
name|newdevid
init|=
name|path_to_devid
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|newdevid
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|devid
argument_list|,
name|newdevid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|newpath
decl_stmt|;
if|if
condition|(
operator|(
name|newpath
operator|=
name|devid_to_path
argument_list|(
name|devid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * Update the path appropriately. 					 */
name|set_path
argument_list|(
name|zhp
argument_list|,
name|nv
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
name|newpath
argument_list|)
operator|==
literal|0
condition|)
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newdevid
condition|)
name|devid_str_free
argument_list|(
name|newdevid
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|strncmp
argument_list|(
name|path
argument_list|,
name|ZFS_DISK_ROOTD
argument_list|,
name|strlen
argument_list|(
name|ZFS_DISK_ROOTD
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|path
operator|+=
name|strlen
argument_list|(
name|ZFS_DISK_ROOTD
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_WHOLE_DISK
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
operator|&&
name|value
condition|)
block|{
name|int
name|pathlen
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
decl_stmt|;
comment|/* 			 * If it starts with c#, and ends with "s0", chop 			 * the "s0" off, or if it ends with "s0/old", remove 			 * the "s0" from the middle. 			 */
if|if
condition|(
name|CTD_CHECK
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|tmp
index|[
name|pathlen
operator|-
literal|2
index|]
argument_list|,
literal|"s0"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tmp
index|[
name|pathlen
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pathlen
operator|>
literal|6
operator|&&
name|strcmp
argument_list|(
operator|&
name|tmp
index|[
name|pathlen
operator|-
literal|6
index|]
argument_list|,
literal|"s0/old"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|tmp
index|[
name|pathlen
operator|-
literal|6
index|]
argument_list|,
literal|"/old"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|tmp
operator|)
return|;
block|}
else|#
directive|else
comment|/* !illumos */
if|if
condition|(
name|strncmp
argument_list|(
name|path
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
argument_list|(
name|_PATH_DEV
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|path
operator|+=
sizeof|sizeof
argument_list|(
name|_PATH_DEV
argument_list|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* illumos */
block|}
else|else
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If it's a raidz device, we need to stick in the parity level. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|path
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NPARITY
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%llu"
argument_list|,
name|path
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|value
argument_list|)
expr_stmt|;
name|path
operator|=
name|buf
expr_stmt|;
block|}
comment|/* 		 * We identify each top-level vdev by using a<type-id> 		 * naming convention. 		 */
if|if
condition|(
name|verbose
condition|)
block|{
name|uint64_t
name|id
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
operator|&
name|id
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s-%llu"
argument_list|,
name|path
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|id
argument_list|)
expr_stmt|;
name|path
operator|=
name|buf
expr_stmt|;
block|}
block|}
return|return
operator|(
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
operator|)
return|;
block|}
specifier|static
name|int
name|zbookmark_mem_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|memcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|zbookmark_phys_t
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/*  * Retrieve the persistent error log, uniquify the members, and return to the  * caller.  */
name|int
name|zpool_get_errlog
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nverrlistp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint64_t
name|count
decl_stmt|;
name|zbookmark_phys_t
modifier|*
name|zb
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Retrieve the raw error list from the kernel.  If the number of errors 	 * has increased, allocate more space and continue until we get the 	 * entire list. 	 */
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_ERRCOUNT
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|zc
operator|.
name|zc_nvlist_dst
operator|=
operator|(
name|uintptr_t
operator|)
name|zfs_alloc
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|zbookmark_phys_t
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|uintptr_t
operator|)
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zc
operator|.
name|zc_nvlist_dst_size
operator|=
name|count
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_ERROR_LOG
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|void
modifier|*
name|dst
decl_stmt|;
name|count
operator|=
name|zc
operator|.
name|zc_nvlist_dst_size
expr_stmt|;
name|dst
operator|=
name|zfs_alloc
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|zbookmark_phys_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zc
operator|.
name|zc_nvlist_dst
operator|=
operator|(
name|uintptr_t
operator|)
name|dst
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
comment|/* 	 * Sort the resulting bookmarks.  This is a little confusing due to the 	 * implementation of ZFS_IOC_ERROR_LOG.  The bookmarks are copied last 	 * to first, and 'zc_nvlist_dst_size' indicates the number of boomarks 	 * _not_ copied as part of the process.  So we point the start of our 	 * array appropriate and decrement the total number of elements. 	 */
name|zb
operator|=
operator|(
operator|(
name|zbookmark_phys_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
operator|)
operator|+
name|zc
operator|.
name|zc_nvlist_dst_size
expr_stmt|;
name|count
operator|-=
name|zc
operator|.
name|zc_nvlist_dst_size
expr_stmt|;
name|qsort
argument_list|(
name|zb
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|zbookmark_phys_t
argument_list|)
argument_list|,
name|zbookmark_mem_compare
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_alloc
argument_list|(
name|nverrlistp
argument_list|,
literal|0
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the nverrlistp with nvlist's of dataset and object numbers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
comment|/* ignoring zb_blkid and zb_level for now */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|zb
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|zb_objset
operator|==
name|zb
index|[
name|i
index|]
operator|.
name|zb_objset
operator|&&
name|zb
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|zb_object
operator|==
name|zb
index|[
name|i
index|]
operator|.
name|zb_object
condition|)
continue|continue;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_ERR_DATASET
argument_list|,
name|zb
index|[
name|i
index|]
operator|.
name|zb_objset
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_ERR_OBJECT
argument_list|,
name|zb
index|[
name|i
index|]
operator|.
name|zb_object
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
operator|*
name|nverrlistp
argument_list|,
literal|"ejk"
argument_list|,
name|nv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nomem
label|:
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
return|return
operator|(
name|no_memory
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|)
operator|)
return|;
block|}
comment|/*  * Upgrade a ZFS pool to the latest on-disk version.  */
name|int
name|zpool_upgrade
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|new_version
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|new_version
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_POOL_UPGRADE
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|zpool_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot upgrade '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|void
name|zfs_save_arguments
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|int
name|len
parameter_list|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|string
argument_list|,
name|basename
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|string
argument_list|,
literal|" "
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|string
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|zpool_log_history
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|int
name|err
decl_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_string
argument_list|(
name|args
argument_list|,
literal|"message"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|err
operator|=
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_LOG_HISTORY
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*  * Perform ioctl to get some command history of a pool.  *  * 'buf' is the buffer to fill up to 'len' bytes.  'off' is the  * logical offset of the history buffer to start reading from.  *  * Upon return, 'off' is the next logical offset to read from and  * 'len' is the actual amount of bytes read into 'buf'.  */
specifier|static
name|int
name|get_history
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|uint64_t
modifier|*
name|off
parameter_list|,
name|uint64_t
modifier|*
name|len
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_history
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|zc
operator|.
name|zc_history_len
operator|=
operator|*
name|len
expr_stmt|;
name|zc
operator|.
name|zc_history_offset
operator|=
operator|*
name|off
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_GET_HISTORY
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EPERM
case|:
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_PERM
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot show history for pool '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
case|case
name|ENOENT
case|:
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOHISTORY
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get history for pool "
literal|"'%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
case|case
name|ENOTSUP
case|:
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get history for pool "
literal|"'%s', pool must be upgraded"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zpool_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get history for '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
block|}
block|}
operator|*
name|len
operator|=
name|zc
operator|.
name|zc_history_len
expr_stmt|;
operator|*
name|off
operator|=
name|zc
operator|.
name|zc_history_offset
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Process the buffer of nvlists, unpacking and storing each nvlist record  * into 'records'.  'leftover' is set to the number of bytes that weren't  * processed as there wasn't a complete record.  */
name|int
name|zpool_history_unpack
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|bytes_read
parameter_list|,
name|uint64_t
modifier|*
name|leftover
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
modifier|*
name|records
parameter_list|,
name|uint_t
modifier|*
name|numrecords
parameter_list|)
block|{
name|uint64_t
name|reclen
decl_stmt|;
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|bytes_read
operator|>
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
condition|)
block|{
comment|/* get length of packed record (stored as little endian) */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|reclen
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
condition|;
name|i
operator|++
control|)
name|reclen
operator|+=
call|(
name|uint64_t
call|)
argument_list|(
operator|(
operator|(
name|uchar_t
operator|*
operator|)
name|buf
operator|)
index|[
name|i
index|]
argument_list|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
operator|+
name|reclen
condition|)
break|break;
comment|/* unpack record */
if|if
condition|(
name|nvlist_unpack
argument_list|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
argument_list|,
name|reclen
argument_list|,
operator|&
name|nv
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bytes_read
operator|-=
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
operator|+
name|reclen
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
operator|+
name|reclen
expr_stmt|;
comment|/* add record to nvlist array */
operator|(
operator|*
name|numrecords
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|ISP2
argument_list|(
operator|*
name|numrecords
operator|+
literal|1
argument_list|)
condition|)
block|{
operator|*
name|records
operator|=
name|realloc
argument_list|(
operator|*
name|records
argument_list|,
operator|*
name|numrecords
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|records
operator|)
index|[
operator|*
name|numrecords
operator|-
literal|1
index|]
operator|=
name|nv
expr_stmt|;
block|}
operator|*
name|leftover
operator|=
name|bytes_read
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* from spa_history.c: spa_history_create_obj() */
define|#
directive|define
name|HIS_BUF_LEN_DEF
value|(128<< 10)
define|#
directive|define
name|HIS_BUF_LEN_MAX
value|(1<< 30)
comment|/*  * Retrieve the command history of a pool.  */
name|int
name|zpool_get_history
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvhisp
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|uint64_t
name|buflen
init|=
name|HIS_BUF_LEN_DEF
decl_stmt|;
name|uint64_t
name|off
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|records
init|=
name|NULL
decl_stmt|;
name|uint_t
name|numrecords
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
do|do
block|{
name|uint64_t
name|bytes_read
init|=
name|buflen
decl_stmt|;
name|uint64_t
name|leftover
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|get_history
argument_list|(
name|zhp
argument_list|,
name|buf
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|bytes_read
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* if nothing else was read in, we're at EOF, just return */
if|if
condition|(
name|bytes_read
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|err
operator|=
name|zpool_history_unpack
argument_list|(
name|buf
argument_list|,
name|bytes_read
argument_list|,
operator|&
name|leftover
argument_list|,
operator|&
name|records
argument_list|,
operator|&
name|numrecords
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|off
operator|-=
name|leftover
expr_stmt|;
if|if
condition|(
name|leftover
operator|==
name|bytes_read
condition|)
block|{
comment|/* 			 * no progress made, because buffer is not big enough 			 * to hold this record; resize and retry. 			 */
name|buflen
operator|*=
literal|2
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|buflen
operator|>=
name|HIS_BUF_LEN_MAX
operator|)
operator|||
operator|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
block|}
comment|/* CONSTCOND */
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|verify
argument_list|(
name|nvlist_alloc
argument_list|(
name|nvhisp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
operator|*
name|nvhisp
argument_list|,
name|ZPOOL_HIST_RECORD
argument_list|,
name|records
argument_list|,
name|numrecords
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numrecords
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|records
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|records
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|void
name|zpool_obj_to_path
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|char
modifier|*
name|pathname
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|boolean_t
name|mounted
init|=
name|B_FALSE
decl_stmt|;
name|char
modifier|*
name|mntpnt
init|=
name|NULL
decl_stmt|;
name|char
name|dsname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
if|if
condition|(
name|dsobj
operator|==
literal|0
condition|)
block|{
comment|/* special case for the MOS */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"<metadata>:<0x%llx>"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get the dataset's name */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|dsobj
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_DSOBJ_TO_DSNAME
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* just write out a path of two object numbers */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"<0x%llx>:<0x%llx>"
argument_list|,
name|dsobj
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dsname
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
sizeof|sizeof
argument_list|(
name|dsname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* find out if the dataset is mounted */
name|mounted
operator|=
name|is_mounted
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|dsname
argument_list|,
operator|&
name|mntpnt
argument_list|)
expr_stmt|;
comment|/* get the corrupted object's path */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dsname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|obj
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJ_TO_PATH
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mounted
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"%s%s"
argument_list|,
name|mntpnt
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"%s:%s"
argument_list|,
name|dsname
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"%s:<0x%llx>"
argument_list|,
name|dsname
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mntpnt
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|illumos
comment|/*  * Read the EFI label from the config, if a label does not exist then  * pass back the error to the caller. If the caller has passed a non-NULL  * diskaddr argument then we set it to the starting address of the EFI  * partition.  */
specifier|static
name|int
name|read_efi_label
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|diskaddr_t
modifier|*
name|sb
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|diskname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|err
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|diskname
argument_list|,
sizeof|sizeof
argument_list|(
name|diskname
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|ZFS_RDISK_ROOT
argument_list|,
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|diskname
argument_list|,
name|O_RDONLY
operator||
name|O_NDELAY
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|struct
name|dk_gpt
modifier|*
name|vtoc
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|efi_alloc_and_read
argument_list|(
name|fd
argument_list|,
operator|&
name|vtoc
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
operator|*
name|sb
operator|=
name|vtoc
operator|->
name|efi_parts
index|[
literal|0
index|]
operator|.
name|p_start
expr_stmt|;
name|efi_free
argument_list|(
name|vtoc
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*  * determine where a partition starts on a disk in the current  * configuration  */
specifier|static
name|diskaddr_t
name|find_start_block
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|diskaddr_t
name|sb
init|=
name|MAXOFFSET_T
decl_stmt|;
name|uint64_t
name|wholedisk
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_WHOLE_DISK
argument_list|,
operator|&
name|wholedisk
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|wholedisk
condition|)
block|{
return|return
operator|(
name|MAXOFFSET_T
operator|)
return|;
block|}
if|if
condition|(
name|read_efi_label
argument_list|(
name|config
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|sb
operator|=
name|MAXOFFSET_T
expr_stmt|;
return|return
operator|(
name|sb
operator|)
return|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|sb
operator|=
name|find_start_block
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|MAXOFFSET_T
condition|)
block|{
return|return
operator|(
name|sb
operator|)
return|;
block|}
block|}
return|return
operator|(
name|MAXOFFSET_T
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* illumos */
comment|/*  * Label an individual disk.  The name provided is the short name,  * stripped of any leading /dev path.  */
name|int
name|zpool_label_disk
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|dk_gpt
modifier|*
name|vtoc
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|size_t
name|resv
init|=
name|EFI_MIN_RESV_SIZE
decl_stmt|;
name|uint64_t
name|slice_size
decl_stmt|;
name|diskaddr_t
name|start_block
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
comment|/* prepare an error message just in case */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot label '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
condition|)
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zpool_start_block
operator|==
literal|0
condition|)
name|start_block
operator|=
name|find_start_block
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
else|else
name|start_block
operator|=
name|zhp
operator|->
name|zpool_start_block
expr_stmt|;
name|zhp
operator|->
name|zpool_start_block
operator|=
name|start_block
expr_stmt|;
block|}
else|else
block|{
comment|/* new pool */
name|start_block
operator|=
name|NEW_START_BLOCK
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|ZFS_RDISK_ROOT
argument_list|,
name|name
argument_list|,
name|BACKUP_SLICE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * This shouldn't happen.  We've long since verified that this 		 * is a valid device. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unable to open device"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_OPENFAILED
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|efi_alloc_and_init
argument_list|(
name|fd
argument_list|,
name|EFI_NUMPAR
argument_list|,
operator|&
name|vtoc
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The only way this can fail is if we run out of memory, or we 		 * were unable to read the disk's capacity 		 */
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unable to read disk capacity"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOCAP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|slice_size
operator|=
name|vtoc
operator|->
name|efi_last_u_lba
operator|+
literal|1
expr_stmt|;
name|slice_size
operator|-=
name|EFI_MIN_RESV_SIZE
expr_stmt|;
if|if
condition|(
name|start_block
operator|==
name|MAXOFFSET_T
condition|)
name|start_block
operator|=
name|NEW_START_BLOCK
expr_stmt|;
name|slice_size
operator|-=
name|start_block
expr_stmt|;
name|vtoc
operator|->
name|efi_parts
index|[
literal|0
index|]
operator|.
name|p_start
operator|=
name|start_block
expr_stmt|;
name|vtoc
operator|->
name|efi_parts
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
name|slice_size
expr_stmt|;
comment|/* 	 * Why we use V_USR: V_BACKUP confuses users, and is considered 	 * disposable by some EFI utilities (since EFI doesn't have a backup 	 * slice).  V_UNASSIGNED is supposed to be used only for zero size 	 * partitions, and efi_write() will fail if we use it.  V_ROOT, V_BOOT, 	 * etc. were all pretty specific.  V_USR is as close to reality as we 	 * can get, in the absence of V_OTHER. 	 */
name|vtoc
operator|->
name|efi_parts
index|[
literal|0
index|]
operator|.
name|p_tag
operator|=
name|V_USR
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|vtoc
operator|->
name|efi_parts
index|[
literal|0
index|]
operator|.
name|p_name
argument_list|,
literal|"zfs"
argument_list|)
expr_stmt|;
name|vtoc
operator|->
name|efi_parts
index|[
literal|8
index|]
operator|.
name|p_start
operator|=
name|slice_size
operator|+
name|start_block
expr_stmt|;
name|vtoc
operator|->
name|efi_parts
index|[
literal|8
index|]
operator|.
name|p_size
operator|=
name|resv
expr_stmt|;
name|vtoc
operator|->
name|efi_parts
index|[
literal|8
index|]
operator|.
name|p_tag
operator|=
name|V_RESERVED
expr_stmt|;
if|if
condition|(
name|efi_write
argument_list|(
name|fd
argument_list|,
name|vtoc
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Some block drivers (like pcata) may not support EFI 		 * GPT labels.  Print out a helpful error message dir- 		 * ecting the user to manually label the disk and give 		 * a specific slice. 		 */
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|efi_free
argument_list|(
name|vtoc
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"try using fdisk(1M) and then provide a specific slice"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_LABELFAILED
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|efi_free
argument_list|(
name|vtoc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* illumos */
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|boolean_t
name|supported_dump_vdev_type
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|char
modifier|*
name|type
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|children
decl_stmt|,
name|c
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_FILE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_HOLE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_MISSING
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"vdev type '%s' is not supported"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_VDEVNOTSUP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|supported_dump_vdev_type
argument_list|(
name|hdl
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|errbuf
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
comment|/*  * Check if this zvol is allowable for use as a dump device; zero if  * it is,> 0 if it isn't,< 0 if it isn't a zvol.  *  * Allowable storage configurations include mirrors, all raidz variants, and  * pools with log, cache, and spare devices.  Pools which are backed by files or  * have missing/hole vdevs are not suitable.  */
name|int
name|zvol_check_dump_config
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|volname
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|top
decl_stmt|;
name|uint_t
name|toplevels
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|poolname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|pathlen
init|=
name|strlen
argument_list|(
name|ZVOL_FULL_DEV_DIR
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
name|ZVOL_FULL_DEV_DIR
argument_list|,
name|pathlen
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dump is not supported on device '%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdl
operator|=
name|libzfs_init
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|libzfs_print_on_error
argument_list|(
name|hdl
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|volname
operator|=
name|arg
operator|+
name|pathlen
expr_stmt|;
comment|/* check the configuration of the pool */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|volname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"malformed dataset name"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|-
name|volname
operator|>=
name|ZFS_MAX_DATASET_NAME_LEN
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset name is too long"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NAMETOOLONG
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|poolname
argument_list|,
name|volname
argument_list|,
name|p
operator|-
name|volname
argument_list|)
expr_stmt|;
name|poolname
index|[
name|p
operator|-
name|volname
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|hdl
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"could not open pool '%s'"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_OPENFAILED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"could not obtain vdev configuration for  '%s'"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALCONFIG
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|toplevels
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|supported_dump_vdev_type
argument_list|(
name|hdl
argument_list|,
name|top
index|[
literal|0
index|]
argument_list|,
name|errbuf
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|zhp
condition|)
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|libzfs_fini
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|int
name|zpool_nextboot
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|uint64_t
name|pool_guid
parameter_list|,
name|uint64_t
name|dev_guid
parameter_list|,
specifier|const
name|char
modifier|*
name|command
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|packed
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|args
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
name|pool_guid
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|args
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|dev_guid
argument_list|)
expr_stmt|;
name|fnvlist_add_string
argument_list|(
name|args
argument_list|,
literal|"command"
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|error
operator|=
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_NEXTBOOT
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

