begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<devid.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<zone.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<umem.h>
end_include

begin_include
include|#
directive|include
file|"zfs_namecheck.h"
end_include

begin_include
include|#
directive|include
file|"zfs_prop.h"
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_function_decl
specifier|static
name|int
name|read_efi_label
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|diskaddr_t
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64
argument_list|)
end_if

begin_define
define|#
directive|define
name|BOOTCMD
value|"installgrub(1M)"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BOOTCMD
value|"installboot(1M)"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sun */
end_comment

begin_comment
comment|/*  * ====================================================================  *   zpool property functions  * ====================================================================  */
end_comment

begin_function
specifier|static
name|int
name|zpool_get_all_props
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_alloc_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_GET_PROPS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|zcmd_expand_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|zcmd_read_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
operator|&
name|zhp
operator|->
name|zpool_props
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zpool_props_refresh
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|old_props
decl_stmt|;
name|old_props
operator|=
name|zhp
operator|->
name|zpool_props
expr_stmt|;
if|if
condition|(
name|zpool_get_all_props
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nvlist_free
argument_list|(
name|old_props
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|zpool_get_prop_string
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|zpool_prop_t
name|prop
parameter_list|,
name|zprop_source_t
modifier|*
name|src
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|,
modifier|*
name|nvl
decl_stmt|;
name|uint64_t
name|ival
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|zprop_source_t
name|source
decl_stmt|;
name|nvl
operator|=
name|zhp
operator|->
name|zpool_props
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|nvl
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPROP_SOURCE
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|source
operator|=
name|ival
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|source
operator|=
name|ZPROP_SRC_DEFAULT
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|zpool_prop_default_string
argument_list|(
name|prop
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|value
operator|=
literal|"-"
expr_stmt|;
block|}
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|source
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|zpool_get_prop_int
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|zpool_prop_t
name|prop
parameter_list|,
name|zprop_source_t
modifier|*
name|src
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|,
modifier|*
name|nvl
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|zprop_source_t
name|source
decl_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zpool_props
operator|==
name|NULL
operator|&&
name|zpool_get_all_props
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
comment|/* 		 * zpool_get_all_props() has most likely failed because 		 * the pool is faulted, but if all we need is the top level 		 * vdev's guid then get it from the zhp config nvlist. 		 */
if|if
condition|(
operator|(
name|prop
operator|==
name|ZPOOL_PROP_GUID
operator|)
operator|&&
operator|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|value
operator|)
return|;
block|}
return|return
operator|(
name|zpool_prop_default_numeric
argument_list|(
name|prop
argument_list|)
operator|)
return|;
block|}
name|nvl
operator|=
name|zhp
operator|->
name|zpool_props
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|nvl
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPROP_SOURCE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|source
operator|=
name|value
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|source
operator|=
name|ZPROP_SRC_DEFAULT
expr_stmt|;
name|value
operator|=
name|zpool_prop_default_numeric
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|source
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map VDEV STATE to printed strings.  */
end_comment

begin_function
name|char
modifier|*
name|zpool_state_to_name
parameter_list|(
name|vdev_state_t
name|state
parameter_list|,
name|vdev_aux_t
name|aux
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|VDEV_STATE_CLOSED
case|:
case|case
name|VDEV_STATE_OFFLINE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"OFFLINE"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_REMOVED
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"REMOVED"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_CANT_OPEN
case|:
if|if
condition|(
name|aux
operator|==
name|VDEV_AUX_CORRUPT_DATA
operator|||
name|aux
operator|==
name|VDEV_AUX_BAD_LOG
condition|)
return|return
operator|(
name|gettext
argument_list|(
literal|"FAULTED"
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|gettext
argument_list|(
literal|"UNAVAIL"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_FAULTED
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"FAULTED"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_DEGRADED
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"DEGRADED"
argument_list|)
operator|)
return|;
case|case
name|VDEV_STATE_HEALTHY
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"ONLINE"
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|gettext
argument_list|(
literal|"UNKNOWN"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a zpool property value for 'prop' and return the value in  * a pre-allocated buffer.  */
end_comment

begin_function
name|int
name|zpool_get_prop
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|zpool_prop_t
name|prop
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|zprop_source_t
modifier|*
name|srctype
parameter_list|)
block|{
name|uint64_t
name|intval
decl_stmt|;
specifier|const
name|char
modifier|*
name|strval
decl_stmt|;
name|zprop_source_t
name|src
init|=
name|ZPROP_SRC_NONE
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
if|if
condition|(
name|zpool_get_state
argument_list|(
name|zhp
argument_list|)
operator|==
name|POOL_STATE_UNAVAIL
condition|)
block|{
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZPOOL_PROP_NAME
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|zpool_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_HEALTH
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"FAULTED"
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_GUID
case|:
name|intval
operator|=
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%llu"
argument_list|,
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_ALTROOT
case|:
case|case
name|ZPOOL_PROP_CACHEFILE
case|:
if|if
condition|(
name|zhp
operator|->
name|zpool_props
operator|!=
name|NULL
operator|||
name|zpool_get_all_props
argument_list|(
name|zhp
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|zpool_get_prop_string
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|src
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|srctype
operator|!=
name|NULL
condition|)
operator|*
name|srctype
operator|=
name|src
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
default|default:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|srctype
operator|!=
name|NULL
condition|)
operator|*
name|srctype
operator|=
name|src
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zhp
operator|->
name|zpool_props
operator|==
name|NULL
operator|&&
name|zpool_get_all_props
argument_list|(
name|zhp
argument_list|)
operator|&&
name|prop
operator|!=
name|ZPOOL_PROP_NAME
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|zpool_prop_get_type
argument_list|(
name|prop
argument_list|)
condition|)
block|{
case|case
name|PROP_TYPE_STRING
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|zpool_get_prop_string
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|src
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_TYPE_NUMBER
case|:
name|intval
operator|=
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZPOOL_PROP_SIZE
case|:
case|case
name|ZPOOL_PROP_USED
case|:
case|case
name|ZPOOL_PROP_AVAILABLE
case|:
operator|(
name|void
operator|)
name|zfs_nicenum
argument_list|(
name|intval
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_CAPACITY
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%llu%%"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_HEALTH
case|:
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|zpool_state_to_name
argument_list|(
name|intval
argument_list|,
name|vs
operator|->
name|vs_aux
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%llu"
argument_list|,
name|intval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROP_TYPE_INDEX
case|:
name|intval
operator|=
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_prop_index_to_string
argument_list|(
name|prop
argument_list|,
name|intval
argument_list|,
operator|&
name|strval
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|strval
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|srctype
condition|)
operator|*
name|srctype
operator|=
name|src
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|pool_is_bootable
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|char
name|bootfs
index|[
name|ZPOOL_MAXNAMELEN
index|]
decl_stmt|;
return|return
operator|(
name|zpool_get_prop
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_BOOTFS
argument_list|,
name|bootfs
argument_list|,
sizeof|sizeof
argument_list|(
name|bootfs
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|bootfs
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|bootfs
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the bootfs name has the same pool name as it is set to.  * Assuming bootfs is a valid dataset name.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|bootfs_name_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|char
modifier|*
name|bootfs
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|zfs_name_valid
argument_list|(
name|bootfs
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_SNAPSHOT
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|pool
argument_list|,
name|bootfs
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|bootfs
index|[
name|len
index|]
operator|==
literal|'/'
operator|||
name|bootfs
index|[
name|len
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Inspect the configuration to determine if any of the devices contain  * an EFI label.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|pool_uses_efi
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|sun
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|read_efi_label
argument_list|(
name|config
argument_list|,
name|NULL
argument_list|)
operator|>=
literal|0
operator|)
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|pool_uses_efi
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* sun */
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an nvlist of zpool properties to be set, validate that they are  * correct, and parse any numeric properties (index, boolean, etc) if they are  * specified as strings.  */
end_comment

begin_function
specifier|static
name|nvlist_t
modifier|*
name|zpool_valid_proplist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|poolname
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|uint64_t
name|version
parameter_list|,
name|boolean_t
name|create_or_import
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|nvlist_t
modifier|*
name|retprops
decl_stmt|;
name|zpool_prop_t
name|prop
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
name|uint64_t
name|intval
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|;
name|struct
name|stat64
name|statbuf
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|retprops
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|props
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|nvpair_name
argument_list|(
name|elem
argument_list|)
decl_stmt|;
comment|/* 		 * Make sure this property is valid and applies to this type. 		 */
if|if
condition|(
operator|(
name|prop
operator|=
name|zpool_name_to_prop
argument_list|(
name|propname
argument_list|)
operator|)
operator|==
name|ZPROP_INVAL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid property '%s'"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|zpool_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' "
literal|"is readonly"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPREADONLY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|zprop_parse_value
argument_list|(
name|hdl
argument_list|,
name|elem
argument_list|,
name|prop
argument_list|,
name|ZFS_TYPE_POOL
argument_list|,
name|retprops
argument_list|,
operator|&
name|strval
argument_list|,
operator|&
name|intval
argument_list|,
name|errbuf
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* 		 * Perform additional checking for specific properties. 		 */
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZPOOL_PROP_VERSION
case|:
if|if
condition|(
name|intval
operator|<
name|version
operator|||
name|intval
operator|>
name|SPA_VERSION
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property '%s' number %d is invalid."
argument_list|)
argument_list|,
name|propname
argument_list|,
name|intval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|ZPOOL_PROP_BOOTFS
case|:
if|if
condition|(
name|create_or_import
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property '%s' cannot be set at creation "
literal|"or import time"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|version
operator|<
name|SPA_VERSION_BOOTFS
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgraded to support "
literal|"'%s' property"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 			 * bootfs property value has to be a dataset name and 			 * the dataset has to be in the same pool as it sets to. 			 */
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|bootfs_name_valid
argument_list|(
name|poolname
argument_list|,
name|strval
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' "
literal|"is an invalid name"
argument_list|)
argument_list|,
name|strval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|hdl
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"could not open pool '%s'"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_OPENFAILED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
comment|/* 			 * bootfs property cannot be set on a disk which has 			 * been EFI labeled. 			 */
if|if
condition|(
name|pool_uses_efi
argument_list|(
name|nvroot
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property '%s' not supported on "
literal|"EFI labeled devices"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOL_NOTSUP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
endif|#
directive|endif
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_ALTROOT
case|:
if|if
condition|(
operator|!
name|create_or_import
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property '%s' can only be set during pool "
literal|"creation or import"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bad alternate root '%s'"
argument_list|)
argument_list|,
name|strval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|ZPOOL_PROP_CACHEFILE
case|:
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property '%s' must be empty, an "
literal|"absolute path, or 'none'"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|slash
operator|=
name|strrchr
argument_list|(
name|strval
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|slash
argument_list|,
literal|"/."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|slash
argument_list|,
literal|"/.."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is not a valid file"
argument_list|)
argument_list|,
name|strval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|stat64
argument_list|(
name|strval
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is not a valid directory"
argument_list|)
argument_list|,
name|strval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|retprops
operator|)
return|;
name|error
label|:
name|nvlist_free
argument_list|(
name|retprops
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set zpool property : propname=propval.  */
end_comment

begin_function
name|int
name|zpool_set_prop
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|char
modifier|*
name|propval
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|realprops
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot set property for '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|no_memory
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|)
operator|)
return|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|nvl
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|no_memory
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|)
operator|)
return|;
block|}
name|version
operator|=
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|realprops
operator|=
name|zpool_valid_proplist
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
name|nvl
argument_list|,
name|version
argument_list|,
name|B_FALSE
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|nvl
operator|=
name|realprops
expr_stmt|;
comment|/* 	 * Execute the corresponding ioctl() to set this property. 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|ZFS_IOC_POOL_SET_PROPS
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|zpool_props_refresh
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zpool_expand_proplist
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|zprop_list_t
modifier|*
modifier|*
name|plp
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|zprop_list_t
modifier|*
name|entry
decl_stmt|;
name|char
name|buf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
if|if
condition|(
name|zprop_expand_list
argument_list|(
name|hdl
argument_list|,
name|plp
argument_list|,
name|ZFS_TYPE_POOL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|entry
operator|=
operator|*
name|plp
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|pl_fixed
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|pl_prop
operator|!=
name|ZPROP_INVAL
operator|&&
name|zpool_get_prop
argument_list|(
name|zhp
argument_list|,
name|entry
operator|->
name|pl_prop
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
name|entry
operator|->
name|pl_width
condition|)
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Validate the given pool name, optionally putting an extended error message in  * 'buf'.  */
end_comment

begin_function
name|boolean_t
name|zpool_name_valid
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|boolean_t
name|isopen
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|)
block|{
name|namecheck_err_t
name|why
decl_stmt|;
name|char
name|what
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|pool_namecheck
argument_list|(
name|pool
argument_list|,
operator|&
name|why
argument_list|,
operator|&
name|what
argument_list|)
expr_stmt|;
comment|/* 	 * The rules for reserved pool names were extended at a later point. 	 * But we need to support users with existing pools that may now be 	 * invalid.  So we only check for this expanded set of names during a 	 * create (or import), and only in userland. 	 */
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|!
name|isopen
operator|&&
operator|(
name|strncmp
argument_list|(
name|pool
argument_list|,
literal|"mirror"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|pool
argument_list|,
literal|"raidz"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|pool
argument_list|,
literal|"spare"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|pool
argument_list|,
literal|"log"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is reserved"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|NAME_ERR_TOOLONG
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is too long"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_INVALCHAR
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid character "
literal|"'%c' in pool name"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_NOLETTER
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name must begin with a letter"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_RESERVED
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is reserved"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_DISKLIKE
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool name is reserved"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_LEADING_SLASH
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"leading slash in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_EMPTY_COMPONENT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"empty component in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_TRAILING_SLASH
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"trailing slash in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_MULTIPLE_AT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"multiple '@' delimiters in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open a handle to the given pool, even if the pool is currently in the FAULTED  * state.  */
end_comment

begin_function
name|zpool_handle_t
modifier|*
name|zpool_open_canfail
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|boolean_t
name|missing
decl_stmt|;
comment|/* 	 * Make sure the pool name is valid. 	 */
if|if
condition|(
operator|!
name|zpool_name_valid
argument_list|(
name|hdl
argument_list|,
name|B_TRUE
argument_list|,
name|pool
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot open '%s'"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zpool_handle_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zhp
operator|->
name|zpool_hdl
operator|=
name|hdl
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zhp
operator|->
name|zpool_name
argument_list|,
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|zhp
operator|->
name|zpool_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_refresh_stats
argument_list|(
name|zhp
argument_list|,
operator|&
name|missing
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|missing
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such pool"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot open '%s'"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Like the above, but silent on error.  Used when iterating over pools (because  * the configuration cache may be out of date).  */
end_comment

begin_function
name|int
name|zpool_open_silent
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|zpool_handle_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|boolean_t
name|missing
decl_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zpool_handle_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zhp
operator|->
name|zpool_hdl
operator|=
name|hdl
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zhp
operator|->
name|zpool_name
argument_list|,
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|zhp
operator|->
name|zpool_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_refresh_stats
argument_list|(
name|zhp
argument_list|,
operator|&
name|missing
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|missing
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|ret
operator|=
name|zhp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Similar to zpool_open_canfail(), but refuses to open pools in the faulted  * state.  */
end_comment

begin_function
name|zpool_handle_t
modifier|*
name|zpool_open
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|hdl
argument_list|,
name|pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|zhp
operator|->
name|zpool_state
operator|==
name|POOL_STATE_UNAVAIL
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOLUNAVAIL
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot open '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the handle.  Simply frees the memory associated with the handle.  */
end_comment

begin_function
name|void
name|zpool_close
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
if|if
condition|(
name|zhp
operator|->
name|zpool_config
condition|)
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zpool_old_config
condition|)
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zpool_old_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zpool_props
condition|)
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zpool_props
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the name of the pool.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zpool_get_name
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zpool_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the state of the pool (ACTIVE or UNAVAILABLE)  */
end_comment

begin_function
name|int
name|zpool_get_state
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zpool_state
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the named pool, using the provided vdev list.  It is assumed  * that the consumer has already validated the contents of the nvlist, so we  * don't have to worry about error semantics.  */
end_comment

begin_function
name|int
name|zpool_create
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|nvlist_t
modifier|*
name|fsprops
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|nvlist_t
modifier|*
name|zc_fsprops
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|zc_props
init|=
name|NULL
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|altroot
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create '%s'"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zpool_name_valid
argument_list|(
name|hdl
argument_list|,
name|B_FALSE
argument_list|,
name|pool
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|zcmd_write_conf_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvroot
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|props
condition|)
block|{
if|if
condition|(
operator|(
name|zc_props
operator|=
name|zpool_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|pool
argument_list|,
name|props
argument_list|,
name|SPA_VERSION_1
argument_list|,
name|B_TRUE
argument_list|,
name|msg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|create_failed
goto|;
block|}
block|}
if|if
condition|(
name|fsprops
condition|)
block|{
name|uint64_t
name|zoned
decl_stmt|;
name|char
modifier|*
name|zonestr
decl_stmt|;
name|zoned
operator|=
operator|(
operator|(
name|nvlist_lookup_string
argument_list|(
name|fsprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_ZONED
argument_list|)
argument_list|,
operator|&
name|zonestr
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strcmp
argument_list|(
name|zonestr
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|zc_fsprops
operator|=
name|zfs_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|,
name|fsprops
argument_list|,
name|zoned
argument_list|,
name|NULL
argument_list|,
name|msg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|create_failed
goto|;
block|}
if|if
condition|(
operator|!
name|zc_props
operator|&&
operator|(
name|nvlist_alloc
argument_list|(
operator|&
name|zc_props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
goto|goto
name|create_failed
goto|;
block|}
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|zc_props
argument_list|,
name|ZPOOL_ROOTFS_PROPS
argument_list|,
name|zc_fsprops
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|create_failed
goto|;
block|}
block|}
if|if
condition|(
name|zc_props
operator|&&
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|zc_props
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|create_failed
goto|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_POOL_CREATE
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zc_props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zc_fsprops
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EBUSY
case|:
comment|/* 			 * This can happen if the user has specified the same 			 * device multiple times.  We can't reliably detect this 			 * until we try to add it and see we already have a 			 * label. 			 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more vdevs refer to the same device"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
operator|)
return|;
case|case
name|EOVERFLOW
case|:
comment|/* 			 * This occurs when one of the devices is below 			 * SPA_MINDEVSIZE.  Unfortunately, we can't detect which 			 * device was the problem device since there's no 			 * reliable way to determine device size from userland. 			 */
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|zfs_nicenum
argument_list|(
name|SPA_MINDEVSIZE
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more devices is less than the "
literal|"minimum size (%s)"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
operator|)
return|;
case|case
name|ENOSPC
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more devices is out of space"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
operator|)
return|;
case|case
name|ENOTBLK
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cache device must be a disk or disk slice"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* 	 * If this is an alternate root pool, then we automatically set the 	 * mountpoint of the root dataset to be '/'. 	 */
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_ALTROOT
argument_list|)
argument_list|,
operator|&
name|altroot
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|verify
argument_list|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|pool
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zfs_prop_set
argument_list|(
name|zhp
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_MOUNTPOINT
argument_list|)
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
name|create_failed
label|:
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zc_props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zc_fsprops
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy the given pool.  It is up to the caller to ensure that there are no  * datasets left in the pool.  */
end_comment

begin_function
name|int
name|zpool_destroy
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zfp
init|=
name|NULL
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zpool_state
operator|==
name|POOL_STATE_ACTIVE
operator|&&
operator|(
name|zfp
operator|=
name|zfs_open
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zpool_remove_zvol_links
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|ZFS_IOC_POOL_DESTROY
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot destroy '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EROFS
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more devices is read only"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zfp
condition|)
name|zfs_close
argument_list|(
name|zfp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zfp
condition|)
block|{
name|remove_mountpoint
argument_list|(
name|zfp
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zfp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the given vdevs to the pool.  The caller must have already performed the  * necessary verification to ensure that the vdev specification is well-formed.  */
end_comment

begin_function
name|int
name|zpool_add
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|,
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|,
name|nl2cache
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot add to '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|)
operator|<
name|SPA_VERSION_SPARES
operator|&&
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be "
literal|"upgraded to add hot spares"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|pool_is_bootable
argument_list|(
name|zhp
argument_list|)
operator|&&
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|nspares
condition|;
name|s
operator|++
control|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|spares
index|[
name|s
index|]
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
operator|&&
name|pool_uses_efi
argument_list|(
name|spares
index|[
name|s
index|]
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"device '%s' contains an EFI label and "
literal|"cannot be used on root pools."
argument_list|)
argument_list|,
name|zpool_vdev_name
argument_list|(
name|hdl
argument_list|,
name|NULL
argument_list|,
name|spares
index|[
name|s
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOL_NOTSUP
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|)
operator|<
name|SPA_VERSION_L2CACHE
operator|&&
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be "
literal|"upgraded to add cache devices"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zcmd_write_conf_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvroot
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|ZFS_IOC_VDEV_ADD
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EBUSY
case|:
comment|/* 			 * This can happen if the user has specified the same 			 * device multiple times.  We can't reliably detect this 			 * until we try to add it and see we already have a 			 * label. 			 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more vdevs refer to the same device"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOVERFLOW
case|:
comment|/* 			 * This occurrs when one of the devices is below 			 * SPA_MINDEVSIZE.  Unfortunately, we can't detect which 			 * device was the problem device since there's no 			 * reliable way to determine device size from userland. 			 */
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|zfs_nicenum
argument_list|(
name|SPA_MINDEVSIZE
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"device is less than the minimum "
literal|"size (%s)"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOTSUP
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgraded to add these vdevs"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EDOM
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"root pool can not have multiple vdevs"
literal|" or separate logs"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOL_NOTSUP
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOTBLK
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cache device must be a disk or disk slice"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Exports the pool from the system.  The caller must ensure that there are no  * mounted datasets in the pool.  */
end_comment

begin_function
name|int
name|zpool_export_common
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|boolean_t
name|hardforce
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|zpool_remove_zvol_links
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot export '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|force
expr_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
name|hardforce
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|ZFS_IOC_POOL_EXPORT
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EXDEV
case|:
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"use '-f' to override the following errors:\n"
literal|"'%s' has an active shared spare which could be"
literal|" used by other pools once '%s' is exported."
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|EZFS_ACTIVE_SPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zpool_standard_error_fmt
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zpool_export
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|boolean_t
name|force
parameter_list|)
block|{
return|return
operator|(
name|zpool_export_common
argument_list|(
name|zhp
argument_list|,
name|force
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zpool_export_force
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zpool_export_common
argument_list|(
name|zhp
argument_list|,
name|B_TRUE
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zpool_import() is a contracted interface. Should be kept the same  * if possible.  *  * Applications should use zpool_import_props() to import a pool with  * new properties value to be set.  */
end_comment

begin_function
name|int
name|zpool_import
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
name|char
modifier|*
name|altroot
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|altroot
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOMEM
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import '%s'"
argument_list|)
argument_list|,
name|newname
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_ALTROOT
argument_list|)
argument_list|,
name|altroot
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_string
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_CACHEFILE
argument_list|)
argument_list|,
literal|"none"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOMEM
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import '%s'"
argument_list|)
argument_list|,
name|newname
argument_list|)
operator|)
return|;
block|}
block|}
name|ret
operator|=
name|zpool_import_props
argument_list|(
name|hdl
argument_list|,
name|config
argument_list|,
name|newname
argument_list|,
name|props
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
condition|)
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Import the given pool using the known configuration and a list of  * properties to be set. The configuration should have come from  * zpool_find_import(). The 'newname' parameters control whether the pool  * is imported with a different name.  */
end_comment

begin_function
name|int
name|zpool_import_props
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|boolean_t
name|importfaulted
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|thename
decl_stmt|;
name|char
modifier|*
name|origname
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|origname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import pool '%s'"
argument_list|)
argument_list|,
name|origname
argument_list|)
expr_stmt|;
if|if
condition|(
name|newname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|zpool_name_valid
argument_list|(
name|hdl
argument_list|,
name|B_FALSE
argument_list|,
name|newname
argument_list|)
condition|)
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import '%s'"
argument_list|)
argument_list|,
name|newname
argument_list|)
operator|)
return|;
name|thename
operator|=
operator|(
name|char
operator|*
operator|)
name|newname
expr_stmt|;
block|}
else|else
block|{
name|thename
operator|=
name|origname
expr_stmt|;
block|}
if|if
condition|(
name|props
condition|)
block|{
name|uint64_t
name|version
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|props
operator|=
name|zpool_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|origname
argument_list|,
name|props
argument_list|,
name|version
argument_list|,
name|B_TRUE
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|props
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|thename
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_conf_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|config
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zc
operator|.
name|zc_cookie
operator|=
operator|(
name|uint64_t
operator|)
name|importfaulted
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_POOL_IMPORT
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|desc
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|newname
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import '%s'"
argument_list|)
argument_list|,
name|thename
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import '%s' as '%s'"
argument_list|)
argument_list|,
name|origname
argument_list|,
name|thename
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOTSUP
case|:
comment|/* 			 * Unsupported version. 			 */
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALCONFIG
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
comment|/* 		 * This should never fail, but play it safe anyway. 		 */
if|if
condition|(
name|zpool_open_silent
argument_list|(
name|hdl
argument_list|,
name|thename
argument_list|,
operator|&
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zhp
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|zpool_create_zvol_links
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scrub the pool.  */
end_comment

begin_function
name|int
name|zpool_scrub
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|pool_scrub_type_t
name|type
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|ZFS_IOC_POOL_SCRUB
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot scrub %s"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EBUSY
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_RESILVERING
argument_list|,
name|msg
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'avail_spare' is set to TRUE if the provided guid refers to an AVAIL  * spare; but FALSE if its an INUSE spare.  */
end_comment

begin_function
specifier|static
name|nvlist_t
modifier|*
name|vdev_to_nvlist_iter
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
specifier|const
name|char
modifier|*
name|search
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|boolean_t
modifier|*
name|avail_spare
parameter_list|,
name|boolean_t
modifier|*
name|l2cache
parameter_list|,
name|boolean_t
modifier|*
name|log
parameter_list|)
block|{
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint64_t
name|theguid
decl_stmt|,
name|present
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|uint64_t
name|wholedisk
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|ret
decl_stmt|;
name|uint64_t
name|is_log
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|theguid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|search
operator|==
name|NULL
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NOT_PRESENT
argument_list|,
operator|&
name|present
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If the device has never been present since import, the only 		 * reliable way to match the vdev is by GUID. 		 */
if|if
condition|(
name|theguid
operator|==
name|guid
condition|)
return|return
operator|(
name|nv
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|search
operator|!=
name|NULL
operator|&&
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_WHOLE_DISK
argument_list|,
operator|&
name|wholedisk
argument_list|)
expr_stmt|;
if|if
condition|(
name|wholedisk
condition|)
block|{
comment|/* 			 * For whole disks, the internal path has 's0', but the 			 * path passed in by the user doesn't. 			 */
if|if
condition|(
name|strlen
argument_list|(
name|search
argument_list|)
operator|==
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|2
operator|&&
name|strncmp
argument_list|(
name|search
argument_list|,
name|path
argument_list|,
name|strlen
argument_list|(
name|search
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|nv
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|search
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|nv
operator|)
return|;
block|}
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|vdev_to_nvlist_iter
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|search
argument_list|,
name|guid
argument_list|,
name|avail_spare
argument_list|,
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * The 'is_log' value is only set for the toplevel 			 * vdev, not the leaf vdevs.  So we always lookup the 			 * log device from the root of the vdev tree (where 			 * 'log' is non-NULL). 			 */
if|if
condition|(
name|log
operator|!=
name|NULL
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|is_log
argument_list|)
operator|==
literal|0
operator|&&
name|is_log
condition|)
block|{
operator|*
name|log
operator|=
name|B_TRUE
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|vdev_to_nvlist_iter
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|search
argument_list|,
name|guid
argument_list|,
name|avail_spare
argument_list|,
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|avail_spare
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|vdev_to_nvlist_iter
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|search
argument_list|,
name|guid
argument_list|,
name|avail_spare
argument_list|,
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|l2cache
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|zpool_find_vdev
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|boolean_t
modifier|*
name|avail_spare
parameter_list|,
name|boolean_t
modifier|*
name|l2cache
parameter_list|,
name|boolean_t
modifier|*
name|log
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|search
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|guid
operator|=
name|strtoull
argument_list|(
name|path
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid
operator|!=
literal|0
operator|&&
operator|*
name|end
operator|==
literal|'\0'
condition|)
block|{
name|search
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|search
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
name|search
operator|=
name|path
expr_stmt|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|avail_spare
operator|=
name|B_FALSE
expr_stmt|;
operator|*
name|l2cache
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|log
operator|!=
name|NULL
condition|)
operator|*
name|log
operator|=
name|B_FALSE
expr_stmt|;
return|return
operator|(
name|vdev_to_nvlist_iter
argument_list|(
name|nvroot
argument_list|,
name|search
argument_list|,
name|guid
argument_list|,
name|avail_spare
argument_list|,
name|l2cache
argument_list|,
name|log
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_online
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|uint64_t
name|ival
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_OFFLINE
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_FAULTED
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_REMOVED
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get phys_path for a root pool  * Return 0 on success; non-zeron on failure.  */
end_comment

begin_function
name|int
name|zpool_get_physpath
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
name|physpath
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|vdev_root
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Make sure this is a root pool, as phys_path doesn't mean 	 * anything to a non-root pool. 	 */
if|if
condition|(
operator|!
name|pool_is_bootable
argument_list|(
name|zhp
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|vdev_root
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|vdev_root
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child2
decl_stmt|;
name|uint_t
name|count2
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|tmppath
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|child
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|3
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_DISK
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|vdev_online
argument_list|(
name|child
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|8
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|child
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_PHYS_PATH
argument_list|,
operator|&
name|tmppath
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|physpath
argument_list|,
name|tmppath
argument_list|,
name|strlen
argument_list|(
name|tmppath
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_MIRROR
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|child
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child2
argument_list|,
operator|&
name|count2
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|4
operator|)
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|vdev_online
argument_list|(
name|child2
index|[
name|j
index|]
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|8
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|child2
index|[
name|j
index|]
argument_list|,
name|ZPOOL_CONFIG_PHYS_PATH
argument_list|,
operator|&
name|tmppath
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|5
operator|)
return|;
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|physpath
argument_list|)
operator|+
name|strlen
argument_list|(
name|tmppath
argument_list|)
operator|)
operator|>
name|MAXNAMELEN
condition|)
return|return
operator|(
operator|-
literal|6
operator|)
return|;
if|if
condition|(
name|strlen
argument_list|(
name|physpath
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|physpath
argument_list|,
name|tmppath
argument_list|,
name|strlen
argument_list|(
name|tmppath
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|physpath
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|physpath
argument_list|,
name|tmppath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|7
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns TRUE if the given guid corresponds to the given type.  * This is used to check for hot spares (INUSE or not), and level 2 cache  * devices.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|is_guid_type
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|uint64_t
name|target_guid
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|list
decl_stmt|;
name|uint_t
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|type
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|list
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|target_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid
operator|==
name|target_guid
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bring the specified vdev online.   The 'flags' parameter is a set of the  * ZFS_ONLINE_* flags.  */
end_comment

begin_function
name|int
name|zpool_vdev_online
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|vdev_state_t
modifier|*
name|newstate
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|,
name|l2cache
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot online %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail_spare
operator|||
name|is_guid_type
argument_list|(
name|zhp
argument_list|,
name|zc
operator|.
name|zc_guid
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|)
operator|==
name|B_TRUE
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|zc
operator|.
name|zc_cookie
operator|=
name|VDEV_STATE_ONLINE
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|ZFS_IOC_VDEV_SET_STATE
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
operator|*
name|newstate
operator|=
name|zc
operator|.
name|zc_cookie
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take the specified vdev offline  */
end_comment

begin_function
name|int
name|zpool_vdev_offline
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|boolean_t
name|istmp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|,
name|l2cache
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot offline %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail_spare
operator|||
name|is_guid_type
argument_list|(
name|zhp
argument_list|,
name|zc
operator|.
name|zc_guid
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|)
operator|==
name|B_TRUE
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|zc
operator|.
name|zc_cookie
operator|=
name|VDEV_STATE_OFFLINE
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|istmp
condition|?
name|ZFS_OFFLINE_TEMPORARY
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|ZFS_IOC_VDEV_SET_STATE
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EBUSY
case|:
comment|/* 		 * There are no other replicas of this device. 		 */
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOREPLICAS
argument_list|,
name|msg
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Mark the given vdev faulted.  */
end_comment

begin_function
name|int
name|zpool_vdev_fault
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot fault %llu"
argument_list|)
argument_list|,
name|guid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
name|guid
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|VDEV_STATE_FAULTED
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_VDEV_SET_STATE
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EBUSY
case|:
comment|/* 		 * There are no other replicas of this device. 		 */
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOREPLICAS
argument_list|,
name|msg
argument_list|)
operator|)
return|;
case|case
name|EEXIST
case|:
comment|/* 		 * The log device has unplayed logs 		 */
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_UNPLAYED_LOGS
argument_list|,
name|msg
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Mark the given vdev degraded.  */
end_comment

begin_function
name|int
name|zpool_vdev_degrade
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot degrade %llu"
argument_list|)
argument_list|,
name|guid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
name|guid
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|VDEV_STATE_DEGRADED
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_VDEV_SET_STATE
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns TRUE if the given nvlist is a vdev that was originally swapped in as  * a hot spare.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|is_replacing_spare
parameter_list|(
name|nvlist_t
modifier|*
name|search
parameter_list|,
name|nvlist_t
modifier|*
name|tgt
parameter_list|,
name|int
name|which
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|search
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|search
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_SPARE
argument_list|)
operator|==
literal|0
operator|&&
name|children
operator|==
literal|2
operator|&&
name|child
index|[
name|which
index|]
operator|==
name|tgt
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|is_replacing_spare
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|tgt
argument_list|,
name|which
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach new_disk (fully described by nvroot) to old_disk.  * If 'replacing' is specified, the new disk will replace the old one.  */
end_comment

begin_function
name|int
name|zpool_vdev_attach
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|old_disk
parameter_list|,
specifier|const
name|char
modifier|*
name|new_disk
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|int
name|replacing
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|,
name|l2cache
decl_stmt|,
name|islog
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|newname
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|children
decl_stmt|;
name|nvlist_t
modifier|*
name|config_root
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|boolean_t
name|rootpool
init|=
name|pool_is_bootable
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
if|if
condition|(
name|replacing
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot replace %s with %s"
argument_list|)
argument_list|,
name|old_disk
argument_list|,
name|new_disk
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot attach %s to %s"
argument_list|)
argument_list|,
name|new_disk
argument_list|,
name|old_disk
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a root pool, make sure that we're not attaching an 	 * EFI labeled device. 	 */
if|if
condition|(
name|rootpool
operator|&&
name|pool_uses_efi
argument_list|(
name|nvroot
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"EFI labeled devices are not supported on root pools."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOL_NOTSUP
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|old_disk
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|islog
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|avail_spare
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|l2cache
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISL2CACHE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|replacing
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
operator|||
name|children
operator|!=
literal|1
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"new device must be a single disk"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALCONFIG
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|config_root
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newname
operator|=
name|zpool_vdev_name
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|child
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * If the target is a hot spare that has been swapped in, we can only 	 * replace it with another hot spare. 	 */
if|if
condition|(
name|replacing
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_IS_SPARE
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|newname
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|avail_spare
operator|)
operator|&&
name|is_replacing_spare
argument_list|(
name|config_root
argument_list|,
name|tgt
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"can only be replaced by another hot spare"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTARGET
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If we are attempting to replace a spare, it canot be applied to an 	 * already spared device. 	 */
if|if
condition|(
name|replacing
operator|&&
name|nvlist_lookup_string
argument_list|(
name|child
index|[
literal|0
index|]
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
operator|&&
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|newname
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
operator|&&
name|avail_spare
operator|&&
name|is_replacing_spare
argument_list|(
name|config_root
argument_list|,
name|tgt
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"device has already been replaced with a spare"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTARGET
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_conf_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvroot
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|ZFS_IOC_VDEV_ATTACH
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|rootpool
condition|)
block|{
comment|/* 			 * XXX - This should be removed once we can 			 * automatically install the bootblocks on the 			 * newly attached disk. 			 */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Please "
literal|"be sure to invoke %s to make '%s' bootable.\n"
argument_list|)
argument_list|,
name|BOOTCMD
argument_list|,
name|new_disk
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* sun */
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOTSUP
case|:
comment|/* 		 * Can't attach to or replace this type of vdev. 		 */
if|if
condition|(
name|replacing
condition|)
block|{
if|if
condition|(
name|islog
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot replace a log with a spare"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot replace a replacing device"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"can only attach to mirrors and top-level "
literal|"disks"
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTARGET
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
comment|/* 		 * The new device must be a single disk. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"new device must be a single disk"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALCONFIG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBUSY
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"%s is busy"
argument_list|)
argument_list|,
name|new_disk
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOVERFLOW
case|:
comment|/* 		 * The new device is too small. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"device is too small"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EDOM
case|:
comment|/* 		 * The new device has a different alignment requirement. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"devices have different sector alignment"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENAMETOOLONG
case|:
comment|/* 		 * The resulting top-level vdev spec won't fit in the label. 		 */
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_DEVOVERFLOW
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach the specified device.  */
end_comment

begin_function
name|int
name|zpool_vdev_detach
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|,
name|l2cache
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot detach %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|avail_spare
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|l2cache
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISL2CACHE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_VDEV_DETACH
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOTSUP
case|:
comment|/* 		 * Can't detach from this type of vdev. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"only "
literal|"applicable to mirror and replacing vdevs"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|EZFS_BADTARGET
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBUSY
case|:
comment|/* 		 * There are no other replicas of this device. 		 */
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOREPLICAS
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the given device.  Currently, this is supported only for hot spares  * and level 2 cache devices.  */
end_comment

begin_function
name|int
name|zpool_vdev_remove
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|,
name|l2cache
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot remove %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|avail_spare
operator|&&
operator|!
name|l2cache
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"only inactive hot spares or cache devices "
literal|"can be removed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_VDEV_REMOVE
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the errors for the pool, or the particular device if specified.  */
end_comment

begin_function
name|int
name|zpool_clear
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|,
name|l2cache
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
if|if
condition|(
name|path
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot clear errors for %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot clear errors for %s"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
block|{
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|,
operator|&
name|l2cache
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
comment|/* 		 * Don't allow error clearing for hot spares.  Do allow 		 * error clearing for l2cache devices. 		 */
if|if
condition|(
name|avail_spare
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_CLEAR
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Similar to zpool_clear(), but takes a GUID (used by fmd).  */
end_comment

begin_function
name|int
name|zpool_vdev_clear
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot clear errors for %llx"
argument_list|)
argument_list|,
name|guid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
name|guid
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_CLEAR
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all zvols in a given pool by walking the /dev/zvol/dsk/<pool>  * hierarchy.  */
end_comment

begin_function
name|int
name|zpool_iter_zvol
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|int
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|char
argument_list|(
operator|*
name|paths
argument_list|)
index|[
name|MAXPATHLEN
index|]
expr_stmt|;
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|size_t
name|size
init|=
literal|4
decl_stmt|;
name|int
name|curr
decl_stmt|,
name|fd
decl_stmt|,
name|base
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|(
name|base
operator|=
name|open
argument_list|(
name|ZVOL_FULL_DEV_DIR
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|errno
operator|==
name|ENOENT
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|ZVOL_FULL_DEV_DIR
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|err
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|==
name|ENOENT
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Oddly this wasn't a directory -- ignore that failure since we 	 * know there are no links lower in the (non-existant) hierarchy. 	 */
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|paths
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|paths
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|paths
index|[
literal|0
index|]
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|paths
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|curr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|curr
operator|>=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|ZVOL_FULL_DEV_DIR
argument_list|,
name|paths
index|[
name|curr
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|err
goto|;
block|}
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
continue|continue;
if|if
condition|(
name|curr
operator|+
literal|1
operator|==
name|size
condition|)
block|{
name|paths
operator|=
name|zfs_realloc
argument_list|(
name|hdl
argument_list|,
name|paths
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|paths
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|size
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|paths
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|paths
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|size
operator|*=
literal|2
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|paths
index|[
name|curr
operator|+
literal|1
index|]
argument_list|,
name|paths
index|[
name|curr
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|paths
index|[
name|curr
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|paths
index|[
name|curr
index|]
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
argument_list|(
name|paths
index|[
name|curr
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|paths
index|[
name|curr
index|]
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
sizeof|sizeof
argument_list|(
name|paths
index|[
name|curr
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|curr
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|cb
argument_list|(
name|paths
index|[
name|curr
index|]
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|curr
operator|--
expr_stmt|;
block|}
name|free
argument_list|(
name|paths
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
name|err
label|:
name|free
argument_list|(
name|paths
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|zvol_cb
block|{
name|zpool_handle_t
modifier|*
name|zcb_pool
decl_stmt|;
name|boolean_t
name|zcb_create
decl_stmt|;
block|}
name|zvol_cb_t
typedef|;
end_typedef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|do_zvol_create
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_create_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_iter_snapshots
argument_list|(
name|zhp
argument_list|,
name|do_zvol_create
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|ret
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|do_zvol_create
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all zvols in the pool and make any necessary minor nodes.  */
end_comment

begin_function
name|int
name|zpool_create_zvol_links
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zfp
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * If the pool is unavailable, just return success. 	 */
if|if
condition|(
operator|(
name|zfp
operator|=
name|make_dataset_handle
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ret
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zfp
argument_list|,
name|do_zvol_create
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_zvol_remove
parameter_list|(
specifier|const
name|char
modifier|*
name|dataset
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
init|=
name|data
decl_stmt|;
return|return
operator|(
name|zvol_remove_link
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|dataset
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all zvols in the pool and remove any minor nodes.  We iterate  * by examining the /dev links so that a corrupted pool doesn't impede this  * operation.  */
end_comment

begin_function
name|int
name|zpool_remove_zvol_links
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zpool_iter_zvol
argument_list|(
name|zhp
argument_list|,
name|do_zvol_remove
argument_list|,
name|zhp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from a devid string to a path.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|devid_to_path
parameter_list|(
name|char
modifier|*
name|devid_str
parameter_list|)
block|{
name|ddi_devid_t
name|devid
decl_stmt|;
name|char
modifier|*
name|minor
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|devid_nmlist_t
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|devid_str_decode
argument_list|(
name|devid_str
argument_list|,
operator|&
name|devid
argument_list|,
operator|&
name|minor
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ret
operator|=
name|devid_deviceid_to_nmlist
argument_list|(
literal|"/dev"
argument_list|,
name|devid
argument_list|,
name|minor
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|devid_str_free
argument_list|(
name|minor
argument_list|)
expr_stmt|;
name|devid_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|path
operator|=
name|strdup
argument_list|(
name|list
index|[
literal|0
index|]
operator|.
name|devname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|devid_free_nmlist
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|path
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from a path to a devid string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|path_to_devid
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|ddi_devid_t
name|devid
decl_stmt|;
name|char
modifier|*
name|minor
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|minor
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|devid_get
argument_list|(
name|fd
argument_list|,
operator|&
name|devid
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|devid_get_minor_name
argument_list|(
name|fd
argument_list|,
operator|&
name|minor
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|devid_str_encode
argument_list|(
name|devid
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|minor
operator|!=
name|NULL
condition|)
name|devid_str_free
argument_list|(
name|minor
argument_list|)
expr_stmt|;
name|devid_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Issue the necessary ioctl() to update the stored path value for the vdev.  We  * ignore any failure here, since a common case is for an unprivileged user to  * type 'zpool status', and we'll display the correct information anyway.  */
end_comment

begin_function
specifier|static
name|void
name|set_path
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_VDEV_SETPATH
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a vdev, return the name to display in iostat.  If the vdev has a path,  * we use that, stripping off any leading "/dev/dsk/"; if not, we use the type.  * We also check if this is a whole disk, in which case we strip off the  * trailing 's0' slice name.  *  * This routine is also responsible for identifying when disks have been  * reconfigured in a new location.  The kernel will have opened the device by  * devid, but the path will still refer to the old location.  To catch this, we  * first do a path -> devid translation (which is fast for the common case).  If  * the devid matches, we're done.  If not, we do a reverse devid -> path  * translation and issue the appropriate ioctl() to update the path of the vdev.  * If 'zhp' is NULL, then this is an exported pool, and we don't need to do any  * of these checks.  */
end_comment

begin_function
name|char
modifier|*
name|zpool_vdev_name
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|devid
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NOT_PRESENT
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|value
argument_list|)
expr_stmt|;
name|path
operator|=
name|buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If the device is dead (faulted, offline, etc) then don't 		 * bother opening it.  Otherwise we may be forcing the user to 		 * open a misbehaving device, which can have undesirable 		 * effects. 		 */
if|if
condition|(
operator|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|!=
literal|0
operator|||
name|vs
operator|->
name|vs_state
operator|>=
name|VDEV_STATE_DEGRADED
operator|)
operator|&&
name|zhp
operator|!=
name|NULL
operator|&&
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DEVID
argument_list|,
operator|&
name|devid
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Determine if the current path is correct. 			 */
name|char
modifier|*
name|newdevid
init|=
name|path_to_devid
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|newdevid
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|devid
argument_list|,
name|newdevid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|newpath
decl_stmt|;
if|if
condition|(
operator|(
name|newpath
operator|=
name|devid_to_path
argument_list|(
name|devid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * Update the path appropriately. 					 */
name|set_path
argument_list|(
name|zhp
argument_list|,
name|nv
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
name|newpath
argument_list|)
operator|==
literal|0
condition|)
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newdevid
condition|)
name|devid_str_free
argument_list|(
name|newdevid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|path
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
argument_list|(
name|_PATH_DEV
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|path
operator|+=
sizeof|sizeof
argument_list|(
name|_PATH_DEV
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_WHOLE_DISK
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
operator|&&
name|value
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|tmp
index|[
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
block|}
block|}
else|else
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If it's a raidz device, we need to stick in the parity level. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|path
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NPARITY
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%llu"
argument_list|,
name|path
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|value
argument_list|)
expr_stmt|;
name|path
operator|=
name|buf
expr_stmt|;
block|}
block|}
return|return
operator|(
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zbookmark_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|memcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the persistent error log, uniquify the members, and return to the  * caller.  */
end_comment

begin_function
name|int
name|zpool_get_errlog
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nverrlistp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint64_t
name|count
decl_stmt|;
name|zbookmark_t
modifier|*
name|zb
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Retrieve the raw error list from the kernel.  If the number of errors 	 * has increased, allocate more space and continue until we get the 	 * entire list. 	 */
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_ERRCOUNT
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|zc
operator|.
name|zc_nvlist_dst
operator|=
operator|(
name|uintptr_t
operator|)
name|zfs_alloc
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|uintptr_t
operator|)
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zc
operator|.
name|zc_nvlist_dst_size
operator|=
name|count
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_ERROR_LOG
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|count
operator|=
name|zc
operator|.
name|zc_nvlist_dst_size
expr_stmt|;
if|if
condition|(
operator|(
name|zc
operator|.
name|zc_nvlist_dst
operator|=
operator|(
name|uintptr_t
operator|)
name|zfs_alloc
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|uintptr_t
operator|)
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
comment|/* 	 * Sort the resulting bookmarks.  This is a little confusing due to the 	 * implementation of ZFS_IOC_ERROR_LOG.  The bookmarks are copied last 	 * to first, and 'zc_nvlist_dst_size' indicates the number of boomarks 	 * _not_ copied as part of the process.  So we point the start of our 	 * array appropriate and decrement the total number of elements. 	 */
name|zb
operator|=
operator|(
operator|(
name|zbookmark_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
operator|)
operator|+
name|zc
operator|.
name|zc_nvlist_dst_size
expr_stmt|;
name|count
operator|-=
name|zc
operator|.
name|zc_nvlist_dst_size
expr_stmt|;
name|qsort
argument_list|(
name|zb
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|,
name|zbookmark_compare
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_alloc
argument_list|(
name|nverrlistp
argument_list|,
literal|0
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the nverrlistp with nvlist's of dataset and object numbers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
comment|/* ignoring zb_blkid and zb_level for now */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|zb
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|zb_objset
operator|==
name|zb
index|[
name|i
index|]
operator|.
name|zb_objset
operator|&&
name|zb
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|zb_object
operator|==
name|zb
index|[
name|i
index|]
operator|.
name|zb_object
condition|)
continue|continue;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_ERR_DATASET
argument_list|,
name|zb
index|[
name|i
index|]
operator|.
name|zb_objset
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_ERR_OBJECT
argument_list|,
name|zb
index|[
name|i
index|]
operator|.
name|zb_object
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
operator|*
name|nverrlistp
argument_list|,
literal|"ejk"
argument_list|,
name|nv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nomem
label|:
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
return|return
operator|(
name|no_memory
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Upgrade a ZFS pool to the latest on-disk version.  */
end_comment

begin_function
name|int
name|zpool_upgrade
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|new_version
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|new_version
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_POOL_UPGRADE
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|zpool_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot upgrade '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zpool_set_history_str
parameter_list|(
specifier|const
name|char
modifier|*
name|subcommand
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|history_str
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|history_str
argument_list|,
name|subcommand
argument_list|,
name|HIS_MAX_RECORD_LEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|history_str
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|>
name|HIS_MAX_RECORD_LEN
condition|)
break|break;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|history_str
argument_list|,
literal|" "
argument_list|,
name|HIS_MAX_RECORD_LEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|history_str
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|HIS_MAX_RECORD_LEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Stage command history for logging.  */
end_comment

begin_function
name|int
name|zpool_stage_history
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|history_str
parameter_list|)
block|{
if|if
condition|(
name|history_str
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|strlen
argument_list|(
name|history_str
argument_list|)
operator|>
name|HIS_MAX_RECORD_LEN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|hdl
operator|->
name|libzfs_log_str
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hdl
operator|->
name|libzfs_log_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdl
operator|->
name|libzfs_log_str
operator|=
name|strdup
argument_list|(
name|history_str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|no_memory
argument_list|(
name|hdl
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform ioctl to get some command history of a pool.  *  * 'buf' is the buffer to fill up to 'len' bytes.  'off' is the  * logical offset of the history buffer to start reading from.  *  * Upon return, 'off' is the next logical offset to read from and  * 'len' is the actual amount of bytes read into 'buf'.  */
end_comment

begin_function
specifier|static
name|int
name|get_history
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|uint64_t
modifier|*
name|off
parameter_list|,
name|uint64_t
modifier|*
name|len
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_history
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|zc
operator|.
name|zc_history_len
operator|=
operator|*
name|len
expr_stmt|;
name|zc
operator|.
name|zc_history_offset
operator|=
operator|*
name|off
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_GET_HISTORY
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EPERM
case|:
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_PERM
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot show history for pool '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
case|case
name|ENOENT
case|:
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOHISTORY
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get history for pool "
literal|"'%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
case|case
name|ENOTSUP
case|:
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get history for pool "
literal|"'%s', pool must be upgraded"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zpool_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get history for '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
block|}
block|}
operator|*
name|len
operator|=
name|zc
operator|.
name|zc_history_len
expr_stmt|;
operator|*
name|off
operator|=
name|zc
operator|.
name|zc_history_offset
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process the buffer of nvlists, unpacking and storing each nvlist record  * into 'records'.  'leftover' is set to the number of bytes that weren't  * processed as there wasn't a complete record.  */
end_comment

begin_function
specifier|static
name|int
name|zpool_history_unpack
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|bytes_read
parameter_list|,
name|uint64_t
modifier|*
name|leftover
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
modifier|*
name|records
parameter_list|,
name|uint_t
modifier|*
name|numrecords
parameter_list|)
block|{
name|uint64_t
name|reclen
decl_stmt|;
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|bytes_read
operator|>
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
condition|)
block|{
comment|/* get length of packed record (stored as little endian) */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|reclen
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
condition|;
name|i
operator|++
control|)
name|reclen
operator|+=
call|(
name|uint64_t
call|)
argument_list|(
operator|(
operator|(
name|uchar_t
operator|*
operator|)
name|buf
operator|)
index|[
name|i
index|]
argument_list|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
operator|+
name|reclen
condition|)
break|break;
comment|/* unpack record */
if|if
condition|(
name|nvlist_unpack
argument_list|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
argument_list|,
name|reclen
argument_list|,
operator|&
name|nv
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bytes_read
operator|-=
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
operator|+
name|reclen
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
operator|+
name|reclen
expr_stmt|;
comment|/* add record to nvlist array */
operator|(
operator|*
name|numrecords
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|ISP2
argument_list|(
operator|*
name|numrecords
operator|+
literal|1
argument_list|)
condition|)
block|{
operator|*
name|records
operator|=
name|realloc
argument_list|(
operator|*
name|records
argument_list|,
operator|*
name|numrecords
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|records
operator|)
index|[
operator|*
name|numrecords
operator|-
literal|1
index|]
operator|=
name|nv
expr_stmt|;
block|}
operator|*
name|leftover
operator|=
name|bytes_read
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HIS_BUF_LEN
value|(128*1024)
end_define

begin_comment
comment|/*  * Retrieve the command history of a pool.  */
end_comment

begin_function
name|int
name|zpool_get_history
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvhisp
parameter_list|)
block|{
name|char
name|buf
index|[
name|HIS_BUF_LEN
index|]
decl_stmt|;
name|uint64_t
name|off
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|records
init|=
name|NULL
decl_stmt|;
name|uint_t
name|numrecords
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|;
do|do
block|{
name|uint64_t
name|bytes_read
init|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|uint64_t
name|leftover
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|get_history
argument_list|(
name|zhp
argument_list|,
name|buf
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|bytes_read
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* if nothing else was read in, we're at EOF, just return */
if|if
condition|(
operator|!
name|bytes_read
condition|)
break|break;
if|if
condition|(
operator|(
name|err
operator|=
name|zpool_history_unpack
argument_list|(
name|buf
argument_list|,
name|bytes_read
argument_list|,
operator|&
name|leftover
argument_list|,
operator|&
name|records
argument_list|,
operator|&
name|numrecords
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|off
operator|-=
name|leftover
expr_stmt|;
comment|/* CONSTCOND */
block|}
do|while
condition|(
literal|1
condition|)
do|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|verify
argument_list|(
name|nvlist_alloc
argument_list|(
name|nvhisp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
operator|*
name|nvhisp
argument_list|,
name|ZPOOL_HIST_RECORD
argument_list|,
name|records
argument_list|,
name|numrecords
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numrecords
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|records
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|records
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zpool_obj_to_path
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|char
modifier|*
name|pathname
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|boolean_t
name|mounted
init|=
name|B_FALSE
decl_stmt|;
name|char
modifier|*
name|mntpnt
init|=
name|NULL
decl_stmt|;
name|char
name|dsname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|dsobj
operator|==
literal|0
condition|)
block|{
comment|/* special case for the MOS */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"<metadata>:<0x%llx>"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get the dataset's name */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|dsobj
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_DSOBJ_TO_DSNAME
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* just write out a path of two object numbers */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"<0x%llx>:<0x%llx>"
argument_list|,
name|dsobj
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dsname
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
sizeof|sizeof
argument_list|(
name|dsname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* find out if the dataset is mounted */
name|mounted
operator|=
name|is_mounted
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|dsname
argument_list|,
operator|&
name|mntpnt
argument_list|)
expr_stmt|;
comment|/* get the corrupted object's path */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dsname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|obj
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJ_TO_PATH
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mounted
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"%s%s"
argument_list|,
name|mntpnt
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"%s:%s"
argument_list|,
name|dsname
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"%s:<0x%llx>"
argument_list|,
name|dsname
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mntpnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|RDISK_ROOT
value|"/dev/rdsk"
end_define

begin_define
define|#
directive|define
name|BACKUP_SLICE
value|"s2"
end_define

begin_comment
comment|/*  * Don't start the slice at the default block of 34; many storage  * devices will use a stripe width of 128k, so start there instead.  */
end_comment

begin_define
define|#
directive|define
name|NEW_START_BLOCK
value|256
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_comment
comment|/*  * Read the EFI label from the config, if a label does not exist then  * pass back the error to the caller. If the caller has passed a non-NULL  * diskaddr argument then we set it to the starting address of the EFI  * partition.  */
end_comment

begin_function
specifier|static
name|int
name|read_efi_label
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|diskaddr_t
modifier|*
name|sb
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|diskname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|err
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|diskname
argument_list|,
sizeof|sizeof
argument_list|(
name|diskname
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|RDISK_ROOT
argument_list|,
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|diskname
argument_list|,
name|O_RDONLY
operator||
name|O_NDELAY
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|struct
name|dk_gpt
modifier|*
name|vtoc
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|efi_alloc_and_read
argument_list|(
name|fd
argument_list|,
operator|&
name|vtoc
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
operator|*
name|sb
operator|=
name|vtoc
operator|->
name|efi_parts
index|[
literal|0
index|]
operator|.
name|p_start
expr_stmt|;
name|efi_free
argument_list|(
name|vtoc
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * determine where a partition starts on a disk in the current  * configuration  */
end_comment

begin_function
specifier|static
name|diskaddr_t
name|find_start_block
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|diskaddr_t
name|sb
init|=
name|MAXOFFSET_T
decl_stmt|;
name|uint64_t
name|wholedisk
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_WHOLE_DISK
argument_list|,
operator|&
name|wholedisk
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|wholedisk
condition|)
block|{
return|return
operator|(
name|MAXOFFSET_T
operator|)
return|;
block|}
if|if
condition|(
name|read_efi_label
argument_list|(
name|config
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|sb
operator|=
name|MAXOFFSET_T
expr_stmt|;
return|return
operator|(
name|sb
operator|)
return|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|sb
operator|=
name|find_start_block
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|MAXOFFSET_T
condition|)
block|{
return|return
operator|(
name|sb
operator|)
return|;
block|}
block|}
return|return
operator|(
name|MAXOFFSET_T
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sun */
end_comment

begin_comment
comment|/*  * Label an individual disk.  The name provided is the short name,  * stripped of any leading /dev path.  */
end_comment

begin_function
name|int
name|zpool_label_disk
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|dk_gpt
modifier|*
name|vtoc
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|size_t
name|resv
init|=
name|EFI_MIN_RESV_SIZE
decl_stmt|;
name|uint64_t
name|slice_size
decl_stmt|;
name|diskaddr_t
name|start_block
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
comment|/* prepare an error message just in case */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot label '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
condition|)
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
if|if
condition|(
name|pool_is_bootable
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"EFI labeled devices are not supported on root "
literal|"pools."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOL_NOTSUP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zpool_start_block
operator|==
literal|0
condition|)
name|start_block
operator|=
name|find_start_block
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
else|else
name|start_block
operator|=
name|zhp
operator|->
name|zpool_start_block
expr_stmt|;
name|zhp
operator|->
name|zpool_start_block
operator|=
name|start_block
expr_stmt|;
block|}
else|else
block|{
comment|/* new pool */
name|start_block
operator|=
name|NEW_START_BLOCK
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|RDISK_ROOT
argument_list|,
name|name
argument_list|,
name|BACKUP_SLICE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * This shouldn't happen.  We've long since verified that this 		 * is a valid device. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unable to open device"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_OPENFAILED
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|efi_alloc_and_init
argument_list|(
name|fd
argument_list|,
name|EFI_NUMPAR
argument_list|,
operator|&
name|vtoc
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The only way this can fail is if we run out of memory, or we 		 * were unable to read the disk's capacity 		 */
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unable to read disk capacity"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOCAP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|slice_size
operator|=
name|vtoc
operator|->
name|efi_last_u_lba
operator|+
literal|1
expr_stmt|;
name|slice_size
operator|-=
name|EFI_MIN_RESV_SIZE
expr_stmt|;
if|if
condition|(
name|start_block
operator|==
name|MAXOFFSET_T
condition|)
name|start_block
operator|=
name|NEW_START_BLOCK
expr_stmt|;
name|slice_size
operator|-=
name|start_block
expr_stmt|;
name|vtoc
operator|->
name|efi_parts
index|[
literal|0
index|]
operator|.
name|p_start
operator|=
name|start_block
expr_stmt|;
name|vtoc
operator|->
name|efi_parts
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
name|slice_size
expr_stmt|;
comment|/* 	 * Why we use V_USR: V_BACKUP confuses users, and is considered 	 * disposable by some EFI utilities (since EFI doesn't have a backup 	 * slice).  V_UNASSIGNED is supposed to be used only for zero size 	 * partitions, and efi_write() will fail if we use it.  V_ROOT, V_BOOT, 	 * etc. were all pretty specific.  V_USR is as close to reality as we 	 * can get, in the absence of V_OTHER. 	 */
name|vtoc
operator|->
name|efi_parts
index|[
literal|0
index|]
operator|.
name|p_tag
operator|=
name|V_USR
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|vtoc
operator|->
name|efi_parts
index|[
literal|0
index|]
operator|.
name|p_name
argument_list|,
literal|"zfs"
argument_list|)
expr_stmt|;
name|vtoc
operator|->
name|efi_parts
index|[
literal|8
index|]
operator|.
name|p_start
operator|=
name|slice_size
operator|+
name|start_block
expr_stmt|;
name|vtoc
operator|->
name|efi_parts
index|[
literal|8
index|]
operator|.
name|p_size
operator|=
name|resv
expr_stmt|;
name|vtoc
operator|->
name|efi_parts
index|[
literal|8
index|]
operator|.
name|p_tag
operator|=
name|V_RESERVED
expr_stmt|;
if|if
condition|(
name|efi_write
argument_list|(
name|fd
argument_list|,
name|vtoc
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Some block drivers (like pcata) may not support EFI 		 * GPT labels.  Print out a helpful error message dir- 		 * ecting the user to manually label the disk and give 		 * a specific slice. 		 */
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|efi_free
argument_list|(
name|vtoc
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"try using fdisk(1M) and then provide a specific slice"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_LABELFAILED
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|efi_free
argument_list|(
name|vtoc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sun */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|supported_dump_vdev_type
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|char
modifier|*
name|type
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|children
decl_stmt|,
name|c
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_FILE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_LOG
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_MISSING
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"vdev type '%s' is not supported"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_VDEVNOTSUP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|supported_dump_vdev_type
argument_list|(
name|hdl
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|errbuf
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * check if this zvol is allowable for use as a dump device; zero if  * it is,> 0 if it isn't,< 0 if it isn't a zvol  */
end_comment

begin_function
name|int
name|zvol_check_dump_config
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|volname
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|top
decl_stmt|;
name|uint_t
name|toplevels
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|poolname
index|[
name|ZPOOL_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|pathlen
init|=
name|strlen
argument_list|(
name|ZVOL_FULL_DEV_DIR
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
name|ZVOL_FULL_DEV_DIR
argument_list|,
name|pathlen
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dump is not supported on device '%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdl
operator|=
name|libzfs_init
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|libzfs_print_on_error
argument_list|(
name|hdl
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|volname
operator|=
name|arg
operator|+
name|pathlen
expr_stmt|;
comment|/* check the configuration of the pool */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|volname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"malformed dataset name"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|-
name|volname
operator|>=
name|ZFS_MAXNAMELEN
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset name is too long"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NAMETOOLONG
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|poolname
argument_list|,
name|volname
argument_list|,
name|p
operator|-
name|volname
argument_list|)
expr_stmt|;
name|poolname
index|[
name|p
operator|-
name|volname
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open
argument_list|(
name|hdl
argument_list|,
name|poolname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"could not open pool '%s'"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_OPENFAILED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"could not obtain vdev configuration for  '%s'"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALCONFIG
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|toplevels
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|toplevels
operator|!=
literal|1
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' has multiple top level vdevs"
argument_list|)
argument_list|,
name|poolname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_DEVOVERFLOW
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|supported_dump_vdev_type
argument_list|(
name|hdl
argument_list|,
name|top
index|[
literal|0
index|]
argument_list|,
name|errbuf
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|zhp
condition|)
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|libzfs_fini
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

