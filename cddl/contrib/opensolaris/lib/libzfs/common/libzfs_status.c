begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012 by Delphix. All rights reserved.  * Copyright (c) 2013 Steven Hartland. All rights reserved.  */
end_comment

begin_comment
comment|/*  * This file contains the functions which analyze the status of a pool.  This  * include both the status of an active pool, as well as the status exported  * pools.  Returns one of the ZPOOL_STATUS_* defines describing the status of  * the pool.  This status is independent (to a certain degree) from the state of  * the pool.  A pool's state describes only whether or not it is capable of  * providing the necessary fault tolerance for data.  The status describes the  * overall status of devices.  A pool that is online can still have a device  * that is experiencing errors.  *  * Only a subset of the possible faults can be detected using 'zpool status',  * and not all possible errors correspond to a FMA message ID.  The explanation  * is left up to the caller, depending on whether it is a live pool or an  * import.  */
end_comment

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_include
include|#
directive|include
file|"zfeature_common.h"
end_include

begin_comment
comment|/*  * Message ID table.  This must be kept in sync with the ZPOOL_STATUS_* defines  * in libzfs.h.  Note that there are some status results which go past the end  * of this table, and hence have no associated message ID.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zfs_msgid_table
index|[]
init|=
block|{
literal|"ZFS-8000-14"
block|,
literal|"ZFS-8000-2Q"
block|,
literal|"ZFS-8000-3C"
block|,
literal|"ZFS-8000-4J"
block|,
literal|"ZFS-8000-5E"
block|,
literal|"ZFS-8000-6X"
block|,
literal|"ZFS-8000-72"
block|,
literal|"ZFS-8000-8A"
block|,
literal|"ZFS-8000-9P"
block|,
literal|"ZFS-8000-A5"
block|,
literal|"ZFS-8000-EY"
block|,
literal|"ZFS-8000-HC"
block|,
literal|"ZFS-8000-JQ"
block|,
literal|"ZFS-8000-K4"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NMSGID
value|(sizeof (zfs_msgid_table) / sizeof (zfs_msgid_table[0]))
end_define

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vdev_missing
parameter_list|(
name|vdev_stat_t
modifier|*
name|vs
parameter_list|,
name|uint_t
name|vsc
parameter_list|)
block|{
return|return
operator|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|vs
operator|->
name|vs_aux
operator|==
name|VDEV_AUX_OPEN_FAILED
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vdev_faulted
parameter_list|(
name|vdev_stat_t
modifier|*
name|vs
parameter_list|,
name|uint_t
name|vsc
parameter_list|)
block|{
return|return
operator|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_FAULTED
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vdev_errors
parameter_list|(
name|vdev_stat_t
modifier|*
name|vs
parameter_list|,
name|uint_t
name|vsc
parameter_list|)
block|{
return|return
operator|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_DEGRADED
operator|||
name|vs
operator|->
name|vs_read_errors
operator|!=
literal|0
operator|||
name|vs
operator|->
name|vs_write_errors
operator|!=
literal|0
operator|||
name|vs
operator|->
name|vs_checksum_errors
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vdev_broken
parameter_list|(
name|vdev_stat_t
modifier|*
name|vs
parameter_list|,
name|uint_t
name|vsc
parameter_list|)
block|{
return|return
operator|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vdev_offlined
parameter_list|(
name|vdev_stat_t
modifier|*
name|vs
parameter_list|,
name|uint_t
name|vsc
parameter_list|)
block|{
return|return
operator|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_OFFLINE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vdev_removed
parameter_list|(
name|vdev_stat_t
modifier|*
name|vs
parameter_list|,
name|uint_t
name|vsc
parameter_list|)
block|{
return|return
operator|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_REMOVED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_non_native_ashift
parameter_list|(
name|vdev_stat_t
modifier|*
name|vs
parameter_list|,
name|uint_t
name|vsc
parameter_list|)
block|{
return|return
operator|(
name|VDEV_STAT_VALID
argument_list|(
name|vs_physical_ashift
argument_list|,
name|vsc
argument_list|)
operator|&&
name|vs
operator|->
name|vs_configured_ashift
operator|<
name|vs
operator|->
name|vs_physical_ashift
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detect if any leaf devices that have seen errors or could not be opened.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|find_vdev_problem
parameter_list|(
name|nvlist_t
modifier|*
name|vdev
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|vdev_stat_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|)
parameter_list|,
name|boolean_t
name|ignore_replacing
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|vsc
decl_stmt|,
name|children
decl_stmt|;
comment|/* 	 * Ignore problems within a 'replacing' vdev, since we're presumably in 	 * the process of repairing any such errors, and don't want to call them 	 * out again.  We'll pick up the fact that a resilver is happening 	 * later. 	 */
if|if
condition|(
name|ignore_replacing
operator|==
name|B_TRUE
condition|)
block|{
name|char
modifier|*
name|type
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|vdev
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_REPLACING
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|vdev
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|find_vdev_problem
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|func
argument_list|,
name|ignore_replacing
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
else|else
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|vdev
argument_list|,
name|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
argument_list|(
name|vs
argument_list|,
name|vsc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
comment|/* 	 * Check any L2 cache devs 	 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|vdev
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|find_vdev_problem
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|func
argument_list|,
name|ignore_replacing
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Active pool health status.  *  * To determine the status for a pool, we make several passes over the config,  * picking the most egregious error we find.  In order of importance, we do the  * following:  *  *	- Check for a complete and valid configuration  *	- Look for any faulted or missing devices in a non-replicated config  *	- Check for any data errors  *	- Check for any faulted or missing devices in a replicated config  *	- Look for any devices showing errors  *	- Check for any resilvering devices  *  * There can obviously be multiple errors within a single pool, so this routine  * only picks the most damaging of all the current errors to report.  */
end_comment

begin_function
specifier|static
name|zpool_status_t
name|check_status
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|boolean_t
name|isimport
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|pool_scan_stat_t
modifier|*
name|ps
init|=
name|NULL
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|,
name|psc
decl_stmt|;
name|uint64_t
name|nerr
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
name|uint64_t
name|stateval
decl_stmt|;
name|uint64_t
name|suspended
decl_stmt|;
name|uint64_t
name|hostid
init|=
literal|0
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|stateval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Currently resilvering a vdev 	 */
operator|(
name|void
operator|)
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SCAN_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|ps
argument_list|,
operator|&
name|psc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|&&
name|ps
operator|->
name|pss_func
operator|==
name|POOL_SCAN_RESILVER
operator|&&
name|ps
operator|->
name|pss_state
operator|==
name|DSS_SCANNING
condition|)
return|return
operator|(
name|ZPOOL_STATUS_RESILVERING
operator|)
return|;
comment|/* 	 * Pool last accessed by another system. 	 */
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
operator|&
name|hostid
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostid
operator|!=
literal|0
operator|&&
operator|(
name|unsigned
name|long
operator|)
name|hostid
operator|!=
name|gethostid
argument_list|()
operator|&&
name|stateval
operator|==
name|POOL_STATE_ACTIVE
condition|)
return|return
operator|(
name|ZPOOL_STATUS_HOSTID_MISMATCH
operator|)
return|;
comment|/* 	 * Newer on-disk version. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|vs
operator|->
name|vs_aux
operator|==
name|VDEV_AUX_VERSION_NEWER
condition|)
return|return
operator|(
name|ZPOOL_STATUS_VERSION_NEWER
operator|)
return|;
comment|/* 	 * Unsupported feature(s). 	 */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|vs
operator|->
name|vs_aux
operator|==
name|VDEV_AUX_UNSUP_FEAT
condition|)
block|{
name|nvlist_t
modifier|*
name|nvinfo
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_LOAD_INFO
argument_list|,
operator|&
name|nvinfo
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_exists
argument_list|(
name|nvinfo
argument_list|,
name|ZPOOL_CONFIG_CAN_RDONLY
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_UNSUP_FEAT_WRITE
operator|)
return|;
return|return
operator|(
name|ZPOOL_STATUS_UNSUP_FEAT_READ
operator|)
return|;
block|}
comment|/* 	 * Check that the config is complete. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|vs
operator|->
name|vs_aux
operator|==
name|VDEV_AUX_BAD_GUID_SUM
condition|)
return|return
operator|(
name|ZPOOL_STATUS_BAD_GUID_SUM
operator|)
return|;
comment|/* 	 * Check whether the pool has suspended due to failed I/O. 	 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_SUSPENDED
argument_list|,
operator|&
name|suspended
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|suspended
operator|==
name|ZIO_FAILURE_MODE_CONTINUE
condition|)
return|return
operator|(
name|ZPOOL_STATUS_IO_FAILURE_CONTINUE
operator|)
return|;
return|return
operator|(
name|ZPOOL_STATUS_IO_FAILURE_WAIT
operator|)
return|;
block|}
comment|/* 	 * Could not read a log. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|vs
operator|->
name|vs_aux
operator|==
name|VDEV_AUX_BAD_LOG
condition|)
block|{
return|return
operator|(
name|ZPOOL_STATUS_BAD_LOG
operator|)
return|;
block|}
comment|/* 	 * Bad devices in non-replicated config. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_faulted
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_FAULTED_DEV_NR
operator|)
return|;
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_missing
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_MISSING_DEV_NR
operator|)
return|;
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_broken
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_CORRUPT_LABEL_NR
operator|)
return|;
comment|/* 	 * Corrupted pool metadata 	 */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
name|vs
operator|->
name|vs_aux
operator|==
name|VDEV_AUX_CORRUPT_DATA
condition|)
return|return
operator|(
name|ZPOOL_STATUS_CORRUPT_POOL
operator|)
return|;
comment|/* 	 * Persistent data errors. 	 */
if|if
condition|(
operator|!
name|isimport
condition|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_ERRCOUNT
argument_list|,
operator|&
name|nerr
argument_list|)
operator|==
literal|0
operator|&&
name|nerr
operator|!=
literal|0
condition|)
return|return
operator|(
name|ZPOOL_STATUS_CORRUPT_DATA
operator|)
return|;
block|}
comment|/* 	 * Missing devices in a replicated config. 	 */
if|if
condition|(
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_faulted
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_FAULTED_DEV_R
operator|)
return|;
if|if
condition|(
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_missing
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_MISSING_DEV_R
operator|)
return|;
if|if
condition|(
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_broken
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_CORRUPT_LABEL_R
operator|)
return|;
comment|/* 	 * Devices with errors 	 */
if|if
condition|(
operator|!
name|isimport
operator|&&
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_errors
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_FAILING_DEV
operator|)
return|;
comment|/* 	 * Offlined devices 	 */
if|if
condition|(
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_offlined
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_OFFLINE_DEV
operator|)
return|;
comment|/* 	 * Removed device 	 */
if|if
condition|(
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_removed
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_REMOVED_DEV
operator|)
return|;
comment|/* 	 * Suboptimal, but usable, ashift configuration. 	 */
if|if
condition|(
name|find_vdev_problem
argument_list|(
name|nvroot
argument_list|,
name|vdev_non_native_ashift
argument_list|,
name|B_FALSE
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_NON_NATIVE_ASHIFT
operator|)
return|;
comment|/* 	 * Outdated, but usable, version 	 */
if|if
condition|(
name|SPA_VERSION_IS_SUPPORTED
argument_list|(
name|version
argument_list|)
operator|&&
name|version
operator|!=
name|SPA_VERSION
condition|)
return|return
operator|(
name|ZPOOL_STATUS_VERSION_OLDER
operator|)
return|;
comment|/* 	 * Usable pool with disabled features 	 */
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_FEATURES
condition|)
block|{
name|int
name|i
decl_stmt|;
name|nvlist_t
modifier|*
name|feat
decl_stmt|;
if|if
condition|(
name|isimport
condition|)
block|{
name|feat
operator|=
name|fnvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_LOAD_INFO
argument_list|)
expr_stmt|;
name|feat
operator|=
name|fnvlist_lookup_nvlist
argument_list|(
name|feat
argument_list|,
name|ZPOOL_CONFIG_ENABLED_FEAT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|feat
operator|=
name|fnvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_FEATURE_STATS
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPA_FEATURES
condition|;
name|i
operator|++
control|)
block|{
name|zfeature_info_t
modifier|*
name|fi
init|=
operator|&
name|spa_feature_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|nvlist_exists
argument_list|(
name|feat
argument_list|,
name|fi
operator|->
name|fi_guid
argument_list|)
condition|)
return|return
operator|(
name|ZPOOL_STATUS_FEAT_DISABLED
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ZPOOL_STATUS_OK
operator|)
return|;
block|}
end_function

begin_function
name|zpool_status_t
name|zpool_get_status
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
modifier|*
name|msgid
parameter_list|)
block|{
name|zpool_status_t
name|ret
init|=
name|check_status
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|B_FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>=
name|NMSGID
condition|)
operator|*
name|msgid
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|msgid
operator|=
name|zfs_msgid_table
index|[
name|ret
index|]
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|zpool_status_t
name|zpool_import_status
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|char
modifier|*
modifier|*
name|msgid
parameter_list|)
block|{
name|zpool_status_t
name|ret
init|=
name|check_status
argument_list|(
name|config
argument_list|,
name|B_TRUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>=
name|NMSGID
condition|)
operator|*
name|msgid
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|msgid
operator|=
name|zfs_msgid_table
index|[
name|ret
index|]
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_ddt_stat
parameter_list|(
specifier|const
name|ddt_stat_t
modifier|*
name|dds
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|char
name|refcnt
index|[
literal|6
index|]
decl_stmt|;
name|char
name|blocks
index|[
literal|6
index|]
decl_stmt|,
name|lsize
index|[
literal|6
index|]
decl_stmt|,
name|psize
index|[
literal|6
index|]
decl_stmt|,
name|dsize
index|[
literal|6
index|]
decl_stmt|;
name|char
name|ref_blocks
index|[
literal|6
index|]
decl_stmt|,
name|ref_lsize
index|[
literal|6
index|]
decl_stmt|,
name|ref_psize
index|[
literal|6
index|]
decl_stmt|,
name|ref_dsize
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|dds
operator|==
name|NULL
operator|||
name|dds
operator|->
name|dds_blocks
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|h
operator|==
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|refcnt
argument_list|,
literal|"Total"
argument_list|)
expr_stmt|;
else|else
name|zfs_nicenum
argument_list|(
literal|1ULL
operator|<<
name|h
argument_list|,
name|refcnt
argument_list|,
sizeof|sizeof
argument_list|(
name|refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|dds
operator|->
name|dds_blocks
argument_list|,
name|blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|dds
operator|->
name|dds_lsize
argument_list|,
name|lsize
argument_list|,
sizeof|sizeof
argument_list|(
name|lsize
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|dds
operator|->
name|dds_psize
argument_list|,
name|psize
argument_list|,
sizeof|sizeof
argument_list|(
name|psize
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|dds
operator|->
name|dds_dsize
argument_list|,
name|dsize
argument_list|,
sizeof|sizeof
argument_list|(
name|dsize
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|dds
operator|->
name|dds_ref_blocks
argument_list|,
name|ref_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|ref_blocks
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|dds
operator|->
name|dds_ref_lsize
argument_list|,
name|ref_lsize
argument_list|,
sizeof|sizeof
argument_list|(
name|ref_lsize
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|dds
operator|->
name|dds_ref_psize
argument_list|,
name|ref_psize
argument_list|,
sizeof|sizeof
argument_list|(
name|ref_psize
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|dds
operator|->
name|dds_ref_dsize
argument_list|,
name|ref_dsize
argument_list|,
sizeof|sizeof
argument_list|(
name|ref_dsize
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%6s   %6s   %5s   %5s   %5s   %6s   %5s   %5s   %5s\n"
argument_list|,
name|refcnt
argument_list|,
name|blocks
argument_list|,
name|lsize
argument_list|,
name|psize
argument_list|,
name|dsize
argument_list|,
name|ref_blocks
argument_list|,
name|ref_lsize
argument_list|,
name|ref_psize
argument_list|,
name|ref_dsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print the DDT histogram and the column totals.  */
end_comment

begin_function
name|void
name|zpool_dump_ddt
parameter_list|(
specifier|const
name|ddt_stat_t
modifier|*
name|dds_total
parameter_list|,
specifier|const
name|ddt_histogram_t
modifier|*
name|ddh
parameter_list|)
block|{
name|int
name|h
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"bucket   "
literal|"           allocated             "
literal|"          referenced          \n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"______   "
literal|"______________________________   "
literal|"______________________________\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%6s   %6s   %5s   %5s   %5s   %6s   %5s   %5s   %5s\n"
argument_list|,
literal|"refcnt"
argument_list|,
literal|"blocks"
argument_list|,
literal|"LSIZE"
argument_list|,
literal|"PSIZE"
argument_list|,
literal|"DSIZE"
argument_list|,
literal|"blocks"
argument_list|,
literal|"LSIZE"
argument_list|,
literal|"PSIZE"
argument_list|,
literal|"DSIZE"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%6s   %6s   %5s   %5s   %5s   %6s   %5s   %5s   %5s\n"
argument_list|,
literal|"------"
argument_list|,
literal|"------"
argument_list|,
literal|"-----"
argument_list|,
literal|"-----"
argument_list|,
literal|"-----"
argument_list|,
literal|"------"
argument_list|,
literal|"-----"
argument_list|,
literal|"-----"
argument_list|,
literal|"-----"
argument_list|)
expr_stmt|;
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
literal|64
condition|;
name|h
operator|++
control|)
name|dump_ddt_stat
argument_list|(
operator|&
name|ddh
operator|->
name|ddh_stat
index|[
name|h
index|]
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|dump_ddt_stat
argument_list|(
name|dds_total
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

