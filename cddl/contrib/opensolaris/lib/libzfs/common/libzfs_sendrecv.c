begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mntent.h>
end_include

begin_include
include|#
directive|include
file|<sys/mnttab.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|"zfs_namecheck.h"
end_include

begin_include
include|#
directive|include
file|"zfs_prop.h"
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_include
include|#
directive|include
file|<fletcher.c>
end_include

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/* We need to use something for ENODATA. */
end_comment

begin_define
define|#
directive|define
name|ENODATA
value|EIDRM
end_define

begin_function_decl
specifier|static
name|int
name|zfs_receive_impl
parameter_list|(
name|libzfs_handle_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|recvflags_t
parameter_list|,
name|int
parameter_list|,
name|avl_tree_t
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Routines for dealing with the AVL tree of fs-nvlists  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fsavl_node
block|{
name|avl_node_t
name|fn_node
decl_stmt|;
name|nvlist_t
modifier|*
name|fn_nvfs
decl_stmt|;
name|char
modifier|*
name|fn_snapname
decl_stmt|;
name|uint64_t
name|fn_guid
decl_stmt|;
block|}
name|fsavl_node_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|fsavl_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|fsavl_node_t
modifier|*
name|fn1
init|=
name|arg1
decl_stmt|;
specifier|const
name|fsavl_node_t
modifier|*
name|fn2
init|=
name|arg2
decl_stmt|;
if|if
condition|(
name|fn1
operator|->
name|fn_guid
operator|>
name|fn2
operator|->
name|fn_guid
condition|)
return|return
operator|(
operator|+
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|fn1
operator|->
name|fn_guid
operator|<
name|fn2
operator|->
name|fn_guid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given the GUID of a snapshot, find its containing filesystem and  * (optionally) name.  */
end_comment

begin_function
specifier|static
name|nvlist_t
modifier|*
name|fsavl_find
parameter_list|(
name|avl_tree_t
modifier|*
name|avl
parameter_list|,
name|uint64_t
name|snapguid
parameter_list|,
name|char
modifier|*
modifier|*
name|snapname
parameter_list|)
block|{
name|fsavl_node_t
name|fn_find
decl_stmt|;
name|fsavl_node_t
modifier|*
name|fn
decl_stmt|;
name|fn_find
operator|.
name|fn_guid
operator|=
name|snapguid
expr_stmt|;
name|fn
operator|=
name|avl_find
argument_list|(
name|avl
argument_list|,
operator|&
name|fn_find
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
if|if
condition|(
name|snapname
condition|)
operator|*
name|snapname
operator|=
name|fn
operator|->
name|fn_snapname
expr_stmt|;
return|return
operator|(
name|fn
operator|->
name|fn_nvfs
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fsavl_destroy
parameter_list|(
name|avl_tree_t
modifier|*
name|avl
parameter_list|)
block|{
name|fsavl_node_t
modifier|*
name|fn
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
if|if
condition|(
name|avl
operator|==
name|NULL
condition|)
return|return;
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|fn
operator|=
name|avl_destroy_nodes
argument_list|(
name|avl
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
name|avl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|avl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|avl_tree_t
modifier|*
name|fsavl_create
parameter_list|(
name|nvlist_t
modifier|*
name|fss
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|fsavl
decl_stmt|;
name|nvpair_t
modifier|*
name|fselem
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|fsavl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|avl_tree_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|avl_create
argument_list|(
name|fsavl
argument_list|,
name|fsavl_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|fsavl_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|fsavl_node_t
argument_list|,
name|fn_node
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fselem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|fss
argument_list|,
name|fselem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
name|nvfs
decl_stmt|,
modifier|*
name|snaps
decl_stmt|;
name|nvpair_t
modifier|*
name|snapelem
init|=
name|NULL
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvpair_value_nvlist
argument_list|(
name|fselem
argument_list|,
operator|&
name|nvfs
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|nvfs
argument_list|,
literal|"snaps"
argument_list|,
operator|&
name|snaps
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|snapelem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|snapelem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fsavl_node_t
modifier|*
name|fn
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvpair_value_uint64
argument_list|(
name|snapelem
argument_list|,
operator|&
name|guid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fsavl_node_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fsavl_destroy
argument_list|(
name|fsavl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fn
operator|->
name|fn_nvfs
operator|=
name|nvfs
expr_stmt|;
name|fn
operator|->
name|fn_snapname
operator|=
name|nvpair_name
argument_list|(
name|snapelem
argument_list|)
expr_stmt|;
name|fn
operator|->
name|fn_guid
operator|=
name|guid
expr_stmt|;
comment|/* 			 * Note: if there are multiple snaps with the 			 * same GUID, we ignore all but one. 			 */
if|if
condition|(
name|avl_find
argument_list|(
name|fsavl
argument_list|,
name|fn
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
name|avl_add
argument_list|(
name|fsavl
argument_list|,
name|fn
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|fsavl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines for dealing with the giant nvlist of fs-nvlists, etc.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|send_data
block|{
name|uint64_t
name|parent_fromsnap_guid
decl_stmt|;
name|nvlist_t
modifier|*
name|parent_snaps
decl_stmt|;
name|nvlist_t
modifier|*
name|fss
decl_stmt|;
name|nvlist_t
modifier|*
name|snapprops
decl_stmt|;
specifier|const
name|char
modifier|*
name|fromsnap
decl_stmt|;
specifier|const
name|char
modifier|*
name|tosnap
decl_stmt|;
comment|/* 	 * The header nvlist is of the following format: 	 * { 	 *   "tosnap" -> string 	 *   "fromsnap" -> string (if incremental) 	 *   "fss" -> { 	 *	id -> { 	 * 	 *	 "name" -> string (full name; for debugging) 	 *	 "parentfromsnap" -> number (guid of fromsnap in parent) 	 * 	 *	 "props" -> { name -> value (only if set here) } 	 *	 "snaps" -> { name (lastname) -> number (guid) } 	 *	 "snapprops" -> { name (lastname) -> { name -> value } } 	 * 	 *	 "origin" -> number (guid) (if clone) 	 *	 "sent" -> boolean (not on-disk) 	 *	} 	 *   } 	 * } 	 * 	 */
block|}
name|send_data_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|send_iterate_prop
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|send_iterate_snap
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|send_data_t
modifier|*
name|sd
init|=
name|arg
decl_stmt|;
name|uint64_t
name|guid
init|=
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_guid
decl_stmt|;
name|char
modifier|*
name|snapname
decl_stmt|;
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|snapname
operator|=
name|strrchr
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_uint64
argument_list|(
name|sd
operator|->
name|parent_snaps
argument_list|,
name|snapname
argument_list|,
name|guid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * NB: if there is no fromsnap here (it's a newly created fs in 	 * an incremental replication), we will substitute the tosnap. 	 */
if|if
condition|(
operator|(
name|sd
operator|->
name|fromsnap
operator|&&
name|strcmp
argument_list|(
name|snapname
argument_list|,
name|sd
operator|->
name|fromsnap
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|sd
operator|->
name|parent_fromsnap_guid
operator|==
literal|0
operator|&&
name|sd
operator|->
name|tosnap
operator|&&
name|strcmp
argument_list|(
name|snapname
argument_list|,
name|sd
operator|->
name|tosnap
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sd
operator|->
name|parent_fromsnap_guid
operator|=
name|guid
expr_stmt|;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|send_iterate_prop
argument_list|(
name|zhp
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_nvlist
argument_list|(
name|sd
operator|->
name|snapprops
argument_list|,
name|snapname
argument_list|,
name|nv
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_iterate_prop
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|propname
init|=
name|nvpair_name
argument_list|(
name|elem
argument_list|)
decl_stmt|;
name|zfs_prop_t
name|prop
init|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|propnv
decl_stmt|;
if|if
condition|(
operator|!
name|zfs_prop_user
argument_list|(
name|propname
argument_list|)
operator|&&
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
continue|continue;
name|verify
argument_list|(
name|nvpair_value_nvlist
argument_list|(
name|elem
argument_list|,
operator|&
name|propnv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_QUOTA
operator|||
name|prop
operator|==
name|ZFS_PROP_RESERVATION
condition|)
block|{
comment|/* these guys are modifyable, but have no source */
name|uint64_t
name|value
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|propnv
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
continue|continue;
block|}
else|else
block|{
name|char
modifier|*
name|source
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|propnv
argument_list|,
name|ZPROP_SOURCE
argument_list|,
operator|&
name|source
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|source
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
name|zfs_prop_user
argument_list|(
name|propname
argument_list|)
operator|||
name|zfs_prop_get_type
argument_list|(
name|prop
argument_list|)
operator|==
name|PROP_TYPE_STRING
condition|)
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propnv
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_string
argument_list|(
name|nv
argument_list|,
name|propname
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|value
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|propnv
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|propname
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|send_iterate_fs
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|send_data_t
modifier|*
name|sd
init|=
name|arg
decl_stmt|;
name|nvlist_t
modifier|*
name|nvfs
decl_stmt|,
modifier|*
name|nv
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|uint64_t
name|parent_fromsnap_guid_save
init|=
name|sd
operator|->
name|parent_fromsnap_guid
decl_stmt|;
name|uint64_t
name|guid
init|=
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_guid
decl_stmt|;
name|char
name|guidstring
index|[
literal|64
index|]
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|nvfs
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_string
argument_list|(
name|nvfs
argument_list|,
literal|"name"
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_uint64
argument_list|(
name|nvfs
argument_list|,
literal|"parentfromsnap"
argument_list|,
name|sd
operator|->
name|parent_fromsnap_guid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_origin
index|[
literal|0
index|]
condition|)
block|{
name|zfs_handle_t
modifier|*
name|origin
init|=
name|zfs_open
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_origin
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
decl_stmt|;
if|if
condition|(
name|origin
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_uint64
argument_list|(
name|nvfs
argument_list|,
literal|"origin"
argument_list|,
name|origin
operator|->
name|zfs_dmustats
operator|.
name|dds_guid
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* iterate over props */
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|send_iterate_prop
argument_list|(
name|zhp
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_nvlist
argument_list|(
name|nvfs
argument_list|,
literal|"props"
argument_list|,
name|nv
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
comment|/* iterate over snaps, and set sd->parent_fromsnap_guid */
name|sd
operator|->
name|parent_fromsnap_guid
operator|=
literal|0
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|sd
operator|->
name|parent_snaps
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|sd
operator|->
name|snapprops
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_iter_snapshots
argument_list|(
name|zhp
argument_list|,
name|send_iterate_snap
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_nvlist
argument_list|(
name|nvfs
argument_list|,
literal|"snaps"
argument_list|,
name|sd
operator|->
name|parent_snaps
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_nvlist
argument_list|(
name|nvfs
argument_list|,
literal|"snapprops"
argument_list|,
name|sd
operator|->
name|snapprops
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|sd
operator|->
name|parent_snaps
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|sd
operator|->
name|snapprops
argument_list|)
expr_stmt|;
comment|/* add this fs to nvlist */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|guidstring
argument_list|,
sizeof|sizeof
argument_list|(
name|guidstring
argument_list|)
argument_list|,
literal|"0x%llx"
argument_list|,
operator|(
name|longlong_t
operator|)
name|guid
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_nvlist
argument_list|(
name|sd
operator|->
name|fss
argument_list|,
name|guidstring
argument_list|,
name|nvfs
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvfs
argument_list|)
expr_stmt|;
comment|/* iterate over children */
name|rv
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|send_iterate_fs
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|sd
operator|->
name|parent_fromsnap_guid
operator|=
name|parent_fromsnap_guid_save
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gather_nvlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
specifier|const
name|char
modifier|*
name|fromsnap
parameter_list|,
specifier|const
name|char
modifier|*
name|tosnap
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvlp
parameter_list|,
name|avl_tree_t
modifier|*
modifier|*
name|avlp
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|send_data_t
name|sd
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|fsname
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EZFS_BADTYPE
operator|)
return|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|sd
operator|.
name|fss
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sd
operator|.
name|fromsnap
operator|=
name|fromsnap
expr_stmt|;
name|sd
operator|.
name|tosnap
operator|=
name|tosnap
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|send_iterate_fs
argument_list|(
name|zhp
argument_list|,
operator|&
name|sd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|sd
operator|.
name|fss
argument_list|)
expr_stmt|;
if|if
condition|(
name|avlp
operator|!=
name|NULL
condition|)
operator|*
name|avlp
operator|=
name|NULL
expr_stmt|;
operator|*
name|nvlp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|avlp
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|avlp
operator|=
name|fsavl_create
argument_list|(
name|sd
operator|.
name|fss
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|sd
operator|.
name|fss
argument_list|)
expr_stmt|;
operator|*
name|nvlp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EZFS_NOMEM
operator|)
return|;
block|}
operator|*
name|nvlp
operator|=
name|sd
operator|.
name|fss
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines for dealing with the sorted snapshot functionality  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zfs_node
block|{
name|zfs_handle_t
modifier|*
name|zn_handle
decl_stmt|;
name|avl_node_t
name|zn_avlnode
decl_stmt|;
block|}
name|zfs_node_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|zfs_sort_snaps
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|avl
init|=
name|data
decl_stmt|;
name|zfs_node_t
modifier|*
name|node
init|=
name|zfs_alloc
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_node_t
argument_list|)
argument_list|)
decl_stmt|;
name|node
operator|->
name|zn_handle
operator|=
name|zhp
expr_stmt|;
name|avl_add
argument_list|(
name|avl
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_snapshot_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|larg
parameter_list|,
specifier|const
name|void
modifier|*
name|rarg
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|l
init|=
operator|(
operator|(
name|zfs_node_t
operator|*
operator|)
name|larg
operator|)
operator|->
name|zn_handle
decl_stmt|;
name|zfs_handle_t
modifier|*
name|r
init|=
operator|(
operator|(
name|zfs_node_t
operator|*
operator|)
name|rarg
operator|)
operator|->
name|zn_handle
decl_stmt|;
name|uint64_t
name|lcreate
decl_stmt|,
name|rcreate
decl_stmt|;
comment|/* 	 * Sort them according to creation time.  We use the hidden 	 * CREATETXG property to get an absolute ordering of snapshots. 	 */
name|lcreate
operator|=
name|zfs_prop_get_int
argument_list|(
name|l
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
name|rcreate
operator|=
name|zfs_prop_get_int
argument_list|(
name|r
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcreate
operator|<
name|rcreate
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|lcreate
operator|>
name|rcreate
condition|)
return|return
operator|(
operator|+
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_iter_snapshots_sorted
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_iter_f
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|zfs_node_t
modifier|*
name|node
decl_stmt|;
name|avl_tree_t
name|avl
decl_stmt|;
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
name|avl_create
argument_list|(
operator|&
name|avl
argument_list|,
name|zfs_snapshot_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_node_t
argument_list|,
name|zn_avlnode
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_iter_snapshots
argument_list|(
name|zhp
argument_list|,
name|zfs_sort_snaps
argument_list|,
operator|&
name|avl
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|avl_first
argument_list|(
operator|&
name|avl
argument_list|)
init|;
name|node
operator|!=
name|NULL
condition|;
name|node
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|avl
argument_list|,
name|node
argument_list|)
control|)
name|ret
operator||=
name|callback
argument_list|(
name|node
operator|->
name|zn_handle
argument_list|,
name|data
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|node
operator|=
name|avl_destroy_nodes
argument_list|(
operator|&
name|avl
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|avl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines specific to "zfs send"  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|send_dump_data
block|{
comment|/* these are all just the short snapname (the part after the @) */
specifier|const
name|char
modifier|*
name|fromsnap
decl_stmt|;
specifier|const
name|char
modifier|*
name|tosnap
decl_stmt|;
name|char
name|lastsnap
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|boolean_t
name|seenfrom
decl_stmt|,
name|seento
decl_stmt|,
name|replicate
decl_stmt|,
name|doall
decl_stmt|,
name|fromorigin
decl_stmt|;
name|boolean_t
name|verbose
decl_stmt|;
name|int
name|outfd
decl_stmt|;
name|boolean_t
name|err
decl_stmt|;
name|nvlist_t
modifier|*
name|fss
decl_stmt|;
name|avl_tree_t
modifier|*
name|fsavl
decl_stmt|;
block|}
name|send_dump_data_t
typedef|;
end_typedef

begin_comment
comment|/*  * Dumps a backup of the given snapshot (incremental from fromsnap if it's not  * NULL) to the file descriptor specified by outfd.  */
end_comment

begin_function
specifier|static
name|int
name|dump_ioctl
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|fromsnap
parameter_list|,
name|boolean_t
name|fromorigin
parameter_list|,
name|int
name|outfd
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fromsnap
operator|==
name|NULL
operator|||
name|fromsnap
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|!
name|fromorigin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromsnap
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|fromsnap
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|outfd
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|fromorigin
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SEND
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"warning: cannot send '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EXDEV
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"not an earlier snapshot from the same fs"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_CROSSTARGET
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|ENOENT
case|:
if|if
condition|(
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"incremental source (@%s) does not exist"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|EDQUOT
case|:
case|case
name|EFBIG
case|:
case|case
name|EIO
case|:
case|case
name|ENOLINK
case|:
case|case
name|ENOSPC
case|:
case|case
name|ENXIO
case|:
case|case
name|EPIPE
case|:
case|case
name|ERANGE
case|:
case|case
name|EFAULT
case|:
case|case
name|EROFS
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADBACKUP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_snapshot
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|send_dump_data_t
modifier|*
name|sdd
init|=
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|thissnap
decl_stmt|;
name|int
name|err
decl_stmt|;
name|thissnap
operator|=
name|strchr
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sdd
operator|->
name|fromsnap
operator|&&
operator|!
name|sdd
operator|->
name|seenfrom
operator|&&
name|strcmp
argument_list|(
name|sdd
operator|->
name|fromsnap
argument_list|,
name|thissnap
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sdd
operator|->
name|seenfrom
operator|=
name|B_TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sdd
operator|->
name|lastsnap
argument_list|,
name|thissnap
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sdd
operator|->
name|seento
operator|||
operator|!
name|sdd
operator|->
name|seenfrom
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* send it */
if|if
condition|(
name|sdd
operator|->
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sending from @%s to %s\n"
argument_list|,
name|sdd
operator|->
name|lastsnap
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|dump_ioctl
argument_list|(
name|zhp
argument_list|,
name|sdd
operator|->
name|lastsnap
argument_list|,
name|sdd
operator|->
name|lastsnap
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|sdd
operator|->
name|fromorigin
operator|||
name|sdd
operator|->
name|replicate
operator|)
argument_list|,
name|sdd
operator|->
name|outfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sdd
operator|->
name|seento
operator|&&
name|strcmp
argument_list|(
name|sdd
operator|->
name|tosnap
argument_list|,
name|thissnap
argument_list|)
operator|==
literal|0
condition|)
name|sdd
operator|->
name|seento
operator|=
name|B_TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sdd
operator|->
name|lastsnap
argument_list|,
name|thissnap
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_filesystem
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|send_dump_data_t
modifier|*
name|sdd
init|=
name|arg
decl_stmt|;
name|boolean_t
name|missingfrom
init|=
name|B_FALSE
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|tosnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: "
literal|"could not send %s@%s: does not exist\n"
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|tosnap
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|err
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sdd
operator|->
name|replicate
operator|&&
name|sdd
operator|->
name|fromsnap
condition|)
block|{
comment|/* 		 * If this fs does not have fromsnap, and we're doing 		 * recursive, we need to send a full stream from the 		 * beginning (or an incremental from the origin if this 		 * is a clone).  If we're doing non-recursive, then let 		 * them get the error. 		 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|fromsnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|missingfrom
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sdd
operator|->
name|doall
condition|)
block|{
name|sdd
operator|->
name|seenfrom
operator|=
name|sdd
operator|->
name|seento
operator|=
name|sdd
operator|->
name|lastsnap
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sdd
operator|->
name|fromsnap
operator|==
name|NULL
operator|||
name|missingfrom
condition|)
name|sdd
operator|->
name|seenfrom
operator|=
name|B_TRUE
expr_stmt|;
name|rv
operator|=
name|zfs_iter_snapshots_sorted
argument_list|(
name|zhp
argument_list|,
name|dump_snapshot
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sdd
operator|->
name|seenfrom
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: could not send %s@%s:\n"
literal|"incremental source (%s@%s) does not exist\n"
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|tosnap
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|fromsnap
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|err
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sdd
operator|->
name|seento
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: could not send %s@%s:\n"
literal|"incremental source (%s@%s) "
literal|"is not earlier than it\n"
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|tosnap
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|fromsnap
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|err
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|zfs_handle_t
modifier|*
name|snapzhp
decl_stmt|;
name|char
name|snapname
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|snapname
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|sdd
operator|->
name|tosnap
argument_list|)
expr_stmt|;
name|snapzhp
operator|=
name|zfs_open
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|snapname
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapzhp
operator|==
name|NULL
condition|)
block|{
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
name|dump_ioctl
argument_list|(
name|snapzhp
argument_list|,
name|missingfrom
condition|?
name|NULL
else|:
name|sdd
operator|->
name|fromsnap
argument_list|,
name|sdd
operator|->
name|fromorigin
operator|||
name|missingfrom
argument_list|,
name|sdd
operator|->
name|outfd
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|seento
operator|=
name|B_TRUE
expr_stmt|;
name|zfs_close
argument_list|(
name|snapzhp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_filesystems
parameter_list|(
name|zfs_handle_t
modifier|*
name|rzhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|send_dump_data_t
modifier|*
name|sdd
init|=
name|arg
decl_stmt|;
name|nvpair_t
modifier|*
name|fspair
decl_stmt|;
name|boolean_t
name|needagain
decl_stmt|,
name|progress
decl_stmt|;
if|if
condition|(
operator|!
name|sdd
operator|->
name|replicate
condition|)
return|return
operator|(
name|dump_filesystem
argument_list|(
name|rzhp
argument_list|,
name|sdd
argument_list|)
operator|)
return|;
name|again
label|:
name|needagain
operator|=
name|progress
operator|=
name|B_FALSE
expr_stmt|;
for|for
control|(
name|fspair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|sdd
operator|->
name|fss
argument_list|,
name|NULL
argument_list|)
init|;
name|fspair
condition|;
name|fspair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|sdd
operator|->
name|fss
argument_list|,
name|fspair
argument_list|)
control|)
block|{
name|nvlist_t
modifier|*
name|fslist
decl_stmt|;
name|char
modifier|*
name|fsname
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|origin_guid
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|origin_nv
decl_stmt|;
name|VERIFY
argument_list|(
name|nvpair_value_nvlist
argument_list|(
name|fspair
argument_list|,
operator|&
name|fslist
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_boolean
argument_list|(
name|fslist
argument_list|,
literal|"sent"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|VERIFY
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|fslist
argument_list|,
literal|"name"
argument_list|,
operator|&
name|fsname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|fslist
argument_list|,
literal|"origin"
argument_list|,
operator|&
name|origin_guid
argument_list|)
expr_stmt|;
name|origin_nv
operator|=
name|fsavl_find
argument_list|(
name|sdd
operator|->
name|fsavl
argument_list|,
name|origin_guid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin_nv
operator|&&
name|nvlist_lookup_boolean
argument_list|(
name|origin_nv
argument_list|,
literal|"sent"
argument_list|)
operator|==
name|ENOENT
condition|)
block|{
comment|/* 			 * origin has not been sent yet; 			 * skip this clone. 			 */
name|needagain
operator|=
name|B_TRUE
expr_stmt|;
continue|continue;
block|}
name|zhp
operator|=
name|zfs_open
argument_list|(
name|rzhp
operator|->
name|zfs_hdl
argument_list|,
name|fsname
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|err
operator|=
name|dump_filesystem
argument_list|(
name|zhp
argument_list|,
name|sdd
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_boolean
argument_list|(
name|fslist
argument_list|,
literal|"sent"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|progress
operator|=
name|B_TRUE
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|needagain
condition|)
block|{
name|assert
argument_list|(
name|progress
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dumps a backup of tosnap, incremental from fromsnap if it isn't NULL.  * If 'doall', dump all intermediate snaps.  * If 'replicate', dump special header and do recursively.  */
end_comment

begin_function
name|int
name|zfs_send
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|fromsnap
parameter_list|,
specifier|const
name|char
modifier|*
name|tosnap
parameter_list|,
name|boolean_t
name|replicate
parameter_list|,
name|boolean_t
name|doall
parameter_list|,
name|boolean_t
name|fromorigin
parameter_list|,
name|boolean_t
name|verbose
parameter_list|,
name|int
name|outfd
parameter_list|)
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|send_dump_data_t
name|sdd
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|err
decl_stmt|;
name|nvlist_t
modifier|*
name|fss
init|=
name|NULL
decl_stmt|;
name|avl_tree_t
modifier|*
name|fsavl
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot send '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromsnap
operator|&&
name|fromsnap
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"zero-length incremental source"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|replicate
operator|||
name|doall
condition|)
block|{
name|dmu_replay_record_t
name|drr
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|packbuf
init|=
name|NULL
decl_stmt|;
name|size_t
name|buflen
init|=
literal|0
decl_stmt|;
name|zio_cksum_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|assert
argument_list|(
name|fromsnap
operator|||
name|doall
argument_list|)
expr_stmt|;
if|if
condition|(
name|replicate
condition|)
block|{
name|nvlist_t
modifier|*
name|hdrnv
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|hdrnv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromsnap
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_string
argument_list|(
name|hdrnv
argument_list|,
literal|"fromsnap"
argument_list|,
name|fromsnap
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_string
argument_list|(
name|hdrnv
argument_list|,
literal|"tosnap"
argument_list|,
name|tosnap
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|gather_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|fromsnap
argument_list|,
name|tosnap
argument_list|,
operator|&
name|fss
argument_list|,
operator|&
name|fsavl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_nvlist
argument_list|(
name|hdrnv
argument_list|,
literal|"fss"
argument_list|,
name|fss
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|nvlist_pack
argument_list|(
name|hdrnv
argument_list|,
operator|&
name|packbuf
argument_list|,
operator|&
name|buflen
argument_list|,
name|NV_ENCODE_XDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|hdrnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|fsavl_destroy
argument_list|(
name|fsavl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|fss
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|err
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* write first begin record */
name|drr
operator|.
name|drr_type
operator|=
name|DRR_BEGIN
expr_stmt|;
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_magic
operator|=
name|DMU_BACKUP_MAGIC
expr_stmt|;
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_version
operator|=
name|DMU_BACKUP_HEADER_VERSION
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_toname
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_toname
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|tosnap
argument_list|)
expr_stmt|;
name|drr
operator|.
name|drr_payloadlen
operator|=
name|buflen
expr_stmt|;
name|fletcher_4_incremental_native
argument_list|(
operator|&
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|err
operator|=
name|write
argument_list|(
name|outfd
argument_list|,
operator|&
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write header nvlist */
if|if
condition|(
name|err
operator|!=
operator|-
literal|1
condition|)
block|{
name|fletcher_4_incremental_native
argument_list|(
name|packbuf
argument_list|,
name|buflen
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|err
operator|=
name|write
argument_list|(
name|outfd
argument_list|,
name|packbuf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|packbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
block|{
name|fsavl_destroy
argument_list|(
name|fsavl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|fss
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* write end record */
if|if
condition|(
name|err
operator|!=
operator|-
literal|1
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
argument_list|)
expr_stmt|;
name|drr
operator|.
name|drr_type
operator|=
name|DRR_END
expr_stmt|;
name|drr
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|=
name|zc
expr_stmt|;
name|err
operator|=
name|write
argument_list|(
name|outfd
argument_list|,
operator|&
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
block|{
name|fsavl_destroy
argument_list|(
name|fsavl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|fss
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
block|}
comment|/* dump each stream */
name|sdd
operator|.
name|fromsnap
operator|=
name|fromsnap
expr_stmt|;
name|sdd
operator|.
name|tosnap
operator|=
name|tosnap
expr_stmt|;
name|sdd
operator|.
name|outfd
operator|=
name|outfd
expr_stmt|;
name|sdd
operator|.
name|replicate
operator|=
name|replicate
expr_stmt|;
name|sdd
operator|.
name|doall
operator|=
name|doall
expr_stmt|;
name|sdd
operator|.
name|fromorigin
operator|=
name|fromorigin
expr_stmt|;
name|sdd
operator|.
name|fss
operator|=
name|fss
expr_stmt|;
name|sdd
operator|.
name|fsavl
operator|=
name|fsavl
expr_stmt|;
name|sdd
operator|.
name|verbose
operator|=
name|verbose
expr_stmt|;
name|err
operator|=
name|dump_filesystems
argument_list|(
name|zhp
argument_list|,
operator|&
name|sdd
argument_list|)
expr_stmt|;
name|fsavl_destroy
argument_list|(
name|fsavl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|fss
argument_list|)
expr_stmt|;
if|if
condition|(
name|replicate
operator|||
name|doall
condition|)
block|{
comment|/* 		 * write final end record.  NB: want to do this even if 		 * there was some error, because it might not be totally 		 * failed. 		 */
name|dmu_replay_record_t
name|drr
init|=
block|{
literal|0
block|}
decl_stmt|;
name|drr
operator|.
name|drr_type
operator|=
name|DRR_END
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|outfd
argument_list|,
operator|&
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|err
operator|||
name|sdd
operator|.
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines specific to "zfs recv"  */
end_comment

begin_function
specifier|static
name|int
name|recv_read
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|ilen
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|,
name|zio_cksum_t
modifier|*
name|zc
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|int
name|len
init|=
name|ilen
decl_stmt|;
do|do
block|{
name|rv
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|rv
expr_stmt|;
name|len
operator|-=
name|rv
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|rv
operator|<
literal|0
operator|||
name|len
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"failed to read from stream"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive"
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zc
condition|)
block|{
if|if
condition|(
name|byteswap
condition|)
name|fletcher_4_incremental_byteswap
argument_list|(
name|buf
argument_list|,
name|ilen
argument_list|,
name|zc
argument_list|)
expr_stmt|;
else|else
name|fletcher_4_incremental_native
argument_list|(
name|buf
argument_list|,
name|ilen
argument_list|,
name|zc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|recv_read_nvlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|len
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|,
name|zio_cksum_t
modifier|*
name|zc
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|buf
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|err
operator|=
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|byteswap
argument_list|,
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|err
operator|=
name|nvlist_unpack
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|nvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid "
literal|"stream (malformed nvlist)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|recv_rename
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|tryname
parameter_list|,
name|int
name|baselen
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|,
name|recvflags_t
name|flags
parameter_list|)
block|{
specifier|static
name|int
name|seq
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|err
decl_stmt|;
name|prop_changelist_t
modifier|*
name|clp
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|clp
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_NAME
argument_list|,
literal|0
argument_list|,
name|flags
operator|.
name|force
condition|?
name|MS_FORCE
else|:
literal|0
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|err
operator|=
name|changelist_prefix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|tryname
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newname
argument_list|,
name|tryname
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|tryname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"attempting rename %s to %s\n"
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_RENAME
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|changelist_rename
argument_list|(
name|clp
argument_list|,
name|name
argument_list|,
name|tryname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|ENOENT
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|name
operator|+
name|baselen
argument_list|,
literal|"recv-"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|seq
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|newname
operator|+
name|baselen
argument_list|,
name|ZFS_MAXNAMELEN
operator|-
name|baselen
argument_list|,
literal|"recv-%u-%u"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|seq
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|newname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"failed - trying rename %s to %s\n"
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_RENAME
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|changelist_rename
argument_list|(
name|clp
argument_list|,
name|name
argument_list|,
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|flags
operator|.
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"failed (%u) - "
literal|"will try again on next pass\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|EAGAIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|.
name|verbose
condition|)
block|{
if|if
condition|(
name|err
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"success\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"failed (%u)\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|changelist_postfix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|recv_destroy
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|baselen
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|,
name|recvflags_t
name|flags
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|prop_changelist_t
modifier|*
name|clp
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|clp
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_NAME
argument_list|,
literal|0
argument_list|,
name|flags
operator|.
name|force
condition|?
name|MS_FORCE
else|:
literal|0
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|err
operator|=
name|changelist_prefix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"attempting destroy %s\n"
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_DESTROY
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|.
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"success\n"
argument_list|)
expr_stmt|;
name|changelist_remove
argument_list|(
name|clp
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|changelist_postfix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|err
operator|=
name|recv_rename
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|baselen
argument_list|,
name|newname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|guid_to_name_data
block|{
name|uint64_t
name|guid
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|guid_to_name_data_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|guid_to_name_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|guid_to_name_data_t
modifier|*
name|gtnd
init|=
name|arg
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_guid
operator|==
name|gtnd
operator|->
name|guid
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|gtnd
operator|->
name|name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|err
operator|=
name|zfs_iter_children
argument_list|(
name|zhp
argument_list|,
name|guid_to_name_cb
argument_list|,
name|gtnd
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|guid_to_name
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|parent
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* exhaustive search all local snapshots */
name|guid_to_name_data_t
name|gtnd
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|gtnd
operator|.
name|guid
operator|=
name|guid
expr_stmt|;
name|gtnd
operator|.
name|name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|parent
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|zhp
operator|=
name|make_dataset_handle
argument_list|(
name|hdl
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|zfs_iter_children
argument_list|(
name|zhp
argument_list|,
name|guid_to_name_cb
argument_list|,
operator|&
name|gtnd
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EEXIST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|parent
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|zhp
operator|=
name|make_dataset_handle
argument_list|(
name|hdl
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|zhp
condition|)
block|{
name|err
operator|=
name|zfs_iter_children
argument_list|(
name|zhp
argument_list|,
name|guid_to_name_cb
argument_list|,
operator|&
name|gtnd
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|==
name|EEXIST
condition|?
literal|0
else|:
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if dataset guid1 is created before guid2.  */
end_comment

begin_function
specifier|static
name|int
name|created_before
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|avl_tree_t
modifier|*
name|avl
parameter_list|,
name|uint64_t
name|guid1
parameter_list|,
name|uint64_t
name|guid2
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvfs
decl_stmt|;
name|char
modifier|*
name|fsname
decl_stmt|,
modifier|*
name|snapname
decl_stmt|;
name|char
name|buf
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|zfs_node_t
name|zn1
decl_stmt|,
name|zn2
decl_stmt|;
if|if
condition|(
name|guid2
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|guid1
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|nvfs
operator|=
name|fsavl_find
argument_list|(
name|avl
argument_list|,
name|guid1
argument_list|,
operator|&
name|snapname
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|nvfs
argument_list|,
literal|"name"
argument_list|,
operator|&
name|fsname
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|fsname
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
name|zn1
operator|.
name|zn_handle
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|buf
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|zn1
operator|.
name|zn_handle
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nvfs
operator|=
name|fsavl_find
argument_list|(
name|avl
argument_list|,
name|guid2
argument_list|,
operator|&
name|snapname
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|nvfs
argument_list|,
literal|"name"
argument_list|,
operator|&
name|fsname
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|fsname
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
name|zn2
operator|.
name|zn_handle
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|buf
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|zn2
operator|.
name|zn_handle
operator|==
name|NULL
condition|)
block|{
name|zfs_close
argument_list|(
name|zn2
operator|.
name|zn_handle
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rv
operator|=
operator|(
name|zfs_snapshot_compare
argument_list|(
operator|&
name|zn1
argument_list|,
operator|&
name|zn2
argument_list|)
operator|==
operator|-
literal|1
operator|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zn1
operator|.
name|zn_handle
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zn2
operator|.
name|zn_handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|recv_incremental_replication
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|tofs
parameter_list|,
name|recvflags_t
name|flags
parameter_list|,
name|nvlist_t
modifier|*
name|stream_nv
parameter_list|,
name|avl_tree_t
modifier|*
name|stream_avl
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|local_nv
decl_stmt|;
name|avl_tree_t
modifier|*
name|local_avl
decl_stmt|;
name|nvpair_t
modifier|*
name|fselem
decl_stmt|,
modifier|*
name|nextfselem
decl_stmt|;
name|char
modifier|*
name|tosnap
decl_stmt|,
modifier|*
name|fromsnap
decl_stmt|;
name|char
name|newname
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|needagain
decl_stmt|,
name|progress
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|stream_nv
argument_list|,
literal|"fromsnap"
argument_list|,
operator|&
name|fromsnap
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|stream_nv
argument_list|,
literal|"tosnap"
argument_list|,
operator|&
name|tosnap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|dryrun
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|again
label|:
name|needagain
operator|=
name|progress
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|gather_nvlist
argument_list|(
name|hdl
argument_list|,
name|tofs
argument_list|,
name|fromsnap
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_nv
argument_list|,
operator|&
name|local_avl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Process deletes and renames 	 */
for|for
control|(
name|fselem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|local_nv
argument_list|,
name|NULL
argument_list|)
init|;
name|fselem
condition|;
name|fselem
operator|=
name|nextfselem
control|)
block|{
name|nvlist_t
modifier|*
name|nvfs
decl_stmt|,
modifier|*
name|snaps
decl_stmt|;
name|nvlist_t
modifier|*
name|stream_nvfs
init|=
name|NULL
decl_stmt|;
name|nvpair_t
modifier|*
name|snapelem
decl_stmt|,
modifier|*
name|nextsnapelem
decl_stmt|;
name|uint64_t
name|fromguid
init|=
literal|0
decl_stmt|;
name|uint64_t
name|originguid
init|=
literal|0
decl_stmt|;
name|uint64_t
name|stream_originguid
init|=
literal|0
decl_stmt|;
name|uint64_t
name|parent_fromsnap_guid
decl_stmt|,
name|stream_parent_fromsnap_guid
decl_stmt|;
name|char
modifier|*
name|fsname
decl_stmt|,
modifier|*
name|stream_fsname
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|nextfselem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|local_nv
argument_list|,
name|fselem
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvpair_value_nvlist
argument_list|(
name|fselem
argument_list|,
operator|&
name|nvfs
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|nvfs
argument_list|,
literal|"snaps"
argument_list|,
operator|&
name|snaps
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|nvfs
argument_list|,
literal|"name"
argument_list|,
operator|&
name|fsname
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_uint64
argument_list|(
name|nvfs
argument_list|,
literal|"parentfromsnap"
argument_list|,
operator|&
name|parent_fromsnap_guid
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nvfs
argument_list|,
literal|"origin"
argument_list|,
operator|&
name|originguid
argument_list|)
expr_stmt|;
comment|/* 		 * First find the stream's fs, so we can check for 		 * a different origin (due to "zfs promote") 		 */
for|for
control|(
name|snapelem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
init|;
name|snapelem
condition|;
name|snapelem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|snapelem
argument_list|)
control|)
block|{
name|uint64_t
name|thisguid
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvpair_value_uint64
argument_list|(
name|snapelem
argument_list|,
operator|&
name|thisguid
argument_list|)
argument_list|)
expr_stmt|;
name|stream_nvfs
operator|=
name|fsavl_find
argument_list|(
name|stream_avl
argument_list|,
name|thisguid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream_nvfs
operator|!=
name|NULL
condition|)
break|break;
block|}
comment|/* check for promote */
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|stream_nvfs
argument_list|,
literal|"origin"
argument_list|,
operator|&
name|stream_originguid
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream_nvfs
operator|&&
name|originguid
operator|!=
name|stream_originguid
condition|)
block|{
switch|switch
condition|(
name|created_before
argument_list|(
name|hdl
argument_list|,
name|local_avl
argument_list|,
name|stream_originguid
argument_list|,
name|originguid
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
block|{
comment|/* promote it! */
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|nvlist_t
modifier|*
name|origin_nvfs
decl_stmt|;
name|char
modifier|*
name|origin_fsname
decl_stmt|;
if|if
condition|(
name|flags
operator|.
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"promoting %s\n"
argument_list|,
name|fsname
argument_list|)
expr_stmt|;
name|origin_nvfs
operator|=
name|fsavl_find
argument_list|(
name|local_avl
argument_list|,
name|originguid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|origin_nvfs
argument_list|,
literal|"name"
argument_list|,
operator|&
name|origin_fsname
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|origin_fsname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|fsname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_PROMOTE
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|progress
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
default|default:
break|break;
case|case
operator|-
literal|1
case|:
name|fsavl_destroy
argument_list|(
name|local_avl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|local_nv
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 			 * We had/have the wrong origin, therefore our 			 * list of snapshots is wrong.  Need to handle 			 * them on the next pass. 			 */
name|needagain
operator|=
name|B_TRUE
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|snapelem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
init|;
name|snapelem
condition|;
name|snapelem
operator|=
name|nextsnapelem
control|)
block|{
name|uint64_t
name|thisguid
decl_stmt|;
name|char
modifier|*
name|stream_snapname
decl_stmt|;
name|nvlist_t
modifier|*
name|found
decl_stmt|,
modifier|*
name|props
decl_stmt|;
name|nextsnapelem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|snapelem
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvpair_value_uint64
argument_list|(
name|snapelem
argument_list|,
operator|&
name|thisguid
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|fsavl_find
argument_list|(
name|stream_avl
argument_list|,
name|thisguid
argument_list|,
operator|&
name|stream_snapname
argument_list|)
expr_stmt|;
comment|/* check for delete */
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
block|{
name|char
name|name
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|flags
operator|.
name|force
condition|)
continue|continue;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|fsname
argument_list|,
name|nvpair_name
argument_list|(
name|snapelem
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|recv_destroy
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|fsname
argument_list|)
operator|+
literal|1
argument_list|,
name|newname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|needagain
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|progress
operator|=
name|B_TRUE
expr_stmt|;
continue|continue;
block|}
name|stream_nvfs
operator|=
name|found
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|stream_nvfs
argument_list|,
literal|"snapprops"
argument_list|,
operator|&
name|props
argument_list|)
operator|&&
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|props
argument_list|,
name|stream_snapname
argument_list|,
operator|&
name|props
argument_list|)
condition|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|B_TRUE
expr_stmt|;
comment|/* clear current props */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|fsname
argument_list|,
name|nvpair_name
argument_list|(
name|snapelem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|props
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_SET_PROP
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check for different snapname */
if|if
condition|(
name|strcmp
argument_list|(
name|nvpair_name
argument_list|(
name|snapelem
argument_list|)
argument_list|,
name|stream_snapname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|name
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|char
name|tryname
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|fsname
argument_list|,
name|nvpair_name
argument_list|(
name|snapelem
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tryname
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|fsname
argument_list|,
name|stream_snapname
argument_list|)
expr_stmt|;
name|error
operator|=
name|recv_rename
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|tryname
argument_list|,
name|strlen
argument_list|(
name|fsname
argument_list|)
operator|+
literal|1
argument_list|,
name|newname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|needagain
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|progress
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|stream_snapname
argument_list|,
name|fromsnap
argument_list|)
operator|==
literal|0
condition|)
name|fromguid
operator|=
name|thisguid
expr_stmt|;
block|}
comment|/* check for delete */
if|if
condition|(
name|stream_nvfs
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|flags
operator|.
name|force
condition|)
continue|continue;
name|error
operator|=
name|recv_destroy
argument_list|(
name|hdl
argument_list|,
name|fsname
argument_list|,
name|strlen
argument_list|(
name|tofs
argument_list|)
operator|+
literal|1
argument_list|,
name|newname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|needagain
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|progress
operator|=
name|B_TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fromguid
operator|==
literal|0
operator|&&
name|flags
operator|.
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"local fs %s does not have fromsnap "
literal|"(%s in stream); must have been deleted locally; "
literal|"ignoring\n"
argument_list|,
name|fsname
argument_list|,
name|fromsnap
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|stream_nvfs
argument_list|,
literal|"name"
argument_list|,
operator|&
name|stream_fsname
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_uint64
argument_list|(
name|stream_nvfs
argument_list|,
literal|"parentfromsnap"
argument_list|,
operator|&
name|stream_parent_fromsnap_guid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check for rename */
name|p1
operator|=
name|strrchr
argument_list|(
name|fsname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|p2
operator|=
name|strrchr
argument_list|(
name|stream_fsname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stream_parent_fromsnap_guid
operator|!=
literal|0
operator|&&
name|stream_parent_fromsnap_guid
operator|!=
name|parent_fromsnap_guid
operator|)
operator|||
operator|(
name|p1
operator|!=
name|NULL
operator|&&
name|p2
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|nvlist_t
modifier|*
name|parent
decl_stmt|;
name|char
name|tryname
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|parent
operator|=
name|fsavl_find
argument_list|(
name|local_avl
argument_list|,
name|stream_parent_fromsnap_guid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * NB: parent might not be found if we used the 			 * tosnap for stream_parent_fromsnap_guid, 			 * because the parent is a newly-created fs; 			 * we'll be able to rename it after we recv the 			 * new fs. 			 */
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|pname
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|parent
argument_list|,
literal|"name"
argument_list|,
operator|&
name|pname
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tryname
argument_list|,
sizeof|sizeof
argument_list|(
name|tryname
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|pname
argument_list|,
name|p2
operator|!=
name|NULL
condition|?
name|p2
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tryname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"local fs %s new parent "
literal|"not found\n"
argument_list|,
name|fsname
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|recv_rename
argument_list|(
name|hdl
argument_list|,
name|fsname
argument_list|,
name|tryname
argument_list|,
name|strlen
argument_list|(
name|tofs
argument_list|)
operator|+
literal|1
argument_list|,
name|newname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|needagain
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|progress
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
name|fsavl_destroy
argument_list|(
name|local_avl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|local_nv
argument_list|)
expr_stmt|;
if|if
condition|(
name|needagain
operator|&&
name|progress
condition|)
block|{
comment|/* do another pass to fix up temporary names */
if|if
condition|(
name|flags
operator|.
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"another pass:\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
operator|(
name|needagain
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_receive_package
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|destname
parameter_list|,
name|recvflags_t
name|flags
parameter_list|,
name|dmu_replay_record_t
modifier|*
name|drr
parameter_list|,
name|zio_cksum_t
modifier|*
name|zc
parameter_list|,
name|char
modifier|*
modifier|*
name|top_zfs
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|stream_nv
init|=
name|NULL
decl_stmt|;
name|avl_tree_t
modifier|*
name|stream_avl
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|fromsnap
init|=
name|NULL
decl_stmt|;
name|char
name|tofs
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|dmu_replay_record_t
name|drre
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|anyerr
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|softerr
init|=
name|B_FALSE
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|destname
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"can not specify snapshot name for multi-snapshot stream"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|assert
argument_list|(
name|drr
operator|->
name|drr_type
operator|==
name|DRR_BEGIN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_magic
operator|==
name|DMU_BACKUP_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_version
operator|==
name|DMU_BACKUP_HEADER_VERSION
argument_list|)
expr_stmt|;
comment|/* 	 * Read in the nvlist from the stream. 	 */
if|if
condition|(
name|drr
operator|->
name|drr_payloadlen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|flags
operator|.
name|isprefix
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"must use -d to receive replication "
literal|"(send -R) stream"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|recv_read_nvlist
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
name|drr
operator|->
name|drr_payloadlen
argument_list|,
operator|&
name|stream_nv
argument_list|,
name|flags
operator|.
name|byteswap
argument_list|,
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Read in the end record and verify checksum. 	 */
if|if
condition|(
literal|0
operator|!=
operator|(
name|error
operator|=
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
operator|&
name|drre
argument_list|,
sizeof|sizeof
argument_list|(
name|drre
argument_list|)
argument_list|,
name|flags
operator|.
name|byteswap
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|flags
operator|.
name|byteswap
condition|)
block|{
name|drre
operator|.
name|drr_type
operator|=
name|BSWAP_32
argument_list|(
name|drre
operator|.
name|drr_type
argument_list|)
expr_stmt|;
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|0
index|]
operator|=
name|BSWAP_64
argument_list|(
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|1
index|]
operator|=
name|BSWAP_64
argument_list|(
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|2
index|]
operator|=
name|BSWAP_64
argument_list|(
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|3
index|]
operator|=
name|BSWAP_64
argument_list|(
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drre
operator|.
name|drr_type
operator|!=
name|DRR_END
condition|)
block|{
name|error
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|ZIO_CHECKSUM_EQUAL
argument_list|(
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
argument_list|,
operator|*
name|zc
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"incorrect header checksum"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|stream_nv
argument_list|,
literal|"fromsnap"
argument_list|,
operator|&
name|fromsnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|drr
operator|->
name|drr_payloadlen
operator|!=
literal|0
condition|)
block|{
name|nvlist_t
modifier|*
name|stream_fss
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|stream_nv
argument_list|,
literal|"fss"
argument_list|,
operator|&
name|stream_fss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stream_avl
operator|=
name|fsavl_create
argument_list|(
name|stream_fss
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"couldn't allocate avl tree"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOMEM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fromsnap
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|tofs
argument_list|,
name|destname
argument_list|,
name|ZFS_MAXNAMELEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|isprefix
condition|)
block|{
name|int
name|i
init|=
name|strcspn
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_toname
argument_list|,
literal|"/@"
argument_list|)
decl_stmt|;
comment|/* zfs_receive_one() will create_parents() */
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|tofs
argument_list|,
operator|&
name|drr
operator|->
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_toname
index|[
name|i
index|]
argument_list|,
name|ZFS_MAXNAMELEN
argument_list|)
expr_stmt|;
operator|*
name|strchr
argument_list|(
name|tofs
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
block|}
name|softerr
operator|=
name|recv_incremental_replication
argument_list|(
name|hdl
argument_list|,
name|tofs
argument_list|,
name|flags
argument_list|,
name|stream_nv
argument_list|,
name|stream_avl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Finally, receive each contained stream */
do|do
block|{
comment|/* 		 * we should figure out if it has a recoverable 		 * error, in which case do a recv_skip() and drive on. 		 * Note, if we fail due to already having this guid, 		 * zfs_receive_one() will take care of it (ie, 		 * recv_skip() and return 0). 		 */
name|error
operator|=
name|zfs_receive_impl
argument_list|(
name|hdl
argument_list|,
name|destname
argument_list|,
name|flags
argument_list|,
name|fd
argument_list|,
name|stream_avl
argument_list|,
name|top_zfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENODATA
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|anyerr
operator||=
name|error
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|drr
operator|->
name|drr_payloadlen
operator|!=
literal|0
operator|&&
name|fromsnap
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Now that we have the fs's they sent us, try the 		 * renames again. 		 */
name|softerr
operator|=
name|recv_incremental_replication
argument_list|(
name|hdl
argument_list|,
name|tofs
argument_list|,
name|flags
argument_list|,
name|stream_nv
argument_list|,
name|stream_avl
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|fsavl_destroy
argument_list|(
name|stream_avl
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream_nv
condition|)
name|nvlist_free
argument_list|(
name|stream_nv
argument_list|)
expr_stmt|;
if|if
condition|(
name|softerr
condition|)
name|error
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|anyerr
condition|)
name|error
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|recv_skip
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|fd
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|dmu_replay_record_t
modifier|*
name|drr
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|1
operator|<<
literal|20
argument_list|)
decl_stmt|;
comment|/* XXX would be great to use lseek if possible... */
name|drr
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_replay_record_t
argument_list|)
argument_list|,
name|byteswap
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|byteswap
condition|)
name|drr
operator|->
name|drr_type
operator|=
name|BSWAP_32
argument_list|(
name|drr
operator|->
name|drr_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|drr
operator|->
name|drr_type
condition|)
block|{
case|case
name|DRR_BEGIN
case|:
comment|/* NB: not to be used on v2 stream packages */
name|assert
argument_list|(
name|drr
operator|->
name|drr_payloadlen
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRR_END
case|:
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|DRR_OBJECT
case|:
if|if
condition|(
name|byteswap
condition|)
block|{
name|drr
operator|->
name|drr_u
operator|.
name|drr_object
operator|.
name|drr_bonuslen
operator|=
name|BSWAP_32
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_object
operator|.
name|drr_bonuslen
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|P2ROUNDUP
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_object
operator|.
name|drr_bonuslen
argument_list|,
literal|8
argument_list|)
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRR_WRITE
case|:
if|if
condition|(
name|byteswap
condition|)
block|{
name|drr
operator|->
name|drr_u
operator|.
name|drr_write
operator|.
name|drr_length
operator|=
name|BSWAP_64
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_write
operator|.
name|drr_length
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|drr
operator|->
name|drr_u
operator|.
name|drr_write
operator|.
name|drr_length
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRR_FREEOBJECTS
case|:
case|case
name|DRR_FREE
case|:
break|break;
default|default:
name|assert
argument_list|(
operator|!
literal|"invalid record type"
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Restores a backup of tosnap from the file descriptor specified by infd.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_receive_one
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|infd
parameter_list|,
specifier|const
name|char
modifier|*
name|tosnap
parameter_list|,
name|recvflags_t
name|flags
parameter_list|,
name|dmu_replay_record_t
modifier|*
name|drr
parameter_list|,
name|dmu_replay_record_t
modifier|*
name|drr_noswap
parameter_list|,
name|avl_tree_t
modifier|*
name|stream_avl
parameter_list|,
name|char
modifier|*
modifier|*
name|top_zfs
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|time_t
name|begin_time
decl_stmt|;
name|int
name|ioctl_err
decl_stmt|,
name|ioctl_errno
decl_stmt|,
name|err
decl_stmt|,
name|choplen
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|drr_begin
modifier|*
name|drrb
init|=
operator|&
name|drr
operator|->
name|drr_u
operator|.
name|drr_begin
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|chopprefix
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|boolean_t
name|newfs
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|stream_wantsnewfs
decl_stmt|;
name|uint64_t
name|parent_snapguid
init|=
literal|0
decl_stmt|;
name|prop_changelist_t
modifier|*
name|clp
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|snapprops_nvlist
init|=
name|NULL
decl_stmt|;
name|begin_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream_avl
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|snapname
decl_stmt|;
name|nvlist_t
modifier|*
name|fs
init|=
name|fsavl_find
argument_list|(
name|stream_avl
argument_list|,
name|drrb
operator|->
name|drr_toguid
argument_list|,
operator|&
name|snapname
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|props
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|fs
argument_list|,
literal|"parentfromsnap"
argument_list|,
operator|&
name|parent_snapguid
argument_list|)
expr_stmt|;
name|err
operator|=
name|nvlist_lookup_nvlist
argument_list|(
name|fs
argument_list|,
literal|"props"
argument_list|,
operator|&
name|props
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|canmountoff
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CANMOUNT
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|props
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|fs
argument_list|,
literal|"snapprops"
argument_list|,
operator|&
name|props
argument_list|)
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|props
argument_list|,
name|snapname
argument_list|,
operator|&
name|snapprops_nvlist
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Determine how much of the snapshot name stored in the stream 	 * we are going to tack on to the name they specified on the 	 * command line, and how much we are going to chop off. 	 * 	 * If they specified a snapshot, chop the entire name stored in 	 * the stream. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|chopprefix
argument_list|,
name|drrb
operator|->
name|drr_toname
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|isprefix
condition|)
block|{
comment|/* 		 * They specified a fs with -d, we want to tack on 		 * everything but the pool name stored in the stream 		 */
if|if
condition|(
name|strchr
argument_list|(
name|tosnap
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid "
literal|"argument - snapshot not allowed with -d"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|chopprefix
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|chopprefix
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|tosnap
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If they specified a filesystem without -d, we want to 		 * tack on everything after the fs specified in the 		 * first name from the stream. 		 */
name|cp
operator|=
name|strchr
argument_list|(
name|chopprefix
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|choplen
operator|=
name|strlen
argument_list|(
name|chopprefix
argument_list|)
expr_stmt|;
comment|/* 	 * Determine name of destination snapshot, store in zc_value. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|tosnap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|drrb
operator|->
name|drr_toname
operator|+
name|choplen
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfs_name_valid
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Determine the name of the origin snapshot, store in zc_string. 	 */
if|if
condition|(
name|drrb
operator|->
name|drr_flags
operator|&
name|DRR_FLAG_CLONE
condition|)
block|{
if|if
condition|(
name|guid_to_name
argument_list|(
name|hdl
argument_list|,
name|tosnap
argument_list|,
name|drrb
operator|->
name|drr_fromguid
argument_list|,
name|zc
operator|.
name|zc_string
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"local origin for clone %s does not exist"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|.
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"found clone origin %s\n"
argument_list|,
name|zc
operator|.
name|zc_string
argument_list|)
expr_stmt|;
block|}
name|stream_wantsnewfs
operator|=
operator|(
name|drrb
operator|->
name|drr_fromguid
operator|==
literal|0
operator|||
operator|(
name|drrb
operator|->
name|drr_flags
operator|&
name|DRR_FLAG_CLONE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|stream_wantsnewfs
condition|)
block|{
comment|/* 		 * if the parent fs does not exist, look for it based on 		 * the parent snap GUID 		 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive new filesystem stream"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
operator|!
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
condition|)
block|{
name|char
name|suffix
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|suffix
argument_list|,
name|strrchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid_to_name
argument_list|(
name|hdl
argument_list|,
name|tosnap
argument_list|,
name|parent_snapguid
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * if the fs does not exist, look for it based on the 		 * fromsnap GUID 		 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive incremental stream"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
operator|*
name|strchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
condition|)
block|{
name|char
name|snap
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|snap
argument_list|,
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid_to_name
argument_list|(
name|hdl
argument_list|,
name|tosnap
argument_list|,
name|drrb
operator|->
name|drr_fromguid
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|snap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
operator|*
name|strchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
condition|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
comment|/* 		 * Destination fs exists.  Therefore this should either 		 * be an incremental, or the stream specifies a new fs 		 * (full stream or clone) and they want us to blow it 		 * away (and have therefore specified -F and removed any 		 * snapshots). 		 */
if|if
condition|(
name|stream_wantsnewfs
condition|)
block|{
if|if
condition|(
operator|!
name|flags
operator|.
name|force
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination '%s' exists\n"
literal|"must specify -F to overwrite it"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SNAPSHOT_LIST_NEXT
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination has snapshots (eg. %s)\n"
literal|"must destroy them to overwrite it"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|stream_wantsnewfs
operator|&&
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_origin
index|[
literal|0
index|]
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination '%s' is a clone\n"
literal|"must destroy it to overwrite it"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|flags
operator|.
name|dryrun
operator|&&
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_FILESYSTEM
operator|&&
name|stream_wantsnewfs
condition|)
block|{
comment|/* We can't do online recv in this case */
name|clp
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_NAME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|changelist_prefix
argument_list|(
name|clp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|flags
operator|.
name|dryrun
operator|&&
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
operator|&&
name|zvol_remove_link
argument_list|(
name|hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Destination filesystem does not exist.  Therefore we better 		 * be creating a new filesystem (either from a full backup, or 		 * a clone).  It would therefore be invalid if the user 		 * specified only the pool name (i.e. if the destination name 		 * contained no slash character). 		 */
if|if
condition|(
operator|!
name|stream_wantsnewfs
operator|||
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination '%s' does not exist"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * Trim off the final dataset component so we perform the 		 * recvbackup ioctl to the filesystems's parent. 		 */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|isprefix
operator|&&
operator|!
name|flags
operator|.
name|dryrun
operator|&&
name|create_parents
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
name|strlen
argument_list|(
name|tosnap
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADRESTORE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|newfs
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|zc
operator|.
name|zc_begin_record
operator|=
name|drr_noswap
operator|->
name|drr_u
operator|.
name|drr_begin
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|infd
expr_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
name|flags
operator|.
name|force
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s stream of %s into %s\n"
argument_list|,
name|flags
operator|.
name|dryrun
condition|?
literal|"would receive"
else|:
literal|"receiving"
argument_list|,
name|drrb
operator|->
name|drr_fromguid
condition|?
literal|"incremental"
else|:
literal|"full"
argument_list|,
name|drrb
operator|->
name|drr_toname
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|.
name|dryrun
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|recv_skip
argument_list|(
name|hdl
argument_list|,
name|infd
argument_list|,
name|flags
operator|.
name|byteswap
argument_list|)
operator|)
return|;
block|}
name|err
operator|=
name|ioctl_err
operator|=
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_RECV
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|ioctl_errno
operator|=
name|errno
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|snapprops_nvlist
condition|)
block|{
name|zfs_cmd_t
name|zc2
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc2
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc2
argument_list|,
name|snapprops_nvlist
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_SET_PROP
argument_list|,
operator|&
name|zc2
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|&&
operator|(
name|ioctl_errno
operator|==
name|ENOENT
operator|||
name|ioctl_errno
operator|==
name|ENODEV
operator|)
condition|)
block|{
comment|/* 		 * It may be that this snapshot already exists, 		 * in which case we want to consume& ignore it 		 * rather than failing. 		 */
name|avl_tree_t
modifier|*
name|local_avl
decl_stmt|;
name|nvlist_t
modifier|*
name|local_nv
decl_stmt|,
modifier|*
name|fs
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
decl_stmt|;
comment|/* 		 * XXX Do this faster by just iterating over snaps in 		 * this fs.  Also if zc_value does not exist, we will 		 * get a strange "does not exist" error message. 		 */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|gather_nvlist
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_nv
argument_list|,
operator|&
name|local_avl
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
name|fs
operator|=
name|fsavl_find
argument_list|(
name|local_avl
argument_list|,
name|drrb
operator|->
name|drr_toguid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fsavl_destroy
argument_list|(
name|local_avl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|local_nv
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|.
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"snap %s already exists; "
literal|"ignoring\n"
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
name|ioctl_err
operator|=
name|recv_skip
argument_list|(
name|hdl
argument_list|,
name|infd
argument_list|,
name|flags
operator|.
name|byteswap
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
block|}
if|if
condition|(
name|ioctl_err
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|ioctl_errno
condition|)
block|{
case|case
name|ENODEV
case|:
name|cp
operator|=
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"most recent snapshot of %s does not\n"
literal|"match incremental source"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADRESTORE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
break|break;
case|case
name|ETXTBSY
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination %s has been modified\n"
literal|"since most recent snapshot"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADRESTORE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EEXIST
case|:
name|cp
operator|=
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfs
condition|)
block|{
comment|/* it's the containing fs that exists */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination already exists"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot restore to %s"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECKSUM
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid stream (checksum mismatch)"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|ioctl_errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Mount or recreate the /dev links for the target filesystem 	 * (if created, or if we tore them down to do an incremental 	 * restore), and the /dev links for the new snapshot (if 	 * created). Also mount any children of the target filesystem 	 * if we did an incremental receive. 	 */
name|cp
operator|=
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
operator|(
name|ioctl_err
operator|==
literal|0
operator|||
operator|!
name|newfs
operator|)
condition|)
block|{
name|zfs_handle_t
modifier|*
name|h
decl_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|h
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
name|err
operator|=
name|zvol_create_link
argument_list|(
name|hdl
argument_list|,
name|h
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|ioctl_err
operator|==
literal|0
condition|)
name|err
operator|=
name|zvol_create_link
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newfs
condition|)
block|{
comment|/* 				 * Track the first/top of hierarchy fs, 				 * for mounting and sharing later. 				 */
if|if
condition|(
name|top_zfs
operator|&&
operator|*
name|top_zfs
operator|==
name|NULL
condition|)
operator|*
name|top_zfs
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
block|}
if|if
condition|(
name|clp
condition|)
block|{
name|err
operator||=
name|changelist_postfix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|||
name|ioctl_err
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|flags
operator|.
name|verbose
condition|)
block|{
name|char
name|buf1
index|[
literal|64
index|]
decl_stmt|;
name|char
name|buf2
index|[
literal|64
index|]
decl_stmt|;
name|uint64_t
name|bytes
init|=
name|zc
operator|.
name|zc_cookie
decl_stmt|;
name|time_t
name|delta
init|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|begin_time
decl_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|delta
operator|=
literal|1
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|bytes
argument_list|,
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|bytes
operator|/
name|delta
argument_list|,
name|buf2
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"received %sB stream in %lu seconds (%sB/sec)\n"
argument_list|,
name|buf1
argument_list|,
name|delta
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_receive_impl
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|tosnap
parameter_list|,
name|recvflags_t
name|flags
parameter_list|,
name|int
name|infd
parameter_list|,
name|avl_tree_t
modifier|*
name|stream_avl
parameter_list|,
name|char
modifier|*
modifier|*
name|top_zfs
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dmu_replay_record_t
name|drr
decl_stmt|,
name|drr_noswap
decl_stmt|;
name|struct
name|drr_begin
modifier|*
name|drrb
init|=
operator|&
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|zio_cksum_t
name|zcksum
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|isprefix
operator|&&
operator|!
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|tosnap
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"specified fs "
literal|"(%s) does not exist"
argument_list|)
argument_list|,
name|tosnap
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* read in the BEGIN record */
if|if
condition|(
literal|0
operator|!=
operator|(
name|err
operator|=
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|infd
argument_list|,
operator|&
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
argument_list|,
name|B_FALSE
argument_list|,
operator|&
name|zcksum
argument_list|)
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|drr
operator|.
name|drr_type
operator|==
name|DRR_END
operator|||
name|drr
operator|.
name|drr_type
operator|==
name|BSWAP_32
argument_list|(
name|DRR_END
argument_list|)
condition|)
block|{
comment|/* It's the double end record at the end of a package */
return|return
operator|(
name|ENODATA
operator|)
return|;
block|}
comment|/* the kernel needs the non-byteswapped begin record */
name|drr_noswap
operator|=
name|drr
expr_stmt|;
name|flags
operator|.
name|byteswap
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|drrb
operator|->
name|drr_magic
operator|==
name|BSWAP_64
argument_list|(
name|DMU_BACKUP_MAGIC
argument_list|)
condition|)
block|{
comment|/* 		 * We computed the checksum in the wrong byteorder in 		 * recv_read() above; do it again correctly. 		 */
name|bzero
argument_list|(
operator|&
name|zcksum
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
name|fletcher_4_incremental_byteswap
argument_list|(
operator|&
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
argument_list|,
operator|&
name|zcksum
argument_list|)
expr_stmt|;
name|flags
operator|.
name|byteswap
operator|=
name|B_TRUE
expr_stmt|;
name|drr
operator|.
name|drr_type
operator|=
name|BSWAP_32
argument_list|(
name|drr
operator|.
name|drr_type
argument_list|)
expr_stmt|;
name|drr
operator|.
name|drr_payloadlen
operator|=
name|BSWAP_32
argument_list|(
name|drr
operator|.
name|drr_payloadlen
argument_list|)
expr_stmt|;
name|drrb
operator|->
name|drr_magic
operator|=
name|BSWAP_64
argument_list|(
name|drrb
operator|->
name|drr_magic
argument_list|)
expr_stmt|;
name|drrb
operator|->
name|drr_version
operator|=
name|BSWAP_64
argument_list|(
name|drrb
operator|->
name|drr_version
argument_list|)
expr_stmt|;
name|drrb
operator|->
name|drr_creation_time
operator|=
name|BSWAP_64
argument_list|(
name|drrb
operator|->
name|drr_creation_time
argument_list|)
expr_stmt|;
name|drrb
operator|->
name|drr_type
operator|=
name|BSWAP_32
argument_list|(
name|drrb
operator|->
name|drr_type
argument_list|)
expr_stmt|;
name|drrb
operator|->
name|drr_flags
operator|=
name|BSWAP_32
argument_list|(
name|drrb
operator|->
name|drr_flags
argument_list|)
expr_stmt|;
name|drrb
operator|->
name|drr_toguid
operator|=
name|BSWAP_64
argument_list|(
name|drrb
operator|->
name|drr_toguid
argument_list|)
expr_stmt|;
name|drrb
operator|->
name|drr_fromguid
operator|=
name|BSWAP_64
argument_list|(
name|drrb
operator|->
name|drr_fromguid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drrb
operator|->
name|drr_magic
operator|!=
name|DMU_BACKUP_MAGIC
operator|||
name|drr
operator|.
name|drr_type
operator|!=
name|DRR_BEGIN
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid "
literal|"stream (bad magic number)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|drrb
operator|->
name|drr_toname
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid "
literal|"stream (bad snapshot name)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|drrb
operator|->
name|drr_version
operator|==
name|DMU_BACKUP_STREAM_VERSION
condition|)
block|{
return|return
operator|(
name|zfs_receive_one
argument_list|(
name|hdl
argument_list|,
name|infd
argument_list|,
name|tosnap
argument_list|,
name|flags
argument_list|,
operator|&
name|drr
argument_list|,
operator|&
name|drr_noswap
argument_list|,
name|stream_avl
argument_list|,
name|top_zfs
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|drrb
operator|->
name|drr_version
operator|==
name|DMU_BACKUP_HEADER_VERSION
condition|)
block|{
return|return
operator|(
name|zfs_receive_package
argument_list|(
name|hdl
argument_list|,
name|infd
argument_list|,
name|tosnap
argument_list|,
name|flags
argument_list|,
operator|&
name|drr
argument_list|,
operator|&
name|zcksum
argument_list|,
name|top_zfs
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"stream is unsupported version %llu"
argument_list|)
argument_list|,
name|drrb
operator|->
name|drr_version
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Restores a backup of tosnap from the file descriptor specified by infd.  * Return 0 on total success, -2 if some things couldn't be  * destroyed/renamed/promoted, -1 if some things couldn't be received.  * (-1 will override -2).  */
end_comment

begin_function
name|int
name|zfs_receive
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|tosnap
parameter_list|,
name|recvflags_t
name|flags
parameter_list|,
name|int
name|infd
parameter_list|,
name|avl_tree_t
modifier|*
name|stream_avl
parameter_list|)
block|{
name|char
modifier|*
name|top_zfs
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|zfs_receive_impl
argument_list|(
name|hdl
argument_list|,
name|tosnap
argument_list|,
name|flags
argument_list|,
name|infd
argument_list|,
name|stream_avl
argument_list|,
operator|&
name|top_zfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|!
name|flags
operator|.
name|nomount
operator|&&
name|top_zfs
condition|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|prop_changelist_t
modifier|*
name|clp
decl_stmt|;
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|top_zfs
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|!=
name|NULL
condition|)
block|{
name|clp
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|CL_GATHER_MOUNT_ALWAYS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|!=
name|NULL
condition|)
block|{
comment|/* mount and share received datasets */
name|err
operator|=
name|changelist_postfix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zhp
operator|==
name|NULL
operator|||
name|clp
operator|==
name|NULL
operator|||
name|err
condition|)
name|err
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|top_zfs
condition|)
name|free
argument_list|(
name|top_zfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

