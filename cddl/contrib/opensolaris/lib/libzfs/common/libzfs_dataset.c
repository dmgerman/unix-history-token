begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<zone.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mntent.h>
end_include

begin_include
include|#
directive|include
file|<sys/mnttab.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_include
include|#
directive|include
file|<priv.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|"zfs_namecheck.h"
end_include

begin_include
include|#
directive|include
file|"zfs_prop.h"
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_include
include|#
directive|include
file|"zfs_deleg.h"
end_include

begin_function_decl
specifier|static
name|int
name|zvol_create_link_common
parameter_list|(
name|libzfs_handle_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Given a single type (not a mask of types), return the type in a human  * readable form.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zfs_type_to_name
parameter_list|(
name|zfs_type_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ZFS_TYPE_FILESYSTEM
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"filesystem"
argument_list|)
operator|)
return|;
case|case
name|ZFS_TYPE_SNAPSHOT
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot"
argument_list|)
operator|)
return|;
case|case
name|ZFS_TYPE_VOLUME
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume"
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a path and mask of ZFS types, return a string describing this dataset.  * This is used when we fail to open a dataset and we cannot get an exact type.  * We guess what the type would have been based on the path and the mask of  * acceptable types.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|path_to_str
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|types
parameter_list|)
block|{
comment|/* 	 * When given a single type, always report the exact type. 	 */
if|if
condition|(
name|types
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot"
argument_list|)
operator|)
return|;
if|if
condition|(
name|types
operator|==
name|ZFS_TYPE_FILESYSTEM
condition|)
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"filesystem"
argument_list|)
operator|)
return|;
if|if
condition|(
name|types
operator|==
name|ZFS_TYPE_VOLUME
condition|)
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume"
argument_list|)
operator|)
return|;
comment|/* 	 * The user is requesting more than one type of dataset.  If this is the 	 * case, consult the path itself.  If we're looking for a snapshot, and 	 * a '@' is found, then report it as "snapshot".  Otherwise, remove the 	 * snapshot attribute and try again. 	 */
if|if
condition|(
name|types
operator|&
name|ZFS_TYPE_SNAPSHOT
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|path
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot"
argument_list|)
operator|)
return|;
return|return
operator|(
name|path_to_str
argument_list|(
name|path
argument_list|,
name|types
operator|&
operator|~
name|ZFS_TYPE_SNAPSHOT
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * The user has requested either filesystems or volumes. 	 * We have no way of knowing a priori what type this would be, so always 	 * report it as "filesystem" or "volume", our two primitive types. 	 */
if|if
condition|(
name|types
operator|&
name|ZFS_TYPE_FILESYSTEM
condition|)
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"filesystem"
argument_list|)
operator|)
return|;
name|assert
argument_list|(
name|types
operator|&
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Validate a ZFS path.  This is used even before trying to open the dataset, to  * provide a more meaningful error message.  We place a more useful message in  * 'buf' detailing exactly why the name was not valid.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_validate_name
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|type
parameter_list|,
name|boolean_t
name|modifying
parameter_list|)
block|{
name|namecheck_err_t
name|why
decl_stmt|;
name|char
name|what
decl_stmt|;
if|if
condition|(
name|dataset_namecheck
argument_list|(
name|path
argument_list|,
operator|&
name|why
argument_list|,
operator|&
name|what
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|NAME_ERR_TOOLONG
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is too long"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_LEADING_SLASH
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"leading slash in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_EMPTY_COMPONENT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"empty component in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_TRAILING_SLASH
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"trailing slash in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_INVALCHAR
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid character "
literal|"'%c' in name"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_MULTIPLE_AT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"multiple '@' delimiters in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_NOLETTER
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool doesn't begin with a letter"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_RESERVED
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is reserved"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_DISKLIKE
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"reserved disk name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|type
operator|&
name|ZFS_TYPE_SNAPSHOT
operator|)
operator|&&
name|strchr
argument_list|(
name|path
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot delimiter '@' in filesystem name"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_SNAPSHOT
operator|&&
name|strchr
argument_list|(
name|path
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"missing '@' delimiter in snapshot name"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|modifying
operator|&&
name|strchr
argument_list|(
name|path
argument_list|,
literal|'%'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid character %c in name"
argument_list|)
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_name_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|zfs_type_t
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_POOL
condition|)
return|return
operator|(
name|zpool_name_valid
argument_list|(
name|NULL
argument_list|,
name|B_FALSE
argument_list|,
name|name
argument_list|)
operator|)
return|;
return|return
operator|(
name|zfs_validate_name
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function takes the raw DSL properties, and filters out the user-defined  * properties into a separate nvlist.  */
end_comment

begin_function
specifier|static
name|nvlist_t
modifier|*
name|process_user_props
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|props
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|zfs_prop_user
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
continue|continue;
name|verify
argument_list|(
name|nvpair_value_nvlist
argument_list|(
name|elem
argument_list|,
operator|&
name|propval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|nvl
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
name|propval
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|nvl
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zpool_handle_t
modifier|*
name|zpool_add_handle
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|pool_name
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zph
decl_stmt|;
if|if
condition|(
operator|(
name|zph
operator|=
name|zpool_open_canfail
argument_list|(
name|hdl
argument_list|,
name|pool_name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hdl
operator|->
name|libzfs_pool_handles
operator|!=
name|NULL
condition|)
name|zph
operator|->
name|zpool_next
operator|=
name|hdl
operator|->
name|libzfs_pool_handles
expr_stmt|;
name|hdl
operator|->
name|libzfs_pool_handles
operator|=
name|zph
expr_stmt|;
block|}
return|return
operator|(
name|zph
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zpool_handle_t
modifier|*
name|zpool_find_handle
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|pool_name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zph
init|=
name|hdl
operator|->
name|libzfs_pool_handles
decl_stmt|;
while|while
condition|(
operator|(
name|zph
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|pool_name
argument_list|,
name|zpool_get_name
argument_list|(
name|zph
argument_list|)
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|zph
operator|=
name|zph
operator|->
name|zpool_next
expr_stmt|;
return|return
operator|(
name|zph
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a handle to the pool that contains the provided dataset.  * If a handle to that pool already exists then that handle is returned.  * Otherwise, a new handle is created and added to the list of handles.  */
end_comment

begin_function
specifier|static
name|zpool_handle_t
modifier|*
name|zpool_handle
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|char
modifier|*
name|pool_name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zph
decl_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
literal|"/@"
argument_list|)
operator|+
literal|1
expr_stmt|;
name|pool_name
operator|=
name|zfs_alloc
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pool_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|zph
operator|=
name|zpool_find_handle
argument_list|(
name|zhp
argument_list|,
name|pool_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|zph
operator|==
name|NULL
condition|)
name|zph
operator|=
name|zpool_add_handle
argument_list|(
name|zhp
argument_list|,
name|pool_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pool_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zph
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zpool_free_handles
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|next
decl_stmt|,
modifier|*
name|zph
init|=
name|hdl
operator|->
name|libzfs_pool_handles
decl_stmt|;
while|while
condition|(
name|zph
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|zph
operator|->
name|zpool_next
expr_stmt|;
name|zpool_close
argument_list|(
name|zph
argument_list|)
expr_stmt|;
name|zph
operator|=
name|next
expr_stmt|;
block|}
name|hdl
operator|->
name|libzfs_pool_handles
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Utility function to gather stats (objset and zpl) for the given object.  */
end_comment

begin_function
specifier|static
name|int
name|get_stats
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|nvlist_t
modifier|*
name|allprops
decl_stmt|,
modifier|*
name|userprops
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_alloc_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|zcmd_expand_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|zhp
operator|->
name|zfs_dmustats
operator|=
name|zc
operator|.
name|zc_objset_stats
expr_stmt|;
comment|/* structure assignment */
if|if
condition|(
name|zcmd_read_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
operator|&
name|allprops
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|userprops
operator|=
name|process_user_props
argument_list|(
name|zhp
argument_list|,
name|allprops
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|allprops
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_user_props
argument_list|)
expr_stmt|;
name|zhp
operator|->
name|zfs_props
operator|=
name|allprops
expr_stmt|;
name|zhp
operator|->
name|zfs_user_props
operator|=
name|userprops
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Refresh the properties currently stored in the handle.  */
end_comment

begin_function
name|void
name|zfs_refresh_properties
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|get_stats
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Makes a handle from the given dataset name.  Used by zfs_open() and  * zfs_iter_* to create child handles on the fly.  */
end_comment

begin_function
name|zfs_handle_t
modifier|*
name|make_dataset_handle
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_handle_t
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|logstr
decl_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zhp
operator|->
name|zfs_hdl
operator|=
name|hdl
expr_stmt|;
comment|/* 	 * Preserve history log string. 	 * any changes performed here will be 	 * logged as an internal event. 	 */
name|logstr
operator|=
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_log_str
expr_stmt|;
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_log_str
operator|=
name|NULL
expr_stmt|;
name|top
label|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_stats
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_log_str
operator|=
name|logstr
expr_stmt|;
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_inconsistent
condition|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* 		 * If it is dds_inconsistent, then we've caught it in 		 * the middle of a 'zfs receive' or 'zfs destroy', and 		 * it is inconsistent from the ZPL's point of view, so 		 * can't be mounted.  However, it could also be that we 		 * have crashed in the middle of one of those 		 * operations, in which case we need to get rid of the 		 * inconsistent state.  We do that by either rolling 		 * back to the previous snapshot (which will fail if 		 * there is none), or destroying the filesystem.  Note 		 * that if we are still in the middle of an active 		 * 'receive' or 'destroy', then the rollback and destroy 		 * will fail with EBUSY and we will drive on as usual. 		 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_type
operator|==
name|DMU_OST_ZVOL
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_remove_link
argument_list|(
name|hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
block|}
else|else
block|{
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
block|}
comment|/* 		 * If we can successfully destroy it, pretend that it 		 * never existed. 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_DESTROY
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_log_str
operator|=
name|logstr
expr_stmt|;
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* If we can successfully roll it back, reget the stats */
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_ROLLBACK
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|top
goto|;
block|}
comment|/* 	 * We've managed to open the dataset and gather statistics.  Determine 	 * the high-level type. 	 */
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_type
operator|==
name|DMU_OST_ZVOL
condition|)
name|zhp
operator|->
name|zfs_head_type
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
elseif|else
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_type
operator|==
name|DMU_OST_ZFS
condition|)
name|zhp
operator|->
name|zfs_head_type
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_is_snapshot
condition|)
name|zhp
operator|->
name|zfs_type
operator|=
name|ZFS_TYPE_SNAPSHOT
expr_stmt|;
elseif|else
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_type
operator|==
name|DMU_OST_ZVOL
condition|)
name|zhp
operator|->
name|zfs_type
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
elseif|else
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_type
operator|==
name|DMU_OST_ZFS
condition|)
name|zhp
operator|->
name|zfs_type
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* we should never see any other types */
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_log_str
operator|=
name|logstr
expr_stmt|;
name|zhp
operator|->
name|zpool_hdl
operator|=
name|zpool_handle
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Opens the given snapshot, filesystem, or volume.   The 'types'  * argument is a mask of acceptable types.  The function will print an  * appropriate error message and return NULL if it can't be opened.  */
end_comment

begin_function
name|zfs_handle_t
modifier|*
name|zfs_open
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|types
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot open '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* 	 * Validate the name before we even try to open it. 	 */
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid dataset name"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Try to get stats for the dataset, which will tell us if it exists. 	 */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|make_dataset_handle
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|types
operator|&
name|zhp
operator|->
name|zfs_type
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a ZFS handle.  Nothing to do but free the associated memory.  */
end_comment

begin_function
name|void
name|zfs_close
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
if|if
condition|(
name|zhp
operator|->
name|zfs_mntopts
condition|)
name|free
argument_list|(
name|zhp
operator|->
name|zfs_mntopts
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_user_props
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zfs_spa_version
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|int
modifier|*
name|spa_version
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zpool_handle
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
if|if
condition|(
name|zpool_handle
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|spa_version
operator|=
name|zpool_get_prop_int
argument_list|(
name|zpool_handle
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The choice of reservation property depends on the SPA version.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_which_resv_prop
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
modifier|*
name|resv_prop
parameter_list|)
block|{
name|int
name|spa_version
decl_stmt|;
if|if
condition|(
name|zfs_spa_version
argument_list|(
name|zhp
argument_list|,
operator|&
name|spa_version
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|spa_version
operator|>=
name|SPA_VERSION_REFRESERVATION
condition|)
operator|*
name|resv_prop
operator|=
name|ZFS_PROP_REFRESERVATION
expr_stmt|;
else|else
operator|*
name|resv_prop
operator|=
name|ZFS_PROP_RESERVATION
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an nvlist of properties to set, validates that they are correct, and  * parses any numeric properties (index, boolean, etc) if they are specified as  * strings.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|zfs_valid_proplist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_type_t
name|type
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|uint64_t
name|zoned
parameter_list|,
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|uint64_t
name|intval
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
name|nvlist_t
modifier|*
name|ret
decl_stmt|;
name|int
name|chosen_normal
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|chosen_utf
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|ret
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|nvpair_name
argument_list|(
name|elem
argument_list|)
decl_stmt|;
comment|/* 		 * Make sure this property is valid and applies to this type. 		 */
if|if
condition|(
operator|(
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
operator|)
operator|==
name|ZPROP_INVAL
condition|)
block|{
if|if
condition|(
operator|!
name|zfs_prop_user
argument_list|(
name|propname
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid property '%s'"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 			 * If this is a user property, make sure it's a 			 * string, and that it's less than ZAP_MAXNAMELEN. 			 */
if|if
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
operator|!=
name|DATA_TYPE_STRING
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a string"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
operator|>=
name|ZAP_MAXNAMELEN
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property name '%s' is too long"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|(
name|void
operator|)
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|strval
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|ret
argument_list|,
name|propname
argument_list|,
name|strval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"this property can not be modified for snapshots"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' does not "
literal|"apply to datasets of this type"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
operator|&&
operator|(
operator|!
name|zfs_prop_setonce
argument_list|(
name|prop
argument_list|)
operator|||
name|zhp
operator|!=
name|NULL
operator|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is readonly"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPREADONLY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|zprop_parse_value
argument_list|(
name|hdl
argument_list|,
name|elem
argument_list|,
name|prop
argument_list|,
name|type
argument_list|,
name|ret
argument_list|,
operator|&
name|strval
argument_list|,
operator|&
name|intval
argument_list|,
name|errbuf
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* 		 * Perform some additional checks for specific properties. 		 */
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_VERSION
case|:
block|{
name|int
name|version
decl_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
break|break;
name|version
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|intval
operator|<
name|version
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Can not downgrade; already at version %u"
argument_list|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
block|}
case|case
name|ZFS_PROP_RECORDSIZE
case|:
case|case
name|ZFS_PROP_VOLBLOCKSIZE
case|:
comment|/* must be power of two within SPA_{MIN,MAX}BLOCKSIZE */
if|if
condition|(
name|intval
operator|<
name|SPA_MINBLOCKSIZE
operator|||
name|intval
operator|>
name|SPA_MAXBLOCKSIZE
operator|||
operator|!
name|ISP2
argument_list|(
name|intval
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be power of 2 from %u "
literal|"to %uk"
argument_list|)
argument_list|,
name|propname
argument_list|,
operator|(
name|uint_t
operator|)
name|SPA_MINBLOCKSIZE
argument_list|,
operator|(
name|uint_t
operator|)
name|SPA_MAXBLOCKSIZE
operator|>>
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|ZFS_PROP_SHAREISCSI
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"off"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"on"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"type=disk"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be 'on', 'off', or 'type=disk'"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|ZFS_PROP_MOUNTPOINT
case|:
block|{
name|namecheck_err_t
name|why
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
name|ZFS_MOUNTPOINT_NONE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|strval
argument_list|,
name|ZFS_MOUNTPOINT_LEGACY
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|mountpoint_namecheck
argument_list|(
name|strval
argument_list|,
operator|&
name|why
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|NAME_ERR_LEADING_SLASH
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be an absolute path, "
literal|"'none', or 'legacy'"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_TOOLONG
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"component of '%s' is too long"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|/*FALLTHRU*/
case|case
name|ZFS_PROP_SHARESMB
case|:
case|case
name|ZFS_PROP_SHARENFS
case|:
comment|/* 			 * For the mountpoint and sharenfs or sharesmb 			 * properties, check if it can be set in a 			 * global/non-global zone based on 			 * the zoned property value: 			 * 			 *		global zone	    non-global zone 			 * -------------------------------------------------- 			 * zoned=on	mountpoint (no)	    mountpoint (yes) 			 *		sharenfs (no)	    sharenfs (no) 			 *		sharesmb (no)	    sharesmb (no) 			 * 			 * zoned=off	mountpoint (yes)	N/A 			 *		sharenfs (yes) 			 *		sharesmb (yes) 			 */
if|if
condition|(
name|zoned
condition|)
block|{
if|if
condition|(
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be set on "
literal|"dataset in a non-global zone"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_SHARENFS
operator|||
name|prop
operator|==
name|ZFS_PROP_SHARESMB
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be set in "
literal|"a non-global zone"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|getzoneid
argument_list|()
operator|!=
name|GLOBAL_ZONEID
condition|)
block|{
comment|/* 				 * If zoned property is 'off', this must be in 				 * a globle zone. If not, something is wrong. 				 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be set while dataset "
literal|"'zoned' property is set"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 			 * At this point, it is legitimate to set the 			 * property. Now we want to make sure that the 			 * property value is valid if it is sharenfs. 			 */
if|if
condition|(
operator|(
name|prop
operator|==
name|ZFS_PROP_SHARENFS
operator|||
name|prop
operator|==
name|ZFS_PROP_SHARESMB
operator|)
operator|&&
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"on"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"off"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_share_proto_t
name|proto
decl_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_SHARESMB
condition|)
name|proto
operator|=
name|PROTO_SMB
expr_stmt|;
else|else
name|proto
operator|=
name|PROTO_NFS
expr_stmt|;
comment|/* 				 * Must be an valid sharing protocol 				 * option string so init the libshare 				 * in order to enable the parser and 				 * then parse the options. We use the 				 * control API since we don't care about 				 * the current configuration and don't 				 * want the overhead of loading it 				 * until we actually do something. 				 */
if|if
condition|(
name|zfs_init_libshare
argument_list|(
name|hdl
argument_list|,
name|SA_INIT_CONTROL_API
argument_list|)
operator|!=
name|SA_OK
condition|)
block|{
comment|/* 					 * An error occurred so we can't do 					 * anything 					 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be set: problem "
literal|"in share initialization"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|zfs_parse_options
argument_list|(
name|strval
argument_list|,
name|proto
argument_list|)
operator|!=
name|SA_OK
condition|)
block|{
comment|/* 					 * There was an error in parsing so 					 * deal with it by issuing an error 					 * message and leaving after 					 * uninitializing the the libshare 					 * interface. 					 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be set to invalid "
literal|"options"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|zfs_uninit_libshare
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|zfs_uninit_libshare
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_UTF8ONLY
case|:
name|chosen_utf
operator|=
operator|(
name|int
operator|)
name|intval
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NORMALIZE
case|:
name|chosen_normal
operator|=
operator|(
name|int
operator|)
name|intval
expr_stmt|;
break|break;
block|}
comment|/* 		 * For changes to existing volumes, we have some additional 		 * checks to enforce. 		 */
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
operator|&&
name|zhp
operator|!=
name|NULL
condition|)
block|{
name|uint64_t
name|volsize
init|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|)
decl_stmt|;
name|uint64_t
name|blocksize
init|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_RESERVATION
case|:
case|case
name|ZFS_PROP_REFRESERVATION
case|:
if|if
condition|(
name|intval
operator|>
name|volsize
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is greater than current "
literal|"volume size"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|ZFS_PROP_VOLSIZE
case|:
if|if
condition|(
name|intval
operator|%
name|blocksize
operator|!=
literal|0
condition|)
block|{
name|zfs_nicenum
argument_list|(
name|blocksize
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a multiple of "
literal|"volume block size (%s)"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|intval
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be zero"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
block|}
block|}
block|}
comment|/* 	 * If normalization was chosen, but no UTF8 choice was made, 	 * enforce rejection of non-UTF8 names. 	 * 	 * If normalization was chosen, but rejecting non-UTF8 names 	 * was explicitly not chosen, it is an error. 	 */
if|if
condition|(
name|chosen_normal
operator|>
literal|0
operator|&&
name|chosen_utf
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|ret
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_UTF8ONLY
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|chosen_normal
operator|>
literal|0
operator|&&
name|chosen_utf
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be set 'on' if normalization chosen"
argument_list|)
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_UTF8ONLY
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * If this is an existing volume, and someone is setting the volsize, 	 * make sure that it matches the reservation, or add it if necessary. 	 */
if|if
condition|(
name|zhp
operator|!=
name|NULL
operator|&&
name|type
operator|==
name|ZFS_TYPE_VOLUME
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|ret
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|,
operator|&
name|intval
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|old_volsize
init|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|)
decl_stmt|;
name|uint64_t
name|old_reservation
decl_stmt|;
name|uint64_t
name|new_reservation
decl_stmt|;
name|zfs_prop_t
name|resv_prop
decl_stmt|;
if|if
condition|(
name|zfs_which_resv_prop
argument_list|(
name|zhp
argument_list|,
operator|&
name|resv_prop
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
name|old_reservation
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|resv_prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_volsize
operator|==
name|old_reservation
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|ret
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|resv_prop
argument_list|)
argument_list|,
operator|&
name|new_reservation
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|ret
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|resv_prop
argument_list|)
argument_list|,
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
name|error
label|:
name|nvlist_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_get_perm_who
parameter_list|(
specifier|const
name|char
modifier|*
name|who
parameter_list|,
name|zfs_deleg_who_type_t
modifier|*
name|who_type
parameter_list|,
name|uint64_t
modifier|*
name|ret_who
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|uid_t
name|id
decl_stmt|;
if|if
condition|(
operator|*
name|who_type
operator|==
name|ZFS_DELEG_EVERYONE
operator|||
operator|*
name|who_type
operator|==
name|ZFS_DELEG_CREATE
operator|||
operator|*
name|who_type
operator|==
name|ZFS_DELEG_NAMED_SET
condition|)
block|{
operator|*
name|ret_who
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|who
operator|==
name|NULL
operator|&&
operator|!
operator|(
operator|*
name|who_type
operator|==
name|ZFS_DELEG_EVERYONE
operator|)
condition|)
return|return
operator|(
name|EZFS_BADWHO
operator|)
return|;
if|if
condition|(
operator|*
name|who_type
operator|==
name|ZFS_DELEG_WHO_UNKNOWN
operator|&&
name|strcmp
argument_list|(
name|who
argument_list|,
literal|"everyone"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|ret_who
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|who_type
operator|=
name|ZFS_DELEG_EVERYONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pwd
operator|=
name|getpwnam
argument_list|(
name|who
argument_list|)
expr_stmt|;
name|grp
operator|=
name|getgrnam
argument_list|(
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|who_type
operator|==
name|ZFS_DELEG_USER
operator|)
operator|&&
name|pwd
condition|)
block|{
operator|*
name|ret_who
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|who_type
operator|==
name|ZFS_DELEG_GROUP
operator|)
operator|&&
name|grp
condition|)
block|{
operator|*
name|ret_who
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pwd
condition|)
block|{
operator|*
name|ret_who
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
operator|*
name|who_type
operator|=
name|ZFS_DELEG_USER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|grp
condition|)
block|{
operator|*
name|ret_who
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
operator|*
name|who_type
operator|=
name|ZFS_DELEG_GROUP
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|id
operator|=
name|strtol
argument_list|(
name|who
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|*
name|end
operator|!=
literal|'\0'
condition|)
block|{
return|return
operator|(
name|EZFS_BADWHO
operator|)
return|;
block|}
else|else
block|{
operator|*
name|ret_who
operator|=
name|id
expr_stmt|;
if|if
condition|(
operator|*
name|who_type
operator|==
name|ZFS_DELEG_WHO_UNKNOWN
condition|)
operator|*
name|who_type
operator|=
name|ZFS_DELEG_USER
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_perms_add_to_nvlist
parameter_list|(
name|nvlist_t
modifier|*
name|who_nvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|perms_nvp
parameter_list|)
block|{
if|if
condition|(
name|perms_nvp
operator|!=
name|NULL
condition|)
block|{
name|verify
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|who_nvp
argument_list|,
name|name
argument_list|,
name|perms_nvp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verify
argument_list|(
name|nvlist_add_boolean
argument_list|(
name|who_nvp
argument_list|,
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|helper
parameter_list|(
name|zfs_deleg_who_type_t
name|who_type
parameter_list|,
name|uint64_t
name|whoid
parameter_list|,
name|char
modifier|*
name|whostr
parameter_list|,
name|zfs_deleg_inherit_t
name|inherit
parameter_list|,
name|nvlist_t
modifier|*
name|who_nvp
parameter_list|,
name|nvlist_t
modifier|*
name|perms_nvp
parameter_list|,
name|nvlist_t
modifier|*
name|sets_nvp
parameter_list|)
block|{
name|boolean_t
name|do_perms
decl_stmt|,
name|do_sets
decl_stmt|;
name|char
name|name
index|[
name|ZFS_MAX_DELEG_NAME
index|]
decl_stmt|;
name|do_perms
operator|=
operator|(
name|nvlist_next_nvpair
argument_list|(
name|perms_nvp
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|do_sets
operator|=
operator|(
name|nvlist_next_nvpair
argument_list|(
name|sets_nvp
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_perms
operator|&&
operator|!
name|do_sets
condition|)
name|do_perms
operator|=
name|do_sets
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|do_perms
condition|)
block|{
name|zfs_deleg_whokey
argument_list|(
name|name
argument_list|,
name|who_type
argument_list|,
name|inherit
argument_list|,
operator|(
name|who_type
operator|==
name|ZFS_DELEG_NAMED_SET
operator|)
condition|?
name|whostr
else|:
operator|(
name|void
operator|*
operator|)
operator|&
name|whoid
argument_list|)
expr_stmt|;
name|zfs_perms_add_to_nvlist
argument_list|(
name|who_nvp
argument_list|,
name|name
argument_list|,
name|perms_nvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_sets
condition|)
block|{
name|zfs_deleg_whokey
argument_list|(
name|name
argument_list|,
name|toupper
argument_list|(
name|who_type
argument_list|)
argument_list|,
name|inherit
argument_list|,
operator|(
name|who_type
operator|==
name|ZFS_DELEG_NAMED_SET
operator|)
condition|?
name|whostr
else|:
operator|(
name|void
operator|*
operator|)
operator|&
name|whoid
argument_list|)
expr_stmt|;
name|zfs_perms_add_to_nvlist
argument_list|(
name|who_nvp
argument_list|,
name|name
argument_list|,
name|sets_nvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_perms_add_who_nvlist
parameter_list|(
name|nvlist_t
modifier|*
name|who_nvp
parameter_list|,
name|uint64_t
name|whoid
parameter_list|,
name|void
modifier|*
name|whostr
parameter_list|,
name|nvlist_t
modifier|*
name|perms_nvp
parameter_list|,
name|nvlist_t
modifier|*
name|sets_nvp
parameter_list|,
name|zfs_deleg_who_type_t
name|who_type
parameter_list|,
name|zfs_deleg_inherit_t
name|inherit
parameter_list|)
block|{
if|if
condition|(
name|who_type
operator|==
name|ZFS_DELEG_NAMED_SET
operator|||
name|who_type
operator|==
name|ZFS_DELEG_CREATE
condition|)
block|{
name|helper
argument_list|(
name|who_type
argument_list|,
name|whoid
argument_list|,
name|whostr
argument_list|,
literal|0
argument_list|,
name|who_nvp
argument_list|,
name|perms_nvp
argument_list|,
name|sets_nvp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inherit
operator|&
name|ZFS_DELEG_PERM_LOCAL
condition|)
block|{
name|helper
argument_list|(
name|who_type
argument_list|,
name|whoid
argument_list|,
name|whostr
argument_list|,
name|ZFS_DELEG_LOCAL
argument_list|,
name|who_nvp
argument_list|,
name|perms_nvp
argument_list|,
name|sets_nvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inherit
operator|&
name|ZFS_DELEG_PERM_DESCENDENT
condition|)
block|{
name|helper
argument_list|(
name|who_type
argument_list|,
name|whoid
argument_list|,
name|whostr
argument_list|,
name|ZFS_DELEG_DESCENDENT
argument_list|,
name|who_nvp
argument_list|,
name|perms_nvp
argument_list|,
name|sets_nvp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Construct nvlist to pass down to kernel for setting/removing permissions.  *  * The nvlist is constructed as a series of nvpairs with an optional embedded  * nvlist of permissions to remove or set.  The topmost nvpairs are the actual  * base attribute named stored in the dsl.  * Arguments:  *  * whostr:   is a comma separated list of users, groups, or a single set name.  *           whostr may be null for everyone or create perms.  * who_type: is the type of entry in whostr.  Typically this will be  *           ZFS_DELEG_WHO_UNKNOWN.  * perms:    common separated list of permissions.  May be null if user  *           is requested to remove permissions by who.  * inherit:  Specifies the inheritance of the permissions.  Will be either  *           ZFS_DELEG_PERM_LOCAL and/or  ZFS_DELEG_PERM_DESCENDENT.  * nvp       The constructed nvlist to pass to zfs_perm_set().  *           The output nvp will look something like this.  *              ul$1234 -> {create ; destroy }  *              Ul$1234 -> { @myset }  *              s-$@myset - { snapshot; checksum; compression }  */
end_comment

begin_function
name|int
name|zfs_build_perms
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
name|whostr
parameter_list|,
name|char
modifier|*
name|perms
parameter_list|,
name|zfs_deleg_who_type_t
name|who_type
parameter_list|,
name|zfs_deleg_inherit_t
name|inherit
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|who_nvp
decl_stmt|;
name|nvlist_t
modifier|*
name|perms_nvp
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|sets_nvp
init|=
name|NULL
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|who_tok
decl_stmt|,
modifier|*
name|perm
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|nvp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|perms
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|nvlist_alloc
argument_list|(
operator|&
name|perms_nvp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|nvlist_alloc
argument_list|(
operator|&
name|sets_nvp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|perms_nvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|nvlist_alloc
argument_list|(
operator|&
name|who_nvp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|perms_nvp
condition|)
name|nvlist_free
argument_list|(
name|perms_nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sets_nvp
condition|)
name|nvlist_free
argument_list|(
name|sets_nvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|who_type
operator|==
name|ZFS_DELEG_NAMED_SET
condition|)
block|{
name|namecheck_err_t
name|why
decl_stmt|;
name|char
name|what
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|permset_namecheck
argument_list|(
name|whostr
argument_list|,
operator|&
name|why
argument_list|,
operator|&
name|what
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|who_nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|perms_nvp
condition|)
name|nvlist_free
argument_list|(
name|perms_nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sets_nvp
condition|)
name|nvlist_free
argument_list|(
name|sets_nvp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|NAME_ERR_NO_AT
case|:
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"set definition must begin with an '@' "
literal|"character"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_BADPERMSET
argument_list|,
name|whostr
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* 	 * Build up nvlist(s) of permissions.  Two nvlists are maintained. 	 * The first nvlist perms_nvp will have normal permissions and the 	 * other sets_nvp will have only permssion set names in it. 	 */
for|for
control|(
name|perm
operator|=
name|strtok
argument_list|(
name|perms
argument_list|,
literal|","
argument_list|)
init|;
name|perm
condition|;
name|perm
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|perm_canonical
init|=
name|zfs_deleg_canonicalize_perm
argument_list|(
name|perm
argument_list|)
decl_stmt|;
if|if
condition|(
name|perm_canonical
condition|)
block|{
name|verify
argument_list|(
name|nvlist_add_boolean
argument_list|(
name|perms_nvp
argument_list|,
name|perm_canonical
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|perm
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
name|verify
argument_list|(
name|nvlist_add_boolean
argument_list|(
name|sets_nvp
argument_list|,
name|perm
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_free
argument_list|(
name|who_nvp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|perms_nvp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|sets_nvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_BADPERM
argument_list|,
name|perm
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|whostr
operator|&&
name|who_type
operator|!=
name|ZFS_DELEG_CREATE
condition|)
block|{
name|who_tok
operator|=
name|strtok
argument_list|(
name|whostr
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|who_tok
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|who_nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|perms_nvp
condition|)
name|nvlist_free
argument_list|(
name|perms_nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sets_nvp
condition|)
name|nvlist_free
argument_list|(
name|sets_nvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Who string is NULL"
argument_list|)
argument_list|,
name|whostr
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_BADWHO
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* 	 * Now create the nvlist(s) 	 */
do|do
block|{
name|uint64_t
name|who_id
decl_stmt|;
name|error
operator|=
name|zfs_get_perm_who
argument_list|(
name|who_tok
argument_list|,
operator|&
name|who_type
argument_list|,
operator|&
name|who_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nvlist_free
argument_list|(
name|who_nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|perms_nvp
condition|)
name|nvlist_free
argument_list|(
name|perms_nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sets_nvp
condition|)
name|nvlist_free
argument_list|(
name|sets_nvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Unable to determine uid/gid for "
literal|"%s "
argument_list|)
argument_list|,
name|who_tok
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_BADWHO
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * add entries for both local and descendent when required 		 */
name|zfs_perms_add_who_nvlist
argument_list|(
name|who_nvp
argument_list|,
name|who_id
argument_list|,
name|who_tok
argument_list|,
name|perms_nvp
argument_list|,
name|sets_nvp
argument_list|,
name|who_type
argument_list|,
name|inherit
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|who_tok
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
condition|)
do|;
operator|*
name|nvp
operator|=
name|who_nvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_perm_set_common
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nvp
parameter_list|,
name|boolean_t
name|unset
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Cannot update 'allows' for '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvp
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_perm_action
operator|=
name|unset
expr_stmt|;
name|error
operator|=
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_SET_FSACL
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|errno
operator|==
name|ENOTSUP
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|gettext
argument_list|(
literal|"Pool must be upgraded to use 'allow/unallow'"
argument_list|)
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_perm_set
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nvp
parameter_list|)
block|{
return|return
operator|(
name|zfs_perm_set_common
argument_list|(
name|zhp
argument_list|,
name|nvp
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_perm_remove
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|perms
parameter_list|)
block|{
return|return
operator|(
name|zfs_perm_set_common
argument_list|(
name|zhp
argument_list|,
name|perms
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|perm_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|zfs_perm_node_t
modifier|*
name|node1
init|=
name|arg1
decl_stmt|;
specifier|const
name|zfs_perm_node_t
modifier|*
name|node2
init|=
name|arg2
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|strcmp
argument_list|(
name|node1
operator|->
name|z_pname
argument_list|,
name|node2
operator|->
name|z_pname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_destroy_perm_tree
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|)
block|{
name|zfs_perm_node_t
modifier|*
name|permnode
decl_stmt|;
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|permnode
operator|=
name|avl_destroy_nodes
argument_list|(
name|tree
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|permnode
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_destroy_tree
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|)
block|{
name|zfs_allow_node_t
modifier|*
name|allownode
decl_stmt|;
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|allownode
operator|=
name|avl_destroy_nodes
argument_list|(
name|tree
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|zfs_destroy_perm_tree
argument_list|(
operator|&
name|allownode
operator|->
name|z_localdescend
argument_list|)
expr_stmt|;
name|zfs_destroy_perm_tree
argument_list|(
operator|&
name|allownode
operator|->
name|z_local
argument_list|)
expr_stmt|;
name|zfs_destroy_perm_tree
argument_list|(
operator|&
name|allownode
operator|->
name|z_descend
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|allownode
argument_list|)
expr_stmt|;
block|}
name|avl_destroy
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zfs_free_allows
parameter_list|(
name|zfs_allow_t
modifier|*
name|allow
parameter_list|)
block|{
name|zfs_allow_t
modifier|*
name|allownext
decl_stmt|;
name|zfs_allow_t
modifier|*
name|freeallow
decl_stmt|;
name|allownext
operator|=
name|allow
expr_stmt|;
while|while
condition|(
name|allownext
condition|)
block|{
name|zfs_destroy_tree
argument_list|(
operator|&
name|allownext
operator|->
name|z_sets
argument_list|)
expr_stmt|;
name|zfs_destroy_tree
argument_list|(
operator|&
name|allownext
operator|->
name|z_crperms
argument_list|)
expr_stmt|;
name|zfs_destroy_tree
argument_list|(
operator|&
name|allownext
operator|->
name|z_user
argument_list|)
expr_stmt|;
name|zfs_destroy_tree
argument_list|(
operator|&
name|allownext
operator|->
name|z_group
argument_list|)
expr_stmt|;
name|zfs_destroy_tree
argument_list|(
operator|&
name|allownext
operator|->
name|z_everyone
argument_list|)
expr_stmt|;
name|freeallow
operator|=
name|allownext
expr_stmt|;
name|allownext
operator|=
name|allownext
operator|->
name|z_next
expr_stmt|;
name|free
argument_list|(
name|freeallow
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|zfs_allow_t
modifier|*
name|zfs_alloc_perm_tree
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_allow_t
modifier|*
name|prev
parameter_list|,
name|char
modifier|*
name|setpoint
parameter_list|)
block|{
name|zfs_allow_t
modifier|*
name|ptree
decl_stmt|;
if|if
condition|(
operator|(
name|ptree
operator|=
name|zfs_alloc
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_allow_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|ptree
operator|->
name|z_setpoint
argument_list|,
name|setpoint
argument_list|,
sizeof|sizeof
argument_list|(
name|ptree
operator|->
name|z_setpoint
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|ptree
operator|->
name|z_sets
argument_list|,
name|perm_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_allow_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_allow_node_t
argument_list|,
name|z_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|ptree
operator|->
name|z_crperms
argument_list|,
name|perm_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_allow_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_allow_node_t
argument_list|,
name|z_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|ptree
operator|->
name|z_user
argument_list|,
name|perm_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_allow_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_allow_node_t
argument_list|,
name|z_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|ptree
operator|->
name|z_group
argument_list|,
name|perm_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_allow_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_allow_node_t
argument_list|,
name|z_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|ptree
operator|->
name|z_everyone
argument_list|,
name|perm_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_allow_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_allow_node_t
argument_list|,
name|z_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|z_next
operator|=
name|ptree
expr_stmt|;
name|ptree
operator|->
name|z_next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ptree
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add permissions to the appropriate AVL permission tree.  * The appropriate tree may not be the requested tree.  * For example if ld indicates a local permission, but  * same permission also exists as a descendent permission  * then the permission will be removed from the descendent  * tree and add the the local+descendent tree.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_coalesce_perm
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_allow_node_t
modifier|*
name|allownode
parameter_list|,
name|char
modifier|*
name|perm
parameter_list|,
name|char
name|ld
parameter_list|)
block|{
name|zfs_perm_node_t
name|pnode
decl_stmt|,
modifier|*
name|permnode
decl_stmt|,
modifier|*
name|permnode2
decl_stmt|;
name|zfs_perm_node_t
modifier|*
name|newnode
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|,
name|where2
decl_stmt|;
name|avl_tree_t
modifier|*
name|tree
decl_stmt|,
modifier|*
name|altree
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pnode
operator|.
name|z_pname
argument_list|,
name|perm
argument_list|,
sizeof|sizeof
argument_list|(
name|pnode
operator|.
name|z_pname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|==
name|ZFS_DELEG_NA
condition|)
block|{
name|tree
operator|=
operator|&
name|allownode
operator|->
name|z_localdescend
expr_stmt|;
name|altree
operator|=
operator|&
name|allownode
operator|->
name|z_descend
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ld
operator|==
name|ZFS_DELEG_LOCAL
condition|)
block|{
name|tree
operator|=
operator|&
name|allownode
operator|->
name|z_local
expr_stmt|;
name|altree
operator|=
operator|&
name|allownode
operator|->
name|z_descend
expr_stmt|;
block|}
else|else
block|{
name|tree
operator|=
operator|&
name|allownode
operator|->
name|z_descend
expr_stmt|;
name|altree
operator|=
operator|&
name|allownode
operator|->
name|z_local
expr_stmt|;
block|}
name|permnode
operator|=
name|avl_find
argument_list|(
name|tree
argument_list|,
operator|&
name|pnode
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|permnode2
operator|=
name|avl_find
argument_list|(
name|altree
argument_list|,
operator|&
name|pnode
argument_list|,
operator|&
name|where2
argument_list|)
expr_stmt|;
if|if
condition|(
name|permnode2
condition|)
block|{
name|avl_remove
argument_list|(
name|altree
argument_list|,
name|permnode2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|permnode2
argument_list|)
expr_stmt|;
if|if
condition|(
name|permnode
operator|==
name|NULL
condition|)
block|{
name|tree
operator|=
operator|&
name|allownode
operator|->
name|z_localdescend
expr_stmt|;
block|}
block|}
comment|/* 	 * Now insert new permission in either requested location 	 * local/descendent or into ld when perm will exist in both. 	 */
if|if
condition|(
name|permnode
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|newnode
operator|=
name|zfs_alloc
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_perm_node_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|newnode
operator|=
name|pnode
expr_stmt|;
name|avl_add
argument_list|(
name|tree
argument_list|,
name|newnode
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Uggh, this is going to be a bit complicated.  * we have an nvlist coming out of the kernel that  * will indicate where the permission is set and then  * it will contain allow of the various "who's", and what  * their permissions are.  To further complicate this  * we will then have to coalesce the local,descendent  * and local+descendent permissions where appropriate.  * The kernel only knows about a permission as being local  * or descendent, but not both.  *  * In order to make this easier for zfs_main to deal with  * a series of AVL trees will be used to maintain  * all of this, primarily for sorting purposes as well  * as the ability to quickly locate a specific entry.  *  * What we end up with are tree's for sets, create perms,  * user, groups and everyone.  With each of those trees  * we have subtrees for local, descendent and local+descendent  * permissions.  */
end_comment

begin_function
name|int
name|zfs_perm_get
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_allow_t
modifier|*
modifier|*
name|zfs_perms
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nvlist_t
modifier|*
name|nvlist
decl_stmt|;
name|nvlist_t
modifier|*
name|permnv
decl_stmt|,
modifier|*
name|sourcenv
decl_stmt|;
name|nvpair_t
modifier|*
name|who_pair
decl_stmt|,
modifier|*
name|source_pair
decl_stmt|;
name|nvpair_t
modifier|*
name|perm_pair
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|zfs_allow_t
modifier|*
name|zallowp
decl_stmt|,
modifier|*
name|newallowp
decl_stmt|;
name|char
name|ld
decl_stmt|;
name|char
modifier|*
name|nvpname
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|avl_tree_t
modifier|*
name|tree
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_alloc_dst_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
operator|&
name|zc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_GET_FSACL
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|zcmd_expand_dst_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOTSUP
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|gettext
argument_list|(
literal|"Pool must be upgraded to use 'allow'"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|zcmd_read_dst_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
operator|&
name|zc
argument_list|,
operator|&
name|nvlist
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|source_pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvlist
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_pair
operator|==
name|NULL
condition|)
block|{
operator|*
name|zfs_perms
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|zfs_perms
operator|=
name|zfs_alloc_perm_tree
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
name|nvpair_name
argument_list|(
name|source_pair
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zfs_perms
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zallowp
operator|=
operator|*
name|zfs_perms
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|zfs_allow_node_t
modifier|*
name|allownode
decl_stmt|;
name|zfs_allow_node_t
name|findallownode
decl_stmt|;
name|zfs_allow_node_t
modifier|*
name|newallownode
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zallowp
operator|->
name|z_setpoint
argument_list|,
name|nvpair_name
argument_list|(
name|source_pair
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|zallowp
operator|->
name|z_setpoint
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|nvpair_value_nvlist
argument_list|(
name|source_pair
argument_list|,
operator|&
name|sourcenv
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|abort
goto|;
comment|/* 		 * Make sure nvlist is composed correctly 		 */
if|if
condition|(
name|zfs_deleg_verify_nvlist
argument_list|(
name|sourcenv
argument_list|)
condition|)
block|{
goto|goto
name|abort
goto|;
block|}
name|who_pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|sourcenv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|who_pair
operator|==
name|NULL
condition|)
block|{
goto|goto
name|abort
goto|;
block|}
do|do
block|{
name|error
operator|=
name|nvpair_value_nvlist
argument_list|(
name|who_pair
argument_list|,
operator|&
name|permnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|abort
goto|;
block|}
comment|/* 			 * First build up the key to use 			 * for looking up in the various 			 * who trees. 			 */
name|ld
operator|=
name|nvpair_name
argument_list|(
name|who_pair
argument_list|)
index|[
literal|1
index|]
expr_stmt|;
name|nvpname
operator|=
name|nvpair_name
argument_list|(
name|who_pair
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nvpair_name
argument_list|(
name|who_pair
argument_list|)
index|[
literal|0
index|]
condition|)
block|{
case|case
name|ZFS_DELEG_USER
case|:
case|case
name|ZFS_DELEG_USER_SETS
case|:
name|tree
operator|=
operator|&
name|zallowp
operator|->
name|z_user
expr_stmt|;
name|uid
operator|=
name|atol
argument_list|(
operator|&
name|nvpname
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|pwd
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|findallownode
operator|.
name|z_key
argument_list|,
sizeof|sizeof
argument_list|(
name|findallownode
operator|.
name|z_key
argument_list|)
argument_list|,
literal|"user %s"
argument_list|,
operator|(
name|pwd
operator|)
condition|?
name|pwd
operator|->
name|pw_name
else|:
operator|&
name|nvpair_name
argument_list|(
name|who_pair
argument_list|)
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_GROUP
case|:
case|case
name|ZFS_DELEG_GROUP_SETS
case|:
name|tree
operator|=
operator|&
name|zallowp
operator|->
name|z_group
expr_stmt|;
name|gid
operator|=
name|atol
argument_list|(
operator|&
name|nvpname
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|grp
operator|=
name|getgrgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|findallownode
operator|.
name|z_key
argument_list|,
sizeof|sizeof
argument_list|(
name|findallownode
operator|.
name|z_key
argument_list|)
argument_list|,
literal|"group %s"
argument_list|,
operator|(
name|grp
operator|)
condition|?
name|grp
operator|->
name|gr_name
else|:
operator|&
name|nvpair_name
argument_list|(
name|who_pair
argument_list|)
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_CREATE
case|:
case|case
name|ZFS_DELEG_CREATE_SETS
case|:
name|tree
operator|=
operator|&
name|zallowp
operator|->
name|z_crperms
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|findallownode
operator|.
name|z_key
argument_list|,
literal|""
argument_list|,
sizeof|sizeof
argument_list|(
name|findallownode
operator|.
name|z_key
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_EVERYONE
case|:
case|case
name|ZFS_DELEG_EVERYONE_SETS
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|findallownode
operator|.
name|z_key
argument_list|,
sizeof|sizeof
argument_list|(
name|findallownode
operator|.
name|z_key
argument_list|)
argument_list|,
literal|"everyone"
argument_list|)
expr_stmt|;
name|tree
operator|=
operator|&
name|zallowp
operator|->
name|z_everyone
expr_stmt|;
break|break;
case|case
name|ZFS_DELEG_NAMED_SET
case|:
case|case
name|ZFS_DELEG_NAMED_SET_SETS
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|findallownode
operator|.
name|z_key
argument_list|,
sizeof|sizeof
argument_list|(
name|findallownode
operator|.
name|z_key
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
operator|&
name|nvpair_name
argument_list|(
name|who_pair
argument_list|)
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|tree
operator|=
operator|&
name|zallowp
operator|->
name|z_sets
expr_stmt|;
break|break;
block|}
comment|/* 			 * Place who in tree 			 */
name|allownode
operator|=
name|avl_find
argument_list|(
name|tree
argument_list|,
operator|&
name|findallownode
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|allownode
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|newallownode
operator|=
name|zfs_alloc
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_allow_node_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|abort
goto|;
block|}
name|avl_create
argument_list|(
operator|&
name|newallownode
operator|->
name|z_localdescend
argument_list|,
name|perm_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_perm_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_perm_node_t
argument_list|,
name|z_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|newallownode
operator|->
name|z_local
argument_list|,
name|perm_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_perm_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_perm_node_t
argument_list|,
name|z_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|newallownode
operator|->
name|z_descend
argument_list|,
name|perm_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_perm_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_perm_node_t
argument_list|,
name|z_node
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|newallownode
operator|->
name|z_key
argument_list|,
name|findallownode
operator|.
name|z_key
argument_list|,
sizeof|sizeof
argument_list|(
name|findallownode
operator|.
name|z_key
argument_list|)
argument_list|)
expr_stmt|;
name|avl_insert
argument_list|(
name|tree
argument_list|,
name|newallownode
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|allownode
operator|=
name|newallownode
expr_stmt|;
block|}
comment|/* 			 * Now iterate over the permissions and 			 * place them in the appropriate local, 			 * descendent or local+descendent tree. 			 * 			 * The permissions are added to the tree 			 * via zfs_coalesce_perm(). 			 */
name|perm_pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|permnv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|perm_pair
operator|==
name|NULL
condition|)
goto|goto
name|abort
goto|;
do|do
block|{
if|if
condition|(
name|zfs_coalesce_perm
argument_list|(
name|zhp
argument_list|,
name|allownode
argument_list|,
name|nvpair_name
argument_list|(
name|perm_pair
argument_list|)
argument_list|,
name|ld
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|abort
goto|;
block|}
do|while
condition|(
name|perm_pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|permnv
argument_list|,
name|perm_pair
argument_list|)
condition|)
do|;
block|}
do|while
condition|(
name|who_pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|sourcenv
argument_list|,
name|who_pair
argument_list|)
condition|)
do|;
name|source_pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvlist
argument_list|,
name|source_pair
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_pair
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * allocate another node from the link list of 		 * zfs_allow_t structures 		 */
name|newallowp
operator|=
name|zfs_alloc_perm_tree
argument_list|(
name|zhp
argument_list|,
name|zallowp
argument_list|,
name|nvpair_name
argument_list|(
name|source_pair
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newallowp
operator|==
name|NULL
condition|)
block|{
goto|goto
name|abort
goto|;
block|}
name|zallowp
operator|=
name|newallowp
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|nvlist
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|abort
label|:
name|zfs_free_allows
argument_list|(
operator|*
name|zfs_perms
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvlist
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|zfs_deleg_perm_note
parameter_list|(
name|zfs_deleg_note_t
name|note
parameter_list|)
block|{
comment|/* 	 * Don't put newlines on end of lines 	 */
switch|switch
condition|(
name|note
condition|)
block|{
case|case
name|ZFS_DELEG_NOTE_CREATE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Must also have the 'mount' ability"
argument_list|)
operator|)
return|;
case|case
name|ZFS_DELEG_NOTE_DESTROY
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Must also have the 'mount' ability"
argument_list|)
operator|)
return|;
case|case
name|ZFS_DELEG_NOTE_SNAPSHOT
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Must also have the 'mount' ability"
argument_list|)
operator|)
return|;
case|case
name|ZFS_DELEG_NOTE_ROLLBACK
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Must also have the 'mount' ability"
argument_list|)
operator|)
return|;
case|case
name|ZFS_DELEG_NOTE_CLONE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Must also have the 'create' "
literal|"ability and 'mount'\n"
literal|"\t\t\t\tability in the origin file system"
argument_list|)
operator|)
return|;
case|case
name|ZFS_DELEG_NOTE_PROMOTE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Must also have the 'mount'\n"
literal|"\t\t\t\tand 'promote' ability in the origin file system"
argument_list|)
operator|)
return|;
case|case
name|ZFS_DELEG_NOTE_RENAME
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Must also have the 'mount' "
literal|"and 'create' \n\t\t\t\tability in the new parent"
argument_list|)
operator|)
return|;
case|case
name|ZFS_DELEG_NOTE_RECEIVE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Must also have the 'mount'"
literal|" and 'create' ability"
argument_list|)
operator|)
return|;
case|case
name|ZFS_DELEG_NOTE_USERPROP
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Allows changing any user property"
argument_list|)
operator|)
return|;
case|case
name|ZFS_DELEG_NOTE_ALLOW
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Must also have the permission that is being\n"
literal|"\t\t\t\tallowed"
argument_list|)
operator|)
return|;
case|case
name|ZFS_DELEG_NOTE_MOUNT
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Allows mount/umount of ZFS datasets"
argument_list|)
operator|)
return|;
case|case
name|ZFS_DELEG_NOTE_SHARE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Allows sharing file systems over NFS or SMB\n"
literal|"\t\t\t\tprotocols"
argument_list|)
operator|)
return|;
case|case
name|ZFS_DELEG_NOTE_NONE
case|:
default|default:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|""
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|ZFS_DELEG_SUBCOMMAND
block|,
name|ZFS_DELEG_PROP
block|,
name|ZFS_DELEG_OTHER
block|}
name|zfs_deleg_perm_type_t
typedef|;
end_typedef

begin_comment
comment|/*  * is the permission a subcommand or other?  */
end_comment

begin_function
name|zfs_deleg_perm_type_t
name|zfs_deleg_perm_type
parameter_list|(
specifier|const
name|char
modifier|*
name|perm
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|perm
argument_list|,
literal|"userprop"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ZFS_DELEG_OTHER
operator|)
return|;
else|else
return|return
operator|(
name|ZFS_DELEG_SUBCOMMAND
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|zfs_deleg_perm_type_str
parameter_list|(
name|zfs_deleg_perm_type_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ZFS_DELEG_SUBCOMMAND
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"subcommand"
argument_list|)
operator|)
return|;
case|case
name|ZFS_DELEG_PROP
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property"
argument_list|)
operator|)
return|;
case|case
name|ZFS_DELEG_OTHER
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"other"
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_deleg_prop_cb
parameter_list|(
name|int
name|prop
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
name|zfs_prop_delegatable
argument_list|(
name|prop
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-15s %-15s\n"
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
name|zfs_deleg_perm_type_str
argument_list|(
name|ZFS_DELEG_PROP
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZPROP_CONT
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_deleg_permissions
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%-15s %-15s\t%s\n\n"
argument_list|,
literal|"NAME"
argument_list|,
literal|"TYPE"
argument_list|,
literal|"NOTES"
argument_list|)
expr_stmt|;
comment|/* 	 * First print out the subcommands 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zfs_deleg_perm_tab
index|[
name|i
index|]
operator|.
name|z_perm
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-15s %-15s\t%s\n"
argument_list|,
name|zfs_deleg_perm_tab
index|[
name|i
index|]
operator|.
name|z_perm
argument_list|,
name|zfs_deleg_perm_type_str
argument_list|(
name|zfs_deleg_perm_type
argument_list|(
name|zfs_deleg_perm_tab
index|[
name|i
index|]
operator|.
name|z_perm
argument_list|)
argument_list|)
argument_list|,
name|zfs_deleg_perm_note
argument_list|(
name|zfs_deleg_perm_tab
index|[
name|i
index|]
operator|.
name|z_note
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zprop_iter
argument_list|(
name|zfs_deleg_prop_cb
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|,
name|ZFS_TYPE_DATASET
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a property name and value, set the property for the given dataset.  */
end_comment

begin_function
name|int
name|zfs_prop_set
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|char
modifier|*
name|propval
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|prop_changelist_t
modifier|*
name|cl
init|=
name|NULL
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
init|=
name|NULL
decl_stmt|,
modifier|*
name|realprops
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
name|boolean_t
name|do_prefix
decl_stmt|;
name|uint64_t
name|idx
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot set property for '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_string
argument_list|(
name|nvl
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|realprops
operator|=
name|zfs_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|,
name|nvl
argument_list|,
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
argument_list|,
name|zhp
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|nvl
operator|=
name|realprops
expr_stmt|;
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
expr_stmt|;
comment|/* We don't support those properties on FreeBSD. */
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_DEVICES
case|:
case|case
name|ZFS_PROP_ZONED
case|:
case|case
name|ZFS_PROP_SHAREISCSI
case|:
case|case
name|ZFS_PROP_ISCSIOPTIONS
case|:
case|case
name|ZFS_PROP_XATTR
case|:
case|case
name|ZFS_PROP_VSCAN
case|:
case|case
name|ZFS_PROP_NBMAND
case|:
case|case
name|ZFS_PROP_SHARESMB
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|"property '%s' not supported on FreeBSD"
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PERM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|cl
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_MOUNTPOINT
operator|&&
name|changelist_haszonedchild
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"child dataset with inherited mountpoint is used "
literal|"in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * If the dataset's canmount property is being set to noauto, 	 * then we want to prevent unmounting& remounting it. 	 */
name|do_prefix
operator|=
operator|!
operator|(
operator|(
name|prop
operator|==
name|ZFS_PROP_CANMOUNT
operator|)
operator|&&
operator|(
name|zprop_string_to_index
argument_list|(
name|prop
argument_list|,
name|propval
argument_list|,
operator|&
name|idx
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|idx
operator|==
name|ZFS_CANMOUNT_NOAUTO
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|do_prefix
operator|&&
operator|(
name|ret
operator|=
name|changelist_prefix
argument_list|(
name|cl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* 	 * Execute the corresponding ioctl() to set this property. 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_SET_PROP
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOSPC
case|:
comment|/* 			 * For quotas and reservations, ENOSPC indicates 			 * something different; setting a quota or reservation 			 * doesn't use any disk space. 			 */
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_QUOTA
case|:
case|case
name|ZFS_PROP_REFQUOTA
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"size is less than current used or "
literal|"reserved space"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPSPACE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_RESERVATION
case|:
case|case
name|ZFS_PROP_REFRESERVATION
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"size is greater than available space"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPSPACE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EBUSY
case|:
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_VOLBLOCKSIZE
condition|)
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_VOLHASDATA
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|EBUSY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EROFS
case|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_DSREADONLY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOTSUP
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool and or dataset must be upgraded to set this "
literal|"property or value"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERANGE
case|:
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_COMPRESSION
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property setting is not allowed on "
literal|"bootable datasets"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOTSUP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EOVERFLOW
case|:
comment|/* 			 * This platform can't address a volume this big. 			 */
ifdef|#
directive|ifdef
name|_ILP32
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_VOLSIZE
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_VOLTOOBIG
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* FALLTHROUGH */
default|default:
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|do_prefix
condition|)
name|ret
operator|=
name|changelist_postfix
argument_list|(
name|cl
argument_list|)
expr_stmt|;
comment|/* 		 * Refresh the statistics so the new property value 		 * is reflected. 		 */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|get_stats
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
name|error
label|:
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
condition|)
name|changelist_free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a property, inherit the value from the parent dataset.  */
end_comment

begin_function
name|int
name|zfs_prop_inherit
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|prop_changelist_t
modifier|*
name|cl
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot inherit %s for '%s'"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
operator|)
operator|==
name|ZPROP_INVAL
condition|)
block|{
comment|/* 		 * For user properties, the amount of work we have to do is very 		 * small, so just do it here. 		 */
if|if
condition|(
operator|!
name|zfs_prop_user
argument_list|(
name|propname
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid property"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|propname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_INHERIT_PROP
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Verify that this property is inheritable. 	 */
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPREADONLY
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|zfs_prop_inheritable
argument_list|(
name|prop
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPNONINHERIT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
comment|/* 	 * Check to see if the value applies to this type 	 */
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
comment|/* 	 * Normalize the name, to get rid of shorthand abbrevations. 	 */
name|propname
operator|=
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|propname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_MOUNTPOINT
operator|&&
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
operator|&&
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset is used in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Determine datasets which will be affected by this change, if any. 	 */
if|if
condition|(
operator|(
name|cl
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_MOUNTPOINT
operator|&&
name|changelist_haszonedchild
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"child dataset with inherited mountpoint is used "
literal|"in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|changelist_prefix
argument_list|(
name|cl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_INHERIT_PROP
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|changelist_postfix
argument_list|(
name|cl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* 		 * Refresh the statistics so the new property is reflected. 		 */
operator|(
name|void
operator|)
name|get_stats
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
name|error
label|:
name|changelist_free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * True DSL properties are stored in an nvlist.  The following two functions  * extract them appropriately.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|getprop_uint64
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|char
modifier|*
modifier|*
name|source
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
operator|*
name|source
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPROP_SOURCE
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|zfs_prop_default_numeric
argument_list|(
name|prop
argument_list|)
expr_stmt|;
operator|*
name|source
operator|=
literal|""
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|getprop_string
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|char
modifier|*
modifier|*
name|source
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
operator|*
name|source
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPROP_SOURCE
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|zfs_prop_default_string
argument_list|(
name|prop
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|value
operator|=
literal|""
expr_stmt|;
operator|*
name|source
operator|=
literal|""
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal function for getting a numeric property.  Both zfs_prop_get() and  * zfs_prop_get_int() are built using this interface.  *  * Certain properties can be overridden using 'mount -o'.  In this case, scan  * the contents of the /etc/mnttab entry, searching for the appropriate options.  * If they differ from the on-disk values, report the current values and mark  * the source "temporary".  */
end_comment

begin_function
specifier|static
name|int
name|get_numeric_property
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|zprop_source_t
modifier|*
name|src
parameter_list|,
name|char
modifier|*
modifier|*
name|source
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|nvlist_t
modifier|*
name|zplprops
init|=
name|NULL
decl_stmt|;
name|struct
name|mnttab
name|mnt
decl_stmt|;
name|char
modifier|*
name|mntopt_on
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|mntopt_off
init|=
name|NULL
decl_stmt|;
operator|*
name|source
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_ATIME
case|:
name|mntopt_on
operator|=
name|MNTOPT_ATIME
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NOATIME
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_DEVICES
case|:
name|mntopt_on
operator|=
name|MNTOPT_DEVICES
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NODEVICES
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_EXEC
case|:
name|mntopt_on
operator|=
name|MNTOPT_EXEC
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NOEXEC
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_READONLY
case|:
name|mntopt_on
operator|=
name|MNTOPT_RO
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_RW
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_SETUID
case|:
name|mntopt_on
operator|=
name|MNTOPT_SETUID
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NOSETUID
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_XATTR
case|:
name|mntopt_on
operator|=
name|MNTOPT_XATTR
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NOXATTR
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NBMAND
case|:
name|mntopt_on
operator|=
name|MNTOPT_NBMAND
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NONBMAND
expr_stmt|;
break|break;
block|}
comment|/* 	 * Because looking up the mount options is potentially expensive 	 * (iterating over all of /etc/mnttab), we defer its calculation until 	 * we're looking up a property which requires its presence. 	 */
if|if
condition|(
operator|!
name|zhp
operator|->
name|zfs_mntcheck
operator|&&
operator|(
name|mntopt_on
operator|!=
name|NULL
operator|||
name|prop
operator|==
name|ZFS_PROP_MOUNTED
operator|)
condition|)
block|{
name|struct
name|mnttab
name|entry
decl_stmt|,
name|search
init|=
block|{
literal|0
block|}
decl_stmt|;
name|FILE
modifier|*
name|mnttab
init|=
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_mnttab
decl_stmt|;
name|search
operator|.
name|mnt_special
operator|=
operator|(
name|char
operator|*
operator|)
name|zhp
operator|->
name|zfs_name
expr_stmt|;
name|search
operator|.
name|mnt_fstype
operator|=
name|MNTTYPE_ZFS
expr_stmt|;
name|rewind
argument_list|(
name|mnttab
argument_list|)
expr_stmt|;
if|if
condition|(
name|getmntany
argument_list|(
name|mnttab
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|search
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zhp
operator|->
name|zfs_mntopts
operator|=
name|zfs_strdup
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|entry
operator|.
name|mnt_mntopts
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_mntopts
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zhp
operator|->
name|zfs_mntcheck
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|zhp
operator|->
name|zfs_mntopts
operator|==
name|NULL
condition|)
name|mnt
operator|.
name|mnt_mntopts
operator|=
literal|""
expr_stmt|;
else|else
name|mnt
operator|.
name|mnt_mntopts
operator|=
name|zhp
operator|->
name|zfs_mntopts
expr_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_ATIME
case|:
case|case
name|ZFS_PROP_DEVICES
case|:
case|case
name|ZFS_PROP_EXEC
case|:
case|case
name|ZFS_PROP_READONLY
case|:
case|case
name|ZFS_PROP_SETUID
case|:
case|case
name|ZFS_PROP_XATTR
case|:
case|case
name|ZFS_PROP_NBMAND
case|:
operator|*
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
name|mntopt_on
argument_list|)
operator|&&
operator|!
operator|*
name|val
condition|)
block|{
operator|*
name|val
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|ZPROP_SRC_TEMPORARY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
name|mntopt_off
argument_list|)
operator|&&
operator|*
name|val
condition|)
block|{
operator|*
name|val
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|ZPROP_SRC_TEMPORARY
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_CANMOUNT
case|:
operator|*
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|val
operator|!=
name|ZFS_CANMOUNT_ON
condition|)
operator|*
name|source
operator|=
name|zhp
operator|->
name|zfs_name
expr_stmt|;
else|else
operator|*
name|source
operator|=
literal|""
expr_stmt|;
comment|/* default */
break|break;
case|case
name|ZFS_PROP_QUOTA
case|:
case|case
name|ZFS_PROP_REFQUOTA
case|:
case|case
name|ZFS_PROP_RESERVATION
case|:
case|case
name|ZFS_PROP_REFRESERVATION
case|:
operator|*
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|val
operator|==
literal|0
condition|)
operator|*
name|source
operator|=
literal|""
expr_stmt|;
comment|/* default */
else|else
operator|*
name|source
operator|=
name|zhp
operator|->
name|zfs_name
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_MOUNTED
case|:
operator|*
name|val
operator|=
operator|(
name|zhp
operator|->
name|zfs_mntopts
operator|!=
name|NULL
operator|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NUMCLONES
case|:
operator|*
name|val
operator|=
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_num_clones
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_VERSION
case|:
case|case
name|ZFS_PROP_NORMALIZE
case|:
case|case
name|ZFS_PROP_UTF8ONLY
case|:
case|case
name|ZFS_PROP_CASE
case|:
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|zhp
operator|->
name|zfs_head_type
argument_list|)
operator|||
name|zcmd_alloc_dst_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
operator|&
name|zc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_OBJSET_ZPLPROPS
argument_list|,
operator|&
name|zc
argument_list|)
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unable to get %s property"
argument_list|)
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"internal error"
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zcmd_read_dst_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
operator|&
name|zc
argument_list|,
operator|&
name|zplprops
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|zplprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
name|val
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unable to get %s property"
argument_list|)
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_NOMEM
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"internal error"
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zplprops
condition|)
name|nvlist_free
argument_list|(
name|zplprops
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|zfs_prop_get_type
argument_list|(
name|prop
argument_list|)
condition|)
block|{
case|case
name|PROP_TYPE_NUMBER
case|:
case|case
name|PROP_TYPE_INDEX
case|:
operator|*
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|source
argument_list|)
expr_stmt|;
comment|/* 			 * If we tried to use a defalut value for a 			 * readonly property, it means that it was not 			 * present; return an error. 			 */
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
operator|&&
operator|*
name|source
operator|&&
operator|(
operator|*
name|source
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|PROP_TYPE_STRING
case|:
default|default:
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get non-numeric property"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"internal error"
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the source type, given the raw source string.  */
end_comment

begin_function
specifier|static
name|void
name|get_source
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zprop_source_t
modifier|*
name|srctype
parameter_list|,
name|char
modifier|*
name|source
parameter_list|,
name|char
modifier|*
name|statbuf
parameter_list|,
name|size_t
name|statlen
parameter_list|)
block|{
if|if
condition|(
name|statbuf
operator|==
name|NULL
operator|||
operator|*
name|srctype
operator|==
name|ZPROP_SRC_TEMPORARY
condition|)
return|return;
if|if
condition|(
name|source
operator|==
name|NULL
condition|)
block|{
operator|*
name|srctype
operator|=
name|ZPROP_SRC_NONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|source
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|srctype
operator|=
name|ZPROP_SRC_DEFAULT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|source
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|srctype
operator|=
name|ZPROP_SRC_LOCAL
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|statbuf
argument_list|,
name|source
argument_list|,
name|statlen
argument_list|)
expr_stmt|;
operator|*
name|srctype
operator|=
name|ZPROP_SRC_INHERITED
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Retrieve a property from the given object.  If 'literal' is specified, then  * numbers are left as exact values.  Otherwise, numbers are converted to a  * human-readable form.  *  * Returns 0 on success, or -1 on error.  */
end_comment

begin_function
name|int
name|zfs_prop_get
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|char
modifier|*
name|propbuf
parameter_list|,
name|size_t
name|proplen
parameter_list|,
name|zprop_source_t
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|statbuf
parameter_list|,
name|size_t
name|statlen
parameter_list|,
name|boolean_t
name|literal
parameter_list|)
block|{
name|char
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|strval
decl_stmt|;
comment|/* 	 * Check to see if this property applies to our object 	 */
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|ZPROP_SRC_NONE
expr_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_CREATION
case|:
comment|/* 		 * 'creation' is a time_t stored in the statistics.  We convert 		 * this into a string unless 'literal' is specified. 		 */
block|{
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|source
argument_list|)
expr_stmt|;
name|time_t
name|time
init|=
operator|(
name|time_t
operator|)
name|val
decl_stmt|;
name|struct
name|tm
name|t
decl_stmt|;
if|if
condition|(
name|literal
operator|||
name|localtime_r
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|t
argument_list|)
operator|==
name|NULL
operator|||
name|strftime
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%a %b %e %k:%M %Y"
argument_list|,
operator|&
name|t
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%llu"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_MOUNTPOINT
case|:
comment|/* 		 * Getting the precise mountpoint can be tricky. 		 * 		 *  - for 'none' or 'legacy', return those values. 		 *  - for inherited mountpoints, we want to take everything 		 *    after our ancestor and append it to the inherited value. 		 * 		 * If the pool has an alternate root, we want to prepend that 		 * root to any values we return. 		 */
name|str
operator|=
name|getprop_string
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|root
init|=
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|zhp
operator|->
name|zfs_name
operator|+
name|strlen
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|relpath
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|relpath
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|zpool_get_prop
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|ZPOOL_PROP_ALTROOT
argument_list|,
name|buf
argument_list|,
name|MAXPATHLEN
argument_list|,
name|NULL
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|root
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|root
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * Special case an alternate root of '/'. This will 			 * avoid having multiple leading slashes in the 			 * mountpoint path. 			 */
if|if
condition|(
name|strcmp
argument_list|(
name|root
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
name|root
operator|++
expr_stmt|;
comment|/* 			 * If the mountpoint is '/' then skip over this 			 * if we are obtaining either an alternate root or 			 * an inherited mountpoint. 			 */
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|root
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|relpath
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|relpath
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%s%s"
argument_list|,
name|root
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%s%s%s%s"
argument_list|,
name|root
argument_list|,
name|str
argument_list|,
name|relpath
index|[
literal|0
index|]
operator|==
literal|'@'
condition|?
literal|""
else|:
literal|"/"
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 'legacy' or 'none' */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|str
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_ORIGIN
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|getprop_string
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|source
argument_list|)
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
comment|/* 		 * If there is no parent at all, return failure to indicate that 		 * it doesn't apply to this dataset. 		 */
if|if
condition|(
name|propbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
name|ZFS_PROP_QUOTA
case|:
case|case
name|ZFS_PROP_REFQUOTA
case|:
case|case
name|ZFS_PROP_RESERVATION
case|:
case|case
name|ZFS_PROP_REFRESERVATION
case|:
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * If quota or reservation is 0, we translate this into 'none' 		 * (unless literal is set), and indicate that it's the default 		 * value.  Otherwise, we print the number nicely and indicate 		 * that its set locally. 		 */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|literal
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"0"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"none"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|literal
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|val
argument_list|)
expr_stmt|;
else|else
name|zfs_nicenum
argument_list|(
name|val
argument_list|,
name|propbuf
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_COMPRESSRATIO
case|:
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%lld.%02lldx"
argument_list|,
operator|(
name|longlong_t
operator|)
name|val
operator|/
literal|100
argument_list|,
operator|(
name|longlong_t
operator|)
name|val
operator|%
literal|100
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_TYPE
case|:
switch|switch
condition|(
name|zhp
operator|->
name|zfs_type
condition|)
block|{
case|case
name|ZFS_TYPE_FILESYSTEM
case|:
name|str
operator|=
literal|"filesystem"
expr_stmt|;
break|break;
case|case
name|ZFS_TYPE_VOLUME
case|:
name|str
operator|=
literal|"volume"
expr_stmt|;
break|break;
case|case
name|ZFS_TYPE_SNAPSHOT
case|:
name|str
operator|=
literal|"snapshot"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_MOUNTED
case|:
comment|/* 		 * The 'mounted' property is a pseudo-property that described 		 * whether the filesystem is currently mounted.  Even though 		 * it's a boolean value, the typical values of "on" and "off" 		 * don't make sense, so we translate to "yes" and "no". 		 */
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTED
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|val
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"yes"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"no"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NAME
case|:
comment|/* 		 * The 'name' property is a pseudo-property derived from the 		 * dataset name.  It is presented as a real property to simplify 		 * consumers. 		 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|zfs_prop_get_type
argument_list|(
name|prop
argument_list|)
condition|)
block|{
case|case
name|PROP_TYPE_NUMBER
case|:
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|literal
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|val
argument_list|)
expr_stmt|;
else|else
name|zfs_nicenum
argument_list|(
name|val
argument_list|,
name|propbuf
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_TYPE_STRING
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|getprop_string
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|source
argument_list|)
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_TYPE_INDEX
case|:
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zfs_prop_index_to_string
argument_list|(
name|prop
argument_list|,
name|val
argument_list|,
operator|&
name|strval
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|strval
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|get_source
argument_list|(
name|zhp
argument_list|,
name|src
argument_list|,
name|source
argument_list|,
name|statbuf
argument_list|,
name|statlen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility function to get the given numeric property.  Does no validation that  * the given property is the appropriate type; should only be used with  * hard-coded property types.  */
end_comment

begin_function
name|uint64_t
name|zfs_prop_get_int
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|)
block|{
name|char
modifier|*
name|source
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|NULL
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_prop_set_int
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|zfs_nicenum
argument_list|(
name|val
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_prop_set
argument_list|(
name|zhp
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Similar to zfs_prop_get(), but returns the value as an integer.  */
end_comment

begin_function
name|int
name|zfs_prop_get_numeric
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|uint64_t
modifier|*
name|value
parameter_list|,
name|zprop_source_t
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|statbuf
parameter_list|,
name|size_t
name|statlen
parameter_list|)
block|{
name|char
modifier|*
name|source
decl_stmt|;
comment|/* 	 * Check to see if this property applies to our object 	 */
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|)
condition|)
block|{
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_PROPTYPE
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get property '%s'"
argument_list|)
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|ZPROP_SRC_NONE
expr_stmt|;
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
name|value
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|get_source
argument_list|(
name|zhp
argument_list|,
name|src
argument_list|,
name|source
argument_list|,
name|statbuf
argument_list|,
name|statlen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the name of the given zfs handle.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zfs_get_name
parameter_list|(
specifier|const
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zfs_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the type of the given zfs handle.  */
end_comment

begin_function
name|zfs_type_t
name|zfs_get_type
parameter_list|(
specifier|const
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zfs_type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all child filesystems  */
end_comment

begin_function
name|int
name|zfs_iter_filesystems
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_iter_f
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zfs_handle_t
modifier|*
name|nzhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|!=
name|ZFS_TYPE_FILESYSTEM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
init|;
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_DATASET_LIST_NEXT
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
control|)
block|{
comment|/* 		 * Ignore private dataset names. 		 */
if|if
condition|(
name|dataset_name_hidden
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Silently ignore errors, as the only plausible explanation is 		 * that the pool has since been removed. 		 */
if|if
condition|(
operator|(
name|nzhp
operator|=
name|make_dataset_handle
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ret
operator|=
name|func
argument_list|(
name|nzhp
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * An errno value of ESRCH indicates normal completion.  If ENOENT is 	 * returned, then the underlying dataset has been removed since we 	 * obtained the handle. 	 */
if|if
condition|(
name|errno
operator|!=
name|ESRCH
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot iterate filesystems"
argument_list|)
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all snapshots  */
end_comment

begin_function
name|int
name|zfs_iter_snapshots
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_iter_f
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zfs_handle_t
modifier|*
name|nzhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
init|;
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SNAPSHOT_LIST_NEXT
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|nzhp
operator|=
name|make_dataset_handle
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ret
operator|=
name|func
argument_list|(
name|nzhp
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * An errno value of ESRCH indicates normal completion.  If ENOENT is 	 * returned, then the underlying dataset has been removed since we 	 * obtained the handle.  Silently ignore this case, and return success. 	 */
if|if
condition|(
name|errno
operator|!=
name|ESRCH
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot iterate filesystems"
argument_list|)
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all children, snapshots and filesystems  */
end_comment

begin_function
name|int
name|zfs_iter_children
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_iter_f
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|func
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
return|return
operator|(
name|zfs_iter_snapshots
argument_list|(
name|zhp
argument_list|,
name|func
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a complete name, return just the portion that refers to the parent.  * Can return NULL if this is a pool.  */
end_comment

begin_function
specifier|static
name|int
name|parent_name
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|char
modifier|*
name|loc
decl_stmt|;
if|if
condition|(
operator|(
name|loc
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|path
argument_list|,
name|MIN
argument_list|(
name|buflen
argument_list|,
name|loc
operator|-
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|loc
operator|-
name|path
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If accept_ancestor is false, then check to make sure that the given path has  * a parent, and that it exists.  If accept_ancestor is true, then find the  * closest existing ancestor for the given path.  In prefixlen return the  * length of already existing prefix of the given path.  We also fetch the  * 'zoned' property, which is used to validate property settings when creating  * new datasets.  */
end_comment

begin_function
specifier|static
name|int
name|check_parents
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|uint64_t
modifier|*
name|zoned
parameter_list|,
name|boolean_t
name|accept_ancestor
parameter_list|,
name|int
modifier|*
name|prefixlen
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|parent
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|"cannot create '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* get parent, and check to see if this is just a pool */
if|if
condition|(
name|parent_name
argument_list|(
name|path
argument_list|,
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"missing dataset name"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* check to see if the pool exists */
if|if
condition|(
operator|(
name|slash
operator|=
name|strchr
argument_list|(
name|parent
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|slash
operator|=
name|parent
operator|+
name|strlen
argument_list|(
name|parent
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|parent
argument_list|,
name|slash
operator|-
name|parent
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_name
index|[
name|slash
operator|-
name|parent
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such pool '%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* check to see if the parent dataset exists */
while|while
condition|(
operator|(
name|zhp
operator|=
name|make_dataset_handle
argument_list|(
name|hdl
argument_list|,
name|parent
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
operator|&&
name|accept_ancestor
condition|)
block|{
comment|/* 			 * Go deeper to find an ancestor, give up on top level. 			 */
if|if
condition|(
name|parent_name
argument_list|(
name|parent
argument_list|,
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such pool '%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"parent does not exist"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
operator|*
name|zoned
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
expr_stmt|;
comment|/* we are in a non-global zone, but parent is in the global zone */
if|if
condition|(
name|getzoneid
argument_list|()
operator|!=
name|GLOBAL_ZONEID
operator|&&
operator|!
operator|(
operator|*
name|zoned
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|EPERM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* make sure parent is a filesystem */
if|if
condition|(
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|!=
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"parent is not a filesystem"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefixlen
operator|!=
name|NULL
condition|)
operator|*
name|prefixlen
operator|=
name|strlen
argument_list|(
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finds whether the dataset of the given type(s) exists.  */
end_comment

begin_function
name|boolean_t
name|zfs_dataset_exists
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|zfs_type_t
name|types
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|types
argument_list|,
name|B_FALSE
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
comment|/* 	 * Try to get stats for the dataset, which will tell us if it exists. 	 */
if|if
condition|(
operator|(
name|zhp
operator|=
name|make_dataset_handle
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|ds_type
init|=
name|zhp
operator|->
name|zfs_type
decl_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|types
operator|&
name|ds_type
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a path to 'target', create all the ancestors between  * the prefixlen portion of the path, and the target itself.  * Fail if the initial prefixlen-ancestor does not already exist.  */
end_comment

begin_function
name|int
name|create_parents
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|int
name|prefixlen
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
comment|/* make sure prefix exists */
name|cp
operator|=
name|target
operator|+
name|prefixlen
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'/'
condition|)
block|{
name|assert
argument_list|(
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|h
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zfs_close
argument_list|(
name|h
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to create, mount, and share any ancestor filesystems, 	 * up to the prefixlen-long one. 	 */
for|for
control|(
name|cp
operator|=
name|target
operator|+
name|prefixlen
operator|+
literal|1
init|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
condition|;
operator|*
name|cp
operator|=
literal|'/'
operator|,
name|cp
operator|++
control|)
block|{
name|char
modifier|*
name|logstr
decl_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|h
operator|=
name|make_dataset_handle
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
comment|/* it already exists, nothing to do here */
name|zfs_close
argument_list|(
name|h
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|logstr
operator|=
name|hdl
operator|->
name|libzfs_log_str
expr_stmt|;
name|hdl
operator|->
name|libzfs_log_str
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zfs_create
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|hdl
operator|->
name|libzfs_log_str
operator|=
name|logstr
expr_stmt|;
name|opname
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"create"
argument_list|)
expr_stmt|;
goto|goto
name|ancestorerr
goto|;
block|}
name|hdl
operator|->
name|libzfs_log_str
operator|=
name|logstr
expr_stmt|;
name|h
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|opname
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"open"
argument_list|)
expr_stmt|;
goto|goto
name|ancestorerr
goto|;
block|}
if|if
condition|(
name|zfs_mount
argument_list|(
name|h
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|opname
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"mount"
argument_list|)
expr_stmt|;
goto|goto
name|ancestorerr
goto|;
block|}
if|if
condition|(
name|zfs_share
argument_list|(
name|h
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|opname
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"share"
argument_list|)
expr_stmt|;
goto|goto
name|ancestorerr
goto|;
block|}
name|zfs_close
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|ancestorerr
label|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"failed to %s ancestor '%s'"
argument_list|)
argument_list|,
name|opname
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Creates non-existing ancestors of the given path.  */
end_comment

begin_function
name|int
name|zfs_create_ancestors
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|prefix
decl_stmt|;
name|uint64_t
name|zoned
decl_stmt|;
name|char
modifier|*
name|path_copy
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|check_parents
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
operator|&
name|zoned
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|prefix
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|path_copy
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rc
operator|=
name|create_parents
argument_list|(
name|hdl
argument_list|,
name|path_copy
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path_copy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path_copy
operator|==
name|NULL
operator|||
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new filesystem or volume.  */
end_comment

begin_function
name|int
name|zfs_create
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|zfs_type_t
name|type
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|uint64_t
name|size
init|=
literal|0
decl_stmt|;
name|uint64_t
name|blocksize
init|=
name|zfs_prop_default_numeric
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|uint64_t
name|zoned
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* validate the path, taking care to note the extended error message */
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|type
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
comment|/* validate parents exist */
if|if
condition|(
name|check_parents
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
operator|&
name|zoned
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * The failure modes when creating a dataset of a different type over 	 * one that already exists is a little strange.  In particular, if you 	 * try to create a dataset on top of an existing dataset, the ioctl() 	 * will return ENOENT, not EEXIST.  To prevent this from happening, we 	 * first try to see if the dataset exists. 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset already exists"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
else|else
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
if|if
condition|(
name|props
operator|&&
operator|(
name|props
operator|=
name|zfs_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|type
argument_list|,
name|props
argument_list|,
name|zoned
argument_list|,
name|NULL
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
comment|/* 		 * If we are creating a volume, the size and block size must 		 * satisfy a few restraints.  First, the blocksize must be a 		 * valid block size between SPA_{MIN,MAX}BLOCKSIZE.  Second, the 		 * volsize must be a multiple of the block size, and cannot be 		 * zero. 		 */
if|if
condition|(
name|props
operator|==
name|NULL
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|,
operator|&
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"missing volume size"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|nvlist_lookup_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
operator|&
name|blocksize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|ENOENT
condition|)
block|{
name|blocksize
operator|=
name|zfs_prop_default_numeric
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"missing volume block size"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume size cannot be zero"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|%
name|blocksize
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume size must be a multiple of volume block "
literal|"size"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|props
operator|&&
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|props
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
comment|/* create the dataset */
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_CREATE
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
name|ret
operator|=
name|zvol_create_link
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Volume successfully created, but device links "
literal|"were not created"
argument_list|)
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
comment|/* check for failure */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|char
name|parent
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|parent_name
argument_list|(
name|path
argument_list|,
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such parent '%s'"
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|EINVAL
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"parent '%s' is not a filesystem"
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|EDOM
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume block size must be power of 2 from "
literal|"%u to %uk"
argument_list|)
argument_list|,
operator|(
name|uint_t
operator|)
name|SPA_MINBLOCKSIZE
argument_list|,
operator|(
name|uint_t
operator|)
name|SPA_MAXBLOCKSIZE
operator|>>
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|ENOTSUP
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgraded to set this "
literal|"property or value"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|_ILP32
case|case
name|EOVERFLOW
case|:
comment|/* 			 * This platform can't address a volume this big. 			 */
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_VOLTOOBIG
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* FALLTHROUGH */
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroys the given dataset.  The caller must make sure that the filesystem  * isn't mounted, and that there are no active dependents.  */
end_comment

begin_function
name|int
name|zfs_destroy
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
comment|/* 		 * If user doesn't have permissions to unshare volume, then 		 * abort the request.  This would only happen for a 		 * non-privileged user. 		 */
if|if
condition|(
name|zfs_unshare_iscsi
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zvol_remove_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
block|}
else|else
block|{
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
block|}
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_DESTROY
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|zfs_standard_error_fmt
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot destroy '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|)
return|;
block|}
name|remove_mountpoint
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|destroydata
block|{
name|char
modifier|*
name|snapname
decl_stmt|;
name|boolean_t
name|gotone
decl_stmt|;
name|boolean_t
name|closezhp
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|zfs_remove_link_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|destroydata
modifier|*
name|dd
init|=
name|arg
decl_stmt|;
name|zfs_handle_t
modifier|*
name|szhp
decl_stmt|;
name|char
name|name
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|boolean_t
name|closezhp
init|=
name|dd
operator|->
name|closezhp
decl_stmt|;
name|int
name|rv
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|name
argument_list|,
literal|"@"
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|name
argument_list|,
name|dd
operator|->
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|szhp
operator|=
name|make_dataset_handle
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|szhp
condition|)
block|{
name|dd
operator|->
name|gotone
operator|=
name|B_TRUE
expr_stmt|;
name|zfs_close
argument_list|(
name|szhp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_remove_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * NB: this is simply a best-effort.  We don't want to 		 * return an error, because then we wouldn't visit all 		 * the volumes. 		 */
block|}
name|dd
operator|->
name|closezhp
operator|=
name|B_TRUE
expr_stmt|;
name|rv
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|zfs_remove_link_cb
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|closezhp
condition|)
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroys all snapshots with the given name in zhp& descendants.  */
end_comment

begin_function
name|int
name|zfs_destroy_snaps
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
name|snapname
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|destroydata
name|dd
init|=
block|{
literal|0
block|}
decl_stmt|;
name|dd
operator|.
name|snapname
operator|=
name|snapname
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_remove_link_cb
argument_list|(
name|zhp
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dd
operator|.
name|gotone
condition|)
block|{
return|return
operator|(
name|zfs_standard_error_fmt
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ENOENT
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot destroy '%s@%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|snapname
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_DESTROY_SNAPS
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot destroy '%s@%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EEXIST
case|:
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot is cloned"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clones the given dataset.  The target must be of the same type as the source.  */
end_comment

begin_function
name|int
name|zfs_clone
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|parent
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|zfs_type_t
name|type
decl_stmt|;
name|uint64_t
name|zoned
decl_stmt|;
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create '%s'"
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* validate the target name */
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
comment|/* validate parents exist */
if|if
condition|(
name|check_parents
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
operator|&
name|zoned
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|parent_name
argument_list|(
name|target
argument_list|,
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do the clone */
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
name|type
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
block|}
else|else
block|{
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
name|type
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
block|}
if|if
condition|(
name|props
condition|)
block|{
if|if
condition|(
operator|(
name|props
operator|=
name|zfs_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|type
argument_list|,
name|props
argument_list|,
name|zoned
argument_list|,
name|zhp
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|props
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_CREATE
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
comment|/* 			 * The parent doesn't exist.  We should have caught this 			 * above, but there may a race condition that has since 			 * destroyed the parent. 			 * 			 * At this point, we don't know whether it's the source 			 * that doesn't exist anymore, or whether the target 			 * dataset doesn't exist. 			 */
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such parent '%s'"
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|EXDEV
case|:
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"source and target pools differ"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_CROSSTARGET
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
name|ret
operator|=
name|zvol_create_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|promote_data
block|{
name|char
name|cb_mountpoint
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cb_target
decl_stmt|;
specifier|const
name|char
modifier|*
name|cb_errbuf
decl_stmt|;
name|uint64_t
name|cb_pivot_txg
decl_stmt|;
block|}
name|promote_data_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|promote_snap_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|promote_data_t
modifier|*
name|pd
init|=
name|data
decl_stmt|;
name|zfs_handle_t
modifier|*
name|szhp
decl_stmt|;
name|char
name|snapname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
comment|/* We don't care about snapshots after the pivot point */
if|if
condition|(
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
operator|>
name|pd
operator|->
name|cb_pivot_txg
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Remove the device link if it's a zvol. */
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|zvol_remove_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
comment|/* Check for conflicting names */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|snapname
argument_list|,
name|pd
operator|->
name|cb_target
argument_list|,
sizeof|sizeof
argument_list|(
name|snapname
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|snapname
argument_list|,
name|strchr
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
literal|'@'
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|snapname
argument_list|)
argument_list|)
expr_stmt|;
name|szhp
operator|=
name|make_dataset_handle
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|szhp
operator|!=
name|NULL
condition|)
block|{
name|zfs_close
argument_list|(
name|szhp
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot name '%s' from origin \n"
literal|"conflicts with '%s' from target"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
name|rv
operator|=
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|pd
operator|->
name|cb_errbuf
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|promote_snap_done_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|promote_data_t
modifier|*
name|pd
init|=
name|data
decl_stmt|;
comment|/* We don't care about snapshots after the pivot point */
if|if
condition|(
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
operator|<=
name|pd
operator|->
name|cb_pivot_txg
condition|)
block|{
comment|/* Create the device link if it's a zvol. */
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|zvol_create_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Promotes the given clone fs to be the clone parent.  */
end_comment

begin_function
name|int
name|zfs_promote
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|parent
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|zfs_handle_t
modifier|*
name|pzhp
decl_stmt|;
name|promote_data_t
name|pd
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot promote '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshots can not be promoted"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|parent
argument_list|,
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_origin
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"not a cloned filesystem"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|parent
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Walk the snapshots we will be moving */
name|pzhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_origin
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzhp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|pd
operator|.
name|cb_pivot_txg
operator|=
name|zfs_prop_get_int
argument_list|(
name|pzhp
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|pzhp
argument_list|)
expr_stmt|;
name|pd
operator|.
name|cb_target
operator|=
name|zhp
operator|->
name|zfs_name
expr_stmt|;
name|pd
operator|.
name|cb_errbuf
operator|=
name|errbuf
expr_stmt|;
name|pzhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|parent
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzhp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|zfs_prop_get
argument_list|(
name|pzhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|pd
operator|.
name|cb_mountpoint
argument_list|,
sizeof|sizeof
argument_list|(
name|pd
operator|.
name|cb_mountpoint
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_iter_snapshots
argument_list|(
name|pzhp
argument_list|,
name|promote_snap_cb
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|pzhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* issue the ioctl */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_origin
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_PROMOTE
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|zfs_iter_snapshots
argument_list|(
name|pzhp
argument_list|,
name|promote_snap_done_cb
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|pzhp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|save_errno
condition|)
block|{
case|case
name|EEXIST
case|:
comment|/* 			 * There is a conflicting snapshot name.  We 			 * should have caught this above, but they could 			 * have renamed something in the mean time. 			 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"conflicting snapshot name from parent '%s'"
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|save_errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|zfs_iter_snapshots
argument_list|(
name|zhp
argument_list|,
name|promote_snap_done_cb
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|pzhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|createdata
block|{
specifier|const
name|char
modifier|*
name|cd_snapname
decl_stmt|;
name|int
name|cd_ifexists
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|zfs_create_link_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|createdata
modifier|*
name|cd
init|=
name|arg
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
name|char
name|name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|name
argument_list|,
literal|"@"
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|name
argument_list|,
name|cd
operator|->
name|cd_snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zvol_create_link_common
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|name
argument_list|,
name|cd
operator|->
name|cd_ifexists
argument_list|)
expr_stmt|;
comment|/* 		 * NB: this is simply a best-effort.  We don't want to 		 * return an error, because then we wouldn't visit all 		 * the volumes. 		 */
block|}
name|ret
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|zfs_create_link_cb
argument_list|,
name|cd
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Takes a snapshot of the given dataset.  */
end_comment

begin_function
name|int
name|zfs_snapshot
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|boolean_t
name|recursive
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|delim
decl_stmt|;
name|char
name|parent
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot snapshot '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* validate the target name */
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
if|if
condition|(
name|props
condition|)
block|{
if|if
condition|(
operator|(
name|props
operator|=
name|zfs_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|,
name|props
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|props
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|}
comment|/* make sure the parent exists and is of the appropriate type */
name|delim
operator|=
name|strchr
argument_list|(
name|path
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|parent
argument_list|,
name|path
argument_list|,
name|delim
operator|-
name|path
argument_list|)
expr_stmt|;
name|parent
index|[
name|delim
operator|-
name|path
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|parent
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|delim
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
else|else
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|recursive
expr_stmt|;
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_SNAPSHOT
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
comment|/* 	 * if it was recursive, the one that actually failed will be in 	 * zc.zc_name. 	 */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create snapshot '%s@%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|recursive
condition|)
block|{
name|struct
name|createdata
name|cd
decl_stmt|;
name|cd
operator|.
name|cd_snapname
operator|=
name|delim
operator|+
literal|1
expr_stmt|;
name|cd
operator|.
name|cd_ifexists
operator|=
name|B_FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|zfs_create_link_cb
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
name|ret
operator|=
name|zvol_create_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Volume successfully snapshotted, but device links "
literal|"were not created"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy any more recent snapshots.  We invoke this callback on any dependents  * of the snapshot first.  If the 'cb_dependent' member is non-zero, then this  * is a dependent and we should just destroy it without checking the transaction  * group.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rollback_data
block|{
specifier|const
name|char
modifier|*
name|cb_target
decl_stmt|;
comment|/* the snapshot */
name|uint64_t
name|cb_create
decl_stmt|;
comment|/* creation time reference */
name|boolean_t
name|cb_error
decl_stmt|;
name|boolean_t
name|cb_dependent
decl_stmt|;
name|boolean_t
name|cb_force
decl_stmt|;
block|}
name|rollback_data_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|rollback_destroy
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rollback_data_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_dependent
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|cbp
operator|->
name|cb_target
argument_list|)
operator|!=
literal|0
operator|&&
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_SNAPSHOT
operator|&&
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
operator|>
name|cbp
operator|->
name|cb_create
condition|)
block|{
name|char
modifier|*
name|logstr
decl_stmt|;
name|cbp
operator|->
name|cb_dependent
operator|=
name|B_TRUE
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator||=
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_FALSE
argument_list|,
name|rollback_destroy
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_dependent
operator|=
name|B_FALSE
expr_stmt|;
name|logstr
operator|=
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_log_str
expr_stmt|;
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_log_str
operator|=
name|NULL
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator||=
name|zfs_destroy
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_log_str
operator|=
name|logstr
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We must destroy this clone; first unmount it */
name|prop_changelist_t
modifier|*
name|clp
decl_stmt|;
name|clp
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_NAME
argument_list|,
literal|0
argument_list|,
name|cbp
operator|->
name|cb_force
condition|?
name|MS_FORCE
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
operator|||
name|changelist_prefix
argument_list|(
name|clp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cbp
operator|->
name|cb_error
operator|=
name|B_TRUE
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zfs_destroy
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
name|cbp
operator|->
name|cb_error
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|changelist_remove
argument_list|(
name|clp
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|changelist_postfix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a dataset, rollback to a specific snapshot, discarding any  * data changes since then and making it the active dataset.  *  * Any snapshots more recent than the target are destroyed, along with  * their dependents.  */
end_comment

begin_function
name|int
name|zfs_rollback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_handle_t
modifier|*
name|snap
parameter_list|,
name|boolean_t
name|force
parameter_list|)
block|{
name|rollback_data_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|err
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|boolean_t
name|restore_resv
init|=
literal|0
decl_stmt|;
name|uint64_t
name|old_volsize
decl_stmt|,
name|new_volsize
decl_stmt|;
name|zfs_prop_t
name|resv_prop
decl_stmt|;
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_FILESYSTEM
operator|||
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy all recent snapshots and its dependends. 	 */
name|cb
operator|.
name|cb_force
operator|=
name|force
expr_stmt|;
name|cb
operator|.
name|cb_target
operator|=
name|snap
operator|->
name|zfs_name
expr_stmt|;
name|cb
operator|.
name|cb_create
operator|=
name|zfs_prop_get_int
argument_list|(
name|snap
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_iter_children
argument_list|(
name|zhp
argument_list|,
name|rollback_destroy
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_error
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Now that we have verified that the snapshot is the latest, 	 * rollback to the given snapshot. 	 */
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
if|if
condition|(
name|zvol_remove_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zfs_which_resv_prop
argument_list|(
name|zhp
argument_list|,
operator|&
name|resv_prop
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|old_volsize
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|)
expr_stmt|;
name|restore_resv
operator|=
operator|(
name|old_volsize
operator|==
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|resv_prop
argument_list|)
operator|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
else|else
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
comment|/* 	 * We rely on zfs_iter_children() to verify that there are no 	 * newer snapshots for the given dataset.  Therefore, we can 	 * simply pass the name on to the ioctl() call.  There is still 	 * an unlikely race condition where the user has taken a 	 * snapshot since we verified that this was the most recent. 	 * 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_ROLLBACK
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_standard_error_fmt
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot rollback '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * For volumes, if the pre-rollback volsize matched the pre- 	 * rollback reservation and the volsize has changed then set 	 * the reservation property to the post-rollback volsize. 	 * Make a new handle since the rollback closed the dataset. 	 */
if|if
condition|(
operator|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
operator|)
operator|&&
operator|(
name|zhp
operator|=
name|make_dataset_handle
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|err
operator|=
name|zvol_create_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|restore_resv
condition|)
block|{
name|new_volsize
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_volsize
operator|!=
name|new_volsize
condition|)
name|err
operator|=
name|zfs_prop_set_int
argument_list|(
name|zhp
argument_list|,
name|resv_prop
argument_list|,
name|new_volsize
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all dependents for a given dataset.  This includes both  * hierarchical dependents (children) and data dependents (snapshots and  * clones).  The bulk of the processing occurs in get_dependents() in  * libzfs_graph.c.  */
end_comment

begin_function
name|int
name|zfs_iter_dependents
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|boolean_t
name|allowrecursion
parameter_list|,
name|zfs_iter_f
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|dependents
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|zfs_handle_t
modifier|*
name|child
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|get_dependents
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|allowrecursion
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
operator|&
name|dependents
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|child
operator|=
name|make_dataset_handle
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dependents
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ret
operator|=
name|func
argument_list|(
name|child
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|dependents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dependents
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Renames the given dataset.  */
end_comment

begin_function
name|int
name|zfs_rename
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|boolean_t
name|recursive
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|delim
decl_stmt|;
name|prop_changelist_t
modifier|*
name|cl
init|=
name|NULL
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhrp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|parentname
init|=
name|NULL
decl_stmt|;
name|char
name|parent
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
comment|/* if we have the same exact name, just return success */
if|if
condition|(
name|strcmp
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|target
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot rename to '%s'"
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the target name is valid 	 */
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
block|{
if|if
condition|(
operator|(
name|strchr
argument_list|(
name|target
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|*
name|target
operator|==
literal|'@'
condition|)
block|{
comment|/* 			 * Snapshot target name is abbreviated, 			 * reconstruct full dataset name 			 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|parent
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|delim
operator|=
name|strchr
argument_list|(
name|parent
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|target
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
operator|*
operator|(
operator|++
name|delim
operator|)
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
name|delim
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|parent
argument_list|,
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|parent
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Make sure we're renaming within the same dataset. 			 */
name|delim
operator|=
name|strchr
argument_list|(
name|target
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|target
argument_list|,
name|delim
operator|-
name|target
argument_list|)
operator|!=
literal|0
operator|||
name|zhp
operator|->
name|zfs_name
index|[
name|delim
operator|-
name|target
index|]
operator|!=
literal|'@'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshots must be part of same "
literal|"dataset"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_CROSSTARGET
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|recursive
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"recursive rename must be a snapshot"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
name|uint64_t
name|unused
decl_stmt|;
comment|/* validate parents */
if|if
condition|(
name|check_parents
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
operator|&
name|unused
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|parent_name
argument_list|(
name|target
argument_list|,
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make sure we're in the same pool */
name|verify
argument_list|(
operator|(
name|delim
operator|=
name|strchr
argument_list|(
name|target
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|target
argument_list|,
name|delim
operator|-
name|target
argument_list|)
operator|!=
literal|0
operator|||
name|zhp
operator|->
name|zfs_name
index|[
name|delim
operator|-
name|target
index|]
operator|!=
literal|'/'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"datasets must be within same pool"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_CROSSTARGET
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* new name cannot be a child of the current dataset name */
if|if
condition|(
name|strncmp
argument_list|(
name|parent
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|strlen
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"New dataset name cannot be a descendent of "
literal|"current dataset name"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot rename '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
operator|&&
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset is used in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|recursive
condition|)
block|{
name|struct
name|destroydata
name|dd
decl_stmt|;
name|parentname
operator|=
name|zfs_strdup
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentname
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|delim
operator|=
name|strchr
argument_list|(
name|parentname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|delim
operator|=
literal|'\0'
expr_stmt|;
name|zhrp
operator|=
name|zfs_open
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|parentname
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhrp
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|dd
operator|.
name|snapname
operator|=
name|delim
operator|+
literal|1
expr_stmt|;
name|dd
operator|.
name|gotone
operator|=
name|B_FALSE
expr_stmt|;
name|dd
operator|.
name|closezhp
operator|=
name|B_TRUE
expr_stmt|;
comment|/* We remove any zvol links prior to renaming them */
name|ret
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhrp
argument_list|,
name|zfs_remove_link_cb
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cl
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_NAME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|changelist_haszonedchild
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"child dataset with inherited mountpoint is used "
literal|"in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|changelist_prefix
argument_list|(
name|cl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
else|else
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|recursive
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_RENAME
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * if it was recursive, the one that actually failed will 		 * be in zc.zc_name 		 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot rename '%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|recursive
operator|&&
name|errno
operator|==
name|EEXIST
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"a child dataset already has a snapshot "
literal|"with the new name"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * On failure, we still want to remount any filesystems that 		 * were previously mounted, so we don't alter the system state. 		 */
if|if
condition|(
name|recursive
condition|)
block|{
name|struct
name|createdata
name|cd
decl_stmt|;
comment|/* only create links for datasets that had existed */
name|cd
operator|.
name|cd_snapname
operator|=
name|delim
operator|+
literal|1
expr_stmt|;
name|cd
operator|.
name|cd_ifexists
operator|=
name|B_TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_iter_filesystems
argument_list|(
name|zhrp
argument_list|,
name|zfs_create_link_cb
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|changelist_postfix
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|recursive
condition|)
block|{
name|struct
name|createdata
name|cd
decl_stmt|;
comment|/* only create links for datasets that had existed */
name|cd
operator|.
name|cd_snapname
operator|=
name|strchr
argument_list|(
name|target
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cd
operator|.
name|cd_ifexists
operator|=
name|B_TRUE
expr_stmt|;
name|ret
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhrp
argument_list|,
name|zfs_create_link_cb
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|changelist_rename
argument_list|(
name|cl
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|ret
operator|=
name|changelist_postfix
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
block|}
name|error
label|:
if|if
condition|(
name|parentname
condition|)
block|{
name|free
argument_list|(
name|parentname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zhrp
condition|)
block|{
name|zfs_close
argument_list|(
name|zhrp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cl
condition|)
block|{
name|changelist_free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a zvol dataset, issue the ioctl to create the appropriate minor node,  * poke devfsadm to create the /dev link, and then wait for the link to appear.  */
end_comment

begin_function
name|int
name|zvol_create_link
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset
parameter_list|)
block|{
return|return
operator|(
name|zvol_create_link_common
argument_list|(
name|hdl
argument_list|,
name|dataset
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_create_link_common
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset
parameter_list|,
name|int
name|ifexists
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
if|#
directive|if
literal|0
block|di_devlink_handle_t dhdl; 	priv_set_t *priv_effective; 	int privileged;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Issue the appropriate ioctl. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_CREATE_MINOR
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EEXIST
case|:
comment|/* 			 * Silently ignore the case where the link already 			 * exists.  This allows 'zfs volinit' to be run multiple 			 * times without errors. 			 */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ENOENT
case|:
comment|/* 			 * Dataset does not exist in the kernel.  If we 			 * don't care (see zfs_rename), then ignore the 			 * error quietly. 			 */
if|if
condition|(
name|ifexists
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
default|default:
return|return
operator|(
name|zfs_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create device links "
literal|"for '%s'"
argument_list|)
argument_list|,
name|dataset
argument_list|)
operator|)
return|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* 	 * If privileged call devfsadm and wait for the links to 	 * magically appear. 	 * Otherwise, print out an informational message. 	 */
block|priv_effective = priv_allocset(); 	(void) getppriv(PRIV_EFFECTIVE, priv_effective); 	privileged = (priv_isfullset(priv_effective) == B_TRUE); 	priv_freeset(priv_effective);  	if (privileged) { 		if ((dhdl = di_devlink_init(ZFS_DRIVER, 		    DI_MAKE_LINK)) == NULL) { 			zfs_error_aux(hdl, strerror(errno)); 			(void) zfs_error_fmt(hdl, errno, 			    dgettext(TEXT_DOMAIN, "cannot create device links " 			    "for '%s'"), dataset); 			(void) ioctl(hdl->libzfs_fd, ZFS_IOC_REMOVE_MINOR,&zc); 			return (-1); 		} else { 			(void) di_devlink_fini(&dhdl); 		} 	} else { 		char pathname[MAXPATHLEN]; 		struct stat64 statbuf; 		int i;
define|#
directive|define
name|MAX_WAIT
value|10
comment|/* 		 * This is the poor mans way of waiting for the link 		 * to show up.  If after 10 seconds we still don't 		 * have it, then print out a message. 		 */
block|(void) snprintf(pathname, sizeof (pathname), "/dev/zvol/dsk/%s", 		    dataset);  		for (i = 0; i != MAX_WAIT; i++) { 			if (stat64(pathname,&statbuf) == 0) 				break; 			(void) sleep(1); 		} 		if (i == MAX_WAIT) 			(void) printf(gettext("%s may not be immediately " 			    "available\n"), pathname); 	}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a minor node for the given zvol and the associated /dev links.  */
end_comment

begin_function
name|int
name|zvol_remove_link
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_REMOVE_MINOR
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENXIO
case|:
comment|/* 			 * Silently ignore the case where the link no longer 			 * exists, so that 'zfs volfini' can be run multiple 			 * times without errors. 			 */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot remove device "
literal|"links for '%s'"
argument_list|)
argument_list|,
name|dataset
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|zfs_get_user_props
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zfs_user_props
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is used by 'zfs list' to determine the exact set of columns to  * display, and their maximum widths.  This does two main things:  *  *      - If this is a list of all properties, then expand the list to include  *        all native properties, and set a flag so that for each dataset we look  *        for new unique user properties and add them to the list.  *  *      - For non fixed-width properties, keep track of the maximum width seen  *        so that we can size the column appropriately.  */
end_comment

begin_function
name|int
name|zfs_expand_proplist
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zprop_list_t
modifier|*
modifier|*
name|plp
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|zprop_list_t
modifier|*
name|entry
decl_stmt|;
name|zprop_list_t
modifier|*
modifier|*
name|last
decl_stmt|,
modifier|*
modifier|*
name|start
decl_stmt|;
name|nvlist_t
modifier|*
name|userprops
decl_stmt|,
modifier|*
name|propval
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
name|char
name|buf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
if|if
condition|(
name|zprop_expand_list
argument_list|(
name|hdl
argument_list|,
name|plp
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|userprops
operator|=
name|zfs_get_user_props
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|*
name|plp
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|pl_all
operator|&&
name|nvlist_next_nvpair
argument_list|(
name|userprops
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Go through and add any user properties as necessary.  We 		 * start by incrementing our list pointer to the first 		 * non-native property. 		 */
name|start
operator|=
name|plp
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|start
operator|)
operator|->
name|pl_prop
operator|==
name|ZPROP_INVAL
condition|)
break|break;
name|start
operator|=
operator|&
operator|(
operator|*
name|start
operator|)
operator|->
name|pl_next
expr_stmt|;
block|}
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|userprops
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * See if we've already found this property in our list. 			 */
for|for
control|(
name|last
operator|=
name|start
init|;
operator|*
name|last
operator|!=
name|NULL
condition|;
name|last
operator|=
operator|&
operator|(
operator|*
name|last
operator|)
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|last
operator|)
operator|->
name|pl_user_prop
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|last
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zprop_list_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|(
name|entry
operator|->
name|pl_user_prop
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
operator|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|entry
operator|->
name|pl_prop
operator|=
name|ZPROP_INVAL
expr_stmt|;
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|pl_all
operator|=
name|B_TRUE
expr_stmt|;
operator|*
name|last
operator|=
name|entry
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Now go through and check the width of any non-fixed columns 	 */
for|for
control|(
name|entry
operator|=
operator|*
name|plp
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|pl_fixed
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|pl_prop
operator|!=
name|ZPROP_INVAL
condition|)
block|{
if|if
condition|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|entry
operator|->
name|pl_prop
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
name|entry
operator|->
name|pl_width
condition|)
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|userprops
argument_list|,
name|entry
operator|->
name|pl_user_prop
argument_list|,
operator|&
name|propval
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|strval
argument_list|)
operator|>
name|entry
operator|->
name|pl_width
condition|)
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|strval
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TODO
end_ifdef

begin_function
name|int
name|zfs_iscsi_perm_check
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|dataset
parameter_list|,
name|ucred_t
modifier|*
name|cred
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|nvlist_t
modifier|*
name|nvp
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
specifier|const
name|gid_t
modifier|*
name|groups
decl_stmt|;
name|int
name|group_cnt
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|no_memory
argument_list|(
name|hdl
argument_list|)
operator|)
return|;
name|uid
operator|=
name|ucred_geteuid
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|gid
operator|=
name|ucred_getegid
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|group_cnt
operator|=
name|ucred_getgroups
argument_list|(
name|cred
argument_list|,
operator|&
name|groups
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|==
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|gid
operator|==
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|group_cnt
operator|==
operator|(
name|uid_t
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|nvlist_add_uint32
argument_list|(
name|nvp
argument_list|,
name|ZFS_DELEG_PERM_UID
argument_list|,
name|uid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_add_uint32
argument_list|(
name|nvp
argument_list|,
name|ZFS_DELEG_PERM_GID
argument_list|,
name|gid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_add_uint32_array
argument_list|(
name|nvp
argument_list|,
name|ZFS_DELEG_PERM_GROUPS
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|groups
argument_list|,
name|group_cnt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvp
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|error
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_ISCSI_PERM_CHECK
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|zfs_deleg_share_nfs
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|dataset
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|export
parameter_list|,
name|void
modifier|*
name|sharetab
parameter_list|,
name|int
name|sharemax
parameter_list|,
name|zfs_share_op_t
name|operation
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_share
operator|.
name|z_sharedata
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|sharetab
expr_stmt|;
name|zc
operator|.
name|zc_share
operator|.
name|z_exportdata
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|export
expr_stmt|;
name|zc
operator|.
name|zc_share
operator|.
name|z_sharetype
operator|=
name|operation
expr_stmt|;
name|zc
operator|.
name|zc_share
operator|.
name|z_sharemax
operator|=
name|sharemax
expr_stmt|;
name|error
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SHARE
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach/detach the given filesystem to/from the given jail.  */
end_comment

begin_function
name|int
name|zfs_jail
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|int
name|jailid
parameter_list|,
name|int
name|attach
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|cmd
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|attach
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot jail '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot jail '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|zhp
operator|->
name|zfs_type
condition|)
block|{
case|case
name|ZFS_TYPE_VOLUME
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volumes can not be jailed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|ZFS_TYPE_SNAPSHOT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshots can not be jailed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
name|zc
operator|.
name|zc_jailid
operator|=
name|jailid
expr_stmt|;
name|cmd
operator|=
name|attach
condition|?
name|ZFS_IOC_JAIL
else|:
name|ZFS_IOC_UNJAIL
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|cmd
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

