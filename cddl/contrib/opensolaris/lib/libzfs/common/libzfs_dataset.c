begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<zone.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mntent.h>
end_include

begin_include
include|#
directive|include
file|<sys/mnttab.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|"zfs_namecheck.h"
end_include

begin_include
include|#
directive|include
file|"zfs_prop.h"
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_comment
comment|/*  * Given a single type (not a mask of types), return the type in a human  * readable form.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zfs_type_to_name
parameter_list|(
name|zfs_type_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ZFS_TYPE_FILESYSTEM
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"filesystem"
argument_list|)
operator|)
return|;
case|case
name|ZFS_TYPE_SNAPSHOT
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot"
argument_list|)
operator|)
return|;
case|case
name|ZFS_TYPE_VOLUME
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume"
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a path and mask of ZFS types, return a string describing this dataset.  * This is used when we fail to open a dataset and we cannot get an exact type.  * We guess what the type would have been based on the path and the mask of  * acceptable types.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|path_to_str
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|types
parameter_list|)
block|{
comment|/* 	 * When given a single type, always report the exact type. 	 */
if|if
condition|(
name|types
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot"
argument_list|)
operator|)
return|;
if|if
condition|(
name|types
operator|==
name|ZFS_TYPE_FILESYSTEM
condition|)
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"filesystem"
argument_list|)
operator|)
return|;
if|if
condition|(
name|types
operator|==
name|ZFS_TYPE_VOLUME
condition|)
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume"
argument_list|)
operator|)
return|;
comment|/* 	 * The user is requesting more than one type of dataset.  If this is the 	 * case, consult the path itself.  If we're looking for a snapshot, and 	 * a '@' is found, then report it as "snapshot".  Otherwise, remove the 	 * snapshot attribute and try again. 	 */
if|if
condition|(
name|types
operator|&
name|ZFS_TYPE_SNAPSHOT
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|path
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot"
argument_list|)
operator|)
return|;
return|return
operator|(
name|path_to_str
argument_list|(
name|path
argument_list|,
name|types
operator|&
operator|~
name|ZFS_TYPE_SNAPSHOT
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * The user has requested either filesystems or volumes. 	 * We have no way of knowing a priori what type this would be, so always 	 * report it as "filesystem" or "volume", our two primitive types. 	 */
if|if
condition|(
name|types
operator|&
name|ZFS_TYPE_FILESYSTEM
condition|)
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"filesystem"
argument_list|)
operator|)
return|;
name|assert
argument_list|(
name|types
operator|&
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Validate a ZFS path.  This is used even before trying to open the dataset, to  * provide a more meaningful error message.  We place a more useful message in  * 'buf' detailing exactly why the name was not valid.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_validate_name
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|namecheck_err_t
name|why
decl_stmt|;
name|char
name|what
decl_stmt|;
if|if
condition|(
name|dataset_namecheck
argument_list|(
name|path
argument_list|,
operator|&
name|why
argument_list|,
operator|&
name|what
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|NAME_ERR_TOOLONG
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is too long"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_LEADING_SLASH
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"leading slash in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_EMPTY_COMPONENT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"empty component in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_TRAILING_SLASH
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"trailing slash in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_INVALCHAR
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid character "
literal|"'%c' in name"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_MULTIPLE_AT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"multiple '@' delimiters in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_NOLETTER
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool doesn't begin with a letter"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_RESERVED
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is reserved"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_DISKLIKE
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"reserved disk name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|type
operator|&
name|ZFS_TYPE_SNAPSHOT
operator|)
operator|&&
name|strchr
argument_list|(
name|path
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot delimiter '@' in filesystem name"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_SNAPSHOT
operator|&&
name|strchr
argument_list|(
name|path
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"missing '@' delimiter in snapshot name"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_name_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|zfs_type_t
name|type
parameter_list|)
block|{
return|return
operator|(
name|zfs_validate_name
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function takes the raw DSL properties, and filters out the user-defined  * properties into a separate nvlist.  */
end_comment

begin_function
specifier|static
name|int
name|process_user_props
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_user_props
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|zhp
operator|->
name|zfs_user_props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|no_memory
argument_list|(
name|hdl
argument_list|)
operator|)
return|;
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|zfs_prop_user
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
continue|continue;
name|verify
argument_list|(
name|nvpair_value_nvlist
argument_list|(
name|elem
argument_list|,
operator|&
name|propval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_user_props
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
name|propval
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|no_memory
argument_list|(
name|hdl
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility function to gather stats (objset and zpl) for the given object.  */
end_comment

begin_function
specifier|static
name|int
name|get_stats
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_alloc_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|zcmd_expand_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|zhp
operator|->
name|zfs_dmustats
operator|=
name|zc
operator|.
name|zc_objset_stats
expr_stmt|;
comment|/* structure assignment */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zhp
operator|->
name|zfs_root
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
sizeof|sizeof
argument_list|(
name|zhp
operator|->
name|zfs_root
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_props
condition|)
block|{
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|)
expr_stmt|;
name|zhp
operator|->
name|zfs_props
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|zcmd_read_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
operator|&
name|zhp
operator|->
name|zfs_props
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|process_user_props
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Refresh the properties currently stored in the handle.  */
end_comment

begin_function
name|void
name|zfs_refresh_properties
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|get_stats
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Makes a handle from the given dataset name.  Used by zfs_open() and  * zfs_iter_* to create child handles on the fly.  */
end_comment

begin_function
name|zfs_handle_t
modifier|*
name|make_dataset_handle
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_handle_t
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zhp
operator|->
name|zfs_hdl
operator|=
name|hdl
expr_stmt|;
name|top
label|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_stats
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_inconsistent
condition|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* 		 * If it is dds_inconsistent, then we've caught it in 		 * the middle of a 'zfs receive' or 'zfs destroy', and 		 * it is inconsistent from the ZPL's point of view, so 		 * can't be mounted.  However, it could also be that we 		 * have crashed in the middle of one of those 		 * operations, in which case we need to get rid of the 		 * inconsistent state.  We do that by either rolling 		 * back to the previous snapshot (which will fail if 		 * there is none), or destroying the filesystem.  Note 		 * that if we are still in the middle of an active 		 * 'receive' or 'destroy', then the rollback and destroy 		 * will fail with EBUSY and we will drive on as usual. 		 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_type
operator|==
name|DMU_OST_ZVOL
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_remove_link
argument_list|(
name|hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
block|}
else|else
block|{
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
block|}
comment|/* If we can successfully roll it back, reget the stats */
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_ROLLBACK
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|top
goto|;
comment|/* 		 * If we can sucessfully destroy it, pretend that it 		 * never existed. 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_DESTROY
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 	 * We've managed to open the dataset and gather statistics.  Determine 	 * the high-level type. 	 */
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_type
operator|==
name|DMU_OST_ZVOL
condition|)
name|zhp
operator|->
name|zfs_head_type
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
elseif|else
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_type
operator|==
name|DMU_OST_ZFS
condition|)
name|zhp
operator|->
name|zfs_head_type
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_is_snapshot
condition|)
name|zhp
operator|->
name|zfs_type
operator|=
name|ZFS_TYPE_SNAPSHOT
expr_stmt|;
elseif|else
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_type
operator|==
name|DMU_OST_ZVOL
condition|)
name|zhp
operator|->
name|zfs_type
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
elseif|else
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_type
operator|==
name|DMU_OST_ZFS
condition|)
name|zhp
operator|->
name|zfs_type
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* we should never see any other types */
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Opens the given snapshot, filesystem, or volume.   The 'types'  * argument is a mask of acceptable types.  The function will print an  * appropriate error message and return NULL if it can't be opened.  */
end_comment

begin_function
name|zfs_handle_t
modifier|*
name|zfs_open
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|types
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot open '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* 	 * Validate the name before we even try to open it. 	 */
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|ZFS_TYPE_ANY
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid dataset name"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Try to get stats for the dataset, which will tell us if it exists. 	 */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|make_dataset_handle
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|types
operator|&
name|zhp
operator|->
name|zfs_type
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a ZFS handle.  Nothing to do but free the associated memory.  */
end_comment

begin_function
name|void
name|zfs_close
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
if|if
condition|(
name|zhp
operator|->
name|zfs_mntopts
condition|)
name|free
argument_list|(
name|zhp
operator|->
name|zfs_mntopts
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_user_props
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a numeric suffix, convert the value into a number of bits that the  * resulting value must be shifted.  */
end_comment

begin_function
specifier|static
name|int
name|str2shift
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ends
init|=
literal|"BKMGTPEZ"
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|ends
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|toupper
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
operator|==
name|ends
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|strlen
argument_list|(
name|ends
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid numeric suffix '%s'"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * We want to allow trailing 'b' characters for 'GB' or 'Mb'.  But don't 	 * allow 'BB' - that's just weird. 	 */
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|toupper
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'B'
operator|&&
name|buf
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
name|toupper
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|'B'
operator|)
condition|)
return|return
operator|(
literal|10
operator|*
name|i
operator|)
return|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid numeric suffix '%s'"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a string of the form '100G' into a real number.  Used when setting  * properties or creating a volume.  'buf' is used to place an extended error  * message for the caller to use.  */
end_comment

begin_function
specifier|static
name|int
name|nicestrtonum
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|uint64_t
modifier|*
name|num
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|shift
decl_stmt|;
operator|*
name|num
operator|=
literal|0
expr_stmt|;
comment|/* Check to see if this looks like a number.  */
if|if
condition|(
operator|(
name|value
index|[
literal|0
index|]
operator|<
literal|'0'
operator|||
name|value
index|[
literal|0
index|]
operator|>
literal|'9'
operator|)
operator|&&
name|value
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
name|hdl
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bad numeric value '%s'"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Rely on stroll() to process the numeric portion.  */
name|errno
operator|=
literal|0
expr_stmt|;
operator|*
name|num
operator|=
name|strtoll
argument_list|(
name|value
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* 	 * Check for ERANGE, which indicates that the value is too large to fit 	 * in a 64-bit value. 	 */
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
if|if
condition|(
name|hdl
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"numeric value is too large"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * If we have a decimal value, then do the computation with floating 	 * point arithmetic.  Otherwise, use standard arithmetic. 	 */
if|if
condition|(
operator|*
name|end
operator|==
literal|'.'
condition|)
block|{
name|double
name|fval
init|=
name|strtod
argument_list|(
name|value
argument_list|,
operator|&
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|shift
operator|=
name|str2shift
argument_list|(
name|hdl
argument_list|,
name|end
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fval
operator|*=
name|pow
argument_list|(
literal|2
argument_list|,
name|shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|fval
operator|>
name|UINT64_MAX
condition|)
block|{
if|if
condition|(
name|hdl
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"numeric value is too large"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|num
operator|=
operator|(
name|uint64_t
operator|)
name|fval
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|shift
operator|=
name|str2shift
argument_list|(
name|hdl
argument_list|,
name|end
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Check for overflow */
if|if
condition|(
name|shift
operator|>=
literal|64
operator|||
operator|(
operator|*
name|num
operator|<<
name|shift
operator|)
operator|>>
name|shift
operator|!=
operator|*
name|num
condition|)
block|{
if|if
condition|(
name|hdl
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"numeric value is too large"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|num
operator|<<=
name|shift
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_nicestrtonum
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nicestrtonum
argument_list|(
name|hdl
argument_list|,
name|str
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The prop_parse_*() functions are designed to allow flexibility in callers  * when setting properties.  At the DSL layer, all properties are either 64-bit  * numbers or strings.  We want the user to be able to ignore this fact and  * specify properties as native values (boolean, for example) or as strings (to  * simplify command line utilities).  This also handles converting index types  * (compression, checksum, etc) from strings to their on-disk index.  */
end_comment

begin_function
specifier|static
name|int
name|prop_parse_boolean
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|nvpair_t
modifier|*
name|elem
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
name|uint64_t
name|ret
decl_stmt|;
switch|switch
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
condition|)
block|{
case|case
name|DATA_TYPE_STRING
case|:
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|verify
argument_list|(
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property '%s' must be 'on' or 'off'"
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
block|}
case|case
name|DATA_TYPE_UINT64
case|:
block|{
name|verify
argument_list|(
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|ret
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|1
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a boolean value"
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
block|}
case|case
name|DATA_TYPE_BOOLEAN_VALUE
case|:
block|{
name|boolean_t
name|value
decl_stmt|;
name|verify
argument_list|(
name|nvpair_value_boolean_value
argument_list|(
name|elem
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|value
expr_stmt|;
break|break;
block|}
default|default:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a boolean value"
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|val
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|prop_parse_number
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|nvpair_t
modifier|*
name|elem
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
name|uint64_t
name|ret
decl_stmt|;
name|boolean_t
name|isnone
init|=
name|B_FALSE
decl_stmt|;
switch|switch
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
condition|)
block|{
case|case
name|DATA_TYPE_STRING
case|:
block|{
name|char
modifier|*
name|value
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isnone
operator|=
name|B_TRUE
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nicestrtonum
argument_list|(
name|hdl
argument_list|,
name|value
argument_list|,
operator|&
name|ret
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
block|}
case|case
name|DATA_TYPE_UINT64
case|:
operator|(
name|void
operator|)
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
break|break;
default|default:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a number"
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Quota special: force 'none' and don't allow 0. 	 */
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|!
name|isnone
operator|&&
name|prop
operator|==
name|ZFS_PROP_QUOTA
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"use 'none' to disable quota"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|val
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|prop_parse_index
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|nvpair_t
modifier|*
name|elem
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
name|char
modifier|*
name|propname
init|=
name|nvpair_name
argument_list|(
name|elem
argument_list|)
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
operator|!=
name|DATA_TYPE_STRING
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a string"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_prop_string_to_index
argument_list|(
name|prop
argument_list|,
name|value
argument_list|,
name|val
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be one of '%s'"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|zfs_prop_values
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the bootfs name has the same pool name as it is set to.  * Assuming bootfs is a valid dataset name.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|bootfs_poolname_valid
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|,
name|char
modifier|*
name|bootfs
parameter_list|)
block|{
name|char
name|ch
decl_stmt|,
modifier|*
name|pname
decl_stmt|;
comment|/* get the pool name from the bootfs name */
name|pname
operator|=
name|bootfs
expr_stmt|;
while|while
condition|(
operator|*
name|bootfs
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|bootfs
argument_list|)
operator|&&
operator|*
name|bootfs
operator|!=
literal|'/'
condition|)
name|bootfs
operator|++
expr_stmt|;
name|ch
operator|=
operator|*
name|bootfs
expr_stmt|;
operator|*
name|bootfs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pool
argument_list|,
name|pname
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|bootfs
operator|=
name|ch
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
operator|*
name|bootfs
operator|=
name|ch
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an nvlist of properties to set, validates that they are correct, and  * parses any numeric properties (index, boolean, etc) if they are specified as  * strings.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|zfs_validate_properties
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_type_t
name|type
parameter_list|,
name|char
modifier|*
name|pool_name
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|uint64_t
name|zoned
parameter_list|,
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
name|uint64_t
name|intval
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
name|nvlist_t
modifier|*
name|ret
decl_stmt|;
name|int
name|isuser
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|ret
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot properties cannot be modified"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|propname
operator|=
name|nvpair_name
argument_list|(
name|elem
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure this property is valid and applies to this type. 		 */
if|if
condition|(
operator|(
name|prop
operator|=
name|zfs_name_to_prop_common
argument_list|(
name|propname
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|ZFS_PROP_INVAL
condition|)
block|{
name|isuser
operator|=
name|zfs_prop_user
argument_list|(
name|propname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isuser
operator|||
operator|(
name|isuser
operator|&&
operator|(
name|type
operator|&
name|ZFS_TYPE_POOL
operator|)
operator|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid property '%s'"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
else|else
block|{
comment|/* 				 * If this is a user property, make sure it's a 				 * string, and that it's less than 				 * ZAP_MAXNAMELEN. 				 */
if|if
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
operator|!=
name|DATA_TYPE_STRING
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a string"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
operator|>=
name|ZAP_MAXNAMELEN
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property name '%s' is too long"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
operator|(
name|void
operator|)
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|strval
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|ret
argument_list|,
name|propname
argument_list|,
name|strval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
continue|continue;
block|}
comment|/* 		 * Normalize the name, to get rid of shorthand abbrevations. 		 */
name|propname
operator|=
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' does not "
literal|"apply to datasets of this type"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
operator|&&
operator|(
name|prop
operator|!=
name|ZFS_PROP_VOLBLOCKSIZE
operator|||
name|zhp
operator|!=
name|NULL
operator|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is readonly"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPREADONLY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 		 * Convert any properties to the internal DSL value types. 		 */
name|strval
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|zfs_prop_get_type
argument_list|(
name|prop
argument_list|)
condition|)
block|{
case|case
name|prop_type_boolean
case|:
if|if
condition|(
name|prop_parse_boolean
argument_list|(
name|hdl
argument_list|,
name|elem
argument_list|,
operator|&
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|prop_type_string
case|:
if|if
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
operator|!=
name|DATA_TYPE_STRING
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a string"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|(
name|void
operator|)
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|strval
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|strval
argument_list|)
operator|>=
name|ZFS_MAXPROPLEN
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is too long"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|prop_type_number
case|:
if|if
condition|(
name|prop_parse_number
argument_list|(
name|hdl
argument_list|,
name|elem
argument_list|,
name|prop
argument_list|,
operator|&
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|prop_type_index
case|:
if|if
condition|(
name|prop_parse_index
argument_list|(
name|hdl
argument_list|,
name|elem
argument_list|,
name|prop
argument_list|,
operator|&
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * Add the result to our return set of properties. 		 */
if|if
condition|(
name|strval
condition|)
block|{
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|ret
argument_list|,
name|propname
argument_list|,
name|strval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|ret
argument_list|,
name|propname
argument_list|,
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 		 * Perform some additional checks for specific properties. 		 */
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_RECORDSIZE
case|:
case|case
name|ZFS_PROP_VOLBLOCKSIZE
case|:
comment|/* must be power of two within SPA_{MIN,MAX}BLOCKSIZE */
if|if
condition|(
name|intval
operator|<
name|SPA_MINBLOCKSIZE
operator|||
name|intval
operator|>
name|SPA_MAXBLOCKSIZE
operator|||
operator|!
name|ISP2
argument_list|(
name|intval
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be power of 2 from %u "
literal|"to %uk"
argument_list|)
argument_list|,
name|propname
argument_list|,
operator|(
name|uint_t
operator|)
name|SPA_MINBLOCKSIZE
argument_list|,
operator|(
name|uint_t
operator|)
name|SPA_MAXBLOCKSIZE
operator|>>
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|ZFS_PROP_SHAREISCSI
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"off"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"on"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"type=disk"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be 'on', 'off', or 'type=disk'"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|ZFS_PROP_MOUNTPOINT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
name|ZFS_MOUNTPOINT_NONE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|strval
argument_list|,
name|ZFS_MOUNTPOINT_LEGACY
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be an absolute path, "
literal|"'none', or 'legacy'"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/*FALLTHRU*/
case|case
name|ZFS_PROP_SHARENFS
case|:
comment|/* 			 * For the mountpoint and sharenfs properties, check if 			 * it can be set in a global/non-global zone based on 			 * the zoned property value: 			 * 			 *		global zone	    non-global zone 			 * -------------------------------------------------- 			 * zoned=on	mountpoint (no)	    mountpoint (yes) 			 *		sharenfs (no)	    sharenfs (no) 			 * 			 * zoned=off	mountpoint (yes)	N/A 			 *		sharenfs (yes) 			 */
if|if
condition|(
name|zoned
condition|)
block|{
if|if
condition|(
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be set on "
literal|"dataset in a non-global zone"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_SHARENFS
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be set in "
literal|"a non-global zone"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|getzoneid
argument_list|()
operator|!=
name|GLOBAL_ZONEID
condition|)
block|{
comment|/* 				 * If zoned property is 'off', this must be in 				 * a globle zone. If not, something is wrong. 				 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be set while dataset "
literal|"'zoned' property is set"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|ZFS_PROP_BOOTFS
case|:
comment|/* 			 * bootfs property value has to be a dataset name and 			 * the dataset has to be in the same pool as it sets to. 			 */
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
operator|!
name|zfs_name_valid
argument_list|(
name|strval
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|||
operator|!
name|bootfs_poolname_valid
argument_list|(
name|pool_name
argument_list|,
name|strval
argument_list|)
operator|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' "
literal|"is an invalid name"
argument_list|)
argument_list|,
name|strval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
block|}
comment|/* 		 * For changes to existing volumes, we have some additional 		 * checks to enforce. 		 */
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
operator|&&
name|zhp
operator|!=
name|NULL
condition|)
block|{
name|uint64_t
name|volsize
init|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|)
decl_stmt|;
name|uint64_t
name|blocksize
init|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_RESERVATION
case|:
if|if
condition|(
name|intval
operator|>
name|volsize
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is greater than current "
literal|"volume size"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|ZFS_PROP_VOLSIZE
case|:
if|if
condition|(
name|intval
operator|%
name|blocksize
operator|!=
literal|0
condition|)
block|{
name|zfs_nicenum
argument_list|(
name|blocksize
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a multiple of "
literal|"volume block size (%s)"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|intval
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be zero"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
block|}
block|}
block|}
comment|/* 	 * If this is an existing volume, and someone is setting the volsize, 	 * make sure that it matches the reservation, or add it if necessary. 	 */
if|if
condition|(
name|zhp
operator|!=
name|NULL
operator|&&
name|type
operator|==
name|ZFS_TYPE_VOLUME
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|ret
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|,
operator|&
name|intval
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|old_volsize
init|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|)
decl_stmt|;
name|uint64_t
name|old_reservation
init|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_RESERVATION
argument_list|)
decl_stmt|;
name|uint64_t
name|new_reservation
decl_stmt|;
if|if
condition|(
name|old_volsize
operator|==
name|old_reservation
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|ret
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_RESERVATION
argument_list|)
argument_list|,
operator|&
name|new_reservation
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|ret
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_RESERVATION
argument_list|)
argument_list|,
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
name|error
label|:
name|nvlist_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a property name and value, set the property for the given dataset.  */
end_comment

begin_function
name|int
name|zfs_prop_set
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|char
modifier|*
name|propval
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|prop_changelist_t
modifier|*
name|cl
init|=
name|NULL
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
init|=
name|NULL
decl_stmt|,
modifier|*
name|realprops
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot set property for '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_string
argument_list|(
name|nvl
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|realprops
operator|=
name|zfs_validate_properties
argument_list|(
name|hdl
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|,
name|NULL
argument_list|,
name|nvl
argument_list|,
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
argument_list|,
name|zhp
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|nvl
operator|=
name|realprops
expr_stmt|;
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
expr_stmt|;
comment|/* We don't support those properties on FreeBSD. */
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_SHAREISCSI
case|:
case|case
name|ZFS_PROP_DEVICES
case|:
case|case
name|ZFS_PROP_ACLMODE
case|:
case|case
name|ZFS_PROP_ACLINHERIT
case|:
case|case
name|ZFS_PROP_ISCSIOPTIONS
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|"property '%s' not supported on FreeBSD"
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PERM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|cl
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_MOUNTPOINT
operator|&&
name|changelist_haszonedchild
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"child dataset with inherited mountpoint is used "
literal|"in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|changelist_prefix
argument_list|(
name|cl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* 	 * Execute the corresponding ioctl() to set this property. 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvl
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
name|ret
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SET_PROP
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOSPC
case|:
comment|/* 			 * For quotas and reservations, ENOSPC indicates 			 * something different; setting a quota or reservation 			 * doesn't use any disk space. 			 */
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_QUOTA
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"size is less than current used or "
literal|"reserved space"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPSPACE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_RESERVATION
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"size is greater than available space"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPSPACE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EBUSY
case|:
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_VOLBLOCKSIZE
condition|)
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_VOLHASDATA
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|EBUSY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EROFS
case|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_DSREADONLY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOTSUP
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgraded to allow gzip compression"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOVERFLOW
case|:
comment|/* 			 * This platform can't address a volume this big. 			 */
ifdef|#
directive|ifdef
name|_ILP32
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_VOLSIZE
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_VOLTOOBIG
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* FALLTHROUGH */
default|default:
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Refresh the statistics so the new property value 		 * is reflected. 		 */
if|if
condition|(
operator|(
name|ret
operator|=
name|changelist_postfix
argument_list|(
name|cl
argument_list|)
operator|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|get_stats
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
name|error
label|:
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
condition|)
name|changelist_free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a property, inherit the value from the parent dataset.  */
end_comment

begin_function
name|int
name|zfs_prop_inherit
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|prop_changelist_t
modifier|*
name|cl
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot inherit %s for '%s'"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
operator|)
operator|==
name|ZFS_PROP_INVAL
condition|)
block|{
comment|/* 		 * For user properties, the amount of work we have to do is very 		 * small, so just do it here. 		 */
if|if
condition|(
operator|!
name|zfs_prop_user
argument_list|(
name|propname
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid property"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|propname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SET_PROP
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Verify that this property is inheritable. 	 */
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPREADONLY
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|zfs_prop_inheritable
argument_list|(
name|prop
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPNONINHERIT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
comment|/* 	 * Check to see if the value applies to this type 	 */
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
comment|/* 	 * Normalize the name, to get rid of shorthand abbrevations. 	 */
name|propname
operator|=
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|propname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_MOUNTPOINT
operator|&&
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
operator|&&
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset is used in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Determine datasets which will be affected by this change, if any. 	 */
if|if
condition|(
operator|(
name|cl
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_MOUNTPOINT
operator|&&
name|changelist_haszonedchild
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"child dataset with inherited mountpoint is used "
literal|"in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|changelist_prefix
argument_list|(
name|cl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|ret
operator|=
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SET_PROP
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|changelist_postfix
argument_list|(
name|cl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* 		 * Refresh the statistics so the new property is reflected. 		 */
operator|(
name|void
operator|)
name|get_stats
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
name|error
label|:
name|changelist_free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nicebool
parameter_list|(
name|int
name|value
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
if|if
condition|(
name|value
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"on"
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"off"
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * True DSL properties are stored in an nvlist.  The following two functions  * extract them appropriately.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|getprop_uint64
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|char
modifier|*
modifier|*
name|source
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
operator|*
name|source
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_SOURCE
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|zfs_prop_default_numeric
argument_list|(
name|prop
argument_list|)
expr_stmt|;
operator|*
name|source
operator|=
literal|""
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|getprop_string
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|char
modifier|*
modifier|*
name|source
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
operator|*
name|source
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_SOURCE
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|zfs_prop_default_string
argument_list|(
name|prop
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|value
operator|=
literal|""
expr_stmt|;
operator|*
name|source
operator|=
literal|""
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal function for getting a numeric property.  Both zfs_prop_get() and  * zfs_prop_get_int() are built using this interface.  *  * Certain properties can be overridden using 'mount -o'.  In this case, scan  * the contents of the /etc/mnttab entry, searching for the appropriate options.  * If they differ from the on-disk values, report the current values and mark  * the source "temporary".  */
end_comment

begin_function
specifier|static
name|int
name|get_numeric_property
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|zfs_source_t
modifier|*
name|src
parameter_list|,
name|char
modifier|*
modifier|*
name|source
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|mnttab
name|mnt
decl_stmt|;
name|char
modifier|*
name|mntopt_on
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|mntopt_off
init|=
name|NULL
decl_stmt|;
operator|*
name|source
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_ATIME
case|:
name|mntopt_on
operator|=
name|MNTOPT_ATIME
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NOATIME
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_DEVICES
case|:
name|mntopt_on
operator|=
name|MNTOPT_DEVICES
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NODEVICES
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_EXEC
case|:
name|mntopt_on
operator|=
name|MNTOPT_EXEC
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NOEXEC
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_READONLY
case|:
name|mntopt_on
operator|=
name|MNTOPT_RO
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_RW
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_SETUID
case|:
name|mntopt_on
operator|=
name|MNTOPT_SETUID
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NOSETUID
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_XATTR
case|:
name|mntopt_on
operator|=
name|MNTOPT_XATTR
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NOXATTR
expr_stmt|;
break|break;
block|}
comment|/* 	 * Because looking up the mount options is potentially expensive 	 * (iterating over all of /etc/mnttab), we defer its calculation until 	 * we're looking up a property which requires its presence. 	 */
if|if
condition|(
operator|!
name|zhp
operator|->
name|zfs_mntcheck
operator|&&
operator|(
name|mntopt_on
operator|!=
name|NULL
operator|||
name|prop
operator|==
name|ZFS_PROP_MOUNTED
operator|)
condition|)
block|{
name|struct
name|mnttab
name|entry
decl_stmt|,
name|search
init|=
block|{
literal|0
block|}
decl_stmt|;
name|FILE
modifier|*
name|mnttab
init|=
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_mnttab
decl_stmt|;
name|search
operator|.
name|mnt_special
operator|=
operator|(
name|char
operator|*
operator|)
name|zhp
operator|->
name|zfs_name
expr_stmt|;
name|search
operator|.
name|mnt_fstype
operator|=
name|MNTTYPE_ZFS
expr_stmt|;
name|rewind
argument_list|(
name|mnttab
argument_list|)
expr_stmt|;
if|if
condition|(
name|getmntany
argument_list|(
name|mnttab
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|search
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zhp
operator|->
name|zfs_mntopts
operator|=
name|zfs_strdup
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|entry
operator|.
name|mnt_mntopts
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_mntopts
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zhp
operator|->
name|zfs_mntcheck
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|zhp
operator|->
name|zfs_mntopts
operator|==
name|NULL
condition|)
name|mnt
operator|.
name|mnt_mntopts
operator|=
literal|""
expr_stmt|;
else|else
name|mnt
operator|.
name|mnt_mntopts
operator|=
name|zhp
operator|->
name|zfs_mntopts
expr_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_ATIME
case|:
case|case
name|ZFS_PROP_DEVICES
case|:
case|case
name|ZFS_PROP_EXEC
case|:
case|case
name|ZFS_PROP_READONLY
case|:
case|case
name|ZFS_PROP_SETUID
case|:
case|case
name|ZFS_PROP_XATTR
case|:
operator|*
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
name|mntopt_on
argument_list|)
operator|&&
operator|!
operator|*
name|val
condition|)
block|{
operator|*
name|val
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|ZFS_SRC_TEMPORARY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
name|mntopt_off
argument_list|)
operator|&&
operator|*
name|val
condition|)
block|{
operator|*
name|val
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|ZFS_SRC_TEMPORARY
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_RECORDSIZE
case|:
case|case
name|ZFS_PROP_COMPRESSION
case|:
case|case
name|ZFS_PROP_ZONED
case|:
case|case
name|ZFS_PROP_CREATION
case|:
case|case
name|ZFS_PROP_COMPRESSRATIO
case|:
case|case
name|ZFS_PROP_REFERENCED
case|:
case|case
name|ZFS_PROP_USED
case|:
case|case
name|ZFS_PROP_CREATETXG
case|:
case|case
name|ZFS_PROP_AVAILABLE
case|:
case|case
name|ZFS_PROP_VOLSIZE
case|:
case|case
name|ZFS_PROP_VOLBLOCKSIZE
case|:
operator|*
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|source
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_CANMOUNT
case|:
operator|*
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|val
operator|==
literal|0
condition|)
operator|*
name|source
operator|=
name|zhp
operator|->
name|zfs_name
expr_stmt|;
else|else
operator|*
name|source
operator|=
literal|""
expr_stmt|;
comment|/* default */
break|break;
case|case
name|ZFS_PROP_QUOTA
case|:
case|case
name|ZFS_PROP_RESERVATION
case|:
operator|*
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|val
operator|==
literal|0
condition|)
operator|*
name|source
operator|=
literal|""
expr_stmt|;
comment|/* default */
else|else
operator|*
name|source
operator|=
name|zhp
operator|->
name|zfs_name
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_MOUNTED
case|:
operator|*
name|val
operator|=
operator|(
name|zhp
operator|->
name|zfs_mntopts
operator|!=
name|NULL
operator|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NUMCLONES
case|:
operator|*
name|val
operator|=
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_num_clones
expr_stmt|;
break|break;
default|default:
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get non-numeric property"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"internal error"
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the source type, given the raw source string.  */
end_comment

begin_function
specifier|static
name|void
name|get_source
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_source_t
modifier|*
name|srctype
parameter_list|,
name|char
modifier|*
name|source
parameter_list|,
name|char
modifier|*
name|statbuf
parameter_list|,
name|size_t
name|statlen
parameter_list|)
block|{
if|if
condition|(
name|statbuf
operator|==
name|NULL
operator|||
operator|*
name|srctype
operator|==
name|ZFS_SRC_TEMPORARY
condition|)
return|return;
if|if
condition|(
name|source
operator|==
name|NULL
condition|)
block|{
operator|*
name|srctype
operator|=
name|ZFS_SRC_NONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|source
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|srctype
operator|=
name|ZFS_SRC_DEFAULT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|source
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|srctype
operator|=
name|ZFS_SRC_LOCAL
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|statbuf
argument_list|,
name|source
argument_list|,
name|statlen
argument_list|)
expr_stmt|;
operator|*
name|srctype
operator|=
name|ZFS_SRC_INHERITED
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Retrieve a property from the given object.  If 'literal' is specified, then  * numbers are left as exact values.  Otherwise, numbers are converted to a  * human-readable form.  *  * Returns 0 on success, or -1 on error.  */
end_comment

begin_function
name|int
name|zfs_prop_get
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|char
modifier|*
name|propbuf
parameter_list|,
name|size_t
name|proplen
parameter_list|,
name|zfs_source_t
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|statbuf
parameter_list|,
name|size_t
name|statlen
parameter_list|,
name|boolean_t
name|literal
parameter_list|)
block|{
name|char
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|strval
decl_stmt|;
comment|/* 	 * Check to see if this property applies to our object 	 */
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|ZFS_SRC_NONE
expr_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_ATIME
case|:
case|case
name|ZFS_PROP_READONLY
case|:
case|case
name|ZFS_PROP_SETUID
case|:
case|case
name|ZFS_PROP_ZONED
case|:
case|case
name|ZFS_PROP_DEVICES
case|:
case|case
name|ZFS_PROP_EXEC
case|:
case|case
name|ZFS_PROP_CANMOUNT
case|:
case|case
name|ZFS_PROP_XATTR
case|:
comment|/* 		 * Basic boolean values are built on top of 		 * get_numeric_property(). 		 */
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nicebool
argument_list|(
name|val
argument_list|,
name|propbuf
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_AVAILABLE
case|:
case|case
name|ZFS_PROP_RECORDSIZE
case|:
case|case
name|ZFS_PROP_CREATETXG
case|:
case|case
name|ZFS_PROP_REFERENCED
case|:
case|case
name|ZFS_PROP_USED
case|:
case|case
name|ZFS_PROP_VOLSIZE
case|:
case|case
name|ZFS_PROP_VOLBLOCKSIZE
case|:
case|case
name|ZFS_PROP_NUMCLONES
case|:
comment|/* 		 * Basic numeric values are built on top of 		 * get_numeric_property(). 		 */
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|literal
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|val
argument_list|)
expr_stmt|;
else|else
name|zfs_nicenum
argument_list|(
name|val
argument_list|,
name|propbuf
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_COMPRESSION
case|:
case|case
name|ZFS_PROP_CHECKSUM
case|:
case|case
name|ZFS_PROP_SNAPDIR
case|:
ifdef|#
directive|ifdef
name|ZFS_NO_ACL
case|case
name|ZFS_PROP_ACLMODE
case|:
case|case
name|ZFS_PROP_ACLINHERIT
case|:
case|case
name|ZFS_PROP_COPIES
case|:
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|source
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zfs_prop_index_to_string
argument_list|(
name|prop
argument_list|,
name|val
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|strval
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
comment|/* ZFS_NO_ACL */
case|case
name|ZFS_PROP_ACLMODE
case|:
case|case
name|ZFS_PROP_ACLINHERIT
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"<unsupported>"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* ZFS_NO_ACL */
case|case
name|ZFS_PROP_CREATION
case|:
comment|/* 		 * 'creation' is a time_t stored in the statistics.  We convert 		 * this into a string unless 'literal' is specified. 		 */
block|{
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|source
argument_list|)
expr_stmt|;
name|time_t
name|time
init|=
operator|(
name|time_t
operator|)
name|val
decl_stmt|;
name|struct
name|tm
name|t
decl_stmt|;
if|if
condition|(
name|literal
operator|||
name|localtime_r
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|t
argument_list|)
operator|==
name|NULL
operator|||
name|strftime
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%a %b %e %k:%M %Y"
argument_list|,
operator|&
name|t
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%llu"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_MOUNTPOINT
case|:
comment|/* 		 * Getting the precise mountpoint can be tricky. 		 * 		 *  - for 'none' or 'legacy', return those values. 		 *  - for default mountpoints, construct it as /zfs/<dataset> 		 *  - for inherited mountpoints, we want to take everything 		 *    after our ancestor and append it to the inherited value. 		 * 		 * If the pool has an alternate root, we want to prepend that 		 * root to any values we return. 		 */
name|root
operator|=
name|zhp
operator|->
name|zfs_root
expr_stmt|;
name|str
operator|=
name|getprop_string
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%s/zfs/%s"
argument_list|,
name|root
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
specifier|const
name|char
modifier|*
name|relpath
init|=
name|zhp
operator|->
name|zfs_name
operator|+
name|strlen
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|relpath
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|relpath
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|relpath
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%s%s"
argument_list|,
name|root
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%s%s%s%s"
argument_list|,
name|root
argument_list|,
name|str
argument_list|,
name|relpath
index|[
literal|0
index|]
operator|==
literal|'@'
condition|?
literal|""
else|:
literal|"/"
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 'legacy' or 'none' */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|str
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_SHARENFS
case|:
case|case
name|ZFS_PROP_SHAREISCSI
case|:
case|case
name|ZFS_PROP_ISCSIOPTIONS
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|getprop_string
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|source
argument_list|)
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_ORIGIN
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|getprop_string
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|source
argument_list|)
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
comment|/* 		 * If there is no parent at all, return failure to indicate that 		 * it doesn't apply to this dataset. 		 */
if|if
condition|(
name|propbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
name|ZFS_PROP_QUOTA
case|:
case|case
name|ZFS_PROP_RESERVATION
case|:
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * If quota or reservation is 0, we translate this into 'none' 		 * (unless literal is set), and indicate that it's the default 		 * value.  Otherwise, we print the number nicely and indicate 		 * that its set locally. 		 */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|literal
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"0"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"none"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|literal
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|val
argument_list|)
expr_stmt|;
else|else
name|zfs_nicenum
argument_list|(
name|val
argument_list|,
name|propbuf
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_COMPRESSRATIO
case|:
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%lld.%02lldx"
argument_list|,
operator|(
name|longlong_t
operator|)
name|val
operator|/
literal|100
argument_list|,
operator|(
name|longlong_t
operator|)
name|val
operator|%
literal|100
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_TYPE
case|:
switch|switch
condition|(
name|zhp
operator|->
name|zfs_type
condition|)
block|{
case|case
name|ZFS_TYPE_FILESYSTEM
case|:
name|str
operator|=
literal|"filesystem"
expr_stmt|;
break|break;
case|case
name|ZFS_TYPE_VOLUME
case|:
name|str
operator|=
literal|"volume"
expr_stmt|;
break|break;
case|case
name|ZFS_TYPE_SNAPSHOT
case|:
name|str
operator|=
literal|"snapshot"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_MOUNTED
case|:
comment|/* 		 * The 'mounted' property is a pseudo-property that described 		 * whether the filesystem is currently mounted.  Even though 		 * it's a boolean value, the typical values of "on" and "off" 		 * don't make sense, so we translate to "yes" and "no". 		 */
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTED
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|val
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"yes"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"no"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NAME
case|:
comment|/* 		 * The 'name' property is a pseudo-property derived from the 		 * dataset name.  It is presented as a real property to simplify 		 * consumers. 		 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|get_source
argument_list|(
name|zhp
argument_list|,
name|src
argument_list|,
name|source
argument_list|,
name|statbuf
argument_list|,
name|statlen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility function to get the given numeric property.  Does no validation that  * the given property is the appropriate type; should only be used with  * hard-coded property types.  */
end_comment

begin_function
name|uint64_t
name|zfs_prop_get_int
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|)
block|{
name|char
modifier|*
name|source
decl_stmt|;
name|zfs_source_t
name|sourcetype
init|=
name|ZFS_SRC_NONE
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|sourcetype
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Similar to zfs_prop_get(), but returns the value as an integer.  */
end_comment

begin_function
name|int
name|zfs_prop_get_numeric
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|uint64_t
modifier|*
name|value
parameter_list|,
name|zfs_source_t
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|statbuf
parameter_list|,
name|size_t
name|statlen
parameter_list|)
block|{
name|char
modifier|*
name|source
decl_stmt|;
comment|/* 	 * Check to see if this property applies to our object 	 */
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|)
condition|)
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_PROPTYPE
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get property '%s'"
argument_list|)
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|ZFS_SRC_NONE
expr_stmt|;
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
name|value
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|get_source
argument_list|(
name|zhp
argument_list|,
name|src
argument_list|,
name|source
argument_list|,
name|statbuf
argument_list|,
name|statlen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the name of the given zfs handle.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zfs_get_name
parameter_list|(
specifier|const
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zfs_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the type of the given zfs handle.  */
end_comment

begin_function
name|zfs_type_t
name|zfs_get_type
parameter_list|(
specifier|const
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zfs_type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all child filesystems  */
end_comment

begin_function
name|int
name|zfs_iter_filesystems
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_iter_f
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zfs_handle_t
modifier|*
name|nzhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
for|for
control|(
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
init|;
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_DATASET_LIST_NEXT
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
control|)
block|{
comment|/* 		 * Ignore private dataset names. 		 */
if|if
condition|(
name|dataset_name_hidden
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Silently ignore errors, as the only plausible explanation is 		 * that the pool has since been removed. 		 */
if|if
condition|(
operator|(
name|nzhp
operator|=
name|make_dataset_handle
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ret
operator|=
name|func
argument_list|(
name|nzhp
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * An errno value of ESRCH indicates normal completion.  If ENOENT is 	 * returned, then the underlying dataset has been removed since we 	 * obtained the handle. 	 */
if|if
condition|(
name|errno
operator|!=
name|ESRCH
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot iterate filesystems"
argument_list|)
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all snapshots  */
end_comment

begin_function
name|int
name|zfs_iter_snapshots
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_iter_f
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zfs_handle_t
modifier|*
name|nzhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
for|for
control|(
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
init|;
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SNAPSHOT_LIST_NEXT
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|nzhp
operator|=
name|make_dataset_handle
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ret
operator|=
name|func
argument_list|(
name|nzhp
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * An errno value of ESRCH indicates normal completion.  If ENOENT is 	 * returned, then the underlying dataset has been removed since we 	 * obtained the handle.  Silently ignore this case, and return success. 	 */
if|if
condition|(
name|errno
operator|!=
name|ESRCH
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot iterate filesystems"
argument_list|)
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all children, snapshots and filesystems  */
end_comment

begin_function
name|int
name|zfs_iter_children
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_iter_f
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|func
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
return|return
operator|(
name|zfs_iter_snapshots
argument_list|(
name|zhp
argument_list|,
name|func
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a complete name, return just the portion that refers to the parent.  * Can return NULL if this is a pool.  */
end_comment

begin_function
specifier|static
name|int
name|parent_name
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|char
modifier|*
name|loc
decl_stmt|;
if|if
condition|(
operator|(
name|loc
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|path
argument_list|,
name|MIN
argument_list|(
name|buflen
argument_list|,
name|loc
operator|-
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|loc
operator|-
name|path
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks to make sure that the given path has a parent, and that it exists.  We  * also fetch the 'zoned' property, which is used to validate property settings  * when creating new datasets.  */
end_comment

begin_function
specifier|static
name|int
name|check_parents
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|uint64_t
modifier|*
name|zoned
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|parent
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|"cannot create '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* get parent, and check to see if this is just a pool */
if|if
condition|(
name|parent_name
argument_list|(
name|path
argument_list|,
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"missing dataset name"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* check to see if the pool exists */
if|if
condition|(
operator|(
name|slash
operator|=
name|strchr
argument_list|(
name|parent
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|slash
operator|=
name|parent
operator|+
name|strlen
argument_list|(
name|parent
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|parent
argument_list|,
name|slash
operator|-
name|parent
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_name
index|[
name|slash
operator|-
name|parent
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such pool '%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* check to see if the parent dataset exists */
if|if
condition|(
operator|(
name|zhp
operator|=
name|make_dataset_handle
argument_list|(
name|hdl
argument_list|,
name|parent
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"parent does not exist"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
operator|*
name|zoned
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
expr_stmt|;
comment|/* we are in a non-global zone, but parent is in the global zone */
if|if
condition|(
name|getzoneid
argument_list|()
operator|!=
name|GLOBAL_ZONEID
operator|&&
operator|!
operator|(
operator|*
name|zoned
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|EPERM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* make sure parent is a filesystem */
if|if
condition|(
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|!=
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"parent is not a filesystem"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new filesystem or volume.  */
end_comment

begin_function
name|int
name|zfs_create
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|zfs_type_t
name|type
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|uint64_t
name|size
init|=
literal|0
decl_stmt|;
name|uint64_t
name|blocksize
init|=
name|zfs_prop_default_numeric
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|uint64_t
name|zoned
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* validate the path, taking care to note the extended error message */
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
comment|/* validate parents exist */
if|if
condition|(
name|check_parents
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
operator|&
name|zoned
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * The failure modes when creating a dataset of a different type over 	 * one that already exists is a little strange.  In particular, if you 	 * try to create a dataset on top of an existing dataset, the ioctl() 	 * will return ENOENT, not EEXIST.  To prevent this from happening, we 	 * first try to see if the dataset exists. 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset already exists"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
else|else
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
if|if
condition|(
name|props
operator|&&
operator|(
name|props
operator|=
name|zfs_validate_properties
argument_list|(
name|hdl
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|zoned
argument_list|,
name|NULL
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
comment|/* 		 * If we are creating a volume, the size and block size must 		 * satisfy a few restraints.  First, the blocksize must be a 		 * valid block size between SPA_{MIN,MAX}BLOCKSIZE.  Second, the 		 * volsize must be a multiple of the block size, and cannot be 		 * zero. 		 */
if|if
condition|(
name|props
operator|==
name|NULL
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|,
operator|&
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"missing volume size"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|nvlist_lookup_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
operator|&
name|blocksize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|ENOENT
condition|)
block|{
name|blocksize
operator|=
name|zfs_prop_default_numeric
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"missing volume block size"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume size cannot be zero"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|%
name|blocksize
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume size must be a multiple of volume block "
literal|"size"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|props
operator|&&
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|props
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
comment|/* create the dataset */
name|ret
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_CREATE
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
name|ret
operator|=
name|zvol_create_link
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Volume successfully created, but device links "
literal|"were not created"
argument_list|)
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
comment|/* check for failure */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|char
name|parent
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|parent_name
argument_list|(
name|path
argument_list|,
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such parent '%s'"
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|EINVAL
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"parent '%s' is not a filesystem"
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|EDOM
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume block size must be power of 2 from "
literal|"%u to %uk"
argument_list|)
argument_list|,
operator|(
name|uint_t
operator|)
name|SPA_MINBLOCKSIZE
argument_list|,
operator|(
name|uint_t
operator|)
name|SPA_MAXBLOCKSIZE
operator|>>
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|_ILP32
case|case
name|EOVERFLOW
case|:
comment|/* 			 * This platform can't address a volume this big. 			 */
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_VOLTOOBIG
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* FALLTHROUGH */
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroys the given dataset.  The caller must make sure that the filesystem  * isn't mounted, and that there are no active dependents.  */
end_comment

begin_function
name|int
name|zfs_destroy
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
comment|/* 		 * Unconditionally unshare this zvol ignoring failure as it 		 * indicates only that the volume wasn't shared initially. 		 */
operator|(
name|void
operator|)
name|zfs_unshare_iscsi
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zvol_remove_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
block|}
else|else
block|{
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_DESTROY
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|zfs_standard_error_fmt
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot destroy '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|)
return|;
block|}
name|remove_mountpoint
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|destroydata
block|{
name|char
modifier|*
name|snapname
decl_stmt|;
name|boolean_t
name|gotone
decl_stmt|;
name|boolean_t
name|closezhp
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|zfs_remove_link_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|destroydata
modifier|*
name|dd
init|=
name|arg
decl_stmt|;
name|zfs_handle_t
modifier|*
name|szhp
decl_stmt|;
name|char
name|name
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|boolean_t
name|closezhp
init|=
name|dd
operator|->
name|closezhp
decl_stmt|;
name|int
name|rv
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|name
argument_list|,
literal|"@"
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|name
argument_list|,
name|dd
operator|->
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|szhp
operator|=
name|make_dataset_handle
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|szhp
condition|)
block|{
name|dd
operator|->
name|gotone
operator|=
name|B_TRUE
expr_stmt|;
name|zfs_close
argument_list|(
name|szhp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_remove_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * NB: this is simply a best-effort.  We don't want to 		 * return an error, because then we wouldn't visit all 		 * the volumes. 		 */
block|}
name|dd
operator|->
name|closezhp
operator|=
name|B_TRUE
expr_stmt|;
name|rv
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|zfs_remove_link_cb
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|closezhp
condition|)
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroys all snapshots with the given name in zhp& descendants.  */
end_comment

begin_function
name|int
name|zfs_destroy_snaps
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
name|snapname
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|destroydata
name|dd
init|=
block|{
literal|0
block|}
decl_stmt|;
name|dd
operator|.
name|snapname
operator|=
name|snapname
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_remove_link_cb
argument_list|(
name|zhp
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dd
operator|.
name|gotone
condition|)
block|{
return|return
operator|(
name|zfs_standard_error_fmt
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ENOENT
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot destroy '%s@%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|snapname
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_DESTROY_SNAPS
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot destroy '%s@%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EEXIST
case|:
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot is cloned"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clones the given dataset.  The target must be of the same type as the source.  */
end_comment

begin_function
name|int
name|zfs_clone
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|parent
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|zfs_type_t
name|type
decl_stmt|;
name|uint64_t
name|zoned
decl_stmt|;
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create '%s'"
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* validate the target name */
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
comment|/* validate parents exist */
if|if
condition|(
name|check_parents
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
operator|&
name|zoned
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|parent_name
argument_list|(
name|target
argument_list|,
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do the clone */
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
name|type
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
block|}
else|else
block|{
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
name|type
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
block|}
if|if
condition|(
name|props
condition|)
block|{
if|if
condition|(
operator|(
name|props
operator|=
name|zfs_validate_properties
argument_list|(
name|hdl
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|zoned
argument_list|,
name|zhp
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|props
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_CREATE
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
comment|/* 			 * The parent doesn't exist.  We should have caught this 			 * above, but there may a race condition that has since 			 * destroyed the parent. 			 * 			 * At this point, we don't know whether it's the source 			 * that doesn't exist anymore, or whether the target 			 * dataset doesn't exist. 			 */
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such parent '%s'"
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|EXDEV
case|:
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"source and target pools differ"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_CROSSTARGET
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
name|ret
operator|=
name|zvol_create_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|promote_data
block|{
name|char
name|cb_mountpoint
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cb_target
decl_stmt|;
specifier|const
name|char
modifier|*
name|cb_errbuf
decl_stmt|;
name|uint64_t
name|cb_pivot_txg
decl_stmt|;
block|}
name|promote_data_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|promote_snap_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|promote_data_t
modifier|*
name|pd
init|=
name|data
decl_stmt|;
name|zfs_handle_t
modifier|*
name|szhp
decl_stmt|;
name|char
name|snapname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
comment|/* We don't care about snapshots after the pivot point */
if|if
condition|(
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
operator|>
name|pd
operator|->
name|cb_pivot_txg
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Remove the device link if it's a zvol. */
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|zvol_remove_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
comment|/* Check for conflicting names */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|snapname
argument_list|,
name|pd
operator|->
name|cb_target
argument_list|,
sizeof|sizeof
argument_list|(
name|snapname
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|snapname
argument_list|,
name|strchr
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
literal|'@'
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|snapname
argument_list|)
argument_list|)
expr_stmt|;
name|szhp
operator|=
name|make_dataset_handle
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|szhp
operator|!=
name|NULL
condition|)
block|{
name|zfs_close
argument_list|(
name|szhp
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot name '%s' from origin \n"
literal|"conflicts with '%s' from target"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
name|rv
operator|=
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|pd
operator|->
name|cb_errbuf
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|promote_snap_done_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|promote_data_t
modifier|*
name|pd
init|=
name|data
decl_stmt|;
comment|/* We don't care about snapshots after the pivot point */
if|if
condition|(
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
operator|<=
name|pd
operator|->
name|cb_pivot_txg
condition|)
block|{
comment|/* Create the device link if it's a zvol. */
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|zvol_create_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Promotes the given clone fs to be the clone parent.  */
end_comment

begin_function
name|int
name|zfs_promote
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|parent
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|zfs_handle_t
modifier|*
name|pzhp
decl_stmt|;
name|promote_data_t
name|pd
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot promote '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshots can not be promoted"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|parent
argument_list|,
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_clone_of
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"not a cloned filesystem"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|parent
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Walk the snapshots we will be moving */
name|pzhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_clone_of
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzhp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|pd
operator|.
name|cb_pivot_txg
operator|=
name|zfs_prop_get_int
argument_list|(
name|pzhp
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|pzhp
argument_list|)
expr_stmt|;
name|pd
operator|.
name|cb_target
operator|=
name|zhp
operator|->
name|zfs_name
expr_stmt|;
name|pd
operator|.
name|cb_errbuf
operator|=
name|errbuf
expr_stmt|;
name|pzhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|parent
argument_list|,
name|ZFS_TYPE_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzhp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|zfs_prop_get
argument_list|(
name|pzhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|pd
operator|.
name|cb_mountpoint
argument_list|,
sizeof|sizeof
argument_list|(
name|pd
operator|.
name|cb_mountpoint
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_iter_snapshots
argument_list|(
name|pzhp
argument_list|,
name|promote_snap_cb
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|pzhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* issue the ioctl */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_clone_of
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_PROMOTE
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|zfs_iter_snapshots
argument_list|(
name|pzhp
argument_list|,
name|promote_snap_done_cb
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|pzhp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|save_errno
condition|)
block|{
case|case
name|EEXIST
case|:
comment|/* 			 * There is a conflicting snapshot name.  We 			 * should have caught this above, but they could 			 * have renamed something in the mean time. 			 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"conflicting snapshot name from parent '%s'"
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|save_errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|zfs_iter_snapshots
argument_list|(
name|zhp
argument_list|,
name|promote_snap_done_cb
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|pzhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_create_link_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|snapname
init|=
name|arg
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
name|char
name|name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|name
argument_list|,
literal|"@"
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|name
argument_list|,
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zvol_create_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * NB: this is simply a best-effort.  We don't want to 		 * return an error, because then we wouldn't visit all 		 * the volumes. 		 */
block|}
name|ret
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|zfs_create_link_cb
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Takes a snapshot of the given dataset.  */
end_comment

begin_function
name|int
name|zfs_snapshot
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|boolean_t
name|recursive
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|delim
decl_stmt|;
name|char
modifier|*
name|parent
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot snapshot '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* validate the target name */
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
comment|/* make sure the parent exists and is of the appropriate type */
name|delim
operator|=
name|strchr
argument_list|(
name|path
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|parent
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|delim
operator|-
name|path
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|parent
argument_list|,
name|path
argument_list|,
name|delim
operator|-
name|path
argument_list|)
expr_stmt|;
name|parent
index|[
name|delim
operator|-
name|path
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|parent
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|delim
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|recursive
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SNAPSHOT
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
comment|/* 	 * if it was recursive, the one that actually failed will be in 	 * zc.zc_name. 	 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create snapshot '%s@%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|recursive
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|zfs_create_link_cb
argument_list|,
operator|(
name|char
operator|*
operator|)
name|delim
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
name|ret
operator|=
name|zvol_create_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_DESTROY
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dumps a backup of the given snapshot (incremental from fromsnap if it's not  * NULL) to the file descriptor specified by outfd.  */
end_comment

begin_function
name|int
name|zfs_send
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|fromsnap
parameter_list|,
name|int
name|outfd
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromsnap
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|fromsnap
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|outfd
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SENDBACKUP
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot send '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EXDEV
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"not an earlier snapshot from the same fs"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_CROSSTARGET
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|EDQUOT
case|:
case|case
name|EFBIG
case|:
case|case
name|EIO
case|:
case|case
name|ENOLINK
case|:
case|case
name|ENOSPC
case|:
case|case
name|ENXIO
case|:
case|case
name|EPIPE
case|:
case|case
name|ERANGE
case|:
case|case
name|EFAULT
case|:
case|case
name|EROFS
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADBACKUP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create ancestors of 'target', but not target itself, and not  * ancestors whose names are shorter than prefixlen.  Die if  * prefixlen-ancestor does not exist.  */
end_comment

begin_function
specifier|static
name|int
name|create_parents
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|int
name|prefixlen
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* make sure prefix exists */
name|cp
operator|=
name|strchr
argument_list|(
name|target
operator|+
name|prefixlen
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|h
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zfs_close
argument_list|(
name|h
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to create, mount, and share any ancestor filesystems, 	 * up to the prefixlen-long one. 	 */
for|for
control|(
name|cp
operator|=
name|target
operator|+
name|prefixlen
operator|+
literal|1
init|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
condition|;
operator|*
name|cp
operator|=
literal|'/'
operator|,
name|cp
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|h
operator|=
name|make_dataset_handle
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
comment|/* it already exists, nothing to do here */
name|zfs_close
argument_list|(
name|h
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|opname
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"create"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_create
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|ancestorerr
goto|;
name|opname
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"open"
argument_list|)
expr_stmt|;
name|h
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|ancestorerr
goto|;
name|opname
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"mount"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_mount
argument_list|(
name|h
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|ancestorerr
goto|;
name|opname
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"share"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_share
argument_list|(
name|h
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|ancestorerr
goto|;
name|zfs_close
argument_list|(
name|h
argument_list|)
expr_stmt|;
continue|continue;
name|ancestorerr
label|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"failed to %s ancestor '%s'"
argument_list|)
argument_list|,
name|opname
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Restores a backup of tosnap from the file descriptor specified by infd.  */
end_comment

begin_function
name|int
name|zfs_receive
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|tosnap
parameter_list|,
name|int
name|isprefix
parameter_list|,
name|int
name|verbose
parameter_list|,
name|int
name|dryrun
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|int
name|infd
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|time_t
name|begin_time
decl_stmt|;
name|int
name|ioctl_err
decl_stmt|,
name|err
decl_stmt|,
name|bytes
decl_stmt|,
name|size
decl_stmt|,
name|choplen
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|dmu_replay_record_t
name|drr
decl_stmt|;
name|struct
name|drr_begin
modifier|*
name|drrb
init|=
operator|&
name|zc
operator|.
name|zc_begin_record
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|prop_changelist_t
modifier|*
name|clp
decl_stmt|;
name|char
name|chopprefix
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|begin_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read in the BEGIN record */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|drr
expr_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|size
operator|=
name|read
argument_list|(
name|infd
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
operator|-
name|bytes
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|size
expr_stmt|;
name|bytes
operator|+=
name|size
expr_stmt|;
block|}
do|while
condition|(
name|size
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|size
operator|<
literal|0
operator|||
name|bytes
operator|!=
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid "
literal|"stream (failed to read first record)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|zc
operator|.
name|zc_begin_record
operator|=
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
expr_stmt|;
if|if
condition|(
name|drrb
operator|->
name|drr_magic
operator|!=
name|DMU_BACKUP_MAGIC
operator|&&
name|drrb
operator|->
name|drr_magic
operator|!=
name|BSWAP_64
argument_list|(
name|DMU_BACKUP_MAGIC
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid "
literal|"stream (bad magic number)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|drrb
operator|->
name|drr_version
operator|!=
name|DMU_BACKUP_VERSION
operator|&&
name|drrb
operator|->
name|drr_version
operator|!=
name|BSWAP_64
argument_list|(
name|DMU_BACKUP_VERSION
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"only version "
literal|"0x%llx is supported (stream is version 0x%llx)"
argument_list|)
argument_list|,
name|DMU_BACKUP_VERSION
argument_list|,
name|drrb
operator|->
name|drr_version
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_toname
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid "
literal|"stream (bad snapshot name)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Determine how much of the snapshot name stored in the stream 	 * we are going to tack on to the name they specified on the 	 * command line, and how much we are going to chop off. 	 * 	 * If they specified a snapshot, chop the entire name stored in 	 * the stream. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|chopprefix
argument_list|,
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_toname
argument_list|)
expr_stmt|;
if|if
condition|(
name|isprefix
condition|)
block|{
comment|/* 		 * They specified a fs with -d, we want to tack on 		 * everything but the pool name stored in the stream 		 */
if|if
condition|(
name|strchr
argument_list|(
name|tosnap
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid "
literal|"argument - snapshot not allowed with -d"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|chopprefix
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|chopprefix
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|tosnap
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If they specified a filesystem without -d, we want to 		 * tack on everything after the fs specified in the 		 * first name from the stream. 		 */
name|cp
operator|=
name|strchr
argument_list|(
name|chopprefix
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|choplen
operator|=
name|strlen
argument_list|(
name|chopprefix
argument_list|)
expr_stmt|;
comment|/* 	 * Determine name of destination snapshot, store in zc_value. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|tosnap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_toname
operator|+
name|choplen
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|drrb
operator|->
name|drr_fromguid
condition|)
block|{
comment|/* incremental backup stream */
name|zfs_handle_t
modifier|*
name|h
decl_stmt|;
comment|/* do the recvbackup ioctl to the containing fs */
operator|*
name|strchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* make sure destination fs exists */
name|h
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|dryrun
condition|)
block|{
comment|/* 			 * We need to unmount all the dependents of the dataset 			 * and the dataset itself. If it's a volume 			 * then remove device link. 			 */
if|if
condition|(
name|h
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
name|clp
operator|=
name|changelist_gather
argument_list|(
name|h
argument_list|,
name|ZFS_PROP_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|changelist_prefix
argument_list|(
name|clp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|zvol_remove_link
argument_list|(
name|hdl
argument_list|,
name|h
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
block|}
block|}
name|zfs_close
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* full backup stream */
comment|/* Make sure destination fs does not exist */
operator|*
name|strchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination '%s' exists"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * they're trying to do a recv into a 			 * nonexistant topmost filesystem. 			 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination does not exist"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* Do the recvbackup ioctl to the fs's parent. */
operator|*
name|strrchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'/'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isprefix
operator|&&
operator|(
name|err
operator|=
name|create_parents
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
name|strlen
argument_list|(
name|tosnap
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADRESTORE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
name|zc
operator|.
name|zc_cookie
operator|=
name|infd
expr_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
name|force
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s stream of %s into %s\n"
argument_list|,
name|dryrun
condition|?
literal|"would receive"
else|:
literal|"receiving"
argument_list|,
name|drrb
operator|->
name|drr_fromguid
condition|?
literal|"incremental"
else|:
literal|"full"
argument_list|,
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_toname
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dryrun
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|ioctl_err
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_RECVBACKUP
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl_err
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENODEV
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"most recent snapshot does not match incremental "
literal|"source"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADRESTORE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETXTBSY
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination has been modified since most recent "
literal|"snapshot"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADRESTORE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EEXIST
case|:
if|if
condition|(
name|drrb
operator|->
name|drr_fromguid
operator|==
literal|0
condition|)
block|{
comment|/* it's the containing fs that exists */
name|cp
operator|=
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination already exists"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot restore to %s"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECKSUM
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid stream (checksum mismatch)"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Mount or recreate the /dev links for the target filesystem 	 * (if created, or if we tore them down to do an incremental 	 * restore), and the /dev links for the new snapshot (if 	 * created). Also mount any children of the target filesystem 	 * if we did an incremental receive. 	 */
name|cp
operator|=
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
operator|(
name|ioctl_err
operator|==
literal|0
operator|||
name|drrb
operator|->
name|drr_fromguid
operator|)
condition|)
block|{
name|zfs_handle_t
modifier|*
name|h
decl_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|h
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
name|err
operator|=
name|zvol_create_link
argument_list|(
name|hdl
argument_list|,
name|h
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|ioctl_err
operator|==
literal|0
condition|)
name|err
operator|=
name|zvol_create_link
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|drrb
operator|->
name|drr_fromguid
condition|)
block|{
name|err
operator|=
name|changelist_postfix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|zfs_mount
argument_list|(
name|h
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|zfs_close
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|||
name|ioctl_err
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|verbose
condition|)
block|{
name|char
name|buf1
index|[
literal|64
index|]
decl_stmt|;
name|char
name|buf2
index|[
literal|64
index|]
decl_stmt|;
name|uint64_t
name|bytes
init|=
name|zc
operator|.
name|zc_cookie
decl_stmt|;
name|time_t
name|delta
init|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|begin_time
decl_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|delta
operator|=
literal|1
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|bytes
argument_list|,
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|bytes
operator|/
name|delta
argument_list|,
name|buf2
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"received %sb stream in %lu seconds (%sb/sec)\n"
argument_list|,
name|buf1
argument_list|,
name|delta
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy any more recent snapshots.  We invoke this callback on any dependents  * of the snapshot first.  If the 'cb_dependent' member is non-zero, then this  * is a dependent and we should just destroy it without checking the transaction  * group.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rollback_data
block|{
specifier|const
name|char
modifier|*
name|cb_target
decl_stmt|;
comment|/* the snapshot */
name|uint64_t
name|cb_create
decl_stmt|;
comment|/* creation time reference */
name|prop_changelist_t
modifier|*
name|cb_clp
decl_stmt|;
comment|/* changelist pointer */
name|int
name|cb_error
decl_stmt|;
name|boolean_t
name|cb_dependent
decl_stmt|;
block|}
name|rollback_data_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|rollback_destroy
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rollback_data_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_dependent
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|cbp
operator|->
name|cb_target
argument_list|)
operator|!=
literal|0
operator|&&
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_SNAPSHOT
operator|&&
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
operator|>
name|cbp
operator|->
name|cb_create
condition|)
block|{
name|cbp
operator|->
name|cb_dependent
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_FALSE
argument_list|,
name|rollback_destroy
argument_list|,
name|cbp
argument_list|)
operator|!=
literal|0
condition|)
name|cbp
operator|->
name|cb_error
operator|=
literal|1
expr_stmt|;
name|cbp
operator|->
name|cb_dependent
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|zfs_destroy
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
name|cbp
operator|->
name|cb_error
operator|=
literal|1
expr_stmt|;
else|else
name|changelist_remove
argument_list|(
name|zhp
argument_list|,
name|cbp
operator|->
name|cb_clp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|zfs_destroy
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
name|cbp
operator|->
name|cb_error
operator|=
literal|1
expr_stmt|;
else|else
name|changelist_remove
argument_list|(
name|zhp
argument_list|,
name|cbp
operator|->
name|cb_clp
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rollback the dataset to its latest snapshot.  */
end_comment

begin_function
specifier|static
name|int
name|do_rollback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_FILESYSTEM
operator|||
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
operator|&&
name|zvol_remove_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
else|else
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
comment|/* 	 * We rely on the consumer to verify that there are no newer snapshots 	 * for the given dataset.  Given these constraints, we can simply pass 	 * the name on to the ioctl() call.  There is still an unlikely race 	 * condition where the user has taken a snapshot since we verified that 	 * this was the most recent. 	 */
if|if
condition|(
operator|(
name|ret
operator|=
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_ROLLBACK
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_standard_error_fmt
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot rollback '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
name|ret
operator|=
name|zvol_create_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a dataset, rollback to a specific snapshot, discarding any  * data changes since then and making it the active dataset.  *  * Any snapshots more recent than the target are destroyed, along with  * their dependents.  */
end_comment

begin_function
name|int
name|zfs_rollback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_handle_t
modifier|*
name|snap
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|rollback_data_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|prop_changelist_t
modifier|*
name|clp
decl_stmt|;
comment|/* 	 * Unmount all dependendents of the dataset and the dataset itself. 	 * The list we need to gather is the same as for doing rename 	 */
name|clp
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_NAME
argument_list|,
name|flag
condition|?
name|MS_FORCE
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|changelist_prefix
argument_list|(
name|clp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Destroy all recent snapshots and its dependends. 	 */
name|cb
operator|.
name|cb_target
operator|=
name|snap
operator|->
name|zfs_name
expr_stmt|;
name|cb
operator|.
name|cb_create
operator|=
name|zfs_prop_get_int
argument_list|(
name|snap
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
name|cb
operator|.
name|cb_clp
operator|=
name|clp
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_iter_children
argument_list|(
name|zhp
argument_list|,
name|rollback_destroy
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|cb
operator|.
name|cb_error
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|changelist_postfix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Now that we have verified that the snapshot is the latest, 	 * rollback to the given snapshot. 	 */
name|ret
operator|=
name|do_rollback
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|changelist_postfix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * We only want to re-mount the filesystem if it was mounted in the 	 * first place. 	 */
name|ret
operator|=
name|changelist_postfix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|out
label|:
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all dependents for a given dataset.  This includes both  * hierarchical dependents (children) and data dependents (snapshots and  * clones).  The bulk of the processing occurs in get_dependents() in  * libzfs_graph.c.  */
end_comment

begin_function
name|int
name|zfs_iter_dependents
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|boolean_t
name|allowrecursion
parameter_list|,
name|zfs_iter_f
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|dependents
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|zfs_handle_t
modifier|*
name|child
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|get_dependents
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|allowrecursion
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
operator|&
name|dependents
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|child
operator|=
name|make_dataset_handle
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dependents
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ret
operator|=
name|func
argument_list|(
name|child
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|dependents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dependents
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Renames the given dataset.  */
end_comment

begin_function
name|int
name|zfs_rename
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|delim
decl_stmt|;
name|prop_changelist_t
modifier|*
name|cl
decl_stmt|;
name|char
name|parent
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
comment|/* if we have the same exact name, just return success */
if|if
condition|(
name|strcmp
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|target
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot rename to '%s'"
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the target name is valid 	 */
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
block|{
if|if
condition|(
operator|(
name|strchr
argument_list|(
name|target
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|*
name|target
operator|==
literal|'@'
condition|)
block|{
comment|/* 			 * Snapshot target name is abbreviated, 			 * reconstruct full dataset name 			 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|parent
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|delim
operator|=
name|strchr
argument_list|(
name|parent
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|target
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
operator|*
operator|(
operator|++
name|delim
operator|)
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
name|delim
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|parent
argument_list|,
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|parent
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Make sure we're renaming within the same dataset. 			 */
name|delim
operator|=
name|strchr
argument_list|(
name|target
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|target
argument_list|,
name|delim
operator|-
name|target
argument_list|)
operator|!=
literal|0
operator|||
name|zhp
operator|->
name|zfs_name
index|[
name|delim
operator|-
name|target
index|]
operator|!=
literal|'@'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshots must be part of same "
literal|"dataset"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_CROSSTARGET
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
name|uint64_t
name|unused
decl_stmt|;
comment|/* validate parents */
if|if
condition|(
name|check_parents
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
operator|&
name|unused
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|parent_name
argument_list|(
name|target
argument_list|,
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make sure we're in the same pool */
name|verify
argument_list|(
operator|(
name|delim
operator|=
name|strchr
argument_list|(
name|target
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|target
argument_list|,
name|delim
operator|-
name|target
argument_list|)
operator|!=
literal|0
operator|||
name|zhp
operator|->
name|zfs_name
index|[
name|delim
operator|-
name|target
index|]
operator|!=
literal|'/'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"datasets must be within same pool"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_CROSSTARGET
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* new name cannot be a child of the current dataset name */
if|if
condition|(
name|strncmp
argument_list|(
name|parent
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|strlen
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"New dataset name cannot be a descendent of "
literal|"current dataset name"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot rename '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
operator|&&
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset is used in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cl
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_NAME
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|changelist_haszonedchild
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"child dataset with inherited mountpoint is used "
literal|"in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|changelist_prefix
argument_list|(
name|cl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
else|else
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_RENAME
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
comment|/* 		 * On failure, we still want to remount any filesystems that 		 * were previously mounted, so we don't alter the system state. 		 */
operator|(
name|void
operator|)
name|changelist_postfix
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|changelist_rename
argument_list|(
name|cl
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|ret
operator|=
name|changelist_postfix
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
name|error
label|:
name|changelist_free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a zvol dataset, issue the ioctl to create the appropriate minor node,  * poke devfsadm to create the /dev link, and then wait for the link to appear.  */
end_comment

begin_function
name|int
name|zvol_create_link
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
if|#
directive|if
literal|0
block|di_devlink_handle_t dhdl;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Issue the appropriate ioctl. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_CREATE_MINOR
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EEXIST
case|:
comment|/* 			 * Silently ignore the case where the link already 			 * exists.  This allows 'zfs volinit' to be run multiple 			 * times without errors. 			 */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create device links "
literal|"for '%s'"
argument_list|)
argument_list|,
name|dataset
argument_list|)
operator|)
return|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* 	 * Call devfsadm and wait for the links to magically appear. 	 */
block|if ((dhdl = di_devlink_init(ZFS_DRIVER, DI_MAKE_LINK)) == NULL) { 		zfs_error_aux(hdl, strerror(errno)); 		(void) zfs_error_fmt(hdl, EZFS_DEVLINKS, 		    dgettext(TEXT_DOMAIN, "cannot create device links " 		    "for '%s'"), dataset); 		(void) ioctl(hdl->libzfs_fd, ZFS_IOC_REMOVE_MINOR,&zc); 		return (-1); 	} else { 		(void) di_devlink_fini(&dhdl); 	}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a minor node for the given zvol and the associated /dev links.  */
end_comment

begin_function
name|int
name|zvol_remove_link
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_REMOVE_MINOR
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENXIO
case|:
comment|/* 			 * Silently ignore the case where the link no longer 			 * exists, so that 'zfs volfini' can be run multiple 			 * times without errors. 			 */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot remove device "
literal|"links for '%s'"
argument_list|)
argument_list|,
name|dataset
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|zfs_get_user_props
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zfs_user_props
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a comma-separated list of properties, contruct a property list  * containing both user-defined and native properties.  This function will  * return a NULL list if 'all' is specified, which can later be expanded on a  * per-dataset basis by zfs_expand_proplist().  */
end_comment

begin_function
name|int
name|zfs_get_proplist_common
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|fields
parameter_list|,
name|zfs_proplist_t
modifier|*
modifier|*
name|listp
parameter_list|,
name|zfs_type_t
name|type
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
name|zfs_proplist_t
modifier|*
name|entry
decl_stmt|;
name|zfs_proplist_t
modifier|*
modifier|*
name|last
decl_stmt|;
operator|*
name|listp
operator|=
name|NULL
expr_stmt|;
name|last
operator|=
name|listp
expr_stmt|;
comment|/* 	 * If 'all' is specified, return a NULL list. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|fields
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If no fields were specified, return an error. 	 */
if|if
condition|(
name|fields
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no properties specified"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bad property list"
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * It would be nice to use getsubopt() here, but the inclusion of column 	 * aliases makes this more effort than it's worth. 	 */
name|s
operator|=
name|fields
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
name|s
operator|+
name|len
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|p
operator|-
name|s
expr_stmt|;
block|}
comment|/* 		 * Check for empty options. 		 */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"empty property name"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bad property list"
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * Check all regular property names. 		 */
name|c
operator|=
name|s
index|[
name|len
index|]
expr_stmt|;
name|s
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|prop
operator|=
name|zfs_name_to_prop_common
argument_list|(
name|s
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|!=
name|ZFS_PROP_INVAL
operator|&&
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|type
argument_list|)
condition|)
name|prop
operator|=
name|ZFS_PROP_INVAL
expr_stmt|;
comment|/* 		 * When no property table entry can be found, return failure if 		 * this is a pool property or if this isn't a user-defined 		 * dataset property, 		 */
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_INVAL
operator|&&
operator|(
name|type
operator|&
name|ZFS_TYPE_POOL
operator|||
operator|!
name|zfs_prop_user
argument_list|(
name|s
argument_list|)
operator|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid property '%s'"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bad property list"
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|entry
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_proplist_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|entry
operator|->
name|pl_prop
operator|=
name|prop
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_INVAL
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|pl_user_prop
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|s
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|->
name|pl_width
operator|=
name|zfs_prop_width
argument_list|(
name|prop
argument_list|,
operator|&
name|entry
operator|->
name|pl_fixed
argument_list|)
expr_stmt|;
block|}
operator|*
name|last
operator|=
name|entry
expr_stmt|;
name|last
operator|=
operator|&
name|entry
operator|->
name|pl_next
expr_stmt|;
name|s
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_get_proplist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|fields
parameter_list|,
name|zfs_proplist_t
modifier|*
modifier|*
name|listp
parameter_list|)
block|{
return|return
operator|(
name|zfs_get_proplist_common
argument_list|(
name|hdl
argument_list|,
name|fields
argument_list|,
name|listp
argument_list|,
name|ZFS_TYPE_ANY
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_free_proplist
parameter_list|(
name|zfs_proplist_t
modifier|*
name|pl
parameter_list|)
block|{
name|zfs_proplist_t
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|pl
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|pl
operator|->
name|pl_next
expr_stmt|;
name|free
argument_list|(
name|pl
operator|->
name|pl_user_prop
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pl
argument_list|)
expr_stmt|;
name|pl
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|expand_data
block|{
name|zfs_proplist_t
modifier|*
modifier|*
name|last
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
decl_stmt|;
block|}
name|expand_data_t
typedef|;
end_typedef

begin_function
specifier|static
name|zfs_prop_t
name|zfs_expand_proplist_cb
parameter_list|(
name|zfs_prop_t
name|prop
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|zfs_proplist_t
modifier|*
name|entry
decl_stmt|;
name|expand_data_t
modifier|*
name|edp
init|=
name|cb
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|zfs_alloc
argument_list|(
name|edp
operator|->
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_proplist_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ZFS_PROP_INVAL
operator|)
return|;
name|entry
operator|->
name|pl_prop
operator|=
name|prop
expr_stmt|;
name|entry
operator|->
name|pl_width
operator|=
name|zfs_prop_width
argument_list|(
name|prop
argument_list|,
operator|&
name|entry
operator|->
name|pl_fixed
argument_list|)
expr_stmt|;
name|entry
operator|->
name|pl_all
operator|=
name|B_TRUE
expr_stmt|;
operator|*
operator|(
name|edp
operator|->
name|last
operator|)
operator|=
name|entry
expr_stmt|;
name|edp
operator|->
name|last
operator|=
operator|&
name|entry
operator|->
name|pl_next
expr_stmt|;
return|return
operator|(
name|ZFS_PROP_CONT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_expand_proplist_common
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_proplist_t
modifier|*
modifier|*
name|plp
parameter_list|,
name|zfs_type_t
name|type
parameter_list|)
block|{
name|zfs_proplist_t
modifier|*
name|entry
decl_stmt|;
name|zfs_proplist_t
modifier|*
modifier|*
name|last
decl_stmt|;
name|expand_data_t
name|exp
decl_stmt|;
if|if
condition|(
operator|*
name|plp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If this is the very first time we've been called for an 'all' 		 * specification, expand the list to include all native 		 * properties. 		 */
name|last
operator|=
name|plp
expr_stmt|;
name|exp
operator|.
name|last
operator|=
name|last
expr_stmt|;
name|exp
operator|.
name|hdl
operator|=
name|hdl
expr_stmt|;
if|if
condition|(
name|zfs_prop_iter_common
argument_list|(
name|zfs_expand_proplist_cb
argument_list|,
operator|&
name|exp
argument_list|,
name|type
argument_list|,
name|B_FALSE
argument_list|)
operator|==
name|ZFS_PROP_INVAL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * Add 'name' to the beginning of the list, which is handled 		 * specially. 		 */
if|if
condition|(
operator|(
name|entry
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_proplist_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|entry
operator|->
name|pl_prop
operator|=
name|ZFS_PROP_NAME
expr_stmt|;
name|entry
operator|->
name|pl_width
operator|=
name|zfs_prop_width
argument_list|(
name|ZFS_PROP_NAME
argument_list|,
operator|&
name|entry
operator|->
name|pl_fixed
argument_list|)
expr_stmt|;
name|entry
operator|->
name|pl_all
operator|=
name|B_TRUE
expr_stmt|;
name|entry
operator|->
name|pl_next
operator|=
operator|*
name|plp
expr_stmt|;
operator|*
name|plp
operator|=
name|entry
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is used by 'zfs list' to determine the exact set of columns to  * display, and their maximum widths.  This does two main things:  *  *      - If this is a list of all properties, then expand the list to include  *        all native properties, and set a flag so that for each dataset we look  *        for new unique user properties and add them to the list.  *  *      - For non fixed-width properties, keep track of the maximum width seen  *        so that we can size the column appropriately.  */
end_comment

begin_function
name|int
name|zfs_expand_proplist
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_proplist_t
modifier|*
modifier|*
name|plp
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|zfs_proplist_t
modifier|*
name|entry
decl_stmt|;
name|zfs_proplist_t
modifier|*
modifier|*
name|last
decl_stmt|,
modifier|*
modifier|*
name|start
decl_stmt|;
name|nvlist_t
modifier|*
name|userprops
decl_stmt|,
modifier|*
name|propval
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
name|char
name|buf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
if|if
condition|(
name|zfs_expand_proplist_common
argument_list|(
name|hdl
argument_list|,
name|plp
argument_list|,
name|ZFS_TYPE_ANY
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|userprops
operator|=
name|zfs_get_user_props
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|*
name|plp
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|pl_all
operator|&&
name|nvlist_next_nvpair
argument_list|(
name|userprops
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Go through and add any user properties as necessary.  We 		 * start by incrementing our list pointer to the first 		 * non-native property. 		 */
name|start
operator|=
name|plp
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|start
operator|)
operator|->
name|pl_prop
operator|==
name|ZFS_PROP_INVAL
condition|)
break|break;
name|start
operator|=
operator|&
operator|(
operator|*
name|start
operator|)
operator|->
name|pl_next
expr_stmt|;
block|}
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|userprops
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * See if we've already found this property in our list. 			 */
for|for
control|(
name|last
operator|=
name|start
init|;
operator|*
name|last
operator|!=
name|NULL
condition|;
name|last
operator|=
operator|&
operator|(
operator|*
name|last
operator|)
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|last
operator|)
operator|->
name|pl_user_prop
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|last
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_proplist_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|(
name|entry
operator|->
name|pl_user_prop
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
operator|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|entry
operator|->
name|pl_prop
operator|=
name|ZFS_PROP_INVAL
expr_stmt|;
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|pl_all
operator|=
name|B_TRUE
expr_stmt|;
operator|*
name|last
operator|=
name|entry
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Now go through and check the width of any non-fixed columns 	 */
for|for
control|(
name|entry
operator|=
operator|*
name|plp
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|pl_fixed
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|pl_prop
operator|!=
name|ZFS_PROP_INVAL
condition|)
block|{
if|if
condition|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|entry
operator|->
name|pl_prop
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
name|entry
operator|->
name|pl_width
condition|)
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|userprops
argument_list|,
name|entry
operator|->
name|pl_user_prop
argument_list|,
operator|&
name|propval
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propval
argument_list|,
name|ZFS_PROP_VALUE
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|strval
argument_list|)
operator|>
name|entry
operator|->
name|pl_width
condition|)
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|strval
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach/detach the given filesystem to/from the given jail.  */
end_comment

begin_function
name|int
name|zfs_jail
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|int
name|jailid
parameter_list|,
name|int
name|attach
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|cmd
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|attach
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot jail '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot jail '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|zhp
operator|->
name|zfs_type
condition|)
block|{
case|case
name|ZFS_TYPE_VOLUME
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volumes can not be jailed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|ZFS_TYPE_SNAPSHOT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshots can not be jailed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
name|zc
operator|.
name|zc_jailid
operator|=
name|jailid
expr_stmt|;
name|cmd
operator|=
name|attach
condition|?
name|ZFS_IOC_JAIL
else|:
name|ZFS_IOC_UNJAIL
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|cmd
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

