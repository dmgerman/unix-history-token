begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012 by Delphix. All rights reserved.  */
end_comment

begin_comment
comment|/*  * LibZFS_Core (lzc) is intended to replace most functionality in libzfs.  * It has the following characteristics:  *  *  - Thread Safe.  libzfs_core is accessible concurrently from multiple  *  threads.  This is accomplished primarily by avoiding global data  *  (e.g. caching).  Since it's thread-safe, there is no reason for a  *  process to have multiple libzfs "instances".  Therefore, we store  *  our few pieces of data (e.g. the file descriptor) in global  *  variables.  The fd is reference-counted so that the libzfs_core  *  library can be "initialized" multiple times (e.g. by different  *  consumers within the same process).  *  *  - Committed Interface.  The libzfs_core interface will be committed,  *  therefore consumers can compile against it and be confident that  *  their code will continue to work on future releases of this code.  *  Currently, the interface is Evolving (not Committed), but we intend  *  to commit to it once it is more complete and we determine that it  *  meets the needs of all consumers.  *  *  - Programatic Error Handling.  libzfs_core communicates errors with  *  defined error numbers, and doesn't print anything to stdout/stderr.  *  *  - Thin Layer.  libzfs_core is a thin layer, marshaling arguments  *  to/from the kernel ioctls.  There is generally a 1:1 correspondence  *  between libzfs_core functions and ioctls to /dev/zfs.  *  *  - Clear Atomicity.  Because libzfs_core functions are generally 1:1  *  with kernel ioctls, and kernel ioctls are general atomic, each  *  libzfs_core function is atomic.  For example, creating multiple  *  snapshots with a single call to lzc_snapshot() is atomic -- it  *  can't fail with only some of the requested snapshots created, even  *  in the event of power loss or system crash.  *  *  - Continued libzfs Support.  Some higher-level operations (e.g.  *  support for "zfs send -R") are too complicated to fit the scope of  *  libzfs_core.  This functionality will continue to live in libzfs.  *  Where appropriate, libzfs will use the underlying atomic operations  *  of libzfs_core.  For example, libzfs may implement "zfs send -R |  *  zfs receive" by using individual "send one snapshot", rename,  *  destroy, and "receive one snapshot" operations in libzfs_core.  *  /sbin/zfs and /zbin/zpool will link with both libzfs and  *  libzfs_core.  Other consumers should aim to use only libzfs_core,  *  since that will be the supported, stable interface going forwards.  */
end_comment

begin_define
define|#
directive|define
name|_IN_LIBZFS_CORE_
end_define

begin_include
include|#
directive|include
file|<libzfs_core.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvpair.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<libzfs_impl.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|g_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|g_lock
init|=
name|PTHREAD_MUTEX_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_refcount
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|libzfs_core_init
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|g_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_refcount
operator|==
literal|0
condition|)
block|{
name|g_fd
operator|=
name|open
argument_list|(
literal|"/dev/zfs"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_fd
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|g_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
block|}
name|g_refcount
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|g_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|libzfs_core_fini
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|g_lock
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|g_refcount
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_refcount
operator|--
expr_stmt|;
if|if
condition|(
name|g_refcount
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|g_fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|g_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lzc_ioctl
parameter_list|(
name|zfs_ioc_t
name|ioc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|source
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|resultp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|packed
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|ASSERT3S
argument_list|(
name|g_refcount
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|packed
operator|=
name|fnvlist_pack
argument_list|(
name|source
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_src
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|packed
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_src_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|resultp
operator|!=
name|NULL
condition|)
block|{
name|zc
operator|.
name|zc_nvlist_dst_size
operator|=
name|MAX
argument_list|(
name|size
operator|*
literal|2
argument_list|,
literal|128
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_dst
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|malloc
argument_list|(
name|zc
operator|.
name|zc_nvlist_dst_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|zc
operator|.
name|zc_nvlist_dst
operator|==
name|NULL
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|zc
operator|.
name|zc_nvlist_dst
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
while|while
condition|(
name|ioctl
argument_list|(
name|g_fd
argument_list|,
name|ioc
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
operator|&&
name|resultp
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_dst_size
operator|*=
literal|2
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_dst
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|malloc
argument_list|(
name|zc
operator|.
name|zc_nvlist_dst_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|zc
operator|.
name|zc_nvlist_dst
operator|==
name|NULL
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|zc
operator|.
name|zc_nvlist_dst
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|errno
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|zc
operator|.
name|zc_nvlist_dst_filled
condition|)
block|{
operator|*
name|resultp
operator|=
name|fnvlist_unpack
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|,
name|zc
operator|.
name|zc_nvlist_dst_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resultp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|resultp
operator|=
name|NULL
expr_stmt|;
block|}
name|out
label|:
name|fnvlist_pack_free
argument_list|(
name|packed
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|lzc_create
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
name|dmu_objset_type_t
name|type
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|nvlist_t
modifier|*
name|args
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|fnvlist_add_int32
argument_list|(
name|args
argument_list|,
literal|"type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
name|fnvlist_add_nvlist
argument_list|(
name|args
argument_list|,
literal|"props"
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|error
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_CREATE
argument_list|,
name|fsname
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|lzc_clone
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|nvlist_t
modifier|*
name|args
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|fnvlist_add_string
argument_list|(
name|args
argument_list|,
literal|"origin"
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
name|fnvlist_add_nvlist
argument_list|(
name|args
argument_list|,
literal|"props"
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|error
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_CLONE
argument_list|,
name|fsname
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Creates snapshots.  *  * The keys in the snaps nvlist are the snapshots to be created.  * They must all be in the same pool.  *  * The props nvlist is properties to set.  Currently only user properties  * are supported.  { user:prop_name -> string value }  *  * The returned results nvlist will have an entry for each snapshot that failed.  * The value will be the (int32) error code.  *  * The return value will be 0 if all snapshots were created, otherwise it will  * be the errno of a (undetermined) snapshot that failed.  */
name|int
name|lzc_snapshot
parameter_list|(
name|nvlist_t
modifier|*
name|snaps
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|errlist
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|pool
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
operator|*
name|errlist
operator|=
name|NULL
expr_stmt|;
comment|/* determine the pool name */
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pool
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pool
index|[
name|strcspn
argument_list|(
name|pool
argument_list|,
literal|"/@"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|args
argument_list|,
literal|"snaps"
argument_list|,
name|snaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
name|fnvlist_add_nvlist
argument_list|(
name|args
argument_list|,
literal|"props"
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|error
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_SNAPSHOT
argument_list|,
name|pool
argument_list|,
name|args
argument_list|,
name|errlist
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Destroys snapshots.  *  * The keys in the snaps nvlist are the snapshots to be destroyed.  * They must all be in the same pool.  *  * Snapshots that do not exist will be silently ignored.  *  * If 'defer' is not set, and a snapshot has user holds or clones, the  * destroy operation will fail and none of the snapshots will be  * destroyed.  *  * If 'defer' is set, and a snapshot has user holds or clones, it will be  * marked for deferred destruction, and will be destroyed when the last hold  * or clone is removed/destroyed.  *  * The return value will be 0 if all snapshots were destroyed (or marked for  * later destruction if 'defer' is set) or didn't exist to begin with.  *  * Otherwise the return value will be the errno of a (undetermined) snapshot  * that failed, no snapshots will be destroyed, and the errlist will have an  * entry for each snapshot that failed.  The value in the errlist will be  * the (int32) error code.  */
name|int
name|lzc_destroy_snaps
parameter_list|(
name|nvlist_t
modifier|*
name|snaps
parameter_list|,
name|boolean_t
name|defer
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|errlist
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|pool
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
comment|/* determine the pool name */
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pool
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pool
index|[
name|strcspn
argument_list|(
name|pool
argument_list|,
literal|"/@"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|args
argument_list|,
literal|"snaps"
argument_list|,
name|snaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|defer
condition|)
name|fnvlist_add_boolean
argument_list|(
name|args
argument_list|,
literal|"defer"
argument_list|)
expr_stmt|;
name|error
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_DESTROY_SNAPS
argument_list|,
name|pool
argument_list|,
name|args
argument_list|,
name|errlist
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|lzc_snaprange_space
parameter_list|(
specifier|const
name|char
modifier|*
name|firstsnap
parameter_list|,
specifier|const
name|char
modifier|*
name|lastsnap
parameter_list|,
name|uint64_t
modifier|*
name|usedp
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|nvlist_t
modifier|*
name|result
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
name|fs
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|atp
decl_stmt|;
comment|/* determine the fs name */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|fs
argument_list|,
name|firstsnap
argument_list|,
sizeof|sizeof
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
name|atp
operator|=
name|strchr
argument_list|(
name|fs
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|atp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|atp
operator|=
literal|'\0'
expr_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_string
argument_list|(
name|args
argument_list|,
literal|"firstsnap"
argument_list|,
name|firstsnap
argument_list|)
expr_stmt|;
name|err
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_SPACE_SNAPS
argument_list|,
name|lastsnap
argument_list|,
name|args
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
operator|*
name|usedp
operator|=
name|fnvlist_lookup_uint64
argument_list|(
name|result
argument_list|,
literal|"used"
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|boolean_t
name|lzc_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|dataset
parameter_list|)
block|{
comment|/* 	 * The objset_stats ioctl is still legacy, so we need to construct our 	 * own zfs_cmd_t rather than using zfsc_ioctl(). 	 */
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ioctl
argument_list|(
name|g_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
comment|/*  * If fromsnap is NULL, a full (non-incremental) stream will be sent.  */
name|int
name|lzc_send
parameter_list|(
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
specifier|const
name|char
modifier|*
name|fromsnap
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|int
name|err
decl_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_int32
argument_list|(
name|args
argument_list|,
literal|"fd"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromsnap
operator|!=
name|NULL
condition|)
name|fnvlist_add_string
argument_list|(
name|args
argument_list|,
literal|"fromsnap"
argument_list|,
name|fromsnap
argument_list|)
expr_stmt|;
name|err
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_SEND_NEW
argument_list|,
name|snapname
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*  * If fromsnap is NULL, a full (non-incremental) stream will be estimated.  */
name|int
name|lzc_send_space
parameter_list|(
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
specifier|const
name|char
modifier|*
name|fromsnap
parameter_list|,
name|uint64_t
modifier|*
name|spacep
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|nvlist_t
modifier|*
name|result
decl_stmt|;
name|int
name|err
decl_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|fromsnap
operator|!=
name|NULL
condition|)
name|fnvlist_add_string
argument_list|(
name|args
argument_list|,
literal|"fromsnap"
argument_list|,
name|fromsnap
argument_list|)
expr_stmt|;
name|err
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_SEND_SPACE
argument_list|,
name|snapname
argument_list|,
name|args
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
operator|*
name|spacep
operator|=
name|fnvlist_lookup_uint64
argument_list|(
name|result
argument_list|,
literal|"space"
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
specifier|static
name|int
name|recv_read
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|ilen
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|int
name|len
init|=
name|ilen
decl_stmt|;
do|do
block|{
name|rv
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|rv
expr_stmt|;
name|len
operator|-=
name|rv
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|rv
operator|<
literal|0
operator|||
name|len
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * The simplest receive case: receive from the specified fd, creating the  * specified snapshot.  Apply the specified properties a "received" properties  * (which can be overridden by locally-set properties).  If the stream is a  * clone, its origin snapshot must be specified by 'origin'.  The 'force'  * flag will cause the target filesystem to be rolled back or destroyed if  * necessary to receive.  *  * Return 0 on success or an errno on failure.  *  * Note: this interface does not work on dedup'd streams  * (those with DMU_BACKUP_FEATURE_DEDUP).  */
name|int
name|lzc_receive
parameter_list|(
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
comment|/* 	 * The receive ioctl is still legacy, so we need to construct our own 	 * zfs_cmd_t rather than using zfsc_ioctl(). 	 */
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|atp
decl_stmt|;
name|char
modifier|*
name|packed
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|dmu_replay_record_t
name|drr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT3S
argument_list|(
name|g_refcount
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* zc_name is name of containing filesystem */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|atp
operator|=
name|strchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|atp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|atp
operator|=
literal|'\0'
expr_stmt|;
comment|/* if the fs does not exist, try its parent. */
if|if
condition|(
operator|!
name|lzc_exists
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|slashp
init|=
name|strrchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|slashp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
operator|*
name|slashp
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* zc_value is full name of the snapshot to create */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
block|{
comment|/* zc_nvlist_src is props to set */
name|packed
operator|=
name|fnvlist_pack
argument_list|(
name|props
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_src
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|packed
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_src_size
operator|=
name|size
expr_stmt|;
block|}
comment|/* zc_string is name of clone origin (if DRR_FLAG_CLONE) */
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_string
argument_list|,
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_string
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zc_begin_record is non-byteswapped BEGIN record */
name|error
operator|=
name|recv_read
argument_list|(
name|fd
argument_list|,
operator|&
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|zc
operator|.
name|zc_begin_record
operator|=
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
expr_stmt|;
comment|/* zc_cookie is fd to read from */
name|zc
operator|.
name|zc_cookie
operator|=
name|fd
expr_stmt|;
comment|/* zc guid is force flag */
name|zc
operator|.
name|zc_guid
operator|=
name|force
expr_stmt|;
comment|/* zc_cleanup_fd is unused */
name|zc
operator|.
name|zc_cleanup_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|ioctl
argument_list|(
name|g_fd
argument_list|,
name|ZFS_IOC_RECV
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|errno
expr_stmt|;
name|out
label|:
if|if
condition|(
name|packed
operator|!=
name|NULL
condition|)
name|fnvlist_pack_free
argument_list|(
name|packed
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

