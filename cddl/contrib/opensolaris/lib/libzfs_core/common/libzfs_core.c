begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012, 2014 by Delphix. All rights reserved.  * Copyright (c) 2013 Steven Hartland. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  * Copyright 2017 RackTop Systems.  */
end_comment

begin_comment
comment|/*  * LibZFS_Core (lzc) is intended to replace most functionality in libzfs.  * It has the following characteristics:  *  *  - Thread Safe.  libzfs_core is accessible concurrently from multiple  *  threads.  This is accomplished primarily by avoiding global data  *  (e.g. caching).  Since it's thread-safe, there is no reason for a  *  process to have multiple libzfs "instances".  Therefore, we store  *  our few pieces of data (e.g. the file descriptor) in global  *  variables.  The fd is reference-counted so that the libzfs_core  *  library can be "initialized" multiple times (e.g. by different  *  consumers within the same process).  *  *  - Committed Interface.  The libzfs_core interface will be committed,  *  therefore consumers can compile against it and be confident that  *  their code will continue to work on future releases of this code.  *  Currently, the interface is Evolving (not Committed), but we intend  *  to commit to it once it is more complete and we determine that it  *  meets the needs of all consumers.  *  *  - Programatic Error Handling.  libzfs_core communicates errors with  *  defined error numbers, and doesn't print anything to stdout/stderr.  *  *  - Thin Layer.  libzfs_core is a thin layer, marshaling arguments  *  to/from the kernel ioctls.  There is generally a 1:1 correspondence  *  between libzfs_core functions and ioctls to /dev/zfs.  *  *  - Clear Atomicity.  Because libzfs_core functions are generally 1:1  *  with kernel ioctls, and kernel ioctls are general atomic, each  *  libzfs_core function is atomic.  For example, creating multiple  *  snapshots with a single call to lzc_snapshot() is atomic -- it  *  can't fail with only some of the requested snapshots created, even  *  in the event of power loss or system crash.  *  *  - Continued libzfs Support.  Some higher-level operations (e.g.  *  support for "zfs send -R") are too complicated to fit the scope of  *  libzfs_core.  This functionality will continue to live in libzfs.  *  Where appropriate, libzfs will use the underlying atomic operations  *  of libzfs_core.  For example, libzfs may implement "zfs send -R |  *  zfs receive" by using individual "send one snapshot", rename,  *  destroy, and "receive one snapshot" operations in libzfs_core.  *  /sbin/zfs and /zbin/zpool will link with both libzfs and  *  libzfs_core.  Other consumers should aim to use only libzfs_core,  *  since that will be the supported, stable interface going forwards.  */
end_comment

begin_define
define|#
directive|define
name|_IN_LIBZFS_CORE_
end_define

begin_include
include|#
directive|include
file|<libzfs_core.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvpair.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|"libzfs_core_compat.h"
end_include

begin_include
include|#
directive|include
file|"libzfs_compat.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|zfs_ioctl_version
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|g_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|g_lock
init|=
name|PTHREAD_MUTEX_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_refcount
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|libzfs_core_init
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|g_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_refcount
operator|==
literal|0
condition|)
block|{
name|g_fd
operator|=
name|open
argument_list|(
literal|"/dev/zfs"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_fd
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|g_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
block|}
name|g_refcount
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|g_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|libzfs_core_fini
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|g_lock
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|g_refcount
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_refcount
operator|--
expr_stmt|;
if|if
condition|(
name|g_refcount
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|g_fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|g_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lzc_ioctl
parameter_list|(
name|zfs_ioc_t
name|ioc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|source
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|resultp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|packed
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|nvlist_t
modifier|*
name|oldsource
decl_stmt|;
endif|#
directive|endif
name|size_t
name|size
decl_stmt|;
name|ASSERT3S
argument_list|(
name|g_refcount
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|zfs_ioctl_version
operator|==
name|ZFS_IOCVER_UNDEF
condition|)
name|zfs_ioctl_version
operator|=
name|get_zfs_ioctl_version
argument_list|()
expr_stmt|;
if|if
condition|(
name|zfs_ioctl_version
operator|<
name|ZFS_IOCVER_LZC
condition|)
block|{
name|oldsource
operator|=
name|source
expr_stmt|;
name|error
operator|=
name|lzc_compat_pre
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|ioc
argument_list|,
operator|&
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
name|packed
operator|=
name|fnvlist_pack
argument_list|(
name|source
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_src
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|packed
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_src_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|resultp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|resultp
operator|=
name|NULL
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_dst_size
operator|=
name|MAX
argument_list|(
name|size
operator|*
literal|2
argument_list|,
literal|128
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_dst
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|malloc
argument_list|(
name|zc
operator|.
name|zc_nvlist_dst_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|zc
operator|.
name|zc_nvlist_dst
operator|==
name|NULL
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|zc
operator|.
name|zc_nvlist_dst
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
while|while
condition|(
name|ioctl
argument_list|(
name|g_fd
argument_list|,
name|ioc
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
operator|&&
name|resultp
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_dst_size
operator|*=
literal|2
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_dst
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|malloc
argument_list|(
name|zc
operator|.
name|zc_nvlist_dst_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|zc
operator|.
name|zc_nvlist_dst
operator|==
name|NULL
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|zc
operator|.
name|zc_nvlist_dst
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|errno
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|zfs_ioctl_version
operator|<
name|ZFS_IOCVER_LZC
condition|)
name|lzc_compat_post
argument_list|(
operator|&
name|zc
argument_list|,
name|ioc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zc
operator|.
name|zc_nvlist_dst_filled
condition|)
block|{
operator|*
name|resultp
operator|=
name|fnvlist_unpack
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|,
name|zc
operator|.
name|zc_nvlist_dst_size
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|zfs_ioctl_version
operator|<
name|ZFS_IOCVER_LZC
condition|)
name|lzc_compat_outnvl
argument_list|(
operator|&
name|zc
argument_list|,
name|ioc
argument_list|,
name|resultp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
label|:
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|zfs_ioctl_version
operator|<
name|ZFS_IOCVER_LZC
condition|)
block|{
if|if
condition|(
name|source
operator|!=
name|oldsource
condition|)
name|nvlist_free
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|source
operator|=
name|oldsource
expr_stmt|;
block|}
endif|#
directive|endif
name|fnvlist_pack_free
argument_list|(
name|packed
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|lzc_create
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
name|enum
name|lzc_dataset_type
name|type
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|nvlist_t
modifier|*
name|args
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|fnvlist_add_int32
argument_list|(
name|args
argument_list|,
literal|"type"
argument_list|,
operator|(
name|dmu_objset_type_t
operator|)
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
name|fnvlist_add_nvlist
argument_list|(
name|args
argument_list|,
literal|"props"
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|error
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_CREATE
argument_list|,
name|fsname
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|lzc_clone
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|nvlist_t
modifier|*
name|args
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|fnvlist_add_string
argument_list|(
name|args
argument_list|,
literal|"origin"
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
name|fnvlist_add_nvlist
argument_list|(
name|args
argument_list|,
literal|"props"
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|error
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_CLONE
argument_list|,
name|fsname
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|lzc_promote
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
name|char
modifier|*
name|snapnamebuf
parameter_list|,
name|int
name|snapnamelen
parameter_list|)
block|{
comment|/* 	 * The promote ioctl is still legacy, so we need to construct our 	 * own zfs_cmd_t rather than using lzc_ioctl(). 	 */
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ASSERT3S
argument_list|(
name|g_refcount
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VERIFY3S
argument_list|(
name|g_fd
argument_list|,
operator|!=
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|fsname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|g_fd
argument_list|,
name|ZFS_IOC_PROMOTE
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|error
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|error
operator|==
name|EEXIST
operator|&&
name|snapnamebuf
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|snapnamebuf
argument_list|,
name|zc
operator|.
name|zc_string
argument_list|,
name|snapnamelen
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Creates snapshots.  *  * The keys in the snaps nvlist are the snapshots to be created.  * They must all be in the same pool.  *  * The props nvlist is properties to set.  Currently only user properties  * are supported.  { user:prop_name -> string value }  *  * The returned results nvlist will have an entry for each snapshot that failed.  * The value will be the (int32) error code.  *  * The return value will be 0 if all snapshots were created, otherwise it will  * be the errno of a (unspecified) snapshot that failed.  */
name|int
name|lzc_snapshot
parameter_list|(
name|nvlist_t
modifier|*
name|snaps
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|errlist
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|pool
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
operator|*
name|errlist
operator|=
name|NULL
expr_stmt|;
comment|/* determine the pool name */
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pool
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pool
index|[
name|strcspn
argument_list|(
name|pool
argument_list|,
literal|"/@"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|args
argument_list|,
literal|"snaps"
argument_list|,
name|snaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
name|fnvlist_add_nvlist
argument_list|(
name|args
argument_list|,
literal|"props"
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|error
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_SNAPSHOT
argument_list|,
name|pool
argument_list|,
name|args
argument_list|,
name|errlist
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Destroys snapshots.  *  * The keys in the snaps nvlist are the snapshots to be destroyed.  * They must all be in the same pool.  *  * Snapshots that do not exist will be silently ignored.  *  * If 'defer' is not set, and a snapshot has user holds or clones, the  * destroy operation will fail and none of the snapshots will be  * destroyed.  *  * If 'defer' is set, and a snapshot has user holds or clones, it will be  * marked for deferred destruction, and will be destroyed when the last hold  * or clone is removed/destroyed.  *  * The return value will be 0 if all snapshots were destroyed (or marked for  * later destruction if 'defer' is set) or didn't exist to begin with.  *  * Otherwise the return value will be the errno of a (unspecified) snapshot  * that failed, no snapshots will be destroyed, and the errlist will have an  * entry for each snapshot that failed.  The value in the errlist will be  * the (int32) error code.  */
name|int
name|lzc_destroy_snaps
parameter_list|(
name|nvlist_t
modifier|*
name|snaps
parameter_list|,
name|boolean_t
name|defer
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|errlist
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|pool
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
comment|/* determine the pool name */
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pool
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pool
index|[
name|strcspn
argument_list|(
name|pool
argument_list|,
literal|"/@"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|args
argument_list|,
literal|"snaps"
argument_list|,
name|snaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|defer
condition|)
name|fnvlist_add_boolean
argument_list|(
name|args
argument_list|,
literal|"defer"
argument_list|)
expr_stmt|;
name|error
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_DESTROY_SNAPS
argument_list|,
name|pool
argument_list|,
name|args
argument_list|,
name|errlist
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|lzc_snaprange_space
parameter_list|(
specifier|const
name|char
modifier|*
name|firstsnap
parameter_list|,
specifier|const
name|char
modifier|*
name|lastsnap
parameter_list|,
name|uint64_t
modifier|*
name|usedp
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|nvlist_t
modifier|*
name|result
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
name|fs
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|atp
decl_stmt|;
comment|/* determine the fs name */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|fs
argument_list|,
name|firstsnap
argument_list|,
sizeof|sizeof
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
name|atp
operator|=
name|strchr
argument_list|(
name|fs
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|atp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|atp
operator|=
literal|'\0'
expr_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_string
argument_list|(
name|args
argument_list|,
literal|"firstsnap"
argument_list|,
name|firstsnap
argument_list|)
expr_stmt|;
name|err
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_SPACE_SNAPS
argument_list|,
name|lastsnap
argument_list|,
name|args
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
operator|*
name|usedp
operator|=
name|fnvlist_lookup_uint64
argument_list|(
name|result
argument_list|,
literal|"used"
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|boolean_t
name|lzc_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|dataset
parameter_list|)
block|{
comment|/* 	 * The objset_stats ioctl is still legacy, so we need to construct our 	 * own zfs_cmd_t rather than using lzc_ioctl(). 	 */
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ioctl
argument_list|(
name|g_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
comment|/*  * Create "user holds" on snapshots.  If there is a hold on a snapshot,  * the snapshot can not be destroyed.  (However, it can be marked for deletion  * by lzc_destroy_snaps(defer=B_TRUE).)  *  * The keys in the nvlist are snapshot names.  * The snapshots must all be in the same pool.  * The value is the name of the hold (string type).  *  * If cleanup_fd is not -1, it must be the result of open("/dev/zfs", O_EXCL).  * In this case, when the cleanup_fd is closed (including on process  * termination), the holds will be released.  If the system is shut down  * uncleanly, the holds will be released when the pool is next opened  * or imported.  *  * Holds for snapshots which don't exist will be skipped and have an entry  * added to errlist, but will not cause an overall failure.  *  * The return value will be 0 if all holds, for snapshots that existed,  * were succesfully created.  *  * Otherwise the return value will be the errno of a (unspecified) hold that  * failed and no holds will be created.  *  * In all cases the errlist will have an entry for each hold that failed  * (name = snapshot), with its value being the error code (int32).  */
name|int
name|lzc_hold
parameter_list|(
name|nvlist_t
modifier|*
name|holds
parameter_list|,
name|int
name|cleanup_fd
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|errlist
parameter_list|)
block|{
name|char
name|pool
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* determine the pool name */
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|holds
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pool
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pool
index|[
name|strcspn
argument_list|(
name|pool
argument_list|,
literal|"/@"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|args
argument_list|,
literal|"holds"
argument_list|,
name|holds
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_fd
operator|!=
operator|-
literal|1
condition|)
name|fnvlist_add_int32
argument_list|(
name|args
argument_list|,
literal|"cleanup_fd"
argument_list|,
name|cleanup_fd
argument_list|)
expr_stmt|;
name|error
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_HOLD
argument_list|,
name|pool
argument_list|,
name|args
argument_list|,
name|errlist
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Release "user holds" on snapshots.  If the snapshot has been marked for  * deferred destroy (by lzc_destroy_snaps(defer=B_TRUE)), it does not have  * any clones, and all the user holds are removed, then the snapshot will be  * destroyed.  *  * The keys in the nvlist are snapshot names.  * The snapshots must all be in the same pool.  * The value is a nvlist whose keys are the holds to remove.  *  * Holds which failed to release because they didn't exist will have an entry  * added to errlist, but will not cause an overall failure.  *  * The return value will be 0 if the nvl holds was empty or all holds that  * existed, were successfully removed.  *  * Otherwise the return value will be the errno of a (unspecified) hold that  * failed to release and no holds will be released.  *  * In all cases the errlist will have an entry for each hold that failed to  * to release.  */
name|int
name|lzc_release
parameter_list|(
name|nvlist_t
modifier|*
name|holds
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|errlist
parameter_list|)
block|{
name|char
name|pool
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
comment|/* determine the pool name */
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|holds
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pool
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pool
index|[
name|strcspn
argument_list|(
name|pool
argument_list|,
literal|"/@"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_RELEASE
argument_list|,
name|pool
argument_list|,
name|holds
argument_list|,
name|errlist
argument_list|)
operator|)
return|;
block|}
comment|/*  * Retrieve list of user holds on the specified snapshot.  *  * On success, *holdsp will be set to a nvlist which the caller must free.  * The keys are the names of the holds, and the value is the creation time  * of the hold (uint64) in seconds since the epoch.  */
name|int
name|lzc_get_holds
parameter_list|(
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|holdsp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|nvlist_t
modifier|*
name|innvl
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|error
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_GET_HOLDS
argument_list|,
name|snapname
argument_list|,
name|innvl
argument_list|,
name|holdsp
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|innvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Generate a zfs send stream for the specified snapshot and write it to  * the specified file descriptor.  *  * "snapname" is the full name of the snapshot to send (e.g. "pool/fs@snap")  *  * If "from" is NULL, a full (non-incremental) stream will be sent.  * If "from" is non-NULL, it must be the full name of a snapshot or  * bookmark to send an incremental from (e.g. "pool/fs@earlier_snap" or  * "pool/fs#earlier_bmark").  If non-NULL, the specified snapshot or  * bookmark must represent an earlier point in the history of "snapname").  * It can be an earlier snapshot in the same filesystem or zvol as "snapname",  * or it can be the origin of "snapname"'s filesystem, or an earlier  * snapshot in the origin, etc.  *  * "fd" is the file descriptor to write the send stream to.  *  * If "flags" contains LZC_SEND_FLAG_LARGE_BLOCK, the stream is permitted  * to contain DRR_WRITE records with drr_length> 128K, and DRR_OBJECT  * records with drr_blksz> 128K.  *  * If "flags" contains LZC_SEND_FLAG_EMBED_DATA, the stream is permitted  * to contain DRR_WRITE_EMBEDDED records with drr_etype==BP_EMBEDDED_TYPE_DATA,  * which the receiving system must support (as indicated by support  * for the "embedded_data" feature).  */
name|int
name|lzc_send
parameter_list|(
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
name|int
name|fd
parameter_list|,
name|enum
name|lzc_send_flags
name|flags
parameter_list|)
block|{
return|return
operator|(
name|lzc_send_resume
argument_list|(
name|snapname
argument_list|,
name|from
argument_list|,
name|fd
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
name|int
name|lzc_send_resume
parameter_list|(
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
name|int
name|fd
parameter_list|,
name|enum
name|lzc_send_flags
name|flags
parameter_list|,
name|uint64_t
name|resumeobj
parameter_list|,
name|uint64_t
name|resumeoff
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|int
name|err
decl_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_int32
argument_list|(
name|args
argument_list|,
literal|"fd"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
name|fnvlist_add_string
argument_list|(
name|args
argument_list|,
literal|"fromsnap"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LZC_SEND_FLAG_LARGE_BLOCK
condition|)
name|fnvlist_add_boolean
argument_list|(
name|args
argument_list|,
literal|"largeblockok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LZC_SEND_FLAG_EMBED_DATA
condition|)
name|fnvlist_add_boolean
argument_list|(
name|args
argument_list|,
literal|"embedok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LZC_SEND_FLAG_COMPRESS
condition|)
name|fnvlist_add_boolean
argument_list|(
name|args
argument_list|,
literal|"compressok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|resumeobj
operator|!=
literal|0
operator|||
name|resumeoff
operator|!=
literal|0
condition|)
block|{
name|fnvlist_add_uint64
argument_list|(
name|args
argument_list|,
literal|"resume_object"
argument_list|,
name|resumeobj
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|args
argument_list|,
literal|"resume_offset"
argument_list|,
name|resumeoff
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_SEND_NEW
argument_list|,
name|snapname
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*  * "from" can be NULL, a snapshot, or a bookmark.  *  * If from is NULL, a full (non-incremental) stream will be estimated.  This  * is calculated very efficiently.  *  * If from is a snapshot, lzc_send_space uses the deadlists attached to  * each snapshot to efficiently estimate the stream size.  *  * If from is a bookmark, the indirect blocks in the destination snapshot  * are traversed, looking for blocks with a birth time since the creation TXG of  * the snapshot this bookmark was created from.  This will result in  * significantly more I/O and be less efficient than a send space estimation on  * an equivalent snapshot.  */
name|int
name|lzc_send_space
parameter_list|(
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
name|enum
name|lzc_send_flags
name|flags
parameter_list|,
name|uint64_t
modifier|*
name|spacep
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|nvlist_t
modifier|*
name|result
decl_stmt|;
name|int
name|err
decl_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
name|fnvlist_add_string
argument_list|(
name|args
argument_list|,
literal|"from"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LZC_SEND_FLAG_LARGE_BLOCK
condition|)
name|fnvlist_add_boolean
argument_list|(
name|args
argument_list|,
literal|"largeblockok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LZC_SEND_FLAG_EMBED_DATA
condition|)
name|fnvlist_add_boolean
argument_list|(
name|args
argument_list|,
literal|"embedok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LZC_SEND_FLAG_COMPRESS
condition|)
name|fnvlist_add_boolean
argument_list|(
name|args
argument_list|,
literal|"compressok"
argument_list|)
expr_stmt|;
name|err
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_SEND_SPACE
argument_list|,
name|snapname
argument_list|,
name|args
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
operator|*
name|spacep
operator|=
name|fnvlist_lookup_uint64
argument_list|(
name|result
argument_list|,
literal|"space"
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
specifier|static
name|int
name|recv_read
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|ilen
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|int
name|len
init|=
name|ilen
decl_stmt|;
do|do
block|{
name|rv
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|rv
expr_stmt|;
name|len
operator|-=
name|rv
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|rv
operator|<
literal|0
operator|||
name|len
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|recv_impl
parameter_list|(
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|boolean_t
name|resumable
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|dmu_replay_record_t
modifier|*
name|begin_record
parameter_list|)
block|{
comment|/* 	 * The receive ioctl is still legacy, so we need to construct our own 	 * zfs_cmd_t rather than using zfsc_ioctl(). 	 */
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|atp
decl_stmt|;
name|char
modifier|*
name|packed
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT3S
argument_list|(
name|g_refcount
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* zc_name is name of containing filesystem */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|atp
operator|=
name|strchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|atp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|atp
operator|=
literal|'\0'
expr_stmt|;
comment|/* if the fs does not exist, try its parent. */
if|if
condition|(
operator|!
name|lzc_exists
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|slashp
init|=
name|strrchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|slashp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
operator|*
name|slashp
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* zc_value is full name of the snapshot to create */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
block|{
comment|/* zc_nvlist_src is props to set */
name|packed
operator|=
name|fnvlist_pack
argument_list|(
name|props
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_src
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|packed
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_src_size
operator|=
name|size
expr_stmt|;
block|}
comment|/* zc_string is name of clone origin (if DRR_FLAG_CLONE) */
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_string
argument_list|,
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_string
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zc_begin_record is non-byteswapped BEGIN record */
if|if
condition|(
name|begin_record
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|recv_read
argument_list|(
name|fd
argument_list|,
operator|&
name|zc
operator|.
name|zc_begin_record
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_begin_record
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|zc
operator|.
name|zc_begin_record
operator|=
operator|*
name|begin_record
expr_stmt|;
block|}
comment|/* zc_cookie is fd to read from */
name|zc
operator|.
name|zc_cookie
operator|=
name|fd
expr_stmt|;
comment|/* zc guid is force flag */
name|zc
operator|.
name|zc_guid
operator|=
name|force
expr_stmt|;
name|zc
operator|.
name|zc_resumable
operator|=
name|resumable
expr_stmt|;
comment|/* zc_cleanup_fd is unused */
name|zc
operator|.
name|zc_cleanup_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|ioctl
argument_list|(
name|g_fd
argument_list|,
name|ZFS_IOC_RECV
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|errno
expr_stmt|;
name|out
label|:
if|if
condition|(
name|packed
operator|!=
name|NULL
condition|)
name|fnvlist_pack_free
argument_list|(
name|packed
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * The simplest receive case: receive from the specified fd, creating the  * specified snapshot.  Apply the specified properties as "received" properties  * (which can be overridden by locally-set properties).  If the stream is a  * clone, its origin snapshot must be specified by 'origin'.  The 'force'  * flag will cause the target filesystem to be rolled back or destroyed if  * necessary to receive.  *  * Return 0 on success or an errno on failure.  *  * Note: this interface does not work on dedup'd streams  * (those with DMU_BACKUP_FEATURE_DEDUP).  */
name|int
name|lzc_receive
parameter_list|(
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
return|return
operator|(
name|recv_impl
argument_list|(
name|snapname
argument_list|,
name|props
argument_list|,
name|origin
argument_list|,
name|force
argument_list|,
name|B_FALSE
argument_list|,
name|fd
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
comment|/*  * Like lzc_receive, but if the receive fails due to premature stream  * termination, the intermediate state will be preserved on disk.  In this  * case, ECKSUM will be returned.  The receive may subsequently be resumed  * with a resuming send stream generated by lzc_send_resume().  */
name|int
name|lzc_receive_resumable
parameter_list|(
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
return|return
operator|(
name|recv_impl
argument_list|(
name|snapname
argument_list|,
name|props
argument_list|,
name|origin
argument_list|,
name|force
argument_list|,
name|B_TRUE
argument_list|,
name|fd
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
comment|/*  * Like lzc_receive, but allows the caller to read the begin record and then to  * pass it in.  That could be useful if the caller wants to derive, for example,  * the snapname or the origin parameters based on the information contained in  * the begin record.  * The begin record must be in its original form as read from the stream,  * in other words, it should not be byteswapped.  *  * The 'resumable' parameter allows to obtain the same behavior as with  * lzc_receive_resumable.  */
name|int
name|lzc_receive_with_header
parameter_list|(
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|boolean_t
name|resumable
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|dmu_replay_record_t
modifier|*
name|begin_record
parameter_list|)
block|{
if|if
condition|(
name|begin_record
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|recv_impl
argument_list|(
name|snapname
argument_list|,
name|props
argument_list|,
name|origin
argument_list|,
name|force
argument_list|,
name|resumable
argument_list|,
name|fd
argument_list|,
name|begin_record
argument_list|)
operator|)
return|;
block|}
comment|/*  * Roll back this filesystem or volume to its most recent snapshot.  * If snapnamebuf is not NULL, it will be filled in with the name  * of the most recent snapshot.  * Note that the latest snapshot may change if a new one is concurrently  * created or the current one is destroyed.  lzc_rollback_to can be used  * to roll back to a specific latest snapshot.  *  * Return 0 on success or an errno on failure.  */
name|int
name|lzc_rollback
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
name|char
modifier|*
name|snapnamebuf
parameter_list|,
name|int
name|snapnamelen
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|nvlist_t
modifier|*
name|result
decl_stmt|;
name|int
name|err
decl_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|err
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_ROLLBACK
argument_list|,
name|fsname
argument_list|,
name|args
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|snapnamebuf
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|snapname
init|=
name|fnvlist_lookup_string
argument_list|(
name|result
argument_list|,
literal|"target"
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|snapnamebuf
argument_list|,
name|snapname
argument_list|,
name|snapnamelen
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*  * Roll back this filesystem or volume to the specified snapshot,  * if possible.  *  * Return 0 on success or an errno on failure.  */
name|int
name|lzc_rollback_to
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
specifier|const
name|char
modifier|*
name|snapname
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|args
decl_stmt|;
name|nvlist_t
modifier|*
name|result
decl_stmt|;
name|int
name|err
decl_stmt|;
name|args
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_string
argument_list|(
name|args
argument_list|,
literal|"target"
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
name|err
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_ROLLBACK
argument_list|,
name|fsname
argument_list|,
name|args
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*  * Creates bookmarks.  *  * The bookmarks nvlist maps from name of the bookmark (e.g. "pool/fs#bmark") to  * the name of the snapshot (e.g. "pool/fs@snap").  All the bookmarks and  * snapshots must be in the same pool.  *  * The returned results nvlist will have an entry for each bookmark that failed.  * The value will be the (int32) error code.  *  * The return value will be 0 if all bookmarks were created, otherwise it will  * be the errno of a (undetermined) bookmarks that failed.  */
name|int
name|lzc_bookmark
parameter_list|(
name|nvlist_t
modifier|*
name|bookmarks
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|errlist
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|pool
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
comment|/* determine the pool name */
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|bookmarks
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pool
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pool
index|[
name|strcspn
argument_list|(
name|pool
argument_list|,
literal|"/#"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_BOOKMARK
argument_list|,
name|pool
argument_list|,
name|bookmarks
argument_list|,
name|errlist
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Retrieve bookmarks.  *  * Retrieve the list of bookmarks for the given file system. The props  * parameter is an nvlist of property names (with no values) that will be  * returned for each bookmark.  *  * The following are valid properties on bookmarks, all of which are numbers  * (represented as uint64 in the nvlist)  *  * "guid" - globally unique identifier of the snapshot it refers to  * "createtxg" - txg when the snapshot it refers to was created  * "creation" - timestamp when the snapshot it refers to was created  *  * The format of the returned nvlist as follows:  *<short name of bookmark> -> {  *<name of property> -> {  *         "value" -> uint64  *     }  *  }  */
name|int
name|lzc_get_bookmarks
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|bmarks
parameter_list|)
block|{
return|return
operator|(
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_GET_BOOKMARKS
argument_list|,
name|fsname
argument_list|,
name|props
argument_list|,
name|bmarks
argument_list|)
operator|)
return|;
block|}
comment|/*  * Destroys bookmarks.  *  * The keys in the bmarks nvlist are the bookmarks to be destroyed.  * They must all be in the same pool.  Bookmarks are specified as  *<fs>#<bmark>.  *  * Bookmarks that do not exist will be silently ignored.  *  * The return value will be 0 if all bookmarks that existed were destroyed.  *  * Otherwise the return value will be the errno of a (undetermined) bookmark  * that failed, no bookmarks will be destroyed, and the errlist will have an  * entry for each bookmarks that failed.  The value in the errlist will be  * the (int32) error code.  */
name|int
name|lzc_destroy_bookmarks
parameter_list|(
name|nvlist_t
modifier|*
name|bmarks
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|errlist
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|pool
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
comment|/* determine the pool name */
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|bmarks
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pool
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pool
index|[
name|strcspn
argument_list|(
name|pool
argument_list|,
literal|"/#"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|lzc_ioctl
argument_list|(
name|ZFS_IOC_DESTROY_BOOKMARKS
argument_list|,
name|pool
argument_list|,
name|bmarks
argument_list|,
name|errlist
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

