begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/processor.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/zmod.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_comment
comment|/*  * Emulation of kernel services in userland.  */
end_comment

begin_decl_stmt
name|int
name|hz
init|=
literal|119
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frequency when using gethrtime()>> 23 for lbolt */
end_comment

begin_decl_stmt
name|uint64_t
name|physmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vnode_t
modifier|*
name|rootdir
init|=
operator|(
name|vnode_t
operator|*
operator|)
literal|0xabcd1234
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|hw_serial
index|[
literal|11
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|utsname
name|utsname
init|=
block|{
literal|"userland"
block|,
literal|"libzpool"
block|,
literal|"1"
block|,
literal|"1"
block|,
literal|"na"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * =========================================================================  * threads  * =========================================================================  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|kthread_t
modifier|*
name|zk_thread_create
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|thread_t
name|tid
decl_stmt|;
name|VERIFY
argument_list|(
name|thr_create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
call|(
modifier|*
call|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|func
argument_list|,
name|arg
argument_list|,
name|THR_DETACHED
argument_list|,
operator|&
name|tid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|tid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * =========================================================================  * kstats  * =========================================================================  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|kstat_t
modifier|*
name|kstat_create
parameter_list|(
name|char
modifier|*
name|module
parameter_list|,
name|int
name|instance
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|class
parameter_list|,
name|uchar_t
name|type
parameter_list|,
name|ulong_t
name|ndata
parameter_list|,
name|uchar_t
name|ks_flag
parameter_list|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|kstat_install
parameter_list|(
name|kstat_t
modifier|*
name|ksp
parameter_list|)
block|{}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|kstat_delete
parameter_list|(
name|kstat_t
modifier|*
name|ksp
parameter_list|)
block|{}
end_function

begin_comment
comment|/*  * =========================================================================  * mutexes  * =========================================================================  */
end_comment

begin_function
name|void
name|zmutex_init
parameter_list|(
name|kmutex_t
modifier|*
name|mp
parameter_list|)
block|{
name|mp
operator|->
name|m_owner
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|_mutex_init
argument_list|(
operator|&
name|mp
operator|->
name|m_lock
argument_list|,
name|USYNC_THREAD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zmutex_destroy
parameter_list|(
name|kmutex_t
modifier|*
name|mp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_owner
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_mutex_destroy
argument_list|(
operator|&
operator|(
name|mp
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_owner
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1UL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mutex_enter
parameter_list|(
name|kmutex_t
modifier|*
name|mp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_owner
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1UL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_owner
operator|!=
name|curthread
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|mutex_lock
argument_list|(
operator|&
name|mp
operator|->
name|m_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_owner
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_owner
operator|=
name|curthread
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mutex_tryenter
parameter_list|(
name|kmutex_t
modifier|*
name|mp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_owner
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1UL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mutex_trylock
argument_list|(
operator|&
name|mp
operator|->
name|m_lock
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_owner
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_owner
operator|=
name|curthread
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|mutex_exit
parameter_list|(
name|kmutex_t
modifier|*
name|mp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_owner
operator|==
name|curthread
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_owner
operator|=
name|NULL
expr_stmt|;
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|mp
operator|->
name|m_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|mutex_owner
parameter_list|(
name|kmutex_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
operator|(
name|mp
operator|->
name|m_owner
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * =========================================================================  * rwlocks  * =========================================================================  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|rw_init
parameter_list|(
name|krwlock_t
modifier|*
name|rwlp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rwlock_init
argument_list|(
operator|&
name|rwlp
operator|->
name|rw_lock
argument_list|,
name|USYNC_THREAD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rwlp
operator|->
name|rw_owner
operator|=
name|NULL
expr_stmt|;
name|rwlp
operator|->
name|rw_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rw_destroy
parameter_list|(
name|krwlock_t
modifier|*
name|rwlp
parameter_list|)
block|{
name|rwlock_destroy
argument_list|(
operator|&
name|rwlp
operator|->
name|rw_lock
argument_list|)
expr_stmt|;
name|rwlp
operator|->
name|rw_owner
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1UL
expr_stmt|;
name|rwlp
operator|->
name|rw_count
operator|=
operator|-
literal|2
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rw_enter
parameter_list|(
name|krwlock_t
modifier|*
name|rwlp
parameter_list|,
name|krw_t
name|rw
parameter_list|)
block|{
comment|//ASSERT(!RW_LOCK_HELD(rwlp));
name|ASSERT
argument_list|(
name|rwlp
operator|->
name|rw_owner
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1UL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rwlp
operator|->
name|rw_owner
operator|!=
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|RW_READER
condition|)
block|{
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|rwlp
operator|->
name|rw_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rwlp
operator|->
name|rw_count
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|rwlp
operator|->
name|rw_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|rw_wrlock
argument_list|(
operator|&
name|rwlp
operator|->
name|rw_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rwlp
operator|->
name|rw_count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|rwlp
operator|->
name|rw_count
operator|=
operator|-
literal|1
expr_stmt|;
name|rwlp
operator|->
name|rw_owner
operator|=
name|curthread
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rw_exit
parameter_list|(
name|krwlock_t
modifier|*
name|rwlp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|rwlp
operator|->
name|rw_owner
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1UL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rwlp
operator|->
name|rw_owner
operator|==
name|curthread
condition|)
block|{
comment|/* Write locked. */
name|ASSERT
argument_list|(
name|rwlp
operator|->
name|rw_count
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rwlp
operator|->
name|rw_count
operator|=
literal|0
expr_stmt|;
name|rwlp
operator|->
name|rw_owner
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Read locked. */
name|ASSERT
argument_list|(
name|rwlp
operator|->
name|rw_count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|rwlp
operator|->
name|rw_count
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|rwlp
operator|->
name|rw_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rw_tryenter
parameter_list|(
name|krwlock_t
modifier|*
name|rwlp
parameter_list|,
name|krw_t
name|rw
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|ASSERT
argument_list|(
name|rwlp
operator|->
name|rw_owner
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1UL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rwlp
operator|->
name|rw_owner
operator|!=
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|RW_READER
condition|)
name|rv
operator|=
name|rw_tryrdlock
argument_list|(
operator|&
name|rwlp
operator|->
name|rw_lock
argument_list|)
expr_stmt|;
else|else
name|rv
operator|=
name|rw_trywrlock
argument_list|(
operator|&
name|rwlp
operator|->
name|rw_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|rwlp
operator|->
name|rw_owner
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|RW_READER
condition|)
block|{
name|ASSERT
argument_list|(
name|rwlp
operator|->
name|rw_count
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|rwlp
operator|->
name|rw_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|rwlp
operator|->
name|rw_count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|rwlp
operator|->
name|rw_count
operator|=
operator|-
literal|1
expr_stmt|;
name|rwlp
operator|->
name|rw_owner
operator|=
name|curthread
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|rw_tryupgrade
parameter_list|(
name|krwlock_t
modifier|*
name|rwlp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|rwlp
operator|->
name|rw_owner
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1UL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rw_lock_held
parameter_list|(
name|krwlock_t
modifier|*
name|rwlp
parameter_list|)
block|{
return|return
operator|(
name|rwlp
operator|->
name|rw_count
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * =========================================================================  * condition variables  * =========================================================================  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cv_init
parameter_list|(
name|kcondvar_t
modifier|*
name|cv
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|VERIFY
argument_list|(
name|cond_init
argument_list|(
name|cv
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cv_destroy
parameter_list|(
name|kcondvar_t
modifier|*
name|cv
parameter_list|)
block|{
name|VERIFY
argument_list|(
name|cond_destroy
argument_list|(
name|cv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cv_wait
parameter_list|(
name|kcondvar_t
modifier|*
name|cv
parameter_list|,
name|kmutex_t
modifier|*
name|mp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mutex_owner
argument_list|(
name|mp
argument_list|)
operator|==
name|curthread
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_owner
operator|=
name|NULL
expr_stmt|;
name|int
name|ret
init|=
name|cond_wait
argument_list|(
name|cv
argument_list|,
operator|&
name|mp
operator|->
name|m_lock
argument_list|)
decl_stmt|;
name|VERIFY
argument_list|(
name|ret
operator|==
literal|0
operator|||
name|ret
operator|==
name|EINTR
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_owner
operator|=
name|curthread
expr_stmt|;
block|}
end_function

begin_function
name|clock_t
name|cv_timedwait
parameter_list|(
name|kcondvar_t
modifier|*
name|cv
parameter_list|,
name|kmutex_t
modifier|*
name|mp
parameter_list|,
name|clock_t
name|abstime
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|clock_t
name|delta
decl_stmt|;
name|ASSERT
argument_list|(
name|abstime
operator|>
literal|0
argument_list|)
expr_stmt|;
name|top
label|:
name|delta
operator|=
name|abstime
expr_stmt|;
if|if
condition|(
name|delta
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|assert
argument_list|(
operator|!
literal|"gettimeofday() failed"
argument_list|)
expr_stmt|;
name|ts
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
operator|+
name|delta
operator|/
name|hz
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
name|tv
operator|.
name|tv_usec
operator|*
literal|1000
operator|+
operator|(
name|delta
operator|%
name|hz
operator|)
operator|*
operator|(
name|NANOSEC
operator|/
name|hz
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ts
operator|.
name|tv_nsec
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|tv_nsec
operator|>=
name|NANOSEC
condition|)
block|{
name|ts
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|-=
name|NANOSEC
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|mutex_owner
argument_list|(
name|mp
argument_list|)
operator|==
name|curthread
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_owner
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|pthread_cond_timedwait
argument_list|(
name|cv
argument_list|,
operator|&
name|mp
operator|->
name|m_lock
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_owner
operator|=
name|curthread
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
goto|goto
name|top
goto|;
if|if
condition|(
name|error
operator|==
name|ETIMEDOUT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cv_signal
parameter_list|(
name|kcondvar_t
modifier|*
name|cv
parameter_list|)
block|{
name|VERIFY
argument_list|(
name|cond_signal
argument_list|(
name|cv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cv_broadcast
parameter_list|(
name|kcondvar_t
modifier|*
name|cv
parameter_list|)
block|{
name|VERIFY
argument_list|(
name|cond_broadcast
argument_list|(
name|cv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * =========================================================================  * vnode operations  * =========================================================================  */
end_comment

begin_comment
comment|/*  * Note: for the xxxat() versions of these functions, we assume that the  * starting vp is always rootdir (which is true for spa_directory.c, the only  * ZFS consumer of these interfaces).  We assert this is true, and then emulate  * them by adding '/' in front of the path.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|vn_open
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|x3
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|int
name|old_umask
decl_stmt|;
name|char
name|realpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat64
name|st
decl_stmt|;
comment|/* 	 * If we're accessing a real disk from userland, we need to use 	 * the character interface to avoid caching.  This is particularly 	 * important if we're trying to look at a real in-kernel storage 	 * pool from userland, e.g. via zdb, because otherwise we won't 	 * see the changes occurring under the segmap cache. 	 * On the other hand, the stupid character device returns zero 	 * for its size.  So -- gag -- we open the block device to get 	 * its size, and remember it for subsequent VOP_GETATTR(). 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|path
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|dsk
decl_stmt|;
name|fd
operator|=
name|open64
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|errno
operator|)
return|;
if|if
condition|(
name|fstat64
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|realpath
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|dsk
operator|=
name|strstr
argument_list|(
name|path
argument_list|,
literal|"/dsk/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsk
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|realpath
operator|+
operator|(
name|dsk
operator|-
name|path
operator|)
operator|+
literal|1
argument_list|,
literal|"r%s"
argument_list|,
name|dsk
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|realpath
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FCREAT
operator|)
operator|&&
name|stat64
argument_list|(
name|realpath
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|errno
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|FCREAT
condition|)
name|old_umask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * The construct 'flags - FREAD' conveniently maps combinations of 	 * FREAD and FWRITE to the corresponding O_RDONLY, O_WRONLY, and O_RDWR. 	 */
name|fd
operator|=
name|open64
argument_list|(
name|realpath
argument_list|,
name|flags
operator|-
name|FREAD
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FCREAT
condition|)
operator|(
name|void
operator|)
name|umask
argument_list|(
name|old_umask
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|errno
operator|)
return|;
if|if
condition|(
name|fstat64
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
operator|=
name|umem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vnode_t
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|S_ISCHR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|DIOCGMEDIASIZE
argument_list|,
operator|&
name|vp
operator|->
name|v_size
argument_list|)
expr_stmt|;
else|else
name|vp
operator|->
name|v_size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|vp
operator|->
name|v_path
operator|=
name|spa_strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vn_openat
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|x3
parameter_list|,
name|vnode_t
modifier|*
name|startvp
parameter_list|)
block|{
name|char
modifier|*
name|realpath
init|=
name|umem_alloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|2
argument_list|,
name|UMEM_NOFAIL
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ASSERT
argument_list|(
name|startvp
operator|==
name|rootdir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|realpath
argument_list|,
literal|"/%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vn_open
argument_list|(
name|realpath
argument_list|,
name|x1
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|vpp
argument_list|,
name|x2
argument_list|,
name|x3
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|realpath
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|vn_rdwr
parameter_list|(
name|int
name|uio
parameter_list|,
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|offset_t
name|offset
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|x2
parameter_list|,
name|rlim64_t
name|x3
parameter_list|,
name|void
modifier|*
name|x4
parameter_list|,
name|ssize_t
modifier|*
name|residp
parameter_list|)
block|{
name|ssize_t
name|iolen
decl_stmt|,
name|split
decl_stmt|;
if|if
condition|(
name|uio
operator|==
name|UIO_READ
condition|)
block|{
name|iolen
operator|=
name|pread64
argument_list|(
name|vp
operator|->
name|v_fd
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * To simulate partial disk writes, we split writes into two 		 * system calls so that the process can be killed in between. 		 */
name|split
operator|=
operator|(
name|len
operator|>
literal|0
condition|?
name|rand
argument_list|()
operator|%
name|len
else|:
literal|0
operator|)
expr_stmt|;
name|iolen
operator|=
name|pwrite64
argument_list|(
name|vp
operator|->
name|v_fd
argument_list|,
name|addr
argument_list|,
name|split
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|iolen
operator|+=
name|pwrite64
argument_list|(
name|vp
operator|->
name|v_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
name|split
argument_list|,
name|len
operator|-
name|split
argument_list|,
name|offset
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iolen
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|errno
operator|)
return|;
if|if
condition|(
name|residp
condition|)
operator|*
name|residp
operator|=
name|len
operator|-
name|iolen
expr_stmt|;
elseif|else
if|if
condition|(
name|iolen
operator|!=
name|len
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vn_close
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|close
argument_list|(
name|vp
operator|->
name|v_fd
argument_list|)
expr_stmt|;
name|spa_strfree
argument_list|(
name|vp
operator|->
name|v_path
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
name|vnode_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ZFS_DEBUG
end_ifdef

begin_comment
comment|/*  * =========================================================================  * Figure out which debugging statements to print  * =========================================================================  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dprintf_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dprintf_print_all
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|dprintf_find_string
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
modifier|*
name|tmp_str
init|=
name|dprintf_string
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
comment|/* 	 * Find out if this is a string we want to print. 	 * String format: file1.c,function_name1,file2.c,file3.c 	 */
while|while
condition|(
name|tmp_str
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|tmp_str
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|tmp_str
index|[
name|len
index|]
operator|==
literal|','
operator|||
name|tmp_str
index|[
name|len
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tmp_str
operator|=
name|strchr
argument_list|(
name|tmp_str
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_str
operator|!=
name|NULL
condition|)
name|tmp_str
operator|++
expr_stmt|;
comment|/* Get rid of , */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dprintf_setup
parameter_list|(
name|int
modifier|*
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * Debugging can be specified two ways: by setting the 	 * environment variable ZFS_DEBUG, or by including a 	 * "debug=..."  argument on the command line.  The command 	 * line setting overrides the environment variable. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
literal|"debug="
argument_list|)
decl_stmt|;
comment|/* First look for a command line argument */
if|if
condition|(
name|strncmp
argument_list|(
literal|"debug="
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dprintf_string
operator|=
name|argv
index|[
name|i
index|]
operator|+
name|len
expr_stmt|;
comment|/* Remove from args */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
operator|*
name|argc
condition|;
name|j
operator|++
control|)
name|argv
index|[
name|j
index|]
operator|=
name|argv
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|argv
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|argc
operator|)
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dprintf_string
operator|==
name|NULL
condition|)
block|{
comment|/* Look for ZFS_DEBUG environment variable */
name|dprintf_string
operator|=
name|getenv
argument_list|(
literal|"ZFS_DEBUG"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Are we just turning on all debugging? 	 */
if|if
condition|(
name|dprintf_find_string
argument_list|(
literal|"on"
argument_list|)
condition|)
name|dprintf_print_all
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * =========================================================================  * debug printfs  * =========================================================================  */
end_comment

begin_function
name|void
name|__dprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|newfile
decl_stmt|;
name|va_list
name|adx
decl_stmt|;
comment|/* 	 * Get rid of annoying "../common/" prefix to filename. 	 */
name|newfile
operator|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfile
operator|!=
name|NULL
condition|)
block|{
name|newfile
operator|=
name|newfile
operator|+
literal|1
expr_stmt|;
comment|/* Get rid of leading / */
block|}
else|else
block|{
name|newfile
operator|=
name|file
expr_stmt|;
block|}
if|if
condition|(
name|dprintf_print_all
operator|||
name|dprintf_find_string
argument_list|(
name|newfile
argument_list|)
operator|||
name|dprintf_find_string
argument_list|(
name|func
argument_list|)
condition|)
block|{
comment|/* Print out just the function name if requested */
name|flockfile
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|dprintf_find_string
argument_list|(
literal|"pid"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|dprintf_find_string
argument_list|(
literal|"tid"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%u "
argument_list|,
name|thr_self
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (dprintf_find_string("cpu")) 			(void) printf("%u ", getcpuid());
endif|#
directive|endif
if|if
condition|(
name|dprintf_find_string
argument_list|(
literal|"time"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%llu "
argument_list|,
name|gethrtime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|dprintf_find_string
argument_list|(
literal|"long"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s, line %d: "
argument_list|,
name|newfile
argument_list|,
name|line
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|adx
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|adx
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|adx
argument_list|)
expr_stmt|;
name|funlockfile
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ZFS_DEBUG */
end_comment

begin_comment
comment|/*  * =========================================================================  * cmn_err() and panic()  * =========================================================================  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ce_prefix
index|[
name|CE_IGNORE
index|]
index|[
literal|10
index|]
init|=
block|{
literal|""
block|,
literal|"NOTICE: "
block|,
literal|"WARNING: "
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ce_suffix
index|[
name|CE_IGNORE
index|]
index|[
literal|2
index|]
init|=
block|{
literal|""
block|,
literal|"\n"
block|,
literal|"\n"
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|vpanic
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|adx
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|adx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* think of it as a "user-level crash dump" */
block|}
end_function

begin_function
name|void
name|panic
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|adx
decl_stmt|;
name|va_start
argument_list|(
name|adx
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vpanic
argument_list|(
name|fmt
argument_list|,
name|adx
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|adx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vcmn_err
parameter_list|(
name|int
name|ce
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|adx
parameter_list|)
block|{
if|if
condition|(
name|ce
operator|==
name|CE_PANIC
condition|)
name|vpanic
argument_list|(
name|fmt
argument_list|,
name|adx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|!=
name|CE_NOTE
condition|)
block|{
comment|/* suppress noise in userland stress testing */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|ce_prefix
index|[
name|ce
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|adx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|ce_suffix
index|[
name|ce
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*PRINTFLIKE2*/
end_comment

begin_function
name|void
name|cmn_err
parameter_list|(
name|int
name|ce
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|adx
decl_stmt|;
name|va_start
argument_list|(
name|adx
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vcmn_err
argument_list|(
name|ce
argument_list|,
name|fmt
argument_list|,
name|adx
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|adx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * =========================================================================  * kobj interfaces  * =========================================================================  */
end_comment

begin_function
name|struct
name|_buf
modifier|*
name|kobj_open_file
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|_buf
modifier|*
name|file
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
comment|/* set vp as the _fd field of the file */
if|if
condition|(
name|vn_openat
argument_list|(
name|name
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|FREAD
argument_list|,
literal|0
argument_list|,
operator|&
name|vp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|rootdir
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|-
literal|1UL
operator|)
return|;
name|file
operator|=
name|umem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_buf
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
name|file
operator|->
name|_fd
operator|=
operator|(
name|intptr_t
operator|)
name|vp
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kobj_read_file
parameter_list|(
name|struct
name|_buf
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|size
parameter_list|,
name|unsigned
name|off
parameter_list|)
block|{
name|ssize_t
name|resid
decl_stmt|;
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
operator|(
name|vnode_t
operator|*
operator|)
name|file
operator|->
name|_fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
operator|(
name|offset_t
operator|)
name|off
argument_list|,
name|UIO_SYSSPACE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|resid
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|-
name|resid
operator|)
return|;
block|}
end_function

begin_function
name|void
name|kobj_close_file
parameter_list|(
name|struct
name|_buf
modifier|*
name|file
parameter_list|)
block|{
name|vn_close
argument_list|(
operator|(
name|vnode_t
operator|*
operator|)
name|file
operator|->
name|_fd
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|file
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|kobj_get_filesize
parameter_list|(
name|struct
name|_buf
modifier|*
name|file
parameter_list|,
name|uint64_t
modifier|*
name|size
parameter_list|)
block|{
name|struct
name|stat64
name|st
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
operator|(
name|vnode_t
operator|*
operator|)
name|file
operator|->
name|_fd
decl_stmt|;
if|if
condition|(
name|fstat64
argument_list|(
name|vp
operator|->
name|v_fd
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|vn_close
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
operator|*
name|size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * =========================================================================  * misc routines  * =========================================================================  */
end_comment

begin_function
name|void
name|delay
parameter_list|(
name|clock_t
name|ticks
parameter_list|)
block|{
name|poll
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ticks
operator|*
operator|(
literal|1000
operator|/
name|hz
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Find highest one bit set.  *	Returns bit number + 1 of highest bit that is set, otherwise returns 0.  * High order bit is 31 (or 63 in _LP64 kernel).  */
end_comment

begin_ifdef
unit|int highbit(ulong_t i) { 	register int h = 1;  	if (i == 0) 		return (0);
ifdef|#
directive|ifdef
name|_LP64
end_ifdef

begin_endif
unit|if (i& 0xffffffff00000000ul) { 		h += 32; i>>= 32; 	}
endif|#
directive|endif
end_endif

begin_endif
unit|if (i& 0xffff0000) { 		h += 16; i>>= 16; 	} 	if (i& 0xff00) { 		h += 8; i>>= 8; 	} 	if (i& 0xf0) { 		h += 4; i>>= 4; 	} 	if (i& 0xc) { 		h += 2; i>>= 2; 	} 	if (i& 0x2) { 		h += 1; 	} 	return (h); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|random_get_bytes_common
parameter_list|(
name|uint8_t
modifier|*
name|ptr
parameter_list|,
name|size_t
name|len
parameter_list|,
name|char
modifier|*
name|devname
parameter_list|)
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|devname
argument_list|,
name|O_RDONLY
argument_list|)
decl_stmt|;
name|size_t
name|resid
init|=
name|len
decl_stmt|;
name|ssize_t
name|bytes
decl_stmt|;
name|ASSERT
argument_list|(
name|fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|resid
operator|!=
literal|0
condition|)
block|{
name|bytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|ptr
argument_list|,
name|resid
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bytes
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|bytes
expr_stmt|;
name|resid
operator|-=
name|bytes
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|random_get_bytes
parameter_list|(
name|uint8_t
modifier|*
name|ptr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|(
name|random_get_bytes_common
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|,
literal|"/dev/random"
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|random_get_pseudo_bytes
parameter_list|(
name|uint8_t
modifier|*
name|ptr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|(
name|random_get_bytes_common
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|,
literal|"/dev/urandom"
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ddi_strtoul
parameter_list|(
specifier|const
name|char
modifier|*
name|hw_serial
parameter_list|,
name|char
modifier|*
modifier|*
name|nptr
parameter_list|,
name|int
name|base
parameter_list|,
name|unsigned
name|long
modifier|*
name|result
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
operator|*
name|result
operator|=
name|strtoul
argument_list|(
name|hw_serial
argument_list|,
operator|&
name|end
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|result
operator|==
literal|0
condition|)
return|return
operator|(
name|errno
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * =========================================================================  * kernel emulation setup& teardown  * =========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|umem_out_of_memory
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|errmsg
index|[]
init|=
literal|"out of memory -- generating core dump\n"
decl_stmt|;
name|write
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|errmsg
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|kernel_init
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|umem_nofail_callback
argument_list|(
name|umem_out_of_memory
argument_list|)
expr_stmt|;
name|physmem
operator|=
name|sysconf
argument_list|(
name|_SC_PHYS_PAGES
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"physmem = %llu pages (%.2f GB)\n"
argument_list|,
name|physmem
argument_list|,
operator|(
name|double
operator|)
name|physmem
operator|*
name|sysconf
argument_list|(
name|_SC_PAGE_SIZE
argument_list|)
operator|/
operator|(
literal|1ULL
operator|<<
literal|30
operator|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|hw_serial
argument_list|,
sizeof|sizeof
argument_list|(
name|hw_serial
argument_list|)
argument_list|,
literal|"%ld"
argument_list|,
name|gethostid
argument_list|()
argument_list|)
expr_stmt|;
name|spa_init
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kernel_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|spa_fini
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|z_uncompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|dstlen
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srclen
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uLongf
name|len
init|=
operator|*
name|dstlen
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|uncompress
argument_list|(
name|dst
argument_list|,
operator|&
name|len
argument_list|,
name|src
argument_list|,
name|srclen
argument_list|)
operator|)
operator|==
name|Z_OK
condition|)
operator|*
name|dstlen
operator|=
operator|(
name|size_t
operator|)
name|len
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|z_compress_level
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|dstlen
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srclen
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uLongf
name|len
init|=
operator|*
name|dstlen
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|compress2
argument_list|(
name|dst
argument_list|,
operator|&
name|len
argument_list|,
name|src
argument_list|,
name|srclen
argument_list|,
name|level
argument_list|)
operator|)
operator|==
name|Z_OK
condition|)
operator|*
name|dstlen
operator|=
operator|(
name|size_t
operator|)
name|len
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

