begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<ctf_impl.h>
end_include

begin_comment
comment|/*  * Compare the given input string and length against a table of known C storage  * qualifier keywords.  We just ignore these in ctf_lookup_by_name, below.  To  * do this quickly, we use a pre-computed Perfect Hash Function similar to the  * technique originally described in the classic paper:  *  * R.J. Cichelli, "Minimal Perfect Hash Functions Made Simple",  * Communications of the ACM, Volume 23, Issue 1, January 1980, pp. 17-19.  *  * For an input string S of length N, we use hash H = S[N - 1] + N - 105, which  * for the current set of qualifiers yields a unique H in the range [0 .. 20].  * The hash can be modified when the keyword set changes as necessary.  We also  * store the length of each keyword and check it prior to the final strcmp().  */
end_comment

begin_function
specifier|static
name|int
name|isqualifier
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
name|qual
block|{
specifier|const
name|char
modifier|*
name|q_name
decl_stmt|;
name|size_t
name|q_len
decl_stmt|;
block|}
name|qhash
index|[]
init|=
block|{
block|{
literal|"static"
block|,
literal|6
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|"volatile"
block|,
literal|8
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|"auto"
block|,
literal|4
block|}
block|,
block|{
literal|"extern"
block|,
literal|6
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|"const"
block|,
literal|5
block|}
block|,
block|{
literal|"register"
block|,
literal|8
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|"restrict"
block|,
literal|8
block|}
block|,
block|{
literal|"_Restrict"
block|,
literal|9
block|}
block|}
struct|;
name|int
name|h
init|=
name|s
index|[
name|len
operator|-
literal|1
index|]
operator|+
operator|(
name|int
operator|)
name|len
operator|-
literal|105
decl_stmt|;
specifier|const
name|struct
name|qual
modifier|*
name|qp
init|=
operator|&
name|qhash
index|[
name|h
index|]
decl_stmt|;
return|return
operator|(
name|h
operator|>=
literal|0
operator|&&
name|h
operator|<
sizeof|sizeof
argument_list|(
name|qhash
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|qhash
index|[
literal|0
index|]
argument_list|)
operator|&&
name|len
operator|==
name|qp
operator|->
name|q_len
operator|&&
name|strncmp
argument_list|(
name|qp
operator|->
name|q_name
argument_list|,
name|s
argument_list|,
name|qp
operator|->
name|q_len
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to convert the given C type name into the corresponding CTF type ID.  * It is not possible to do complete and proper conversion of type names  * without implementing a more full-fledged parser, which is necessary to  * handle things like types that are function pointers to functions that  * have arguments that are function pointers, and fun stuff like that.  * Instead, this function implements a very simple conversion algorithm that  * finds the things that we actually care about: structs, unions, enums,  * integers, floats, typedefs, and pointers to any of these named types.  */
end_comment

begin_function
name|ctf_id_t
name|ctf_lookup_by_name
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|delimiters
index|[]
init|=
literal|" \t\n\r\v\f*"
decl_stmt|;
specifier|const
name|ctf_lookup_t
modifier|*
name|lp
decl_stmt|;
specifier|const
name|ctf_helem_t
modifier|*
name|hp
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|ctf_id_t
name|type
init|=
literal|0
decl_stmt|;
name|ctf_id_t
name|ntype
decl_stmt|,
name|ptype
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
for|for
control|(
name|p
operator|=
name|name
operator|,
name|end
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|=
name|q
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* skip leading ws */
if|if
condition|(
name|p
operator|==
name|end
condition|)
break|break;
if|if
condition|(
operator|(
name|q
operator|=
name|strpbrk
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|delimiters
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|q
operator|=
name|end
expr_stmt|;
comment|/* compare until end */
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
comment|/* 			 * Find a pointer to type by looking in fp->ctf_ptrtab. 			 * If we can't find a pointer to the given type, see if 			 * we can compute a pointer to the type resulting from 			 * resolving the type down to its base type and use 			 * that instead.  This helps with cases where the CTF 			 * data includes "struct foo *" but not "foo_t *" and 			 * the user tries to access "foo_t *" in the debugger. 			 */
name|ntype
operator|=
name|fp
operator|->
name|ctf_ptrtab
index|[
name|CTF_TYPE_TO_INDEX
argument_list|(
name|type
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|ntype
operator|==
literal|0
condition|)
block|{
name|ntype
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntype
operator|==
name|CTF_ERR
operator|||
operator|(
name|ntype
operator|=
name|fp
operator|->
name|ctf_ptrtab
index|[
name|CTF_TYPE_TO_INDEX
argument_list|(
name|ntype
argument_list|)
index|]
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOTYPE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|type
operator|=
name|CTF_INDEX_TO_TYPE
argument_list|(
name|ntype
argument_list|,
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_CHILD
operator|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isqualifier
argument_list|(
name|p
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|q
operator|-
name|p
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* skip qualifier keyword */
for|for
control|(
name|lp
operator|=
name|fp
operator|->
name|ctf_lookups
init|;
name|lp
operator|->
name|ctl_prefix
operator|!=
name|NULL
condition|;
name|lp
operator|++
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|ctl_prefix
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|strncmp
argument_list|(
name|p
argument_list|,
name|lp
operator|->
name|ctl_prefix
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|q
operator|-
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|+=
name|lp
operator|->
name|ctl_len
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
comment|/* skip prefix and next ws */
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'*'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|q
operator|=
name|end
expr_stmt|;
comment|/* compare until end */
while|while
condition|(
name|isspace
argument_list|(
name|q
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|q
operator|--
expr_stmt|;
comment|/* exclude trailing ws */
if|if
condition|(
operator|(
name|hp
operator|=
name|ctf_hash_lookup
argument_list|(
name|lp
operator|->
name|ctl_hash
argument_list|,
name|fp
argument_list|,
name|p
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|q
operator|-
name|p
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOTYPE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|type
operator|=
name|hp
operator|->
name|h_type
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|lp
operator|->
name|ctl_prefix
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOTYPE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|||
name|type
operator|==
literal|0
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_SYNTAX
argument_list|)
operator|)
return|;
return|return
operator|(
name|type
operator|)
return|;
name|err
label|:
if|if
condition|(
name|fp
operator|->
name|ctf_parent
operator|!=
name|NULL
operator|&&
operator|(
name|ptype
operator|=
name|ctf_lookup_by_name
argument_list|(
name|fp
operator|->
name|ctf_parent
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|CTF_ERR
condition|)
return|return
operator|(
name|ptype
operator|)
return|;
return|return
operator|(
name|CTF_ERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a symbol table index, return the type of the data object described  * by the corresponding entry in the symbol table.  */
end_comment

begin_function
name|ctf_id_t
name|ctf_lookup_by_symbol
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ulong_t
name|symidx
parameter_list|)
block|{
specifier|const
name|ctf_sect_t
modifier|*
name|sp
init|=
operator|&
name|fp
operator|->
name|ctf_symtab
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|cts_data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOSYMTAB
argument_list|)
operator|)
return|;
if|if
condition|(
name|symidx
operator|>=
name|fp
operator|->
name|ctf_nsyms
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|cts_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
condition|)
block|{
specifier|const
name|Elf32_Sym
modifier|*
name|symp
init|=
operator|(
name|Elf32_Sym
operator|*
operator|)
name|sp
operator|->
name|cts_data
operator|+
name|symidx
decl_stmt|;
if|if
condition|(
name|ELF32_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_OBJECT
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOTDATA
argument_list|)
operator|)
return|;
block|}
else|else
block|{
specifier|const
name|Elf64_Sym
modifier|*
name|symp
init|=
operator|(
name|Elf64_Sym
operator|*
operator|)
name|sp
operator|->
name|cts_data
operator|+
name|symidx
decl_stmt|;
if|if
condition|(
name|ELF64_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_OBJECT
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOTDATA
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|fp
operator|->
name|ctf_sxlate
index|[
name|symidx
index|]
operator|==
operator|-
literal|1u
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOTYPEDAT
argument_list|)
operator|)
return|;
name|type
operator|=
operator|*
operator|(
name|ushort_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|fp
operator|->
name|ctf_buf
operator|+
name|fp
operator|->
name|ctf_sxlate
index|[
name|symidx
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOTYPEDAT
argument_list|)
operator|)
return|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the pointer to the internal CTF type data corresponding to the  * given type ID.  If the ID is invalid, the function returns NULL.  * This function is not exported outside of the library.  */
end_comment

begin_function
specifier|const
name|ctf_type_t
modifier|*
name|ctf_lookup_by_id
parameter_list|(
name|ctf_file_t
modifier|*
modifier|*
name|fpp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fp
init|=
operator|*
name|fpp
decl_stmt|;
comment|/* caller passes in starting CTF container */
if|if
condition|(
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_CHILD
operator|)
operator|&&
name|CTF_TYPE_ISPARENT
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|fp
operator|=
name|fp
operator|->
name|ctf_parent
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ctf_set_errno
argument_list|(
operator|*
name|fpp
argument_list|,
name|ECTF_NOPARENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|type
operator|=
name|CTF_TYPE_TO_INDEX
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>
literal|0
operator|&&
name|type
operator|<=
name|fp
operator|->
name|ctf_typemax
condition|)
block|{
operator|*
name|fpp
operator|=
name|fp
expr_stmt|;
comment|/* function returns ending CTF container */
return|return
operator|(
name|LCTF_INDEX_TO_TYPEPTR
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_BADID
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a symbol table index, return the info for the function described  * by the corresponding entry in the symbol table.  */
end_comment

begin_function
name|int
name|ctf_func_info
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ulong_t
name|symidx
parameter_list|,
name|ctf_funcinfo_t
modifier|*
name|fip
parameter_list|)
block|{
specifier|const
name|ctf_sect_t
modifier|*
name|sp
init|=
operator|&
name|fp
operator|->
name|ctf_symtab
decl_stmt|;
specifier|const
name|ushort_t
modifier|*
name|dp
decl_stmt|;
name|ushort_t
name|info
decl_stmt|,
name|kind
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|cts_data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOSYMTAB
argument_list|)
operator|)
return|;
if|if
condition|(
name|symidx
operator|>=
name|fp
operator|->
name|ctf_nsyms
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|cts_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
condition|)
block|{
specifier|const
name|Elf32_Sym
modifier|*
name|symp
init|=
operator|(
name|Elf32_Sym
operator|*
operator|)
name|sp
operator|->
name|cts_data
operator|+
name|symidx
decl_stmt|;
if|if
condition|(
name|ELF32_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOTFUNC
argument_list|)
operator|)
return|;
block|}
else|else
block|{
specifier|const
name|Elf64_Sym
modifier|*
name|symp
init|=
operator|(
name|Elf64_Sym
operator|*
operator|)
name|sp
operator|->
name|cts_data
operator|+
name|symidx
decl_stmt|;
if|if
condition|(
name|ELF64_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOTFUNC
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|fp
operator|->
name|ctf_sxlate
index|[
name|symidx
index|]
operator|==
operator|-
literal|1u
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOFUNCDAT
argument_list|)
operator|)
return|;
name|dp
operator|=
operator|(
name|ushort_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|fp
operator|->
name|ctf_buf
operator|+
name|fp
operator|->
name|ctf_sxlate
index|[
name|symidx
index|]
operator|)
expr_stmt|;
name|info
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|kind
operator|=
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|n
operator|=
name|LCTF_INFO_VLEN
argument_list|(
name|fp
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_UNKNOWN
operator|&&
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOFUNCDAT
argument_list|)
operator|)
return|;
if|if
condition|(
name|kind
operator|!=
name|CTF_K_FUNCTION
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_CORRUPT
argument_list|)
operator|)
return|;
name|fip
operator|->
name|ctc_return
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|fip
operator|->
name|ctc_argc
operator|=
name|n
expr_stmt|;
name|fip
operator|->
name|ctc_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
operator|&&
name|dp
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|fip
operator|->
name|ctc_flags
operator||=
name|CTF_FUNC_VARARG
expr_stmt|;
name|fip
operator|->
name|ctc_argc
operator|--
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a symbol table index, return the arguments for the function described  * by the corresponding entry in the symbol table.  */
end_comment

begin_function
name|int
name|ctf_func_args
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ulong_t
name|symidx
parameter_list|,
name|uint_t
name|argc
parameter_list|,
name|ctf_id_t
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|ushort_t
modifier|*
name|dp
decl_stmt|;
name|ctf_funcinfo_t
name|f
decl_stmt|;
if|if
condition|(
name|ctf_func_info
argument_list|(
name|fp
argument_list|,
name|symidx
argument_list|,
operator|&
name|f
argument_list|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
comment|/* 	 * The argument data is two ushort_t's past the translation table 	 * offset: one for the function info, and one for the return type. 	 */
name|dp
operator|=
operator|(
name|ushort_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|fp
operator|->
name|ctf_buf
operator|+
name|fp
operator|->
name|ctf_sxlate
index|[
name|symidx
index|]
operator|)
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|argc
operator|=
name|MIN
argument_list|(
name|argc
argument_list|,
name|f
operator|.
name|ctc_argc
argument_list|)
init|;
name|argc
operator|!=
literal|0
condition|;
name|argc
operator|--
control|)
operator|*
name|argv
operator|++
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

