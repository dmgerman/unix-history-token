begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013, Joyent, Inc.  All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<ctf_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/zmod.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|ctf_dmodel_t
name|_libctf_models
index|[]
init|=
block|{
block|{
literal|"ILP32"
block|,
name|CTF_MODEL_ILP32
block|,
literal|4
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|"LP64"
block|,
name|CTF_MODEL_LP64
block|,
literal|8
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|_CTF_SECTION
index|[]
init|=
literal|".SUNW_ctf"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|_CTF_NULLSTR
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_libctf_version
init|=
name|CTF_VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* library client version */
end_comment

begin_decl_stmt
name|int
name|_libctf_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debugging messages enabled */
end_comment

begin_function
specifier|static
name|ushort_t
name|get_kind_v1
parameter_list|(
name|ushort_t
name|info
parameter_list|)
block|{
return|return
operator|(
name|CTF_INFO_KIND_V1
argument_list|(
name|info
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ushort_t
name|get_kind_v2
parameter_list|(
name|ushort_t
name|info
parameter_list|)
block|{
return|return
operator|(
name|CTF_INFO_KIND
argument_list|(
name|info
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ushort_t
name|get_root_v1
parameter_list|(
name|ushort_t
name|info
parameter_list|)
block|{
return|return
operator|(
name|CTF_INFO_ISROOT_V1
argument_list|(
name|info
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ushort_t
name|get_root_v2
parameter_list|(
name|ushort_t
name|info
parameter_list|)
block|{
return|return
operator|(
name|CTF_INFO_ISROOT
argument_list|(
name|info
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ushort_t
name|get_vlen_v1
parameter_list|(
name|ushort_t
name|info
parameter_list|)
block|{
return|return
operator|(
name|CTF_INFO_VLEN_V1
argument_list|(
name|info
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ushort_t
name|get_vlen_v2
parameter_list|(
name|ushort_t
name|info
parameter_list|)
block|{
return|return
operator|(
name|CTF_INFO_VLEN
argument_list|(
name|info
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|ctf_fileops_t
name|ctf_fileops
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
block|{
name|get_kind_v1
block|,
name|get_root_v1
block|,
name|get_vlen_v1
block|}
block|,
block|{
name|get_kind_v2
block|,
name|get_root_v2
block|,
name|get_vlen_v2
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Convert a 32-bit ELF symbol into GElf (Elf64) and return a pointer to it.  */
end_comment

begin_function
specifier|static
name|Elf64_Sym
modifier|*
name|sym_to_gelf
parameter_list|(
specifier|const
name|Elf32_Sym
modifier|*
name|src
parameter_list|,
name|Elf64_Sym
modifier|*
name|dst
parameter_list|)
block|{
name|dst
operator|->
name|st_name
operator|=
name|src
operator|->
name|st_name
expr_stmt|;
name|dst
operator|->
name|st_value
operator|=
name|src
operator|->
name|st_value
expr_stmt|;
name|dst
operator|->
name|st_size
operator|=
name|src
operator|->
name|st_size
expr_stmt|;
name|dst
operator|->
name|st_info
operator|=
name|src
operator|->
name|st_info
expr_stmt|;
name|dst
operator|->
name|st_other
operator|=
name|src
operator|->
name|st_other
expr_stmt|;
name|dst
operator|->
name|st_shndx
operator|=
name|src
operator|->
name|st_shndx
expr_stmt|;
return|return
operator|(
name|dst
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the symtab translation table by filling each entry with the  * offset of the CTF type or function data corresponding to each STT_FUNC or  * STT_OBJECT entry in the symbol table.  */
end_comment

begin_function
specifier|static
name|int
name|init_symtab
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
specifier|const
name|ctf_header_t
modifier|*
name|hp
parameter_list|,
specifier|const
name|ctf_sect_t
modifier|*
name|sp
parameter_list|,
specifier|const
name|ctf_sect_t
modifier|*
name|strp
parameter_list|)
block|{
specifier|const
name|uchar_t
modifier|*
name|symp
init|=
name|sp
operator|->
name|cts_data
decl_stmt|;
name|uint_t
modifier|*
name|xp
init|=
name|fp
operator|->
name|ctf_sxlate
decl_stmt|;
name|uint_t
modifier|*
name|xend
init|=
name|xp
operator|+
name|fp
operator|->
name|ctf_nsyms
decl_stmt|;
name|uint_t
name|objtoff
init|=
name|hp
operator|->
name|cth_objtoff
decl_stmt|;
name|uint_t
name|funcoff
init|=
name|hp
operator|->
name|cth_funcoff
decl_stmt|;
name|ushort_t
name|info
decl_stmt|,
name|vlen
decl_stmt|;
name|Elf64_Sym
name|sym
decl_stmt|,
modifier|*
name|gsp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* 	 * The CTF data object and function type sections are ordered to match 	 * the relative order of the respective symbol types in the symtab. 	 * If no type information is available for a symbol table entry, a 	 * pad is inserted in the CTF section.  As a further optimization, 	 * anonymous or undefined symbols are omitted from the CTF data. 	 */
for|for
control|(
init|;
name|xp
operator|<
name|xend
condition|;
name|xp
operator|++
operator|,
name|symp
operator|+=
name|sp
operator|->
name|cts_entsize
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|cts_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
condition|)
name|gsp
operator|=
name|sym_to_gelf
argument_list|(
operator|(
name|Elf32_Sym
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|symp
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
else|else
name|gsp
operator|=
operator|(
name|Elf64_Sym
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|symp
expr_stmt|;
if|if
condition|(
name|gsp
operator|->
name|st_name
operator|<
name|strp
operator|->
name|cts_size
condition|)
name|name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|strp
operator|->
name|cts_data
operator|+
name|gsp
operator|->
name|st_name
expr_stmt|;
else|else
name|name
operator|=
name|_CTF_NULLSTR
expr_stmt|;
if|if
condition|(
name|gsp
operator|->
name|st_name
operator|==
literal|0
operator|||
name|gsp
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_START_"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_END_"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|xp
operator|=
operator|-
literal|1u
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|ELF64_ST_TYPE
argument_list|(
name|gsp
operator|->
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STT_OBJECT
case|:
if|if
condition|(
name|objtoff
operator|>=
name|hp
operator|->
name|cth_funcoff
operator|||
operator|(
name|gsp
operator|->
name|st_shndx
operator|==
name|SHN_ABS
operator|&&
name|gsp
operator|->
name|st_value
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|xp
operator|=
operator|-
literal|1u
expr_stmt|;
break|break;
block|}
operator|*
name|xp
operator|=
name|objtoff
expr_stmt|;
name|objtoff
operator|+=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|STT_FUNC
case|:
if|if
condition|(
name|funcoff
operator|>=
name|hp
operator|->
name|cth_typeoff
condition|)
block|{
operator|*
name|xp
operator|=
operator|-
literal|1u
expr_stmt|;
break|break;
block|}
operator|*
name|xp
operator|=
name|funcoff
expr_stmt|;
name|info
operator|=
operator|*
operator|(
name|ushort_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|fp
operator|->
name|ctf_buf
operator|+
name|funcoff
operator|)
expr_stmt|;
name|vlen
operator|=
name|LCTF_INFO_VLEN
argument_list|(
name|fp
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* 			 * If we encounter a zero pad at the end, just skip it. 			 * Otherwise skip over the function and its return type 			 * (+2) and the argument list (vlen). 			 */
if|if
condition|(
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|info
argument_list|)
operator|==
name|CTF_K_UNKNOWN
operator|&&
name|vlen
operator|==
literal|0
condition|)
name|funcoff
operator|+=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
expr_stmt|;
comment|/* skip pad */
else|else
name|funcoff
operator|+=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|vlen
operator|+
literal|2
operator|)
expr_stmt|;
break|break;
default|default:
operator|*
name|xp
operator|=
operator|-
literal|1u
expr_stmt|;
break|break;
block|}
block|}
name|ctf_dprintf
argument_list|(
literal|"loaded %lu symtab entries\n"
argument_list|,
name|fp
operator|->
name|ctf_nsyms
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the type ID translation table with the byte offset of each type,  * and initialize the hash tables of each named type.  */
end_comment

begin_function
specifier|static
name|int
name|init_types
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
specifier|const
name|ctf_header_t
modifier|*
name|cth
parameter_list|)
block|{
comment|/* LINTED - pointer alignment */
specifier|const
name|ctf_type_t
modifier|*
name|tbuf
init|=
operator|(
name|ctf_type_t
operator|*
operator|)
operator|(
name|fp
operator|->
name|ctf_buf
operator|+
name|cth
operator|->
name|cth_typeoff
operator|)
decl_stmt|;
comment|/* LINTED - pointer alignment */
specifier|const
name|ctf_type_t
modifier|*
name|tend
init|=
operator|(
name|ctf_type_t
operator|*
operator|)
operator|(
name|fp
operator|->
name|ctf_buf
operator|+
name|cth
operator|->
name|cth_stroff
operator|)
decl_stmt|;
name|ulong_t
name|pop
index|[
name|CTF_K_MAX
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
name|ctf_hash_t
modifier|*
name|hp
decl_stmt|;
name|ushort_t
name|id
decl_stmt|,
name|dst
decl_stmt|;
name|uint_t
modifier|*
name|xp
decl_stmt|;
comment|/* 	 * We initially determine whether the container is a child or a parent 	 * based on the value of cth_parname.  To support containers that pre- 	 * date cth_parname, we also scan the types themselves for references 	 * to values in the range reserved for child types in our first pass. 	 */
name|int
name|child
init|=
name|cth
operator|->
name|cth_parname
operator|!=
literal|0
decl_stmt|;
name|int
name|nlstructs
init|=
literal|0
decl_stmt|,
name|nlunions
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * We make two passes through the entire type section.  In this first 	 * pass, we count the number of each type and the total number of types. 	 */
for|for
control|(
name|tp
operator|=
name|tbuf
init|;
name|tp
operator|<
name|tend
condition|;
name|fp
operator|->
name|ctf_typemax
operator|++
control|)
block|{
name|ushort_t
name|kind
init|=
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|ulong_t
name|vlen
init|=
name|LCTF_INFO_VLEN
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|ssize_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
name|size_t
name|vbytes
decl_stmt|;
name|uint_t
name|n
decl_stmt|;
operator|(
name|void
operator|)
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_array_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|vlen
operator|+
operator|(
name|vlen
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
if|if
condition|(
name|fp
operator|->
name|ctf_version
operator|==
name|CTF_VERSION_1
operator|||
name|size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
block|{
name|ctf_member_t
modifier|*
name|mp
init|=
operator|(
name|ctf_member_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_member_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
for|for
control|(
name|n
operator|=
name|vlen
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|mp
operator|++
control|)
name|child
operator||=
name|CTF_TYPE_ISCHILD
argument_list|(
name|mp
operator|->
name|ctm_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctf_lmember_t
modifier|*
name|lmp
init|=
operator|(
name|ctf_lmember_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_lmember_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
for|for
control|(
name|n
operator|=
name|vlen
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|lmp
operator|++
control|)
name|child
operator||=
name|CTF_TYPE_ISCHILD
argument_list|(
name|lmp
operator|->
name|ctlm_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_ENUM
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_enum_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
break|break;
case|case
name|CTF_K_FORWARD
case|:
comment|/* 			 * For forward declarations, ctt_type is the CTF_K_* 			 * kind for the tag, so bump that population count too. 			 * If ctt_type is unknown, treat the tag as a struct. 			 */
if|if
condition|(
name|tp
operator|->
name|ctt_type
operator|==
name|CTF_K_UNKNOWN
operator|||
name|tp
operator|->
name|ctt_type
operator|>=
name|CTF_K_MAX
condition|)
name|pop
index|[
name|CTF_K_STRUCT
index|]
operator|++
expr_stmt|;
else|else
name|pop
index|[
name|tp
operator|->
name|ctt_type
index|]
operator|++
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|CTF_K_UNKNOWN
case|:
name|vbytes
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
case|case
name|CTF_K_TYPEDEF
case|:
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
name|child
operator||=
name|CTF_TYPE_ISCHILD
argument_list|(
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
name|vbytes
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ctf_dprintf
argument_list|(
literal|"detected invalid CTF kind -- %u\n"
argument_list|,
name|kind
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECTF_CORRUPT
operator|)
return|;
block|}
name|tp
operator|=
operator|(
name|ctf_type_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|+
name|vbytes
operator|)
expr_stmt|;
name|pop
index|[
name|kind
index|]
operator|++
expr_stmt|;
block|}
comment|/* 	 * If we detected a reference to a child type ID, then we know this 	 * container is a child and may have a parent's types imported later. 	 */
if|if
condition|(
name|child
condition|)
block|{
name|ctf_dprintf
argument_list|(
literal|"CTF container %p is a child\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_flags
operator||=
name|LCTF_CHILD
expr_stmt|;
block|}
else|else
name|ctf_dprintf
argument_list|(
literal|"CTF container %p is a parent\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fp
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we've counted up the number of each type, we can allocate 	 * the hash tables, type translation table, and pointer table. 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|ctf_hash_create
argument_list|(
operator|&
name|fp
operator|->
name|ctf_structs
argument_list|,
name|pop
index|[
name|CTF_K_STRUCT
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|ctf_hash_create
argument_list|(
operator|&
name|fp
operator|->
name|ctf_unions
argument_list|,
name|pop
index|[
name|CTF_K_UNION
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|ctf_hash_create
argument_list|(
operator|&
name|fp
operator|->
name|ctf_enums
argument_list|,
name|pop
index|[
name|CTF_K_ENUM
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|ctf_hash_create
argument_list|(
operator|&
name|fp
operator|->
name|ctf_names
argument_list|,
name|pop
index|[
name|CTF_K_INTEGER
index|]
operator|+
name|pop
index|[
name|CTF_K_FLOAT
index|]
operator|+
name|pop
index|[
name|CTF_K_FUNCTION
index|]
operator|+
name|pop
index|[
name|CTF_K_TYPEDEF
index|]
operator|+
name|pop
index|[
name|CTF_K_POINTER
index|]
operator|+
name|pop
index|[
name|CTF_K_VOLATILE
index|]
operator|+
name|pop
index|[
name|CTF_K_CONST
index|]
operator|+
name|pop
index|[
name|CTF_K_RESTRICT
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|fp
operator|->
name|ctf_txlate
operator|=
name|ctf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
operator|*
operator|(
name|fp
operator|->
name|ctf_typemax
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_ptrtab
operator|=
name|ctf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|fp
operator|->
name|ctf_typemax
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_txlate
operator|==
name|NULL
operator|||
name|fp
operator|->
name|ctf_ptrtab
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
comment|/* memory allocation failed */
name|xp
operator|=
name|fp
operator|->
name|ctf_txlate
expr_stmt|;
operator|*
name|xp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* type id 0 is used as a sentinel value */
name|bzero
argument_list|(
name|fp
operator|->
name|ctf_txlate
argument_list|,
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
operator|*
operator|(
name|fp
operator|->
name|ctf_typemax
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|fp
operator|->
name|ctf_ptrtab
argument_list|,
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|fp
operator|->
name|ctf_typemax
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * In the second pass through the types, we fill in each entry of the 	 * type and pointer tables and add names to the appropriate hashes. 	 */
for|for
control|(
name|id
operator|=
literal|1
operator|,
name|tp
operator|=
name|tbuf
init|;
name|tp
operator|<
name|tend
condition|;
name|xp
operator|++
operator|,
name|id
operator|++
control|)
block|{
name|ushort_t
name|kind
init|=
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|ulong_t
name|vlen
init|=
name|LCTF_INFO_VLEN
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|ssize_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|vbytes
decl_stmt|;
name|ctf_helem_t
modifier|*
name|hep
decl_stmt|;
name|ctf_encoding_t
name|cte
decl_stmt|;
operator|(
name|void
operator|)
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
name|name
operator|=
name|ctf_strptr
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
comment|/* 			 * Only insert a new integer base type definition if 			 * this type name has not been defined yet.  We re-use 			 * the names with different encodings for bit-fields. 			 */
if|if
condition|(
operator|(
name|hep
operator|=
name|ctf_hash_lookup
argument_list|(
operator|&
name|fp
operator|->
name|ctf_names
argument_list|,
name|fp
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ctf_hash_insert
argument_list|(
operator|&
name|fp
operator|->
name|ctf_names
argument_list|,
name|fp
argument_list|,
name|CTF_INDEX_TO_TYPE
argument_list|(
name|id
argument_list|,
name|child
argument_list|)
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|err
operator|!=
name|ECTF_STRTAB
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctf_type_encoding
argument_list|(
name|fp
argument_list|,
name|hep
operator|->
name|h_type
argument_list|,
operator|&
name|cte
argument_list|)
operator|==
literal|0
operator|&&
name|cte
operator|.
name|cte_bits
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Work-around SOS8 stabs bug: replace existing 				 * intrinsic w/ same name if it was zero bits. 				 */
name|hep
operator|->
name|h_type
operator|=
name|CTF_INDEX_TO_TYPE
argument_list|(
name|id
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_array_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|err
operator|=
name|ctf_hash_insert
argument_list|(
operator|&
name|fp
operator|->
name|ctf_names
argument_list|,
name|fp
argument_list|,
name|CTF_INDEX_TO_TYPE
argument_list|(
name|id
argument_list|,
name|child
argument_list|)
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|err
operator|!=
name|ECTF_STRTAB
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|vlen
operator|+
operator|(
name|vlen
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
name|err
operator|=
name|ctf_hash_define
argument_list|(
operator|&
name|fp
operator|->
name|ctf_structs
argument_list|,
name|fp
argument_list|,
name|CTF_INDEX_TO_TYPE
argument_list|(
name|id
argument_list|,
name|child
argument_list|)
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|err
operator|!=
name|ECTF_STRTAB
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|fp
operator|->
name|ctf_version
operator|==
name|CTF_VERSION_1
operator|||
name|size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_member_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
else|else
block|{
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_lmember_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
name|nlstructs
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_UNION
case|:
name|err
operator|=
name|ctf_hash_define
argument_list|(
operator|&
name|fp
operator|->
name|ctf_unions
argument_list|,
name|fp
argument_list|,
name|CTF_INDEX_TO_TYPE
argument_list|(
name|id
argument_list|,
name|child
argument_list|)
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|err
operator|!=
name|ECTF_STRTAB
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|fp
operator|->
name|ctf_version
operator|==
name|CTF_VERSION_1
operator|||
name|size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_member_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
else|else
block|{
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_lmember_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
name|nlunions
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_ENUM
case|:
name|err
operator|=
name|ctf_hash_define
argument_list|(
operator|&
name|fp
operator|->
name|ctf_enums
argument_list|,
name|fp
argument_list|,
name|CTF_INDEX_TO_TYPE
argument_list|(
name|id
argument_list|,
name|child
argument_list|)
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|err
operator|!=
name|ECTF_STRTAB
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_enum_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
break|break;
case|case
name|CTF_K_TYPEDEF
case|:
name|err
operator|=
name|ctf_hash_insert
argument_list|(
operator|&
name|fp
operator|->
name|ctf_names
argument_list|,
name|fp
argument_list|,
name|CTF_INDEX_TO_TYPE
argument_list|(
name|id
argument_list|,
name|child
argument_list|)
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|err
operator|!=
name|ECTF_STRTAB
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|vbytes
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CTF_K_FORWARD
case|:
comment|/* 			 * Only insert forward tags into the given hash if the 			 * type or tag name is not already present. 			 */
switch|switch
condition|(
name|tp
operator|->
name|ctt_type
condition|)
block|{
case|case
name|CTF_K_STRUCT
case|:
name|hp
operator|=
operator|&
name|fp
operator|->
name|ctf_structs
expr_stmt|;
break|break;
case|case
name|CTF_K_UNION
case|:
name|hp
operator|=
operator|&
name|fp
operator|->
name|ctf_unions
expr_stmt|;
break|break;
case|case
name|CTF_K_ENUM
case|:
name|hp
operator|=
operator|&
name|fp
operator|->
name|ctf_enums
expr_stmt|;
break|break;
default|default:
name|hp
operator|=
operator|&
name|fp
operator|->
name|ctf_structs
expr_stmt|;
block|}
if|if
condition|(
name|ctf_hash_lookup
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ctf_hash_insert
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
name|CTF_INDEX_TO_TYPE
argument_list|(
name|id
argument_list|,
name|child
argument_list|)
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|err
operator|!=
name|ECTF_STRTAB
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
name|vbytes
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
comment|/* 			 * If the type referenced by the pointer is in this CTF 			 * container, then store the index of the pointer type 			 * in fp->ctf_ptrtab[ index of referenced type ]. 			 */
if|if
condition|(
name|CTF_TYPE_ISCHILD
argument_list|(
name|tp
operator|->
name|ctt_type
argument_list|)
operator|==
name|child
operator|&&
name|CTF_TYPE_TO_INDEX
argument_list|(
name|tp
operator|->
name|ctt_type
argument_list|)
operator|<=
name|fp
operator|->
name|ctf_typemax
condition|)
name|fp
operator|->
name|ctf_ptrtab
index|[
name|CTF_TYPE_TO_INDEX
argument_list|(
name|tp
operator|->
name|ctt_type
argument_list|)
index|]
operator|=
name|id
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
name|err
operator|=
name|ctf_hash_insert
argument_list|(
operator|&
name|fp
operator|->
name|ctf_names
argument_list|,
name|fp
argument_list|,
name|CTF_INDEX_TO_TYPE
argument_list|(
name|id
argument_list|,
name|child
argument_list|)
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|err
operator|!=
name|ECTF_STRTAB
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/*FALLTHRU*/
default|default:
name|vbytes
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|xp
operator|=
call|(
name|uint_t
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|-
operator|(
name|uintptr_t
operator|)
name|fp
operator|->
name|ctf_buf
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|ctf_type_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|+
name|vbytes
operator|)
expr_stmt|;
block|}
name|ctf_dprintf
argument_list|(
literal|"%lu total types processed\n"
argument_list|,
name|fp
operator|->
name|ctf_typemax
argument_list|)
expr_stmt|;
name|ctf_dprintf
argument_list|(
literal|"%u enum names hashed\n"
argument_list|,
name|ctf_hash_size
argument_list|(
operator|&
name|fp
operator|->
name|ctf_enums
argument_list|)
argument_list|)
expr_stmt|;
name|ctf_dprintf
argument_list|(
literal|"%u struct names hashed (%d long)\n"
argument_list|,
name|ctf_hash_size
argument_list|(
operator|&
name|fp
operator|->
name|ctf_structs
argument_list|)
argument_list|,
name|nlstructs
argument_list|)
expr_stmt|;
name|ctf_dprintf
argument_list|(
literal|"%u union names hashed (%d long)\n"
argument_list|,
name|ctf_hash_size
argument_list|(
operator|&
name|fp
operator|->
name|ctf_unions
argument_list|)
argument_list|,
name|nlunions
argument_list|)
expr_stmt|;
name|ctf_dprintf
argument_list|(
literal|"%u base type names hashed\n"
argument_list|,
name|ctf_hash_size
argument_list|(
operator|&
name|fp
operator|->
name|ctf_names
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Make an additional pass through the pointer table to find pointers 	 * that point to anonymous typedef nodes.  If we find one, modify the 	 * pointer table so that the pointer is also known to point to the 	 * node that is referenced by the anonymous typedef node. 	 */
for|for
control|(
name|id
operator|=
literal|1
init|;
name|id
operator|<=
name|fp
operator|->
name|ctf_typemax
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dst
operator|=
name|fp
operator|->
name|ctf_ptrtab
index|[
name|id
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|tp
operator|=
name|LCTF_INDEX_TO_TYPEPTR
argument_list|(
name|fp
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
operator|==
name|CTF_K_TYPEDEF
operator|&&
name|strcmp
argument_list|(
name|ctf_strptr
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
operator|&&
name|CTF_TYPE_ISCHILD
argument_list|(
name|tp
operator|->
name|ctt_type
argument_list|)
operator|==
name|child
operator|&&
name|CTF_TYPE_TO_INDEX
argument_list|(
name|tp
operator|->
name|ctt_type
argument_list|)
operator|<=
name|fp
operator|->
name|ctf_typemax
condition|)
name|fp
operator|->
name|ctf_ptrtab
index|[
name|CTF_TYPE_TO_INDEX
argument_list|(
name|tp
operator|->
name|ctt_type
argument_list|)
index|]
operator|=
name|dst
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decode the specified CTF buffer and optional symbol table and create a new  * CTF container representing the symbolic debugging information.  This code  * can be used directly by the debugger, or it can be used as the engine for  * ctf_fdopen() or ctf_open(), below.  */
end_comment

begin_function
name|ctf_file_t
modifier|*
name|ctf_bufopen
parameter_list|(
specifier|const
name|ctf_sect_t
modifier|*
name|ctfsect
parameter_list|,
specifier|const
name|ctf_sect_t
modifier|*
name|symsect
parameter_list|,
specifier|const
name|ctf_sect_t
modifier|*
name|strsect
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
specifier|const
name|ctf_preamble_t
modifier|*
name|pp
decl_stmt|;
name|ctf_header_t
name|hp
decl_stmt|;
name|ctf_file_t
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|hdrsz
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|ctfsect
operator|==
name|NULL
operator|||
operator|(
operator|(
name|symsect
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|strsect
operator|==
name|NULL
operator|)
operator|)
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|symsect
operator|!=
name|NULL
operator|&&
name|symsect
operator|->
name|cts_entsize
operator|!=
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
operator|&&
name|symsect
operator|->
name|cts_entsize
operator|!=
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_SYMTAB
argument_list|)
operator|)
return|;
if|if
condition|(
name|symsect
operator|!=
name|NULL
operator|&&
name|symsect
operator|->
name|cts_data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_SYMBAD
argument_list|)
operator|)
return|;
if|if
condition|(
name|strsect
operator|!=
name|NULL
operator|&&
name|strsect
operator|->
name|cts_data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_STRBAD
argument_list|)
operator|)
return|;
if|if
condition|(
name|ctfsect
operator|->
name|cts_size
operator|<
sizeof|sizeof
argument_list|(
name|ctf_preamble_t
argument_list|)
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_NOCTFBUF
argument_list|)
operator|)
return|;
name|pp
operator|=
operator|(
specifier|const
name|ctf_preamble_t
operator|*
operator|)
name|ctfsect
operator|->
name|cts_data
expr_stmt|;
name|ctf_dprintf
argument_list|(
literal|"ctf_bufopen: magic=0x%x version=%u\n"
argument_list|,
name|pp
operator|->
name|ctp_magic
argument_list|,
name|pp
operator|->
name|ctp_version
argument_list|)
expr_stmt|;
comment|/* 	 * Validate each part of the CTF header (either V1 or V2). 	 * First, we validate the preamble (common to all versions).  At that 	 * point, we know specific header version, and can validate the 	 * version-specific parts including section offsets and alignments. 	 */
if|if
condition|(
name|pp
operator|->
name|ctp_magic
operator|!=
name|CTF_MAGIC
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_NOCTFBUF
argument_list|)
operator|)
return|;
if|if
condition|(
name|pp
operator|->
name|ctp_version
operator|==
name|CTF_VERSION_2
condition|)
block|{
if|if
condition|(
name|ctfsect
operator|->
name|cts_size
operator|<
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_NOCTFBUF
argument_list|)
operator|)
return|;
name|bcopy
argument_list|(
name|ctfsect
operator|->
name|cts_data
argument_list|,
operator|&
name|hp
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
argument_list|)
argument_list|)
expr_stmt|;
name|hdrsz
operator|=
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pp
operator|->
name|ctp_version
operator|==
name|CTF_VERSION_1
condition|)
block|{
specifier|const
name|ctf_header_v1_t
modifier|*
name|h1p
init|=
operator|(
specifier|const
name|ctf_header_v1_t
operator|*
operator|)
name|ctfsect
operator|->
name|cts_data
decl_stmt|;
if|if
condition|(
name|ctfsect
operator|->
name|cts_size
operator|<
sizeof|sizeof
argument_list|(
name|ctf_header_v1_t
argument_list|)
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_NOCTFBUF
argument_list|)
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|hp
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
argument_list|)
argument_list|)
expr_stmt|;
name|hp
operator|.
name|cth_preamble
operator|=
name|h1p
operator|->
name|cth_preamble
expr_stmt|;
name|hp
operator|.
name|cth_objtoff
operator|=
name|h1p
operator|->
name|cth_objtoff
expr_stmt|;
name|hp
operator|.
name|cth_funcoff
operator|=
name|h1p
operator|->
name|cth_funcoff
expr_stmt|;
name|hp
operator|.
name|cth_typeoff
operator|=
name|h1p
operator|->
name|cth_typeoff
expr_stmt|;
name|hp
operator|.
name|cth_stroff
operator|=
name|h1p
operator|->
name|cth_stroff
expr_stmt|;
name|hp
operator|.
name|cth_strlen
operator|=
name|h1p
operator|->
name|cth_strlen
expr_stmt|;
name|hdrsz
operator|=
sizeof|sizeof
argument_list|(
name|ctf_header_v1_t
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_CTFVERS
argument_list|)
operator|)
return|;
name|size
operator|=
name|hp
operator|.
name|cth_stroff
operator|+
name|hp
operator|.
name|cth_strlen
expr_stmt|;
name|ctf_dprintf
argument_list|(
literal|"ctf_bufopen: uncompressed size=%lu\n"
argument_list|,
operator|(
name|ulong_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|.
name|cth_lbloff
operator|>
name|size
operator|||
name|hp
operator|.
name|cth_objtoff
operator|>
name|size
operator|||
name|hp
operator|.
name|cth_funcoff
operator|>
name|size
operator|||
name|hp
operator|.
name|cth_typeoff
operator|>
name|size
operator|||
name|hp
operator|.
name|cth_stroff
operator|>
name|size
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_CORRUPT
argument_list|)
operator|)
return|;
if|if
condition|(
name|hp
operator|.
name|cth_lbloff
operator|>
name|hp
operator|.
name|cth_objtoff
operator|||
name|hp
operator|.
name|cth_objtoff
operator|>
name|hp
operator|.
name|cth_funcoff
operator|||
name|hp
operator|.
name|cth_funcoff
operator|>
name|hp
operator|.
name|cth_typeoff
operator|||
name|hp
operator|.
name|cth_typeoff
operator|>
name|hp
operator|.
name|cth_stroff
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_CORRUPT
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|hp
operator|.
name|cth_lbloff
operator|&
literal|3
operator|)
operator|||
operator|(
name|hp
operator|.
name|cth_objtoff
operator|&
literal|1
operator|)
operator|||
operator|(
name|hp
operator|.
name|cth_funcoff
operator|&
literal|1
operator|)
operator|||
operator|(
name|hp
operator|.
name|cth_typeoff
operator|&
literal|3
operator|)
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_CORRUPT
argument_list|)
operator|)
return|;
comment|/* 	 * Once everything is determined to be valid, attempt to decompress 	 * the CTF data buffer if it is compressed.  Otherwise we just put 	 * the data section's buffer pointer into ctf_buf, below. 	 */
if|if
condition|(
name|hp
operator|.
name|cth_flags
operator|&
name|CTF_F_COMPRESS
condition|)
block|{
name|size_t
name|srclen
decl_stmt|,
name|dstlen
decl_stmt|;
specifier|const
name|void
modifier|*
name|src
decl_stmt|;
name|int
name|rc
init|=
name|Z_OK
decl_stmt|;
if|if
condition|(
name|ctf_zopen
argument_list|(
name|errp
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* errp is set for us */
if|if
condition|(
operator|(
name|base
operator|=
name|ctf_data_alloc
argument_list|(
name|size
operator|+
name|hdrsz
argument_list|)
operator|)
operator|==
name|MAP_FAILED
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_ZALLOC
argument_list|)
operator|)
return|;
name|bcopy
argument_list|(
name|ctfsect
operator|->
name|cts_data
argument_list|,
name|base
argument_list|,
name|hdrsz
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ctf_preamble_t
operator|*
operator|)
name|base
operator|)
operator|->
name|ctp_flags
operator|&=
operator|~
name|CTF_F_COMPRESS
expr_stmt|;
name|buf
operator|=
operator|(
name|uchar_t
operator|*
operator|)
name|base
operator|+
name|hdrsz
expr_stmt|;
name|src
operator|=
operator|(
name|uchar_t
operator|*
operator|)
name|ctfsect
operator|->
name|cts_data
operator|+
name|hdrsz
expr_stmt|;
name|srclen
operator|=
name|ctfsect
operator|->
name|cts_size
operator|-
name|hdrsz
expr_stmt|;
name|dstlen
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|z_uncompress
argument_list|(
name|buf
argument_list|,
operator|&
name|dstlen
argument_list|,
name|src
argument_list|,
name|srclen
argument_list|)
operator|)
operator|!=
name|Z_OK
condition|)
block|{
name|ctf_dprintf
argument_list|(
literal|"zlib inflate err: %s\n"
argument_list|,
name|z_strerror
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|ctf_data_free
argument_list|(
name|base
argument_list|,
name|size
operator|+
name|hdrsz
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_DECOMPRESS
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|dstlen
operator|!=
name|size
condition|)
block|{
name|ctf_dprintf
argument_list|(
literal|"zlib inflate short -- got %lu of %lu "
literal|"bytes\n"
argument_list|,
operator|(
name|ulong_t
operator|)
name|dstlen
argument_list|,
operator|(
name|ulong_t
operator|)
name|size
argument_list|)
expr_stmt|;
name|ctf_data_free
argument_list|(
name|base
argument_list|,
name|size
operator|+
name|hdrsz
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|ECTF_CORRUPT
argument_list|)
operator|)
return|;
block|}
name|ctf_data_protect
argument_list|(
name|base
argument_list|,
name|size
operator|+
name|hdrsz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
operator|(
name|void
operator|*
operator|)
name|ctfsect
operator|->
name|cts_data
expr_stmt|;
name|buf
operator|=
operator|(
name|uchar_t
operator|*
operator|)
name|base
operator|+
name|hdrsz
expr_stmt|;
block|}
comment|/* 	 * Once we have uncompressed and validated the CTF data buffer, we can 	 * proceed with allocating a ctf_file_t and initializing it. 	 */
if|if
condition|(
operator|(
name|fp
operator|=
name|ctf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ctf_file_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|EAGAIN
argument_list|)
operator|)
return|;
name|bzero
argument_list|(
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_file_t
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_version
operator|=
name|hp
operator|.
name|cth_version
expr_stmt|;
name|fp
operator|->
name|ctf_fileops
operator|=
operator|&
name|ctf_fileops
index|[
name|hp
operator|.
name|cth_version
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|ctfsect
argument_list|,
operator|&
name|fp
operator|->
name|ctf_data
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_sect_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsect
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|symsect
argument_list|,
operator|&
name|fp
operator|->
name|ctf_symtab
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_sect_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|strsect
argument_list|,
operator|&
name|fp
operator|->
name|ctf_strtab
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_sect_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|ctf_data
operator|.
name|cts_name
operator|!=
name|NULL
condition|)
name|fp
operator|->
name|ctf_data
operator|.
name|cts_name
operator|=
name|ctf_strdup
argument_list|(
name|fp
operator|->
name|ctf_data
operator|.
name|cts_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_symtab
operator|.
name|cts_name
operator|!=
name|NULL
condition|)
name|fp
operator|->
name|ctf_symtab
operator|.
name|cts_name
operator|=
name|ctf_strdup
argument_list|(
name|fp
operator|->
name|ctf_symtab
operator|.
name|cts_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_strtab
operator|.
name|cts_name
operator|!=
name|NULL
condition|)
name|fp
operator|->
name|ctf_strtab
operator|.
name|cts_name
operator|=
name|ctf_strdup
argument_list|(
name|fp
operator|->
name|ctf_strtab
operator|.
name|cts_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_data
operator|.
name|cts_name
operator|==
name|NULL
condition|)
name|fp
operator|->
name|ctf_data
operator|.
name|cts_name
operator|=
name|_CTF_NULLSTR
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_symtab
operator|.
name|cts_name
operator|==
name|NULL
condition|)
name|fp
operator|->
name|ctf_symtab
operator|.
name|cts_name
operator|=
name|_CTF_NULLSTR
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_strtab
operator|.
name|cts_name
operator|==
name|NULL
condition|)
name|fp
operator|->
name|ctf_strtab
operator|.
name|cts_name
operator|=
name|_CTF_NULLSTR
expr_stmt|;
name|fp
operator|->
name|ctf_str
index|[
name|CTF_STRTAB_0
index|]
operator|.
name|cts_strs
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|+
name|hp
operator|.
name|cth_stroff
expr_stmt|;
name|fp
operator|->
name|ctf_str
index|[
name|CTF_STRTAB_0
index|]
operator|.
name|cts_len
operator|=
name|hp
operator|.
name|cth_strlen
expr_stmt|;
if|if
condition|(
name|strsect
operator|!=
name|NULL
condition|)
block|{
name|fp
operator|->
name|ctf_str
index|[
name|CTF_STRTAB_1
index|]
operator|.
name|cts_strs
operator|=
name|strsect
operator|->
name|cts_data
expr_stmt|;
name|fp
operator|->
name|ctf_str
index|[
name|CTF_STRTAB_1
index|]
operator|.
name|cts_len
operator|=
name|strsect
operator|->
name|cts_size
expr_stmt|;
block|}
name|fp
operator|->
name|ctf_base
operator|=
name|base
expr_stmt|;
name|fp
operator|->
name|ctf_buf
operator|=
name|buf
expr_stmt|;
name|fp
operator|->
name|ctf_size
operator|=
name|size
operator|+
name|hdrsz
expr_stmt|;
comment|/* 	 * If we have a parent container name and label, store the relocated 	 * string pointers in the CTF container for easy access later. 	 */
if|if
condition|(
name|hp
operator|.
name|cth_parlabel
operator|!=
literal|0
condition|)
name|fp
operator|->
name|ctf_parlabel
operator|=
name|ctf_strptr
argument_list|(
name|fp
argument_list|,
name|hp
operator|.
name|cth_parlabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|.
name|cth_parname
operator|!=
literal|0
condition|)
name|fp
operator|->
name|ctf_parname
operator|=
name|ctf_strptr
argument_list|(
name|fp
argument_list|,
name|hp
operator|.
name|cth_parname
argument_list|)
expr_stmt|;
name|ctf_dprintf
argument_list|(
literal|"ctf_bufopen: parent name %s (label %s)\n"
argument_list|,
name|fp
operator|->
name|ctf_parname
condition|?
name|fp
operator|->
name|ctf_parname
else|:
literal|"<NULL>"
argument_list|,
name|fp
operator|->
name|ctf_parlabel
condition|?
name|fp
operator|->
name|ctf_parlabel
else|:
literal|"<NULL>"
argument_list|)
expr_stmt|;
comment|/* 	 * If we have a symbol table section, allocate and initialize 	 * the symtab translation table, pointed to by ctf_sxlate. 	 */
if|if
condition|(
name|symsect
operator|!=
name|NULL
condition|)
block|{
name|fp
operator|->
name|ctf_nsyms
operator|=
name|symsect
operator|->
name|cts_size
operator|/
name|symsect
operator|->
name|cts_entsize
expr_stmt|;
name|fp
operator|->
name|ctf_sxlate
operator|=
name|ctf_alloc
argument_list|(
name|fp
operator|->
name|ctf_nsyms
operator|*
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_sxlate
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|EAGAIN
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|init_symtab
argument_list|(
name|fp
argument_list|,
operator|&
name|hp
argument_list|,
name|symsect
argument_list|,
name|strsect
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|init_types
argument_list|(
name|fp
argument_list|,
operator|&
name|hp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Initialize the ctf_lookup_by_name top-level dictionary.  We keep an 	 * array of type name prefixes and the corresponding ctf_hash to use. 	 * NOTE: This code must be kept in sync with the code in ctf_update(). 	 */
name|fp
operator|->
name|ctf_lookups
index|[
literal|0
index|]
operator|.
name|ctl_prefix
operator|=
literal|"struct"
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|0
index|]
operator|.
name|ctl_len
operator|=
name|strlen
argument_list|(
name|fp
operator|->
name|ctf_lookups
index|[
literal|0
index|]
operator|.
name|ctl_prefix
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|0
index|]
operator|.
name|ctl_hash
operator|=
operator|&
name|fp
operator|->
name|ctf_structs
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|1
index|]
operator|.
name|ctl_prefix
operator|=
literal|"union"
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|1
index|]
operator|.
name|ctl_len
operator|=
name|strlen
argument_list|(
name|fp
operator|->
name|ctf_lookups
index|[
literal|1
index|]
operator|.
name|ctl_prefix
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|1
index|]
operator|.
name|ctl_hash
operator|=
operator|&
name|fp
operator|->
name|ctf_unions
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|2
index|]
operator|.
name|ctl_prefix
operator|=
literal|"enum"
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|2
index|]
operator|.
name|ctl_len
operator|=
name|strlen
argument_list|(
name|fp
operator|->
name|ctf_lookups
index|[
literal|2
index|]
operator|.
name|ctl_prefix
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|2
index|]
operator|.
name|ctl_hash
operator|=
operator|&
name|fp
operator|->
name|ctf_enums
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|3
index|]
operator|.
name|ctl_prefix
operator|=
name|_CTF_NULLSTR
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|3
index|]
operator|.
name|ctl_len
operator|=
name|strlen
argument_list|(
name|fp
operator|->
name|ctf_lookups
index|[
literal|3
index|]
operator|.
name|ctl_prefix
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|3
index|]
operator|.
name|ctl_hash
operator|=
operator|&
name|fp
operator|->
name|ctf_names
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|4
index|]
operator|.
name|ctl_prefix
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|4
index|]
operator|.
name|ctl_len
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|4
index|]
operator|.
name|ctl_hash
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symsect
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|symsect
operator|->
name|cts_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ctf_setmodel
argument_list|(
name|fp
argument_list|,
name|CTF_MODEL_LP64
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|ctf_setmodel
argument_list|(
name|fp
argument_list|,
name|CTF_MODEL_ILP32
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ctf_setmodel
argument_list|(
name|fp
argument_list|,
name|CTF_MODEL_NATIVE
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_refcnt
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
name|bad
label|:
name|ctf_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dupliate a ctf_file_t and its underlying section information into a new  * container. This works by copying the three ctf_sect_t's of the original  * container if they exist and passing those into ctf_bufopen. To copy those, we  * mmap anonymous memory with ctf_data_alloc and bcopy the data across. It's not  * the cheapest thing, but it's what we've got.  */
end_comment

begin_function
name|ctf_file_t
modifier|*
name|ctf_dup
parameter_list|(
name|ctf_file_t
modifier|*
name|ofp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fp
decl_stmt|;
name|ctf_sect_t
name|ctfsect
decl_stmt|,
name|symsect
decl_stmt|,
name|strsect
decl_stmt|;
name|ctf_sect_t
modifier|*
name|ctp
decl_stmt|,
modifier|*
name|symp
decl_stmt|,
modifier|*
name|strp
decl_stmt|;
name|void
modifier|*
name|cbuf
decl_stmt|,
modifier|*
name|symbuf
decl_stmt|,
modifier|*
name|strbuf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|cbuf
operator|=
name|symbuf
operator|=
name|strbuf
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * The ctfsect isn't allowed to not exist, but the symbol and string 	 * section might not. We only need to copy the data of the section, not 	 * the name, as ctf_bufopen will take care of that. 	 */
name|bcopy
argument_list|(
operator|&
name|ofp
operator|->
name|ctf_data
argument_list|,
operator|&
name|ctfsect
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_sect_t
argument_list|)
argument_list|)
expr_stmt|;
name|cbuf
operator|=
name|ctf_data_alloc
argument_list|(
name|ctfsect
operator|.
name|cts_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbuf
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_MMAP
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|ctfsect
operator|.
name|cts_data
argument_list|,
name|cbuf
argument_list|,
name|ctfsect
operator|.
name|cts_size
argument_list|)
expr_stmt|;
name|ctf_data_protect
argument_list|(
name|cbuf
argument_list|,
name|ctfsect
operator|.
name|cts_size
argument_list|)
expr_stmt|;
name|ctfsect
operator|.
name|cts_data
operator|=
name|cbuf
expr_stmt|;
name|ctfsect
operator|.
name|cts_offset
operator|=
literal|0
expr_stmt|;
name|ctp
operator|=
operator|&
name|ctfsect
expr_stmt|;
if|if
condition|(
name|ofp
operator|->
name|ctf_symtab
operator|.
name|cts_data
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|ofp
operator|->
name|ctf_symtab
argument_list|,
operator|&
name|symsect
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_sect_t
argument_list|)
argument_list|)
expr_stmt|;
name|symbuf
operator|=
name|ctf_data_alloc
argument_list|(
name|symsect
operator|.
name|cts_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbuf
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_MMAP
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|bcopy
argument_list|(
name|symsect
operator|.
name|cts_data
argument_list|,
name|symbuf
argument_list|,
name|symsect
operator|.
name|cts_size
argument_list|)
expr_stmt|;
name|ctf_data_protect
argument_list|(
name|symbuf
argument_list|,
name|symsect
operator|.
name|cts_size
argument_list|)
expr_stmt|;
name|symsect
operator|.
name|cts_data
operator|=
name|symbuf
expr_stmt|;
name|symsect
operator|.
name|cts_offset
operator|=
literal|0
expr_stmt|;
name|symp
operator|=
operator|&
name|symsect
expr_stmt|;
block|}
else|else
block|{
name|symp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ofp
operator|->
name|ctf_strtab
operator|.
name|cts_data
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|ofp
operator|->
name|ctf_strtab
argument_list|,
operator|&
name|strsect
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_sect_t
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf
operator|=
name|ctf_data_alloc
argument_list|(
name|strsect
operator|.
name|cts_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_MMAP
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|bcopy
argument_list|(
name|strsect
operator|.
name|cts_data
argument_list|,
name|strbuf
argument_list|,
name|strsect
operator|.
name|cts_size
argument_list|)
expr_stmt|;
name|ctf_data_protect
argument_list|(
name|strbuf
argument_list|,
name|strsect
operator|.
name|cts_size
argument_list|)
expr_stmt|;
name|strsect
operator|.
name|cts_data
operator|=
name|strbuf
expr_stmt|;
name|strsect
operator|.
name|cts_offset
operator|=
literal|0
expr_stmt|;
name|strp
operator|=
operator|&
name|strsect
expr_stmt|;
block|}
else|else
block|{
name|strp
operator|=
name|NULL
expr_stmt|;
block|}
name|fp
operator|=
name|ctf_bufopen
argument_list|(
name|ctp
argument_list|,
name|symp
argument_list|,
name|strp
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|fp
operator|->
name|ctf_flags
operator||=
name|LCTF_MMAP
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
name|err
label|:
name|ctf_data_free
argument_list|(
name|cbuf
argument_list|,
name|ctfsect
operator|.
name|cts_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbuf
operator|!=
name|NULL
condition|)
name|ctf_data_free
argument_list|(
name|symbuf
argument_list|,
name|symsect
operator|.
name|cts_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf
operator|!=
name|NULL
condition|)
name|ctf_data_free
argument_list|(
name|strbuf
argument_list|,
name|strsect
operator|.
name|cts_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the specified CTF container and free associated data structures.  Note  * that ctf_close() is a reference counted operation: if the specified file is  * the parent of other active containers, its reference count will be greater  * than one and it will be freed later when no active children exist.  */
end_comment

begin_function
name|void
name|ctf_close
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|)
block|{
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|,
modifier|*
name|ntd
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return;
comment|/* allow ctf_close(NULL) to simplify caller code */
name|ctf_dprintf
argument_list|(
literal|"ctf_close(%p) refcnt=%u\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fp
argument_list|,
name|fp
operator|->
name|ctf_refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_refcnt
operator|>
literal|1
condition|)
block|{
name|fp
operator|->
name|ctf_refcnt
operator|--
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fp
operator|->
name|ctf_parent
operator|!=
name|NULL
condition|)
name|ctf_close
argument_list|(
name|fp
operator|->
name|ctf_parent
argument_list|)
expr_stmt|;
comment|/* 	 * Note, to work properly with reference counting on the dynamic 	 * section, we must delete the list in reverse. 	 */
for|for
control|(
name|dtd
operator|=
name|ctf_list_prev
argument_list|(
operator|&
name|fp
operator|->
name|ctf_dtdefs
argument_list|)
init|;
name|dtd
operator|!=
name|NULL
condition|;
name|dtd
operator|=
name|ntd
control|)
block|{
name|ntd
operator|=
name|ctf_list_prev
argument_list|(
name|dtd
argument_list|)
expr_stmt|;
name|ctf_dtd_delete
argument_list|(
name|fp
argument_list|,
name|dtd
argument_list|)
expr_stmt|;
block|}
name|ctf_free
argument_list|(
name|fp
operator|->
name|ctf_dthash
argument_list|,
name|fp
operator|->
name|ctf_dthashlen
operator|*
sizeof|sizeof
argument_list|(
name|ctf_dtdef_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_MMAP
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|ctf_data
operator|.
name|cts_data
operator|!=
name|NULL
condition|)
name|ctf_sect_munmap
argument_list|(
operator|&
name|fp
operator|->
name|ctf_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_symtab
operator|.
name|cts_data
operator|!=
name|NULL
condition|)
name|ctf_sect_munmap
argument_list|(
operator|&
name|fp
operator|->
name|ctf_symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_strtab
operator|.
name|cts_data
operator|!=
name|NULL
condition|)
name|ctf_sect_munmap
argument_list|(
operator|&
name|fp
operator|->
name|ctf_strtab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|ctf_data
operator|.
name|cts_name
operator|!=
name|_CTF_NULLSTR
operator|&&
name|fp
operator|->
name|ctf_data
operator|.
name|cts_name
operator|!=
name|NULL
condition|)
block|{
name|ctf_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|ctf_data
operator|.
name|cts_name
argument_list|,
name|strlen
argument_list|(
name|fp
operator|->
name|ctf_data
operator|.
name|cts_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|ctf_symtab
operator|.
name|cts_name
operator|!=
name|_CTF_NULLSTR
operator|&&
name|fp
operator|->
name|ctf_symtab
operator|.
name|cts_name
operator|!=
name|NULL
condition|)
block|{
name|ctf_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|ctf_symtab
operator|.
name|cts_name
argument_list|,
name|strlen
argument_list|(
name|fp
operator|->
name|ctf_symtab
operator|.
name|cts_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|ctf_strtab
operator|.
name|cts_name
operator|!=
name|_CTF_NULLSTR
operator|&&
name|fp
operator|->
name|ctf_strtab
operator|.
name|cts_name
operator|!=
name|NULL
condition|)
block|{
name|ctf_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|ctf_strtab
operator|.
name|cts_name
argument_list|,
name|strlen
argument_list|(
name|fp
operator|->
name|ctf_strtab
operator|.
name|cts_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|ctf_base
operator|!=
name|fp
operator|->
name|ctf_data
operator|.
name|cts_data
operator|&&
name|fp
operator|->
name|ctf_base
operator|!=
name|NULL
condition|)
name|ctf_data_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fp
operator|->
name|ctf_base
argument_list|,
name|fp
operator|->
name|ctf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_sxlate
operator|!=
name|NULL
condition|)
name|ctf_free
argument_list|(
name|fp
operator|->
name|ctf_sxlate
argument_list|,
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
operator|*
name|fp
operator|->
name|ctf_nsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_txlate
operator|!=
name|NULL
condition|)
block|{
name|ctf_free
argument_list|(
name|fp
operator|->
name|ctf_txlate
argument_list|,
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
operator|*
operator|(
name|fp
operator|->
name|ctf_typemax
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|ctf_ptrtab
operator|!=
name|NULL
condition|)
block|{
name|ctf_free
argument_list|(
name|fp
operator|->
name|ctf_ptrtab
argument_list|,
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|fp
operator|->
name|ctf_typemax
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|ctf_hash_destroy
argument_list|(
operator|&
name|fp
operator|->
name|ctf_structs
argument_list|)
expr_stmt|;
name|ctf_hash_destroy
argument_list|(
operator|&
name|fp
operator|->
name|ctf_unions
argument_list|)
expr_stmt|;
name|ctf_hash_destroy
argument_list|(
operator|&
name|fp
operator|->
name|ctf_enums
argument_list|)
expr_stmt|;
name|ctf_hash_destroy
argument_list|(
operator|&
name|fp
operator|->
name|ctf_names
argument_list|)
expr_stmt|;
name|ctf_free
argument_list|(
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_file_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the CTF handle for the parent CTF container, if one exists.  * Otherwise return NULL to indicate this container has no imported parent.  */
end_comment

begin_function
name|ctf_file_t
modifier|*
name|ctf_parent_file
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|)
block|{
return|return
operator|(
name|fp
operator|->
name|ctf_parent
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the name of the parent CTF container, if one exists.  Otherwise  * return NULL to indicate this container is a root container.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ctf_parent_name
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|)
block|{
return|return
operator|(
name|fp
operator|->
name|ctf_parname
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Import the types from the specified parent container by storing a pointer  * to it in ctf_parent and incrementing its reference count.  Only one parent  * is allowed: if a parent already exists, it is replaced by the new parent.  */
end_comment

begin_function
name|int
name|ctf_import
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_file_t
modifier|*
name|pfp
parameter_list|)
block|{
if|if
condition|(
name|fp
operator|==
name|NULL
operator|||
name|fp
operator|==
name|pfp
operator|||
operator|(
name|pfp
operator|!=
name|NULL
operator|&&
name|pfp
operator|->
name|ctf_refcnt
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|pfp
operator|!=
name|NULL
operator|&&
name|pfp
operator|->
name|ctf_dmodel
operator|!=
name|fp
operator|->
name|ctf_dmodel
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_DMODEL
argument_list|)
operator|)
return|;
if|if
condition|(
name|fp
operator|->
name|ctf_parent
operator|!=
name|NULL
condition|)
name|ctf_close
argument_list|(
name|fp
operator|->
name|ctf_parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfp
operator|!=
name|NULL
condition|)
block|{
name|fp
operator|->
name|ctf_flags
operator||=
name|LCTF_CHILD
expr_stmt|;
name|pfp
operator|->
name|ctf_refcnt
operator|++
expr_stmt|;
block|}
name|fp
operator|->
name|ctf_parent
operator|=
name|pfp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the data model constant for the CTF container.  */
end_comment

begin_function
name|int
name|ctf_setmodel
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|int
name|model
parameter_list|)
block|{
specifier|const
name|ctf_dmodel_t
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|_libctf_models
init|;
name|dp
operator|->
name|ctd_name
operator|!=
name|NULL
condition|;
name|dp
operator|++
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|ctd_code
operator|==
name|model
condition|)
block|{
name|fp
operator|->
name|ctf_dmodel
operator|=
name|dp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the data model constant for the CTF container.  */
end_comment

begin_function
name|int
name|ctf_getmodel
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|)
block|{
return|return
operator|(
name|fp
operator|->
name|ctf_dmodel
operator|->
name|ctd_code
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ctf_setspecific
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|fp
operator|->
name|ctf_specific
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|ctf_getspecific
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|)
block|{
return|return
operator|(
name|fp
operator|->
name|ctf_specific
operator|)
return|;
block|}
end_function

end_unit

