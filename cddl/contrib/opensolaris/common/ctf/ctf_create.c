begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013, Joyent, Inc.  All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<ctf_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/debug.h>
end_include

begin_comment
comment|/*  * This static string is used as the template for initially populating a  * dynamic container's string table.  We always store \0 in the first byte,  * and we use the generic string "PARENT" to mark this container's parent  * if one is associated with the container using ctf_import().  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|_CTF_STRTAB_TEMPLATE
index|[]
init|=
literal|"\0PARENT"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * To create an empty CTF container, we just declare a zeroed header and call  * ctf_bufopen() on it.  If ctf_bufopen succeeds, we mark the new container r/w  * and initialize the dynamic members.  We set dtstrlen to 1 to reserve the  * first byte of the string table for a \0 byte, and we start assigning type  * IDs at 1 because type ID 0 is used as a sentinel.  */
end_comment

begin_function
name|ctf_file_t
modifier|*
name|ctf_create
parameter_list|(
name|int
modifier|*
name|errp
parameter_list|)
block|{
specifier|static
specifier|const
name|ctf_header_t
name|hdr
init|=
block|{
block|{
name|CTF_MAGIC
block|,
name|CTF_VERSION
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|const
name|ulong_t
name|hashlen
init|=
literal|128
decl_stmt|;
name|ctf_dtdef_t
modifier|*
modifier|*
name|hash
init|=
name|ctf_alloc
argument_list|(
name|hashlen
operator|*
sizeof|sizeof
argument_list|(
name|ctf_dtdef_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|ctf_sect_t
name|cts
decl_stmt|;
name|ctf_file_t
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|hash
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_open_errno
argument_list|(
name|errp
argument_list|,
name|EAGAIN
argument_list|)
operator|)
return|;
name|cts
operator|.
name|cts_name
operator|=
name|_CTF_SECTION
expr_stmt|;
name|cts
operator|.
name|cts_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|cts
operator|.
name|cts_flags
operator|=
literal|0
expr_stmt|;
name|cts
operator|.
name|cts_data
operator|=
operator|&
name|hdr
expr_stmt|;
name|cts
operator|.
name|cts_size
operator|=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|cts
operator|.
name|cts_entsize
operator|=
literal|1
expr_stmt|;
name|cts
operator|.
name|cts_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|ctf_bufopen
argument_list|(
operator|&
name|cts
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|errp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ctf_free
argument_list|(
name|hash
argument_list|,
name|hashlen
operator|*
sizeof|sizeof
argument_list|(
name|ctf_dtdef_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fp
operator|->
name|ctf_flags
operator||=
name|LCTF_RDWR
expr_stmt|;
name|fp
operator|->
name|ctf_dthashlen
operator|=
name|hashlen
expr_stmt|;
name|bzero
argument_list|(
name|hash
argument_list|,
name|hashlen
operator|*
sizeof|sizeof
argument_list|(
name|ctf_dtdef_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_dthash
operator|=
name|hash
expr_stmt|;
name|fp
operator|->
name|ctf_dtstrlen
operator|=
sizeof|sizeof
argument_list|(
name|_CTF_STRTAB_TEMPLATE
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_dtnextid
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|ctf_dtoldid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uchar_t
modifier|*
name|ctf_copy_smembers
parameter_list|(
name|ctf_dtdef_t
modifier|*
name|dtd
parameter_list|,
name|uint_t
name|soff
parameter_list|,
name|uchar_t
modifier|*
name|t
parameter_list|)
block|{
name|ctf_dmdef_t
modifier|*
name|dmd
init|=
name|ctf_list_next
argument_list|(
operator|&
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_members
argument_list|)
decl_stmt|;
name|ctf_member_t
name|ctm
decl_stmt|;
for|for
control|(
init|;
name|dmd
operator|!=
name|NULL
condition|;
name|dmd
operator|=
name|ctf_list_next
argument_list|(
name|dmd
argument_list|)
control|)
block|{
if|if
condition|(
name|dmd
operator|->
name|dmd_name
condition|)
block|{
name|ctm
operator|.
name|ctm_name
operator|=
name|soff
expr_stmt|;
name|soff
operator|+=
name|strlen
argument_list|(
name|dmd
operator|->
name|dmd_name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|ctm
operator|.
name|ctm_name
operator|=
literal|0
expr_stmt|;
name|ctm
operator|.
name|ctm_type
operator|=
operator|(
name|ushort_t
operator|)
name|dmd
operator|->
name|dmd_type
expr_stmt|;
name|ctm
operator|.
name|ctm_offset
operator|=
operator|(
name|ushort_t
operator|)
name|dmd
operator|->
name|dmd_offset
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ctm
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|ctm
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|+=
sizeof|sizeof
argument_list|(
name|ctm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uchar_t
modifier|*
name|ctf_copy_lmembers
parameter_list|(
name|ctf_dtdef_t
modifier|*
name|dtd
parameter_list|,
name|uint_t
name|soff
parameter_list|,
name|uchar_t
modifier|*
name|t
parameter_list|)
block|{
name|ctf_dmdef_t
modifier|*
name|dmd
init|=
name|ctf_list_next
argument_list|(
operator|&
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_members
argument_list|)
decl_stmt|;
name|ctf_lmember_t
name|ctlm
decl_stmt|;
for|for
control|(
init|;
name|dmd
operator|!=
name|NULL
condition|;
name|dmd
operator|=
name|ctf_list_next
argument_list|(
name|dmd
argument_list|)
control|)
block|{
if|if
condition|(
name|dmd
operator|->
name|dmd_name
condition|)
block|{
name|ctlm
operator|.
name|ctlm_name
operator|=
name|soff
expr_stmt|;
name|soff
operator|+=
name|strlen
argument_list|(
name|dmd
operator|->
name|dmd_name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|ctlm
operator|.
name|ctlm_name
operator|=
literal|0
expr_stmt|;
name|ctlm
operator|.
name|ctlm_type
operator|=
operator|(
name|ushort_t
operator|)
name|dmd
operator|->
name|dmd_type
expr_stmt|;
name|ctlm
operator|.
name|ctlm_pad
operator|=
literal|0
expr_stmt|;
name|ctlm
operator|.
name|ctlm_offsethi
operator|=
name|CTF_OFFSET_TO_LMEMHI
argument_list|(
name|dmd
operator|->
name|dmd_offset
argument_list|)
expr_stmt|;
name|ctlm
operator|.
name|ctlm_offsetlo
operator|=
name|CTF_OFFSET_TO_LMEMLO
argument_list|(
name|dmd
operator|->
name|dmd_offset
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ctlm
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|ctlm
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|+=
sizeof|sizeof
argument_list|(
name|ctlm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uchar_t
modifier|*
name|ctf_copy_emembers
parameter_list|(
name|ctf_dtdef_t
modifier|*
name|dtd
parameter_list|,
name|uint_t
name|soff
parameter_list|,
name|uchar_t
modifier|*
name|t
parameter_list|)
block|{
name|ctf_dmdef_t
modifier|*
name|dmd
init|=
name|ctf_list_next
argument_list|(
operator|&
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_members
argument_list|)
decl_stmt|;
name|ctf_enum_t
name|cte
decl_stmt|;
for|for
control|(
init|;
name|dmd
operator|!=
name|NULL
condition|;
name|dmd
operator|=
name|ctf_list_next
argument_list|(
name|dmd
argument_list|)
control|)
block|{
name|cte
operator|.
name|cte_name
operator|=
name|soff
expr_stmt|;
name|cte
operator|.
name|cte_value
operator|=
name|dmd
operator|->
name|dmd_value
expr_stmt|;
name|soff
operator|+=
name|strlen
argument_list|(
name|dmd
operator|->
name|dmd_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|cte
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|cte
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|+=
sizeof|sizeof
argument_list|(
name|cte
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uchar_t
modifier|*
name|ctf_copy_membnames
parameter_list|(
name|ctf_dtdef_t
modifier|*
name|dtd
parameter_list|,
name|uchar_t
modifier|*
name|s
parameter_list|)
block|{
name|ctf_dmdef_t
modifier|*
name|dmd
init|=
name|ctf_list_next
argument_list|(
operator|&
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_members
argument_list|)
decl_stmt|;
name|size_t
name|len
decl_stmt|;
for|for
control|(
init|;
name|dmd
operator|!=
name|NULL
condition|;
name|dmd
operator|=
name|ctf_list_next
argument_list|(
name|dmd
argument_list|)
control|)
block|{
if|if
condition|(
name|dmd
operator|->
name|dmd_name
operator|==
name|NULL
condition|)
continue|continue;
comment|/* skip anonymous members */
name|len
operator|=
name|strlen
argument_list|(
name|dmd
operator|->
name|dmd_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|dmd
operator|->
name|dmd_name
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Only types of dyanmic CTF containers contain reference counts. These  * containers are marked RD/WR. Because of that we basically make this a no-op  * for compatability with non-dynamic CTF sections. This is also a no-op for  * types which are not dynamic types. It is the responsibility of the caller to  * make sure it is a valid type. We help that caller out on debug builds.  *  * Note that the reference counts are not maintained for types that are not  * within this container. In other words if we have a type in a parent, that  * will not have its reference count increased. On the flip side, the parent  * will not be allowed to remove dynamic types if it has children.  */
end_comment

begin_function
specifier|static
name|void
name|ctf_ref_inc
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|tid
parameter_list|)
block|{
name|ctf_dtdef_t
modifier|*
name|dtd
init|=
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|dtd
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_RDWR
operator|)
condition|)
return|return;
name|dtd
operator|->
name|dtd_ref
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Just as with ctf_ref_inc, this is a no-op on non-writeable containers and the  * caller should ensure that this is already a valid type.  */
end_comment

begin_function
specifier|static
name|void
name|ctf_ref_dec
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|tid
parameter_list|)
block|{
name|ctf_dtdef_t
modifier|*
name|dtd
init|=
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|dtd
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_RDWR
operator|)
condition|)
return|return;
name|ASSERT
argument_list|(
name|dtd
operator|->
name|dtd_ref
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_ref
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If the specified CTF container is writable and has been modified, reload  * this container with the updated type definitions.  In order to make this  * code and the rest of libctf as simple as possible, we perform updates by  * taking the dynamic type definitions and creating an in-memory CTF file  * containing the definitions, and then call ctf_bufopen() on it.  This not  * only leverages ctf_bufopen(), but also avoids having to bifurcate the rest  * of the library code with different lookup paths for static and dynamic  * type definitions.  We are therefore optimizing greatly for lookup over  * update, which we assume will be an uncommon operation.  We perform one  * extra trick here for the benefit of callers and to keep our code simple:  * ctf_bufopen() will return a new ctf_file_t, but we want to keep the fp  * constant for the caller, so after ctf_bufopen() returns, we use bcopy to  * swap the interior of the old and new ctf_file_t's, and then free the old.  *  * Note that the lists of dynamic types stays around and the resulting container  * is still writeable. Furthermore, the reference counts that are on the dtd's  * are still valid.  */
end_comment

begin_function
name|int
name|ctf_update
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|)
block|{
name|ctf_file_t
name|ofp
decl_stmt|,
modifier|*
name|nfp
decl_stmt|;
name|ctf_header_t
name|hdr
decl_stmt|;
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|;
name|ctf_sect_t
name|cts
decl_stmt|;
name|uchar_t
modifier|*
name|s
decl_stmt|,
modifier|*
name|s0
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_RDWR
operator|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_RDONLY
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_DIRTY
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no update required */
comment|/* 	 * Fill in an initial CTF header.  We will leave the label, object, 	 * and function sections empty and only output a header, type section, 	 * and string table.  The type section begins at a 4-byte aligned 	 * boundary past the CTF header itself (at relative offset zero). 	 */
name|bzero
argument_list|(
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|cth_magic
operator|=
name|CTF_MAGIC
expr_stmt|;
name|hdr
operator|.
name|cth_version
operator|=
name|CTF_VERSION
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_CHILD
condition|)
name|hdr
operator|.
name|cth_parname
operator|=
literal|1
expr_stmt|;
comment|/* i.e. _CTF_STRTAB_TEMPLATE[1] */
comment|/* 	 * Iterate through the dynamic type definition list and compute the 	 * size of the CTF type section we will need to generate. 	 */
for|for
control|(
name|size
operator|=
literal|0
operator|,
name|dtd
operator|=
name|ctf_list_next
argument_list|(
operator|&
name|fp
operator|->
name|ctf_dtdefs
argument_list|)
init|;
name|dtd
operator|!=
name|NULL
condition|;
name|dtd
operator|=
name|ctf_list_next
argument_list|(
name|dtd
argument_list|)
control|)
block|{
name|uint_t
name|kind
init|=
name|CTF_INFO_KIND
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
decl_stmt|;
name|uint_t
name|vlen
init|=
name|CTF_INFO_VLEN
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_size
operator|!=
name|CTF_LSIZE_SENT
condition|)
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_stype_t
argument_list|)
expr_stmt|;
else|else
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_type_t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_array_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|vlen
operator|+
operator|(
name|vlen
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
if|if
condition|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_member_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
else|else
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_lmember_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
break|break;
case|case
name|CTF_K_ENUM
case|:
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_enum_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Fill in the string table offset and size, compute the size of the 	 * entire CTF buffer we need, and then allocate a new buffer and 	 * bcopy the finished header to the start of the buffer. 	 */
name|hdr
operator|.
name|cth_stroff
operator|=
name|hdr
operator|.
name|cth_typeoff
operator|+
name|size
expr_stmt|;
name|hdr
operator|.
name|cth_strlen
operator|=
name|fp
operator|->
name|ctf_dtstrlen
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
operator|+
name|hdr
operator|.
name|cth_stroff
operator|+
name|hdr
operator|.
name|cth_strlen
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|ctf_data_alloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|MAP_FAILED
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EAGAIN
argument_list|)
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|hdr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
name|uchar_t
operator|*
operator|)
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
expr_stmt|;
name|s
operator|=
name|s0
operator|=
operator|(
name|uchar_t
operator|*
operator|)
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
operator|+
name|hdr
operator|.
name|cth_stroff
expr_stmt|;
name|bcopy
argument_list|(
name|_CTF_STRTAB_TEMPLATE
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|_CTF_STRTAB_TEMPLATE
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|_CTF_STRTAB_TEMPLATE
argument_list|)
expr_stmt|;
comment|/* 	 * We now take a final lap through the dynamic type definition list and 	 * copy the appropriate type records and strings to the output buffer. 	 */
for|for
control|(
name|dtd
operator|=
name|ctf_list_next
argument_list|(
operator|&
name|fp
operator|->
name|ctf_dtdefs
argument_list|)
init|;
name|dtd
operator|!=
name|NULL
condition|;
name|dtd
operator|=
name|ctf_list_next
argument_list|(
name|dtd
argument_list|)
control|)
block|{
name|uint_t
name|kind
init|=
name|CTF_INFO_KIND
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
decl_stmt|;
name|uint_t
name|vlen
init|=
name|CTF_INFO_VLEN
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
decl_stmt|;
name|ctf_array_t
name|cta
decl_stmt|;
name|uint_t
name|encoding
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|dtd
operator|->
name|dtd_name
operator|!=
name|NULL
condition|)
block|{
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_name
operator|=
call|(
name|uint_t
call|)
argument_list|(
name|s
operator|-
name|s0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|dtd
operator|->
name|dtd_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|dtd
operator|->
name|dtd_name
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
block|}
else|else
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_size
operator|!=
name|CTF_LSIZE_SENT
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ctf_stype_t
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ctf_type_t
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dtd
operator|->
name|dtd_data
argument_list|,
name|t
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|t
operator|+=
name|len
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
if|if
condition|(
name|kind
operator|==
name|CTF_K_INTEGER
condition|)
block|{
name|encoding
operator|=
name|CTF_INT_DATA
argument_list|(
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_enc
operator|.
name|cte_format
argument_list|,
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_enc
operator|.
name|cte_offset
argument_list|,
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_enc
operator|.
name|cte_bits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|encoding
operator|=
name|CTF_FP_DATA
argument_list|(
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_enc
operator|.
name|cte_format
argument_list|,
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_enc
operator|.
name|cte_offset
argument_list|,
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_enc
operator|.
name|cte_bits
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|&
name|encoding
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|+=
sizeof|sizeof
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|cta
operator|.
name|cta_contents
operator|=
operator|(
name|ushort_t
operator|)
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_arr
operator|.
name|ctr_contents
expr_stmt|;
name|cta
operator|.
name|cta_index
operator|=
operator|(
name|ushort_t
operator|)
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_arr
operator|.
name|ctr_index
expr_stmt|;
name|cta
operator|.
name|cta_nelems
operator|=
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_arr
operator|.
name|ctr_nelems
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|cta
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|cta
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|+=
sizeof|sizeof
argument_list|(
name|cta
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
block|{
name|ushort_t
modifier|*
name|argv
init|=
operator|(
name|ushort_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|t
decl_stmt|;
name|uint_t
name|argc
decl_stmt|;
for|for
control|(
name|argc
operator|=
literal|0
init|;
name|argc
operator|<
name|vlen
condition|;
name|argc
operator|++
control|)
operator|*
name|argv
operator|++
operator|=
operator|(
name|ushort_t
operator|)
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_argv
index|[
name|argc
index|]
expr_stmt|;
if|if
condition|(
name|vlen
operator|&
literal|1
condition|)
operator|*
name|argv
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* pad to 4-byte boundary */
name|t
operator|=
operator|(
name|uchar_t
operator|*
operator|)
name|argv
expr_stmt|;
break|break;
block|}
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
if|if
condition|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
name|t
operator|=
name|ctf_copy_smembers
argument_list|(
name|dtd
argument_list|,
call|(
name|uint_t
call|)
argument_list|(
name|s
operator|-
name|s0
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|ctf_copy_lmembers
argument_list|(
name|dtd
argument_list|,
call|(
name|uint_t
call|)
argument_list|(
name|s
operator|-
name|s0
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|s
operator|=
name|ctf_copy_membnames
argument_list|(
name|dtd
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ENUM
case|:
name|t
operator|=
name|ctf_copy_emembers
argument_list|(
name|dtd
argument_list|,
call|(
name|uint_t
call|)
argument_list|(
name|s
operator|-
name|s0
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|s
operator|=
name|ctf_copy_membnames
argument_list|(
name|dtd
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Finally, we are ready to ctf_bufopen() the new container.  If this 	 * is successful, we then switch nfp and fp and free the old container. 	 */
name|ctf_data_protect
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cts
operator|.
name|cts_name
operator|=
name|_CTF_SECTION
expr_stmt|;
name|cts
operator|.
name|cts_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|cts
operator|.
name|cts_flags
operator|=
literal|0
expr_stmt|;
name|cts
operator|.
name|cts_data
operator|=
name|buf
expr_stmt|;
name|cts
operator|.
name|cts_size
operator|=
name|size
expr_stmt|;
name|cts
operator|.
name|cts_entsize
operator|=
literal|1
expr_stmt|;
name|cts
operator|.
name|cts_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|nfp
operator|=
name|ctf_bufopen
argument_list|(
operator|&
name|cts
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|err
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ctf_data_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|err
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ctf_setmodel
argument_list|(
name|nfp
argument_list|,
name|ctf_getmodel
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ctf_import
argument_list|(
name|nfp
argument_list|,
name|fp
operator|->
name|ctf_parent
argument_list|)
expr_stmt|;
name|nfp
operator|->
name|ctf_refcnt
operator|=
name|fp
operator|->
name|ctf_refcnt
expr_stmt|;
name|nfp
operator|->
name|ctf_flags
operator||=
name|fp
operator|->
name|ctf_flags
operator|&
operator|~
name|LCTF_DIRTY
expr_stmt|;
name|nfp
operator|->
name|ctf_data
operator|.
name|cts_data
operator|=
name|NULL
expr_stmt|;
comment|/* force ctf_data_free() on close */
name|nfp
operator|->
name|ctf_dthash
operator|=
name|fp
operator|->
name|ctf_dthash
expr_stmt|;
name|nfp
operator|->
name|ctf_dthashlen
operator|=
name|fp
operator|->
name|ctf_dthashlen
expr_stmt|;
name|nfp
operator|->
name|ctf_dtdefs
operator|=
name|fp
operator|->
name|ctf_dtdefs
expr_stmt|;
name|nfp
operator|->
name|ctf_dtstrlen
operator|=
name|fp
operator|->
name|ctf_dtstrlen
expr_stmt|;
name|nfp
operator|->
name|ctf_dtnextid
operator|=
name|fp
operator|->
name|ctf_dtnextid
expr_stmt|;
name|nfp
operator|->
name|ctf_dtoldid
operator|=
name|fp
operator|->
name|ctf_dtnextid
operator|-
literal|1
expr_stmt|;
name|nfp
operator|->
name|ctf_specific
operator|=
name|fp
operator|->
name|ctf_specific
expr_stmt|;
name|fp
operator|->
name|ctf_dthash
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|ctf_dthashlen
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|fp
operator|->
name|ctf_dtdefs
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_list_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fp
argument_list|,
operator|&
name|ofp
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_file_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|nfp
argument_list|,
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_file_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ofp
argument_list|,
name|nfp
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_file_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the ctf_lookup_by_name top-level dictionary.  We keep an 	 * array of type name prefixes and the corresponding ctf_hash to use. 	 * NOTE: This code must be kept in sync with the code in ctf_bufopen(). 	 */
name|fp
operator|->
name|ctf_lookups
index|[
literal|0
index|]
operator|.
name|ctl_hash
operator|=
operator|&
name|fp
operator|->
name|ctf_structs
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|1
index|]
operator|.
name|ctl_hash
operator|=
operator|&
name|fp
operator|->
name|ctf_unions
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|2
index|]
operator|.
name|ctl_hash
operator|=
operator|&
name|fp
operator|->
name|ctf_enums
expr_stmt|;
name|fp
operator|->
name|ctf_lookups
index|[
literal|3
index|]
operator|.
name|ctl_hash
operator|=
operator|&
name|fp
operator|->
name|ctf_names
expr_stmt|;
name|nfp
operator|->
name|ctf_refcnt
operator|=
literal|1
expr_stmt|;
comment|/* force nfp to be freed */
name|ctf_close
argument_list|(
name|nfp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ctf_dtd_insert
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_dtdef_t
modifier|*
name|dtd
parameter_list|)
block|{
name|ulong_t
name|h
init|=
name|dtd
operator|->
name|dtd_type
operator|&
operator|(
name|fp
operator|->
name|ctf_dthashlen
operator|-
literal|1
operator|)
decl_stmt|;
name|dtd
operator|->
name|dtd_hash
operator|=
name|fp
operator|->
name|ctf_dthash
index|[
name|h
index|]
expr_stmt|;
name|fp
operator|->
name|ctf_dthash
index|[
name|h
index|]
operator|=
name|dtd
expr_stmt|;
name|ctf_list_append
argument_list|(
operator|&
name|fp
operator|->
name|ctf_dtdefs
argument_list|,
name|dtd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctf_dtd_delete
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_dtdef_t
modifier|*
name|dtd
parameter_list|)
block|{
name|ulong_t
name|h
init|=
name|dtd
operator|->
name|dtd_type
operator|&
operator|(
name|fp
operator|->
name|ctf_dthashlen
operator|-
literal|1
operator|)
decl_stmt|;
name|ctf_dtdef_t
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|q
init|=
operator|&
name|fp
operator|->
name|ctf_dthash
index|[
name|h
index|]
decl_stmt|;
name|ctf_dmdef_t
modifier|*
name|dmd
decl_stmt|,
modifier|*
name|nmd
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|kind
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|q
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|dtd_hash
control|)
block|{
if|if
condition|(
name|p
operator|!=
name|dtd
condition|)
name|q
operator|=
operator|&
name|p
operator|->
name|dtd_hash
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|=
name|p
operator|->
name|dtd_hash
expr_stmt|;
name|kind
operator|=
name|CTF_INFO_KIND
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
case|case
name|CTF_K_ENUM
case|:
for|for
control|(
name|dmd
operator|=
name|ctf_list_next
argument_list|(
operator|&
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_members
argument_list|)
init|;
name|dmd
operator|!=
name|NULL
condition|;
name|dmd
operator|=
name|nmd
control|)
block|{
if|if
condition|(
name|dmd
operator|->
name|dmd_name
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|dmd
operator|->
name|dmd_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ctf_free
argument_list|(
name|dmd
operator|->
name|dmd_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_dtstrlen
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|!=
name|CTF_K_ENUM
condition|)
name|ctf_ref_dec
argument_list|(
name|fp
argument_list|,
name|dmd
operator|->
name|dmd_type
argument_list|)
expr_stmt|;
name|nmd
operator|=
name|ctf_list_next
argument_list|(
name|dmd
argument_list|)
expr_stmt|;
name|ctf_free
argument_list|(
name|dmd
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_dmdef_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|ctf_ref_dec
argument_list|(
name|fp
argument_list|,
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTF_INFO_VLEN
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_argv
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|ctf_ref_dec
argument_list|(
name|fp
argument_list|,
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ctf_free
argument_list|(
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_argv
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_id_t
argument_list|)
operator|*
name|CTF_INFO_VLEN
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|ctf_ref_dec
argument_list|(
name|fp
argument_list|,
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_arr
operator|.
name|ctr_contents
argument_list|)
expr_stmt|;
name|ctf_ref_dec
argument_list|(
name|fp
argument_list|,
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_arr
operator|.
name|ctr_index
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_TYPEDEF
case|:
name|ctf_ref_dec
argument_list|(
name|fp
argument_list|,
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
name|ctf_ref_dec
argument_list|(
name|fp
argument_list|,
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dtd
operator|->
name|dtd_name
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|dtd
operator|->
name|dtd_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ctf_free
argument_list|(
name|dtd
operator|->
name|dtd_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_dtstrlen
operator|-=
name|len
expr_stmt|;
block|}
name|ctf_list_delete
argument_list|(
operator|&
name|fp
operator|->
name|ctf_dtdefs
argument_list|,
name|dtd
argument_list|)
expr_stmt|;
name|ctf_free
argument_list|(
name|dtd
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_dtdef_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ctf_dtdef_t
modifier|*
name|ctf_dtd_lookup
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
name|ulong_t
name|h
init|=
name|type
operator|&
operator|(
name|fp
operator|->
name|ctf_dthashlen
operator|-
literal|1
operator|)
decl_stmt|;
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_dthash
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|dtd
operator|=
name|fp
operator|->
name|ctf_dthash
index|[
name|h
index|]
init|;
name|dtd
operator|!=
name|NULL
condition|;
name|dtd
operator|=
name|dtd
operator|->
name|dtd_hash
control|)
block|{
if|if
condition|(
name|dtd
operator|->
name|dtd_type
operator|==
name|type
condition|)
break|break;
block|}
return|return
operator|(
name|dtd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Discard all of the dynamic type definitions that have been added to the  * container since the last call to ctf_update().  We locate such types by  * scanning the list and deleting elements that have type IDs greater than  * ctf_dtoldid, which is set by ctf_update(), above. Note that to work properly  * with our reference counting schemes, we must delete the dynamic list in  * reverse.  */
end_comment

begin_function
name|int
name|ctf_discard
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|)
block|{
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|,
modifier|*
name|ntd
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_RDWR
operator|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_RDONLY
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_DIRTY
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no update required */
for|for
control|(
name|dtd
operator|=
name|ctf_list_prev
argument_list|(
operator|&
name|fp
operator|->
name|ctf_dtdefs
argument_list|)
init|;
name|dtd
operator|!=
name|NULL
condition|;
name|dtd
operator|=
name|ntd
control|)
block|{
name|ntd
operator|=
name|ctf_list_prev
argument_list|(
name|dtd
argument_list|)
expr_stmt|;
if|if
condition|(
name|CTF_TYPE_TO_INDEX
argument_list|(
name|dtd
operator|->
name|dtd_type
argument_list|)
operator|<=
name|fp
operator|->
name|ctf_dtoldid
condition|)
continue|continue;
comment|/* skip types that have been committed */
name|ctf_dtd_delete
argument_list|(
name|fp
argument_list|,
name|dtd
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|ctf_dtnextid
operator|=
name|fp
operator|->
name|ctf_dtoldid
operator|+
literal|1
expr_stmt|;
name|fp
operator|->
name|ctf_flags
operator|&=
operator|~
name|LCTF_DIRTY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ctf_id_t
name|ctf_add_generic
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ctf_dtdef_t
modifier|*
modifier|*
name|rp
parameter_list|)
block|{
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|flag
operator|!=
name|CTF_ADD_NONROOT
operator|&&
name|flag
operator|!=
name|CTF_ADD_ROOT
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_RDWR
operator|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_RDONLY
argument_list|)
operator|)
return|;
if|if
condition|(
name|CTF_INDEX_TO_TYPE
argument_list|(
name|fp
operator|->
name|ctf_dtnextid
argument_list|,
literal|1
argument_list|)
operator|>
name|CTF_MAX_TYPE
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_FULL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|dtd
operator|=
name|ctf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ctf_dtdef_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EAGAIN
argument_list|)
operator|)
return|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|=
name|ctf_strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ctf_free
argument_list|(
name|dtd
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_dtdef_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EAGAIN
argument_list|)
operator|)
return|;
block|}
name|type
operator|=
name|fp
operator|->
name|ctf_dtnextid
operator|++
expr_stmt|;
name|type
operator|=
name|CTF_INDEX_TO_TYPE
argument_list|(
name|type
argument_list|,
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_CHILD
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dtd
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_dtdef_t
argument_list|)
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_name
operator|=
name|s
expr_stmt|;
name|dtd
operator|->
name|dtd_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|fp
operator|->
name|ctf_dtstrlen
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ctf_dtd_insert
argument_list|(
name|fp
argument_list|,
name|dtd
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_flags
operator||=
name|LCTF_DIRTY
expr_stmt|;
operator|*
name|rp
operator|=
name|dtd
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When encoding integer sizes, we want to convert a byte count in the range  * 1-8 to the closest power of 2 (e.g. 3->4, 5->8, etc).  The clp2() function  * is a clever implementation from "Hacker's Delight" by Henry Warren, Jr.  */
end_comment

begin_function
specifier|static
name|size_t
name|clp2
parameter_list|(
name|size_t
name|x
parameter_list|)
block|{
name|x
operator|--
expr_stmt|;
name|x
operator||=
operator|(
name|x
operator|>>
literal|1
operator|)
expr_stmt|;
name|x
operator||=
operator|(
name|x
operator|>>
literal|2
operator|)
expr_stmt|;
name|x
operator||=
operator|(
name|x
operator|>>
literal|4
operator|)
expr_stmt|;
name|x
operator||=
operator|(
name|x
operator|>>
literal|8
operator|)
expr_stmt|;
name|x
operator||=
operator|(
name|x
operator|>>
literal|16
operator|)
expr_stmt|;
return|return
operator|(
name|x
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ctf_id_t
name|ctf_add_encoded
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|ctf_encoding_t
modifier|*
name|ep
parameter_list|,
name|uint_t
name|kind
parameter_list|)
block|{
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_add_generic
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|,
operator|&
name|dtd
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|kind
argument_list|,
name|flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_size
operator|=
name|clp2
argument_list|(
name|P2ROUNDUP
argument_list|(
name|ep
operator|->
name|cte_bits
argument_list|,
name|NBBY
argument_list|)
operator|/
name|NBBY
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_enc
operator|=
operator|*
name|ep
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ctf_id_t
name|ctf_add_reftype
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
name|ctf_id_t
name|ref
parameter_list|,
name|uint_t
name|kind
parameter_list|)
block|{
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
if|if
condition|(
name|ref
operator|==
name|CTF_ERR
operator|||
name|ref
operator|<
literal|0
operator|||
name|ref
operator|>
name|CTF_MAX_TYPE
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_add_generic
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|NULL
argument_list|,
operator|&
name|dtd
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
name|ctf_ref_inc
argument_list|(
name|fp
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|kind
argument_list|,
name|flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_type
operator|=
operator|(
name|ushort_t
operator|)
name|ref
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
name|ctf_id_t
name|ctf_add_integer
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|ctf_encoding_t
modifier|*
name|ep
parameter_list|)
block|{
return|return
operator|(
name|ctf_add_encoded
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|,
name|ep
argument_list|,
name|CTF_K_INTEGER
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ctf_id_t
name|ctf_add_float
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|ctf_encoding_t
modifier|*
name|ep
parameter_list|)
block|{
return|return
operator|(
name|ctf_add_encoded
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|,
name|ep
argument_list|,
name|CTF_K_FLOAT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ctf_id_t
name|ctf_add_pointer
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
name|ctf_id_t
name|ref
parameter_list|)
block|{
return|return
operator|(
name|ctf_add_reftype
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|ref
argument_list|,
name|CTF_K_POINTER
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ctf_id_t
name|ctf_add_array
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
specifier|const
name|ctf_arinfo_t
modifier|*
name|arp
parameter_list|)
block|{
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|ctf_file_t
modifier|*
name|fpd
decl_stmt|;
if|if
condition|(
name|arp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
name|fpd
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fpd
argument_list|,
name|arp
operator|->
name|ctr_contents
argument_list|)
operator|==
name|NULL
operator|&&
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|arp
operator|->
name|ctr_contents
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_BADID
argument_list|)
operator|)
return|;
name|fpd
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fpd
argument_list|,
name|arp
operator|->
name|ctr_index
argument_list|)
operator|==
name|NULL
operator|&&
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|arp
operator|->
name|ctr_index
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_BADID
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_add_generic
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|NULL
argument_list|,
operator|&
name|dtd
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_ARRAY
argument_list|,
name|flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_size
operator|=
literal|0
expr_stmt|;
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_arr
operator|=
operator|*
name|arp
expr_stmt|;
name|ctf_ref_inc
argument_list|(
name|fp
argument_list|,
name|arp
operator|->
name|ctr_contents
argument_list|)
expr_stmt|;
name|ctf_ref_inc
argument_list|(
name|fp
argument_list|,
name|arp
operator|->
name|ctr_index
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctf_set_array
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
specifier|const
name|ctf_arinfo_t
modifier|*
name|arp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fpd
decl_stmt|;
name|ctf_dtdef_t
modifier|*
name|dtd
init|=
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_RDWR
operator|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_RDONLY
argument_list|)
operator|)
return|;
if|if
condition|(
name|dtd
operator|==
name|NULL
operator|||
name|CTF_INFO_KIND
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
operator|!=
name|CTF_K_ARRAY
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_BADID
argument_list|)
operator|)
return|;
name|fpd
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fpd
argument_list|,
name|arp
operator|->
name|ctr_contents
argument_list|)
operator|==
name|NULL
operator|&&
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|arp
operator|->
name|ctr_contents
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_BADID
argument_list|)
operator|)
return|;
name|fpd
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fpd
argument_list|,
name|arp
operator|->
name|ctr_index
argument_list|)
operator|==
name|NULL
operator|&&
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|arp
operator|->
name|ctr_index
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_BADID
argument_list|)
operator|)
return|;
name|ctf_ref_dec
argument_list|(
name|fp
argument_list|,
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_arr
operator|.
name|ctr_contents
argument_list|)
expr_stmt|;
name|ctf_ref_dec
argument_list|(
name|fp
argument_list|,
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_arr
operator|.
name|ctr_index
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_flags
operator||=
name|LCTF_DIRTY
expr_stmt|;
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_arr
operator|=
operator|*
name|arp
expr_stmt|;
name|ctf_ref_inc
argument_list|(
name|fp
argument_list|,
name|arp
operator|->
name|ctr_contents
argument_list|)
expr_stmt|;
name|ctf_ref_inc
argument_list|(
name|fp
argument_list|,
name|arp
operator|->
name|ctr_index
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|ctf_id_t
name|ctf_add_function
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
specifier|const
name|ctf_funcinfo_t
modifier|*
name|ctc
parameter_list|,
specifier|const
name|ctf_id_t
modifier|*
name|argv
parameter_list|)
block|{
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|uint_t
name|vlen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ctf_id_t
modifier|*
name|vdat
init|=
name|NULL
decl_stmt|;
name|ctf_file_t
modifier|*
name|fpd
decl_stmt|;
if|if
condition|(
name|ctc
operator|==
name|NULL
operator|||
operator|(
name|ctc
operator|->
name|ctc_flags
operator|&
operator|~
name|CTF_FUNC_VARARG
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ctc
operator|->
name|ctc_argc
operator|!=
literal|0
operator|&&
name|argv
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
name|vlen
operator|=
name|ctc
operator|->
name|ctc_argc
expr_stmt|;
if|if
condition|(
name|ctc
operator|->
name|ctc_flags
operator|&
name|CTF_FUNC_VARARG
condition|)
name|vlen
operator|++
expr_stmt|;
comment|/* add trailing zero to indicate varargs (see below) */
if|if
condition|(
name|vlen
operator|>
name|CTF_MAX_VLEN
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EOVERFLOW
argument_list|)
operator|)
return|;
name|fpd
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fpd
argument_list|,
name|ctc
operator|->
name|ctc_return
argument_list|)
operator|==
name|NULL
operator|&&
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|ctc
operator|->
name|ctc_return
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_BADID
argument_list|)
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctc
operator|->
name|ctc_argc
condition|;
name|i
operator|++
control|)
block|{
name|fpd
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fpd
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|==
name|NULL
operator|&&
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_BADID
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|vlen
operator|!=
literal|0
operator|&&
operator|(
name|vdat
operator|=
name|ctf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ctf_id_t
argument_list|)
operator|*
name|vlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EAGAIN
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_add_generic
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|NULL
argument_list|,
operator|&
name|dtd
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
block|{
name|ctf_free
argument_list|(
name|vdat
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_id_t
argument_list|)
operator|*
name|vlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
block|}
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_FUNCTION
argument_list|,
name|flag
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_type
operator|=
operator|(
name|ushort_t
operator|)
name|ctc
operator|->
name|ctc_return
expr_stmt|;
name|ctf_ref_inc
argument_list|(
name|fp
argument_list|,
name|ctc
operator|->
name|ctc_return
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctc
operator|->
name|ctc_argc
condition|;
name|i
operator|++
control|)
name|ctf_ref_inc
argument_list|(
name|fp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|argv
argument_list|,
name|vdat
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_id_t
argument_list|)
operator|*
name|ctc
operator|->
name|ctc_argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctc
operator|->
name|ctc_flags
operator|&
name|CTF_FUNC_VARARG
condition|)
name|vdat
index|[
name|vlen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* add trailing zero to indicate varargs */
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_argv
operator|=
name|vdat
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
name|ctf_id_t
name|ctf_add_struct
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ctf_hash_t
modifier|*
name|hp
init|=
operator|&
name|fp
operator|->
name|ctf_structs
decl_stmt|;
name|ctf_helem_t
modifier|*
name|hep
init|=
name|NULL
decl_stmt|;
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|hep
operator|=
name|ctf_hash_lookup
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hep
operator|!=
name|NULL
operator|&&
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|hep
operator|->
name|h_type
argument_list|)
operator|==
name|CTF_K_FORWARD
condition|)
name|dtd
operator|=
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|type
operator|=
name|hep
operator|->
name|h_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_add_generic
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|,
operator|&
name|dtd
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_STRUCT
argument_list|,
name|flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_size
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
name|ctf_id_t
name|ctf_add_union
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ctf_hash_t
modifier|*
name|hp
init|=
operator|&
name|fp
operator|->
name|ctf_unions
decl_stmt|;
name|ctf_helem_t
modifier|*
name|hep
init|=
name|NULL
decl_stmt|;
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|hep
operator|=
name|ctf_hash_lookup
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hep
operator|!=
name|NULL
operator|&&
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|hep
operator|->
name|h_type
argument_list|)
operator|==
name|CTF_K_FORWARD
condition|)
name|dtd
operator|=
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|type
operator|=
name|hep
operator|->
name|h_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_add_generic
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|,
operator|&
name|dtd
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_UNION
argument_list|,
name|flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_size
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
name|ctf_id_t
name|ctf_add_enum
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ctf_hash_t
modifier|*
name|hp
init|=
operator|&
name|fp
operator|->
name|ctf_enums
decl_stmt|;
name|ctf_helem_t
modifier|*
name|hep
init|=
name|NULL
decl_stmt|;
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|hep
operator|=
name|ctf_hash_lookup
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hep
operator|!=
name|NULL
operator|&&
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|hep
operator|->
name|h_type
argument_list|)
operator|==
name|CTF_K_FORWARD
condition|)
name|dtd
operator|=
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|type
operator|=
name|hep
operator|->
name|h_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_add_generic
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|,
operator|&
name|dtd
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_ENUM
argument_list|,
name|flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_size
operator|=
name|fp
operator|->
name|ctf_dmodel
operator|->
name|ctd_int
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
name|ctf_id_t
name|ctf_add_forward
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint_t
name|kind
parameter_list|)
block|{
name|ctf_hash_t
modifier|*
name|hp
decl_stmt|;
name|ctf_helem_t
modifier|*
name|hep
decl_stmt|;
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_STRUCT
case|:
name|hp
operator|=
operator|&
name|fp
operator|->
name|ctf_structs
expr_stmt|;
break|break;
case|case
name|CTF_K_UNION
case|:
name|hp
operator|=
operator|&
name|fp
operator|->
name|ctf_unions
expr_stmt|;
break|break;
case|case
name|CTF_K_ENUM
case|:
name|hp
operator|=
operator|&
name|fp
operator|->
name|ctf_enums
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOTSUE
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If the type is already defined or exists as a forward tag, just 	 * return the ctf_id_t of the existing definition. 	 */
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
operator|(
name|hep
operator|=
name|ctf_hash_lookup
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|hep
operator|->
name|h_type
operator|)
return|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_add_generic
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|,
operator|&
name|dtd
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_FORWARD
argument_list|,
name|flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_type
operator|=
name|kind
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
name|ctf_id_t
name|ctf_add_typedef
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ctf_id_t
name|ref
parameter_list|)
block|{
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|ctf_file_t
modifier|*
name|fpd
decl_stmt|;
name|fpd
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|ref
operator|==
name|CTF_ERR
operator|||
operator|(
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fpd
argument_list|,
name|ref
argument_list|)
operator|==
name|NULL
operator|&&
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|ref
argument_list|)
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_add_generic
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|,
operator|&
name|dtd
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_TYPEDEF
argument_list|,
name|flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_type
operator|=
operator|(
name|ushort_t
operator|)
name|ref
expr_stmt|;
name|ctf_ref_inc
argument_list|(
name|fp
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
name|ctf_id_t
name|ctf_add_volatile
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
name|ctf_id_t
name|ref
parameter_list|)
block|{
return|return
operator|(
name|ctf_add_reftype
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|ref
argument_list|,
name|CTF_K_VOLATILE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ctf_id_t
name|ctf_add_const
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
name|ctf_id_t
name|ref
parameter_list|)
block|{
return|return
operator|(
name|ctf_add_reftype
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|ref
argument_list|,
name|CTF_K_CONST
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ctf_id_t
name|ctf_add_restrict
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|uint_t
name|flag
parameter_list|,
name|ctf_id_t
name|ref
parameter_list|)
block|{
return|return
operator|(
name|ctf_add_reftype
argument_list|(
name|fp
argument_list|,
name|flag
argument_list|,
name|ref
argument_list|,
name|CTF_K_RESTRICT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctf_add_enumerator
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|enid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|ctf_dtdef_t
modifier|*
name|dtd
init|=
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|enid
argument_list|)
decl_stmt|;
name|ctf_dmdef_t
modifier|*
name|dmd
decl_stmt|;
name|uint_t
name|kind
decl_stmt|,
name|vlen
decl_stmt|,
name|root
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_RDWR
operator|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_RDONLY
argument_list|)
operator|)
return|;
if|if
condition|(
name|dtd
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_BADID
argument_list|)
operator|)
return|;
name|kind
operator|=
name|CTF_INFO_KIND
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
expr_stmt|;
name|root
operator|=
name|CTF_INFO_ISROOT
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
expr_stmt|;
name|vlen
operator|=
name|CTF_INFO_VLEN
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|CTF_K_ENUM
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOTENUM
argument_list|)
operator|)
return|;
if|if
condition|(
name|vlen
operator|==
name|CTF_MAX_VLEN
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_DTFULL
argument_list|)
operator|)
return|;
for|for
control|(
name|dmd
operator|=
name|ctf_list_next
argument_list|(
operator|&
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_members
argument_list|)
init|;
name|dmd
operator|!=
name|NULL
condition|;
name|dmd
operator|=
name|ctf_list_next
argument_list|(
name|dmd
argument_list|)
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dmd
operator|->
name|dmd_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_DUPMEMBER
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dmd
operator|=
name|ctf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ctf_dmdef_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EAGAIN
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|s
operator|=
name|ctf_strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ctf_free
argument_list|(
name|dmd
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_dmdef_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EAGAIN
argument_list|)
operator|)
return|;
block|}
name|dmd
operator|->
name|dmd_name
operator|=
name|s
expr_stmt|;
name|dmd
operator|->
name|dmd_type
operator|=
name|CTF_ERR
expr_stmt|;
name|dmd
operator|->
name|dmd_offset
operator|=
literal|0
expr_stmt|;
name|dmd
operator|->
name|dmd_value
operator|=
name|value
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|kind
argument_list|,
name|root
argument_list|,
name|vlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ctf_list_append
argument_list|(
operator|&
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_members
argument_list|,
name|dmd
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_dtstrlen
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fp
operator|->
name|ctf_flags
operator||=
name|LCTF_DIRTY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctf_add_member
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|souid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
name|ctf_dtdef_t
modifier|*
name|dtd
init|=
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|souid
argument_list|)
decl_stmt|;
name|ctf_dmdef_t
modifier|*
name|dmd
decl_stmt|;
name|ssize_t
name|msize
decl_stmt|,
name|malign
decl_stmt|,
name|ssize
decl_stmt|;
name|uint_t
name|kind
decl_stmt|,
name|vlen
decl_stmt|,
name|root
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_RDWR
operator|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_RDONLY
argument_list|)
operator|)
return|;
if|if
condition|(
name|dtd
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_BADID
argument_list|)
operator|)
return|;
name|kind
operator|=
name|CTF_INFO_KIND
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
expr_stmt|;
name|root
operator|=
name|CTF_INFO_ISROOT
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
expr_stmt|;
name|vlen
operator|=
name|CTF_INFO_VLEN
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|CTF_K_STRUCT
operator|&&
name|kind
operator|!=
name|CTF_K_UNION
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOTSOU
argument_list|)
operator|)
return|;
if|if
condition|(
name|vlen
operator|==
name|CTF_MAX_VLEN
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_DTFULL
argument_list|)
operator|)
return|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|dmd
operator|=
name|ctf_list_next
argument_list|(
operator|&
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_members
argument_list|)
init|;
name|dmd
operator|!=
name|NULL
condition|;
name|dmd
operator|=
name|ctf_list_next
argument_list|(
name|dmd
argument_list|)
control|)
block|{
if|if
condition|(
name|dmd
operator|->
name|dmd_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|dmd
operator|->
name|dmd_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_DUPMEMBER
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|msize
operator|=
name|ctf_type_size
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|CTF_ERR
operator|||
operator|(
name|malign
operator|=
name|ctf_type_align
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
operator|(
name|dmd
operator|=
name|ctf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ctf_dmdef_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EAGAIN
argument_list|)
operator|)
return|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|=
name|ctf_strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ctf_free
argument_list|(
name|dmd
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_dmdef_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|EAGAIN
argument_list|)
operator|)
return|;
block|}
name|dmd
operator|->
name|dmd_name
operator|=
name|s
expr_stmt|;
name|dmd
operator|->
name|dmd_type
operator|=
name|type
expr_stmt|;
name|dmd
operator|->
name|dmd_value
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_STRUCT
operator|&&
name|vlen
operator|!=
literal|0
condition|)
block|{
name|ctf_dmdef_t
modifier|*
name|lmd
init|=
name|ctf_list_prev
argument_list|(
operator|&
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_members
argument_list|)
decl_stmt|;
name|ctf_id_t
name|ltype
init|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|lmd
operator|->
name|dmd_type
argument_list|)
decl_stmt|;
name|size_t
name|off
init|=
name|lmd
operator|->
name|dmd_offset
decl_stmt|;
name|ctf_encoding_t
name|linfo
decl_stmt|;
name|ssize_t
name|lsize
decl_stmt|;
if|if
condition|(
name|ctf_type_encoding
argument_list|(
name|fp
argument_list|,
name|ltype
argument_list|,
operator|&
name|linfo
argument_list|)
operator|!=
name|CTF_ERR
condition|)
name|off
operator|+=
name|linfo
operator|.
name|cte_bits
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|lsize
operator|=
name|ctf_type_size
argument_list|(
name|fp
argument_list|,
name|ltype
argument_list|)
operator|)
operator|!=
name|CTF_ERR
condition|)
name|off
operator|+=
name|lsize
operator|*
name|NBBY
expr_stmt|;
comment|/* 		 * Round up the offset of the end of the last member to the 		 * next byte boundary, convert 'off' to bytes, and then round 		 * it up again to the next multiple of the alignment required 		 * by the new member.  Finally, convert back to bits and store 		 * the result in dmd_offset.  Technically we could do more 		 * efficient packing if the new member is a bit-field, but 		 * we're the "compiler" and ANSI says we can do as we choose. 		 */
name|off
operator|=
name|roundup
argument_list|(
name|off
argument_list|,
name|NBBY
argument_list|)
operator|/
name|NBBY
expr_stmt|;
name|off
operator|=
name|roundup
argument_list|(
name|off
argument_list|,
name|MAX
argument_list|(
name|malign
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dmd
operator|->
name|dmd_offset
operator|=
name|off
operator|*
name|NBBY
expr_stmt|;
name|ssize
operator|=
name|off
operator|+
name|msize
expr_stmt|;
block|}
else|else
block|{
name|dmd
operator|->
name|dmd_offset
operator|=
literal|0
expr_stmt|;
name|ssize
operator|=
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
operator|&
name|dtd
operator|->
name|dtd_data
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ssize
operator|=
name|MAX
argument_list|(
name|ssize
argument_list|,
name|msize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ssize
operator|>
name|CTF_MAX_SIZE
condition|)
block|{
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_size
operator|=
name|CTF_LSIZE_SENT
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_lsizehi
operator|=
name|CTF_SIZE_TO_LSIZE_HI
argument_list|(
name|ssize
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_lsizelo
operator|=
name|CTF_SIZE_TO_LSIZE_LO
argument_list|(
name|ssize
argument_list|)
expr_stmt|;
block|}
else|else
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_size
operator|=
operator|(
name|ushort_t
operator|)
name|ssize
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|kind
argument_list|,
name|root
argument_list|,
name|vlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ctf_list_append
argument_list|(
operator|&
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_members
argument_list|,
name|dmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|fp
operator|->
name|ctf_dtstrlen
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ctf_ref_inc
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_flags
operator||=
name|LCTF_DIRTY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This removes a type from the dynamic section. This will fail if the type is  * referenced by another type. Note that the CTF ID is never reused currently by  * CTF. Note that if this container is a parent container then we just outright  * refuse to remove the type. There currently is no notion of searching for the  * ctf_dtdef_t in parent containers. If there is, then this constraint could  * become finer grained.  */
end_comment

begin_function
name|int
name|ctf_delete_type
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|fpd
decl_stmt|;
name|ctf_dtdef_t
modifier|*
name|dtd
init|=
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_RDWR
operator|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_RDONLY
argument_list|)
operator|)
return|;
comment|/* 	 * We want to give as useful an errno as possible. That means that we 	 * want to distinguish between a type which does not exist and one for 	 * which the type is not dynamic. 	 */
name|fpd
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fpd
argument_list|,
name|type
argument_list|)
operator|==
name|NULL
operator|&&
name|ctf_dtd_lookup
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
name|dtd
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NOTDYN
argument_list|)
operator|)
return|;
if|if
condition|(
name|dtd
operator|->
name|dtd_ref
operator|!=
literal|0
operator|||
name|fp
operator|->
name|ctf_refcnt
operator|>
literal|1
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_REFERENCED
argument_list|)
operator|)
return|;
name|ctf_dtd_delete
argument_list|(
name|fp
argument_list|,
name|dtd
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ctf_flags
operator||=
name|LCTF_DIRTY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|enumcmp
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ctf_bundle_t
modifier|*
name|ctb
init|=
name|arg
decl_stmt|;
name|int
name|bvalue
decl_stmt|;
return|return
operator|(
name|ctf_enum_value
argument_list|(
name|ctb
operator|->
name|ctb_file
argument_list|,
name|ctb
operator|->
name|ctb_type
argument_list|,
name|name
argument_list|,
operator|&
name|bvalue
argument_list|)
operator|==
name|CTF_ERR
operator|||
name|value
operator|!=
name|bvalue
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|enumadd
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ctf_bundle_t
modifier|*
name|ctb
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|ctf_add_enumerator
argument_list|(
name|ctb
operator|->
name|ctb_file
argument_list|,
name|ctb
operator|->
name|ctb_type
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
operator|==
name|CTF_ERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|membcmp
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|ulong_t
name|offset
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ctf_bundle_t
modifier|*
name|ctb
init|=
name|arg
decl_stmt|;
name|ctf_membinfo_t
name|ctm
decl_stmt|;
return|return
operator|(
name|ctf_member_info
argument_list|(
name|ctb
operator|->
name|ctb_file
argument_list|,
name|ctb
operator|->
name|ctb_type
argument_list|,
name|name
argument_list|,
operator|&
name|ctm
argument_list|)
operator|==
name|CTF_ERR
operator|||
name|ctm
operator|.
name|ctm_offset
operator|!=
name|offset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|membadd
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|ulong_t
name|offset
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ctf_bundle_t
modifier|*
name|ctb
init|=
name|arg
decl_stmt|;
name|ctf_dmdef_t
modifier|*
name|dmd
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|dmd
operator|=
name|ctf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ctf_dmdef_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|ctb
operator|->
name|ctb_file
argument_list|,
name|EAGAIN
argument_list|)
operator|)
return|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|=
name|ctf_strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ctf_free
argument_list|(
name|dmd
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_dmdef_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|ctb
operator|->
name|ctb_file
argument_list|,
name|EAGAIN
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * For now, dmd_type is copied as the src_fp's type; it is reset to an 	 * equivalent dst_fp type by a final loop in ctf_add_type(), below. 	 */
name|dmd
operator|->
name|dmd_name
operator|=
name|s
expr_stmt|;
name|dmd
operator|->
name|dmd_type
operator|=
name|type
expr_stmt|;
name|dmd
operator|->
name|dmd_offset
operator|=
name|offset
expr_stmt|;
name|dmd
operator|->
name|dmd_value
operator|=
operator|-
literal|1
expr_stmt|;
name|ctf_list_append
argument_list|(
operator|&
name|ctb
operator|->
name|ctb_dtd
operator|->
name|dtd_u
operator|.
name|dtu_members
argument_list|,
name|dmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|ctb
operator|->
name|ctb_file
operator|->
name|ctf_dtstrlen
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ctb
operator|->
name|ctb_file
operator|->
name|ctf_flags
operator||=
name|LCTF_DIRTY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The ctf_add_type routine is used to copy a type from a source CTF container  * to a dynamic destination container.  This routine operates recursively by  * following the source type's links and embedded member types.  If the  * destination container already contains a named type which has the same  * attributes, then we succeed and return this type but no changes occur.  */
end_comment

begin_function
name|ctf_id_t
name|ctf_add_type
parameter_list|(
name|ctf_file_t
modifier|*
name|dst_fp
parameter_list|,
name|ctf_file_t
modifier|*
name|src_fp
parameter_list|,
name|ctf_id_t
name|src_type
parameter_list|)
block|{
name|ctf_id_t
name|dst_type
init|=
name|CTF_ERR
decl_stmt|;
name|uint_t
name|dst_kind
init|=
name|CTF_K_UNKNOWN
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint_t
name|kind
decl_stmt|,
name|flag
decl_stmt|,
name|vlen
decl_stmt|;
name|ctf_bundle_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|ctf_encoding_t
name|src_en
decl_stmt|,
name|dst_en
decl_stmt|;
name|ctf_arinfo_t
name|src_ar
decl_stmt|,
name|dst_ar
decl_stmt|;
name|ctf_dtdef_t
modifier|*
name|dtd
decl_stmt|;
name|ctf_funcinfo_t
name|ctc
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
name|ctf_hash_t
modifier|*
name|hp
decl_stmt|;
name|ctf_helem_t
modifier|*
name|hep
decl_stmt|;
if|if
condition|(
name|dst_fp
operator|==
name|src_fp
condition|)
return|return
operator|(
name|src_type
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|dst_fp
operator|->
name|ctf_flags
operator|&
name|LCTF_RDWR
operator|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|dst_fp
argument_list|,
name|ECTF_RDONLY
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|src_fp
argument_list|,
name|src_type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|dst_fp
argument_list|,
name|ctf_errno
argument_list|(
name|src_fp
argument_list|)
argument_list|)
operator|)
return|;
name|name
operator|=
name|ctf_strptr
argument_list|(
name|src_fp
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
expr_stmt|;
name|kind
operator|=
name|LCTF_INFO_KIND
argument_list|(
name|src_fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
expr_stmt|;
name|flag
operator|=
name|LCTF_INFO_ROOT
argument_list|(
name|src_fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
expr_stmt|;
name|vlen
operator|=
name|LCTF_INFO_VLEN
argument_list|(
name|src_fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_STRUCT
case|:
name|hp
operator|=
operator|&
name|dst_fp
operator|->
name|ctf_structs
expr_stmt|;
break|break;
case|case
name|CTF_K_UNION
case|:
name|hp
operator|=
operator|&
name|dst_fp
operator|->
name|ctf_unions
expr_stmt|;
break|break;
case|case
name|CTF_K_ENUM
case|:
name|hp
operator|=
operator|&
name|dst_fp
operator|->
name|ctf_enums
expr_stmt|;
break|break;
default|default:
name|hp
operator|=
operator|&
name|dst_fp
operator|->
name|ctf_names
expr_stmt|;
break|break;
block|}
comment|/* 	 * If the source type has a name and is a root type (visible at the 	 * top-level scope), lookup the name in the destination container and 	 * verify that it is of the same kind before we do anything else. 	 */
if|if
condition|(
operator|(
name|flag
operator|&
name|CTF_ADD_ROOT
operator|)
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|hep
operator|=
name|ctf_hash_lookup
argument_list|(
name|hp
argument_list|,
name|dst_fp
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dst_type
operator|=
operator|(
name|ctf_id_t
operator|)
name|hep
operator|->
name|h_type
expr_stmt|;
name|dst_kind
operator|=
name|ctf_type_kind
argument_list|(
name|dst_fp
argument_list|,
name|dst_type
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If an identically named dst_type exists, fail with ECTF_CONFLICT 	 * unless dst_type is a forward declaration and src_type is a struct, 	 * union, or enum (i.e. the definition of the previous forward decl). 	 */
if|if
condition|(
name|dst_type
operator|!=
name|CTF_ERR
operator|&&
name|dst_kind
operator|!=
name|kind
condition|)
block|{
if|if
condition|(
name|dst_kind
operator|!=
name|CTF_K_FORWARD
operator|||
operator|(
name|kind
operator|!=
name|CTF_K_ENUM
operator|&&
name|kind
operator|!=
name|CTF_K_STRUCT
operator|&&
name|kind
operator|!=
name|CTF_K_UNION
operator|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|dst_fp
argument_list|,
name|ECTF_CONFLICT
argument_list|)
operator|)
return|;
else|else
name|dst_type
operator|=
name|CTF_ERR
expr_stmt|;
block|}
comment|/* 	 * If the non-empty name was not found in the appropriate hash, search 	 * the list of pending dynamic definitions that are not yet committed. 	 * If a matching name and kind are found, assume this is the type that 	 * we are looking for.  This is necessary to permit ctf_add_type() to 	 * operate recursively on entities such as a struct that contains a 	 * pointer member that refers to the same struct type. 	 * 	 * In the case of integer and floating point types, we match using the 	 * type encoding as well - else we may incorrectly return a bitfield 	 * type, for instance. 	 */
if|if
condition|(
name|dst_type
operator|==
name|CTF_ERR
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
name|dtd
operator|=
name|ctf_list_prev
argument_list|(
operator|&
name|dst_fp
operator|->
name|ctf_dtdefs
argument_list|)
init|;
name|dtd
operator|!=
name|NULL
operator|&&
name|CTF_TYPE_TO_INDEX
argument_list|(
name|dtd
operator|->
name|dtd_type
argument_list|)
operator|>
name|dst_fp
operator|->
name|ctf_dtoldid
condition|;
name|dtd
operator|=
name|ctf_list_prev
argument_list|(
name|dtd
argument_list|)
control|)
block|{
if|if
condition|(
name|CTF_INFO_KIND
argument_list|(
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
argument_list|)
operator|!=
name|kind
operator|||
name|dtd
operator|->
name|dtd_name
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|dtd
operator|->
name|dtd_name
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|kind
operator|==
name|CTF_K_INTEGER
operator|||
name|kind
operator|==
name|CTF_K_FLOAT
condition|)
block|{
if|if
condition|(
name|ctf_type_encoding
argument_list|(
name|src_fp
argument_list|,
name|src_type
argument_list|,
operator|&
name|src_en
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|src_en
argument_list|,
operator|&
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_enc
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_encoding_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
return|return
operator|(
name|dtd
operator|->
name|dtd_type
operator|)
return|;
block|}
block|}
name|src
operator|.
name|ctb_file
operator|=
name|src_fp
expr_stmt|;
name|src
operator|.
name|ctb_type
operator|=
name|src_type
expr_stmt|;
name|src
operator|.
name|ctb_dtd
operator|=
name|NULL
expr_stmt|;
name|dst
operator|.
name|ctb_file
operator|=
name|dst_fp
expr_stmt|;
name|dst
operator|.
name|ctb_type
operator|=
name|dst_type
expr_stmt|;
name|dst
operator|.
name|ctb_dtd
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Now perform kind-specific processing.  If dst_type is CTF_ERR, then 	 * we add a new type with the same properties as src_type to dst_fp. 	 * If dst_type is not CTF_ERR, then we verify that dst_type has the 	 * same attributes as src_type.  We recurse for embedded references. 	 */
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
if|if
condition|(
name|ctf_type_encoding
argument_list|(
name|src_fp
argument_list|,
name|src_type
argument_list|,
operator|&
name|src_en
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|dst_fp
argument_list|,
name|ctf_errno
argument_list|(
name|src_fp
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|dst_type
operator|!=
name|CTF_ERR
condition|)
block|{
if|if
condition|(
name|ctf_type_encoding
argument_list|(
name|dst_fp
argument_list|,
name|dst_type
argument_list|,
operator|&
name|dst_en
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|src_en
argument_list|,
operator|&
name|dst_en
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_encoding_t
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|dst_fp
argument_list|,
name|ECTF_CONFLICT
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
name|CTF_K_INTEGER
condition|)
block|{
name|dst_type
operator|=
name|ctf_add_integer
argument_list|(
name|dst_fp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|,
operator|&
name|src_en
argument_list|)
expr_stmt|;
block|}
else|else
name|dst_type
operator|=
name|ctf_add_float
argument_list|(
name|dst_fp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|,
operator|&
name|src_en
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
name|src_type
operator|=
name|ctf_type_reference
argument_list|(
name|src_fp
argument_list|,
name|src_type
argument_list|)
expr_stmt|;
name|src_type
operator|=
name|ctf_add_type
argument_list|(
name|dst_fp
argument_list|,
name|src_fp
argument_list|,
name|src_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_type
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
name|dst_type
operator|=
name|ctf_add_reftype
argument_list|(
name|dst_fp
argument_list|,
name|flag
argument_list|,
name|src_type
argument_list|,
name|kind
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
if|if
condition|(
name|ctf_array_info
argument_list|(
name|src_fp
argument_list|,
name|src_type
argument_list|,
operator|&
name|src_ar
argument_list|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|dst_fp
argument_list|,
name|ctf_errno
argument_list|(
name|src_fp
argument_list|)
argument_list|)
operator|)
return|;
name|src_ar
operator|.
name|ctr_contents
operator|=
name|ctf_add_type
argument_list|(
name|dst_fp
argument_list|,
name|src_fp
argument_list|,
name|src_ar
operator|.
name|ctr_contents
argument_list|)
expr_stmt|;
name|src_ar
operator|.
name|ctr_index
operator|=
name|ctf_add_type
argument_list|(
name|dst_fp
argument_list|,
name|src_fp
argument_list|,
name|src_ar
operator|.
name|ctr_index
argument_list|)
expr_stmt|;
name|src_ar
operator|.
name|ctr_nelems
operator|=
name|src_ar
operator|.
name|ctr_nelems
expr_stmt|;
if|if
condition|(
name|src_ar
operator|.
name|ctr_contents
operator|==
name|CTF_ERR
operator|||
name|src_ar
operator|.
name|ctr_index
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
name|dst_type
operator|!=
name|CTF_ERR
condition|)
block|{
if|if
condition|(
name|ctf_array_info
argument_list|(
name|dst_fp
argument_list|,
name|dst_type
argument_list|,
operator|&
name|dst_ar
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|src_ar
argument_list|,
operator|&
name|dst_ar
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_arinfo_t
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|dst_fp
argument_list|,
name|ECTF_CONFLICT
argument_list|)
operator|)
return|;
block|}
else|else
name|dst_type
operator|=
name|ctf_add_array
argument_list|(
name|dst_fp
argument_list|,
name|flag
argument_list|,
operator|&
name|src_ar
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|ctc
operator|.
name|ctc_return
operator|=
name|ctf_add_type
argument_list|(
name|dst_fp
argument_list|,
name|src_fp
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
name|ctc
operator|.
name|ctc_argc
operator|=
literal|0
expr_stmt|;
name|ctc
operator|.
name|ctc_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctc
operator|.
name|ctc_return
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
name|dst_type
operator|=
name|ctf_add_function
argument_list|(
name|dst_fp
argument_list|,
name|flag
argument_list|,
operator|&
name|ctc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
block|{
name|ctf_dmdef_t
modifier|*
name|dmd
decl_stmt|;
name|int
name|errs
init|=
literal|0
decl_stmt|;
comment|/* 		 * Technically to match a struct or union we need to check both 		 * ways (src members vs. dst, dst members vs. src) but we make 		 * this more optimal by only checking src vs. dst and comparing 		 * the total size of the structure (which we must do anyway) 		 * which covers the possibility of dst members not in src. 		 * This optimization can be defeated for unions, but is so 		 * pathological as to render it irrelevant for our purposes. 		 */
if|if
condition|(
name|dst_type
operator|!=
name|CTF_ERR
operator|&&
name|dst_kind
operator|!=
name|CTF_K_FORWARD
condition|)
block|{
if|if
condition|(
name|ctf_type_size
argument_list|(
name|src_fp
argument_list|,
name|src_type
argument_list|)
operator|!=
name|ctf_type_size
argument_list|(
name|dst_fp
argument_list|,
name|dst_type
argument_list|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|dst_fp
argument_list|,
name|ECTF_CONFLICT
argument_list|)
operator|)
return|;
if|if
condition|(
name|ctf_member_iter
argument_list|(
name|src_fp
argument_list|,
name|src_type
argument_list|,
name|membcmp
argument_list|,
operator|&
name|dst
argument_list|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|dst_fp
argument_list|,
name|ECTF_CONFLICT
argument_list|)
operator|)
return|;
break|break;
block|}
comment|/* 		 * Unlike the other cases, copying structs and unions is done 		 * manually so as to avoid repeated lookups in ctf_add_member 		 * and to ensure the exact same member offsets as in src_type. 		 */
name|dst_type
operator|=
name|ctf_add_generic
argument_list|(
name|dst_fp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|,
operator|&
name|dtd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_type
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
name|dst
operator|.
name|ctb_type
operator|=
name|dst_type
expr_stmt|;
name|dst
operator|.
name|ctb_dtd
operator|=
name|dtd
expr_stmt|;
if|if
condition|(
name|ctf_member_iter
argument_list|(
name|src_fp
argument_list|,
name|src_type
argument_list|,
name|membadd
argument_list|,
operator|&
name|dst
argument_list|)
operator|!=
literal|0
condition|)
name|errs
operator|++
expr_stmt|;
comment|/* increment errs and fail at bottom of case */
if|if
condition|(
operator|(
name|size
operator|=
name|ctf_type_size
argument_list|(
name|src_fp
argument_list|,
name|src_type
argument_list|)
operator|)
operator|>
name|CTF_MAX_SIZE
condition|)
block|{
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_size
operator|=
name|CTF_LSIZE_SENT
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_lsizehi
operator|=
name|CTF_SIZE_TO_LSIZE_HI
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_lsizelo
operator|=
name|CTF_SIZE_TO_LSIZE_LO
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_size
operator|=
operator|(
name|ushort_t
operator|)
name|size
expr_stmt|;
name|dtd
operator|->
name|dtd_data
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|kind
argument_list|,
name|flag
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
comment|/* 		 * Make a final pass through the members changing each dmd_type 		 * (a src_fp type) to an equivalent type in dst_fp.  We pass 		 * through all members, leaving any that fail set to CTF_ERR. 		 */
for|for
control|(
name|dmd
operator|=
name|ctf_list_next
argument_list|(
operator|&
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_members
argument_list|)
init|;
name|dmd
operator|!=
name|NULL
condition|;
name|dmd
operator|=
name|ctf_list_next
argument_list|(
name|dmd
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|dmd
operator|->
name|dmd_type
operator|=
name|ctf_add_type
argument_list|(
name|dst_fp
argument_list|,
name|src_fp
argument_list|,
name|dmd
operator|->
name|dmd_type
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
name|errs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|errs
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
comment|/* 		 * Now that we know that we can't fail, we go through and bump 		 * all the reference counts on the member types. 		 */
for|for
control|(
name|dmd
operator|=
name|ctf_list_next
argument_list|(
operator|&
name|dtd
operator|->
name|dtd_u
operator|.
name|dtu_members
argument_list|)
init|;
name|dmd
operator|!=
name|NULL
condition|;
name|dmd
operator|=
name|ctf_list_next
argument_list|(
name|dmd
argument_list|)
control|)
name|ctf_ref_inc
argument_list|(
name|dst_fp
argument_list|,
name|dmd
operator|->
name|dmd_type
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTF_K_ENUM
case|:
if|if
condition|(
name|dst_type
operator|!=
name|CTF_ERR
operator|&&
name|dst_kind
operator|!=
name|CTF_K_FORWARD
condition|)
block|{
if|if
condition|(
name|ctf_enum_iter
argument_list|(
name|src_fp
argument_list|,
name|src_type
argument_list|,
name|enumcmp
argument_list|,
operator|&
name|dst
argument_list|)
operator|||
name|ctf_enum_iter
argument_list|(
name|dst_fp
argument_list|,
name|dst_type
argument_list|,
name|enumcmp
argument_list|,
operator|&
name|src
argument_list|)
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|dst_fp
argument_list|,
name|ECTF_CONFLICT
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|dst_type
operator|=
name|ctf_add_enum
argument_list|(
name|dst_fp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|.
name|ctb_type
operator|=
name|dst_type
operator|)
operator|==
name|CTF_ERR
operator|||
name|ctf_enum_iter
argument_list|(
name|src_fp
argument_list|,
name|src_type
argument_list|,
name|enumadd
argument_list|,
operator|&
name|dst
argument_list|)
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
block|}
break|break;
case|case
name|CTF_K_FORWARD
case|:
if|if
condition|(
name|dst_type
operator|==
name|CTF_ERR
condition|)
block|{
name|dst_type
operator|=
name|ctf_add_forward
argument_list|(
name|dst_fp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|,
name|CTF_K_STRUCT
argument_list|)
expr_stmt|;
comment|/* assume STRUCT */
block|}
break|break;
case|case
name|CTF_K_TYPEDEF
case|:
name|src_type
operator|=
name|ctf_type_reference
argument_list|(
name|src_fp
argument_list|,
name|src_type
argument_list|)
expr_stmt|;
name|src_type
operator|=
name|ctf_add_type
argument_list|(
name|dst_fp
argument_list|,
name|src_fp
argument_list|,
name|src_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_type
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
comment|/* 		 * If dst_type is not CTF_ERR at this point, we should check if 		 * ctf_type_reference(dst_fp, dst_type) != src_type and if so 		 * fail with ECTF_CONFLICT.  However, this causes problems with 		 *<sys/types.h> typedefs that vary based on things like if 		 * _ILP32x then pid_t is int otherwise long.  We therefore omit 		 * this check and assume that if the identically named typedef 		 * already exists in dst_fp, it is correct or equivalent. 		 */
if|if
condition|(
name|dst_type
operator|==
name|CTF_ERR
condition|)
block|{
name|dst_type
operator|=
name|ctf_add_typedef
argument_list|(
name|dst_fp
argument_list|,
name|flag
argument_list|,
name|name
argument_list|,
name|src_type
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|dst_fp
argument_list|,
name|ECTF_CORRUPT
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|dst_type
operator|)
return|;
block|}
end_function

end_unit

