begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * The objective of this program is to provide a DMU/ZAP/SPA stress test  * that runs entirely in userland, is easy to use, and easy to extend.  *  * The overall design of the ztest program is as follows:  *  * (1) For each major functional area (e.g. adding vdevs to a pool,  *     creating and destroying datasets, reading and writing objects, etc)  *     we have a simple routine to test that functionality.  These  *     individual routines do not have to do anything "stressful".  *  * (2) We turn these simple functionality tests into a stress test by  *     running them all in parallel, with as many threads as desired,  *     and spread across as many datasets, objects, and vdevs as desired.  *  * (3) While all this is happening, we inject faults into the pool to  *     verify that self-healing data really works.  *  * (4) Every time we open a dataset, we change its checksum and compression  *     functions.  Thus even individual objects vary from block to block  *     in which checksum they use and whether they're compressed.  *  * (5) To verify that we never lose on-disk consistency after a crash,  *     we run the entire test in a child of the main process.  *     At random times, the child self-immolates with a SIGKILL.  *     This is the software equivalent of pulling the power cord.  *     The parent then runs the test again, using the existing  *     storage pool, as many times as desired.  *  * (6) To verify that we don't have future leaks or temporal incursions,  *     many of the functional tests record the transaction group number  *     as part of their data.  When reading old data, they verify that  *     the transaction group number is less than the current, open txg.  *     If you add a new test, please do this if applicable.  *  * When run with no arguments, ztest runs for about five minutes and  * produces no output if successful.  To get a little bit of information,  * specify -V.  To get more information, specify -VV, and so on.  *  * To turn this into an overnight stress test, use -T to specify run time.  *  * You can ask more more vdevs [-v], datasets [-d], or threads [-t]  * to increase the pool capacity, fanout, and overall stress level.  *  * The -N(okill) option will suppress kills, so each child runs to completion.  * This can be useful when you're trying to distinguish temporal incursions  * from plain old race conditions.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_compress.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_file.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdio_ext.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<umem.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_decl_stmt
specifier|static
name|char
name|cmdname
index|[]
init|=
literal|"ztest"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zopt_pool
init|=
name|cmdname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|zopt_vdevs
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|zopt_vdevtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zopt_ashift
init|=
name|SPA_MINBLOCKSHIFT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zopt_mirrors
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zopt_raidz
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zopt_raidz_parity
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|zopt_vdev_size
init|=
name|SPA_MINDEVSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zopt_datasets
init|=
literal|7
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zopt_threads
init|=
literal|23
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|zopt_passtime
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 60 seconds */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|zopt_killrate
init|=
literal|70
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 70% kill rate */
end_comment

begin_decl_stmt
specifier|static
name|int
name|zopt_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zopt_init
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zopt_dir
init|=
literal|"/tmp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|zopt_time
init|=
literal|300
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 5 minutes */
end_comment

begin_decl_stmt
specifier|static
name|int
name|zopt_maxfaults
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|ztest_block_tag
block|{
name|uint64_t
name|bt_objset
decl_stmt|;
name|uint64_t
name|bt_object
decl_stmt|;
name|uint64_t
name|bt_offset
decl_stmt|;
name|uint64_t
name|bt_txg
decl_stmt|;
name|uint64_t
name|bt_thread
decl_stmt|;
name|uint64_t
name|bt_seq
decl_stmt|;
block|}
name|ztest_block_tag_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ztest_args
block|{
name|char
name|za_pool
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|spa_t
modifier|*
name|za_spa
decl_stmt|;
name|objset_t
modifier|*
name|za_os
decl_stmt|;
name|zilog_t
modifier|*
name|za_zilog
decl_stmt|;
name|thread_t
name|za_thread
decl_stmt|;
name|uint64_t
name|za_instance
decl_stmt|;
name|uint64_t
name|za_random
decl_stmt|;
name|uint64_t
name|za_diroff
decl_stmt|;
name|uint64_t
name|za_diroff_shared
decl_stmt|;
name|uint64_t
name|za_zil_seq
decl_stmt|;
name|hrtime_t
name|za_start
decl_stmt|;
name|hrtime_t
name|za_stop
decl_stmt|;
name|hrtime_t
name|za_kill
decl_stmt|;
comment|/* 	 * Thread-local variables can go here to aid debugging. 	 */
name|ztest_block_tag_t
name|za_rbt
decl_stmt|;
name|ztest_block_tag_t
name|za_wbt
decl_stmt|;
name|dmu_object_info_t
name|za_doi
decl_stmt|;
name|dmu_buf_t
modifier|*
name|za_dbuf
decl_stmt|;
block|}
name|ztest_args_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
name|ztest_func_t
parameter_list|(
name|ztest_args_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * Note: these aren't static because we want dladdr() to work.  */
end_comment

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_read_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_read_write_zcopy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_write_parallel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_object_alloc_free
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_zap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_fzap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_zap_parallel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_traverse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dsl_prop_get_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_objset_create_destroy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_snapshot_create_destroy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dsl_dataset_promote_busy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_spa_create_destroy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_fault_inject
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_spa_rename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_vdev_attach_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_vdev_LUN_growth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_vdev_add_remove
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_vdev_aux_add_remove
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_scrub
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|ztest_info
block|{
name|ztest_func_t
modifier|*
name|zi_func
decl_stmt|;
comment|/* test function */
name|uint64_t
name|zi_iters
decl_stmt|;
comment|/* iterations per execution */
name|uint64_t
modifier|*
name|zi_interval
decl_stmt|;
comment|/* execute every<interval> seconds */
name|uint64_t
name|zi_calls
decl_stmt|;
comment|/* per-pass count */
name|uint64_t
name|zi_call_time
decl_stmt|;
comment|/* per-pass time */
name|uint64_t
name|zi_call_total
decl_stmt|;
comment|/* cumulative total */
name|uint64_t
name|zi_call_target
decl_stmt|;
comment|/* target cumulative total */
block|}
name|ztest_info_t
typedef|;
end_typedef

begin_decl_stmt
name|uint64_t
name|zopt_always
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* all the time */
end_comment

begin_decl_stmt
name|uint64_t
name|zopt_often
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* every second */
end_comment

begin_decl_stmt
name|uint64_t
name|zopt_sometimes
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* every 10 seconds */
end_comment

begin_decl_stmt
name|uint64_t
name|zopt_rarely
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* every 60 seconds */
end_comment

begin_decl_stmt
name|ztest_info_t
name|ztest_info
index|[]
init|=
block|{
block|{
name|ztest_dmu_read_write
block|,
literal|1
block|,
operator|&
name|zopt_always
block|}
block|,
block|{
name|ztest_dmu_read_write_zcopy
block|,
literal|1
block|,
operator|&
name|zopt_always
block|}
block|,
block|{
name|ztest_dmu_write_parallel
block|,
literal|30
block|,
operator|&
name|zopt_always
block|}
block|,
block|{
name|ztest_dmu_object_alloc_free
block|,
literal|1
block|,
operator|&
name|zopt_always
block|}
block|,
block|{
name|ztest_zap
block|,
literal|30
block|,
operator|&
name|zopt_always
block|}
block|,
block|{
name|ztest_fzap
block|,
literal|30
block|,
operator|&
name|zopt_always
block|}
block|,
block|{
name|ztest_zap_parallel
block|,
literal|100
block|,
operator|&
name|zopt_always
block|}
block|,
block|{
name|ztest_dsl_prop_get_set
block|,
literal|1
block|,
operator|&
name|zopt_sometimes
block|}
block|,
block|{
name|ztest_dmu_objset_create_destroy
block|,
literal|1
block|,
operator|&
name|zopt_sometimes
block|}
block|,
block|{
name|ztest_dmu_snapshot_create_destroy
block|,
literal|1
block|,
operator|&
name|zopt_sometimes
block|}
block|,
block|{
name|ztest_spa_create_destroy
block|,
literal|1
block|,
operator|&
name|zopt_sometimes
block|}
block|,
block|{
name|ztest_fault_inject
block|,
literal|1
block|,
operator|&
name|zopt_sometimes
block|}
block|,
block|{
name|ztest_spa_rename
block|,
literal|1
block|,
operator|&
name|zopt_rarely
block|}
block|,
block|{
name|ztest_vdev_attach_detach
block|,
literal|1
block|,
operator|&
name|zopt_rarely
block|}
block|,
block|{
name|ztest_vdev_LUN_growth
block|,
literal|1
block|,
operator|&
name|zopt_rarely
block|}
block|,
block|{
name|ztest_dsl_dataset_promote_busy
block|,
literal|1
block|,
operator|&
name|zopt_rarely
block|}
block|,
block|{
name|ztest_vdev_add_remove
block|,
literal|1
block|,
operator|&
name|zopt_vdevtime
block|}
block|,
block|{
name|ztest_vdev_aux_add_remove
block|,
literal|1
block|,
operator|&
name|zopt_vdevtime
block|}
block|,
block|{
name|ztest_scrub
block|,
literal|1
block|,
operator|&
name|zopt_vdevtime
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ZTEST_FUNCS
value|(sizeof (ztest_info) / sizeof (ztest_info_t))
end_define

begin_define
define|#
directive|define
name|ZTEST_SYNC_LOCKS
value|16
end_define

begin_comment
comment|/*  * Stuff we need to share writably between parent and child.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ztest_shared
block|{
name|mutex_t
name|zs_vdev_lock
decl_stmt|;
name|rwlock_t
name|zs_name_lock
decl_stmt|;
name|uint64_t
name|zs_vdev_primaries
decl_stmt|;
name|uint64_t
name|zs_vdev_aux
decl_stmt|;
name|uint64_t
name|zs_enospc_count
decl_stmt|;
name|hrtime_t
name|zs_start_time
decl_stmt|;
name|hrtime_t
name|zs_stop_time
decl_stmt|;
name|uint64_t
name|zs_alloc
decl_stmt|;
name|uint64_t
name|zs_space
decl_stmt|;
name|ztest_info_t
name|zs_info
index|[
name|ZTEST_FUNCS
index|]
decl_stmt|;
name|mutex_t
name|zs_sync_lock
index|[
name|ZTEST_SYNC_LOCKS
index|]
decl_stmt|;
name|uint64_t
name|zs_seq
index|[
name|ZTEST_SYNC_LOCKS
index|]
decl_stmt|;
block|}
name|ztest_shared_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
name|ztest_dev_template
index|[]
init|=
literal|"%s/%s.%llua"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ztest_aux_template
index|[]
init|=
literal|"%s/%s.%s.%llu"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ztest_shared_t
modifier|*
name|ztest_shared
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ztest_random_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ztest_dump_core
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|metaslab_sz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean_t
name|ztest_exiting
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|uint64_t
name|metaslab_gang_bang
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|uint64_t
name|metaslab_df_alloc_threshold
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ZTEST_DIROBJ
value|1
end_define

begin_define
define|#
directive|define
name|ZTEST_MICROZAP_OBJ
value|2
end_define

begin_define
define|#
directive|define
name|ZTEST_FATZAP_OBJ
value|3
end_define

begin_define
define|#
directive|define
name|ZTEST_DIROBJ_BLOCKSIZE
value|(1<< 10)
end_define

begin_define
define|#
directive|define
name|ZTEST_DIRSIZE
value|256
end_define

begin_decl_stmt
specifier|static
name|void
name|usage
argument_list|(
name|boolean_t
argument_list|)
name|__NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These libumem hooks provide a reasonable set of defaults for the allocator's  * debugging facilities.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|_umem_debug_init
parameter_list|()
block|{
return|return
operator|(
literal|"default,verbose"
operator|)
return|;
comment|/* $UMEM_DEBUG setting */
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|_umem_logging_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|"fail,contents"
operator|)
return|;
comment|/* $UMEM_LOGGING setting */
block|}
end_function

begin_define
define|#
directive|define
name|FATAL_MSG_SZ
value|1024
end_define

begin_decl_stmt
name|char
modifier|*
name|fatal_msg
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|fatal
parameter_list|(
name|int
name|do_perror
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|char
name|buf
index|[
name|FATAL_MSG_SZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|message
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"ztest: "
argument_list|)
expr_stmt|;
comment|/* LINTED */
operator|(
name|void
operator|)
name|vsprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_perror
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|FATAL_MSG_SZ
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|": %s"
argument_list|,
name|strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fatal_msg
operator|=
name|buf
expr_stmt|;
comment|/* to ease debugging */
if|if
condition|(
name|ztest_dump_core
condition|)
name|abort
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|str2shift
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ends
init|=
literal|"BKMGTPEZ"
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|ends
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|toupper
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
operator|==
name|ends
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|strlen
argument_list|(
name|ends
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ztest: invalid bytes suffix: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|toupper
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'B'
operator|&&
name|buf
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
return|return
operator|(
literal|10
operator|*
name|i
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ztest: invalid bytes suffix: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|nicenumtoull
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|strtoull
argument_list|(
name|buf
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|buf
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ztest: bad numeric value: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|double
name|fval
init|=
name|strtod
argument_list|(
name|buf
argument_list|,
operator|&
name|end
argument_list|)
decl_stmt|;
name|fval
operator|*=
name|pow
argument_list|(
literal|2
argument_list|,
name|str2shift
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fval
operator|>
name|UINT64_MAX
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ztest: value too large: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
operator|(
name|uint64_t
operator|)
name|fval
expr_stmt|;
block|}
else|else
block|{
name|int
name|shift
init|=
name|str2shift
argument_list|(
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|shift
operator|>=
literal|64
operator|||
operator|(
name|val
operator|<<
name|shift
operator|)
operator|>>
name|shift
operator|!=
name|val
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ztest: value too large: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|val
operator|<<=
name|shift
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|boolean_t
name|requested
parameter_list|)
block|{
name|char
name|nice_vdev_size
index|[
literal|10
index|]
decl_stmt|;
name|char
name|nice_gang_bang
index|[
literal|10
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|requested
condition|?
name|stdout
else|:
name|stderr
decl_stmt|;
name|nicenum
argument_list|(
name|zopt_vdev_size
argument_list|,
name|nice_vdev_size
argument_list|)
expr_stmt|;
name|nicenum
argument_list|(
name|metaslab_gang_bang
argument_list|,
name|nice_gang_bang
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Usage: %s\n"
literal|"\t[-v vdevs (default: %llu)]\n"
literal|"\t[-s size_of_each_vdev (default: %s)]\n"
literal|"\t[-a alignment_shift (default: %d) (use 0 for random)]\n"
literal|"\t[-m mirror_copies (default: %d)]\n"
literal|"\t[-r raidz_disks (default: %d)]\n"
literal|"\t[-R raidz_parity (default: %d)]\n"
literal|"\t[-d datasets (default: %d)]\n"
literal|"\t[-t threads (default: %d)]\n"
literal|"\t[-g gang_block_threshold (default: %s)]\n"
literal|"\t[-i initialize pool i times (default: %d)]\n"
literal|"\t[-k kill percentage (default: %llu%%)]\n"
literal|"\t[-p pool_name (default: %s)]\n"
literal|"\t[-f file directory for vdev files (default: %s)]\n"
literal|"\t[-V(erbose)] (use multiple times for ever more blather)\n"
literal|"\t[-E(xisting)] (use existing pool instead of creating new one)\n"
literal|"\t[-T time] total run time (default: %llu sec)\n"
literal|"\t[-P passtime] time per pass (default: %llu sec)\n"
literal|"\t[-h] (print help)\n"
literal|""
argument_list|,
name|cmdname
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zopt_vdevs
argument_list|,
comment|/* -v */
name|nice_vdev_size
argument_list|,
comment|/* -s */
name|zopt_ashift
argument_list|,
comment|/* -a */
name|zopt_mirrors
argument_list|,
comment|/* -m */
name|zopt_raidz
argument_list|,
comment|/* -r */
name|zopt_raidz_parity
argument_list|,
comment|/* -R */
name|zopt_datasets
argument_list|,
comment|/* -d */
name|zopt_threads
argument_list|,
comment|/* -t */
name|nice_gang_bang
argument_list|,
comment|/* -g */
name|zopt_init
argument_list|,
comment|/* -i */
operator|(
name|u_longlong_t
operator|)
name|zopt_killrate
argument_list|,
comment|/* -k */
name|zopt_pool
argument_list|,
comment|/* -p */
name|zopt_dir
argument_list|,
comment|/* -f */
operator|(
name|u_longlong_t
operator|)
name|zopt_time
argument_list|,
comment|/* -T */
operator|(
name|u_longlong_t
operator|)
name|zopt_passtime
argument_list|)
expr_stmt|;
comment|/* -P */
name|exit
argument_list|(
name|requested
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ztest_random
parameter_list|(
name|uint64_t
name|range
parameter_list|)
block|{
name|uint64_t
name|r
decl_stmt|;
if|if
condition|(
name|range
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|read
argument_list|(
name|ztest_random_fd
argument_list|,
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|r
argument_list|)
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"short read from /dev/urandom"
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|%
name|range
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|ztest_record_enospc
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|ztest_shared
operator|->
name|zs_enospc_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_options
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|opt
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
comment|/* Remember program name. */
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* By default, test gang blocks for blocks 32K and greater */
name|metaslab_gang_bang
operator|=
literal|32
operator|<<
literal|10
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"v:s:a:m:r:R:d:t:g:i:k:p:f:VET:P:h"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|value
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'v'
case|:
case|case
literal|'s'
case|:
case|case
literal|'a'
case|:
case|case
literal|'m'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
case|case
literal|'d'
case|:
case|case
literal|'t'
case|:
case|case
literal|'g'
case|:
case|case
literal|'i'
case|:
case|case
literal|'k'
case|:
case|case
literal|'T'
case|:
case|case
literal|'P'
case|:
name|value
operator|=
name|nicenumtoull
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'v'
case|:
name|zopt_vdevs
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|zopt_vdev_size
operator|=
name|MAX
argument_list|(
name|SPA_MINDEVSIZE
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|zopt_ashift
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|zopt_mirrors
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|zopt_raidz
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|zopt_raidz_parity
operator|=
name|MIN
argument_list|(
name|MAX
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|zopt_datasets
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|zopt_threads
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|metaslab_gang_bang
operator|=
name|MAX
argument_list|(
name|SPA_MINBLOCKSIZE
operator|<<
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|zopt_init
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|zopt_killrate
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|zopt_pool
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|zopt_dir
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|zopt_verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|zopt_init
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|zopt_time
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|zopt_passtime
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|B_TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|zopt_raidz_parity
operator|=
name|MIN
argument_list|(
name|zopt_raidz_parity
argument_list|,
name|zopt_raidz
operator|-
literal|1
argument_list|)
expr_stmt|;
name|zopt_vdevtime
operator|=
operator|(
name|zopt_vdevs
operator|>
literal|0
condition|?
name|zopt_time
operator|/
name|zopt_vdevs
else|:
name|UINT64_MAX
operator|)
expr_stmt|;
name|zopt_maxfaults
operator|=
name|MAX
argument_list|(
name|zopt_mirrors
argument_list|,
literal|1
argument_list|)
operator|*
operator|(
name|zopt_raidz_parity
operator|+
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ztest_get_ashift
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|zopt_ashift
operator|==
literal|0
condition|)
return|return
operator|(
name|SPA_MINBLOCKSHIFT
operator|+
name|ztest_random
argument_list|(
literal|3
argument_list|)
operator|)
return|;
return|return
operator|(
name|zopt_ashift
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|nvlist_t
modifier|*
name|make_vdev_file
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|aux
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|ashift
parameter_list|)
block|{
name|char
name|pathbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|uint64_t
name|vdev
decl_stmt|;
name|nvlist_t
modifier|*
name|file
decl_stmt|;
if|if
condition|(
name|ashift
operator|==
literal|0
condition|)
name|ashift
operator|=
name|ztest_get_ashift
argument_list|()
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|path
operator|=
name|pathbuf
expr_stmt|;
if|if
condition|(
name|aux
operator|!=
name|NULL
condition|)
block|{
name|vdev
operator|=
name|ztest_shared
operator|->
name|zs_vdev_aux
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
name|ztest_aux_template
argument_list|,
name|zopt_dir
argument_list|,
name|zopt_pool
argument_list|,
name|aux
argument_list|,
name|vdev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vdev
operator|=
name|ztest_shared
operator|->
name|zs_vdev_primaries
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
name|ztest_dev_template
argument_list|,
name|zopt_dir
argument_list|,
name|zopt_pool
argument_list|,
name|vdev
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"can't open %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"can't ftruncate %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|file
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|file
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_FILE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|file
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|file
argument_list|,
name|ZPOOL_CONFIG_ASHIFT
argument_list|,
name|ashift
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|nvlist_t
modifier|*
name|make_vdev_raidz
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|aux
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|ashift
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|raidz
decl_stmt|,
modifier|*
modifier|*
name|child
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|2
condition|)
return|return
operator|(
name|make_vdev_file
argument_list|(
name|path
argument_list|,
name|aux
argument_list|,
name|size
argument_list|,
name|ashift
argument_list|)
operator|)
return|;
name|child
operator|=
name|umem_alloc
argument_list|(
name|r
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|r
condition|;
name|c
operator|++
control|)
name|child
index|[
name|c
index|]
operator|=
name|make_vdev_file
argument_list|(
name|path
argument_list|,
name|aux
argument_list|,
name|size
argument_list|,
name|ashift
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|raidz
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|raidz
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|raidz
argument_list|,
name|ZPOOL_CONFIG_NPARITY
argument_list|,
name|zopt_raidz_parity
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|raidz
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|child
argument_list|,
name|r
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|r
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|child
argument_list|,
name|r
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|raidz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|nvlist_t
modifier|*
name|make_vdev_mirror
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|aux
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|ashift
parameter_list|,
name|int
name|r
parameter_list|,
name|int
name|m
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|mirror
decl_stmt|,
modifier|*
modifier|*
name|child
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|m
operator|<
literal|1
condition|)
return|return
operator|(
name|make_vdev_raidz
argument_list|(
name|path
argument_list|,
name|aux
argument_list|,
name|size
argument_list|,
name|ashift
argument_list|,
name|r
argument_list|)
operator|)
return|;
name|child
operator|=
name|umem_alloc
argument_list|(
name|m
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|m
condition|;
name|c
operator|++
control|)
name|child
index|[
name|c
index|]
operator|=
name|make_vdev_raidz
argument_list|(
name|path
argument_list|,
name|aux
argument_list|,
name|size
argument_list|,
name|ashift
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|mirror
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|mirror
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_MIRROR
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|mirror
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|child
argument_list|,
name|m
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|m
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|child
argument_list|,
name|m
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|mirror
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|nvlist_t
modifier|*
name|make_vdev_root
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|aux
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|ashift
parameter_list|,
name|int
name|log
parameter_list|,
name|int
name|r
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|t
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|root
decl_stmt|,
modifier|*
modifier|*
name|child
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ASSERT
argument_list|(
name|t
operator|>
literal|0
argument_list|)
expr_stmt|;
name|child
operator|=
name|umem_alloc
argument_list|(
name|t
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|t
condition|;
name|c
operator|++
control|)
block|{
name|child
index|[
name|c
index|]
operator|=
name|make_vdev_mirror
argument_list|(
name|path
argument_list|,
name|aux
argument_list|,
name|size
argument_list|,
name|ashift
argument_list|,
name|r
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
name|log
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|root
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|root
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_ROOT
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|root
argument_list|,
name|aux
condition|?
name|aux
else|:
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|child
argument_list|,
name|t
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|t
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|child
argument_list|,
name|t
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|root
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_set_random_blocksize
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|bs
init|=
name|SPA_MINBLOCKSHIFT
operator|+
name|ztest_random
argument_list|(
name|SPA_MAXBLOCKSHIFT
operator|-
name|SPA_MINBLOCKSHIFT
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|ibs
init|=
name|DN_MIN_INDBLKSHIFT
operator|+
name|ztest_random
argument_list|(
name|DN_MAX_INDBLKSHIFT
operator|-
name|DN_MIN_INDBLKSHIFT
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dmu_object_set_blocksize
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
literal|1ULL
operator|<<
name|bs
argument_list|,
name|ibs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|char
name|osname
index|[
literal|300
index|]
decl_stmt|;
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|osname
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_object_set_blocksize('%s', %llu, %d, %d) = %d"
argument_list|,
name|osname
argument_list|,
name|object
argument_list|,
literal|1
operator|<<
name|bs
argument_list|,
name|ibs
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|ztest_random_checksum
parameter_list|(
name|void
parameter_list|)
block|{
name|uint8_t
name|checksum
decl_stmt|;
do|do
block|{
name|checksum
operator|=
name|ztest_random
argument_list|(
name|ZIO_CHECKSUM_FUNCTIONS
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|zio_checksum_table
index|[
name|checksum
index|]
operator|.
name|ci_zbt
condition|)
do|;
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_OFF
condition|)
name|checksum
operator|=
name|ZIO_CHECKSUM_ON
expr_stmt|;
return|return
operator|(
name|checksum
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|ztest_random_compress
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|uint8_t
operator|)
name|ztest_random
argument_list|(
name|ZIO_COMPRESS_FUNCTIONS
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_replay_create
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|lr_create_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|dmu_object_claim
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_doid
argument_list|,
name|lr
operator|->
name|lr_mode
argument_list|,
literal|0
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|5
condition|)
block|{
name|char
name|osname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|osname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"replay create of %s object %llu"
literal|" in txg %llu = %d\n"
argument_list|,
name|osname
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|lr
operator|->
name|lr_doid
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_replay_remove
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|lr_remove_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|lr
operator|->
name|lr_doid
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|dmu_object_free
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_doid
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|zil_replay_func_t
modifier|*
name|ztest_replay_vector
index|[
name|TX_MAX_TYPE
index|]
init|=
block|{
name|NULL
block|,
comment|/* 0 no such transaction type */
name|ztest_replay_create
block|,
comment|/* TX_CREATE */
name|NULL
block|,
comment|/* TX_MKDIR */
name|NULL
block|,
comment|/* TX_MKXATTR */
name|NULL
block|,
comment|/* TX_SYMLINK */
name|ztest_replay_remove
block|,
comment|/* TX_REMOVE */
name|NULL
block|,
comment|/* TX_RMDIR */
name|NULL
block|,
comment|/* TX_LINK */
name|NULL
block|,
comment|/* TX_RENAME */
name|NULL
block|,
comment|/* TX_WRITE */
name|NULL
block|,
comment|/* TX_TRUNCATE */
name|NULL
block|,
comment|/* TX_SETATTR */
name|NULL
block|,
comment|/* TX_ACL */
name|NULL
block|,
comment|/* TX_CREATE_ACL */
name|NULL
block|,
comment|/* TX_CREATE_ATTR */
name|NULL
block|,
comment|/* TX_CREATE_ACL_ATTR */
name|NULL
block|,
comment|/* TX_MKDIR_ACL */
name|NULL
block|,
comment|/* TX_MKDIR_ATTR */
name|NULL
block|,
comment|/* TX_MKDIR_ACL_ATTR */
name|NULL
block|,
comment|/* TX_WRITE2 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Verify that we can't destroy an active pool, create an existing pool,  * or create a pool with a bad vdev spec.  */
end_comment

begin_function
name|void
name|ztest_spa_create_destroy
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
comment|/* 	 * Attempt to create using a bad file. 	 */
name|nvroot
operator|=
name|make_vdev_root
argument_list|(
literal|"/dev/bogus"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_create
argument_list|(
literal|"ztest_bad_file"
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_create(bad_file) = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to create using a bad mirror. 	 */
name|nvroot
operator|=
name|make_vdev_root
argument_list|(
literal|"/dev/bogus"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_create
argument_list|(
literal|"ztest_bad_mirror"
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_create(bad_mirror) = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to create an existing pool.  It shouldn't matter 	 * what's in the nvroot; we should fail with EEXIST. 	 */
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
name|nvroot
operator|=
name|make_vdev_root
argument_list|(
literal|"/dev/bogus"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_create
argument_list|(
name|za
operator|->
name|za_pool
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EEXIST
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_create(whatever) = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_open
argument_list|(
name|za
operator|->
name|za_pool
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_open() = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_destroy
argument_list|(
name|za
operator|->
name|za_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EBUSY
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_destroy() = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vdev_t
modifier|*
name|vdev_lookup_by_path
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|vdev_t
modifier|*
name|mvd
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_path
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|path
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|vd
operator|)
return|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|mvd
operator|=
name|vdev_lookup_by_path
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|mvd
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that vdev_add() works as expected.  */
end_comment

begin_function
name|void
name|ztest_vdev_add_remove
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|za
operator|->
name|za_spa
decl_stmt|;
name|uint64_t
name|leaves
init|=
name|MAX
argument_list|(
name|zopt_mirrors
argument_list|,
literal|1
argument_list|)
operator|*
name|zopt_raidz
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_vdev_lock
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|ztest_shared
operator|->
name|zs_vdev_primaries
operator|=
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_children
operator|*
name|leaves
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Make 1/4 of the devices be log devices. 	 */
name|nvroot
operator|=
name|make_vdev_root
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|zopt_vdev_size
argument_list|,
literal|0
argument_list|,
name|ztest_random
argument_list|(
literal|4
argument_list|)
operator|==
literal|0
argument_list|,
name|zopt_raidz
argument_list|,
name|zopt_mirrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_vdev_add
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_vdev_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
name|ztest_record_enospc
argument_list|(
literal|"spa_vdev_add"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_vdev_add() = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that adding/removing aux devices (l2arc, hot spare) works as expected.  */
end_comment

begin_function
name|void
name|ztest_vdev_aux_add_remove
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|za
operator|->
name|za_spa
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|spa_aux_vdev_t
modifier|*
name|sav
decl_stmt|;
name|char
modifier|*
name|aux
decl_stmt|;
name|uint64_t
name|guid
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sav
operator|=
operator|&
name|spa
operator|->
name|spa_spares
expr_stmt|;
name|aux
operator|=
name|ZPOOL_CONFIG_SPARES
expr_stmt|;
block|}
else|else
block|{
name|sav
operator|=
operator|&
name|spa
operator|->
name|spa_l2cache
expr_stmt|;
name|aux
operator|=
name|ZPOOL_CONFIG_L2CACHE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_vdev_lock
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|sav_count
operator|!=
literal|0
operator|&&
name|ztest_random
argument_list|(
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Pick a random device to remove. 		 */
name|guid
operator|=
name|sav
operator|->
name|sav_vdevs
index|[
name|ztest_random
argument_list|(
name|sav
operator|->
name|sav_count
argument_list|)
index|]
operator|->
name|vdev_guid
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Find an unused device we can add. 		 */
name|ztest_shared
operator|->
name|zs_vdev_aux
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
name|ztest_aux_template
argument_list|,
name|zopt_dir
argument_list|,
name|zopt_pool
argument_list|,
name|aux
argument_list|,
name|ztest_shared
operator|->
name|zs_vdev_aux
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sav
operator|->
name|sav_vdevs
index|[
name|c
index|]
operator|->
name|vdev_path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|sav
operator|->
name|sav_count
operator|&&
name|vdev_lookup_by_path
argument_list|(
name|rvd
argument_list|,
name|path
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|ztest_shared
operator|->
name|zs_vdev_aux
operator|++
expr_stmt|;
block|}
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Add a new device. 		 */
name|nvlist_t
modifier|*
name|nvroot
init|=
name|make_vdev_root
argument_list|(
name|NULL
argument_list|,
name|aux
argument_list|,
operator|(
name|zopt_vdev_size
operator|*
literal|5
operator|)
operator|/
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|error
operator|=
name|spa_vdev_add
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_vdev_add(%p) = %d"
argument_list|,
name|nvroot
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Remove an existing device.  Sometimes, dirty its 		 * vdev state first to make sure we handle removal 		 * of devices that have pending state changes. 		 */
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|vdev_online
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_vdev_remove
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EBUSY
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_vdev_remove(%llu) = %d"
argument_list|,
name|guid
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_vdev_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that we can attach and detach devices.  */
end_comment

begin_function
name|void
name|ztest_vdev_attach_detach
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|za
operator|->
name|za_spa
decl_stmt|;
name|spa_aux_vdev_t
modifier|*
name|sav
init|=
operator|&
name|spa
operator|->
name|spa_spares
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|oldvd
decl_stmt|,
modifier|*
name|newvd
decl_stmt|,
modifier|*
name|pvd
decl_stmt|;
name|nvlist_t
modifier|*
name|root
decl_stmt|;
name|uint64_t
name|leaves
init|=
name|MAX
argument_list|(
name|zopt_mirrors
argument_list|,
literal|1
argument_list|)
operator|*
name|zopt_raidz
decl_stmt|;
name|uint64_t
name|leaf
decl_stmt|,
name|top
decl_stmt|;
name|uint64_t
name|ashift
init|=
name|ztest_get_ashift
argument_list|()
decl_stmt|;
name|uint64_t
name|oldguid
decl_stmt|,
name|pguid
decl_stmt|;
name|size_t
name|oldsize
decl_stmt|,
name|newsize
decl_stmt|;
name|char
name|oldpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|newpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|replacing
decl_stmt|;
name|int
name|oldvd_has_siblings
init|=
name|B_FALSE
decl_stmt|;
name|int
name|newvd_is_spare
init|=
name|B_FALSE
decl_stmt|;
name|int
name|oldvd_is_log
decl_stmt|;
name|int
name|error
decl_stmt|,
name|expected_error
decl_stmt|;
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_vdev_lock
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
comment|/* 	 * Decide whether to do an attach or a replace. 	 */
name|replacing
operator|=
name|ztest_random
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Pick a random top-level vdev. 	 */
name|top
operator|=
name|ztest_random
argument_list|(
name|rvd
operator|->
name|vdev_children
argument_list|)
expr_stmt|;
comment|/* 	 * Pick a random leaf within it. 	 */
name|leaf
operator|=
name|ztest_random
argument_list|(
name|leaves
argument_list|)
expr_stmt|;
comment|/* 	 * Locate this vdev. 	 */
name|oldvd
operator|=
name|rvd
operator|->
name|vdev_child
index|[
name|top
index|]
expr_stmt|;
if|if
condition|(
name|zopt_mirrors
operator|>=
literal|1
condition|)
block|{
name|ASSERT
argument_list|(
name|oldvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_mirror_ops
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|oldvd
operator|->
name|vdev_children
operator|>=
name|zopt_mirrors
argument_list|)
expr_stmt|;
name|oldvd
operator|=
name|oldvd
operator|->
name|vdev_child
index|[
name|leaf
operator|/
name|zopt_raidz
index|]
expr_stmt|;
block|}
if|if
condition|(
name|zopt_raidz
operator|>
literal|1
condition|)
block|{
name|ASSERT
argument_list|(
name|oldvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_raidz_ops
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|oldvd
operator|->
name|vdev_children
operator|==
name|zopt_raidz
argument_list|)
expr_stmt|;
name|oldvd
operator|=
name|oldvd
operator|->
name|vdev_child
index|[
name|leaf
operator|%
name|zopt_raidz
index|]
expr_stmt|;
block|}
comment|/* 	 * If we're already doing an attach or replace, oldvd may be a 	 * mirror vdev -- in which case, pick a random child. 	 */
while|while
condition|(
name|oldvd
operator|->
name|vdev_children
operator|!=
literal|0
condition|)
block|{
name|oldvd_has_siblings
operator|=
name|B_TRUE
expr_stmt|;
name|ASSERT
argument_list|(
name|oldvd
operator|->
name|vdev_children
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|oldvd
operator|=
name|oldvd
operator|->
name|vdev_child
index|[
name|ztest_random
argument_list|(
name|oldvd
operator|->
name|vdev_children
argument_list|)
index|]
expr_stmt|;
block|}
name|oldguid
operator|=
name|oldvd
operator|->
name|vdev_guid
expr_stmt|;
name|oldsize
operator|=
name|vdev_get_rsize
argument_list|(
name|oldvd
argument_list|)
expr_stmt|;
name|oldvd_is_log
operator|=
name|oldvd
operator|->
name|vdev_top
operator|->
name|vdev_islog
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|oldpath
argument_list|,
name|oldvd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|pvd
operator|=
name|oldvd
operator|->
name|vdev_parent
expr_stmt|;
name|pguid
operator|=
name|pvd
operator|->
name|vdev_guid
expr_stmt|;
comment|/* 	 * If oldvd has siblings, then half of the time, detach it. 	 */
if|if
condition|(
name|oldvd_has_siblings
operator|&&
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_vdev_detach
argument_list|(
name|spa
argument_list|,
name|oldguid
argument_list|,
name|pguid
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENODEV
operator|&&
name|error
operator|!=
name|EBUSY
operator|&&
name|error
operator|!=
name|ENOTSUP
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"detach (%s) returned %d"
argument_list|,
name|oldpath
argument_list|,
name|error
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_vdev_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * For the new vdev, choose with equal probability between the two 	 * standard paths (ending in either 'a' or 'b') or a random hot spare. 	 */
if|if
condition|(
name|sav
operator|->
name|sav_count
operator|!=
literal|0
operator|&&
name|ztest_random
argument_list|(
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newvd
operator|=
name|sav
operator|->
name|sav_vdevs
index|[
name|ztest_random
argument_list|(
name|sav
operator|->
name|sav_count
argument_list|)
index|]
expr_stmt|;
name|newvd_is_spare
operator|=
name|B_TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|newvd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|newpath
argument_list|,
sizeof|sizeof
argument_list|(
name|newpath
argument_list|)
argument_list|,
name|ztest_dev_template
argument_list|,
name|zopt_dir
argument_list|,
name|zopt_pool
argument_list|,
name|top
operator|*
name|leaves
operator|+
name|leaf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|newpath
index|[
name|strlen
argument_list|(
name|newpath
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'b'
expr_stmt|;
name|newvd
operator|=
name|vdev_lookup_by_path
argument_list|(
name|rvd
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newvd
condition|)
block|{
name|newsize
operator|=
name|vdev_get_rsize
argument_list|(
name|newvd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Make newsize a little bigger or smaller than oldsize. 		 * If it's smaller, the attach should fail. 		 * If it's larger, and we're doing a replace, 		 * we should get dynamic LUN growth when we're done. 		 */
name|newsize
operator|=
literal|10
operator|*
name|oldsize
operator|/
operator|(
literal|9
operator|+
name|ztest_random
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* 	 * If pvd is not a mirror or root, the attach should fail with ENOTSUP, 	 * unless it's a replace; in that case any non-replacing parent is OK. 	 * 	 * If newvd is already part of the pool, it should fail with EBUSY. 	 * 	 * If newvd is too small, it should fail with EOVERFLOW. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_mirror_ops
operator|&&
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_root_ops
operator|&&
operator|(
operator|!
name|replacing
operator|||
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
operator|||
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|)
condition|)
name|expected_error
operator|=
name|ENOTSUP
expr_stmt|;
elseif|else
if|if
condition|(
name|newvd_is_spare
operator|&&
operator|(
operator|!
name|replacing
operator|||
name|oldvd_is_log
operator|)
condition|)
name|expected_error
operator|=
name|ENOTSUP
expr_stmt|;
elseif|else
if|if
condition|(
name|newvd
operator|==
name|oldvd
condition|)
name|expected_error
operator|=
name|replacing
condition|?
literal|0
else|:
name|EBUSY
expr_stmt|;
elseif|else
if|if
condition|(
name|vdev_lookup_by_path
argument_list|(
name|rvd
argument_list|,
name|newpath
argument_list|)
operator|!=
name|NULL
condition|)
name|expected_error
operator|=
name|EBUSY
expr_stmt|;
elseif|else
if|if
condition|(
name|newsize
operator|<
name|oldsize
condition|)
name|expected_error
operator|=
name|EOVERFLOW
expr_stmt|;
elseif|else
if|if
condition|(
name|ashift
operator|>
name|oldvd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
condition|)
name|expected_error
operator|=
name|EDOM
expr_stmt|;
else|else
name|expected_error
operator|=
literal|0
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Build the nvlist describing newpath. 	 */
name|root
operator|=
name|make_vdev_root
argument_list|(
name|newpath
argument_list|,
name|NULL
argument_list|,
name|newvd
operator|==
name|NULL
condition|?
name|newsize
else|:
literal|0
argument_list|,
name|ashift
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_vdev_attach
argument_list|(
name|spa
argument_list|,
name|oldguid
argument_list|,
name|root
argument_list|,
name|replacing
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|/* 	 * If our parent was the replacing vdev, but the replace completed, 	 * then instead of failing with ENOTSUP we may either succeed, 	 * fail with ENODEV, or fail with EOVERFLOW. 	 */
if|if
condition|(
name|expected_error
operator|==
name|ENOTSUP
operator|&&
operator|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ENODEV
operator|||
name|error
operator|==
name|EOVERFLOW
operator|)
condition|)
name|expected_error
operator|=
name|error
expr_stmt|;
comment|/* 	 * If someone grew the LUN, the replacement may be too small. 	 */
if|if
condition|(
name|error
operator|==
name|EOVERFLOW
operator|||
name|error
operator|==
name|EBUSY
condition|)
name|expected_error
operator|=
name|error
expr_stmt|;
comment|/* XXX workaround 6690467 */
if|if
condition|(
name|error
operator|!=
name|expected_error
operator|&&
name|expected_error
operator|!=
name|EBUSY
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"attach (%s %llu, %s %llu, %d) "
literal|"returned %d, expected %d"
argument_list|,
name|oldpath
argument_list|,
operator|(
name|longlong_t
operator|)
name|oldsize
argument_list|,
name|newpath
argument_list|,
operator|(
name|longlong_t
operator|)
name|newsize
argument_list|,
name|replacing
argument_list|,
name|error
argument_list|,
name|expected_error
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_vdev_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that dynamic LUN growth works as expected.  */
end_comment

begin_function
name|void
name|ztest_vdev_LUN_growth
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|za
operator|->
name|za_spa
decl_stmt|;
name|char
name|dev_name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|uint64_t
name|leaves
init|=
name|MAX
argument_list|(
name|zopt_mirrors
argument_list|,
literal|1
argument_list|)
operator|*
name|zopt_raidz
decl_stmt|;
name|uint64_t
name|vdev
decl_stmt|;
name|size_t
name|fsize
decl_stmt|;
name|int
name|fd
decl_stmt|;
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_vdev_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Pick a random leaf vdev. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|vdev
operator|=
name|ztest_random
argument_list|(
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_children
operator|*
name|leaves
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dev_name
argument_list|,
name|ztest_dev_template
argument_list|,
name|zopt_dir
argument_list|,
name|zopt_pool
argument_list|,
name|vdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|dev_name
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Determine the size. 		 */
name|fsize
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
comment|/* 		 * If it's less than 2x the original size, grow by around 3%. 		 */
if|if
condition|(
name|fsize
operator|<
literal|2
operator|*
name|zopt_vdev_size
condition|)
block|{
name|size_t
name|newsize
init|=
name|fsize
operator|+
name|ztest_random
argument_list|(
name|fsize
operator|/
literal|32
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|6
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s grew from %lu to %lu bytes\n"
argument_list|,
name|dev_name
argument_list|,
operator|(
name|ulong_t
operator|)
name|fsize
argument_list|,
operator|(
name|ulong_t
operator|)
name|newsize
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_vdev_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|ztest_create_cb
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
comment|/* 	 * Create the directory object. 	 */
name|VERIFY
argument_list|(
name|dmu_object_claim
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
name|ZTEST_DIROBJ_BLOCKSIZE
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|ztest_block_tag_t
argument_list|)
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_create_claim
argument_list|(
name|os
argument_list|,
name|ZTEST_MICROZAP_OBJ
argument_list|,
name|DMU_OT_ZAP_OTHER
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_create_claim
argument_list|(
name|os
argument_list|,
name|ZTEST_FATZAP_OBJ
argument_list|,
name|DMU_OT_ZAP_OTHER
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_destroy_cb
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ztest_args_t
modifier|*
name|za
init|=
name|arg
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dmu_object_info_t
modifier|*
name|doi
init|=
operator|&
name|za
operator|->
name|za_doi
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Verify that the dataset contains a directory object. 	 */
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|DS_MODE_USER
operator||
name|DS_MODE_READONLY
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
block|{
comment|/* We could have crashed in the middle of destroying it */
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|doi
operator|->
name|doi_type
argument_list|,
operator|==
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|doi
operator|->
name|doi_physical_blks
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy the dataset. 	 */
name|error
operator|=
name|dmu_objset_destroy
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|DS_MODE_USER
operator||
name|DS_MODE_READONLY
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_destroy(os=%p) = %d\n"
argument_list|,
operator|&
name|os
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that dmu_objset_{create,destroy,open,close} work as expected.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|ztest_log_create
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lr_create_t
modifier|*
name|lr
decl_stmt|;
name|size_t
name|namesize
decl_stmt|;
name|char
name|name
index|[
literal|24
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"ZOBJ_%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|object
argument_list|)
expr_stmt|;
name|namesize
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|TX_CREATE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|namesize
operator|+
name|ztest_random
argument_list|(
name|ZIL_MAX_BLKSZ
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_create_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|bzero
argument_list|(
name|lr
operator|+
literal|1
argument_list|,
name|lr
operator|->
name|lr_common
operator|.
name|lrc_reclen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|->
name|lr_doid
operator|=
name|object
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
literal|0
expr_stmt|;
name|lr
operator|->
name|lr_mode
operator|=
name|mode
expr_stmt|;
name|lr
operator|->
name|lr_uid
operator|=
literal|0
expr_stmt|;
name|lr
operator|->
name|lr_gid
operator|=
literal|0
expr_stmt|;
name|lr
operator|->
name|lr_gen
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|lr
operator|->
name|lr_crtime
index|[
literal|0
index|]
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|lr
operator|->
name|lr_crtime
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|lr
operator|->
name|lr_rdev
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
argument_list|,
name|namesize
argument_list|)
expr_stmt|;
return|return
operator|(
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ztest_dmu_objset_create_destroy
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|,
modifier|*
name|os2
decl_stmt|;
name|char
name|name
index|[
literal|100
index|]
decl_stmt|;
name|int
name|basemode
decl_stmt|,
name|expected_error
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|uint64_t
name|seq
decl_stmt|;
name|uint64_t
name|objects
decl_stmt|;
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
literal|100
argument_list|,
literal|"%s/%s_temp_%llu"
argument_list|,
name|za
operator|->
name|za_pool
argument_list|,
name|za
operator|->
name|za_pool
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|za
operator|->
name|za_instance
argument_list|)
expr_stmt|;
name|basemode
operator|=
name|DS_MODE_TYPE
argument_list|(
name|za
operator|->
name|za_instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|basemode
operator|!=
name|DS_MODE_USER
operator|&&
name|basemode
operator|!=
name|DS_MODE_OWNER
condition|)
name|basemode
operator|=
name|DS_MODE_USER
expr_stmt|;
comment|/* 	 * If this dataset exists from a previous run, process its replay log 	 * half of the time.  If we don't replay it, then dmu_objset_destroy() 	 * (invoked from ztest_destroy_cb() below) should just throw it away. 	 */
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
operator|&&
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|DS_MODE_OWNER
argument_list|,
operator|&
name|os
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zil_replay
argument_list|(
name|os
argument_list|,
name|os
argument_list|,
name|ztest_replay_vector
argument_list|)
expr_stmt|;
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * There may be an old instance of the dataset we're about to 	 * create lying around from a previous run.  If so, destroy it 	 * and all of its snapshots. 	 */
operator|(
name|void
operator|)
name|dmu_objset_find
argument_list|(
name|name
argument_list|,
name|ztest_destroy_cb
argument_list|,
name|za
argument_list|,
name|DS_FIND_CHILDREN
operator||
name|DS_FIND_SNAPSHOTS
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that the destroyed dataset is no longer in the namespace. 	 */
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|basemode
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"dmu_objset_open(%s) found destroyed dataset %p"
argument_list|,
name|name
argument_list|,
name|os
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that we can create a new dataset. 	 */
name|error
operator|=
name|dmu_objset_create
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ztest_create_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"dmu_objset_create"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_create(%s) = %d"
argument_list|,
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|basemode
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_open(%s) = %d"
argument_list|,
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Open the intent log for it. 	 */
name|zilog
operator|=
name|zil_open
argument_list|(
name|os
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Put a random number of objects in there. 	 */
name|objects
operator|=
name|ztest_random
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|seq
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|objects
operator|--
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|object
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|object
operator|=
name|dmu_object_alloc
argument_list|(
name|os
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ztest_set_random_blocksize
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|seq
operator|=
name|ztest_log_create
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|object
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ztest_random
argument_list|(
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zil_commit
argument_list|(
name|zilog
argument_list|,
name|seq
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ztest_random
argument_list|(
literal|100
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zil_suspend
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|zil_resume
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Verify that we cannot create an existing dataset. 	 */
name|error
operator|=
name|dmu_objset_create
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EEXIST
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"created existing dataset, error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that multiple dataset holds are allowed, but only when 	 * the new access mode is compatible with the base mode. 	 */
if|if
condition|(
name|basemode
operator|==
name|DS_MODE_OWNER
condition|)
block|{
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|DS_MODE_USER
argument_list|,
operator|&
name|os2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_open('%s') = %d"
argument_list|,
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|dmu_objset_close
argument_list|(
name|os2
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|DS_MODE_OWNER
argument_list|,
operator|&
name|os2
argument_list|)
expr_stmt|;
name|expected_error
operator|=
operator|(
name|basemode
operator|==
name|DS_MODE_OWNER
operator|)
condition|?
name|EBUSY
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|expected_error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_open('%s') = %d, expected %d"
argument_list|,
name|name
argument_list|,
name|error
argument_list|,
name|expected_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|dmu_objset_close
argument_list|(
name|os2
argument_list|)
expr_stmt|;
name|zil_close
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_destroy
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_destroy(%s) = %d"
argument_list|,
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that dmu_snapshot_{create,destroy,open,close} work as expected.  */
end_comment

begin_function
name|void
name|ztest_dmu_snapshot_create_destroy
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|za
operator|->
name|za_os
decl_stmt|;
name|char
name|snapname
index|[
literal|100
index|]
decl_stmt|;
name|char
name|osname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|osname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|snapname
argument_list|,
literal|100
argument_list|,
literal|"%s@%llu"
argument_list|,
name|osname
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|za
operator|->
name|za_instance
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_destroy
argument_list|(
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_destroy() = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_snapshot
argument_list|(
name|osname
argument_list|,
name|strchr
argument_list|(
name|snapname
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
name|ztest_record_enospc
argument_list|(
literal|"dmu_take_snapshot"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EEXIST
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_take_snapshot() = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify dsl_dataset_promote handles EBUSY  */
end_comment

begin_function
name|void
name|ztest_dsl_dataset_promote_busy
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|za
operator|->
name|za_os
decl_stmt|;
name|objset_t
modifier|*
name|clone
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|char
name|snap1name
index|[
literal|100
index|]
decl_stmt|;
name|char
name|clone1name
index|[
literal|100
index|]
decl_stmt|;
name|char
name|snap2name
index|[
literal|100
index|]
decl_stmt|;
name|char
name|clone2name
index|[
literal|100
index|]
decl_stmt|;
name|char
name|snap3name
index|[
literal|100
index|]
decl_stmt|;
name|char
name|osname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
specifier|static
name|uint64_t
name|uniq
init|=
literal|0
decl_stmt|;
name|uint64_t
name|curval
decl_stmt|;
name|curval
operator|=
name|atomic_add_64_nv
argument_list|(
operator|&
name|uniq
argument_list|,
literal|5
argument_list|)
operator|-
literal|5
expr_stmt|;
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|osname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|snap1name
argument_list|,
literal|100
argument_list|,
literal|"%s@s1_%llu"
argument_list|,
name|osname
argument_list|,
name|curval
operator|++
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|clone1name
argument_list|,
literal|100
argument_list|,
literal|"%s/c1_%llu"
argument_list|,
name|osname
argument_list|,
name|curval
operator|++
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|snap2name
argument_list|,
literal|100
argument_list|,
literal|"%s@s2_%llu"
argument_list|,
name|clone1name
argument_list|,
name|curval
operator|++
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|clone2name
argument_list|,
literal|100
argument_list|,
literal|"%s/c2_%llu"
argument_list|,
name|osname
argument_list|,
name|curval
operator|++
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|snap3name
argument_list|,
literal|100
argument_list|,
literal|"%s@s3_%llu"
argument_list|,
name|clone1name
argument_list|,
name|curval
operator|++
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_snapshot
argument_list|(
name|osname
argument_list|,
name|strchr
argument_list|(
name|snap1name
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EEXIST
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_take_snapshot(%s) = %d"
argument_list|,
name|snap1name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|snap1name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|DS_MODE_USER
operator||
name|DS_MODE_READONLY
argument_list|,
operator|&
name|clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_open_snapshot(%s) = %d"
argument_list|,
name|snap1name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_create
argument_list|(
name|clone1name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|clone
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dmu_objset_close
argument_list|(
name|clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_create(%s) = %d"
argument_list|,
name|clone1name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_objset_snapshot
argument_list|(
name|clone1name
argument_list|,
name|strchr
argument_list|(
name|snap2name
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EEXIST
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_open_snapshot(%s) = %d"
argument_list|,
name|snap2name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_objset_snapshot
argument_list|(
name|clone1name
argument_list|,
name|strchr
argument_list|(
name|snap3name
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EEXIST
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_open_snapshot(%s) = %d"
argument_list|,
name|snap3name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|snap3name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|DS_MODE_USER
operator||
name|DS_MODE_READONLY
argument_list|,
operator|&
name|clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_open_snapshot(%s) = %d"
argument_list|,
name|snap3name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_create
argument_list|(
name|clone2name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|clone
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dmu_objset_close
argument_list|(
name|clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"dmu_objset_create"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_create(%s) = %d"
argument_list|,
name|clone2name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dsl_dataset_own
argument_list|(
name|snap1name
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dsl_dataset_own(%s) = %d"
argument_list|,
name|snap1name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_dataset_promote
argument_list|(
name|clone2name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EBUSY
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dsl_dataset_promote(%s), %d, not EBUSY"
argument_list|,
name|clone2name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|dsl_dataset_disown
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|out
label|:
name|error
operator|=
name|dmu_objset_destroy
argument_list|(
name|clone2name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_destroy(%s) = %d"
argument_list|,
name|clone2name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_destroy
argument_list|(
name|snap3name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_destroy(%s) = %d"
argument_list|,
name|snap2name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_destroy
argument_list|(
name|snap2name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_destroy(%s) = %d"
argument_list|,
name|snap2name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_destroy
argument_list|(
name|clone1name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_destroy(%s) = %d"
argument_list|,
name|clone1name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_destroy
argument_list|(
name|snap1name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_destroy(%s) = %d"
argument_list|,
name|snap1name
argument_list|,
name|error
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that dmu_object_{alloc,free} work as expected.  */
end_comment

begin_function
name|void
name|ztest_dmu_object_alloc_free
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|za
operator|->
name|za_os
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|batchobj
decl_stmt|,
name|object
decl_stmt|,
name|batchsize
decl_stmt|,
name|endoff
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|b
decl_stmt|,
name|c
decl_stmt|,
name|error
decl_stmt|,
name|bonuslen
decl_stmt|;
name|dmu_object_info_t
modifier|*
name|doi
init|=
operator|&
name|za
operator|->
name|za_doi
decl_stmt|;
name|char
name|osname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|osname
argument_list|)
expr_stmt|;
name|endoff
operator|=
operator|-
literal|8ULL
expr_stmt|;
name|batchsize
operator|=
literal|2
expr_stmt|;
comment|/* 	 * Create a batch object if necessary, and record it in the directory. 	 */
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_read
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|batchobj
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|batchobj
operator|==
literal|0
condition|)
block|{
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"create a batch object"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|batchobj
operator|=
name|dmu_object_alloc
argument_list|(
name|os
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ztest_set_random_blocksize
argument_list|(
name|os
argument_list|,
name|batchobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|batchobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Destroy the previous batch of objects. 	 */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|batchsize
condition|;
name|b
operator|++
control|)
block|{
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_read
argument_list|(
name|os
argument_list|,
name|batchobj
argument_list|,
name|b
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|object
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Read and validate contents. 		 * We expect the nth byte of the bonus buffer to be n. 		 */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|za
operator|->
name|za_dbuf
operator|=
name|db
expr_stmt|;
name|dmu_object_info_from_db
argument_list|(
name|db
argument_list|,
name|doi
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|doi
operator|->
name|doi_type
operator|==
name|DMU_OT_UINT64_OTHER
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|doi
operator|->
name|doi_bonus_type
operator|==
name|DMU_OT_PLAIN_OTHER
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|doi
operator|->
name|doi_physical_blks
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bonuslen
operator|=
name|doi
operator|->
name|doi_bonus_size
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|bonuslen
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|db
operator|->
name|db_data
operator|)
index|[
name|c
index|]
operator|!=
call|(
name|uint8_t
call|)
argument_list|(
name|c
operator|+
name|bonuslen
argument_list|)
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"bad bonus: %s, obj %llu, off %d: %u != %u"
argument_list|,
name|osname
argument_list|,
name|object
argument_list|,
name|c
argument_list|,
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|db
operator|->
name|db_data
operator|)
index|[
name|c
index|]
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
name|c
operator|+
name|bonuslen
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|za
operator|->
name|za_dbuf
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * We expect the word at endoff to be our object number. 		 */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|endoff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|temp
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|object
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"bad data in %s, got %llu, expected %llu"
argument_list|,
name|osname
argument_list|,
name|temp
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Destroy old object and clear batch entry. 		 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|batchobj
argument_list|,
name|b
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"free object"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|dmu_object_free
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_object_free('%s', %llu) = %d"
argument_list|,
name|osname
argument_list|,
name|object
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|object
operator|=
literal|0
expr_stmt|;
name|dmu_object_set_checksum
argument_list|(
name|os
argument_list|,
name|batchobj
argument_list|,
name|ztest_random_checksum
argument_list|()
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_object_set_compress
argument_list|(
name|os
argument_list|,
name|batchobj
argument_list|,
name|ztest_random_compress
argument_list|()
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|batchobj
argument_list|,
name|b
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Before creating the new batch of objects, generate a bunch of churn. 	 */
for|for
control|(
name|b
operator|=
name|ztest_random
argument_list|(
literal|100
argument_list|)
init|;
name|b
operator|>
literal|0
condition|;
name|b
operator|--
control|)
block|{
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"churn objects"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|object
operator|=
name|dmu_object_alloc
argument_list|(
name|os
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ztest_set_random_blocksize
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_object_free
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_object_free('%s', %llu) = %d"
argument_list|,
name|osname
argument_list|,
name|object
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create a new batch of objects with randomly chosen 	 * blocksizes and record them in the batch directory. 	 */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|batchsize
condition|;
name|b
operator|++
control|)
block|{
name|uint32_t
name|va_blksize
decl_stmt|;
name|u_longlong_t
name|va_nblocks
decl_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|batchobj
argument_list|,
name|b
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
name|endoff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"create batchobj"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|bonuslen
operator|=
operator|(
name|int
operator|)
name|ztest_random
argument_list|(
name|dmu_bonus_max
argument_list|()
argument_list|)
operator|+
literal|1
expr_stmt|;
name|object
operator|=
name|dmu_object_alloc
argument_list|(
name|os
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
name|DMU_OT_PLAIN_OTHER
argument_list|,
name|bonuslen
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ztest_set_random_blocksize
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_object_set_checksum
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|ztest_random_checksum
argument_list|()
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_object_set_compress
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|ztest_random_compress
argument_list|()
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|batchobj
argument_list|,
name|b
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 		 * Write to both the bonus buffer and the regular data. 		 */
name|VERIFY
argument_list|(
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|za
operator|->
name|za_dbuf
operator|=
name|db
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bonuslen
argument_list|,
operator|<=
argument_list|,
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|dmu_object_size_from_db
argument_list|(
name|db
argument_list|,
operator|&
name|va_blksize
argument_list|,
operator|&
name|va_nblocks
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|va_nblocks
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 		 * See comments above regarding the contents of 		 * the bonus buffer and the word at endoff. 		 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|bonuslen
condition|;
name|c
operator|++
control|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|db
operator|->
name|db_data
operator|)
index|[
name|c
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|c
operator|+
name|bonuslen
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|za
operator|->
name|za_dbuf
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Write to a large offset to increase indirection. 		 */
name|dmu_write
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|endoff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Verify that dmu_{read,write} work as expected.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|bufwad
block|{
name|uint64_t
name|bw_index
decl_stmt|;
name|uint64_t
name|bw_txg
decl_stmt|;
name|uint64_t
name|bw_data
decl_stmt|;
block|}
name|bufwad_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|dmu_read_write_dir
block|{
name|uint64_t
name|dd_packobj
decl_stmt|;
name|uint64_t
name|dd_bigobj
decl_stmt|;
name|uint64_t
name|dd_chunk
decl_stmt|;
block|}
name|dmu_read_write_dir_t
typedef|;
end_typedef

begin_function
name|void
name|ztest_dmu_read_write
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|za
operator|->
name|za_os
decl_stmt|;
name|dmu_read_write_dir_t
name|dd
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|freeit
decl_stmt|,
name|error
decl_stmt|;
name|uint64_t
name|n
decl_stmt|,
name|s
decl_stmt|,
name|txg
decl_stmt|;
name|bufwad_t
modifier|*
name|packbuf
decl_stmt|,
modifier|*
name|bigbuf
decl_stmt|,
modifier|*
name|pack
decl_stmt|,
modifier|*
name|bigH
decl_stmt|,
modifier|*
name|bigT
decl_stmt|;
name|uint64_t
name|packoff
decl_stmt|,
name|packsize
decl_stmt|,
name|bigoff
decl_stmt|,
name|bigsize
decl_stmt|;
name|uint64_t
name|regions
init|=
literal|997
decl_stmt|;
name|uint64_t
name|stride
init|=
literal|123456789ULL
decl_stmt|;
name|uint64_t
name|width
init|=
literal|40
decl_stmt|;
name|int
name|free_percent
init|=
literal|5
decl_stmt|;
comment|/* 	 * This test uses two objects, packobj and bigobj, that are always 	 * updated together (i.e. in the same tx) so that their contents are 	 * in sync and can be compared.  Their contents relate to each other 	 * in a simple way: packobj is a dense array of 'bufwad' structures, 	 * while bigobj is a sparse array of the same bufwads.  Specifically, 	 * for any index n, there are three bufwads that should be identical: 	 * 	 *	packobj, at offset n * sizeof (bufwad_t) 	 *	bigobj, at the head of the nth chunk 	 *	bigobj, at the tail of the nth chunk 	 * 	 * The chunk size is arbitrary. It doesn't have to be a power of two, 	 * and it doesn't have any relation to the object blocksize. 	 * The only requirement is that it can hold at least two bufwads. 	 * 	 * Normally, we write the bufwad to each of these locations. 	 * However, free_percent of the time we instead write zeroes to 	 * packobj and perform a dmu_free_range() on bigobj.  By comparing 	 * bigobj to packobj, we can verify that the DMU is correctly 	 * tracking which parts of an object are allocated and free, 	 * and that the contents of the allocated blocks are correct. 	 */
comment|/* 	 * Read the directory info.  If it's the first time, set things up. 	 */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|dd
argument_list|)
argument_list|,
operator|&
name|dd
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dd
operator|.
name|dd_chunk
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|dd
operator|.
name|dd_packobj
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dd
operator|.
name|dd_bigobj
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|dd
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"create r/w directory"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|dd
operator|.
name|dd_packobj
operator|=
name|dmu_object_alloc
argument_list|(
name|os
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dd
operator|.
name|dd_bigobj
operator|=
name|dmu_object_alloc
argument_list|(
name|os
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dd
operator|.
name|dd_chunk
operator|=
operator|(
literal|1000
operator|+
name|ztest_random
argument_list|(
literal|1000
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|ztest_set_random_blocksize
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_packobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ztest_set_random_blocksize
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|dd
argument_list|)
argument_list|,
operator|&
name|dd
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Prefetch a random chunk of the big object. 	 * Our aim here is to get some async reads in flight 	 * for blocks that we may free below; the DMU should 	 * handle this race correctly. 	 */
name|n
operator|=
name|ztest_random
argument_list|(
name|regions
argument_list|)
operator|*
name|stride
operator|+
name|ztest_random
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|s
operator|=
literal|1
operator|+
name|ztest_random
argument_list|(
literal|2
operator|*
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dmu_prefetch
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|n
operator|*
name|dd
operator|.
name|dd_chunk
argument_list|,
name|s
operator|*
name|dd
operator|.
name|dd_chunk
argument_list|)
expr_stmt|;
comment|/* 	 * Pick a random index and compute the offsets into packobj and bigobj. 	 */
name|n
operator|=
name|ztest_random
argument_list|(
name|regions
argument_list|)
operator|*
name|stride
operator|+
name|ztest_random
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|s
operator|=
literal|1
operator|+
name|ztest_random
argument_list|(
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
name|packoff
operator|=
name|n
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
expr_stmt|;
name|packsize
operator|=
name|s
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
expr_stmt|;
name|bigoff
operator|=
name|n
operator|*
name|dd
operator|.
name|dd_chunk
expr_stmt|;
name|bigsize
operator|=
name|s
operator|*
name|dd
operator|.
name|dd_chunk
expr_stmt|;
name|packbuf
operator|=
name|umem_alloc
argument_list|(
name|packsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
name|bigbuf
operator|=
name|umem_alloc
argument_list|(
name|bigsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
comment|/* 	 * free_percent of the time, free a range of bigobj rather than 	 * overwriting it. 	 */
name|freeit
operator|=
operator|(
name|ztest_random
argument_list|(
literal|100
argument_list|)
operator|<
name|free_percent
operator|)
expr_stmt|;
comment|/* 	 * Read the current contents of our objects. 	 */
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|,
name|packbuf
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|,
name|bigbuf
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Get a tx for the mods to both packobj and bigobj. 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|dd
operator|.
name|dd_packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeit
condition|)
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
else|else
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"dmu r/w range"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|packbuf
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|bigbuf
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
return|return;
block|}
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * For each index from n to n + s, verify that the existing bufwad 	 * in packobj matches the bufwads at the head and tail of the 	 * corresponding chunk in bigobj.  Then update all three bufwads 	 * with the new values we want to write out. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
condition|;
name|i
operator|++
control|)
block|{
comment|/* LINTED */
name|pack
operator|=
operator|(
name|bufwad_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|packbuf
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
operator|)
expr_stmt|;
comment|/* LINTED */
name|bigH
operator|=
operator|(
name|bufwad_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bigbuf
operator|+
name|i
operator|*
name|dd
operator|.
name|dd_chunk
operator|)
expr_stmt|;
comment|/* LINTED */
name|bigT
operator|=
operator|(
name|bufwad_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bigH
operator|+
name|dd
operator|.
name|dd_chunk
operator|)
operator|-
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|bigH
operator|-
operator|(
name|uintptr_t
operator|)
name|bigbuf
operator|<
name|bigsize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|bigT
operator|-
operator|(
name|uintptr_t
operator|)
name|bigbuf
operator|<
name|bigsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
operator|->
name|bw_txg
operator|>
name|txg
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"future leak: got %llx, open txg is %llx"
argument_list|,
name|pack
operator|->
name|bw_txg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
operator|->
name|bw_data
operator|!=
literal|0
operator|&&
name|pack
operator|->
name|bw_index
operator|!=
name|n
operator|+
name|i
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"wrong index: got %llx, wanted %llx+%llx"
argument_list|,
name|pack
operator|->
name|bw_index
argument_list|,
name|n
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|pack
argument_list|,
name|bigH
argument_list|,
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"pack/bigH mismatch in %p/%p"
argument_list|,
name|pack
argument_list|,
name|bigH
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|pack
argument_list|,
name|bigT
argument_list|,
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"pack/bigT mismatch in %p/%p"
argument_list|,
name|pack
argument_list|,
name|bigT
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeit
condition|)
block|{
name|bzero
argument_list|(
name|pack
argument_list|,
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pack
operator|->
name|bw_index
operator|=
name|n
operator|+
name|i
expr_stmt|;
name|pack
operator|->
name|bw_txg
operator|=
name|txg
expr_stmt|;
name|pack
operator|->
name|bw_data
operator|=
literal|1
operator|+
name|ztest_random
argument_list|(
operator|-
literal|2ULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|bigH
operator|=
operator|*
name|pack
expr_stmt|;
operator|*
name|bigT
operator|=
operator|*
name|pack
expr_stmt|;
block|}
comment|/* 	 * We've verified all the old bufwads, and made new ones. 	 * Now write them out. 	 */
name|dmu_write
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|,
name|packbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeit
condition|)
block|{
if|if
condition|(
name|zopt_verbose
operator|>=
literal|6
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"freeing offset %llx size %llx"
literal|" txg %llx\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bigoff
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bigsize
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|txg
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_free_range
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zopt_verbose
operator|>=
literal|6
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"writing offset %llx size %llx"
literal|" txg %llx\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bigoff
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bigsize
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|txg
argument_list|)
expr_stmt|;
block|}
name|dmu_write
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|,
name|bigbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Sanity check the stuff we just wrote. 	 */
block|{
name|void
modifier|*
name|packcheck
init|=
name|umem_alloc
argument_list|(
name|packsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
decl_stmt|;
name|void
modifier|*
name|bigcheck
init|=
name|umem_alloc
argument_list|(
name|bigsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|,
name|packcheck
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|,
name|bigcheck
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
name|packbuf
argument_list|,
name|packcheck
argument_list|,
name|packsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
name|bigbuf
argument_list|,
name|bigcheck
argument_list|,
name|bigsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|packcheck
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|bigcheck
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
block|}
name|umem_free
argument_list|(
name|packbuf
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|bigbuf
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|compare_and_update_pbbufs
parameter_list|(
name|uint64_t
name|s
parameter_list|,
name|bufwad_t
modifier|*
name|packbuf
parameter_list|,
name|bufwad_t
modifier|*
name|bigbuf
parameter_list|,
name|uint64_t
name|bigsize
parameter_list|,
name|uint64_t
name|n
parameter_list|,
name|dmu_read_write_dir_t
name|dd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|uint64_t
name|i
decl_stmt|;
name|bufwad_t
modifier|*
name|pack
decl_stmt|;
name|bufwad_t
modifier|*
name|bigH
decl_stmt|;
name|bufwad_t
modifier|*
name|bigT
decl_stmt|;
comment|/* 	 * For each index from n to n + s, verify that the existing bufwad 	 * in packobj matches the bufwads at the head and tail of the 	 * corresponding chunk in bigobj.  Then update all three bufwads 	 * with the new values we want to write out. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
condition|;
name|i
operator|++
control|)
block|{
comment|/* LINTED */
name|pack
operator|=
operator|(
name|bufwad_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|packbuf
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
operator|)
expr_stmt|;
comment|/* LINTED */
name|bigH
operator|=
operator|(
name|bufwad_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bigbuf
operator|+
name|i
operator|*
name|dd
operator|.
name|dd_chunk
operator|)
expr_stmt|;
comment|/* LINTED */
name|bigT
operator|=
operator|(
name|bufwad_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bigH
operator|+
name|dd
operator|.
name|dd_chunk
operator|)
operator|-
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|bigH
operator|-
operator|(
name|uintptr_t
operator|)
name|bigbuf
operator|<
name|bigsize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|bigT
operator|-
operator|(
name|uintptr_t
operator|)
name|bigbuf
operator|<
name|bigsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
operator|->
name|bw_txg
operator|>
name|txg
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"future leak: got %llx, open txg is %llx"
argument_list|,
name|pack
operator|->
name|bw_txg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
operator|->
name|bw_data
operator|!=
literal|0
operator|&&
name|pack
operator|->
name|bw_index
operator|!=
name|n
operator|+
name|i
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"wrong index: got %llx, wanted %llx+%llx"
argument_list|,
name|pack
operator|->
name|bw_index
argument_list|,
name|n
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|pack
argument_list|,
name|bigH
argument_list|,
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"pack/bigH mismatch in %p/%p"
argument_list|,
name|pack
argument_list|,
name|bigH
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|pack
argument_list|,
name|bigT
argument_list|,
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"pack/bigT mismatch in %p/%p"
argument_list|,
name|pack
argument_list|,
name|bigT
argument_list|)
expr_stmt|;
name|pack
operator|->
name|bw_index
operator|=
name|n
operator|+
name|i
expr_stmt|;
name|pack
operator|->
name|bw_txg
operator|=
name|txg
expr_stmt|;
name|pack
operator|->
name|bw_data
operator|=
literal|1
operator|+
name|ztest_random
argument_list|(
operator|-
literal|2ULL
argument_list|)
expr_stmt|;
operator|*
name|bigH
operator|=
operator|*
name|pack
expr_stmt|;
operator|*
name|bigT
operator|=
operator|*
name|pack
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ztest_dmu_read_write_zcopy
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|za
operator|->
name|za_os
decl_stmt|;
name|dmu_read_write_dir_t
name|dd
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|n
decl_stmt|,
name|s
decl_stmt|,
name|txg
decl_stmt|;
name|bufwad_t
modifier|*
name|packbuf
decl_stmt|,
modifier|*
name|bigbuf
decl_stmt|;
name|uint64_t
name|packoff
decl_stmt|,
name|packsize
decl_stmt|,
name|bigoff
decl_stmt|,
name|bigsize
decl_stmt|;
name|uint64_t
name|regions
init|=
literal|997
decl_stmt|;
name|uint64_t
name|stride
init|=
literal|123456789ULL
decl_stmt|;
name|uint64_t
name|width
init|=
literal|9
decl_stmt|;
name|dmu_buf_t
modifier|*
name|bonus_db
decl_stmt|;
name|arc_buf_t
modifier|*
modifier|*
name|bigbuf_arcbufs
decl_stmt|;
name|dmu_object_info_t
modifier|*
name|doi
init|=
operator|&
name|za
operator|->
name|za_doi
decl_stmt|;
comment|/* 	 * This test uses two objects, packobj and bigobj, that are always 	 * updated together (i.e. in the same tx) so that their contents are 	 * in sync and can be compared.  Their contents relate to each other 	 * in a simple way: packobj is a dense array of 'bufwad' structures, 	 * while bigobj is a sparse array of the same bufwads.  Specifically, 	 * for any index n, there are three bufwads that should be identical: 	 * 	 *	packobj, at offset n * sizeof (bufwad_t) 	 *	bigobj, at the head of the nth chunk 	 *	bigobj, at the tail of the nth chunk 	 * 	 * The chunk size is set equal to bigobj block size so that 	 * dmu_assign_arcbuf() can be tested for object updates. 	 */
comment|/* 	 * Read the directory info.  If it's the first time, set things up. 	 */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|dd
argument_list|)
argument_list|,
operator|&
name|dd
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dd
operator|.
name|dd_chunk
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|dd
operator|.
name|dd_packobj
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dd
operator|.
name|dd_bigobj
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|dd
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"create r/w directory"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|dd
operator|.
name|dd_packobj
operator|=
name|dmu_object_alloc
argument_list|(
name|os
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dd
operator|.
name|dd_bigobj
operator|=
name|dmu_object_alloc
argument_list|(
name|os
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ztest_set_random_blocksize
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_packobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ztest_set_random_blocksize
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|doi
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|doi
operator|->
name|doi_data_block_size
operator|>=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ISP2
argument_list|(
name|doi
operator|->
name|doi_data_block_size
argument_list|)
argument_list|)
expr_stmt|;
name|dd
operator|.
name|dd_chunk
operator|=
name|doi
operator|->
name|doi_data_block_size
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|dd
argument_list|)
argument_list|,
operator|&
name|dd
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VERIFY
argument_list|(
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|doi
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|ISP2
argument_list|(
name|doi
operator|->
name|doi_data_block_size
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dd
operator|.
name|dd_chunk
operator|==
name|doi
operator|->
name|doi_data_block_size
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dd
operator|.
name|dd_chunk
operator|>=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Pick a random index and compute the offsets into packobj and bigobj. 	 */
name|n
operator|=
name|ztest_random
argument_list|(
name|regions
argument_list|)
operator|*
name|stride
operator|+
name|ztest_random
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|s
operator|=
literal|1
operator|+
name|ztest_random
argument_list|(
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
name|packoff
operator|=
name|n
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
expr_stmt|;
name|packsize
operator|=
name|s
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
expr_stmt|;
name|bigoff
operator|=
name|n
operator|*
name|dd
operator|.
name|dd_chunk
expr_stmt|;
name|bigsize
operator|=
name|s
operator|*
name|dd
operator|.
name|dd_chunk
expr_stmt|;
name|packbuf
operator|=
name|umem_zalloc
argument_list|(
name|packsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
name|bigbuf
operator|=
name|umem_zalloc
argument_list|(
name|bigsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|bonus_db
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bigbuf_arcbufs
operator|=
name|umem_zalloc
argument_list|(
literal|2
operator|*
name|s
operator|*
sizeof|sizeof
argument_list|(
name|arc_buf_t
operator|*
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
comment|/* 	 * Iteration 0 test zcopy for DB_UNCACHED dbufs. 	 * Iteration 1 test zcopy to already referenced dbufs. 	 * Iteration 2 test zcopy to dirty dbuf in the same txg. 	 * Iteration 3 test zcopy to dbuf dirty in previous txg. 	 * Iteration 4 test zcopy when dbuf is no longer dirty. 	 * Iteration 5 test zcopy when it can't be done. 	 * Iteration 6 one more zcopy write. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|j
decl_stmt|;
name|uint64_t
name|off
decl_stmt|;
comment|/* 		 * In iteration 5 (i == 5) use arcbufs 		 * that don't match bigobj blksz to test 		 * dmu_assign_arcbuf() when it can't directly 		 * assign an arcbuf to a dbuf. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|5
condition|)
block|{
name|bigbuf_arcbufs
index|[
name|j
index|]
operator|=
name|dmu_request_arcbuf
argument_list|(
name|bonus_db
argument_list|,
name|dd
operator|.
name|dd_chunk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
index|]
operator|=
name|dmu_request_arcbuf
argument_list|(
name|bonus_db
argument_list|,
name|dd
operator|.
name|dd_chunk
operator|/
literal|2
argument_list|)
expr_stmt|;
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
operator|=
name|dmu_request_arcbuf
argument_list|(
name|bonus_db
argument_list|,
name|dd
operator|.
name|dd_chunk
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Get a tx for the mods to both packobj and bigobj. 		 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|dd
operator|.
name|dd_packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|100
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
operator|-
literal|1
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"dmu r/w range"
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|packbuf
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|bigbuf
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|5
condition|)
block|{
name|dmu_return_arcbuf
argument_list|(
name|bigbuf_arcbufs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_return_arcbuf
argument_list|(
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
index|]
argument_list|)
expr_stmt|;
name|dmu_return_arcbuf
argument_list|(
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|umem_free
argument_list|(
name|bigbuf_arcbufs
argument_list|,
literal|2
operator|*
name|s
operator|*
sizeof|sizeof
argument_list|(
name|arc_buf_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|bonus_db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return;
block|}
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 		 * 50% of the time don't read objects in the 1st iteration to 		 * test dmu_assign_arcbuf() for the case when there're no 		 * existing dbufs for the specified offsets. 		 */
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|,
name|packbuf
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|,
name|bigbuf
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|compare_and_update_pbbufs
argument_list|(
name|s
argument_list|,
name|packbuf
argument_list|,
name|bigbuf
argument_list|,
name|bigsize
argument_list|,
name|n
argument_list|,
name|dd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 		 * We've verified all the old bufwads, and made new ones. 		 * Now write them out. 		 */
name|dmu_write
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|,
name|packbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|6
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"writing offset %llx size %llx"
literal|" txg %llx\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bigoff
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bigsize
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|txg
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|off
operator|=
name|bigoff
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
condition|;
name|j
operator|++
operator|,
name|off
operator|+=
name|dd
operator|.
name|dd_chunk
control|)
block|{
name|dmu_buf_t
modifier|*
name|dbt
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|5
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bigbuf
operator|+
operator|(
name|off
operator|-
name|bigoff
operator|)
argument_list|,
name|bigbuf_arcbufs
index|[
name|j
index|]
operator|->
name|b_data
argument_list|,
name|dd
operator|.
name|dd_chunk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bigbuf
operator|+
operator|(
name|off
operator|-
name|bigoff
operator|)
argument_list|,
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
index|]
operator|->
name|b_data
argument_list|,
name|dd
operator|.
name|dd_chunk
operator|/
literal|2
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bigbuf
operator|+
operator|(
name|off
operator|-
name|bigoff
operator|)
operator|+
name|dd
operator|.
name|dd_chunk
operator|/
literal|2
argument_list|,
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
operator|->
name|b_data
argument_list|,
name|dd
operator|.
name|dd_chunk
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|VERIFY
argument_list|(
name|dmu_buf_hold
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|off
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbt
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|5
condition|)
block|{
name|dmu_assign_arcbuf
argument_list|(
name|bonus_db
argument_list|,
name|off
argument_list|,
name|bigbuf_arcbufs
index|[
name|j
index|]
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_assign_arcbuf
argument_list|(
name|bonus_db
argument_list|,
name|off
argument_list|,
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
index|]
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_assign_arcbuf
argument_list|(
name|bonus_db
argument_list|,
name|off
operator|+
name|dd
operator|.
name|dd_chunk
operator|/
literal|2
argument_list|,
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|dmu_buf_rele
argument_list|(
name|dbt
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 		 * Sanity check the stuff we just wrote. 		 */
block|{
name|void
modifier|*
name|packcheck
init|=
name|umem_alloc
argument_list|(
name|packsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
decl_stmt|;
name|void
modifier|*
name|bigcheck
init|=
name|umem_alloc
argument_list|(
name|bigsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|,
name|packcheck
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|dd
operator|.
name|dd_bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|,
name|bigcheck
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
name|packbuf
argument_list|,
name|packcheck
argument_list|,
name|packsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
name|bigbuf
argument_list|,
name|bigcheck
argument_list|,
name|bigsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|packcheck
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|bigcheck
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|txg_wait_open
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|3
condition|)
block|{
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|dmu_buf_rele
argument_list|(
name|bonus_db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|packbuf
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|bigbuf
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|bigbuf_arcbufs
argument_list|,
literal|2
operator|*
name|s
operator|*
sizeof|sizeof
argument_list|(
name|arc_buf_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ztest_dmu_check_future_leak
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|za
operator|->
name|za_os
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|ztest_block_tag_t
modifier|*
name|bt
decl_stmt|;
name|dmu_object_info_t
modifier|*
name|doi
init|=
operator|&
name|za
operator|->
name|za_doi
decl_stmt|;
comment|/* 	 * Make sure that, if there is a write record in the bonus buffer 	 * of the ZTEST_DIROBJ, that the txg for this record is<= the 	 * last synced txg of the pool. 	 */
name|VERIFY
argument_list|(
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|za
operator|->
name|za_dbuf
operator|=
name|db
expr_stmt|;
name|VERIFY
argument_list|(
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|doi
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|doi
operator|->
name|doi_bonus_size
argument_list|,
operator|>=
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bt
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|doi
operator|->
name|doi_bonus_size
argument_list|,
operator|<=
argument_list|,
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|doi
operator|->
name|doi_bonus_size
operator|%
sizeof|sizeof
argument_list|(
operator|*
name|bt
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bt
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|doi
operator|->
name|doi_bonus_size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|bt
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|bt_objset
operator|!=
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|bt
operator|->
name|bt_objset
argument_list|,
operator|==
argument_list|,
name|dmu_objset_id
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bt
operator|->
name|bt_object
argument_list|,
operator|==
argument_list|,
name|ZTEST_DIROBJ
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bt
operator|->
name|bt_offset
argument_list|,
operator|==
argument_list|,
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bt
operator|->
name|bt_txg
argument_list|,
operator|<
argument_list|,
name|spa_first_txg
argument_list|(
name|za
operator|->
name|za_spa
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|za
operator|->
name|za_dbuf
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ztest_dmu_write_parallel
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|za
operator|->
name|za_os
decl_stmt|;
name|ztest_block_tag_t
modifier|*
name|rbt
init|=
operator|&
name|za
operator|->
name|za_rbt
decl_stmt|;
name|ztest_block_tag_t
modifier|*
name|wbt
init|=
operator|&
name|za
operator|->
name|za_wbt
decl_stmt|;
specifier|const
name|size_t
name|btsize
init|=
sizeof|sizeof
argument_list|(
name|ztest_block_tag_t
argument_list|)
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|int
name|b
decl_stmt|,
name|error
decl_stmt|;
name|int
name|bs
init|=
name|ZTEST_DIROBJ_BLOCKSIZE
decl_stmt|;
name|int
name|do_free
init|=
literal|0
decl_stmt|;
name|uint64_t
name|off
decl_stmt|,
name|txg
decl_stmt|,
name|txg_how
decl_stmt|;
name|mutex_t
modifier|*
name|lp
decl_stmt|;
name|char
name|osname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|char
name|iobuf
index|[
name|SPA_MAXBLOCKSIZE
index|]
decl_stmt|;
name|blkptr_t
name|blk
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint64_t
name|blkoff
decl_stmt|;
name|zbookmark_t
name|zb
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|dmu_buf_t
modifier|*
name|bonus_db
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
init|=
name|NULL
decl_stmt|;
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|osname
argument_list|)
expr_stmt|;
comment|/* 	 * Have multiple threads write to large offsets in ZTEST_DIROBJ 	 * to verify that having multiple threads writing to the same object 	 * in parallel doesn't cause any trouble. 	 */
if|if
condition|(
name|ztest_random
argument_list|(
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Do the bonus buffer instead of a regular block. 		 * We need a lock to serialize resize vs. others, 		 * so we hash on the objset ID. 		 */
name|b
operator|=
name|dmu_objset_id
argument_list|(
name|os
argument_list|)
operator|%
name|ZTEST_SYNC_LOCKS
expr_stmt|;
name|off
operator|=
operator|-
literal|1ULL
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|ZTEST_DIROBJ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|ztest_random
argument_list|(
name|ZTEST_SYNC_LOCKS
argument_list|)
expr_stmt|;
name|off
operator|=
name|za
operator|->
name|za_diroff_shared
operator|+
operator|(
name|b
operator|<<
name|SPA_MAXBLOCKSHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|do_free
operator|=
literal|1
expr_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|off
argument_list|,
name|bs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|off
argument_list|,
name|bs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|off
operator|!=
operator|-
literal|1ULL
operator|&&
name|P2PHASE
argument_list|(
name|off
argument_list|,
name|bs
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|do_free
operator|&&
name|ztest_random
argument_list|(
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|FTAG
argument_list|,
operator|&
name|bonus_db
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|abuf
operator|=
name|dmu_request_arcbuf
argument_list|(
name|bonus_db
argument_list|,
name|bs
argument_list|)
expr_stmt|;
block|}
name|txg_how
operator|=
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|?
name|TXG_WAIT
else|:
name|TXG_NOWAIT
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|txg_how
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
name|ASSERT
argument_list|(
name|txg_how
operator|==
name|TXG_NOWAIT
argument_list|)
expr_stmt|;
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ztest_record_enospc
argument_list|(
literal|"dmu write parallel"
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|abuf
operator|!=
name|NULL
condition|)
block|{
name|dmu_return_arcbuf
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|bonus_db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|lp
operator|=
operator|&
name|ztest_shared
operator|->
name|zs_sync_lock
index|[
name|b
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|wbt
operator|->
name|bt_objset
operator|=
name|dmu_objset_id
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|wbt
operator|->
name|bt_object
operator|=
name|ZTEST_DIROBJ
expr_stmt|;
name|wbt
operator|->
name|bt_offset
operator|=
name|off
expr_stmt|;
name|wbt
operator|->
name|bt_txg
operator|=
name|txg
expr_stmt|;
name|wbt
operator|->
name|bt_thread
operator|=
name|za
operator|->
name|za_instance
expr_stmt|;
name|wbt
operator|->
name|bt_seq
operator|=
name|ztest_shared
operator|->
name|zs_seq
index|[
name|b
index|]
operator|++
expr_stmt|;
comment|/* protected by lp */
comment|/* 	 * Occasionally, write an all-zero block to test the behavior 	 * of blocks that compress into holes. 	 */
if|if
condition|(
name|off
operator|!=
operator|-
literal|1ULL
operator|&&
name|ztest_random
argument_list|(
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|bzero
argument_list|(
name|wbt
argument_list|,
name|btsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
operator|-
literal|1ULL
condition|)
block|{
name|dmu_object_info_t
modifier|*
name|doi
init|=
operator|&
name|za
operator|->
name|za_doi
decl_stmt|;
name|char
modifier|*
name|dboff
decl_stmt|;
name|VERIFY
argument_list|(
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|za
operator|->
name|za_dbuf
operator|=
name|db
expr_stmt|;
name|dmu_object_info_from_db
argument_list|(
name|db
argument_list|,
name|doi
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|doi
operator|->
name|doi_bonus_size
argument_list|,
operator|<=
argument_list|,
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|doi
operator|->
name|doi_bonus_size
argument_list|,
operator|>=
argument_list|,
name|btsize
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|doi
operator|->
name|doi_bonus_size
operator|%
name|btsize
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dboff
operator|=
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|doi
operator|->
name|doi_bonus_size
operator|-
name|btsize
expr_stmt|;
name|bcopy
argument_list|(
name|dboff
argument_list|,
name|rbt
argument_list|,
name|btsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbt
operator|->
name|bt_objset
operator|!=
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|rbt
operator|->
name|bt_objset
argument_list|,
operator|==
argument_list|,
name|wbt
operator|->
name|bt_objset
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rbt
operator|->
name|bt_object
argument_list|,
operator|==
argument_list|,
name|wbt
operator|->
name|bt_object
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rbt
operator|->
name|bt_offset
argument_list|,
operator|==
argument_list|,
name|wbt
operator|->
name|bt_offset
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rbt
operator|->
name|bt_txg
argument_list|,
operator|<=
argument_list|,
name|wbt
operator|->
name|bt_txg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ztest_random
argument_list|(
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|newsize
init|=
operator|(
name|ztest_random
argument_list|(
name|db
operator|->
name|db_size
operator|/
name|btsize
argument_list|)
operator|+
literal|1
operator|)
operator|*
name|btsize
decl_stmt|;
name|ASSERT3U
argument_list|(
name|newsize
argument_list|,
operator|>=
argument_list|,
name|btsize
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|newsize
argument_list|,
operator|<=
argument_list|,
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|dmu_set_bonus
argument_list|(
name|db
argument_list|,
name|newsize
argument_list|,
name|tx
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dboff
operator|=
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|newsize
operator|-
name|btsize
expr_stmt|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|wbt
argument_list|,
name|dboff
argument_list|,
name|btsize
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|za
operator|->
name|za_dbuf
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_free
condition|)
block|{
name|VERIFY
argument_list|(
name|dmu_free_range
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|off
argument_list|,
name|bs
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abuf
operator|==
name|NULL
condition|)
block|{
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|off
argument_list|,
name|btsize
argument_list|,
name|wbt
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|wbt
argument_list|,
name|abuf
operator|->
name|b_data
argument_list|,
name|btsize
argument_list|)
expr_stmt|;
name|dmu_assign_arcbuf
argument_list|(
name|bonus_db
argument_list|,
name|off
argument_list|,
name|abuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|bonus_db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|1000
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|poll
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* open dn_notxholds window */
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|10000
argument_list|)
operator|==
literal|0
condition|)
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
operator|-
literal|1ULL
operator|||
name|do_free
condition|)
return|return;
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * dmu_sync() the block we just wrote. 	 */
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|blkoff
operator|=
name|P2ALIGN_TYPED
argument_list|(
name|off
argument_list|,
name|bs
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_buf_hold
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|blkoff
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|za
operator|->
name|za_dbuf
operator|=
name|db
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return;
block|}
name|blkoff
operator|=
name|off
operator|-
name|blkoff
expr_stmt|;
name|error
operator|=
name|dmu_sync
argument_list|(
name|NULL
argument_list|,
name|db
argument_list|,
operator|&
name|blk
argument_list|,
name|txg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|za
operator|->
name|za_dbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|blk
operator|.
name|blk_birth
operator|==
literal|0
condition|)
block|{
comment|/* concurrent free */
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return;
block|}
name|txg_suspend
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|blk
operator|.
name|blk_fill
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|BP_GET_TYPE
argument_list|(
operator|&
name|blk
argument_list|)
argument_list|,
operator|==
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|BP_GET_LEVEL
argument_list|(
operator|&
name|blk
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|BP_GET_LSIZE
argument_list|(
operator|&
name|blk
argument_list|)
argument_list|,
operator|==
argument_list|,
name|bs
argument_list|)
expr_stmt|;
comment|/* 	 * Read the block that dmu_sync() returned to make sure its contents 	 * match what we wrote.  We do this while still txg_suspend()ed 	 * to ensure that the block can't be reused before we read it. 	 */
name|zb
operator|.
name|zb_objset
operator|=
name|dmu_objset_id
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zb
operator|.
name|zb_object
operator|=
name|ZTEST_DIROBJ
expr_stmt|;
name|zb
operator|.
name|zb_level
operator|=
literal|0
expr_stmt|;
name|zb
operator|.
name|zb_blkid
operator|=
name|off
operator|/
name|bs
expr_stmt|;
name|error
operator|=
name|zio_wait
argument_list|(
name|zio_read
argument_list|(
name|NULL
argument_list|,
name|za
operator|->
name|za_spa
argument_list|,
operator|&
name|blk
argument_list|,
name|iobuf
argument_list|,
name|bs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|,
operator|&
name|zb
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|txg_resume
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|iobuf
index|[
name|blkoff
index|]
argument_list|,
name|rbt
argument_list|,
name|btsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbt
operator|->
name|bt_objset
operator|==
literal|0
condition|)
comment|/* concurrent free */
return|return;
if|if
condition|(
name|wbt
operator|->
name|bt_objset
operator|==
literal|0
condition|)
comment|/* all-zero overwrite */
return|return;
name|ASSERT3U
argument_list|(
name|rbt
operator|->
name|bt_objset
argument_list|,
operator|==
argument_list|,
name|wbt
operator|->
name|bt_objset
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rbt
operator|->
name|bt_object
argument_list|,
operator|==
argument_list|,
name|wbt
operator|->
name|bt_object
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rbt
operator|->
name|bt_offset
argument_list|,
operator|==
argument_list|,
name|wbt
operator|->
name|bt_offset
argument_list|)
expr_stmt|;
comment|/* 	 * The semantic of dmu_sync() is that we always push the most recent 	 * version of the data, so in the face of concurrent updates we may 	 * see a newer version of the block.  That's OK. 	 */
name|ASSERT3U
argument_list|(
name|rbt
operator|->
name|bt_txg
argument_list|,
operator|>=
argument_list|,
name|wbt
operator|->
name|bt_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbt
operator|->
name|bt_thread
operator|==
name|wbt
operator|->
name|bt_thread
condition|)
name|ASSERT3U
argument_list|(
name|rbt
operator|->
name|bt_seq
argument_list|,
operator|==
argument_list|,
name|wbt
operator|->
name|bt_seq
argument_list|)
expr_stmt|;
else|else
name|ASSERT3U
argument_list|(
name|rbt
operator|->
name|bt_seq
argument_list|,
operator|>
argument_list|,
name|wbt
operator|->
name|bt_seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that zap_{create,destroy,add,remove,update} work as expected.  */
end_comment

begin_define
define|#
directive|define
name|ZTEST_ZAP_MIN_INTS
value|1
end_define

begin_define
define|#
directive|define
name|ZTEST_ZAP_MAX_INTS
value|4
end_define

begin_define
define|#
directive|define
name|ZTEST_ZAP_MAX_PROPS
value|1000
end_define

begin_function
name|void
name|ztest_zap
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|za
operator|->
name|za_os
decl_stmt|;
name|uint64_t
name|object
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|,
name|last_txg
decl_stmt|;
name|uint64_t
name|value
index|[
name|ZTEST_ZAP_MAX_INTS
index|]
decl_stmt|;
name|uint64_t
name|zl_ints
decl_stmt|,
name|zl_intsize
decl_stmt|,
name|prop
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ints
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|char
name|propname
index|[
literal|100
index|]
decl_stmt|,
name|txgname
index|[
literal|100
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|osname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|hc
index|[
literal|2
index|]
init|=
block|{
literal|"s.acl.h"
block|,
literal|".s.open.h.hyLZlg"
block|}
decl_stmt|;
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|osname
argument_list|)
expr_stmt|;
comment|/* 	 * Create a new object if necessary, and record it in the directory. 	 */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|object
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
literal|0
condition|)
block|{
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"create zap test obj"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|object
operator|=
name|zap_create
argument_list|(
name|os
argument_list|,
name|DMU_OT_ZAP_OTHER
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"zap_create('%s', %llu) = %d"
argument_list|,
name|osname
argument_list|,
name|object
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|object
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 		 * Generate a known hash collision, and verify that 		 * we can lookup and remove both entries. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|value
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|error
operator|=
name|zap_add
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|hc
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|value
index|[
name|i
index|]
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|zap_add
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|hc
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|value
index|[
name|i
index|]
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
name|EEXIST
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_length
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|hc
index|[
name|i
index|]
argument_list|,
operator|&
name|zl_intsize
argument_list|,
operator|&
name|zl_ints
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zl_intsize
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zl_ints
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|zap_remove
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|hc
index|[
name|i
index|]
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
name|ints
operator|=
name|MAX
argument_list|(
name|ZTEST_ZAP_MIN_INTS
argument_list|,
name|object
operator|%
name|ZTEST_ZAP_MAX_INTS
argument_list|)
expr_stmt|;
name|prop
operator|=
name|ztest_random
argument_list|(
name|ZTEST_ZAP_MAX_PROPS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|propname
argument_list|,
literal|"prop_%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|prop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|txgname
argument_list|,
literal|"txg_%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|prop
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|last_txg
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If these zap entries already exist, validate their contents. 	 */
name|error
operator|=
name|zap_length
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|txgname
argument_list|,
operator|&
name|zl_intsize
argument_list|,
operator|&
name|zl_ints
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|zl_intsize
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zl_ints
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|txgname
argument_list|,
name|zl_intsize
argument_list|,
name|zl_ints
argument_list|,
operator|&
name|last_txg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_length
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|propname
argument_list|,
operator|&
name|zl_intsize
argument_list|,
operator|&
name|zl_ints
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zl_intsize
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zl_ints
argument_list|,
operator|==
argument_list|,
name|ints
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|propname
argument_list|,
name|zl_intsize
argument_list|,
name|zl_ints
argument_list|,
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ints
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT3U
argument_list|(
name|value
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|,
name|last_txg
operator|+
name|object
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Atomically update two entries in our zap object. 	 * The first is named txg_%llu, and contains the txg 	 * in which the property was last updated.  The second 	 * is named prop_%llu, and the nth element of its value 	 * should be txg + object + n. 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"create zap entry"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_txg
operator|>
name|txg
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"zap future leak: old %llu new %llu"
argument_list|,
name|last_txg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ints
condition|;
name|i
operator|++
control|)
name|value
index|[
name|i
index|]
operator|=
name|txg
operator|+
name|object
operator|+
name|i
expr_stmt|;
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|txgname
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|txg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"zap_update('%s', %llu, '%s') = %d"
argument_list|,
name|osname
argument_list|,
name|object
argument_list|,
name|txgname
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|propname
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|ints
argument_list|,
name|value
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"zap_update('%s', %llu, '%s') = %d"
argument_list|,
name|osname
argument_list|,
name|object
argument_list|,
name|propname
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Remove a random pair of entries. 	 */
name|prop
operator|=
name|ztest_random
argument_list|(
name|ZTEST_ZAP_MAX_PROPS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|propname
argument_list|,
literal|"prop_%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|prop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|txgname
argument_list|,
literal|"txg_%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|prop
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_length
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|txgname
argument_list|,
operator|&
name|zl_intsize
argument_list|,
operator|&
name|zl_ints
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
return|return;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"remove zap entry"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|zap_remove
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|txgname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"zap_remove('%s', %llu, '%s') = %d"
argument_list|,
name|osname
argument_list|,
name|object
argument_list|,
name|txgname
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_remove
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|propname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"zap_remove('%s', %llu, '%s') = %d"
argument_list|,
name|osname
argument_list|,
name|object
argument_list|,
name|propname
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Once in a while, destroy the object. 	 */
if|if
condition|(
name|ztest_random
argument_list|(
literal|1000
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"destroy zap object"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|zap_destroy
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"zap_destroy('%s', %llu) = %d"
argument_list|,
name|osname
argument_list|,
name|object
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|object
operator|=
literal|0
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Testcase to test the upgrading of a microzap to fatzap.  */
end_comment

begin_function
name|void
name|ztest_fzap
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|za
operator|->
name|za_os
decl_stmt|;
name|uint64_t
name|object
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|char
name|osname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|name
init|=
literal|"aaa"
decl_stmt|;
name|char
name|entname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|osname
argument_list|)
expr_stmt|;
comment|/* 	 * Create a new object if necessary, and record it in the directory. 	 */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|object
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
literal|0
condition|)
block|{
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"create zap test obj"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|object
operator|=
name|zap_create
argument_list|(
name|os
argument_list|,
name|DMU_OT_ZAP_OTHER
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"zap_create('%s', %llu) = %d"
argument_list|,
name|osname
argument_list|,
name|object
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|object
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add entries to this ZAP amd make sure it spills over 	 * and gets upgraded to a fatzap. Also, since we are adding 	 * 2050 entries we should see ptrtbl growth and leaf-block 	 * split. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2050
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|entname
argument_list|,
sizeof|sizeof
argument_list|(
name|entname
argument_list|)
argument_list|,
literal|"%s-%d"
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|value
operator|=
name|i
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
name|TRUE
argument_list|,
name|entname
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"create zap entry"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|zap_add
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|entname
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|value
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|EEXIST
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Once in a while, destroy the object. 	 */
if|if
condition|(
name|ztest_random
argument_list|(
literal|1000
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"destroy zap object"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|zap_destroy
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"zap_destroy('%s', %llu) = %d"
argument_list|,
name|osname
argument_list|,
name|object
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|object
operator|=
literal|0
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|za
operator|->
name|za_diroff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ztest_zap_parallel
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|za
operator|->
name|za_os
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|,
name|object
decl_stmt|,
name|count
decl_stmt|,
name|wsize
decl_stmt|,
name|wc
decl_stmt|,
name|zl_wsize
decl_stmt|,
name|zl_wc
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|namelen
decl_stmt|,
name|error
decl_stmt|;
name|char
name|name
index|[
literal|20
index|]
decl_stmt|,
name|string_value
index|[
literal|20
index|]
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
comment|/* 	 * Generate a random name of the form 'xxx.....' where each 	 * x is a random printable character and the dots are dots. 	 * There are 94 such characters, and the name length goes from 	 * 6 to 20, so there are 94^3 * 15 = 12,458,760 possible names. 	 */
name|namelen
operator|=
name|ztest_random
argument_list|(
sizeof|sizeof
argument_list|(
name|name
argument_list|)
operator|-
literal|5
argument_list|)
operator|+
literal|5
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|name
index|[
name|i
index|]
operator|=
literal|'!'
operator|+
name|ztest_random
argument_list|(
literal|'~'
operator|-
literal|'!'
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|namelen
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|name
index|[
name|i
index|]
operator|=
literal|'.'
expr_stmt|;
name|name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|object
operator|=
name|ZTEST_MICROZAP_OBJ
expr_stmt|;
else|else
name|object
operator|=
name|ZTEST_FATZAP_OBJ
expr_stmt|;
if|if
condition|(
operator|(
name|namelen
operator|&
literal|1
operator|)
operator|||
name|object
operator|==
name|ZTEST_MICROZAP_OBJ
condition|)
block|{
name|wsize
operator|=
sizeof|sizeof
argument_list|(
name|txg
argument_list|)
expr_stmt|;
name|wc
operator|=
literal|1
expr_stmt|;
name|data
operator|=
operator|&
name|txg
expr_stmt|;
block|}
else|else
block|{
name|wsize
operator|=
literal|1
expr_stmt|;
name|wc
operator|=
name|namelen
expr_stmt|;
name|data
operator|=
name|string_value
expr_stmt|;
block|}
name|count
operator|=
operator|-
literal|1ULL
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_count
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|count
operator|!=
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
comment|/* 	 * Select an operation: length, lookup, add, update, remove. 	 */
name|i
operator|=
name|ztest_random
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
block|{
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"zap parallel"
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|string_value
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tx
operator|=
name|NULL
expr_stmt|;
name|txg
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|string_value
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|error
operator|=
name|zap_length
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|name
argument_list|,
operator|&
name|zl_wsize
argument_list|,
operator|&
name|zl_wc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|wsize
argument_list|,
operator|==
argument_list|,
name|zl_wsize
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|wc
argument_list|,
operator|==
argument_list|,
name|zl_wc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|name
argument_list|,
name|wsize
argument_list|,
name|wc
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|data
operator|==
name|string_value
operator|&&
name|bcmp
argument_list|(
name|name
argument_list|,
name|data
argument_list|,
name|namelen
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"name '%s' != val '%s' len %d"
argument_list|,
name|name
argument_list|,
name|data
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|error
operator|=
name|zap_add
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|name
argument_list|,
name|wsize
argument_list|,
name|wc
argument_list|,
name|data
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|EEXIST
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|VERIFY
argument_list|(
name|zap_update
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|name
argument_list|,
name|wsize
argument_list|,
name|wc
argument_list|,
name|data
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|error
operator|=
name|zap_remove
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|name
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tx
operator|!=
name|NULL
condition|)
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ztest_dsl_prop_get_set
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|za
operator|->
name|za_os
decl_stmt|;
name|int
name|i
decl_stmt|,
name|inherit
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop
decl_stmt|,
modifier|*
name|valname
decl_stmt|;
name|char
name|setpoint
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|osname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|osname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|prop
operator|=
literal|"checksum"
expr_stmt|;
name|value
operator|=
name|ztest_random_checksum
argument_list|()
expr_stmt|;
name|inherit
operator|=
operator|(
name|value
operator|==
name|ZIO_CHECKSUM_INHERIT
operator|)
expr_stmt|;
block|}
else|else
block|{
name|prop
operator|=
literal|"compression"
expr_stmt|;
name|value
operator|=
name|ztest_random_compress
argument_list|()
expr_stmt|;
name|inherit
operator|=
operator|(
name|value
operator|==
name|ZIO_COMPRESS_INHERIT
operator|)
expr_stmt|;
block|}
name|error
operator|=
name|dsl_prop_set
argument_list|(
name|osname
argument_list|,
name|prop
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|,
operator|!
name|inherit
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"dsl_prop_set"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|dsl_prop_get
argument_list|(
name|osname
argument_list|,
name|prop
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|value
argument_list|,
name|setpoint
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|valname
operator|=
name|zio_checksum_table
index|[
name|value
index|]
operator|.
name|ci_name
expr_stmt|;
else|else
name|valname
operator|=
name|zio_compress_table
index|[
name|value
index|]
operator|.
name|ci_name
expr_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|6
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s = %s for '%s'\n"
argument_list|,
name|osname
argument_list|,
name|prop
argument_list|,
name|valname
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Inject random faults into the on-disk data.  */
end_comment

begin_function
name|void
name|ztest_fault_inject
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|uint64_t
name|leaves
init|=
name|MAX
argument_list|(
name|zopt_mirrors
argument_list|,
literal|1
argument_list|)
operator|*
name|zopt_raidz
decl_stmt|;
name|uint64_t
name|bad
init|=
literal|0x1990c0ffeedecadeULL
decl_stmt|;
name|uint64_t
name|top
decl_stmt|,
name|leaf
decl_stmt|;
name|char
name|path0
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|pathrand
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|size_t
name|fsize
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|za
operator|->
name|za_spa
decl_stmt|;
name|int
name|bshift
init|=
name|SPA_MAXBLOCKSHIFT
operator|+
literal|2
decl_stmt|;
comment|/* don't scrog all labels */
name|int
name|iters
init|=
literal|1000
decl_stmt|;
name|int
name|maxfaults
init|=
name|zopt_maxfaults
decl_stmt|;
name|vdev_t
modifier|*
name|vd0
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|guid0
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|leaves
operator|>=
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * We need SCL_STATE here because we're going to look at vd0->vdev_tsd. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Inject errors on a normal data device. 		 */
name|top
operator|=
name|ztest_random
argument_list|(
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_children
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|ztest_random
argument_list|(
name|leaves
argument_list|)
expr_stmt|;
comment|/* 		 * Generate paths to the first leaf in this top-level vdev, 		 * and to the random leaf we selected.  We'll induce transient 		 * write failures and random online/offline activity on leaf 0, 		 * and we'll write random garbage to the randomly chosen leaf. 		 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|path0
argument_list|,
sizeof|sizeof
argument_list|(
name|path0
argument_list|)
argument_list|,
name|ztest_dev_template
argument_list|,
name|zopt_dir
argument_list|,
name|zopt_pool
argument_list|,
name|top
operator|*
name|leaves
operator|+
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathrand
argument_list|,
sizeof|sizeof
argument_list|(
name|pathrand
argument_list|)
argument_list|,
name|ztest_dev_template
argument_list|,
name|zopt_dir
argument_list|,
name|zopt_pool
argument_list|,
name|top
operator|*
name|leaves
operator|+
name|leaf
argument_list|)
expr_stmt|;
name|vd0
operator|=
name|vdev_lookup_by_path
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|path0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd0
operator|!=
name|NULL
operator|&&
name|maxfaults
operator|!=
literal|1
condition|)
block|{
comment|/* 			 * Make vd0 explicitly claim to be unreadable, 			 * or unwriteable, or reach behind its back 			 * and close the underlying fd.  We can do this if 			 * maxfaults == 0 because we'll fail and reexecute, 			 * and we can do it if maxfaults>= 2 because we'll 			 * have enough redundancy.  If maxfaults == 1, the 			 * combination of this with injection of random data 			 * corruption below exceeds the pool's fault tolerance. 			 */
name|vdev_file_t
modifier|*
name|vf
init|=
name|vd0
operator|->
name|vdev_tsd
decl_stmt|;
if|if
condition|(
name|vf
operator|!=
name|NULL
operator|&&
name|ztest_random
argument_list|(
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|vf
operator|->
name|vf_vnode
operator|->
name|v_fd
argument_list|)
expr_stmt|;
name|vf
operator|->
name|vf_vnode
operator|->
name|v_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vd0
operator|->
name|vdev_cant_read
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|vd0
operator|->
name|vdev_cant_write
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|guid0
operator|=
name|vd0
operator|->
name|vdev_guid
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Inject errors on an l2cache device. 		 */
name|spa_aux_vdev_t
modifier|*
name|sav
init|=
operator|&
name|spa
operator|->
name|spa_l2cache
decl_stmt|;
if|if
condition|(
name|sav
operator|->
name|sav_count
operator|==
literal|0
condition|)
block|{
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return;
block|}
name|vd0
operator|=
name|sav
operator|->
name|sav_vdevs
index|[
name|ztest_random
argument_list|(
name|sav
operator|->
name|sav_count
argument_list|)
index|]
expr_stmt|;
name|guid0
operator|=
name|vd0
operator|->
name|vdev_guid
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|path0
argument_list|,
name|vd0
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pathrand
argument_list|,
name|vd0
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|leaf
operator|=
literal|0
expr_stmt|;
name|leaves
operator|=
literal|1
expr_stmt|;
name|maxfaults
operator|=
name|INT_MAX
expr_stmt|;
comment|/* no limit on cache devices */
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxfaults
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * If we can tolerate two or more faults, randomly online/offline vd0. 	 */
if|if
condition|(
name|maxfaults
operator|>=
literal|2
operator|&&
name|guid0
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ztest_random
argument_list|(
literal|10
argument_list|)
operator|<
literal|6
condition|)
block|{
name|int
name|flags
init|=
operator|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|?
name|ZFS_OFFLINE_TEMPORARY
else|:
literal|0
operator|)
decl_stmt|;
name|VERIFY
argument_list|(
name|vdev_offline
argument_list|(
name|spa
argument_list|,
name|guid0
argument_list|,
name|flags
argument_list|)
operator|!=
name|EBUSY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|vdev_online
argument_list|(
name|spa
argument_list|,
name|guid0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * We have at least single-fault tolerance, so inject data corruption. 	 */
name|fd
operator|=
name|open
argument_list|(
name|pathrand
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
comment|/* we hit a gap in the device namespace */
return|return;
name|fsize
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|iters
operator|!=
literal|0
condition|)
block|{
name|offset
operator|=
name|ztest_random
argument_list|(
name|fsize
operator|/
operator|(
name|leaves
operator|<<
name|bshift
operator|)
argument_list|)
operator|*
operator|(
name|leaves
operator|<<
name|bshift
operator|)
operator|+
operator|(
name|leaf
operator|<<
name|bshift
operator|)
operator|+
operator|(
name|ztest_random
argument_list|(
literal|1ULL
operator|<<
operator|(
name|bshift
operator|-
literal|1
operator|)
argument_list|)
operator|&
operator|-
literal|8ULL
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|fsize
condition|)
continue|continue;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|6
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"injecting bad word into %s,"
literal|" offset 0x%llx\n"
argument_list|,
name|pathrand
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwrite
argument_list|(
name|fd
argument_list|,
operator|&
name|bad
argument_list|,
sizeof|sizeof
argument_list|(
name|bad
argument_list|)
argument_list|,
name|offset
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|bad
argument_list|)
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"can't inject bad word at 0x%llx in %s"
argument_list|,
name|offset
argument_list|,
name|pathrand
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scrub the pool.  */
end_comment

begin_function
name|void
name|ztest_scrub
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|za
operator|->
name|za_spa
decl_stmt|;
operator|(
name|void
operator|)
name|spa_scrub
argument_list|(
name|spa
argument_list|,
name|POOL_SCRUB_EVERYTHING
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|poll
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
comment|/* wait a second, then force a restart */
operator|(
name|void
operator|)
name|spa_scrub
argument_list|(
name|spa
argument_list|,
name|POOL_SCRUB_EVERYTHING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rename the pool to a different name and then rename it back.  */
end_comment

begin_function
name|void
name|ztest_spa_rename
parameter_list|(
name|ztest_args_t
modifier|*
name|za
parameter_list|)
block|{
name|char
modifier|*
name|oldname
decl_stmt|,
modifier|*
name|newname
decl_stmt|;
name|int
name|error
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
operator|(
name|void
operator|)
name|rw_wrlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
name|oldname
operator|=
name|za
operator|->
name|za_pool
expr_stmt|;
name|newname
operator|=
name|umem_alloc
argument_list|(
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|+
literal|5
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newname
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|newname
argument_list|,
literal|"_tmp"
argument_list|)
expr_stmt|;
comment|/* 	 * Do the rename 	 */
name|error
operator|=
name|spa_rename
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_rename('%s', '%s') = %d"
argument_list|,
name|oldname
argument_list|,
name|newname
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Try to open it under the old name, which shouldn't exist 	 */
name|error
operator|=
name|spa_open
argument_list|(
name|oldname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_open('%s') = %d"
argument_list|,
name|oldname
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Open it under the new name and make sure it's still the same spa_t. 	 */
name|error
operator|=
name|spa_open
argument_list|(
name|newname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_open('%s') = %d"
argument_list|,
name|newname
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|==
name|za
operator|->
name|za_spa
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Rename it back to the original 	 */
name|error
operator|=
name|spa_rename
argument_list|(
name|newname
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_rename('%s', '%s') = %d"
argument_list|,
name|newname
argument_list|,
name|oldname
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure it can still be opened 	 */
name|error
operator|=
name|spa_open
argument_list|(
name|oldname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_open('%s') = %d"
argument_list|,
name|oldname
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|==
name|za
operator|->
name|za_spa
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|newname
argument_list|,
name|strlen
argument_list|(
name|newname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Completely obliterate one disk.  */
end_comment

begin_function
specifier|static
name|void
name|ztest_obliterate_one_disk
parameter_list|(
name|uint64_t
name|vdev
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|char
name|dev_name
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|copy_name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|size_t
name|fsize
decl_stmt|;
if|if
condition|(
name|zopt_maxfaults
operator|<
literal|2
condition|)
return|return;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dev_name
argument_list|,
name|ztest_dev_template
argument_list|,
name|zopt_dir
argument_list|,
name|zopt_pool
argument_list|,
name|vdev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|copy_name
argument_list|,
name|MAXPATHLEN
argument_list|,
literal|"%s.old"
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|dev_name
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"can't open %s"
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
comment|/* 	 * Determine the size. 	 */
name|fsize
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * Rename the old device to dev_name.old (useful for debugging). 	 */
name|VERIFY
argument_list|(
name|rename
argument_list|(
name|dev_name
argument_list|,
name|copy_name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Create a new one. 	 */
name|VERIFY
argument_list|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|dev_name
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
operator|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|fsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_replace_one_disk
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|vdev
parameter_list|)
block|{
name|char
name|dev_name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|root
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dev_name
argument_list|,
name|ztest_dev_template
argument_list|,
name|zopt_dir
argument_list|,
name|zopt_pool
argument_list|,
name|vdev
argument_list|)
expr_stmt|;
comment|/* 	 * Build the nvlist describing dev_name. 	 */
name|root
operator|=
name|make_vdev_root
argument_list|(
name|dev_name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|=
name|vdev_lookup_by_path
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|dev_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|guid
operator|=
literal|0
expr_stmt|;
else|else
name|guid
operator|=
name|vd
operator|->
name|vdev_guid
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_vdev_attach
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|root
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EBUSY
operator|&&
name|error
operator|!=
name|ENOTSUP
operator|&&
name|error
operator|!=
name|ENODEV
operator|&&
name|error
operator|!=
name|EDOM
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_vdev_attach(in-place) = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_verify_blocks
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|char
name|zdb
index|[
name|MAXPATHLEN
operator|+
name|MAXNAMELEN
operator|+
literal|20
index|]
decl_stmt|;
name|char
name|zbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|bin
decl_stmt|;
name|char
modifier|*
name|ztest
decl_stmt|;
name|char
modifier|*
name|isa
decl_stmt|;
name|int
name|isalen
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|strlcpy
argument_list|(
name|zdb
argument_list|,
literal|"/usr/bin/ztest"
argument_list|,
sizeof|sizeof
argument_list|(
name|zdb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zdb lives in /usr/sbin, while ztest lives in /usr/bin */
name|bin
operator|=
name|strstr
argument_list|(
name|zdb
argument_list|,
literal|"/usr/bin/"
argument_list|)
expr_stmt|;
name|ztest
operator|=
name|strstr
argument_list|(
name|bin
argument_list|,
literal|"/ztest"
argument_list|)
expr_stmt|;
name|isa
operator|=
name|bin
operator|+
literal|8
expr_stmt|;
name|isalen
operator|=
name|ztest
operator|-
name|isa
expr_stmt|;
name|isa
operator|=
name|strdup
argument_list|(
name|isa
argument_list|)
expr_stmt|;
comment|/* LINTED */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bin
argument_list|,
literal|"/usr/sbin%.*s/zdb -bcc%s%s -U /tmp/zpool.cache %s"
argument_list|,
name|isalen
argument_list|,
name|isa
argument_list|,
name|zopt_verbose
operator|>=
literal|3
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|zopt_verbose
operator|>=
literal|4
condition|?
literal|"v"
else|:
literal|""
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isa
argument_list|)
expr_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|5
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Executing %s\n"
argument_list|,
name|strstr
argument_list|(
name|zdb
argument_list|,
literal|"zdb "
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|popen
argument_list|(
name|zdb
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|zbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|zbuf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|zopt_verbose
operator|>=
literal|3
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|zbuf
argument_list|)
expr_stmt|;
name|status
operator|=
name|pclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return;
name|ztest_dump_core
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"'%s' exit code %d"
argument_list|,
name|zdb
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"'%s' died with signal %d"
argument_list|,
name|zdb
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_walk_pool_directory
parameter_list|(
name|char
modifier|*
name|header
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|6
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|spa
operator|=
name|spa_next
argument_list|(
name|spa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|zopt_verbose
operator|>=
literal|6
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_spa_import_export
parameter_list|(
name|char
modifier|*
name|oldname
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|newconfig
decl_stmt|;
name|uint64_t
name|pool_guid
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"import/export: old = %s, new = %s\n"
argument_list|,
name|oldname
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clean up from previous runs. 	 */
operator|(
name|void
operator|)
name|spa_destroy
argument_list|(
name|newname
argument_list|)
expr_stmt|;
comment|/* 	 * Get the pool's configuration and guid. 	 */
name|error
operator|=
name|spa_open
argument_list|(
name|oldname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_open('%s') = %d"
argument_list|,
name|oldname
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Kick off a scrub to tickle scrub/export races. 	 */
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|spa_scrub
argument_list|(
name|spa
argument_list|,
name|POOL_SCRUB_EVERYTHING
argument_list|)
expr_stmt|;
name|pool_guid
operator|=
name|spa_guid
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ztest_walk_pool_directory
argument_list|(
literal|"pools before export"
argument_list|)
expr_stmt|;
comment|/* 	 * Export it. 	 */
name|error
operator|=
name|spa_export
argument_list|(
name|oldname
argument_list|,
operator|&
name|config
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_export('%s') = %d"
argument_list|,
name|oldname
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ztest_walk_pool_directory
argument_list|(
literal|"pools after export"
argument_list|)
expr_stmt|;
comment|/* 	 * Try to import it. 	 */
name|newconfig
operator|=
name|spa_tryimport
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|newconfig
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|newconfig
argument_list|)
expr_stmt|;
comment|/* 	 * Import it under the new name. 	 */
name|error
operator|=
name|spa_import
argument_list|(
name|newname
argument_list|,
name|config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_import('%s') = %d"
argument_list|,
name|newname
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ztest_walk_pool_directory
argument_list|(
literal|"pools after import"
argument_list|)
expr_stmt|;
comment|/* 	 * Try to import it again -- should fail with EEXIST. 	 */
name|error
operator|=
name|spa_import
argument_list|(
name|newname
argument_list|,
name|config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EEXIST
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_import('%s') twice"
argument_list|,
name|newname
argument_list|)
expr_stmt|;
comment|/* 	 * Try to import it under a different name -- should fail with EEXIST. 	 */
name|error
operator|=
name|spa_import
argument_list|(
name|oldname
argument_list|,
name|config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EEXIST
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_import('%s') under multiple names"
argument_list|,
name|newname
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that the pool is no longer visible under the old name. 	 */
name|error
operator|=
name|spa_open
argument_list|(
name|oldname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_open('%s') = %d"
argument_list|,
name|newname
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that we can open and close the pool using the new name. 	 */
name|error
operator|=
name|spa_open
argument_list|(
name|newname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_open('%s') = %d"
argument_list|,
name|newname
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pool_guid
operator|==
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_resume
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
if|if
condition|(
name|spa_suspended
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|spa_vdev_state_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|vdev_clear
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ztest_resume_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|arg
decl_stmt|;
while|while
condition|(
operator|!
name|ztest_exiting
condition|)
block|{
operator|(
name|void
operator|)
name|poll
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|ztest_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ztest_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ztest_args_t
modifier|*
name|za
init|=
name|arg
decl_stmt|;
name|ztest_shared_t
modifier|*
name|zs
init|=
name|ztest_shared
decl_stmt|;
name|hrtime_t
name|now
decl_stmt|,
name|functime
decl_stmt|;
name|ztest_info_t
modifier|*
name|zi
decl_stmt|;
name|int
name|f
decl_stmt|,
name|i
decl_stmt|;
while|while
condition|(
operator|(
name|now
operator|=
name|gethrtime
argument_list|()
operator|)
operator|<
name|za
operator|->
name|za_stop
condition|)
block|{
comment|/* 		 * See if it's time to force a crash. 		 */
if|if
condition|(
name|now
operator|>
name|za
operator|->
name|za_kill
condition|)
block|{
name|zs
operator|->
name|zs_alloc
operator|=
name|spa_get_alloc
argument_list|(
name|za
operator|->
name|za_spa
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_space
operator|=
name|spa_get_space
argument_list|(
name|za
operator|->
name|za_spa
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Pick a random function. 		 */
name|f
operator|=
name|ztest_random
argument_list|(
name|ZTEST_FUNCS
argument_list|)
expr_stmt|;
name|zi
operator|=
operator|&
name|zs
operator|->
name|zs_info
index|[
name|f
index|]
expr_stmt|;
comment|/* 		 * Decide whether to call it, based on the requested frequency. 		 */
if|if
condition|(
name|zi
operator|->
name|zi_call_target
operator|==
literal|0
operator|||
operator|(
name|double
operator|)
name|zi
operator|->
name|zi_call_total
operator|/
name|zi
operator|->
name|zi_call_target
operator|>
call|(
name|double
call|)
argument_list|(
name|now
operator|-
name|zs
operator|->
name|zs_start_time
argument_list|)
operator|/
operator|(
name|zopt_time
operator|*
name|NANOSEC
operator|)
condition|)
continue|continue;
name|atomic_add_64
argument_list|(
operator|&
name|zi
operator|->
name|zi_calls
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|zi
operator|->
name|zi_call_total
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|za
operator|->
name|za_diroff
operator|=
operator|(
name|za
operator|->
name|za_instance
operator|*
name|ZTEST_FUNCS
operator|+
name|f
operator|)
operator|*
name|ZTEST_DIRSIZE
expr_stmt|;
name|za
operator|->
name|za_diroff_shared
operator|=
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zi
operator|->
name|zi_iters
condition|;
name|i
operator|++
control|)
name|zi
operator|->
name|zi_func
argument_list|(
name|za
argument_list|)
expr_stmt|;
name|functime
operator|=
name|gethrtime
argument_list|()
operator|-
name|now
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|zi
operator|->
name|zi_call_time
argument_list|,
name|functime
argument_list|)
expr_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|4
condition|)
block|{
name|Dl_info
name|dli
decl_stmt|;
operator|(
name|void
operator|)
name|dladdr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|zi
operator|->
name|zi_func
argument_list|,
operator|&
name|dli
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%6.2f sec in %s\n"
argument_list|,
operator|(
name|double
operator|)
name|functime
operator|/
name|NANOSEC
argument_list|,
name|dli
operator|.
name|dli_sname
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we're getting ENOSPC with some regularity, stop. 		 */
if|if
condition|(
name|zs
operator|->
name|zs_enospc_count
operator|>
literal|10
condition|)
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Kick off threads to run tests on all datasets in parallel.  */
end_comment

begin_function
specifier|static
name|void
name|ztest_run
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|t
decl_stmt|,
name|d
decl_stmt|,
name|error
decl_stmt|;
name|ztest_shared_t
modifier|*
name|zs
init|=
name|ztest_shared
decl_stmt|;
name|ztest_args_t
modifier|*
name|za
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|char
name|name
index|[
literal|100
index|]
decl_stmt|;
name|thread_t
name|resume_tid
decl_stmt|;
name|ztest_exiting
operator|=
name|B_FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|_mutex_init
argument_list|(
operator|&
name|zs
operator|->
name|zs_vdev_lock
argument_list|,
name|USYNC_THREAD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rwlock_init
argument_list|(
operator|&
name|zs
operator|->
name|zs_name_lock
argument_list|,
name|USYNC_THREAD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|ZTEST_SYNC_LOCKS
condition|;
name|t
operator|++
control|)
operator|(
name|void
operator|)
name|_mutex_init
argument_list|(
operator|&
name|zs
operator|->
name|zs_sync_lock
index|[
name|t
index|]
argument_list|,
name|USYNC_THREAD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy one disk before we even start. 	 * It's mirrored, so everything should work just fine. 	 * This makes us exercise fault handling very early in spa_load(). 	 */
name|ztest_obliterate_one_disk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that the sum of the sizes of all blocks in the pool 	 * equals the SPA's allocated space total. 	 */
name|ztest_verify_blocks
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* 	 * Kick off a replacement of the disk we just obliterated. 	 */
name|kernel_init
argument_list|(
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|spa_open
argument_list|(
name|pool
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ztest_replace_one_disk
argument_list|(
name|spa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|5
condition|)
name|show_pool_stats
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|kernel_fini
argument_list|()
expr_stmt|;
name|kernel_init
argument_list|(
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that we can export the pool and reimport it under a 	 * different name. 	 */
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
literal|100
argument_list|,
literal|"%s_import"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|ztest_spa_import_export
argument_list|(
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ztest_spa_import_export
argument_list|(
name|name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Verify that we can loop over all pools. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|spa
operator|=
name|spa_next
argument_list|(
name|NULL
argument_list|)
init|;
name|spa
operator|!=
name|NULL
condition|;
name|spa
operator|=
name|spa_next
argument_list|(
name|spa
argument_list|)
control|)
block|{
if|if
condition|(
name|zopt_verbose
operator|>
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"spa_next: found %s\n"
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Open our pool. 	 */
name|VERIFY
argument_list|(
name|spa_open
argument_list|(
name|pool
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * We don't expect the pool to suspend unless maxfaults == 0, 	 * in which case ztest_fault_inject() temporarily takes away 	 * the only valid replica. 	 */
if|if
condition|(
name|zopt_maxfaults
operator|==
literal|0
condition|)
name|spa
operator|->
name|spa_failmode
operator|=
name|ZIO_FAILURE_MODE_WAIT
expr_stmt|;
else|else
name|spa
operator|->
name|spa_failmode
operator|=
name|ZIO_FAILURE_MODE_PANIC
expr_stmt|;
comment|/* 	 * Create a thread to periodically resume suspended I/O. 	 */
name|VERIFY
argument_list|(
name|thr_create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ztest_resume_thread
argument_list|,
name|spa
argument_list|,
name|THR_BOUND
argument_list|,
operator|&
name|resume_tid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that we can safely inquire about about any object, 	 * whether it's allocated or not.  To make it interesting, 	 * we probe a 5-wide window around each power of two. 	 * This hits all edge cases, including zero and the max. 	 */
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|64
condition|;
name|t
operator|++
control|)
block|{
for|for
control|(
name|d
operator|=
operator|-
literal|5
init|;
name|d
operator|<=
literal|5
condition|;
name|d
operator|++
control|)
block|{
name|error
operator|=
name|dmu_object_info
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
operator|(
literal|1ULL
operator|<<
name|t
operator|)
operator|+
name|d
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ENOENT
operator|||
name|error
operator|==
name|EINVAL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Now kick off all the tests that run in parallel. 	 */
name|zs
operator|->
name|zs_enospc_count
operator|=
literal|0
expr_stmt|;
name|za
operator|=
name|umem_zalloc
argument_list|(
name|zopt_threads
operator|*
sizeof|sizeof
argument_list|(
name|ztest_args_t
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|4
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"starting main threads...\n"
argument_list|)
expr_stmt|;
name|za
index|[
literal|0
index|]
operator|.
name|za_start
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|za
index|[
literal|0
index|]
operator|.
name|za_stop
operator|=
name|za
index|[
literal|0
index|]
operator|.
name|za_start
operator|+
name|zopt_passtime
operator|*
name|NANOSEC
expr_stmt|;
name|za
index|[
literal|0
index|]
operator|.
name|za_stop
operator|=
name|MIN
argument_list|(
name|za
index|[
literal|0
index|]
operator|.
name|za_stop
argument_list|,
name|zs
operator|->
name|zs_stop_time
argument_list|)
expr_stmt|;
name|za
index|[
literal|0
index|]
operator|.
name|za_kill
operator|=
name|za
index|[
literal|0
index|]
operator|.
name|za_stop
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|100
argument_list|)
operator|<
name|zopt_killrate
condition|)
name|za
index|[
literal|0
index|]
operator|.
name|za_kill
operator|-=
name|ztest_random
argument_list|(
name|zopt_passtime
operator|*
name|NANOSEC
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|zopt_threads
condition|;
name|t
operator|++
control|)
block|{
name|d
operator|=
name|t
operator|%
name|zopt_datasets
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|za
index|[
name|t
index|]
operator|.
name|za_pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|za
index|[
name|t
index|]
operator|.
name|za_os
operator|=
name|za
index|[
name|d
index|]
operator|.
name|za_os
expr_stmt|;
name|za
index|[
name|t
index|]
operator|.
name|za_spa
operator|=
name|spa
expr_stmt|;
name|za
index|[
name|t
index|]
operator|.
name|za_zilog
operator|=
name|za
index|[
name|d
index|]
operator|.
name|za_zilog
expr_stmt|;
name|za
index|[
name|t
index|]
operator|.
name|za_instance
operator|=
name|t
expr_stmt|;
name|za
index|[
name|t
index|]
operator|.
name|za_random
operator|=
name|ztest_random
argument_list|(
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
name|za
index|[
name|t
index|]
operator|.
name|za_start
operator|=
name|za
index|[
literal|0
index|]
operator|.
name|za_start
expr_stmt|;
name|za
index|[
name|t
index|]
operator|.
name|za_stop
operator|=
name|za
index|[
literal|0
index|]
operator|.
name|za_stop
expr_stmt|;
name|za
index|[
name|t
index|]
operator|.
name|za_kill
operator|=
name|za
index|[
literal|0
index|]
operator|.
name|za_kill
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|zopt_datasets
condition|)
block|{
name|int
name|test_future
init|=
name|FALSE
decl_stmt|;
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
literal|100
argument_list|,
literal|"%s/%s_%d"
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_create
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ztest_create_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EEXIST
condition|)
block|{
name|test_future
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|zs
operator|->
name|zs_enospc_count
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_create(%s) = %d"
argument_list|,
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|DS_MODE_USER
argument_list|,
operator|&
name|za
index|[
name|d
index|]
operator|.
name|za_os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_open('%s') = %d"
argument_list|,
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_future
condition|)
name|ztest_dmu_check_future_leak
argument_list|(
operator|&
name|za
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|zil_replay
argument_list|(
name|za
index|[
name|d
index|]
operator|.
name|za_os
argument_list|,
name|za
index|[
name|d
index|]
operator|.
name|za_os
argument_list|,
name|ztest_replay_vector
argument_list|)
expr_stmt|;
name|za
index|[
name|d
index|]
operator|.
name|za_zilog
operator|=
name|zil_open
argument_list|(
name|za
index|[
name|d
index|]
operator|.
name|za_os
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|thr_create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ztest_thread
argument_list|,
operator|&
name|za
index|[
name|t
index|]
argument_list|,
name|THR_BOUND
argument_list|,
operator|&
name|za
index|[
name|t
index|]
operator|.
name|za_thread
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|t
operator|>=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|thr_join
argument_list|(
name|za
index|[
name|t
index|]
operator|.
name|za_thread
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|zopt_datasets
condition|)
block|{
name|zil_close
argument_list|(
name|za
index|[
name|t
index|]
operator|.
name|za_zilog
argument_list|)
expr_stmt|;
name|dmu_objset_close
argument_list|(
name|za
index|[
name|t
index|]
operator|.
name|za_os
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zopt_verbose
operator|>=
literal|3
condition|)
name|show_pool_stats
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_alloc
operator|=
name|spa_get_alloc
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_space
operator|=
name|spa_get_space
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * If we had out-of-space errors, destroy a random objset. 	 */
if|if
condition|(
name|zs
operator|->
name|zs_enospc_count
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|int
operator|)
name|ztest_random
argument_list|(
name|zopt_datasets
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
literal|100
argument_list|,
literal|"%s/%s_%d"
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|3
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Destroying %s to free up space\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_objset_find
argument_list|(
name|name
argument_list|,
name|ztest_destroy_cb
argument_list|,
operator|&
name|za
index|[
name|d
index|]
argument_list|,
name|DS_FIND_SNAPSHOTS
operator||
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_shared
operator|->
name|zs_name_lock
argument_list|)
expr_stmt|;
block|}
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|za
argument_list|,
name|zopt_threads
operator|*
sizeof|sizeof
argument_list|(
name|ztest_args_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Kill the resume thread */
name|ztest_exiting
operator|=
name|B_TRUE
expr_stmt|;
name|VERIFY
argument_list|(
name|thr_join
argument_list|(
name|resume_tid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ztest_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Right before closing the pool, kick off a bunch of async I/O; 	 * spa_close() should wait for it to complete. 	 */
for|for
control|(
name|t
operator|=
literal|1
init|;
name|t
operator|<
literal|50
condition|;
name|t
operator|++
control|)
name|dmu_prefetch
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
literal|1
operator|<<
literal|15
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|kernel_fini
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_time
parameter_list|(
name|hrtime_t
name|t
parameter_list|,
name|char
modifier|*
name|timebuf
parameter_list|)
block|{
name|hrtime_t
name|s
init|=
name|t
operator|/
name|NANOSEC
decl_stmt|;
name|hrtime_t
name|m
init|=
name|s
operator|/
literal|60
decl_stmt|;
name|hrtime_t
name|h
init|=
name|m
operator|/
literal|60
decl_stmt|;
name|hrtime_t
name|d
init|=
name|h
operator|/
literal|24
decl_stmt|;
name|s
operator|-=
name|m
operator|*
literal|60
expr_stmt|;
name|m
operator|-=
name|h
operator|*
literal|60
expr_stmt|;
name|h
operator|-=
name|d
operator|*
literal|24
expr_stmt|;
name|timebuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|d
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|timebuf
argument_list|,
literal|"%llud%02lluh%02llum%02llus"
argument_list|,
name|d
argument_list|,
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|timebuf
argument_list|,
literal|"%lluh%02llum%02llus"
argument_list|,
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|timebuf
argument_list|,
literal|"%llum%02llus"
argument_list|,
name|m
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|timebuf
argument_list|,
literal|"%llus"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a storage pool with the given name and initial vdev size.  * Then create the specified number of datasets in the pool.  */
end_comment

begin_function
specifier|static
name|void
name|ztest_init
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|kernel_init
argument_list|(
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Create the storage pool. 	 */
operator|(
name|void
operator|)
name|spa_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|ztest_shared
operator|->
name|zs_vdev_primaries
operator|=
literal|0
expr_stmt|;
name|nvroot
operator|=
name|make_vdev_root
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|zopt_vdev_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|zopt_raidz
argument_list|,
name|zopt_mirrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_create
argument_list|(
name|pool
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_create() = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_open
argument_list|(
name|pool
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_open() = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|metaslab_sz
operator|=
literal|1ULL
operator|<<
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_child
index|[
literal|0
index|]
operator|->
name|vdev_ms_shift
expr_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|3
condition|)
name|show_pool_stats
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|kernel_fini
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|kills
init|=
literal|0
decl_stmt|;
name|int
name|iters
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|f
decl_stmt|;
name|ztest_shared_t
modifier|*
name|zs
decl_stmt|;
name|ztest_info_t
modifier|*
name|zi
decl_stmt|;
name|char
name|timebuf
index|[
literal|100
index|]
decl_stmt|;
name|char
name|numbuf
index|[
literal|6
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Override location of zpool.cache */
name|spa_config_path
operator|=
literal|"/tmp/zpool.cache"
expr_stmt|;
name|ztest_random_fd
operator|=
name|open
argument_list|(
literal|"/dev/urandom"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|process_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* 	 * Blow away any existing copy of zpool.cache 	 */
if|if
condition|(
name|zopt_init
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|remove
argument_list|(
literal|"/tmp/zpool.cache"
argument_list|)
expr_stmt|;
name|zs
operator|=
name|ztest_shared
operator|=
operator|(
name|void
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|P2ROUNDUP
argument_list|(
sizeof|sizeof
argument_list|(
name|ztest_shared_t
argument_list|)
argument_list|,
name|getpagesize
argument_list|()
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
operator||
name|MAP_ANON
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%llu vdevs, %d datasets, %d threads,"
literal|" %llu seconds...\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zopt_vdevs
argument_list|,
name|zopt_datasets
argument_list|,
name|zopt_threads
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zopt_time
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create and initialize our storage pool. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|zopt_init
condition|;
name|i
operator|++
control|)
block|{
name|bzero
argument_list|(
name|zs
argument_list|,
sizeof|sizeof
argument_list|(
name|ztest_shared_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|3
operator|&&
name|zopt_init
operator|!=
literal|1
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ztest_init(), pass %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ztest_init
argument_list|(
name|zopt_pool
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize the call targets for each function. 	 */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|ZTEST_FUNCS
condition|;
name|f
operator|++
control|)
block|{
name|zi
operator|=
operator|&
name|zs
operator|->
name|zs_info
index|[
name|f
index|]
expr_stmt|;
operator|*
name|zi
operator|=
name|ztest_info
index|[
name|f
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|zi
operator|->
name|zi_interval
operator|==
literal|0
condition|)
name|zi
operator|->
name|zi_call_target
operator|=
name|UINT64_MAX
expr_stmt|;
else|else
name|zi
operator|->
name|zi_call_target
operator|=
name|zopt_time
operator|/
operator|*
name|zi
operator|->
name|zi_interval
expr_stmt|;
block|}
name|zs
operator|->
name|zs_start_time
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|zs
operator|->
name|zs_stop_time
operator|=
name|zs
operator|->
name|zs_start_time
operator|+
name|zopt_time
operator|*
name|NANOSEC
expr_stmt|;
comment|/* 	 * Run the tests in a loop.  These tests include fault injection 	 * to verify that self-healing data works, and forced crashes 	 * to verify that we never lose on-disk consistency. 	 */
while|while
condition|(
name|gethrtime
argument_list|()
operator|<
name|zs
operator|->
name|zs_stop_time
condition|)
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
comment|/* 		 * Initialize the workload counters for each function. 		 */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|ZTEST_FUNCS
condition|;
name|f
operator|++
control|)
block|{
name|zi
operator|=
operator|&
name|zs
operator|->
name|zs_info
index|[
name|f
index|]
expr_stmt|;
name|zi
operator|->
name|zi_calls
operator|=
literal|0
expr_stmt|;
name|zi
operator|->
name|zi_call_time
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Set the allocation switch size */
name|metaslab_df_alloc_threshold
operator|=
name|ztest_random
argument_list|(
name|metaslab_sz
operator|/
literal|4
argument_list|)
operator|+
literal|1
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"fork failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* child */
name|struct
name|rlimit
name|rl
init|=
block|{
literal|1024
block|,
literal|1024
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|setrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|rl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|enable_extended_FILE_stdio
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ztest_run
argument_list|(
name|zopt_pool
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|!=
name|pid
condition|)
continue|continue;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"child exited with code %d\n"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
operator|!=
name|SIGKILL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"child died with signal %d\n"
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|kills
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"something strange happened "
literal|"to child\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|iters
operator|++
expr_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|1
condition|)
block|{
name|hrtime_t
name|now
init|=
name|gethrtime
argument_list|()
decl_stmt|;
name|now
operator|=
name|MIN
argument_list|(
name|now
argument_list|,
name|zs
operator|->
name|zs_stop_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
name|zs
operator|->
name|zs_stop_time
operator|-
name|now
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
name|nicenum
argument_list|(
name|zs
operator|->
name|zs_space
argument_list|,
name|numbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Pass %3d, %8s, %3llu ENOSPC, "
literal|"%4.1f%% of %5s used, %3.0f%% done, %8s to go\n"
argument_list|,
name|iters
argument_list|,
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|?
literal|"Complete"
else|:
literal|"SIGKILL"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zs
operator|->
name|zs_enospc_count
argument_list|,
literal|100.0
operator|*
name|zs
operator|->
name|zs_alloc
operator|/
name|zs
operator|->
name|zs_space
argument_list|,
name|numbuf
argument_list|,
literal|100.0
operator|*
operator|(
name|now
operator|-
name|zs
operator|->
name|zs_start_time
operator|)
operator|/
operator|(
name|zopt_time
operator|*
name|NANOSEC
operator|)
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zopt_verbose
operator|>=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\nWorkload summary:\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%7s %9s   %s\n"
argument_list|,
literal|"Calls"
argument_list|,
literal|"Time"
argument_list|,
literal|"Function"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%7s %9s   %s\n"
argument_list|,
literal|"-----"
argument_list|,
literal|"----"
argument_list|,
literal|"--------"
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|ZTEST_FUNCS
condition|;
name|f
operator|++
control|)
block|{
name|Dl_info
name|dli
decl_stmt|;
name|zi
operator|=
operator|&
name|zs
operator|->
name|zs_info
index|[
name|f
index|]
expr_stmt|;
name|print_time
argument_list|(
name|zi
operator|->
name|zi_call_time
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dladdr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|zi
operator|->
name|zi_func
argument_list|,
operator|&
name|dli
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%7llu %9s   %s\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zi
operator|->
name|zi_calls
argument_list|,
name|timebuf
argument_list|,
name|dli
operator|.
name|dli_sname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * It's possible that we killed a child during a rename test, in 		 * which case we'll have a 'ztest_tmp' pool lying around instead 		 * of 'ztest'.  Do a blind rename in case this happened. 		 */
name|tmp
operator|=
name|umem_alloc
argument_list|(
name|strlen
argument_list|(
name|zopt_pool
argument_list|)
operator|+
literal|5
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|zopt_pool
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tmp
argument_list|,
literal|"_tmp"
argument_list|)
expr_stmt|;
name|kernel_init
argument_list|(
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_rename
argument_list|(
name|tmp
argument_list|,
name|zopt_pool
argument_list|)
expr_stmt|;
name|kernel_fini
argument_list|()
expr_stmt|;
name|umem_free
argument_list|(
name|tmp
argument_list|,
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|ztest_verify_blocks
argument_list|(
name|zopt_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|zopt_verbose
operator|>=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d killed, %d completed, %.0f%% kill rate\n"
argument_list|,
name|kills
argument_list|,
name|iters
operator|-
name|kills
argument_list|,
operator|(
literal|100.0
operator|*
name|kills
operator|)
operator|/
name|MAX
argument_list|(
literal|1
argument_list|,
name|iters
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

