begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2016 by Delphix. All rights reserved.  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.  * Copyright (c) 2012 Martin Matuska<mm@FreeBSD.org>.  All rights reserved.  * Copyright (c) 2013 Steven Hartland. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_comment
comment|/*  * The objective of this program is to provide a DMU/ZAP/SPA stress test  * that runs entirely in userland, is easy to use, and easy to extend.  *  * The overall design of the ztest program is as follows:  *  * (1) For each major functional area (e.g. adding vdevs to a pool,  *     creating and destroying datasets, reading and writing objects, etc)  *     we have a simple routine to test that functionality.  These  *     individual routines do not have to do anything "stressful".  *  * (2) We turn these simple functionality tests into a stress test by  *     running them all in parallel, with as many threads as desired,  *     and spread across as many datasets, objects, and vdevs as desired.  *  * (3) While all this is happening, we inject faults into the pool to  *     verify that self-healing data really works.  *  * (4) Every time we open a dataset, we change its checksum and compression  *     functions.  Thus even individual objects vary from block to block  *     in which checksum they use and whether they're compressed.  *  * (5) To verify that we never lose on-disk consistency after a crash,  *     we run the entire test in a child of the main process.  *     At random times, the child self-immolates with a SIGKILL.  *     This is the software equivalent of pulling the power cord.  *     The parent then runs the test again, using the existing  *     storage pool, as many times as desired. If backwards compatibility  *     testing is enabled ztest will sometimes run the "older" version  *     of ztest after a SIGKILL.  *  * (6) To verify that we don't have future leaks or temporal incursions,  *     many of the functional tests record the transaction group number  *     as part of their data.  When reading old data, they verify that  *     the transaction group number is less than the current, open txg.  *     If you add a new test, please do this if applicable.  *  * When run with no arguments, ztest runs for about five minutes and  * produces no output if successful.  To get a little bit of information,  * specify -V.  To get more information, specify -VV, and so on.  *  * To turn this into an overnight stress test, use -T to specify run time.  *  * You can ask more more vdevs [-v], datasets [-d], or threads [-t]  * to increase the pool capacity, fanout, and overall stress level.  *  * Use the -k option to set the desired frequency of kills.  *  * When ztest invokes itself it passes all relevant information through a  * temporary file which is mmap-ed in the child process. This allows shared  * memory to survive the exec syscall. The ztest_shared_hdr_t struct is always  * stored at offset 0 of this file and contains information on the size and  * number of shared structures in the file. The information stored in this file  * must remain backwards compatible with older versions of ztest so that  * ztest can invoke them during backwards compatibility testing (-B).  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_file.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_destroy.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_scan.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_userhold.h>
end_include

begin_include
include|#
directive|include
file|<sys/abd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdio_ext.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<umem.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<libnvpair.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|ztest_fd_data
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ztest_fd_rand
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|ztest_shared_hdr
block|{
name|uint64_t
name|zh_hdr_size
decl_stmt|;
name|uint64_t
name|zh_opts_size
decl_stmt|;
name|uint64_t
name|zh_size
decl_stmt|;
name|uint64_t
name|zh_stats_size
decl_stmt|;
name|uint64_t
name|zh_stats_count
decl_stmt|;
name|uint64_t
name|zh_ds_size
decl_stmt|;
name|uint64_t
name|zh_ds_count
decl_stmt|;
block|}
name|ztest_shared_hdr_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ztest_shared_hdr_t
modifier|*
name|ztest_shared_hdr
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|ztest_shared_opts
block|{
name|char
name|zo_pool
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|zo_dir
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|zo_alt_ztest
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|char
name|zo_alt_libpath
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|uint64_t
name|zo_vdevs
decl_stmt|;
name|uint64_t
name|zo_vdevtime
decl_stmt|;
name|size_t
name|zo_vdev_size
decl_stmt|;
name|int
name|zo_ashift
decl_stmt|;
name|int
name|zo_mirrors
decl_stmt|;
name|int
name|zo_raidz
decl_stmt|;
name|int
name|zo_raidz_parity
decl_stmt|;
name|int
name|zo_datasets
decl_stmt|;
name|int
name|zo_threads
decl_stmt|;
name|uint64_t
name|zo_passtime
decl_stmt|;
name|uint64_t
name|zo_killrate
decl_stmt|;
name|int
name|zo_verbose
decl_stmt|;
name|int
name|zo_init
decl_stmt|;
name|uint64_t
name|zo_time
decl_stmt|;
name|uint64_t
name|zo_maxloops
decl_stmt|;
name|uint64_t
name|zo_metaslab_gang_bang
decl_stmt|;
block|}
name|ztest_shared_opts_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|ztest_shared_opts_t
name|ztest_opts_defaults
init|=
block|{
operator|.
name|zo_pool
operator|=
block|{
literal|'z'
block|,
literal|'t'
block|,
literal|'e'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'\0'
block|}
block|,
operator|.
name|zo_dir
operator|=
block|{
literal|'/'
block|,
literal|'t'
block|,
literal|'m'
block|,
literal|'p'
block|,
literal|'\0'
block|}
block|,
operator|.
name|zo_alt_ztest
operator|=
block|{
literal|'\0'
block|}
block|,
operator|.
name|zo_alt_libpath
operator|=
block|{
literal|'\0'
block|}
block|,
operator|.
name|zo_vdevs
operator|=
literal|5
block|,
operator|.
name|zo_ashift
operator|=
name|SPA_MINBLOCKSHIFT
block|,
operator|.
name|zo_mirrors
operator|=
literal|2
block|,
operator|.
name|zo_raidz
operator|=
literal|4
block|,
operator|.
name|zo_raidz_parity
operator|=
literal|1
block|,
operator|.
name|zo_vdev_size
operator|=
name|SPA_MINDEVSIZE
operator|*
literal|4
block|,
comment|/* 256m default size */
operator|.
name|zo_datasets
operator|=
literal|7
block|,
operator|.
name|zo_threads
operator|=
literal|23
block|,
operator|.
name|zo_passtime
operator|=
literal|60
block|,
comment|/* 60 seconds */
operator|.
name|zo_killrate
operator|=
literal|70
block|,
comment|/* 70% kill rate */
operator|.
name|zo_verbose
operator|=
literal|0
block|,
operator|.
name|zo_init
operator|=
literal|1
block|,
operator|.
name|zo_time
operator|=
literal|300
block|,
comment|/* 5 minutes */
operator|.
name|zo_maxloops
operator|=
literal|50
block|,
comment|/* max loops during spa_freeze() */
operator|.
name|zo_metaslab_gang_bang
operator|=
literal|32
operator|<<
literal|10
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|uint64_t
name|metaslab_gang_bang
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|uint64_t
name|metaslab_df_alloc_threshold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|uint64_t
name|zfs_deadman_synctime_ms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|metaslab_preload_limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean_t
name|zfs_compressed_arc_enabled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean_t
name|zfs_abd_scatter_enabled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ztest_shared_opts_t
modifier|*
name|ztest_shared_opts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ztest_shared_opts_t
name|ztest_opts
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|ztest_shared_ds
block|{
name|uint64_t
name|zd_seq
decl_stmt|;
block|}
name|ztest_shared_ds_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ztest_shared_ds_t
modifier|*
name|ztest_shared_ds
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ZTEST_GET_SHARED_DS
parameter_list|(
name|d
parameter_list|)
value|(&ztest_shared_ds[d])
end_define

begin_define
define|#
directive|define
name|BT_MAGIC
value|0x123456789abcdefULL
end_define

begin_define
define|#
directive|define
name|MAXFAULTS
parameter_list|()
define|\
value|(MAX(zs->zs_mirrors, 1) * (ztest_opts.zo_raidz_parity + 1) - 1)
end_define

begin_enum
enum|enum
name|ztest_io_type
block|{
name|ZTEST_IO_WRITE_TAG
block|,
name|ZTEST_IO_WRITE_PATTERN
block|,
name|ZTEST_IO_WRITE_ZEROES
block|,
name|ZTEST_IO_TRUNCATE
block|,
name|ZTEST_IO_SETATTR
block|,
name|ZTEST_IO_REWRITE
block|,
name|ZTEST_IO_TYPES
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
struct|struct
name|ztest_block_tag
block|{
name|uint64_t
name|bt_magic
decl_stmt|;
name|uint64_t
name|bt_objset
decl_stmt|;
name|uint64_t
name|bt_object
decl_stmt|;
name|uint64_t
name|bt_offset
decl_stmt|;
name|uint64_t
name|bt_gen
decl_stmt|;
name|uint64_t
name|bt_txg
decl_stmt|;
name|uint64_t
name|bt_crtxg
decl_stmt|;
block|}
name|ztest_block_tag_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|bufwad
block|{
name|uint64_t
name|bw_index
decl_stmt|;
name|uint64_t
name|bw_txg
decl_stmt|;
name|uint64_t
name|bw_data
decl_stmt|;
block|}
name|bufwad_t
typedef|;
end_typedef

begin_comment
comment|/*  * XXX -- fix zfs range locks to be generic so we can use them here.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|RL_READER
block|,
name|RL_WRITER
block|,
name|RL_APPEND
block|}
name|rl_type_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|rll
block|{
name|void
modifier|*
name|rll_writer
decl_stmt|;
name|int
name|rll_readers
decl_stmt|;
name|mutex_t
name|rll_lock
decl_stmt|;
name|cond_t
name|rll_cv
decl_stmt|;
block|}
name|rll_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|rl
block|{
name|uint64_t
name|rl_object
decl_stmt|;
name|uint64_t
name|rl_offset
decl_stmt|;
name|uint64_t
name|rl_size
decl_stmt|;
name|rll_t
modifier|*
name|rl_lock
decl_stmt|;
block|}
name|rl_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ZTEST_RANGE_LOCKS
value|64
end_define

begin_define
define|#
directive|define
name|ZTEST_OBJECT_LOCKS
value|64
end_define

begin_comment
comment|/*  * Object descriptor.  Used as a template for object lookup/create/remove.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ztest_od
block|{
name|uint64_t
name|od_dir
decl_stmt|;
name|uint64_t
name|od_object
decl_stmt|;
name|dmu_object_type_t
name|od_type
decl_stmt|;
name|dmu_object_type_t
name|od_crtype
decl_stmt|;
name|uint64_t
name|od_blocksize
decl_stmt|;
name|uint64_t
name|od_crblocksize
decl_stmt|;
name|uint64_t
name|od_gen
decl_stmt|;
name|uint64_t
name|od_crgen
decl_stmt|;
name|char
name|od_name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
block|}
name|ztest_od_t
typedef|;
end_typedef

begin_comment
comment|/*  * Per-dataset state.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ztest_ds
block|{
name|ztest_shared_ds_t
modifier|*
name|zd_shared
decl_stmt|;
name|objset_t
modifier|*
name|zd_os
decl_stmt|;
name|rwlock_t
name|zd_zilog_lock
decl_stmt|;
name|zilog_t
modifier|*
name|zd_zilog
decl_stmt|;
name|ztest_od_t
modifier|*
name|zd_od
decl_stmt|;
comment|/* debugging aid */
name|char
name|zd_name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|mutex_t
name|zd_dirobj_lock
decl_stmt|;
name|rll_t
name|zd_object_lock
index|[
name|ZTEST_OBJECT_LOCKS
index|]
decl_stmt|;
name|rll_t
name|zd_range_lock
index|[
name|ZTEST_RANGE_LOCKS
index|]
decl_stmt|;
block|}
name|ztest_ds_t
typedef|;
end_typedef

begin_comment
comment|/*  * Per-iteration state.  */
end_comment

begin_typedef
typedef|typedef
name|void
name|ztest_func_t
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ztest_info
block|{
name|ztest_func_t
modifier|*
name|zi_func
decl_stmt|;
comment|/* test function */
name|uint64_t
name|zi_iters
decl_stmt|;
comment|/* iterations per execution */
name|uint64_t
modifier|*
name|zi_interval
decl_stmt|;
comment|/* execute every<interval> seconds */
block|}
name|ztest_info_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ztest_shared_callstate
block|{
name|uint64_t
name|zc_count
decl_stmt|;
comment|/* per-pass count */
name|uint64_t
name|zc_time
decl_stmt|;
comment|/* per-pass time */
name|uint64_t
name|zc_next
decl_stmt|;
comment|/* next time to call this function */
block|}
name|ztest_shared_callstate_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ztest_shared_callstate_t
modifier|*
name|ztest_shared_callstate
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ZTEST_GET_SHARED_CALLSTATE
parameter_list|(
name|c
parameter_list|)
value|(&ztest_shared_callstate[c])
end_define

begin_comment
comment|/*  * Note: these aren't static because we want dladdr() to work.  */
end_comment

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_read_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_write_parallel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_object_alloc_free
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_commit_callbacks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_zap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_zap_parallel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_zil_commit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_zil_remount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_read_write_zcopy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_objset_create_destroy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_prealloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_fzap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_snapshot_create_destroy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dsl_prop_get_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_spa_prop_get_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_spa_create_destroy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_fault_inject
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_ddt_repair
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dmu_snapshot_hold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_spa_rename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_scrub
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_dsl_dataset_promote_busy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_vdev_attach_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_vdev_LUN_growth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_vdev_add_remove
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_vdev_aux_add_remove
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_split_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_reguid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_func_t
name|ztest_spa_upgrade
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|zopt_always
init|=
literal|0ULL
operator|*
name|NANOSEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* all the time */
end_comment

begin_decl_stmt
name|uint64_t
name|zopt_incessant
init|=
literal|1ULL
operator|*
name|NANOSEC
operator|/
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* every 1/10 second */
end_comment

begin_decl_stmt
name|uint64_t
name|zopt_often
init|=
literal|1ULL
operator|*
name|NANOSEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* every second */
end_comment

begin_decl_stmt
name|uint64_t
name|zopt_sometimes
init|=
literal|10ULL
operator|*
name|NANOSEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* every 10 seconds */
end_comment

begin_decl_stmt
name|uint64_t
name|zopt_rarely
init|=
literal|60ULL
operator|*
name|NANOSEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* every 60 seconds */
end_comment

begin_decl_stmt
name|ztest_info_t
name|ztest_info
index|[]
init|=
block|{
block|{
name|ztest_dmu_read_write
block|,
literal|1
block|,
operator|&
name|zopt_always
block|}
block|,
block|{
name|ztest_dmu_write_parallel
block|,
literal|10
block|,
operator|&
name|zopt_always
block|}
block|,
block|{
name|ztest_dmu_object_alloc_free
block|,
literal|1
block|,
operator|&
name|zopt_always
block|}
block|,
block|{
name|ztest_dmu_commit_callbacks
block|,
literal|1
block|,
operator|&
name|zopt_always
block|}
block|,
block|{
name|ztest_zap
block|,
literal|30
block|,
operator|&
name|zopt_always
block|}
block|,
block|{
name|ztest_zap_parallel
block|,
literal|100
block|,
operator|&
name|zopt_always
block|}
block|,
block|{
name|ztest_split_pool
block|,
literal|1
block|,
operator|&
name|zopt_always
block|}
block|,
block|{
name|ztest_zil_commit
block|,
literal|1
block|,
operator|&
name|zopt_incessant
block|}
block|,
block|{
name|ztest_zil_remount
block|,
literal|1
block|,
operator|&
name|zopt_sometimes
block|}
block|,
block|{
name|ztest_dmu_read_write_zcopy
block|,
literal|1
block|,
operator|&
name|zopt_often
block|}
block|,
block|{
name|ztest_dmu_objset_create_destroy
block|,
literal|1
block|,
operator|&
name|zopt_often
block|}
block|,
block|{
name|ztest_dsl_prop_get_set
block|,
literal|1
block|,
operator|&
name|zopt_often
block|}
block|,
block|{
name|ztest_spa_prop_get_set
block|,
literal|1
block|,
operator|&
name|zopt_sometimes
block|}
block|,
if|#
directive|if
literal|0
block|{ ztest_dmu_prealloc,			1,&zopt_sometimes	},
endif|#
directive|endif
block|{
name|ztest_fzap
block|,
literal|1
block|,
operator|&
name|zopt_sometimes
block|}
block|,
block|{
name|ztest_dmu_snapshot_create_destroy
block|,
literal|1
block|,
operator|&
name|zopt_sometimes
block|}
block|,
block|{
name|ztest_spa_create_destroy
block|,
literal|1
block|,
operator|&
name|zopt_sometimes
block|}
block|,
block|{
name|ztest_fault_inject
block|,
literal|1
block|,
operator|&
name|zopt_sometimes
block|}
block|,
block|{
name|ztest_ddt_repair
block|,
literal|1
block|,
operator|&
name|zopt_sometimes
block|}
block|,
block|{
name|ztest_dmu_snapshot_hold
block|,
literal|1
block|,
operator|&
name|zopt_sometimes
block|}
block|,
block|{
name|ztest_reguid
block|,
literal|1
block|,
operator|&
name|zopt_rarely
block|}
block|,
block|{
name|ztest_spa_rename
block|,
literal|1
block|,
operator|&
name|zopt_rarely
block|}
block|,
block|{
name|ztest_scrub
block|,
literal|1
block|,
operator|&
name|zopt_rarely
block|}
block|,
block|{
name|ztest_spa_upgrade
block|,
literal|1
block|,
operator|&
name|zopt_rarely
block|}
block|,
block|{
name|ztest_dsl_dataset_promote_busy
block|,
literal|1
block|,
operator|&
name|zopt_rarely
block|}
block|,
block|{
name|ztest_vdev_attach_detach
block|,
literal|1
block|,
operator|&
name|zopt_sometimes
block|}
block|,
block|{
name|ztest_vdev_LUN_growth
block|,
literal|1
block|,
operator|&
name|zopt_rarely
block|}
block|,
block|{
name|ztest_vdev_add_remove
block|,
literal|1
block|,
operator|&
name|ztest_opts
operator|.
name|zo_vdevtime
block|}
block|,
block|{
name|ztest_vdev_aux_add_remove
block|,
literal|1
block|,
operator|&
name|ztest_opts
operator|.
name|zo_vdevtime
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ZTEST_FUNCS
value|(sizeof (ztest_info) / sizeof (ztest_info_t))
end_define

begin_comment
comment|/*  * The following struct is used to hold a list of uncalled commit callbacks.  * The callbacks are ordered by txg number.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ztest_cb_list
block|{
name|mutex_t
name|zcl_callbacks_lock
decl_stmt|;
name|list_t
name|zcl_callbacks
decl_stmt|;
block|}
name|ztest_cb_list_t
typedef|;
end_typedef

begin_comment
comment|/*  * Stuff we need to share writably between parent and child.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ztest_shared
block|{
name|boolean_t
name|zs_do_init
decl_stmt|;
name|hrtime_t
name|zs_proc_start
decl_stmt|;
name|hrtime_t
name|zs_proc_stop
decl_stmt|;
name|hrtime_t
name|zs_thread_start
decl_stmt|;
name|hrtime_t
name|zs_thread_stop
decl_stmt|;
name|hrtime_t
name|zs_thread_kill
decl_stmt|;
name|uint64_t
name|zs_enospc_count
decl_stmt|;
name|uint64_t
name|zs_vdev_next_leaf
decl_stmt|;
name|uint64_t
name|zs_vdev_aux
decl_stmt|;
name|uint64_t
name|zs_alloc
decl_stmt|;
name|uint64_t
name|zs_space
decl_stmt|;
name|uint64_t
name|zs_splits
decl_stmt|;
name|uint64_t
name|zs_mirrors
decl_stmt|;
name|uint64_t
name|zs_metaslab_sz
decl_stmt|;
name|uint64_t
name|zs_metaslab_df_alloc_threshold
decl_stmt|;
name|uint64_t
name|zs_guid
decl_stmt|;
block|}
name|ztest_shared_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ID_PARALLEL
value|-1ULL
end_define

begin_decl_stmt
specifier|static
name|char
name|ztest_dev_template
index|[]
init|=
literal|"%s/%s.%llua"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ztest_aux_template
index|[]
init|=
literal|"%s/%s.%s.%llu"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ztest_shared_t
modifier|*
name|ztest_shared
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|spa_t
modifier|*
name|ztest_spa
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ztest_ds_t
modifier|*
name|ztest_ds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mutex_t
name|ztest_vdev_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The ztest_name_lock protects the pool and dataset namespace used by  * the individual tests. To modify the namespace, consumers must grab  * this lock as writer. Grabbing the lock as reader will ensure that the  * namespace does not change while the lock is held.  */
end_comment

begin_decl_stmt
specifier|static
name|rwlock_t
name|ztest_name_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean_t
name|ztest_dump_core
init|=
name|B_TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean_t
name|ztest_exiting
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global commit callback list */
end_comment

begin_decl_stmt
specifier|static
name|ztest_cb_list_t
name|zcl
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|ztest_object
block|{
name|ZTEST_META_DNODE
init|=
literal|0
block|,
name|ZTEST_DIROBJ
block|,
name|ZTEST_OBJECTS
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|usage
argument_list|(
name|boolean_t
argument_list|)
name|__NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These libumem hooks provide a reasonable set of defaults for the allocator's  * debugging facilities.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|_umem_debug_init
parameter_list|()
block|{
return|return
operator|(
literal|"default,verbose"
operator|)
return|;
comment|/* $UMEM_DEBUG setting */
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|_umem_logging_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|"fail,contents"
operator|)
return|;
comment|/* $UMEM_LOGGING setting */
block|}
end_function

begin_define
define|#
directive|define
name|FATAL_MSG_SZ
value|1024
end_define

begin_decl_stmt
name|char
modifier|*
name|fatal_msg
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|fatal
parameter_list|(
name|int
name|do_perror
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|char
name|buf
index|[
name|FATAL_MSG_SZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|message
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"ztest: "
argument_list|)
expr_stmt|;
comment|/* LINTED */
operator|(
name|void
operator|)
name|vsprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_perror
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|FATAL_MSG_SZ
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|": %s"
argument_list|,
name|strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fatal_msg
operator|=
name|buf
expr_stmt|;
comment|/* to ease debugging */
if|if
condition|(
name|ztest_dump_core
condition|)
name|abort
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|str2shift
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ends
init|=
literal|"BKMGTPEZ"
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|ends
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|toupper
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
operator|==
name|ends
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|strlen
argument_list|(
name|ends
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ztest: invalid bytes suffix: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|toupper
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'B'
operator|&&
name|buf
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
return|return
operator|(
literal|10
operator|*
name|i
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ztest: invalid bytes suffix: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|nicenumtoull
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|strtoull
argument_list|(
name|buf
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|buf
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ztest: bad numeric value: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|double
name|fval
init|=
name|strtod
argument_list|(
name|buf
argument_list|,
operator|&
name|end
argument_list|)
decl_stmt|;
name|fval
operator|*=
name|pow
argument_list|(
literal|2
argument_list|,
name|str2shift
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fval
operator|>
name|UINT64_MAX
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ztest: value too large: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
operator|(
name|uint64_t
operator|)
name|fval
expr_stmt|;
block|}
else|else
block|{
name|int
name|shift
init|=
name|str2shift
argument_list|(
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|shift
operator|>=
literal|64
operator|||
operator|(
name|val
operator|<<
name|shift
operator|)
operator|>>
name|shift
operator|!=
name|val
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ztest: value too large: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|val
operator|<<=
name|shift
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|boolean_t
name|requested
parameter_list|)
block|{
specifier|const
name|ztest_shared_opts_t
modifier|*
name|zo
init|=
operator|&
name|ztest_opts_defaults
decl_stmt|;
name|char
name|nice_vdev_size
index|[
literal|10
index|]
decl_stmt|;
name|char
name|nice_gang_bang
index|[
literal|10
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|requested
condition|?
name|stdout
else|:
name|stderr
decl_stmt|;
name|nicenum
argument_list|(
name|zo
operator|->
name|zo_vdev_size
argument_list|,
name|nice_vdev_size
argument_list|)
expr_stmt|;
name|nicenum
argument_list|(
name|zo
operator|->
name|zo_metaslab_gang_bang
argument_list|,
name|nice_gang_bang
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Usage: %s\n"
literal|"\t[-v vdevs (default: %llu)]\n"
literal|"\t[-s size_of_each_vdev (default: %s)]\n"
literal|"\t[-a alignment_shift (default: %d)] use 0 for random\n"
literal|"\t[-m mirror_copies (default: %d)]\n"
literal|"\t[-r raidz_disks (default: %d)]\n"
literal|"\t[-R raidz_parity (default: %d)]\n"
literal|"\t[-d datasets (default: %d)]\n"
literal|"\t[-t threads (default: %d)]\n"
literal|"\t[-g gang_block_threshold (default: %s)]\n"
literal|"\t[-i init_count (default: %d)] initialize pool i times\n"
literal|"\t[-k kill_percentage (default: %llu%%)]\n"
literal|"\t[-p pool_name (default: %s)]\n"
literal|"\t[-f dir (default: %s)] file directory for vdev files\n"
literal|"\t[-V] verbose (use multiple times for ever more blather)\n"
literal|"\t[-E] use existing pool instead of creating new one\n"
literal|"\t[-T time (default: %llu sec)] total run time\n"
literal|"\t[-F freezeloops (default: %llu)] max loops in spa_freeze()\n"
literal|"\t[-P passtime (default: %llu sec)] time per pass\n"
literal|"\t[-B alt_ztest (default:<none>)] alternate ztest path\n"
literal|"\t[-h] (print help)\n"
literal|""
argument_list|,
name|zo
operator|->
name|zo_pool
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zo
operator|->
name|zo_vdevs
argument_list|,
comment|/* -v */
name|nice_vdev_size
argument_list|,
comment|/* -s */
name|zo
operator|->
name|zo_ashift
argument_list|,
comment|/* -a */
name|zo
operator|->
name|zo_mirrors
argument_list|,
comment|/* -m */
name|zo
operator|->
name|zo_raidz
argument_list|,
comment|/* -r */
name|zo
operator|->
name|zo_raidz_parity
argument_list|,
comment|/* -R */
name|zo
operator|->
name|zo_datasets
argument_list|,
comment|/* -d */
name|zo
operator|->
name|zo_threads
argument_list|,
comment|/* -t */
name|nice_gang_bang
argument_list|,
comment|/* -g */
name|zo
operator|->
name|zo_init
argument_list|,
comment|/* -i */
operator|(
name|u_longlong_t
operator|)
name|zo
operator|->
name|zo_killrate
argument_list|,
comment|/* -k */
name|zo
operator|->
name|zo_pool
argument_list|,
comment|/* -p */
name|zo
operator|->
name|zo_dir
argument_list|,
comment|/* -f */
operator|(
name|u_longlong_t
operator|)
name|zo
operator|->
name|zo_time
argument_list|,
comment|/* -T */
operator|(
name|u_longlong_t
operator|)
name|zo
operator|->
name|zo_maxloops
argument_list|,
comment|/* -F */
operator|(
name|u_longlong_t
operator|)
name|zo
operator|->
name|zo_passtime
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|requested
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_options
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|ztest_shared_opts_t
modifier|*
name|zo
init|=
operator|&
name|ztest_opts
decl_stmt|;
name|int
name|opt
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|char
name|altdir
index|[
name|MAXNAMELEN
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|ztest_opts_defaults
argument_list|,
name|zo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zo
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"v:s:a:m:r:R:d:t:g:i:k:p:f:VET:P:hF:B:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|value
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'v'
case|:
case|case
literal|'s'
case|:
case|case
literal|'a'
case|:
case|case
literal|'m'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
case|case
literal|'d'
case|:
case|case
literal|'t'
case|:
case|case
literal|'g'
case|:
case|case
literal|'i'
case|:
case|case
literal|'k'
case|:
case|case
literal|'T'
case|:
case|case
literal|'P'
case|:
case|case
literal|'F'
case|:
name|value
operator|=
name|nicenumtoull
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'v'
case|:
name|zo
operator|->
name|zo_vdevs
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|zo
operator|->
name|zo_vdev_size
operator|=
name|MAX
argument_list|(
name|SPA_MINDEVSIZE
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|zo
operator|->
name|zo_ashift
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|zo
operator|->
name|zo_mirrors
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|zo
operator|->
name|zo_raidz
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|zo
operator|->
name|zo_raidz_parity
operator|=
name|MIN
argument_list|(
name|MAX
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|zo
operator|->
name|zo_datasets
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|zo
operator|->
name|zo_threads
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|zo
operator|->
name|zo_metaslab_gang_bang
operator|=
name|MAX
argument_list|(
name|SPA_MINBLOCKSIZE
operator|<<
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|zo
operator|->
name|zo_init
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|zo
operator|->
name|zo_killrate
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zo
operator|->
name|zo_pool
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|zo
operator|->
name|zo_pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|path
operator|=
name|realpath
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: %s: %s\n"
argument_list|,
name|optarg
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zo
operator|->
name|zo_dir
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|zo
operator|->
name|zo_dir
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
name|zo
operator|->
name|zo_verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|zo
operator|->
name|zo_init
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|zo
operator|->
name|zo_time
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|zo
operator|->
name|zo_passtime
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|zo
operator|->
name|zo_maxloops
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|altdir
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|altdir
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|B_TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|zo
operator|->
name|zo_raidz_parity
operator|=
name|MIN
argument_list|(
name|zo
operator|->
name|zo_raidz_parity
argument_list|,
name|zo
operator|->
name|zo_raidz
operator|-
literal|1
argument_list|)
expr_stmt|;
name|zo
operator|->
name|zo_vdevtime
operator|=
operator|(
name|zo
operator|->
name|zo_vdevs
operator|>
literal|0
condition|?
name|zo
operator|->
name|zo_time
operator|*
name|NANOSEC
operator|/
name|zo
operator|->
name|zo_vdevs
else|:
name|UINT64_MAX
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|altdir
argument_list|)
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|realaltdir
decl_stmt|;
name|char
modifier|*
name|bin
decl_stmt|;
name|char
modifier|*
name|ztest
decl_stmt|;
name|char
modifier|*
name|isa
decl_stmt|;
name|int
name|isalen
decl_stmt|;
name|cmd
operator|=
name|umem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
name|realaltdir
operator|=
name|umem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|NULL
operator|!=
name|realpath
argument_list|(
name|getexecname
argument_list|()
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|access
argument_list|(
name|altdir
argument_list|,
name|F_OK
argument_list|)
condition|)
block|{
name|ztest_dump_core
operator|=
name|B_FALSE
expr_stmt|;
name|fatal
argument_list|(
name|B_TRUE
argument_list|,
literal|"invalid alternate ztest path: %s"
argument_list|,
name|altdir
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|NULL
operator|!=
name|realpath
argument_list|(
name|altdir
argument_list|,
name|realaltdir
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * 'cmd' should be of the form "<anything>/usr/bin/<isa>/ztest". 		 * We want to extract<isa> to determine if we should use 		 * 32 or 64 bit binaries. 		 */
name|bin
operator|=
name|strstr
argument_list|(
name|cmd
argument_list|,
literal|"/usr/bin/"
argument_list|)
expr_stmt|;
name|ztest
operator|=
name|strstr
argument_list|(
name|bin
argument_list|,
literal|"/ztest"
argument_list|)
expr_stmt|;
name|isa
operator|=
name|bin
operator|+
literal|9
expr_stmt|;
name|isalen
operator|=
name|ztest
operator|-
name|isa
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|zo
operator|->
name|zo_alt_ztest
argument_list|,
sizeof|sizeof
argument_list|(
name|zo
operator|->
name|zo_alt_ztest
argument_list|)
argument_list|,
literal|"%s/usr/bin/%.*s/ztest"
argument_list|,
name|realaltdir
argument_list|,
name|isalen
argument_list|,
name|isa
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|zo
operator|->
name|zo_alt_libpath
argument_list|,
sizeof|sizeof
argument_list|(
name|zo
operator|->
name|zo_alt_libpath
argument_list|)
argument_list|,
literal|"%s/usr/lib/%.*s"
argument_list|,
name|realaltdir
argument_list|,
name|isalen
argument_list|,
name|isa
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|access
argument_list|(
name|zo
operator|->
name|zo_alt_ztest
argument_list|,
name|X_OK
argument_list|)
condition|)
block|{
name|ztest_dump_core
operator|=
name|B_FALSE
expr_stmt|;
name|fatal
argument_list|(
name|B_TRUE
argument_list|,
literal|"invalid alternate ztest: %s"
argument_list|,
name|zo
operator|->
name|zo_alt_ztest
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|!=
name|access
argument_list|(
name|zo
operator|->
name|zo_alt_libpath
argument_list|,
name|X_OK
argument_list|)
condition|)
block|{
name|ztest_dump_core
operator|=
name|B_FALSE
expr_stmt|;
name|fatal
argument_list|(
name|B_TRUE
argument_list|,
literal|"invalid alternate lib directory %s"
argument_list|,
name|zo
operator|->
name|zo_alt_libpath
argument_list|)
expr_stmt|;
block|}
name|umem_free
argument_list|(
name|cmd
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|realaltdir
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_kill
parameter_list|(
name|ztest_shared_t
modifier|*
name|zs
parameter_list|)
block|{
name|zs
operator|->
name|zs_alloc
operator|=
name|metaslab_class_get_alloc
argument_list|(
name|spa_normal_class
argument_list|(
name|ztest_spa
argument_list|)
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_space
operator|=
name|metaslab_class_get_space
argument_list|(
name|spa_normal_class
argument_list|(
name|ztest_spa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Before we kill off ztest, make sure that the config is updated. 	 * See comment above spa_config_sync(). 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_config_sync
argument_list|(
name|ztest_spa
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|zfs_dbgmsg_print
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ztest_random
parameter_list|(
name|uint64_t
name|range
parameter_list|)
block|{
name|uint64_t
name|r
decl_stmt|;
name|ASSERT3S
argument_list|(
name|ztest_fd_rand
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|range
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|read
argument_list|(
name|ztest_fd_rand
argument_list|,
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|r
argument_list|)
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"short read from /dev/urandom"
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|%
name|range
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|ztest_record_enospc
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|ztest_shared
operator|->
name|zs_enospc_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ztest_get_ashift
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ztest_opts
operator|.
name|zo_ashift
operator|==
literal|0
condition|)
return|return
operator|(
name|SPA_MINBLOCKSHIFT
operator|+
name|ztest_random
argument_list|(
literal|5
argument_list|)
operator|)
return|;
return|return
operator|(
name|ztest_opts
operator|.
name|zo_ashift
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|nvlist_t
modifier|*
name|make_vdev_file
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|aux
parameter_list|,
name|char
modifier|*
name|pool
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|ashift
parameter_list|)
block|{
name|char
name|pathbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|uint64_t
name|vdev
decl_stmt|;
name|nvlist_t
modifier|*
name|file
decl_stmt|;
if|if
condition|(
name|ashift
operator|==
literal|0
condition|)
name|ashift
operator|=
name|ztest_get_ashift
argument_list|()
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|path
operator|=
name|pathbuf
expr_stmt|;
if|if
condition|(
name|aux
operator|!=
name|NULL
condition|)
block|{
name|vdev
operator|=
name|ztest_shared
operator|->
name|zs_vdev_aux
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf
argument_list|)
argument_list|,
name|ztest_aux_template
argument_list|,
name|ztest_opts
operator|.
name|zo_dir
argument_list|,
name|pool
operator|==
name|NULL
condition|?
name|ztest_opts
operator|.
name|zo_pool
else|:
name|pool
argument_list|,
name|aux
argument_list|,
name|vdev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vdev
operator|=
name|ztest_shared
operator|->
name|zs_vdev_next_leaf
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf
argument_list|)
argument_list|,
name|ztest_dev_template
argument_list|,
name|ztest_opts
operator|.
name|zo_dir
argument_list|,
name|pool
operator|==
name|NULL
condition|?
name|ztest_opts
operator|.
name|zo_pool
else|:
name|pool
argument_list|,
name|vdev
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"can't open %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"can't ftruncate %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|file
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|file
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_FILE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|file
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|file
argument_list|,
name|ZPOOL_CONFIG_ASHIFT
argument_list|,
name|ashift
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|nvlist_t
modifier|*
name|make_vdev_raidz
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|aux
parameter_list|,
name|char
modifier|*
name|pool
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|ashift
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|raidz
decl_stmt|,
modifier|*
modifier|*
name|child
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|2
condition|)
return|return
operator|(
name|make_vdev_file
argument_list|(
name|path
argument_list|,
name|aux
argument_list|,
name|pool
argument_list|,
name|size
argument_list|,
name|ashift
argument_list|)
operator|)
return|;
name|child
operator|=
name|umem_alloc
argument_list|(
name|r
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|r
condition|;
name|c
operator|++
control|)
name|child
index|[
name|c
index|]
operator|=
name|make_vdev_file
argument_list|(
name|path
argument_list|,
name|aux
argument_list|,
name|pool
argument_list|,
name|size
argument_list|,
name|ashift
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|raidz
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|raidz
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|raidz
argument_list|,
name|ZPOOL_CONFIG_NPARITY
argument_list|,
name|ztest_opts
operator|.
name|zo_raidz_parity
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|raidz
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|child
argument_list|,
name|r
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|r
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|child
argument_list|,
name|r
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|raidz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|nvlist_t
modifier|*
name|make_vdev_mirror
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|aux
parameter_list|,
name|char
modifier|*
name|pool
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|ashift
parameter_list|,
name|int
name|r
parameter_list|,
name|int
name|m
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|mirror
decl_stmt|,
modifier|*
modifier|*
name|child
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|m
operator|<
literal|1
condition|)
return|return
operator|(
name|make_vdev_raidz
argument_list|(
name|path
argument_list|,
name|aux
argument_list|,
name|pool
argument_list|,
name|size
argument_list|,
name|ashift
argument_list|,
name|r
argument_list|)
operator|)
return|;
name|child
operator|=
name|umem_alloc
argument_list|(
name|m
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|m
condition|;
name|c
operator|++
control|)
name|child
index|[
name|c
index|]
operator|=
name|make_vdev_raidz
argument_list|(
name|path
argument_list|,
name|aux
argument_list|,
name|pool
argument_list|,
name|size
argument_list|,
name|ashift
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|mirror
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|mirror
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_MIRROR
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|mirror
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|child
argument_list|,
name|m
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|m
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|child
argument_list|,
name|m
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|mirror
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|nvlist_t
modifier|*
name|make_vdev_root
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|aux
parameter_list|,
name|char
modifier|*
name|pool
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|ashift
parameter_list|,
name|int
name|log
parameter_list|,
name|int
name|r
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|t
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|root
decl_stmt|,
modifier|*
modifier|*
name|child
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ASSERT
argument_list|(
name|t
operator|>
literal|0
argument_list|)
expr_stmt|;
name|child
operator|=
name|umem_alloc
argument_list|(
name|t
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|t
condition|;
name|c
operator|++
control|)
block|{
name|child
index|[
name|c
index|]
operator|=
name|make_vdev_mirror
argument_list|(
name|path
argument_list|,
name|aux
argument_list|,
name|pool
argument_list|,
name|size
argument_list|,
name|ashift
argument_list|,
name|r
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
name|log
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|root
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|root
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_ROOT
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|root
argument_list|,
name|aux
condition|?
name|aux
else|:
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|child
argument_list|,
name|t
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|t
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|child
argument_list|,
name|t
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|root
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a random spa version. Returns back a random spa version in the  * range [initial_version, SPA_VERSION_FEATURES].  */
end_comment

begin_function
specifier|static
name|uint64_t
name|ztest_random_spa_version
parameter_list|(
name|uint64_t
name|initial_version
parameter_list|)
block|{
name|uint64_t
name|version
init|=
name|initial_version
decl_stmt|;
if|if
condition|(
name|version
operator|<=
name|SPA_VERSION_BEFORE_FEATURES
condition|)
block|{
name|version
operator|=
name|version
operator|+
name|ztest_random
argument_list|(
name|SPA_VERSION_BEFORE_FEATURES
operator|-
name|version
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>
name|SPA_VERSION_BEFORE_FEATURES
condition|)
name|version
operator|=
name|SPA_VERSION_FEATURES
expr_stmt|;
name|ASSERT
argument_list|(
name|SPA_VERSION_IS_SUPPORTED
argument_list|(
name|version
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|version
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_random_blocksize
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|block_shift
decl_stmt|;
comment|/* 	 * Choose a block size>= the ashift. 	 * If the SPA supports new MAXBLOCKSIZE, test up to 1MB blocks. 	 */
name|int
name|maxbs
init|=
name|SPA_OLD_MAXBLOCKSHIFT
decl_stmt|;
if|if
condition|(
name|spa_maxblocksize
argument_list|(
name|ztest_spa
argument_list|)
operator|==
name|SPA_MAXBLOCKSIZE
condition|)
name|maxbs
operator|=
literal|20
expr_stmt|;
name|block_shift
operator|=
name|ztest_random
argument_list|(
name|maxbs
operator|-
name|ztest_spa
operator|->
name|spa_max_ashift
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|<<
operator|(
name|SPA_MINBLOCKSHIFT
operator|+
name|block_shift
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_random_ibshift
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|DN_MIN_INDBLKSHIFT
operator|+
name|ztest_random
argument_list|(
name|DN_MAX_INDBLKSHIFT
operator|-
name|DN_MIN_INDBLKSHIFT
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ztest_random_vdev_top
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|boolean_t
name|log_ok
parameter_list|)
block|{
name|uint64_t
name|top
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|tvd
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_READER
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|top
operator|=
name|ztest_random
argument_list|(
name|rvd
operator|->
name|vdev_children
argument_list|)
expr_stmt|;
name|tvd
operator|=
name|rvd
operator|->
name|vdev_child
index|[
name|top
index|]
expr_stmt|;
block|}
do|while
condition|(
name|tvd
operator|->
name|vdev_ishole
operator|||
operator|(
name|tvd
operator|->
name|vdev_islog
operator|&&
operator|!
name|log_ok
operator|)
operator|||
name|tvd
operator|->
name|vdev_mg
operator|==
name|NULL
operator|||
name|tvd
operator|->
name|vdev_mg
operator|->
name|mg_class
operator|==
name|NULL
condition|)
do|;
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ztest_random_dsl_prop
parameter_list|(
name|zfs_prop_t
name|prop
parameter_list|)
block|{
name|uint64_t
name|value
decl_stmt|;
do|do
block|{
name|value
operator|=
name|zfs_prop_random_value
argument_list|(
name|prop
argument_list|,
name|ztest_random
argument_list|(
operator|-
literal|1ULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|prop
operator|==
name|ZFS_PROP_CHECKSUM
operator|&&
name|value
operator|==
name|ZIO_CHECKSUM_OFF
condition|)
do|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_dsl_prop_set_uint64
parameter_list|(
name|char
modifier|*
name|osname
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|boolean_t
name|inherit
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|valname
decl_stmt|;
name|char
name|setpoint
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|uint64_t
name|curval
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dsl_prop_set_int
argument_list|(
name|osname
argument_list|,
name|propname
argument_list|,
operator|(
name|inherit
condition|?
name|ZPROP_SRC_NONE
else|:
name|ZPROP_SRC_LOCAL
operator|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_prop_get_integer
argument_list|(
name|osname
argument_list|,
name|propname
argument_list|,
operator|&
name|curval
argument_list|,
name|setpoint
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|6
condition|)
block|{
name|VERIFY
argument_list|(
name|zfs_prop_index_to_string
argument_list|(
name|prop
argument_list|,
name|curval
argument_list|,
operator|&
name|valname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s = %s at '%s'\n"
argument_list|,
name|osname
argument_list|,
name|propname
argument_list|,
name|valname
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_spa_prop_set_uint64
parameter_list|(
name|zpool_prop_t
name|prop
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|ztest_spa
decl_stmt|;
name|nvlist_t
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_prop_set
argument_list|(
name|spa
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_rll_init
parameter_list|(
name|rll_t
modifier|*
name|rll
parameter_list|)
block|{
name|rll
operator|->
name|rll_writer
operator|=
name|NULL
expr_stmt|;
name|rll
operator|->
name|rll_readers
operator|=
literal|0
expr_stmt|;
name|VERIFY
argument_list|(
name|_mutex_init
argument_list|(
operator|&
name|rll
operator|->
name|rll_lock
argument_list|,
name|USYNC_THREAD
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|cond_init
argument_list|(
operator|&
name|rll
operator|->
name|rll_cv
argument_list|,
name|USYNC_THREAD
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_rll_destroy
parameter_list|(
name|rll_t
modifier|*
name|rll
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|rll
operator|->
name|rll_writer
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rll
operator|->
name|rll_readers
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|_mutex_destroy
argument_list|(
operator|&
name|rll
operator|->
name|rll_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|cond_destroy
argument_list|(
operator|&
name|rll
operator|->
name|rll_cv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_rll_lock
parameter_list|(
name|rll_t
modifier|*
name|rll
parameter_list|,
name|rl_type_t
name|type
parameter_list|)
block|{
name|VERIFY
argument_list|(
name|mutex_lock
argument_list|(
operator|&
name|rll
operator|->
name|rll_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|RL_READER
condition|)
block|{
while|while
condition|(
name|rll
operator|->
name|rll_writer
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|cond_wait
argument_list|(
operator|&
name|rll
operator|->
name|rll_cv
argument_list|,
operator|&
name|rll
operator|->
name|rll_lock
argument_list|)
expr_stmt|;
name|rll
operator|->
name|rll_readers
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|rll
operator|->
name|rll_writer
operator|!=
name|NULL
operator|||
name|rll
operator|->
name|rll_readers
condition|)
operator|(
name|void
operator|)
name|cond_wait
argument_list|(
operator|&
name|rll
operator|->
name|rll_cv
argument_list|,
operator|&
name|rll
operator|->
name|rll_lock
argument_list|)
expr_stmt|;
name|rll
operator|->
name|rll_writer
operator|=
name|curthread
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|rll
operator|->
name|rll_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_rll_unlock
parameter_list|(
name|rll_t
modifier|*
name|rll
parameter_list|)
block|{
name|VERIFY
argument_list|(
name|mutex_lock
argument_list|(
operator|&
name|rll
operator|->
name|rll_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rll
operator|->
name|rll_writer
condition|)
block|{
name|ASSERT
argument_list|(
name|rll
operator|->
name|rll_readers
operator|==
literal|0
argument_list|)
expr_stmt|;
name|rll
operator|->
name|rll_writer
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|rll
operator|->
name|rll_readers
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rll
operator|->
name|rll_writer
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|rll
operator|->
name|rll_readers
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|rll
operator|->
name|rll_writer
operator|==
name|NULL
operator|&&
name|rll
operator|->
name|rll_readers
operator|==
literal|0
condition|)
name|VERIFY
argument_list|(
name|cond_broadcast
argument_list|(
operator|&
name|rll
operator|->
name|rll_cv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|rll
operator|->
name|rll_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_object_lock
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|rl_type_t
name|type
parameter_list|)
block|{
name|rll_t
modifier|*
name|rll
init|=
operator|&
name|zd
operator|->
name|zd_object_lock
index|[
name|object
operator|&
operator|(
name|ZTEST_OBJECT_LOCKS
operator|-
literal|1
operator|)
index|]
decl_stmt|;
name|ztest_rll_lock
argument_list|(
name|rll
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_object_unlock
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|object
parameter_list|)
block|{
name|rll_t
modifier|*
name|rll
init|=
operator|&
name|zd
operator|->
name|zd_object_lock
index|[
name|object
operator|&
operator|(
name|ZTEST_OBJECT_LOCKS
operator|-
literal|1
operator|)
index|]
decl_stmt|;
name|ztest_rll_unlock
argument_list|(
name|rll
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rl_t
modifier|*
name|ztest_range_lock
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|rl_type_t
name|type
parameter_list|)
block|{
name|uint64_t
name|hash
init|=
name|object
operator|^
operator|(
name|offset
operator|%
operator|(
name|ZTEST_RANGE_LOCKS
operator|+
literal|1
operator|)
operator|)
decl_stmt|;
name|rll_t
modifier|*
name|rll
init|=
operator|&
name|zd
operator|->
name|zd_range_lock
index|[
name|hash
operator|&
operator|(
name|ZTEST_RANGE_LOCKS
operator|-
literal|1
operator|)
index|]
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|rl
operator|=
name|umem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rl
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
name|rl
operator|->
name|rl_object
operator|=
name|object
expr_stmt|;
name|rl
operator|->
name|rl_offset
operator|=
name|offset
expr_stmt|;
name|rl
operator|->
name|rl_size
operator|=
name|size
expr_stmt|;
name|rl
operator|->
name|rl_lock
operator|=
name|rll
expr_stmt|;
name|ztest_rll_lock
argument_list|(
name|rll
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|rl
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_range_unlock
parameter_list|(
name|rl_t
modifier|*
name|rl
parameter_list|)
block|{
name|rll_t
modifier|*
name|rll
init|=
name|rl
operator|->
name|rl_lock
decl_stmt|;
name|ztest_rll_unlock
argument_list|(
name|rll
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|rl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_zd_init
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|ztest_shared_ds_t
modifier|*
name|szd
parameter_list|,
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|zd
operator|->
name|zd_os
operator|=
name|os
expr_stmt|;
name|zd
operator|->
name|zd_zilog
operator|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zd
operator|->
name|zd_shared
operator|=
name|szd
expr_stmt|;
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|zd
operator|->
name|zd_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zd
operator|->
name|zd_shared
operator|!=
name|NULL
condition|)
name|zd
operator|->
name|zd_shared
operator|->
name|zd_seq
operator|=
literal|0
expr_stmt|;
name|VERIFY
argument_list|(
name|rwlock_init
argument_list|(
operator|&
name|zd
operator|->
name|zd_zilog_lock
argument_list|,
name|USYNC_THREAD
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|_mutex_init
argument_list|(
operator|&
name|zd
operator|->
name|zd_dirobj_lock
argument_list|,
name|USYNC_THREAD
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|l
init|=
literal|0
init|;
name|l
operator|<
name|ZTEST_OBJECT_LOCKS
condition|;
name|l
operator|++
control|)
name|ztest_rll_init
argument_list|(
operator|&
name|zd
operator|->
name|zd_object_lock
index|[
name|l
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|l
init|=
literal|0
init|;
name|l
operator|<
name|ZTEST_RANGE_LOCKS
condition|;
name|l
operator|++
control|)
name|ztest_rll_init
argument_list|(
operator|&
name|zd
operator|->
name|zd_range_lock
index|[
name|l
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_zd_fini
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|)
block|{
name|VERIFY
argument_list|(
name|_mutex_destroy
argument_list|(
operator|&
name|zd
operator|->
name|zd_dirobj_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|l
init|=
literal|0
init|;
name|l
operator|<
name|ZTEST_OBJECT_LOCKS
condition|;
name|l
operator|++
control|)
name|ztest_rll_destroy
argument_list|(
operator|&
name|zd
operator|->
name|zd_object_lock
index|[
name|l
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|l
init|=
literal|0
init|;
name|l
operator|<
name|ZTEST_RANGE_LOCKS
condition|;
name|l
operator|++
control|)
name|ztest_rll_destroy
argument_list|(
operator|&
name|zd
operator|->
name|zd_range_lock
index|[
name|l
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|TXG_MIGHTWAIT
value|(ztest_random(10) == 0 ? TXG_NOWAIT : TXG_WAIT)
end_define

begin_function
specifier|static
name|uint64_t
name|ztest_tx_assign
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|txg_how
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Attempt to assign tx to some transaction group. 	 */
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|txg_how
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
name|ASSERT
argument_list|(
name|txg_how
operator|==
name|TXG_NOWAIT
argument_list|)
expr_stmt|;
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
name|ENOSPC
argument_list|)
expr_stmt|;
name|ztest_record_enospc
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|txg
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|txg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_pattern_set
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|uint64_t
modifier|*
name|ip
init|=
name|buf
decl_stmt|;
name|uint64_t
modifier|*
name|ip_end
init|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|buf
operator|+
operator|(
name|uintptr_t
operator|)
name|size
operator|)
decl_stmt|;
while|while
condition|(
name|ip
operator|<
name|ip_end
condition|)
operator|*
name|ip
operator|++
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|ztest_pattern_match
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|uint64_t
modifier|*
name|ip
init|=
name|buf
decl_stmt|;
name|uint64_t
modifier|*
name|ip_end
init|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|buf
operator|+
operator|(
name|uintptr_t
operator|)
name|size
operator|)
decl_stmt|;
name|uint64_t
name|diff
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ip
operator|<
name|ip_end
condition|)
name|diff
operator||=
operator|(
name|value
operator|-
operator|*
name|ip
operator|++
operator|)
expr_stmt|;
return|return
operator|(
name|diff
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_bt_generate
parameter_list|(
name|ztest_block_tag_t
modifier|*
name|bt
parameter_list|,
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|gen
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|uint64_t
name|crtxg
parameter_list|)
block|{
name|bt
operator|->
name|bt_magic
operator|=
name|BT_MAGIC
expr_stmt|;
name|bt
operator|->
name|bt_objset
operator|=
name|dmu_objset_id
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bt_object
operator|=
name|object
expr_stmt|;
name|bt
operator|->
name|bt_offset
operator|=
name|offset
expr_stmt|;
name|bt
operator|->
name|bt_gen
operator|=
name|gen
expr_stmt|;
name|bt
operator|->
name|bt_txg
operator|=
name|txg
expr_stmt|;
name|bt
operator|->
name|bt_crtxg
operator|=
name|crtxg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_bt_verify
parameter_list|(
name|ztest_block_tag_t
modifier|*
name|bt
parameter_list|,
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|gen
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|uint64_t
name|crtxg
parameter_list|)
block|{
name|ASSERT3U
argument_list|(
name|bt
operator|->
name|bt_magic
argument_list|,
operator|==
argument_list|,
name|BT_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bt
operator|->
name|bt_objset
argument_list|,
operator|==
argument_list|,
name|dmu_objset_id
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bt
operator|->
name|bt_object
argument_list|,
operator|==
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bt
operator|->
name|bt_offset
argument_list|,
operator|==
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bt
operator|->
name|bt_gen
argument_list|,
operator|<=
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bt
operator|->
name|bt_txg
argument_list|,
operator|<=
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bt
operator|->
name|bt_crtxg
argument_list|,
operator|==
argument_list|,
name|crtxg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ztest_block_tag_t
modifier|*
name|ztest_bt_bonus
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|)
block|{
name|dmu_object_info_t
name|doi
decl_stmt|;
name|ztest_block_tag_t
modifier|*
name|bt
decl_stmt|;
name|dmu_object_info_from_db
argument_list|(
name|db
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|doi
operator|.
name|doi_bonus_size
argument_list|,
operator|<=
argument_list|,
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|doi
operator|.
name|doi_bonus_size
argument_list|,
operator|>=
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bt
argument_list|)
argument_list|)
expr_stmt|;
name|bt
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|doi
operator|.
name|doi_bonus_size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|bt
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|bt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ZIL logging ops  */
end_comment

begin_define
define|#
directive|define
name|lrz_type
value|lr_mode
end_define

begin_define
define|#
directive|define
name|lrz_blocksize
value|lr_uid
end_define

begin_define
define|#
directive|define
name|lrz_ibshift
value|lr_gid
end_define

begin_define
define|#
directive|define
name|lrz_bonustype
value|lr_rdev
end_define

begin_define
define|#
directive|define
name|lrz_bonuslen
value|lr_crtime[1]
end_define

begin_function
specifier|static
name|void
name|ztest_log_create
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|lr_create_t
modifier|*
name|lr
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* name follows lr */
name|size_t
name|namesize
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|itx_t
modifier|*
name|itx
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zd
operator|->
name|zd_zilog
argument_list|,
name|tx
argument_list|)
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|TX_CREATE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|namesize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|lr
operator|->
name|lr_common
operator|+
literal|1
argument_list|,
operator|&
name|itx
operator|->
name|itx_lr
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|namesize
operator|-
sizeof|sizeof
argument_list|(
name|lr_t
argument_list|)
argument_list|)
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zd
operator|->
name|zd_zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_log_remove
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|lr_remove_t
modifier|*
name|lr
parameter_list|,
name|uint64_t
name|object
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* name follows lr */
name|size_t
name|namesize
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|itx_t
modifier|*
name|itx
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zd
operator|->
name|zd_zilog
argument_list|,
name|tx
argument_list|)
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|TX_REMOVE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|namesize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|lr
operator|->
name|lr_common
operator|+
literal|1
argument_list|,
operator|&
name|itx
operator|->
name|itx_lr
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|namesize
operator|-
sizeof|sizeof
argument_list|(
name|lr_t
argument_list|)
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_oid
operator|=
name|object
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zd
operator|->
name|zd_zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_log_write
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|itx_wr_state_t
name|write_state
init|=
name|ztest_random
argument_list|(
name|WR_NUM_STATES
argument_list|)
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zd
operator|->
name|zd_zilog
argument_list|,
name|tx
argument_list|)
condition|)
return|return;
if|if
condition|(
name|lr
operator|->
name|lr_length
operator|>
name|ZIL_MAX_LOG_DATA
condition|)
name|write_state
operator|=
name|WR_INDIRECT
expr_stmt|;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|TX_WRITE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
operator|(
name|write_state
operator|==
name|WR_COPIED
condition|?
name|lr
operator|->
name|lr_length
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_state
operator|==
name|WR_COPIED
operator|&&
name|dmu_read
argument_list|(
name|zd
operator|->
name|zd_os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|lr
operator|->
name|lr_offset
argument_list|,
name|lr
operator|->
name|lr_length
argument_list|,
operator|(
operator|(
name|lr_write_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
operator|)
operator|+
literal|1
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zil_itx_destroy
argument_list|(
name|itx
argument_list|)
expr_stmt|;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|TX_WRITE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|write_state
operator|=
name|WR_NEED_COPY
expr_stmt|;
block|}
name|itx
operator|->
name|itx_private
operator|=
name|zd
expr_stmt|;
name|itx
operator|->
name|itx_wr_state
operator|=
name|write_state
expr_stmt|;
name|itx
operator|->
name|itx_sync
operator|=
operator|(
name|ztest_random
argument_list|(
literal|8
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|lr
operator|->
name|lr_common
operator|+
literal|1
argument_list|,
operator|&
name|itx
operator|->
name|itx_lr
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|lr_t
argument_list|)
argument_list|)
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zd
operator|->
name|zd_zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_log_truncate
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|lr_truncate_t
modifier|*
name|lr
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zd
operator|->
name|zd_zilog
argument_list|,
name|tx
argument_list|)
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|TX_TRUNCATE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|lr
operator|->
name|lr_common
operator|+
literal|1
argument_list|,
operator|&
name|itx
operator|->
name|itx_lr
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|lr_t
argument_list|)
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_sync
operator|=
name|B_FALSE
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zd
operator|->
name|zd_zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_log_setattr
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|lr_setattr_t
modifier|*
name|lr
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zd
operator|->
name|zd_zilog
argument_list|,
name|tx
argument_list|)
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|TX_SETATTR
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|lr
operator|->
name|lr_common
operator|+
literal|1
argument_list|,
operator|&
name|itx
operator|->
name|itx_lr
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|lr_t
argument_list|)
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_sync
operator|=
name|B_FALSE
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zd
operator|->
name|zd_zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ZIL replay ops  */
end_comment

begin_function
specifier|static
name|int
name|ztest_replay_create
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|lr_create_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* name follows lr */
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|ztest_block_tag_t
modifier|*
name|bbt
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lr
operator|->
name|lr_doid
operator|==
name|ZTEST_DIROBJ
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|lr
operator|->
name|lr_doid
argument_list|,
name|B_TRUE
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lr
operator|->
name|lrz_type
operator|==
name|DMU_OT_ZAP_OTHER
condition|)
block|{
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
block|}
name|txg
operator|=
name|ztest_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|ASSERT
argument_list|(
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
operator|->
name|zl_replay
operator|==
operator|!
operator|!
name|lr
operator|->
name|lr_foid
argument_list|)
expr_stmt|;
if|if
condition|(
name|lr
operator|->
name|lrz_type
operator|==
name|DMU_OT_ZAP_OTHER
condition|)
block|{
if|if
condition|(
name|lr
operator|->
name|lr_foid
operator|==
literal|0
condition|)
block|{
name|lr
operator|->
name|lr_foid
operator|=
name|zap_create
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lrz_type
argument_list|,
name|lr
operator|->
name|lrz_bonustype
argument_list|,
name|lr
operator|->
name|lrz_bonuslen
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|zap_create_claim
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|lr
operator|->
name|lrz_type
argument_list|,
name|lr
operator|->
name|lrz_bonustype
argument_list|,
name|lr
operator|->
name|lrz_bonuslen
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|lr
operator|->
name|lr_foid
operator|==
literal|0
condition|)
block|{
name|lr
operator|->
name|lr_foid
operator|=
name|dmu_object_alloc
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lrz_type
argument_list|,
literal|0
argument_list|,
name|lr
operator|->
name|lrz_bonustype
argument_list|,
name|lr
operator|->
name|lrz_bonuslen
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|dmu_object_claim
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|lr
operator|->
name|lrz_type
argument_list|,
literal|0
argument_list|,
name|lr
operator|->
name|lrz_bonustype
argument_list|,
name|lr
operator|->
name|lrz_bonuslen
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
name|EEXIST
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zd
operator|->
name|zd_zilog
operator|->
name|zl_replay
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|lr
operator|->
name|lr_foid
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lr
operator|->
name|lrz_type
operator|!=
name|DMU_OT_ZAP_OTHER
condition|)
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_object_set_blocksize
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|lr
operator|->
name|lrz_blocksize
argument_list|,
name|lr
operator|->
name|lrz_ibshift
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|bbt
operator|=
name|ztest_bt_bonus
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ztest_bt_generate
argument_list|(
name|bbt
argument_list|,
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|lr
operator|->
name|lr_gen
argument_list|,
name|txg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_add
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_doid
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|lr
operator|->
name|lr_foid
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ztest_log_create
argument_list|(
name|zd
argument_list|,
name|tx
argument_list|,
name|lr
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_replay_remove
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|lr_remove_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* name follows lr */
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|object
decl_stmt|,
name|txg
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lr
operator|->
name|lr_doid
operator|==
name|ZTEST_DIROBJ
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_doid
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|object
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|object
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|object
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ztest_object_lock
argument_list|(
name|zd
argument_list|,
name|object
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
operator|&
name|doi
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|lr
operator|->
name|lr_doid
argument_list|,
name|B_FALSE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|txg
operator|=
name|ztest_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
block|{
name|ztest_object_unlock
argument_list|(
name|zd
argument_list|,
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
if|if
condition|(
name|doi
operator|.
name|doi_type
operator|==
name|DMU_OT_ZAP_OTHER
condition|)
block|{
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_destroy
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_object_free
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_remove
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_doid
argument_list|,
name|name
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ztest_log_remove
argument_list|(
name|zd
argument_list|,
name|tx
argument_list|,
name|lr
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ztest_object_unlock
argument_list|(
name|zd
argument_list|,
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_replay_write
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|lr
operator|+
literal|1
decl_stmt|;
comment|/* data follows lr */
name|uint64_t
name|offset
decl_stmt|,
name|length
decl_stmt|;
name|ztest_block_tag_t
modifier|*
name|bt
init|=
name|data
decl_stmt|;
name|ztest_block_tag_t
modifier|*
name|bbt
decl_stmt|;
name|uint64_t
name|gen
decl_stmt|,
name|txg
decl_stmt|,
name|lrtxg
decl_stmt|,
name|crtxg
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
init|=
name|NULL
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|lr
operator|->
name|lr_offset
expr_stmt|;
name|length
operator|=
name|lr
operator|->
name|lr_length
expr_stmt|;
comment|/* If it's a dmu_sync() block, write the whole block */
if|if
condition|(
name|lr
operator|->
name|lr_common
operator|.
name|lrc_reclen
operator|==
sizeof|sizeof
argument_list|(
name|lr_write_t
argument_list|)
condition|)
block|{
name|uint64_t
name|blocksize
init|=
name|BP_GET_LSIZE
argument_list|(
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|<
name|blocksize
condition|)
block|{
name|offset
operator|-=
name|offset
operator|%
name|blocksize
expr_stmt|;
name|length
operator|=
name|blocksize
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bt
operator|->
name|bt_magic
operator|==
name|BSWAP_64
argument_list|(
name|BT_MAGIC
argument_list|)
condition|)
name|byteswap_uint64_array
argument_list|(
name|bt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|bt_magic
operator|!=
name|BT_MAGIC
condition|)
name|bt
operator|=
name|NULL
expr_stmt|;
name|ztest_object_lock
argument_list|(
name|zd
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
name|rl
operator|=
name|ztest_range_lock
argument_list|(
name|zd
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_object_info_from_db
argument_list|(
name|db
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
name|bbt
operator|=
name|ztest_bt_bonus
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bbt
operator|->
name|bt_magic
argument_list|,
operator|==
argument_list|,
name|BT_MAGIC
argument_list|)
expr_stmt|;
name|gen
operator|=
name|bbt
operator|->
name|bt_gen
expr_stmt|;
name|crtxg
operator|=
name|bbt
operator|->
name|bt_crtxg
expr_stmt|;
name|lrtxg
operator|=
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txg
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|8
argument_list|)
operator|==
literal|0
operator|&&
name|length
operator|==
name|doi
operator|.
name|doi_data_block_size
operator|&&
name|P2PHASE
argument_list|(
name|offset
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
name|abuf
operator|=
name|dmu_request_arcbuf
argument_list|(
name|db
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|txg
operator|=
name|ztest_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|abuf
operator|!=
name|NULL
condition|)
name|dmu_return_arcbuf
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ztest_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ztest_object_unlock
argument_list|(
name|zd
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
if|if
condition|(
name|bt
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Usually, verify the old data before writing new data -- 		 * but not always, because we also want to verify correct 		 * behavior when the data was not recently read into cache. 		 */
name|ASSERT
argument_list|(
name|offset
operator|%
name|doi
operator|.
name|doi_data_block_size
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|prefetch
init|=
name|ztest_random
argument_list|(
literal|2
argument_list|)
condition|?
name|DMU_READ_PREFETCH
else|:
name|DMU_READ_NO_PREFETCH
decl_stmt|;
name|ztest_block_tag_t
name|rbt
decl_stmt|;
name|VERIFY
argument_list|(
name|dmu_read
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|rbt
argument_list|)
argument_list|,
operator|&
name|rbt
argument_list|,
name|prefetch
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbt
operator|.
name|bt_magic
operator|==
name|BT_MAGIC
condition|)
block|{
name|ztest_bt_verify
argument_list|(
operator|&
name|rbt
argument_list|,
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|offset
argument_list|,
name|gen
argument_list|,
name|txg
argument_list|,
name|crtxg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Writes can appear to be newer than the bonus buffer because 		 * the ztest_get_data() callback does a dmu_read() of the 		 * open-context data, which may be different than the data 		 * as it was when the write was generated. 		 */
if|if
condition|(
name|zd
operator|->
name|zd_zilog
operator|->
name|zl_replay
condition|)
block|{
name|ztest_bt_verify
argument_list|(
name|bt
argument_list|,
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|offset
argument_list|,
name|MAX
argument_list|(
name|gen
argument_list|,
name|bt
operator|->
name|bt_gen
argument_list|)
argument_list|,
name|MAX
argument_list|(
name|txg
argument_list|,
name|lrtxg
argument_list|)
argument_list|,
name|bt
operator|->
name|bt_crtxg
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set the bt's gen/txg to the bonus buffer's gen/txg 		 * so that all of the usual ASSERTs will work. 		 */
name|ztest_bt_generate
argument_list|(
name|bt
argument_list|,
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|offset
argument_list|,
name|gen
argument_list|,
name|txg
argument_list|,
name|crtxg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abuf
operator|==
name|NULL
condition|)
block|{
name|dmu_write
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|data
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|data
argument_list|,
name|abuf
operator|->
name|b_data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|dmu_assign_arcbuf
argument_list|(
name|db
argument_list|,
name|offset
argument_list|,
name|abuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ztest_log_write
argument_list|(
name|zd
argument_list|,
name|tx
argument_list|,
name|lr
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ztest_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ztest_object_unlock
argument_list|(
name|zd
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_replay_truncate
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|lr_truncate_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|ztest_object_lock
argument_list|(
name|zd
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
name|rl
operator|=
name|ztest_range_lock
argument_list|(
name|zd
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|lr
operator|->
name|lr_offset
argument_list|,
name|lr
operator|->
name|lr_length
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|lr
operator|->
name|lr_offset
argument_list|,
name|lr
operator|->
name|lr_length
argument_list|)
expr_stmt|;
name|txg
operator|=
name|ztest_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
block|{
name|ztest_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ztest_object_unlock
argument_list|(
name|zd
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|VERIFY
argument_list|(
name|dmu_free_range
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|lr
operator|->
name|lr_offset
argument_list|,
name|lr
operator|->
name|lr_length
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ztest_log_truncate
argument_list|(
name|zd
argument_list|,
name|tx
argument_list|,
name|lr
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ztest_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ztest_object_unlock
argument_list|(
name|zd
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_replay_setattr
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|lr_setattr_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|ztest_block_tag_t
modifier|*
name|bbt
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|,
name|lrtxg
decl_stmt|,
name|crtxg
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|ztest_object_lock
argument_list|(
name|zd
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|)
expr_stmt|;
name|txg
operator|=
name|ztest_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
block|{
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ztest_object_unlock
argument_list|(
name|zd
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|bbt
operator|=
name|ztest_bt_bonus
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bbt
operator|->
name|bt_magic
argument_list|,
operator|==
argument_list|,
name|BT_MAGIC
argument_list|)
expr_stmt|;
name|crtxg
operator|=
name|bbt
operator|->
name|bt_crtxg
expr_stmt|;
name|lrtxg
operator|=
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txg
expr_stmt|;
if|if
condition|(
name|zd
operator|->
name|zd_zilog
operator|->
name|zl_replay
condition|)
block|{
name|ASSERT
argument_list|(
name|lr
operator|->
name|lr_size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lr
operator|->
name|lr_mode
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lrtxg
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Randomly change the size and increment the generation. 		 */
name|lr
operator|->
name|lr_size
operator|=
operator|(
name|ztest_random
argument_list|(
name|db
operator|->
name|db_size
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|bbt
argument_list|)
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bbt
argument_list|)
expr_stmt|;
name|lr
operator|->
name|lr_mode
operator|=
name|bbt
operator|->
name|bt_gen
operator|+
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
name|lrtxg
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Verify that the current bonus buffer is not newer than our txg. 	 */
name|ztest_bt_verify
argument_list|(
name|bbt
argument_list|,
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|lr
operator|->
name|lr_mode
argument_list|,
name|MAX
argument_list|(
name|txg
argument_list|,
name|lrtxg
argument_list|)
argument_list|,
name|crtxg
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|lr
operator|->
name|lr_size
argument_list|,
operator|>=
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bbt
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|lr
operator|->
name|lr_size
argument_list|,
operator|<=
argument_list|,
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dmu_set_bonus
argument_list|(
name|db
argument_list|,
name|lr
operator|->
name|lr_size
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|bbt
operator|=
name|ztest_bt_bonus
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|ztest_bt_generate
argument_list|(
name|bbt
argument_list|,
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|lr
operator|->
name|lr_mode
argument_list|,
name|txg
argument_list|,
name|crtxg
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ztest_log_setattr
argument_list|(
name|zd
argument_list|,
name|tx
argument_list|,
name|lr
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ztest_object_unlock
argument_list|(
name|zd
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|zil_replay_func_t
modifier|*
name|ztest_replay_vector
index|[
name|TX_MAX_TYPE
index|]
init|=
block|{
name|NULL
block|,
comment|/* 0 no such transaction type */
name|ztest_replay_create
block|,
comment|/* TX_CREATE */
name|NULL
block|,
comment|/* TX_MKDIR */
name|NULL
block|,
comment|/* TX_MKXATTR */
name|NULL
block|,
comment|/* TX_SYMLINK */
name|ztest_replay_remove
block|,
comment|/* TX_REMOVE */
name|NULL
block|,
comment|/* TX_RMDIR */
name|NULL
block|,
comment|/* TX_LINK */
name|NULL
block|,
comment|/* TX_RENAME */
name|ztest_replay_write
block|,
comment|/* TX_WRITE */
name|ztest_replay_truncate
block|,
comment|/* TX_TRUNCATE */
name|ztest_replay_setattr
block|,
comment|/* TX_SETATTR */
name|NULL
block|,
comment|/* TX_ACL */
name|NULL
block|,
comment|/* TX_CREATE_ACL */
name|NULL
block|,
comment|/* TX_CREATE_ATTR */
name|NULL
block|,
comment|/* TX_CREATE_ACL_ATTR */
name|NULL
block|,
comment|/* TX_MKDIR_ACL */
name|NULL
block|,
comment|/* TX_MKDIR_ATTR */
name|NULL
block|,
comment|/* TX_MKDIR_ACL_ATTR */
name|NULL
block|,
comment|/* TX_WRITE2 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ZIL get_data callbacks  */
end_comment

begin_function
specifier|static
name|void
name|ztest_get_done
parameter_list|(
name|zgd_t
modifier|*
name|zgd
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|ztest_ds_t
modifier|*
name|zd
init|=
name|zgd
operator|->
name|zgd_private
decl_stmt|;
name|uint64_t
name|object
init|=
name|zgd
operator|->
name|zgd_rl
operator|->
name|rl_object
decl_stmt|;
if|if
condition|(
name|zgd
operator|->
name|zgd_db
condition|)
name|dmu_buf_rele
argument_list|(
name|zgd
operator|->
name|zgd_db
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
name|ztest_range_unlock
argument_list|(
name|zgd
operator|->
name|zgd_rl
argument_list|)
expr_stmt|;
name|ztest_object_unlock
argument_list|(
name|zd
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|zgd
operator|->
name|zgd_bp
condition|)
name|zil_add_block
argument_list|(
name|zgd
operator|->
name|zgd_zilog
argument_list|,
name|zgd
operator|->
name|zgd_bp
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|zgd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zgd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_get_data
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|ztest_ds_t
modifier|*
name|zd
init|=
name|arg
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|uint64_t
name|object
init|=
name|lr
operator|->
name|lr_foid
decl_stmt|;
name|uint64_t
name|offset
init|=
name|lr
operator|->
name|lr_offset
decl_stmt|;
name|uint64_t
name|size
init|=
name|lr
operator|->
name|lr_length
decl_stmt|;
name|uint64_t
name|txg
init|=
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txg
decl_stmt|;
name|uint64_t
name|crtxg
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|zgd_t
modifier|*
name|zgd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ztest_object_lock
argument_list|(
name|zd
argument_list|,
name|object
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ztest_object_unlock
argument_list|(
name|zd
argument_list|,
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|crtxg
operator|=
name|ztest_bt_bonus
argument_list|(
name|db
argument_list|)
operator|->
name|bt_crtxg
expr_stmt|;
if|if
condition|(
name|crtxg
operator|==
literal|0
operator|||
name|crtxg
operator|>
name|txg
condition|)
block|{
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ztest_object_unlock
argument_list|(
name|zd
argument_list|,
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|dmu_object_info_from_db
argument_list|(
name|db
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|zgd
operator|=
name|umem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zgd
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
name|zgd
operator|->
name|zgd_zilog
operator|=
name|zd
operator|->
name|zd_zilog
expr_stmt|;
name|zgd
operator|->
name|zgd_private
operator|=
name|zd
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
comment|/* immediate write */
name|zgd
operator|->
name|zgd_rl
operator|=
name|ztest_range_lock
argument_list|(
name|zd
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|doi
operator|.
name|doi_data_block_size
expr_stmt|;
if|if
condition|(
name|ISP2
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|offset
operator|=
name|P2ALIGN
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|offset
operator|<
name|size
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|zgd
operator|->
name|zgd_rl
operator|=
name|ztest_range_lock
argument_list|(
name|zd
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_buf_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|zgd
argument_list|,
operator|&
name|db
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|lr
operator|->
name|lr_blkptr
decl_stmt|;
name|zgd
operator|->
name|zgd_db
operator|=
name|db
expr_stmt|;
name|zgd
operator|->
name|zgd_bp
operator|=
name|bp
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_offset
operator|==
name|offset
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_size
operator|==
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_sync
argument_list|(
name|zio
argument_list|,
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txg
argument_list|,
name|ztest_get_done
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|ztest_get_done
argument_list|(
name|zgd
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ztest_lr_alloc
parameter_list|(
name|size_t
name|lrsize
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|lr
decl_stmt|;
name|size_t
name|namesize
init|=
name|name
condition|?
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
else|:
literal|0
decl_stmt|;
name|lr
operator|=
name|umem_zalloc
argument_list|(
name|lrsize
operator|+
name|namesize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|bcopy
argument_list|(
name|name
argument_list|,
name|lr
operator|+
name|lrsize
argument_list|,
name|namesize
argument_list|)
expr_stmt|;
return|return
operator|(
name|lr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ztest_lr_free
parameter_list|(
name|void
modifier|*
name|lr
parameter_list|,
name|size_t
name|lrsize
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|namesize
init|=
name|name
condition|?
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
else|:
literal|0
decl_stmt|;
name|umem_free
argument_list|(
name|lr
argument_list|,
name|lrsize
operator|+
name|namesize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lookup a bunch of objects.  Returns the number of objects not found.  */
end_comment

begin_function
specifier|static
name|int
name|ztest_lookup
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|ztest_od_t
modifier|*
name|od
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|missing
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|_mutex_held
argument_list|(
operator|&
name|zd
operator|->
name|zd_dirobj_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|od
operator|++
control|)
block|{
name|od
operator|->
name|od_object
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|zd
operator|->
name|zd_os
argument_list|,
name|od
operator|->
name|od_dir
argument_list|,
name|od
operator|->
name|od_name
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|od
operator|->
name|od_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|od
operator|->
name|od_object
operator|==
literal|0
argument_list|)
expr_stmt|;
name|missing
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|ztest_block_tag_t
modifier|*
name|bbt
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|ASSERT
argument_list|(
name|od
operator|->
name|od_object
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|missing
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* there should be no gaps */
name|ztest_object_lock
argument_list|(
name|zd
argument_list|,
name|od
operator|->
name|od_object
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_bonus_hold
argument_list|(
name|zd
operator|->
name|zd_os
argument_list|,
name|od
operator|->
name|od_object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_object_info_from_db
argument_list|(
name|db
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
name|bbt
operator|=
name|ztest_bt_bonus
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bbt
operator|->
name|bt_magic
argument_list|,
operator|==
argument_list|,
name|BT_MAGIC
argument_list|)
expr_stmt|;
name|od
operator|->
name|od_type
operator|=
name|doi
operator|.
name|doi_type
expr_stmt|;
name|od
operator|->
name|od_blocksize
operator|=
name|doi
operator|.
name|doi_data_block_size
expr_stmt|;
name|od
operator|->
name|od_gen
operator|=
name|bbt
operator|->
name|bt_gen
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ztest_object_unlock
argument_list|(
name|zd
argument_list|,
name|od
operator|->
name|od_object
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|missing
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_create
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|ztest_od_t
modifier|*
name|od
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|missing
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|_mutex_held
argument_list|(
operator|&
name|zd
operator|->
name|zd_dirobj_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|od
operator|++
control|)
block|{
if|if
condition|(
name|missing
condition|)
block|{
name|od
operator|->
name|od_object
operator|=
literal|0
expr_stmt|;
name|missing
operator|++
expr_stmt|;
continue|continue;
block|}
name|lr_create_t
modifier|*
name|lr
init|=
name|ztest_lr_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|,
name|od
operator|->
name|od_name
argument_list|)
decl_stmt|;
name|lr
operator|->
name|lr_doid
operator|=
name|od
operator|->
name|od_dir
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
literal|0
expr_stmt|;
comment|/* 0 to allocate,> 0 to claim */
name|lr
operator|->
name|lrz_type
operator|=
name|od
operator|->
name|od_crtype
expr_stmt|;
name|lr
operator|->
name|lrz_blocksize
operator|=
name|od
operator|->
name|od_crblocksize
expr_stmt|;
name|lr
operator|->
name|lrz_ibshift
operator|=
name|ztest_random_ibshift
argument_list|()
expr_stmt|;
name|lr
operator|->
name|lrz_bonustype
operator|=
name|DMU_OT_UINT64_OTHER
expr_stmt|;
name|lr
operator|->
name|lrz_bonuslen
operator|=
name|dmu_bonus_max
argument_list|()
expr_stmt|;
name|lr
operator|->
name|lr_gen
operator|=
name|od
operator|->
name|od_crgen
expr_stmt|;
name|lr
operator|->
name|lr_crtime
index|[
literal|0
index|]
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_replay_create
argument_list|(
name|zd
argument_list|,
name|lr
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|missing
operator|==
literal|0
argument_list|)
expr_stmt|;
name|od
operator|->
name|od_object
operator|=
literal|0
expr_stmt|;
name|missing
operator|++
expr_stmt|;
block|}
else|else
block|{
name|od
operator|->
name|od_object
operator|=
name|lr
operator|->
name|lr_foid
expr_stmt|;
name|od
operator|->
name|od_type
operator|=
name|od
operator|->
name|od_crtype
expr_stmt|;
name|od
operator|->
name|od_blocksize
operator|=
name|od
operator|->
name|od_crblocksize
expr_stmt|;
name|od
operator|->
name|od_gen
operator|=
name|od
operator|->
name|od_crgen
expr_stmt|;
name|ASSERT
argument_list|(
name|od
operator|->
name|od_object
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|ztest_lr_free
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|,
name|od
operator|->
name|od_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|missing
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_remove
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|ztest_od_t
modifier|*
name|od
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|missing
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|_mutex_held
argument_list|(
operator|&
name|zd
operator|->
name|zd_dirobj_lock
argument_list|)
argument_list|)
expr_stmt|;
name|od
operator|+=
name|count
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|od
operator|--
control|)
block|{
if|if
condition|(
name|missing
condition|)
block|{
name|missing
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * No object was found. 		 */
if|if
condition|(
name|od
operator|->
name|od_object
operator|==
literal|0
condition|)
continue|continue;
name|lr_remove_t
modifier|*
name|lr
init|=
name|ztest_lr_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|,
name|od
operator|->
name|od_name
argument_list|)
decl_stmt|;
name|lr
operator|->
name|lr_doid
operator|=
name|od
operator|->
name|od_dir
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ztest_replay_remove
argument_list|(
name|zd
argument_list|,
name|lr
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
name|ENOSPC
argument_list|)
expr_stmt|;
name|missing
operator|++
expr_stmt|;
block|}
else|else
block|{
name|od
operator|->
name|od_object
operator|=
literal|0
expr_stmt|;
block|}
name|ztest_lr_free
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|,
name|od
operator|->
name|od_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|missing
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_write
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|lr_write_t
modifier|*
name|lr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|lr
operator|=
name|ztest_lr_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|object
expr_stmt|;
name|lr
operator|->
name|lr_offset
operator|=
name|offset
expr_stmt|;
name|lr
operator|->
name|lr_length
operator|=
name|size
expr_stmt|;
name|lr
operator|->
name|lr_blkoff
operator|=
literal|0
expr_stmt|;
name|BP_ZERO
argument_list|(
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|lr
operator|+
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|ztest_replay_write
argument_list|(
name|zd
argument_list|,
name|lr
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|ztest_lr_free
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_truncate
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|lr_truncate_t
modifier|*
name|lr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|lr
operator|=
name|ztest_lr_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|object
expr_stmt|;
name|lr
operator|->
name|lr_offset
operator|=
name|offset
expr_stmt|;
name|lr
operator|->
name|lr_length
operator|=
name|size
expr_stmt|;
name|error
operator|=
name|ztest_replay_truncate
argument_list|(
name|zd
argument_list|,
name|lr
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|ztest_lr_free
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_setattr
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|object
parameter_list|)
block|{
name|lr_setattr_t
modifier|*
name|lr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|lr
operator|=
name|ztest_lr_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|object
expr_stmt|;
name|lr
operator|->
name|lr_size
operator|=
literal|0
expr_stmt|;
name|lr
operator|->
name|lr_mode
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ztest_replay_setattr
argument_list|(
name|zd
argument_list|,
name|lr
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|ztest_lr_free
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_prealloc
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ztest_object_lock
argument_list|(
name|zd
argument_list|,
name|object
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
name|rl
operator|=
name|ztest_range_lock
argument_list|(
name|zd
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|txg
operator|=
name|ztest_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|!=
literal|0
condition|)
block|{
name|dmu_prealloc
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|dmu_free_long_range
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|ztest_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ztest_object_unlock
argument_list|(
name|zd
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_io
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|ztest_block_tag_t
name|wbt
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|enum
name|ztest_io_type
name|io_type
decl_stmt|;
name|uint64_t
name|blocksize
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|VERIFY
argument_list|(
name|dmu_object_info
argument_list|(
name|zd
operator|->
name|zd_os
argument_list|,
name|object
argument_list|,
operator|&
name|doi
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|blocksize
operator|=
name|doi
operator|.
name|doi_data_block_size
expr_stmt|;
name|data
operator|=
name|umem_alloc
argument_list|(
name|blocksize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
comment|/* 	 * Pick an i/o type at random, biased toward writing block tags. 	 */
name|io_type
operator|=
name|ztest_random
argument_list|(
name|ZTEST_IO_TYPES
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|io_type
operator|=
name|ZTEST_IO_WRITE_TAG
expr_stmt|;
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|zd
operator|->
name|zd_zilog_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|io_type
condition|)
block|{
case|case
name|ZTEST_IO_WRITE_TAG
case|:
name|ztest_bt_generate
argument_list|(
operator|&
name|wbt
argument_list|,
name|zd
operator|->
name|zd_os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ztest_write
argument_list|(
name|zd
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|wbt
argument_list|)
argument_list|,
operator|&
name|wbt
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZTEST_IO_WRITE_PATTERN
case|:
operator|(
name|void
operator|)
name|memset
argument_list|(
name|data
argument_list|,
literal|'a'
operator|+
operator|(
name|object
operator|+
name|offset
operator|)
operator|%
literal|5
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Induce fletcher2 collisions to ensure that 			 * zio_ddt_collision() detects and resolves them 			 * when using fletcher2-verify for deduplication. 			 */
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
operator|^=
literal|1ULL
operator|<<
literal|63
expr_stmt|;
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|data
operator|)
index|[
literal|4
index|]
operator|^=
literal|1ULL
operator|<<
literal|63
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ztest_write
argument_list|(
name|zd
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|blocksize
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZTEST_IO_WRITE_ZEROES
case|:
name|bzero
argument_list|(
name|data
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ztest_write
argument_list|(
name|zd
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|blocksize
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZTEST_IO_TRUNCATE
case|:
operator|(
name|void
operator|)
name|ztest_truncate
argument_list|(
name|zd
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZTEST_IO_SETATTR
case|:
operator|(
name|void
operator|)
name|ztest_setattr
argument_list|(
name|zd
argument_list|,
name|object
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZTEST_IO_REWRITE
case|:
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|ztest_dsl_prop_set_uint64
argument_list|(
name|zd
operator|->
name|zd_name
argument_list|,
name|ZFS_PROP_CHECKSUM
argument_list|,
name|spa_dedup_checksum
argument_list|(
name|ztest_spa
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|ENOSPC
argument_list|)
expr_stmt|;
name|err
operator|=
name|ztest_dsl_prop_set_uint64
argument_list|(
name|zd
operator|->
name|zd_name
argument_list|,
name|ZFS_PROP_COMPRESSION
argument_list|,
name|ztest_random_dsl_prop
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|ENOSPC
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dmu_read
argument_list|(
name|zd
operator|->
name|zd_os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|blocksize
argument_list|,
name|data
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ztest_write
argument_list|(
name|zd
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|blocksize
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|zd
operator|->
name|zd_zilog_lock
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|data
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize an object description template.  */
end_comment

begin_function
specifier|static
name|void
name|ztest_od_init
parameter_list|(
name|ztest_od_t
modifier|*
name|od
parameter_list|,
name|uint64_t
name|id
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|,
name|uint64_t
name|index
parameter_list|,
name|dmu_object_type_t
name|type
parameter_list|,
name|uint64_t
name|blocksize
parameter_list|,
name|uint64_t
name|gen
parameter_list|)
block|{
name|od
operator|->
name|od_dir
operator|=
name|ZTEST_DIROBJ
expr_stmt|;
name|od
operator|->
name|od_object
operator|=
literal|0
expr_stmt|;
name|od
operator|->
name|od_crtype
operator|=
name|type
expr_stmt|;
name|od
operator|->
name|od_crblocksize
operator|=
name|blocksize
condition|?
name|blocksize
else|:
name|ztest_random_blocksize
argument_list|()
expr_stmt|;
name|od
operator|->
name|od_crgen
operator|=
name|gen
expr_stmt|;
name|od
operator|->
name|od_type
operator|=
name|DMU_OT_NONE
expr_stmt|;
name|od
operator|->
name|od_blocksize
operator|=
literal|0
expr_stmt|;
name|od
operator|->
name|od_gen
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|od
operator|->
name|od_name
argument_list|,
sizeof|sizeof
argument_list|(
name|od
operator|->
name|od_name
argument_list|)
argument_list|,
literal|"%s(%lld)[%llu]"
argument_list|,
name|tag
argument_list|,
operator|(
name|int64_t
operator|)
name|id
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lookup or create the objects for a test using the od template.  * If the objects do not all exist, or if 'remove' is specified,  * remove any existing objects and create new ones.  Otherwise,  * use the existing objects.  */
end_comment

begin_function
specifier|static
name|int
name|ztest_object_init
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|ztest_od_t
modifier|*
name|od
parameter_list|,
name|size_t
name|size
parameter_list|,
name|boolean_t
name|remove
parameter_list|)
block|{
name|int
name|count
init|=
name|size
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|od
argument_list|)
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|VERIFY
argument_list|(
name|mutex_lock
argument_list|(
operator|&
name|zd
operator|->
name|zd_dirobj_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ztest_lookup
argument_list|(
name|zd
argument_list|,
name|od
argument_list|,
name|count
argument_list|)
operator|!=
literal|0
operator|||
name|remove
operator|)
operator|&&
operator|(
name|ztest_remove
argument_list|(
name|zd
argument_list|,
name|od
argument_list|,
name|count
argument_list|)
operator|!=
literal|0
operator|||
name|ztest_create
argument_list|(
name|zd
argument_list|,
name|od
argument_list|,
name|count
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
name|zd
operator|->
name|zd_od
operator|=
name|od
expr_stmt|;
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|zd
operator|->
name|zd_dirobj_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_zil_commit
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|zilog_t
modifier|*
name|zilog
init|=
name|zd
operator|->
name|zd_zilog
decl_stmt|;
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|zd
operator|->
name|zd_zilog_lock
argument_list|)
expr_stmt|;
name|zil_commit
argument_list|(
name|zilog
argument_list|,
name|ztest_random
argument_list|(
name|ZTEST_OBJECTS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Remember the committed values in zd, which is in parent/child 	 * shared memory.  If we die, the next iteration of ztest_run() 	 * will verify that the log really does contain this record. 	 */
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zd
operator|->
name|zd_shared
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zd
operator|->
name|zd_shared
operator|->
name|zd_seq
argument_list|,
operator|<=
argument_list|,
name|zilog
operator|->
name|zl_commit_lr_seq
argument_list|)
expr_stmt|;
name|zd
operator|->
name|zd_shared
operator|->
name|zd_seq
operator|=
name|zilog
operator|->
name|zl_commit_lr_seq
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|zd
operator|->
name|zd_zilog_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is designed to simulate the operations that occur during a  * mount/unmount operation.  We hold the dataset across these operations in an  * attempt to expose any implicit assumptions about ZIL management.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_zil_remount
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
comment|/* 	 * We grab the zd_dirobj_lock to ensure that no other thread is 	 * updating the zil (i.e. adding in-memory log records) and the 	 * zd_zilog_lock to block any I/O. 	 */
name|VERIFY0
argument_list|(
name|mutex_lock
argument_list|(
operator|&
name|zd
operator|->
name|zd_dirobj_lock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_wrlock
argument_list|(
operator|&
name|zd
operator|->
name|zd_zilog_lock
argument_list|)
expr_stmt|;
comment|/* zfsvfs_teardown() */
name|zil_close
argument_list|(
name|zd
operator|->
name|zd_zilog
argument_list|)
expr_stmt|;
comment|/* zfsvfs_setup() */
name|VERIFY
argument_list|(
name|zil_open
argument_list|(
name|os
argument_list|,
name|ztest_get_data
argument_list|)
operator|==
name|zd
operator|->
name|zd_zilog
argument_list|)
expr_stmt|;
name|zil_replay
argument_list|(
name|os
argument_list|,
name|zd
argument_list|,
name|ztest_replay_vector
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|zd
operator|->
name|zd_zilog_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|zd
operator|->
name|zd_dirobj_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that we can't destroy an active pool, create an existing pool,  * or create a pool with a bad vdev spec.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_spa_create_destroy
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|ztest_shared_opts_t
modifier|*
name|zo
init|=
operator|&
name|ztest_opts
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
comment|/* 	 * Attempt to create using a bad file. 	 */
name|nvroot
operator|=
name|make_vdev_root
argument_list|(
literal|"/dev/bogus"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|ENOENT
argument_list|,
operator|==
argument_list|,
name|spa_create
argument_list|(
literal|"ztest_bad_file"
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to create using a bad mirror. 	 */
name|nvroot
operator|=
name|make_vdev_root
argument_list|(
literal|"/dev/bogus"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|ENOENT
argument_list|,
operator|==
argument_list|,
name|spa_create
argument_list|(
literal|"ztest_bad_mirror"
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to create an existing pool.  It shouldn't matter 	 * what's in the nvroot; we should fail with EEXIST. 	 */
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
name|nvroot
operator|=
name|make_vdev_root
argument_list|(
literal|"/dev/bogus"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|EEXIST
argument_list|,
operator|==
argument_list|,
name|spa_create
argument_list|(
name|zo
operator|->
name|zo_pool
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|spa_open
argument_list|(
name|zo
operator|->
name|zo_pool
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|EBUSY
argument_list|,
operator|==
argument_list|,
name|spa_destroy
argument_list|(
name|zo
operator|->
name|zo_pool
argument_list|)
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_spa_upgrade
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|uint64_t
name|initial_version
init|=
name|SPA_VERSION_INITIAL
decl_stmt|;
name|uint64_t
name|version
decl_stmt|,
name|newversion
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|,
modifier|*
name|props
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|VERIFY0
argument_list|(
name|mutex_lock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|kmem_asprintf
argument_list|(
literal|"%s_upgrade"
argument_list|,
name|ztest_opts
operator|.
name|zo_pool
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up from previous runs. 	 */
operator|(
name|void
operator|)
name|spa_destroy
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|nvroot
operator|=
name|make_vdev_root
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
name|ztest_opts
operator|.
name|zo_vdev_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ztest_opts
operator|.
name|zo_raidz
argument_list|,
name|ztest_opts
operator|.
name|zo_mirrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If we're configuring a RAIDZ device then make sure that the 	 * the initial version is capable of supporting that feature. 	 */
switch|switch
condition|(
name|ztest_opts
operator|.
name|zo_raidz_parity
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|initial_version
operator|=
name|SPA_VERSION_INITIAL
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|initial_version
operator|=
name|SPA_VERSION_RAIDZ2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|initial_version
operator|=
name|SPA_VERSION_RAIDZ3
expr_stmt|;
break|break;
block|}
comment|/* 	 * Create a pool with a spa version that can be upgraded. Pick 	 * a value between initial_version and SPA_VERSION_BEFORE_FEATURES. 	 */
do|do
block|{
name|version
operator|=
name|ztest_random_spa_version
argument_list|(
name|initial_version
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|version
operator|>
name|SPA_VERSION_BEFORE_FEATURES
condition|)
do|;
name|props
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_VERSION
argument_list|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|spa_create
argument_list|(
name|name
argument_list|,
name|nvroot
argument_list|,
name|props
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|spa_open
argument_list|(
name|name
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|,
operator|==
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|newversion
operator|=
name|ztest_random_spa_version
argument_list|(
name|version
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"upgrading spa version from %llu to %llu\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|version
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|newversion
argument_list|)
expr_stmt|;
block|}
name|spa_upgrade
argument_list|(
name|spa
argument_list|,
name|newversion
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|,
operator|>
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|,
operator|==
argument_list|,
name|fnvlist_lookup_uint64
argument_list|(
name|spa
operator|->
name|spa_config
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_VERSION
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vdev_t
modifier|*
name|vdev_lookup_by_path
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|vdev_t
modifier|*
name|mvd
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_path
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|path
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|vd
operator|)
return|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|mvd
operator|=
name|vdev_lookup_by_path
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|mvd
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the first available hole which can be used as a top-level.  */
end_comment

begin_function
name|int
name|find_vdev_hole
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|RW_READER
argument_list|)
operator|==
name|SCL_VDEV
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|cvd
init|=
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|cvd
operator|->
name|vdev_ishole
condition|)
break|break;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that vdev_add() works as expected.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_vdev_add_remove
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|ztest_shared_t
modifier|*
name|zs
init|=
name|ztest_shared
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|ztest_spa
decl_stmt|;
name|uint64_t
name|leaves
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|int
name|error
decl_stmt|;
name|VERIFY
argument_list|(
name|mutex_lock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|leaves
operator|=
name|MAX
argument_list|(
name|zs
operator|->
name|zs_mirrors
operator|+
name|zs
operator|->
name|zs_splits
argument_list|,
literal|1
argument_list|)
operator|*
name|ztest_opts
operator|.
name|zo_raidz
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|ztest_shared
operator|->
name|zs_vdev_next_leaf
operator|=
name|find_vdev_hole
argument_list|(
name|spa
argument_list|)
operator|*
name|leaves
expr_stmt|;
comment|/* 	 * If we have slogs then remove them 1/4 of the time. 	 */
if|if
condition|(
name|spa_has_slogs
argument_list|(
name|spa
argument_list|)
operator|&&
name|ztest_random
argument_list|(
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Grab the guid from the head of the log class rotor. 		 */
name|guid
operator|=
name|spa_log_class
argument_list|(
name|spa
argument_list|)
operator|->
name|mc_rotor
operator|->
name|mg_vd
operator|->
name|vdev_guid
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 		 * We have to grab the zs_name_lock as writer to 		 * prevent a race between removing a slog (dmu_objset_find) 		 * and destroying a dataset. Removing the slog will 		 * grab a reference on the dataset which may cause 		 * dmu_objset_destroy() to fail with EBUSY thus 		 * leaving the dataset in an inconsistent state. 		 */
name|VERIFY
argument_list|(
name|rw_wrlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_vdev_remove
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EEXIST
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_vdev_remove() = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 		 * Make 1/4 of the devices be log devices. 		 */
name|nvroot
operator|=
name|make_vdev_root
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ztest_opts
operator|.
name|zo_vdev_size
argument_list|,
literal|0
argument_list|,
name|ztest_random
argument_list|(
literal|4
argument_list|)
operator|==
literal|0
argument_list|,
name|ztest_opts
operator|.
name|zo_raidz
argument_list|,
name|zs
operator|->
name|zs_mirrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_vdev_add
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
name|ztest_record_enospc
argument_list|(
literal|"spa_vdev_add"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_vdev_add() = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that adding/removing aux devices (l2arc, hot spare) works as expected.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_vdev_aux_add_remove
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|ztest_shared_t
modifier|*
name|zs
init|=
name|ztest_shared
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|ztest_spa
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|spa_aux_vdev_t
modifier|*
name|sav
decl_stmt|;
name|char
modifier|*
name|aux
decl_stmt|;
name|uint64_t
name|guid
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sav
operator|=
operator|&
name|spa
operator|->
name|spa_spares
expr_stmt|;
name|aux
operator|=
name|ZPOOL_CONFIG_SPARES
expr_stmt|;
block|}
else|else
block|{
name|sav
operator|=
operator|&
name|spa
operator|->
name|spa_l2cache
expr_stmt|;
name|aux
operator|=
name|ZPOOL_CONFIG_L2CACHE
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|mutex_lock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|sav_count
operator|!=
literal|0
operator|&&
name|ztest_random
argument_list|(
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Pick a random device to remove. 		 */
name|guid
operator|=
name|sav
operator|->
name|sav_vdevs
index|[
name|ztest_random
argument_list|(
name|sav
operator|->
name|sav_count
argument_list|)
index|]
operator|->
name|vdev_guid
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Find an unused device we can add. 		 */
name|zs
operator|->
name|zs_vdev_aux
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
name|ztest_aux_template
argument_list|,
name|ztest_opts
operator|.
name|zo_dir
argument_list|,
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
name|aux
argument_list|,
name|zs
operator|->
name|zs_vdev_aux
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sav
operator|->
name|sav_vdevs
index|[
name|c
index|]
operator|->
name|vdev_path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|sav
operator|->
name|sav_count
operator|&&
name|vdev_lookup_by_path
argument_list|(
name|rvd
argument_list|,
name|path
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|zs
operator|->
name|zs_vdev_aux
operator|++
expr_stmt|;
block|}
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Add a new device. 		 */
name|nvlist_t
modifier|*
name|nvroot
init|=
name|make_vdev_root
argument_list|(
name|NULL
argument_list|,
name|aux
argument_list|,
name|NULL
argument_list|,
operator|(
name|ztest_opts
operator|.
name|zo_vdev_size
operator|*
literal|5
operator|)
operator|/
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|error
operator|=
name|spa_vdev_add
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_vdev_add(%p) = %d"
argument_list|,
name|nvroot
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Remove an existing device.  Sometimes, dirty its 		 * vdev state first to make sure we handle removal 		 * of devices that have pending state changes. 		 */
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|vdev_online
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_vdev_remove
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EBUSY
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"spa_vdev_remove(%llu) = %d"
argument_list|,
name|guid
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * split a pool if it has mirror tlvdevs  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_split_pool
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|ztest_shared_t
modifier|*
name|zs
init|=
name|ztest_shared
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|ztest_spa
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|nvlist_t
modifier|*
name|tree
decl_stmt|,
modifier|*
modifier|*
name|child
decl_stmt|,
modifier|*
name|config
decl_stmt|,
modifier|*
name|split
decl_stmt|,
modifier|*
modifier|*
name|schild
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|,
name|schildren
init|=
literal|0
decl_stmt|,
name|lastlogid
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|VERIFY
argument_list|(
name|mutex_lock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* ensure we have a useable config; mirrors of raidz aren't supported */
if|if
condition|(
name|zs
operator|->
name|zs_mirrors
operator|<
literal|3
operator|||
name|ztest_opts
operator|.
name|zo_raidz
operator|>
literal|1
condition|)
block|{
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* clean up the old pool, if any */
operator|(
name|void
operator|)
name|spa_destroy
argument_list|(
literal|"splitp"
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
comment|/* generate a config from the existing config */
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|spa
operator|->
name|spa_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|tree
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|tree
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|schild
operator|=
name|malloc
argument_list|(
name|rvd
operator|->
name|vdev_children
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|tvd
init|=
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|mchild
decl_stmt|;
name|uint_t
name|mchildren
decl_stmt|;
if|if
condition|(
name|tvd
operator|->
name|vdev_islog
operator|||
name|tvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_hole_ops
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|schild
index|[
name|schildren
index|]
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|schild
index|[
name|schildren
index|]
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_HOLE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|schild
index|[
name|schildren
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_HOLE
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastlogid
operator|==
literal|0
condition|)
name|lastlogid
operator|=
name|schildren
expr_stmt|;
operator|++
name|schildren
expr_stmt|;
continue|continue;
block|}
name|lastlogid
operator|=
literal|0
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|mchild
argument_list|,
operator|&
name|mchildren
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|mchild
index|[
literal|0
index|]
argument_list|,
operator|&
name|schild
index|[
name|schildren
operator|++
index|]
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* OK, create a config that can be used to split */
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|split
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|split
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_ROOT
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|split
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|schild
argument_list|,
name|lastlogid
operator|!=
literal|0
condition|?
name|lastlogid
else|:
name|schildren
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
name|split
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|schildren
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|schild
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|schild
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|split
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_wrlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_vdev_split_mirror
argument_list|(
name|spa
argument_list|,
literal|"splitp"
argument_list|,
name|config
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"successful split - results:\n"
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|show_pool_stats
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|show_pool_stats
argument_list|(
name|spa_lookup
argument_list|(
literal|"splitp"
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
operator|++
name|zs
operator|->
name|zs_splits
expr_stmt|;
operator|--
name|zs
operator|->
name|zs_mirrors
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that we can attach and detach devices.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_vdev_attach_detach
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|ztest_shared_t
modifier|*
name|zs
init|=
name|ztest_shared
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|ztest_spa
decl_stmt|;
name|spa_aux_vdev_t
modifier|*
name|sav
init|=
operator|&
name|spa
operator|->
name|spa_spares
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|oldvd
decl_stmt|,
modifier|*
name|newvd
decl_stmt|,
modifier|*
name|pvd
decl_stmt|;
name|nvlist_t
modifier|*
name|root
decl_stmt|;
name|uint64_t
name|leaves
decl_stmt|;
name|uint64_t
name|leaf
decl_stmt|,
name|top
decl_stmt|;
name|uint64_t
name|ashift
init|=
name|ztest_get_ashift
argument_list|()
decl_stmt|;
name|uint64_t
name|oldguid
decl_stmt|,
name|pguid
decl_stmt|;
name|uint64_t
name|oldsize
decl_stmt|,
name|newsize
decl_stmt|;
name|char
name|oldpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|newpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|replacing
decl_stmt|;
name|int
name|oldvd_has_siblings
init|=
name|B_FALSE
decl_stmt|;
name|int
name|newvd_is_spare
init|=
name|B_FALSE
decl_stmt|;
name|int
name|oldvd_is_log
decl_stmt|;
name|int
name|error
decl_stmt|,
name|expected_error
decl_stmt|;
name|VERIFY
argument_list|(
name|mutex_lock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|leaves
operator|=
name|MAX
argument_list|(
name|zs
operator|->
name|zs_mirrors
argument_list|,
literal|1
argument_list|)
operator|*
name|ztest_opts
operator|.
name|zo_raidz
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
comment|/* 	 * Decide whether to do an attach or a replace. 	 */
name|replacing
operator|=
name|ztest_random
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Pick a random top-level vdev. 	 */
name|top
operator|=
name|ztest_random_vdev_top
argument_list|(
name|spa
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Pick a random leaf within it. 	 */
name|leaf
operator|=
name|ztest_random
argument_list|(
name|leaves
argument_list|)
expr_stmt|;
comment|/* 	 * Locate this vdev. 	 */
name|oldvd
operator|=
name|rvd
operator|->
name|vdev_child
index|[
name|top
index|]
expr_stmt|;
if|if
condition|(
name|zs
operator|->
name|zs_mirrors
operator|>=
literal|1
condition|)
block|{
name|ASSERT
argument_list|(
name|oldvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_mirror_ops
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|oldvd
operator|->
name|vdev_children
operator|>=
name|zs
operator|->
name|zs_mirrors
argument_list|)
expr_stmt|;
name|oldvd
operator|=
name|oldvd
operator|->
name|vdev_child
index|[
name|leaf
operator|/
name|ztest_opts
operator|.
name|zo_raidz
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ztest_opts
operator|.
name|zo_raidz
operator|>
literal|1
condition|)
block|{
name|ASSERT
argument_list|(
name|oldvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_raidz_ops
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|oldvd
operator|->
name|vdev_children
operator|==
name|ztest_opts
operator|.
name|zo_raidz
argument_list|)
expr_stmt|;
name|oldvd
operator|=
name|oldvd
operator|->
name|vdev_child
index|[
name|leaf
operator|%
name|ztest_opts
operator|.
name|zo_raidz
index|]
expr_stmt|;
block|}
comment|/* 	 * If we're already doing an attach or replace, oldvd may be a 	 * mirror vdev -- in which case, pick a random child. 	 */
while|while
condition|(
name|oldvd
operator|->
name|vdev_children
operator|!=
literal|0
condition|)
block|{
name|oldvd_has_siblings
operator|=
name|B_TRUE
expr_stmt|;
name|ASSERT
argument_list|(
name|oldvd
operator|->
name|vdev_children
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|oldvd
operator|=
name|oldvd
operator|->
name|vdev_child
index|[
name|ztest_random
argument_list|(
name|oldvd
operator|->
name|vdev_children
argument_list|)
index|]
expr_stmt|;
block|}
name|oldguid
operator|=
name|oldvd
operator|->
name|vdev_guid
expr_stmt|;
name|oldsize
operator|=
name|vdev_get_min_asize
argument_list|(
name|oldvd
argument_list|)
expr_stmt|;
name|oldvd_is_log
operator|=
name|oldvd
operator|->
name|vdev_top
operator|->
name|vdev_islog
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|oldpath
argument_list|,
name|oldvd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|pvd
operator|=
name|oldvd
operator|->
name|vdev_parent
expr_stmt|;
name|pguid
operator|=
name|pvd
operator|->
name|vdev_guid
expr_stmt|;
comment|/* 	 * If oldvd has siblings, then half of the time, detach it. 	 */
if|if
condition|(
name|oldvd_has_siblings
operator|&&
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_vdev_detach
argument_list|(
name|spa
argument_list|,
name|oldguid
argument_list|,
name|pguid
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENODEV
operator|&&
name|error
operator|!=
name|EBUSY
operator|&&
name|error
operator|!=
name|ENOTSUP
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"detach (%s) returned %d"
argument_list|,
name|oldpath
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * For the new vdev, choose with equal probability between the two 	 * standard paths (ending in either 'a' or 'b') or a random hot spare. 	 */
if|if
condition|(
name|sav
operator|->
name|sav_count
operator|!=
literal|0
operator|&&
name|ztest_random
argument_list|(
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newvd
operator|=
name|sav
operator|->
name|sav_vdevs
index|[
name|ztest_random
argument_list|(
name|sav
operator|->
name|sav_count
argument_list|)
index|]
expr_stmt|;
name|newvd_is_spare
operator|=
name|B_TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|newvd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|newpath
argument_list|,
sizeof|sizeof
argument_list|(
name|newpath
argument_list|)
argument_list|,
name|ztest_dev_template
argument_list|,
name|ztest_opts
operator|.
name|zo_dir
argument_list|,
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
name|top
operator|*
name|leaves
operator|+
name|leaf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|newpath
index|[
name|strlen
argument_list|(
name|newpath
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'b'
expr_stmt|;
name|newvd
operator|=
name|vdev_lookup_by_path
argument_list|(
name|rvd
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newvd
condition|)
block|{
name|newsize
operator|=
name|vdev_get_min_asize
argument_list|(
name|newvd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Make newsize a little bigger or smaller than oldsize. 		 * If it's smaller, the attach should fail. 		 * If it's larger, and we're doing a replace, 		 * we should get dynamic LUN growth when we're done. 		 */
name|newsize
operator|=
literal|10
operator|*
name|oldsize
operator|/
operator|(
literal|9
operator|+
name|ztest_random
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* 	 * If pvd is not a mirror or root, the attach should fail with ENOTSUP, 	 * unless it's a replace; in that case any non-replacing parent is OK. 	 * 	 * If newvd is already part of the pool, it should fail with EBUSY. 	 * 	 * If newvd is too small, it should fail with EOVERFLOW. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_mirror_ops
operator|&&
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_root_ops
operator|&&
operator|(
operator|!
name|replacing
operator|||
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
operator|||
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|)
condition|)
name|expected_error
operator|=
name|ENOTSUP
expr_stmt|;
elseif|else
if|if
condition|(
name|newvd_is_spare
operator|&&
operator|(
operator|!
name|replacing
operator|||
name|oldvd_is_log
operator|)
condition|)
name|expected_error
operator|=
name|ENOTSUP
expr_stmt|;
elseif|else
if|if
condition|(
name|newvd
operator|==
name|oldvd
condition|)
name|expected_error
operator|=
name|replacing
condition|?
literal|0
else|:
name|EBUSY
expr_stmt|;
elseif|else
if|if
condition|(
name|vdev_lookup_by_path
argument_list|(
name|rvd
argument_list|,
name|newpath
argument_list|)
operator|!=
name|NULL
condition|)
name|expected_error
operator|=
name|EBUSY
expr_stmt|;
elseif|else
if|if
condition|(
name|newsize
operator|<
name|oldsize
condition|)
name|expected_error
operator|=
name|EOVERFLOW
expr_stmt|;
elseif|else
if|if
condition|(
name|ashift
operator|>
name|oldvd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
condition|)
name|expected_error
operator|=
name|EDOM
expr_stmt|;
else|else
name|expected_error
operator|=
literal|0
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Build the nvlist describing newpath. 	 */
name|root
operator|=
name|make_vdev_root
argument_list|(
name|newpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|newvd
operator|==
name|NULL
condition|?
name|newsize
else|:
literal|0
argument_list|,
name|ashift
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_vdev_attach
argument_list|(
name|spa
argument_list|,
name|oldguid
argument_list|,
name|root
argument_list|,
name|replacing
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|/* 	 * If our parent was the replacing vdev, but the replace completed, 	 * then instead of failing with ENOTSUP we may either succeed, 	 * fail with ENODEV, or fail with EOVERFLOW. 	 */
if|if
condition|(
name|expected_error
operator|==
name|ENOTSUP
operator|&&
operator|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ENODEV
operator|||
name|error
operator|==
name|EOVERFLOW
operator|)
condition|)
name|expected_error
operator|=
name|error
expr_stmt|;
comment|/* 	 * If someone grew the LUN, the replacement may be too small. 	 */
if|if
condition|(
name|error
operator|==
name|EOVERFLOW
operator|||
name|error
operator|==
name|EBUSY
condition|)
name|expected_error
operator|=
name|error
expr_stmt|;
comment|/* XXX workaround 6690467 */
if|if
condition|(
name|error
operator|!=
name|expected_error
operator|&&
name|expected_error
operator|!=
name|EBUSY
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"attach (%s %llu, %s %llu, %d) "
literal|"returned %d, expected %d"
argument_list|,
name|oldpath
argument_list|,
name|oldsize
argument_list|,
name|newpath
argument_list|,
name|newsize
argument_list|,
name|replacing
argument_list|,
name|error
argument_list|,
name|expected_error
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback function which expands the physical size of the vdev.  */
end_comment

begin_function
name|vdev_t
modifier|*
name|grow_vdev
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|size_t
modifier|*
name|newsize
init|=
name|arg
decl_stmt|;
name|size_t
name|fsize
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|RW_READER
argument_list|)
operator|==
name|SCL_STATE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|vd
operator|)
return|;
name|fsize
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ftruncate
argument_list|(
name|fd
argument_list|,
operator|*
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|6
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s grew from %lu to %lu bytes\n"
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|,
operator|(
name|ulong_t
operator|)
name|fsize
argument_list|,
operator|(
name|ulong_t
operator|)
operator|*
name|newsize
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback function which expands a given vdev by calling vdev_online().  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|vdev_t
modifier|*
name|online_vdev
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|vdev_t
modifier|*
name|tvd
init|=
name|vd
operator|->
name|vdev_top
decl_stmt|;
name|uint64_t
name|guid
init|=
name|vd
operator|->
name|vdev_guid
decl_stmt|;
name|uint64_t
name|generation
init|=
name|spa
operator|->
name|spa_config_generation
operator|+
literal|1
decl_stmt|;
name|vdev_state_t
name|newstate
init|=
name|VDEV_STATE_UNKNOWN
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|RW_READER
argument_list|)
operator|==
name|SCL_STATE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
argument_list|)
expr_stmt|;
comment|/* Calling vdev_online will initialize the new metaslabs */
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|spa
argument_list|)
expr_stmt|;
name|error
operator|=
name|vdev_online
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|ZFS_ONLINE_EXPAND
argument_list|,
operator|&
name|newstate
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|spa
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
comment|/* 	 * If vdev_online returned an error or the underlying vdev_open 	 * failed then we abort the expand. The only way to know that 	 * vdev_open fails is by checking the returned newstate. 	 */
if|if
condition|(
name|error
operator|||
name|newstate
operator|!=
name|VDEV_STATE_HEALTHY
condition|)
block|{
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|5
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Unable to expand vdev, state %llu, "
literal|"error %d\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|newstate
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|vd
operator|)
return|;
block|}
name|ASSERT3U
argument_list|(
name|newstate
argument_list|,
operator|==
argument_list|,
name|VDEV_STATE_HEALTHY
argument_list|)
expr_stmt|;
comment|/* 	 * Since we dropped the lock we need to ensure that we're 	 * still talking to the original vdev. It's possible this 	 * vdev may have been detached/replaced while we were 	 * trying to online it. 	 */
if|if
condition|(
name|generation
operator|!=
name|spa
operator|->
name|spa_config_generation
condition|)
block|{
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|5
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"vdev configuration has changed, "
literal|"guid %llu, state %llu, expected gen %llu, "
literal|"got gen %llu\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|guid
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|tvd
operator|->
name|vdev_state
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|generation
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|spa
operator|->
name|spa_config_generation
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|vd
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Traverse the vdev tree calling the supplied function.  * We continue to walk the tree until we either have walked all  * children or we receive a non-NULL return from the callback.  * If a NULL callback is passed, then we just return back the first  * leaf vdev we encounter.  */
end_comment

begin_function
name|vdev_t
modifier|*
name|vdev_walk_tree
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|vdev_t
modifier|*
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|vdev_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return
operator|(
name|vd
operator|)
return|;
else|else
return|return
operator|(
name|func
argument_list|(
name|vd
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
for|for
control|(
name|uint_t
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|cvd
init|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|cvd
operator|=
name|vdev_walk_tree
argument_list|(
name|cvd
argument_list|,
name|func
argument_list|,
name|arg
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|cvd
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that dynamic LUN growth works as expected.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_vdev_LUN_growth
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|ztest_spa
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
name|metaslab_class_t
modifier|*
name|mc
decl_stmt|;
name|metaslab_group_t
modifier|*
name|mg
decl_stmt|;
name|size_t
name|psize
decl_stmt|,
name|newsize
decl_stmt|;
name|uint64_t
name|top
decl_stmt|;
name|uint64_t
name|old_class_space
decl_stmt|,
name|new_class_space
decl_stmt|,
name|old_ms_count
decl_stmt|,
name|new_ms_count
decl_stmt|;
name|VERIFY
argument_list|(
name|mutex_lock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|spa
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|top
operator|=
name|ztest_random_vdev_top
argument_list|(
name|spa
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|tvd
operator|=
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_child
index|[
name|top
index|]
expr_stmt|;
name|mg
operator|=
name|tvd
operator|->
name|vdev_mg
expr_stmt|;
name|mc
operator|=
name|mg
operator|->
name|mg_class
expr_stmt|;
name|old_ms_count
operator|=
name|tvd
operator|->
name|vdev_ms_count
expr_stmt|;
name|old_class_space
operator|=
name|metaslab_class_get_space
argument_list|(
name|mc
argument_list|)
expr_stmt|;
comment|/* 	 * Determine the size of the first leaf vdev associated with 	 * our top-level device. 	 */
name|vd
operator|=
name|vdev_walk_tree
argument_list|(
name|tvd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|vd
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
argument_list|)
expr_stmt|;
name|psize
operator|=
name|vd
operator|->
name|vdev_psize
expr_stmt|;
comment|/* 	 * We only try to expand the vdev if it's healthy, less than 4x its 	 * original size, and it has a valid psize. 	 */
if|if
condition|(
name|tvd
operator|->
name|vdev_state
operator|!=
name|VDEV_STATE_HEALTHY
operator|||
name|psize
operator|==
literal|0
operator|||
name|psize
operator|>=
literal|4
operator|*
name|ztest_opts
operator|.
name|zo_vdev_size
condition|)
block|{
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|spa
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
name|psize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|psize
operator|+
name|psize
operator|/
literal|8
expr_stmt|;
name|ASSERT3U
argument_list|(
name|newsize
argument_list|,
operator|>
argument_list|,
name|psize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|6
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Expanding LUN %s from %lu to %lu\n"
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|,
operator|(
name|ulong_t
operator|)
name|psize
argument_list|,
operator|(
name|ulong_t
operator|)
name|newsize
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Growing the vdev is a two step process: 	 *	1). expand the physical size (i.e. relabel) 	 *	2). online the vdev to create the new metaslabs 	 */
if|if
condition|(
name|vdev_walk_tree
argument_list|(
name|tvd
argument_list|,
name|grow_vdev
argument_list|,
operator|&
name|newsize
argument_list|)
operator|!=
name|NULL
operator|||
name|vdev_walk_tree
argument_list|(
name|tvd
argument_list|,
name|online_vdev
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
operator|||
name|tvd
operator|->
name|vdev_state
operator|!=
name|VDEV_STATE_HEALTHY
condition|)
block|{
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|5
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Could not expand LUN because "
literal|"the vdev configuration changed.\n"
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|spa
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Expanding the LUN will update the config asynchronously, 	 * thus we must wait for the async thread to complete any 	 * pending tasks before proceeding. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|boolean_t
name|done
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|done
operator|=
operator|(
name|spa
operator|->
name|spa_async_thread
operator|==
name|NULL
operator|&&
operator|!
name|spa
operator|->
name|spa_async_tasks
operator|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
break|break;
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|poll
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
block|}
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|spa
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|tvd
operator|=
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_child
index|[
name|top
index|]
expr_stmt|;
name|new_ms_count
operator|=
name|tvd
operator|->
name|vdev_ms_count
expr_stmt|;
name|new_class_space
operator|=
name|metaslab_class_get_space
argument_list|(
name|mc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvd
operator|->
name|vdev_mg
operator|!=
name|mg
operator|||
name|mg
operator|->
name|mg_class
operator|!=
name|mc
condition|)
block|{
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|5
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Could not verify LUN expansion due to "
literal|"intervening vdev offline or remove.\n"
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|spa
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Make sure we were able to grow the vdev. 	 */
if|if
condition|(
name|new_ms_count
operator|<=
name|old_ms_count
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"LUN expansion failed: ms_count %llu<= %llu\n"
argument_list|,
name|old_ms_count
argument_list|,
name|new_ms_count
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure we were able to grow the pool. 	 */
if|if
condition|(
name|new_class_space
operator|<=
name|old_class_space
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"LUN expansion failed: class_space %llu<= %llu\n"
argument_list|,
name|old_class_space
argument_list|,
name|new_class_space
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|5
condition|)
block|{
name|char
name|oldnumbuf
index|[
literal|6
index|]
decl_stmt|,
name|newnumbuf
index|[
literal|6
index|]
decl_stmt|;
name|nicenum
argument_list|(
name|old_class_space
argument_list|,
name|oldnumbuf
argument_list|)
expr_stmt|;
name|nicenum
argument_list|(
name|new_class_space
argument_list|,
name|newnumbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s grew from %s to %s\n"
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|,
name|oldnumbuf
argument_list|,
name|newnumbuf
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|spa
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that dmu_objset_{create,destroy,open,close} work as expected.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|ztest_objset_create_cb
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
comment|/* 	 * Create the objects common to all ztest datasets. 	 */
name|VERIFY
argument_list|(
name|zap_create_claim
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
name|DMU_OT_ZAP_OTHER
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_dataset_create
parameter_list|(
name|char
modifier|*
name|dsname
parameter_list|)
block|{
name|uint64_t
name|zilset
init|=
name|ztest_random
argument_list|(
literal|100
argument_list|)
decl_stmt|;
name|int
name|err
init|=
name|dmu_objset_create
argument_list|(
name|dsname
argument_list|,
name|DMU_OST_OTHER
argument_list|,
literal|0
argument_list|,
name|ztest_objset_create_cb
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|||
name|zilset
operator|<
literal|80
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|6
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Setting dataset %s to sync always\n"
argument_list|,
name|dsname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ztest_dsl_prop_set_uint64
argument_list|(
name|dsname
argument_list|,
name|ZFS_PROP_SYNC
argument_list|,
name|ZFS_SYNC_ALWAYS
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|ztest_objset_destroy_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Verify that the dataset contains a directory object. 	 */
name|VERIFY0
argument_list|(
name|dmu_objset_own
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|B_TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
block|{
comment|/* We could have crashed in the middle of destroying it */
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|doi
operator|.
name|doi_type
argument_list|,
operator|==
argument_list|,
name|DMU_OT_ZAP_OTHER
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|doi
operator|.
name|doi_physical_blocks_512
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy the dataset. 	 */
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|VERIFY0
argument_list|(
name|dsl_destroy_snapshot
argument_list|(
name|name
argument_list|,
name|B_FALSE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VERIFY0
argument_list|(
name|dsl_destroy_head
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|ztest_snapshot_create
parameter_list|(
name|char
modifier|*
name|osname
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|char
name|snapname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|snapname
argument_list|)
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|id
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_snapshot_one
argument_list|(
name|osname
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EEXIST
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"ztest_snapshot_create(%s@%s) = %d"
argument_list|,
name|osname
argument_list|,
name|snapname
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|ztest_snapshot_destroy
parameter_list|(
name|char
modifier|*
name|osname
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|char
name|snapname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|snapname
argument_list|)
argument_list|,
literal|"%s@%llu"
argument_list|,
name|osname
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|id
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_destroy_snapshot
argument_list|(
name|snapname
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"ztest_snapshot_destroy(%s) = %d"
argument_list|,
name|snapname
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_dmu_objset_create_destroy
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|ztest_ds_t
name|zdtmp
decl_stmt|;
name|int
name|iters
decl_stmt|;
name|int
name|error
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|,
modifier|*
name|os2
decl_stmt|;
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s/temp_%llu"
argument_list|,
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|id
argument_list|)
expr_stmt|;
comment|/* 	 * If this dataset exists from a previous run, process its replay log 	 * half of the time.  If we don't replay it, then dmu_objset_destroy() 	 * (invoked from ztest_objset_destroy_cb()) should just throw it away. 	 */
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
operator|&&
name|dmu_objset_own
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|B_FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ztest_zd_init
argument_list|(
operator|&
name|zdtmp
argument_list|,
name|NULL
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|zil_replay
argument_list|(
name|os
argument_list|,
operator|&
name|zdtmp
argument_list|,
name|ztest_replay_vector
argument_list|)
expr_stmt|;
name|ztest_zd_fini
argument_list|(
operator|&
name|zdtmp
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * There may be an old instance of the dataset we're about to 	 * create lying around from a previous run.  If so, destroy it 	 * and all of its snapshots. 	 */
operator|(
name|void
operator|)
name|dmu_objset_find
argument_list|(
name|name
argument_list|,
name|ztest_objset_destroy_cb
argument_list|,
name|NULL
argument_list|,
name|DS_FIND_CHILDREN
operator||
name|DS_FIND_SNAPSHOTS
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that the destroyed dataset is no longer in the namespace. 	 */
name|VERIFY3U
argument_list|(
name|ENOENT
argument_list|,
operator|==
argument_list|,
name|dmu_objset_own
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|B_TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that we can create a new dataset. 	 */
name|error
operator|=
name|ztest_dataset_create
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_create(%s) = %d"
argument_list|,
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|VERIFY0
argument_list|(
name|dmu_objset_own
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|B_FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|ztest_zd_init
argument_list|(
operator|&
name|zdtmp
argument_list|,
name|NULL
argument_list|,
name|os
argument_list|)
expr_stmt|;
comment|/* 	 * Open the intent log for it. 	 */
name|zilog
operator|=
name|zil_open
argument_list|(
name|os
argument_list|,
name|ztest_get_data
argument_list|)
expr_stmt|;
comment|/* 	 * Put some objects in there, do a little I/O to them, 	 * and randomly take a couple of snapshots along the way. 	 */
name|iters
operator|=
name|ztest_random
argument_list|(
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iters
condition|;
name|i
operator|++
control|)
block|{
name|ztest_dmu_object_alloc_free
argument_list|(
operator|&
name|zdtmp
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
name|iters
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|ztest_snapshot_create
argument_list|(
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Verify that we cannot create an existing dataset. 	 */
name|VERIFY3U
argument_list|(
name|EEXIST
argument_list|,
operator|==
argument_list|,
name|dmu_objset_create
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that we can hold an objset that is also owned. 	 */
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_objset_hold
argument_list|(
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os2
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_objset_rele
argument_list|(
name|os2
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that we cannot own an objset that is already owned. 	 */
name|VERIFY3U
argument_list|(
name|EBUSY
argument_list|,
operator|==
argument_list|,
name|dmu_objset_own
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|B_FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os2
argument_list|)
argument_list|)
expr_stmt|;
name|zil_close
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ztest_zd_fini
argument_list|(
operator|&
name|zdtmp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that dmu_snapshot_{create,destroy,open,close} work as expected.  */
end_comment

begin_function
name|void
name|ztest_dmu_snapshot_create_destroy
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ztest_snapshot_destroy
argument_list|(
name|zd
operator|->
name|zd_name
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ztest_snapshot_create
argument_list|(
name|zd
operator|->
name|zd_name
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cleanup non-standard snapshots and clones.  */
end_comment

begin_function
name|void
name|ztest_dsl_dataset_cleanup
parameter_list|(
name|char
modifier|*
name|osname
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|char
name|snap1name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|clone1name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|snap2name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|clone2name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|snap3name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|snap1name
argument_list|,
sizeof|sizeof
argument_list|(
name|snap1name
argument_list|)
argument_list|,
literal|"%s@s1_%llu"
argument_list|,
name|osname
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|clone1name
argument_list|,
sizeof|sizeof
argument_list|(
name|clone1name
argument_list|)
argument_list|,
literal|"%s/c1_%llu"
argument_list|,
name|osname
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|snap2name
argument_list|,
sizeof|sizeof
argument_list|(
name|snap2name
argument_list|)
argument_list|,
literal|"%s@s2_%llu"
argument_list|,
name|clone1name
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|clone2name
argument_list|,
sizeof|sizeof
argument_list|(
name|clone2name
argument_list|)
argument_list|,
literal|"%s/c2_%llu"
argument_list|,
name|osname
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|snap3name
argument_list|,
sizeof|sizeof
argument_list|(
name|snap3name
argument_list|)
argument_list|,
literal|"%s@s3_%llu"
argument_list|,
name|clone1name
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_destroy_head
argument_list|(
name|clone2name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dsl_destroy_head(%s) = %d"
argument_list|,
name|clone2name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_destroy_snapshot
argument_list|(
name|snap3name
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dsl_destroy_snapshot(%s) = %d"
argument_list|,
name|snap3name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_destroy_snapshot
argument_list|(
name|snap2name
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dsl_destroy_snapshot(%s) = %d"
argument_list|,
name|snap2name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_destroy_head
argument_list|(
name|clone1name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dsl_destroy_head(%s) = %d"
argument_list|,
name|clone1name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_destroy_snapshot
argument_list|(
name|snap1name
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dsl_destroy_snapshot(%s) = %d"
argument_list|,
name|snap1name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify dsl_dataset_promote handles EBUSY  */
end_comment

begin_function
name|void
name|ztest_dsl_dataset_promote_busy
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|char
name|snap1name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|clone1name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|snap2name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|clone2name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|snap3name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|osname
init|=
name|zd
operator|->
name|zd_name
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
name|ztest_dsl_dataset_cleanup
argument_list|(
name|osname
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|snap1name
argument_list|,
sizeof|sizeof
argument_list|(
name|snap1name
argument_list|)
argument_list|,
literal|"%s@s1_%llu"
argument_list|,
name|osname
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|clone1name
argument_list|,
sizeof|sizeof
argument_list|(
name|clone1name
argument_list|)
argument_list|,
literal|"%s/c1_%llu"
argument_list|,
name|osname
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|snap2name
argument_list|,
sizeof|sizeof
argument_list|(
name|snap2name
argument_list|)
argument_list|,
literal|"%s@s2_%llu"
argument_list|,
name|clone1name
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|clone2name
argument_list|,
sizeof|sizeof
argument_list|(
name|clone2name
argument_list|)
argument_list|,
literal|"%s/c2_%llu"
argument_list|,
name|osname
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|snap3name
argument_list|,
sizeof|sizeof
argument_list|(
name|snap3name
argument_list|)
argument_list|,
literal|"%s@s3_%llu"
argument_list|,
name|clone1name
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_snapshot_one
argument_list|(
name|osname
argument_list|,
name|strchr
argument_list|(
name|snap1name
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EEXIST
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_take_snapshot(%s) = %d"
argument_list|,
name|snap1name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_objset_clone
argument_list|(
name|clone1name
argument_list|,
name|snap1name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_create(%s) = %d"
argument_list|,
name|clone1name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_objset_snapshot_one
argument_list|(
name|clone1name
argument_list|,
name|strchr
argument_list|(
name|snap2name
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EEXIST
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_open_snapshot(%s) = %d"
argument_list|,
name|snap2name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_objset_snapshot_one
argument_list|(
name|clone1name
argument_list|,
name|strchr
argument_list|(
name|snap3name
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EEXIST
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_open_snapshot(%s) = %d"
argument_list|,
name|snap3name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_objset_clone
argument_list|(
name|clone2name
argument_list|,
name|snap3name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_create(%s) = %d"
argument_list|,
name|clone2name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_objset_own
argument_list|(
name|snap2name
argument_list|,
name|DMU_OST_ANY
argument_list|,
name|B_TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_own(%s) = %d"
argument_list|,
name|snap2name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_dataset_promote
argument_list|(
name|clone2name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|error
operator|!=
name|EBUSY
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dsl_dataset_promote(%s), %d, not EBUSY"
argument_list|,
name|clone2name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|out
label|:
name|ztest_dsl_dataset_cleanup
argument_list|(
name|osname
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that dmu_object_{alloc,free} work as expected.  */
end_comment

begin_function
name|void
name|ztest_dmu_object_alloc_free
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|ztest_od_t
name|od
index|[
literal|4
index|]
decl_stmt|;
name|int
name|batchsize
init|=
sizeof|sizeof
argument_list|(
name|od
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|od
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|b
init|=
literal|0
init|;
name|b
operator|<
name|batchsize
condition|;
name|b
operator|++
control|)
name|ztest_od_init
argument_list|(
operator|&
name|od
index|[
name|b
index|]
argument_list|,
name|id
argument_list|,
name|FTAG
argument_list|,
name|b
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy the previous batch of objects, create a new batch, 	 * and do some I/O on the new objects. 	 */
if|if
condition|(
name|ztest_object_init
argument_list|(
name|zd
argument_list|,
name|od
argument_list|,
sizeof|sizeof
argument_list|(
name|od
argument_list|)
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
while|while
condition|(
name|ztest_random
argument_list|(
literal|4
operator|*
name|batchsize
argument_list|)
operator|!=
literal|0
condition|)
name|ztest_io
argument_list|(
name|zd
argument_list|,
name|od
index|[
name|ztest_random
argument_list|(
name|batchsize
argument_list|)
index|]
operator|.
name|od_object
argument_list|,
name|ztest_random
argument_list|(
name|ZTEST_RANGE_LOCKS
argument_list|)
operator|<<
name|SPA_MAXBLOCKSHIFT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that dmu_{read,write} work as expected.  */
end_comment

begin_function
name|void
name|ztest_dmu_read_write
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|ztest_od_t
name|od
index|[
literal|2
index|]
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|freeit
decl_stmt|,
name|error
decl_stmt|;
name|uint64_t
name|n
decl_stmt|,
name|s
decl_stmt|,
name|txg
decl_stmt|;
name|bufwad_t
modifier|*
name|packbuf
decl_stmt|,
modifier|*
name|bigbuf
decl_stmt|,
modifier|*
name|pack
decl_stmt|,
modifier|*
name|bigH
decl_stmt|,
modifier|*
name|bigT
decl_stmt|;
name|uint64_t
name|packobj
decl_stmt|,
name|packoff
decl_stmt|,
name|packsize
decl_stmt|,
name|bigobj
decl_stmt|,
name|bigoff
decl_stmt|,
name|bigsize
decl_stmt|;
name|uint64_t
name|chunksize
init|=
operator|(
literal|1000
operator|+
name|ztest_random
argument_list|(
literal|1000
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
decl_stmt|;
name|uint64_t
name|regions
init|=
literal|997
decl_stmt|;
name|uint64_t
name|stride
init|=
literal|123456789ULL
decl_stmt|;
name|uint64_t
name|width
init|=
literal|40
decl_stmt|;
name|int
name|free_percent
init|=
literal|5
decl_stmt|;
comment|/* 	 * This test uses two objects, packobj and bigobj, that are always 	 * updated together (i.e. in the same tx) so that their contents are 	 * in sync and can be compared.  Their contents relate to each other 	 * in a simple way: packobj is a dense array of 'bufwad' structures, 	 * while bigobj is a sparse array of the same bufwads.  Specifically, 	 * for any index n, there are three bufwads that should be identical: 	 * 	 *	packobj, at offset n * sizeof (bufwad_t) 	 *	bigobj, at the head of the nth chunk 	 *	bigobj, at the tail of the nth chunk 	 * 	 * The chunk size is arbitrary. It doesn't have to be a power of two, 	 * and it doesn't have any relation to the object blocksize. 	 * The only requirement is that it can hold at least two bufwads. 	 * 	 * Normally, we write the bufwad to each of these locations. 	 * However, free_percent of the time we instead write zeroes to 	 * packobj and perform a dmu_free_range() on bigobj.  By comparing 	 * bigobj to packobj, we can verify that the DMU is correctly 	 * tracking which parts of an object are allocated and free, 	 * and that the contents of the allocated blocks are correct. 	 */
comment|/* 	 * Read the directory info.  If it's the first time, set things up. 	 */
name|ztest_od_init
argument_list|(
operator|&
name|od
index|[
literal|0
index|]
argument_list|,
name|id
argument_list|,
name|FTAG
argument_list|,
literal|0
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
name|ztest_od_init
argument_list|(
operator|&
name|od
index|[
literal|1
index|]
argument_list|,
name|id
argument_list|,
name|FTAG
argument_list|,
literal|1
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_object_init
argument_list|(
name|zd
argument_list|,
name|od
argument_list|,
sizeof|sizeof
argument_list|(
name|od
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|bigobj
operator|=
name|od
index|[
literal|0
index|]
operator|.
name|od_object
expr_stmt|;
name|packobj
operator|=
name|od
index|[
literal|1
index|]
operator|.
name|od_object
expr_stmt|;
name|chunksize
operator|=
name|od
index|[
literal|0
index|]
operator|.
name|od_gen
expr_stmt|;
name|ASSERT
argument_list|(
name|chunksize
operator|==
name|od
index|[
literal|1
index|]
operator|.
name|od_gen
argument_list|)
expr_stmt|;
comment|/* 	 * Prefetch a random chunk of the big object. 	 * Our aim here is to get some async reads in flight 	 * for blocks that we may free below; the DMU should 	 * handle this race correctly. 	 */
name|n
operator|=
name|ztest_random
argument_list|(
name|regions
argument_list|)
operator|*
name|stride
operator|+
name|ztest_random
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|s
operator|=
literal|1
operator|+
name|ztest_random
argument_list|(
literal|2
operator|*
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dmu_prefetch
argument_list|(
name|os
argument_list|,
name|bigobj
argument_list|,
literal|0
argument_list|,
name|n
operator|*
name|chunksize
argument_list|,
name|s
operator|*
name|chunksize
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|)
expr_stmt|;
comment|/* 	 * Pick a random index and compute the offsets into packobj and bigobj. 	 */
name|n
operator|=
name|ztest_random
argument_list|(
name|regions
argument_list|)
operator|*
name|stride
operator|+
name|ztest_random
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|s
operator|=
literal|1
operator|+
name|ztest_random
argument_list|(
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
name|packoff
operator|=
name|n
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
expr_stmt|;
name|packsize
operator|=
name|s
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
expr_stmt|;
name|bigoff
operator|=
name|n
operator|*
name|chunksize
expr_stmt|;
name|bigsize
operator|=
name|s
operator|*
name|chunksize
expr_stmt|;
name|packbuf
operator|=
name|umem_alloc
argument_list|(
name|packsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
name|bigbuf
operator|=
name|umem_alloc
argument_list|(
name|bigsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
comment|/* 	 * free_percent of the time, free a range of bigobj rather than 	 * overwriting it. 	 */
name|freeit
operator|=
operator|(
name|ztest_random
argument_list|(
literal|100
argument_list|)
operator|<
name|free_percent
operator|)
expr_stmt|;
comment|/* 	 * Read the current contents of our objects. 	 */
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|,
name|packbuf
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|,
name|bigbuf
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Get a tx for the mods to both packobj and bigobj. 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeit
condition|)
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
else|else
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
comment|/* This accounts for setting the checksum/compression. */
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|bigobj
argument_list|)
expr_stmt|;
name|txg
operator|=
name|ztest_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_MIGHTWAIT
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
block|{
name|umem_free
argument_list|(
name|packbuf
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|bigbuf
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
return|return;
block|}
name|enum
name|zio_checksum
name|cksum
decl_stmt|;
do|do
block|{
name|cksum
operator|=
operator|(
expr|enum
name|zio_checksum
operator|)
name|ztest_random_dsl_prop
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cksum
operator|>=
name|ZIO_CHECKSUM_LEGACY_FUNCTIONS
condition|)
do|;
name|dmu_object_set_checksum
argument_list|(
name|os
argument_list|,
name|bigobj
argument_list|,
name|cksum
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|enum
name|zio_compress
name|comp
decl_stmt|;
do|do
block|{
name|comp
operator|=
operator|(
expr|enum
name|zio_compress
operator|)
name|ztest_random_dsl_prop
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|comp
operator|>=
name|ZIO_COMPRESS_LEGACY_FUNCTIONS
condition|)
do|;
name|dmu_object_set_compress
argument_list|(
name|os
argument_list|,
name|bigobj
argument_list|,
name|comp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * For each index from n to n + s, verify that the existing bufwad 	 * in packobj matches the bufwads at the head and tail of the 	 * corresponding chunk in bigobj.  Then update all three bufwads 	 * with the new values we want to write out. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
condition|;
name|i
operator|++
control|)
block|{
comment|/* LINTED */
name|pack
operator|=
operator|(
name|bufwad_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|packbuf
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
operator|)
expr_stmt|;
comment|/* LINTED */
name|bigH
operator|=
operator|(
name|bufwad_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bigbuf
operator|+
name|i
operator|*
name|chunksize
operator|)
expr_stmt|;
comment|/* LINTED */
name|bigT
operator|=
operator|(
name|bufwad_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bigH
operator|+
name|chunksize
operator|)
operator|-
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|bigH
operator|-
operator|(
name|uintptr_t
operator|)
name|bigbuf
operator|<
name|bigsize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|bigT
operator|-
operator|(
name|uintptr_t
operator|)
name|bigbuf
operator|<
name|bigsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
operator|->
name|bw_txg
operator|>
name|txg
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"future leak: got %llx, open txg is %llx"
argument_list|,
name|pack
operator|->
name|bw_txg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
operator|->
name|bw_data
operator|!=
literal|0
operator|&&
name|pack
operator|->
name|bw_index
operator|!=
name|n
operator|+
name|i
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"wrong index: got %llx, wanted %llx+%llx"
argument_list|,
name|pack
operator|->
name|bw_index
argument_list|,
name|n
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|pack
argument_list|,
name|bigH
argument_list|,
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"pack/bigH mismatch in %p/%p"
argument_list|,
name|pack
argument_list|,
name|bigH
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|pack
argument_list|,
name|bigT
argument_list|,
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"pack/bigT mismatch in %p/%p"
argument_list|,
name|pack
argument_list|,
name|bigT
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeit
condition|)
block|{
name|bzero
argument_list|(
name|pack
argument_list|,
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pack
operator|->
name|bw_index
operator|=
name|n
operator|+
name|i
expr_stmt|;
name|pack
operator|->
name|bw_txg
operator|=
name|txg
expr_stmt|;
name|pack
operator|->
name|bw_data
operator|=
literal|1
operator|+
name|ztest_random
argument_list|(
operator|-
literal|2ULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|bigH
operator|=
operator|*
name|pack
expr_stmt|;
operator|*
name|bigT
operator|=
operator|*
name|pack
expr_stmt|;
block|}
comment|/* 	 * We've verified all the old bufwads, and made new ones. 	 * Now write them out. 	 */
name|dmu_write
argument_list|(
name|os
argument_list|,
name|packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|,
name|packbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeit
condition|)
block|{
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|7
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"freeing offset %llx size %llx"
literal|" txg %llx\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bigoff
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bigsize
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|txg
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_free_range
argument_list|(
name|os
argument_list|,
name|bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|7
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"writing offset %llx size %llx"
literal|" txg %llx\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bigoff
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bigsize
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|txg
argument_list|)
expr_stmt|;
block|}
name|dmu_write
argument_list|(
name|os
argument_list|,
name|bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|,
name|bigbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Sanity check the stuff we just wrote. 	 */
block|{
name|void
modifier|*
name|packcheck
init|=
name|umem_alloc
argument_list|(
name|packsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
decl_stmt|;
name|void
modifier|*
name|bigcheck
init|=
name|umem_alloc
argument_list|(
name|bigsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|,
name|packcheck
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|,
name|bigcheck
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
name|packbuf
argument_list|,
name|packcheck
argument_list|,
name|packsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
name|bigbuf
argument_list|,
name|bigcheck
argument_list|,
name|bigsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|packcheck
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|bigcheck
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
block|}
name|umem_free
argument_list|(
name|packbuf
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|bigbuf
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|compare_and_update_pbbufs
parameter_list|(
name|uint64_t
name|s
parameter_list|,
name|bufwad_t
modifier|*
name|packbuf
parameter_list|,
name|bufwad_t
modifier|*
name|bigbuf
parameter_list|,
name|uint64_t
name|bigsize
parameter_list|,
name|uint64_t
name|n
parameter_list|,
name|uint64_t
name|chunksize
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|uint64_t
name|i
decl_stmt|;
name|bufwad_t
modifier|*
name|pack
decl_stmt|;
name|bufwad_t
modifier|*
name|bigH
decl_stmt|;
name|bufwad_t
modifier|*
name|bigT
decl_stmt|;
comment|/* 	 * For each index from n to n + s, verify that the existing bufwad 	 * in packobj matches the bufwads at the head and tail of the 	 * corresponding chunk in bigobj.  Then update all three bufwads 	 * with the new values we want to write out. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
condition|;
name|i
operator|++
control|)
block|{
comment|/* LINTED */
name|pack
operator|=
operator|(
name|bufwad_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|packbuf
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
operator|)
expr_stmt|;
comment|/* LINTED */
name|bigH
operator|=
operator|(
name|bufwad_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bigbuf
operator|+
name|i
operator|*
name|chunksize
operator|)
expr_stmt|;
comment|/* LINTED */
name|bigT
operator|=
operator|(
name|bufwad_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bigH
operator|+
name|chunksize
operator|)
operator|-
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|bigH
operator|-
operator|(
name|uintptr_t
operator|)
name|bigbuf
operator|<
name|bigsize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|bigT
operator|-
operator|(
name|uintptr_t
operator|)
name|bigbuf
operator|<
name|bigsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
operator|->
name|bw_txg
operator|>
name|txg
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"future leak: got %llx, open txg is %llx"
argument_list|,
name|pack
operator|->
name|bw_txg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
operator|->
name|bw_data
operator|!=
literal|0
operator|&&
name|pack
operator|->
name|bw_index
operator|!=
name|n
operator|+
name|i
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"wrong index: got %llx, wanted %llx+%llx"
argument_list|,
name|pack
operator|->
name|bw_index
argument_list|,
name|n
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|pack
argument_list|,
name|bigH
argument_list|,
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"pack/bigH mismatch in %p/%p"
argument_list|,
name|pack
argument_list|,
name|bigH
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|pack
argument_list|,
name|bigT
argument_list|,
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"pack/bigT mismatch in %p/%p"
argument_list|,
name|pack
argument_list|,
name|bigT
argument_list|)
expr_stmt|;
name|pack
operator|->
name|bw_index
operator|=
name|n
operator|+
name|i
expr_stmt|;
name|pack
operator|->
name|bw_txg
operator|=
name|txg
expr_stmt|;
name|pack
operator|->
name|bw_data
operator|=
literal|1
operator|+
name|ztest_random
argument_list|(
operator|-
literal|2ULL
argument_list|)
expr_stmt|;
operator|*
name|bigH
operator|=
operator|*
name|pack
expr_stmt|;
operator|*
name|bigT
operator|=
operator|*
name|pack
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ztest_dmu_read_write_zcopy
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|ztest_od_t
name|od
index|[
literal|2
index|]
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|n
decl_stmt|,
name|s
decl_stmt|,
name|txg
decl_stmt|;
name|bufwad_t
modifier|*
name|packbuf
decl_stmt|,
modifier|*
name|bigbuf
decl_stmt|;
name|uint64_t
name|packobj
decl_stmt|,
name|packoff
decl_stmt|,
name|packsize
decl_stmt|,
name|bigobj
decl_stmt|,
name|bigoff
decl_stmt|,
name|bigsize
decl_stmt|;
name|uint64_t
name|blocksize
init|=
name|ztest_random_blocksize
argument_list|()
decl_stmt|;
name|uint64_t
name|chunksize
init|=
name|blocksize
decl_stmt|;
name|uint64_t
name|regions
init|=
literal|997
decl_stmt|;
name|uint64_t
name|stride
init|=
literal|123456789ULL
decl_stmt|;
name|uint64_t
name|width
init|=
literal|9
decl_stmt|;
name|dmu_buf_t
modifier|*
name|bonus_db
decl_stmt|;
name|arc_buf_t
modifier|*
modifier|*
name|bigbuf_arcbufs
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
comment|/* 	 * This test uses two objects, packobj and bigobj, that are always 	 * updated together (i.e. in the same tx) so that their contents are 	 * in sync and can be compared.  Their contents relate to each other 	 * in a simple way: packobj is a dense array of 'bufwad' structures, 	 * while bigobj is a sparse array of the same bufwads.  Specifically, 	 * for any index n, there are three bufwads that should be identical: 	 * 	 *	packobj, at offset n * sizeof (bufwad_t) 	 *	bigobj, at the head of the nth chunk 	 *	bigobj, at the tail of the nth chunk 	 * 	 * The chunk size is set equal to bigobj block size so that 	 * dmu_assign_arcbuf() can be tested for object updates. 	 */
comment|/* 	 * Read the directory info.  If it's the first time, set things up. 	 */
name|ztest_od_init
argument_list|(
operator|&
name|od
index|[
literal|0
index|]
argument_list|,
name|id
argument_list|,
name|FTAG
argument_list|,
literal|0
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
name|blocksize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ztest_od_init
argument_list|(
operator|&
name|od
index|[
literal|1
index|]
argument_list|,
name|id
argument_list|,
name|FTAG
argument_list|,
literal|1
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_object_init
argument_list|(
name|zd
argument_list|,
name|od
argument_list|,
sizeof|sizeof
argument_list|(
name|od
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|bigobj
operator|=
name|od
index|[
literal|0
index|]
operator|.
name|od_object
expr_stmt|;
name|packobj
operator|=
name|od
index|[
literal|1
index|]
operator|.
name|od_object
expr_stmt|;
name|blocksize
operator|=
name|od
index|[
literal|0
index|]
operator|.
name|od_blocksize
expr_stmt|;
name|chunksize
operator|=
name|blocksize
expr_stmt|;
name|ASSERT
argument_list|(
name|chunksize
operator|==
name|od
index|[
literal|1
index|]
operator|.
name|od_gen
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|bigobj
argument_list|,
operator|&
name|doi
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|ISP2
argument_list|(
name|doi
operator|.
name|doi_data_block_size
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|chunksize
operator|==
name|doi
operator|.
name|doi_data_block_size
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|chunksize
operator|>=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Pick a random index and compute the offsets into packobj and bigobj. 	 */
name|n
operator|=
name|ztest_random
argument_list|(
name|regions
argument_list|)
operator|*
name|stride
operator|+
name|ztest_random
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|s
operator|=
literal|1
operator|+
name|ztest_random
argument_list|(
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
name|packoff
operator|=
name|n
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
expr_stmt|;
name|packsize
operator|=
name|s
operator|*
sizeof|sizeof
argument_list|(
name|bufwad_t
argument_list|)
expr_stmt|;
name|bigoff
operator|=
name|n
operator|*
name|chunksize
expr_stmt|;
name|bigsize
operator|=
name|s
operator|*
name|chunksize
expr_stmt|;
name|packbuf
operator|=
name|umem_zalloc
argument_list|(
name|packsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
name|bigbuf
operator|=
name|umem_zalloc
argument_list|(
name|bigsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|bigobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|bonus_db
argument_list|)
argument_list|)
expr_stmt|;
name|bigbuf_arcbufs
operator|=
name|umem_zalloc
argument_list|(
literal|2
operator|*
name|s
operator|*
sizeof|sizeof
argument_list|(
name|arc_buf_t
operator|*
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
comment|/* 	 * Iteration 0 test zcopy for DB_UNCACHED dbufs. 	 * Iteration 1 test zcopy to already referenced dbufs. 	 * Iteration 2 test zcopy to dirty dbuf in the same txg. 	 * Iteration 3 test zcopy to dbuf dirty in previous txg. 	 * Iteration 4 test zcopy when dbuf is no longer dirty. 	 * Iteration 5 test zcopy when it can't be done. 	 * Iteration 6 one more zcopy write. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|j
decl_stmt|;
name|uint64_t
name|off
decl_stmt|;
comment|/* 		 * In iteration 5 (i == 5) use arcbufs 		 * that don't match bigobj blksz to test 		 * dmu_assign_arcbuf() when it can't directly 		 * assign an arcbuf to a dbuf. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|5
condition|)
block|{
name|bigbuf_arcbufs
index|[
name|j
index|]
operator|=
name|dmu_request_arcbuf
argument_list|(
name|bonus_db
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
index|]
operator|=
name|dmu_request_arcbuf
argument_list|(
name|bonus_db
argument_list|,
name|chunksize
operator|/
literal|2
argument_list|)
expr_stmt|;
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
operator|=
name|dmu_request_arcbuf
argument_list|(
name|bonus_db
argument_list|,
name|chunksize
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Get a tx for the mods to both packobj and bigobj. 		 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
name|txg
operator|=
name|ztest_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_MIGHTWAIT
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
block|{
name|umem_free
argument_list|(
name|packbuf
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|bigbuf
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|5
condition|)
block|{
name|dmu_return_arcbuf
argument_list|(
name|bigbuf_arcbufs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_return_arcbuf
argument_list|(
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
index|]
argument_list|)
expr_stmt|;
name|dmu_return_arcbuf
argument_list|(
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|umem_free
argument_list|(
name|bigbuf_arcbufs
argument_list|,
literal|2
operator|*
name|s
operator|*
sizeof|sizeof
argument_list|(
name|arc_buf_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|bonus_db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * 50% of the time don't read objects in the 1st iteration to 		 * test dmu_assign_arcbuf() for the case when there're no 		 * existing dbufs for the specified offsets. 		 */
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|,
name|packbuf
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|,
name|bigbuf
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
name|compare_and_update_pbbufs
argument_list|(
name|s
argument_list|,
name|packbuf
argument_list|,
name|bigbuf
argument_list|,
name|bigsize
argument_list|,
name|n
argument_list|,
name|chunksize
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 		 * We've verified all the old bufwads, and made new ones. 		 * Now write them out. 		 */
name|dmu_write
argument_list|(
name|os
argument_list|,
name|packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|,
name|packbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|7
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"writing offset %llx size %llx"
literal|" txg %llx\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bigoff
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bigsize
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|txg
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|off
operator|=
name|bigoff
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
condition|;
name|j
operator|++
operator|,
name|off
operator|+=
name|chunksize
control|)
block|{
name|dmu_buf_t
modifier|*
name|dbt
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|5
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bigbuf
operator|+
operator|(
name|off
operator|-
name|bigoff
operator|)
argument_list|,
name|bigbuf_arcbufs
index|[
name|j
index|]
operator|->
name|b_data
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bigbuf
operator|+
operator|(
name|off
operator|-
name|bigoff
operator|)
argument_list|,
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
index|]
operator|->
name|b_data
argument_list|,
name|chunksize
operator|/
literal|2
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bigbuf
operator|+
operator|(
name|off
operator|-
name|bigoff
operator|)
operator|+
name|chunksize
operator|/
literal|2
argument_list|,
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
operator|->
name|b_data
argument_list|,
name|chunksize
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|VERIFY
argument_list|(
name|dmu_buf_hold
argument_list|(
name|os
argument_list|,
name|bigobj
argument_list|,
name|off
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbt
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|5
condition|)
block|{
name|dmu_assign_arcbuf
argument_list|(
name|bonus_db
argument_list|,
name|off
argument_list|,
name|bigbuf_arcbufs
index|[
name|j
index|]
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_assign_arcbuf
argument_list|(
name|bonus_db
argument_list|,
name|off
argument_list|,
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
index|]
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_assign_arcbuf
argument_list|(
name|bonus_db
argument_list|,
name|off
operator|+
name|chunksize
operator|/
literal|2
argument_list|,
name|bigbuf_arcbufs
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|dmu_buf_rele
argument_list|(
name|dbt
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 		 * Sanity check the stuff we just wrote. 		 */
block|{
name|void
modifier|*
name|packcheck
init|=
name|umem_alloc
argument_list|(
name|packsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
decl_stmt|;
name|void
modifier|*
name|bigcheck
init|=
name|umem_alloc
argument_list|(
name|bigsize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|packobj
argument_list|,
name|packoff
argument_list|,
name|packsize
argument_list|,
name|packcheck
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|bigobj
argument_list|,
name|bigoff
argument_list|,
name|bigsize
argument_list|,
name|bigcheck
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
name|packbuf
argument_list|,
name|packcheck
argument_list|,
name|packsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
name|bigbuf
argument_list|,
name|bigcheck
argument_list|,
name|bigsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|packcheck
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|bigcheck
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|txg_wait_open
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|3
condition|)
block|{
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|dmu_buf_rele
argument_list|(
name|bonus_db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|packbuf
argument_list|,
name|packsize
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|bigbuf
argument_list|,
name|bigsize
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|bigbuf_arcbufs
argument_list|,
literal|2
operator|*
name|s
operator|*
sizeof|sizeof
argument_list|(
name|arc_buf_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_dmu_write_parallel
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|ztest_od_t
name|od
index|[
literal|1
index|]
decl_stmt|;
name|uint64_t
name|offset
init|=
operator|(
literal|1ULL
operator|<<
operator|(
name|ztest_random
argument_list|(
literal|20
argument_list|)
operator|+
literal|43
operator|)
operator|)
operator|+
operator|(
name|ztest_random
argument_list|(
name|ZTEST_RANGE_LOCKS
argument_list|)
operator|<<
name|SPA_MAXBLOCKSHIFT
operator|)
decl_stmt|;
comment|/* 	 * Have multiple threads write to large offsets in an object 	 * to verify that parallel writes to an object -- even to the 	 * same blocks within the object -- doesn't cause any trouble. 	 */
name|ztest_od_init
argument_list|(
operator|&
name|od
index|[
literal|0
index|]
argument_list|,
name|ID_PARALLEL
argument_list|,
name|FTAG
argument_list|,
literal|0
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_object_init
argument_list|(
name|zd
argument_list|,
name|od
argument_list|,
sizeof|sizeof
argument_list|(
name|od
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
while|while
condition|(
name|ztest_random
argument_list|(
literal|10
argument_list|)
operator|!=
literal|0
condition|)
name|ztest_io
argument_list|(
name|zd
argument_list|,
name|od
index|[
literal|0
index|]
operator|.
name|od_object
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ztest_dmu_prealloc
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|ztest_od_t
name|od
index|[
literal|1
index|]
decl_stmt|;
name|uint64_t
name|offset
init|=
operator|(
literal|1ULL
operator|<<
operator|(
name|ztest_random
argument_list|(
literal|4
argument_list|)
operator|+
name|SPA_MAXBLOCKSHIFT
operator|)
operator|)
operator|+
operator|(
name|ztest_random
argument_list|(
name|ZTEST_RANGE_LOCKS
argument_list|)
operator|<<
name|SPA_MAXBLOCKSHIFT
operator|)
decl_stmt|;
name|uint64_t
name|count
init|=
name|ztest_random
argument_list|(
literal|20
argument_list|)
operator|+
literal|1
decl_stmt|;
name|uint64_t
name|blocksize
init|=
name|ztest_random_blocksize
argument_list|()
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|ztest_od_init
argument_list|(
operator|&
name|od
index|[
literal|0
index|]
argument_list|,
name|id
argument_list|,
name|FTAG
argument_list|,
literal|0
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
name|blocksize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_object_init
argument_list|(
name|zd
argument_list|,
name|od
argument_list|,
sizeof|sizeof
argument_list|(
name|od
argument_list|)
argument_list|,
operator|!
name|ztest_random
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|ztest_truncate
argument_list|(
name|zd
argument_list|,
name|od
index|[
literal|0
index|]
operator|.
name|od_object
argument_list|,
name|offset
argument_list|,
name|count
operator|*
name|blocksize
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|ztest_prealloc
argument_list|(
name|zd
argument_list|,
name|od
index|[
literal|0
index|]
operator|.
name|od_object
argument_list|,
name|offset
argument_list|,
name|count
operator|*
name|blocksize
argument_list|)
expr_stmt|;
name|data
operator|=
name|umem_zalloc
argument_list|(
name|blocksize
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
while|while
condition|(
name|ztest_random
argument_list|(
name|count
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|randoff
init|=
name|offset
operator|+
operator|(
name|ztest_random
argument_list|(
name|count
argument_list|)
operator|*
name|blocksize
operator|)
decl_stmt|;
if|if
condition|(
name|ztest_write
argument_list|(
name|zd
argument_list|,
name|od
index|[
literal|0
index|]
operator|.
name|od_object
argument_list|,
name|randoff
argument_list|,
name|blocksize
argument_list|,
name|data
argument_list|)
operator|!=
literal|0
condition|)
break|break;
while|while
condition|(
name|ztest_random
argument_list|(
literal|4
argument_list|)
operator|!=
literal|0
condition|)
name|ztest_io
argument_list|(
name|zd
argument_list|,
name|od
index|[
literal|0
index|]
operator|.
name|od_object
argument_list|,
name|randoff
argument_list|)
expr_stmt|;
block|}
name|umem_free
argument_list|(
name|data
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that zap_{create,destroy,add,remove,update} work as expected.  */
end_comment

begin_define
define|#
directive|define
name|ZTEST_ZAP_MIN_INTS
value|1
end_define

begin_define
define|#
directive|define
name|ZTEST_ZAP_MAX_INTS
value|4
end_define

begin_define
define|#
directive|define
name|ZTEST_ZAP_MAX_PROPS
value|1000
end_define

begin_function
name|void
name|ztest_zap
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|ztest_od_t
name|od
index|[
literal|1
index|]
decl_stmt|;
name|uint64_t
name|object
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|,
name|last_txg
decl_stmt|;
name|uint64_t
name|value
index|[
name|ZTEST_ZAP_MAX_INTS
index|]
decl_stmt|;
name|uint64_t
name|zl_ints
decl_stmt|,
name|zl_intsize
decl_stmt|,
name|prop
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ints
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|char
name|propname
index|[
literal|100
index|]
decl_stmt|,
name|txgname
index|[
literal|100
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|hc
index|[
literal|2
index|]
init|=
block|{
literal|"s.acl.h"
block|,
literal|".s.open.h.hyLZlg"
block|}
decl_stmt|;
name|ztest_od_init
argument_list|(
operator|&
name|od
index|[
literal|0
index|]
argument_list|,
name|id
argument_list|,
name|FTAG
argument_list|,
literal|0
argument_list|,
name|DMU_OT_ZAP_OTHER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_object_init
argument_list|(
name|zd
argument_list|,
name|od
argument_list|,
sizeof|sizeof
argument_list|(
name|od
argument_list|)
argument_list|,
operator|!
name|ztest_random
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|object
operator|=
name|od
index|[
literal|0
index|]
operator|.
name|od_object
expr_stmt|;
comment|/* 	 * Generate a known hash collision, and verify that 	 * we can lookup and remove both entries. 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|txg
operator|=
name|ztest_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_MIGHTWAIT
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|value
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_add
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|hc
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|value
index|[
name|i
index|]
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY3U
argument_list|(
name|EEXIST
argument_list|,
operator|==
argument_list|,
name|zap_add
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|hc
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|value
index|[
name|i
index|]
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_length
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|hc
index|[
name|i
index|]
argument_list|,
operator|&
name|zl_intsize
argument_list|,
operator|&
name|zl_ints
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zl_intsize
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zl_ints
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_remove
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|hc
index|[
name|i
index|]
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Generate a buch of random entries. 	 */
name|ints
operator|=
name|MAX
argument_list|(
name|ZTEST_ZAP_MIN_INTS
argument_list|,
name|object
operator|%
name|ZTEST_ZAP_MAX_INTS
argument_list|)
expr_stmt|;
name|prop
operator|=
name|ztest_random
argument_list|(
name|ZTEST_ZAP_MAX_PROPS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|propname
argument_list|,
literal|"prop_%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|prop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|txgname
argument_list|,
literal|"txg_%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|prop
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|last_txg
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If these zap entries already exist, validate their contents. 	 */
name|error
operator|=
name|zap_length
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|txgname
argument_list|,
operator|&
name|zl_intsize
argument_list|,
operator|&
name|zl_ints
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|zl_intsize
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zl_ints
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|txgname
argument_list|,
name|zl_intsize
argument_list|,
name|zl_ints
argument_list|,
operator|&
name|last_txg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_length
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|propname
argument_list|,
operator|&
name|zl_intsize
argument_list|,
operator|&
name|zl_ints
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zl_intsize
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zl_ints
argument_list|,
operator|==
argument_list|,
name|ints
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|propname
argument_list|,
name|zl_intsize
argument_list|,
name|zl_ints
argument_list|,
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ints
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT3U
argument_list|(
name|value
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|,
name|last_txg
operator|+
name|object
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Atomically update two entries in our zap object. 	 * The first is named txg_%llu, and contains the txg 	 * in which the property was last updated.  The second 	 * is named prop_%llu, and the nth element of its value 	 * should be txg + object + n. 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|txg
operator|=
name|ztest_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_MIGHTWAIT
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|last_txg
operator|>
name|txg
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"zap future leak: old %llu new %llu"
argument_list|,
name|last_txg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ints
condition|;
name|i
operator|++
control|)
name|value
index|[
name|i
index|]
operator|=
name|txg
operator|+
name|object
operator|+
name|i
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_update
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|txgname
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|txg
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_update
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|propname
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|ints
argument_list|,
name|value
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Remove a random pair of entries. 	 */
name|prop
operator|=
name|ztest_random
argument_list|(
name|ZTEST_ZAP_MAX_PROPS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|propname
argument_list|,
literal|"prop_%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|prop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|txgname
argument_list|,
literal|"txg_%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|prop
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_length
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|txgname
argument_list|,
operator|&
name|zl_intsize
argument_list|,
operator|&
name|zl_ints
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
return|return;
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|txg
operator|=
name|ztest_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_MIGHTWAIT
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
return|return;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_remove
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|txgname
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_remove
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|propname
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Testcase to test the upgrading of a microzap to fatzap.  */
end_comment

begin_function
name|void
name|ztest_fzap
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|ztest_od_t
name|od
index|[
literal|1
index|]
decl_stmt|;
name|uint64_t
name|object
decl_stmt|,
name|txg
decl_stmt|;
name|ztest_od_init
argument_list|(
operator|&
name|od
index|[
literal|0
index|]
argument_list|,
name|id
argument_list|,
name|FTAG
argument_list|,
literal|0
argument_list|,
name|DMU_OT_ZAP_OTHER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_object_init
argument_list|(
name|zd
argument_list|,
name|od
argument_list|,
sizeof|sizeof
argument_list|(
name|od
argument_list|)
argument_list|,
operator|!
name|ztest_random
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|object
operator|=
name|od
index|[
literal|0
index|]
operator|.
name|od_object
expr_stmt|;
comment|/* 	 * Add entries to this ZAP and make sure it spills over 	 * and gets upgraded to a fatzap. Also, since we are adding 	 * 2050 entries we should see ptrtbl growth and leaf-block split. 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2050
condition|;
name|i
operator|++
control|)
block|{
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|uint64_t
name|value
init|=
name|i
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"fzap-%llu-%llu"
argument_list|,
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
name|B_TRUE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|txg
operator|=
name|ztest_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_MIGHTWAIT
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
return|return;
name|error
operator|=
name|zap_add
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|value
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|EEXIST
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_zap_parallel
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|ztest_od_t
name|od
index|[
literal|1
index|]
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|,
name|object
decl_stmt|,
name|count
decl_stmt|,
name|wsize
decl_stmt|,
name|wc
decl_stmt|,
name|zl_wsize
decl_stmt|,
name|zl_wc
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|namelen
decl_stmt|,
name|error
decl_stmt|;
name|int
name|micro
init|=
name|ztest_random
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|char
name|name
index|[
literal|20
index|]
decl_stmt|,
name|string_value
index|[
literal|20
index|]
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|ztest_od_init
argument_list|(
operator|&
name|od
index|[
literal|0
index|]
argument_list|,
name|ID_PARALLEL
argument_list|,
name|FTAG
argument_list|,
name|micro
argument_list|,
name|DMU_OT_ZAP_OTHER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_object_init
argument_list|(
name|zd
argument_list|,
name|od
argument_list|,
sizeof|sizeof
argument_list|(
name|od
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|object
operator|=
name|od
index|[
literal|0
index|]
operator|.
name|od_object
expr_stmt|;
comment|/* 	 * Generate a random name of the form 'xxx.....' where each 	 * x is a random printable character and the dots are dots. 	 * There are 94 such characters, and the name length goes from 	 * 6 to 20, so there are 94^3 * 15 = 12,458,760 possible names. 	 */
name|namelen
operator|=
name|ztest_random
argument_list|(
sizeof|sizeof
argument_list|(
name|name
argument_list|)
operator|-
literal|5
argument_list|)
operator|+
literal|5
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|name
index|[
name|i
index|]
operator|=
literal|'!'
operator|+
name|ztest_random
argument_list|(
literal|'~'
operator|-
literal|'!'
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|namelen
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|name
index|[
name|i
index|]
operator|=
literal|'.'
expr_stmt|;
name|name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|namelen
operator|&
literal|1
operator|)
operator|||
name|micro
condition|)
block|{
name|wsize
operator|=
sizeof|sizeof
argument_list|(
name|txg
argument_list|)
expr_stmt|;
name|wc
operator|=
literal|1
expr_stmt|;
name|data
operator|=
operator|&
name|txg
expr_stmt|;
block|}
else|else
block|{
name|wsize
operator|=
literal|1
expr_stmt|;
name|wc
operator|=
name|namelen
expr_stmt|;
name|data
operator|=
name|string_value
expr_stmt|;
block|}
name|count
operator|=
operator|-
literal|1ULL
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_count
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
operator|&
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|count
operator|!=
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
comment|/* 	 * Select an operation: length, lookup, add, update, remove. 	 */
name|i
operator|=
name|ztest_random
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
block|{
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|txg
operator|=
name|ztest_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_MIGHTWAIT
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
return|return;
name|bcopy
argument_list|(
name|name
argument_list|,
name|string_value
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tx
operator|=
name|NULL
expr_stmt|;
name|txg
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|string_value
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|error
operator|=
name|zap_length
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|name
argument_list|,
operator|&
name|zl_wsize
argument_list|,
operator|&
name|zl_wc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|wsize
argument_list|,
operator|==
argument_list|,
name|zl_wsize
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|wc
argument_list|,
operator|==
argument_list|,
name|zl_wc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|name
argument_list|,
name|wsize
argument_list|,
name|wc
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|data
operator|==
name|string_value
operator|&&
name|bcmp
argument_list|(
name|name
argument_list|,
name|data
argument_list|,
name|namelen
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"name '%s' != val '%s' len %d"
argument_list|,
name|name
argument_list|,
name|data
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|error
operator|=
name|zap_add
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|name
argument_list|,
name|wsize
argument_list|,
name|wc
argument_list|,
name|data
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|EEXIST
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|VERIFY
argument_list|(
name|zap_update
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|name
argument_list|,
name|wsize
argument_list|,
name|wc
argument_list|,
name|data
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|error
operator|=
name|zap_remove
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|name
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tx
operator|!=
name|NULL
condition|)
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Commit callback data.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ztest_cb_data
block|{
name|list_node_t
name|zcd_node
decl_stmt|;
name|uint64_t
name|zcd_txg
decl_stmt|;
name|int
name|zcd_expected_err
decl_stmt|;
name|boolean_t
name|zcd_added
decl_stmt|;
name|boolean_t
name|zcd_called
decl_stmt|;
name|spa_t
modifier|*
name|zcd_spa
decl_stmt|;
block|}
name|ztest_cb_data_t
typedef|;
end_typedef

begin_comment
comment|/* This is the actual commit callback function */
end_comment

begin_function
specifier|static
name|void
name|ztest_commit_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|ztest_cb_data_t
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|uint64_t
name|synced_txg
decl_stmt|;
name|VERIFY
argument_list|(
name|data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|VERIFY3S
argument_list|(
name|data
operator|->
name|zcd_expected_err
argument_list|,
operator|==
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
operator|!
name|data
operator|->
name|zcd_called
argument_list|)
expr_stmt|;
name|synced_txg
operator|=
name|spa_last_synced_txg
argument_list|(
name|data
operator|->
name|zcd_spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|zcd_txg
operator|>
name|synced_txg
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"commit callback of txg %"
name|PRIu64
literal|" called prematurely"
literal|", last synced txg = %"
name|PRIu64
literal|"\n"
argument_list|,
name|data
operator|->
name|zcd_txg
argument_list|,
name|synced_txg
argument_list|)
expr_stmt|;
name|data
operator|->
name|zcd_called
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ECANCELED
condition|)
block|{
name|ASSERT0
argument_list|(
name|data
operator|->
name|zcd_txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|data
operator|->
name|zcd_added
argument_list|)
expr_stmt|;
comment|/* 		 * The private callback data should be destroyed here, but 		 * since we are going to check the zcd_called field after 		 * dmu_tx_abort(), we will destroy it there. 		 */
return|return;
block|}
comment|/* Was this callback added to the global callback list? */
if|if
condition|(
operator|!
name|data
operator|->
name|zcd_added
condition|)
goto|goto
name|out
goto|;
name|ASSERT3U
argument_list|(
name|data
operator|->
name|zcd_txg
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Remove our callback from the list */
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|zcl
operator|.
name|zcl_callbacks_lock
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|zcl
operator|.
name|zcl_callbacks
argument_list|,
name|data
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|zcl
operator|.
name|zcl_callbacks_lock
argument_list|)
expr_stmt|;
name|out
label|:
name|umem_free
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|ztest_cb_data_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate and initialize callback data structure */
end_comment

begin_function
specifier|static
name|ztest_cb_data_t
modifier|*
name|ztest_create_cb_data
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|ztest_cb_data_t
modifier|*
name|cb_data
decl_stmt|;
name|cb_data
operator|=
name|umem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ztest_cb_data_t
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
name|cb_data
operator|->
name|zcd_txg
operator|=
name|txg
expr_stmt|;
name|cb_data
operator|->
name|zcd_spa
operator|=
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
expr_stmt|;
return|return
operator|(
name|cb_data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If a number of txgs equal to this threshold have been created after a commit  * callback has been registered but not called, then we assume there is an  * implementation bug.  */
end_comment

begin_define
define|#
directive|define
name|ZTEST_COMMIT_CALLBACK_THRESH
value|(TXG_CONCURRENT_STATES + 2)
end_define

begin_comment
comment|/*  * Commit callback test.  */
end_comment

begin_function
name|void
name|ztest_dmu_commit_callbacks
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|ztest_od_t
name|od
index|[
literal|1
index|]
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|ztest_cb_data_t
modifier|*
name|cb_data
index|[
literal|3
index|]
decl_stmt|,
modifier|*
name|tmp_cb
decl_stmt|;
name|uint64_t
name|old_txg
decl_stmt|,
name|txg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ztest_od_init
argument_list|(
operator|&
name|od
index|[
literal|0
index|]
argument_list|,
name|id
argument_list|,
name|FTAG
argument_list|,
literal|0
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_object_init
argument_list|(
name|zd
argument_list|,
name|od
argument_list|,
sizeof|sizeof
argument_list|(
name|od
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|cb_data
index|[
literal|0
index|]
operator|=
name|ztest_create_cb_data
argument_list|(
name|os
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dmu_tx_callback_register
argument_list|(
name|tx
argument_list|,
name|ztest_commit_callback
argument_list|,
name|cb_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|od
index|[
literal|0
index|]
operator|.
name|od_object
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Every once in a while, abort the transaction on purpose */
if|if
condition|(
name|ztest_random
argument_list|(
literal|100
argument_list|)
operator|==
literal|0
condition|)
name|error
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_NOWAIT
argument_list|)
expr_stmt|;
name|txg
operator|=
name|error
condition|?
literal|0
else|:
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|cb_data
index|[
literal|0
index|]
operator|->
name|zcd_txg
operator|=
name|txg
expr_stmt|;
name|cb_data
index|[
literal|1
index|]
operator|=
name|ztest_create_cb_data
argument_list|(
name|os
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|dmu_tx_callback_register
argument_list|(
name|tx
argument_list|,
name|ztest_commit_callback
argument_list|,
name|cb_data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * It's not a strict requirement to call the registered 		 * callbacks from inside dmu_tx_abort(), but that's what 		 * it's supposed to happen in the current implementation 		 * so we will check for that. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|cb_data
index|[
name|i
index|]
operator|->
name|zcd_expected_err
operator|=
name|ECANCELED
expr_stmt|;
name|VERIFY
argument_list|(
operator|!
name|cb_data
index|[
name|i
index|]
operator|->
name|zcd_called
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY
argument_list|(
name|cb_data
index|[
name|i
index|]
operator|->
name|zcd_called
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|cb_data
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ztest_cb_data_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|cb_data
index|[
literal|2
index|]
operator|=
name|ztest_create_cb_data
argument_list|(
name|os
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|dmu_tx_callback_register
argument_list|(
name|tx
argument_list|,
name|ztest_commit_callback
argument_list|,
name|cb_data
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Read existing data to make sure there isn't a future leak. 	 */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|od
index|[
literal|0
index|]
operator|.
name|od_object
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|old_txg
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_txg
operator|>
name|txg
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"future leak: got %"
name|PRIu64
literal|", open txg is %"
name|PRIu64
argument_list|,
name|old_txg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|od
index|[
literal|0
index|]
operator|.
name|od_object
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|txg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mutex_lock
argument_list|(
operator|&
name|zcl
operator|.
name|zcl_callbacks_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Since commit callbacks don't have any ordering requirement and since 	 * it is theoretically possible for a commit callback to be called 	 * after an arbitrary amount of time has elapsed since its txg has been 	 * synced, it is difficult to reliably determine whether a commit 	 * callback hasn't been called due to high load or due to a flawed 	 * implementation. 	 * 	 * In practice, we will assume that if after a certain number of txgs a 	 * commit callback hasn't been called, then most likely there's an 	 * implementation bug.. 	 */
name|tmp_cb
operator|=
name|list_head
argument_list|(
operator|&
name|zcl
operator|.
name|zcl_callbacks
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_cb
operator|!=
name|NULL
operator|&&
operator|(
name|txg
operator|-
name|ZTEST_COMMIT_CALLBACK_THRESH
operator|)
operator|>
name|tmp_cb
operator|->
name|zcd_txg
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"Commit callback threshold exceeded, oldest txg: %"
name|PRIu64
literal|", open txg: %"
name|PRIu64
literal|"\n"
argument_list|,
name|tmp_cb
operator|->
name|zcd_txg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Let's find the place to insert our callbacks. 	 * 	 * Even though the list is ordered by txg, it is possible for the 	 * insertion point to not be the end because our txg may already be 	 * quiescing at this point and other callbacks in the open txg 	 * (from other objsets) may have sneaked in. 	 */
name|tmp_cb
operator|=
name|list_tail
argument_list|(
operator|&
name|zcl
operator|.
name|zcl_callbacks
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp_cb
operator|!=
name|NULL
operator|&&
name|tmp_cb
operator|->
name|zcd_txg
operator|>
name|txg
condition|)
name|tmp_cb
operator|=
name|list_prev
argument_list|(
operator|&
name|zcl
operator|.
name|zcl_callbacks
argument_list|,
name|tmp_cb
argument_list|)
expr_stmt|;
comment|/* Add the 3 callbacks to the list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tmp_cb
operator|==
name|NULL
condition|)
name|list_insert_head
argument_list|(
operator|&
name|zcl
operator|.
name|zcl_callbacks
argument_list|,
name|cb_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|list_insert_after
argument_list|(
operator|&
name|zcl
operator|.
name|zcl_callbacks
argument_list|,
name|tmp_cb
argument_list|,
name|cb_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cb_data
index|[
name|i
index|]
operator|->
name|zcd_added
operator|=
name|B_TRUE
expr_stmt|;
name|VERIFY
argument_list|(
operator|!
name|cb_data
index|[
name|i
index|]
operator|->
name|zcd_called
argument_list|)
expr_stmt|;
name|tmp_cb
operator|=
name|cb_data
index|[
name|i
index|]
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mutex_unlock
argument_list|(
operator|&
name|zcl
operator|.
name|zcl_callbacks_lock
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_dsl_prop_get_set
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|zfs_prop_t
name|proplist
index|[]
init|=
block|{
name|ZFS_PROP_CHECKSUM
block|,
name|ZFS_PROP_COMPRESSION
block|,
name|ZFS_PROP_COPIES
block|,
name|ZFS_PROP_DEDUP
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
sizeof|sizeof
argument_list|(
name|proplist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|proplist
index|[
literal|0
index|]
argument_list|)
condition|;
name|p
operator|++
control|)
operator|(
name|void
operator|)
name|ztest_dsl_prop_set_uint64
argument_list|(
name|zd
operator|->
name|zd_name
argument_list|,
name|proplist
index|[
name|p
index|]
argument_list|,
name|ztest_random_dsl_prop
argument_list|(
name|proplist
index|[
name|p
index|]
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|ztest_random
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_spa_prop_get_set
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ztest_spa_prop_set_uint64
argument_list|(
name|ZPOOL_PROP_DEDUPDITTO
argument_list|,
name|ZIO_DEDUPDITTO_MIN
operator|+
name|ztest_random
argument_list|(
name|ZIO_DEDUPDITTO_MIN
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|spa_prop_get
argument_list|(
name|ztest_spa
argument_list|,
operator|&
name|props
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|6
condition|)
name|dump_nvlist
argument_list|(
name|props
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|user_release_one
parameter_list|(
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
specifier|const
name|char
modifier|*
name|holdname
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|snaps
decl_stmt|,
modifier|*
name|holds
decl_stmt|;
name|int
name|error
decl_stmt|;
name|snaps
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|holds
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_boolean
argument_list|(
name|holds
argument_list|,
name|holdname
argument_list|)
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|snaps
argument_list|,
name|snapname
argument_list|,
name|holds
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|holds
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_dataset_user_release
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|snaps
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test snapshot hold/release and deferred destroy.  */
end_comment

begin_function
name|void
name|ztest_dmu_snapshot_hold
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|objset_t
modifier|*
name|origin
decl_stmt|;
name|char
name|snapname
index|[
literal|100
index|]
decl_stmt|;
name|char
name|fullname
index|[
literal|100
index|]
decl_stmt|;
name|char
name|clonename
index|[
literal|100
index|]
decl_stmt|;
name|char
name|tag
index|[
literal|100
index|]
decl_stmt|;
name|char
name|osname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|holds
decl_stmt|;
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|osname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|snapname
argument_list|)
argument_list|,
literal|"sh1_%llu"
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|fullname
argument_list|,
sizeof|sizeof
argument_list|(
name|fullname
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|osname
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|clonename
argument_list|,
sizeof|sizeof
argument_list|(
name|clonename
argument_list|)
argument_list|,
literal|"%s/ch1_%llu"
argument_list|,
name|osname
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
literal|"tag_%llu"
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up from any previous run. 	 */
name|error
operator|=
name|dsl_destroy_head
argument_list|(
name|clonename
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|user_release_one
argument_list|(
name|fullname
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ESRCH
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_destroy_snapshot
argument_list|(
name|fullname
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Create snapshot, clone it, mark snap for deferred destroy, 	 * destroy clone, verify snap was also destroyed. 	 */
name|error
operator|=
name|dmu_objset_snapshot_one
argument_list|(
name|osname
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"dmu_objset_snapshot"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_snapshot(%s) = %d"
argument_list|,
name|fullname
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_objset_clone
argument_list|(
name|clonename
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"dmu_objset_clone"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_clone(%s) = %d"
argument_list|,
name|clonename
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dsl_destroy_snapshot
argument_list|(
name|fullname
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dsl_destroy_snapshot(%s, B_TRUE) = %d"
argument_list|,
name|fullname
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dsl_destroy_head
argument_list|(
name|clonename
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dsl_destroy_head(%s) = %d"
argument_list|,
name|clonename
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_hold
argument_list|(
name|fullname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_hold(%s) = %d"
argument_list|,
name|fullname
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Create snapshot, add temporary hold, verify that we can't 	 * destroy a held snapshot, mark for deferred destroy, 	 * release hold, verify snapshot was destroyed. 	 */
name|error
operator|=
name|dmu_objset_snapshot_one
argument_list|(
name|osname
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"dmu_objset_snapshot"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dmu_objset_snapshot(%s) = %d"
argument_list|,
name|fullname
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|holds
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_string
argument_list|(
name|holds
argument_list|,
name|fullname
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_dataset_user_hold
argument_list|(
name|holds
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|holds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|ztest_record_enospc
argument_list|(
literal|"dsl_dataset_user_hold"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dsl_dataset_user_hold(%s, %s) = %u"
argument_list|,
name|fullname
argument_list|,
name|tag
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dsl_destroy_snapshot
argument_list|(
name|fullname
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EBUSY
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dsl_destroy_snapshot(%s, B_FALSE) = %d"
argument_list|,
name|fullname
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dsl_destroy_snapshot
argument_list|(
name|fullname
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"dsl_destroy_snapshot(%s, B_TRUE) = %d"
argument_list|,
name|fullname
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|user_release_one
argument_list|(
name|fullname
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"user_release_one(%s, %s) = %d"
argument_list|,
name|fullname
argument_list|,
name|tag
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|dmu_objset_hold
argument_list|(
name|fullname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|origin
argument_list|)
argument_list|,
operator|==
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
name|out
label|:
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Inject random faults into the on-disk data.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_fault_inject
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|ztest_shared_t
modifier|*
name|zs
init|=
name|ztest_shared
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|ztest_spa
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|uint64_t
name|leaves
decl_stmt|;
name|uint64_t
name|bad
init|=
literal|0x1990c0ffeedecadeULL
decl_stmt|;
name|uint64_t
name|top
decl_stmt|,
name|leaf
decl_stmt|;
name|char
name|path0
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|pathrand
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|size_t
name|fsize
decl_stmt|;
name|int
name|bshift
init|=
name|SPA_MAXBLOCKSHIFT
operator|+
literal|2
decl_stmt|;
name|int
name|iters
init|=
literal|1000
decl_stmt|;
name|int
name|maxfaults
decl_stmt|;
name|int
name|mirror_save
decl_stmt|;
name|vdev_t
modifier|*
name|vd0
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|guid0
init|=
literal|0
decl_stmt|;
name|boolean_t
name|islog
init|=
name|B_FALSE
decl_stmt|;
name|VERIFY
argument_list|(
name|mutex_lock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|maxfaults
operator|=
name|MAXFAULTS
argument_list|()
expr_stmt|;
name|leaves
operator|=
name|MAX
argument_list|(
name|zs
operator|->
name|zs_mirrors
argument_list|,
literal|1
argument_list|)
operator|*
name|ztest_opts
operator|.
name|zo_raidz
expr_stmt|;
name|mirror_save
operator|=
name|zs
operator|->
name|zs_mirrors
expr_stmt|;
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|leaves
operator|>=
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Grab the name lock as reader. There are some operations 	 * which don't like to have their vdevs changed while 	 * they are in progress (i.e. spa_change_guid). Those 	 * operations will have grabbed the name lock as writer. 	 */
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We need SCL_STATE here because we're going to look at vd0->vdev_tsd. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Inject errors on a normal data device or slog device. 		 */
name|top
operator|=
name|ztest_random_vdev_top
argument_list|(
name|spa
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|ztest_random
argument_list|(
name|leaves
argument_list|)
operator|+
name|zs
operator|->
name|zs_splits
expr_stmt|;
comment|/* 		 * Generate paths to the first leaf in this top-level vdev, 		 * and to the random leaf we selected.  We'll induce transient 		 * write failures and random online/offline activity on leaf 0, 		 * and we'll write random garbage to the randomly chosen leaf. 		 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|path0
argument_list|,
sizeof|sizeof
argument_list|(
name|path0
argument_list|)
argument_list|,
name|ztest_dev_template
argument_list|,
name|ztest_opts
operator|.
name|zo_dir
argument_list|,
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
name|top
operator|*
name|leaves
operator|+
name|zs
operator|->
name|zs_splits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathrand
argument_list|,
sizeof|sizeof
argument_list|(
name|pathrand
argument_list|)
argument_list|,
name|ztest_dev_template
argument_list|,
name|ztest_opts
operator|.
name|zo_dir
argument_list|,
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
name|top
operator|*
name|leaves
operator|+
name|leaf
argument_list|)
expr_stmt|;
name|vd0
operator|=
name|vdev_lookup_by_path
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|path0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd0
operator|!=
name|NULL
operator|&&
name|vd0
operator|->
name|vdev_top
operator|->
name|vdev_islog
condition|)
name|islog
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 		 * If the top-level vdev needs to be resilvered 		 * then we only allow faults on the device that is 		 * resilvering. 		 */
if|if
condition|(
name|vd0
operator|!=
name|NULL
operator|&&
name|maxfaults
operator|!=
literal|1
operator|&&
operator|(
operator|!
name|vdev_resilver_needed
argument_list|(
name|vd0
operator|->
name|vdev_top
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|||
name|vd0
operator|->
name|vdev_resilver_txg
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Make vd0 explicitly claim to be unreadable, 			 * or unwriteable, or reach behind its back 			 * and close the underlying fd.  We can do this if 			 * maxfaults == 0 because we'll fail and reexecute, 			 * and we can do it if maxfaults>= 2 because we'll 			 * have enough redundancy.  If maxfaults == 1, the 			 * combination of this with injection of random data 			 * corruption below exceeds the pool's fault tolerance. 			 */
name|vdev_file_t
modifier|*
name|vf
init|=
name|vd0
operator|->
name|vdev_tsd
decl_stmt|;
if|if
condition|(
name|vf
operator|!=
name|NULL
operator|&&
name|ztest_random
argument_list|(
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|vf
operator|->
name|vf_vnode
operator|->
name|v_fd
argument_list|)
expr_stmt|;
name|vf
operator|->
name|vf_vnode
operator|->
name|v_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vd0
operator|->
name|vdev_cant_read
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|vd0
operator|->
name|vdev_cant_write
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|guid0
operator|=
name|vd0
operator|->
name|vdev_guid
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Inject errors on an l2cache device. 		 */
name|spa_aux_vdev_t
modifier|*
name|sav
init|=
operator|&
name|spa
operator|->
name|spa_l2cache
decl_stmt|;
if|if
condition|(
name|sav
operator|->
name|sav_count
operator|==
literal|0
condition|)
block|{
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|vd0
operator|=
name|sav
operator|->
name|sav_vdevs
index|[
name|ztest_random
argument_list|(
name|sav
operator|->
name|sav_count
argument_list|)
index|]
expr_stmt|;
name|guid0
operator|=
name|vd0
operator|->
name|vdev_guid
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|path0
argument_list|,
name|vd0
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pathrand
argument_list|,
name|vd0
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|leaf
operator|=
literal|0
expr_stmt|;
name|leaves
operator|=
literal|1
expr_stmt|;
name|maxfaults
operator|=
name|INT_MAX
expr_stmt|;
comment|/* no limit on cache devices */
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we can tolerate two or more faults, or we're dealing 	 * with a slog, randomly online/offline vd0. 	 */
if|if
condition|(
operator|(
name|maxfaults
operator|>=
literal|2
operator|||
name|islog
operator|)
operator|&&
name|guid0
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ztest_random
argument_list|(
literal|10
argument_list|)
operator|<
literal|6
condition|)
block|{
name|int
name|flags
init|=
operator|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|?
name|ZFS_OFFLINE_TEMPORARY
else|:
literal|0
operator|)
decl_stmt|;
comment|/* 			 * We have to grab the zs_name_lock as writer to 			 * prevent a race between offlining a slog and 			 * destroying a dataset. Offlining the slog will 			 * grab a reference on the dataset which may cause 			 * dmu_objset_destroy() to fail with EBUSY thus 			 * leaving the dataset in an inconsistent state. 			 */
if|if
condition|(
name|islog
condition|)
operator|(
name|void
operator|)
name|rw_wrlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|vdev_offline
argument_list|(
name|spa
argument_list|,
name|guid0
argument_list|,
name|flags
argument_list|)
operator|!=
name|EBUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|islog
condition|)
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Ideally we would like to be able to randomly 			 * call vdev_[on|off]line without holding locks 			 * to force unpredictable failures but the side 			 * effects of vdev_[on|off]line prevent us from 			 * doing so. We grab the ztest_vdev_lock here to 			 * prevent a race between injection testing and 			 * aux_vdev removal. 			 */
name|VERIFY
argument_list|(
name|mutex_lock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vdev_online
argument_list|(
name|spa
argument_list|,
name|guid0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maxfaults
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * We have at least single-fault tolerance, so inject data corruption. 	 */
name|fd
operator|=
name|open
argument_list|(
name|pathrand
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
comment|/* we hit a gap in the device namespace */
return|return;
name|fsize
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|iters
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The offset must be chosen carefully to ensure that 		 * we do not inject a given logical block with errors 		 * on two different leaf devices, because ZFS can not 		 * tolerate that (if maxfaults==1). 		 * 		 * We divide each leaf into chunks of size 		 * (# leaves * SPA_MAXBLOCKSIZE * 4).  Within each chunk 		 * there is a series of ranges to which we can inject errors. 		 * Each range can accept errors on only a single leaf vdev. 		 * The error injection ranges are separated by ranges 		 * which we will not inject errors on any device (DMZs). 		 * Each DMZ must be large enough such that a single block 		 * can not straddle it, so that a single block can not be 		 * a target in two different injection ranges (on different 		 * leaf vdevs). 		 * 		 * For example, with 3 leaves, each chunk looks like: 		 *    0 to  32M: injection range for leaf 0 		 *  32M to  64M: DMZ - no injection allowed 		 *  64M to  96M: injection range for leaf 1 		 *  96M to 128M: DMZ - no injection allowed 		 * 128M to 160M: injection range for leaf 2 		 * 160M to 192M: DMZ - no injection allowed 		 */
name|offset
operator|=
name|ztest_random
argument_list|(
name|fsize
operator|/
operator|(
name|leaves
operator|<<
name|bshift
operator|)
argument_list|)
operator|*
operator|(
name|leaves
operator|<<
name|bshift
operator|)
operator|+
operator|(
name|leaf
operator|<<
name|bshift
operator|)
operator|+
operator|(
name|ztest_random
argument_list|(
literal|1ULL
operator|<<
operator|(
name|bshift
operator|-
literal|1
operator|)
argument_list|)
operator|&
operator|-
literal|8ULL
operator|)
expr_stmt|;
comment|/* 		 * Only allow damage to the labels at one end of the vdev. 		 * 		 * If all labels are damaged, the device will be totally 		 * inaccessible, which will result in loss of data, 		 * because we also damage (parts of) the other side of 		 * the mirror/raidz. 		 * 		 * Additionally, we will always have both an even and an 		 * odd label, so that we can handle crashes in the 		 * middle of vdev_config_sync(). 		 */
if|if
condition|(
operator|(
name|leaf
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|offset
operator|<
name|VDEV_LABEL_START_SIZE
condition|)
continue|continue;
comment|/* 		 * The two end labels are stored at the "end" of the disk, but 		 * the end of the disk (vdev_psize) is aligned to 		 * sizeof (vdev_label_t). 		 */
name|uint64_t
name|psize
init|=
name|P2ALIGN
argument_list|(
name|fsize
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|leaf
operator|&
literal|1
operator|)
operator|==
literal|1
operator|&&
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|bad
argument_list|)
operator|>
name|psize
operator|-
name|VDEV_LABEL_END_SIZE
condition|)
continue|continue;
name|VERIFY
argument_list|(
name|mutex_lock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mirror_save
operator|!=
name|zs
operator|->
name|zs_mirrors
condition|)
block|{
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pwrite
argument_list|(
name|fd
argument_list|,
operator|&
name|bad
argument_list|,
sizeof|sizeof
argument_list|(
name|bad
argument_list|)
argument_list|,
name|offset
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|bad
argument_list|)
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"can't inject bad word at 0x%llx in %s"
argument_list|,
name|offset
argument_list|,
name|pathrand
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|mutex_unlock
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|7
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"injected bad word into %s,"
literal|" offset 0x%llx\n"
argument_list|,
name|pathrand
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|offset
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that DDT repair works as expected.  */
end_comment

begin_function
name|void
name|ztest_ddt_repair
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|ztest_shared_t
modifier|*
name|zs
init|=
name|ztest_shared
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|ztest_spa
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zd
operator|->
name|zd_os
decl_stmt|;
name|ztest_od_t
name|od
index|[
literal|1
index|]
decl_stmt|;
name|uint64_t
name|object
decl_stmt|,
name|blocksize
decl_stmt|,
name|txg
decl_stmt|,
name|pattern
decl_stmt|,
name|psize
decl_stmt|;
name|enum
name|zio_checksum
name|checksum
init|=
name|spa_dedup_checksum
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|abd_t
modifier|*
name|abd
decl_stmt|;
name|blkptr_t
name|blk
decl_stmt|;
name|int
name|copies
init|=
literal|2
operator|*
name|ZIO_DEDUPDITTO_MIN
decl_stmt|;
name|blocksize
operator|=
name|ztest_random_blocksize
argument_list|()
expr_stmt|;
name|blocksize
operator|=
name|MIN
argument_list|(
name|blocksize
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
comment|/* because we write so many */
name|ztest_od_init
argument_list|(
operator|&
name|od
index|[
literal|0
index|]
argument_list|,
name|id
argument_list|,
name|FTAG
argument_list|,
literal|0
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
name|blocksize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_object_init
argument_list|(
name|zd
argument_list|,
name|od
argument_list|,
sizeof|sizeof
argument_list|(
name|od
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * Take the name lock as writer to prevent anyone else from changing 	 * the pool and dataset properies we need to maintain during this test. 	 */
operator|(
name|void
operator|)
name|rw_wrlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_dsl_prop_set_uint64
argument_list|(
name|zd
operator|->
name|zd_name
argument_list|,
name|ZFS_PROP_DEDUP
argument_list|,
name|checksum
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
operator|||
name|ztest_dsl_prop_set_uint64
argument_list|(
name|zd
operator|->
name|zd_name
argument_list|,
name|ZFS_PROP_COPIES
argument_list|,
literal|1
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|dmu_objset_stats_t
name|dds
decl_stmt|;
name|dsl_pool_config_enter
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_objset_fast_stat
argument_list|(
name|os
argument_list|,
operator|&
name|dds
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|object
operator|=
name|od
index|[
literal|0
index|]
operator|.
name|od_object
expr_stmt|;
name|blocksize
operator|=
name|od
index|[
literal|0
index|]
operator|.
name|od_blocksize
expr_stmt|;
name|pattern
operator|=
name|zs
operator|->
name|zs_guid
operator|^
name|dds
operator|.
name|dds_guid
expr_stmt|;
name|ASSERT
argument_list|(
name|object
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
literal|0
argument_list|,
name|copies
operator|*
name|blocksize
argument_list|)
expr_stmt|;
name|txg
operator|=
name|ztest_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Write all the copies of our block. 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|copies
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|offset
init|=
name|i
operator|*
name|blocksize
decl_stmt|;
name|int
name|error
init|=
name|dmu_buf_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|fatal
argument_list|(
name|B_FALSE
argument_list|,
literal|"dmu_buf_hold(%p, %llu, %llu) = %u"
argument_list|,
name|os
argument_list|,
operator|(
name|long
name|long
operator|)
name|object
argument_list|,
operator|(
name|long
name|long
operator|)
name|offset
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|db
operator|->
name|db_offset
operator|==
name|offset
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_size
operator|==
name|blocksize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ztest_pattern_match
argument_list|(
name|db
operator|->
name|db_data
argument_list|,
name|db
operator|->
name|db_size
argument_list|,
name|pattern
argument_list|)
operator|||
name|ztest_pattern_match
argument_list|(
name|db
operator|->
name|db_data
argument_list|,
name|db
operator|->
name|db_size
argument_list|,
literal|0ULL
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_fill
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ztest_pattern_set
argument_list|(
name|db
operator|->
name|db_data
argument_list|,
name|db
operator|->
name|db_size
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * Find out what block we got. 	 */
name|VERIFY0
argument_list|(
name|dmu_buf_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
name|blk
operator|=
operator|*
operator|(
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|db
operator|)
operator|->
name|db_blkptr
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Damage the block.  Dedup-ditto will save us when we read it later. 	 */
name|psize
operator|=
name|BP_GET_PSIZE
argument_list|(
operator|&
name|blk
argument_list|)
expr_stmt|;
name|abd
operator|=
name|abd_alloc_linear
argument_list|(
name|psize
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|ztest_pattern_set
argument_list|(
name|abd_to_buf
argument_list|(
name|abd
argument_list|)
argument_list|,
name|psize
argument_list|,
operator|~
name|pattern
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio_rewrite
argument_list|(
name|NULL
argument_list|,
name|spa
argument_list|,
literal|0
argument_list|,
operator|&
name|blk
argument_list|,
name|abd
argument_list|,
name|psize
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_PRIORITY_SYNC_WRITE
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_INDUCE_DAMAGE
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|abd_free
argument_list|(
name|abd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scrub the pool.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_scrub
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|ztest_spa
decl_stmt|;
operator|(
name|void
operator|)
name|spa_scan
argument_list|(
name|spa
argument_list|,
name|POOL_SCAN_SCRUB
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|poll
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* wait a moment, then force a restart */
operator|(
name|void
operator|)
name|spa_scan
argument_list|(
name|spa
argument_list|,
name|POOL_SCAN_SCRUB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change the guid for the pool.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_reguid
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|ztest_spa
decl_stmt|;
name|uint64_t
name|orig
decl_stmt|,
name|load
decl_stmt|;
name|int
name|error
decl_stmt|;
name|orig
operator|=
name|spa_guid
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|load
operator|=
name|spa_load_guid
argument_list|(
name|spa
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_wrlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_change_guid
argument_list|(
name|spa
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Changed guid old %llu -> %llu\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|orig
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VERIFY3U
argument_list|(
name|orig
argument_list|,
operator|!=
argument_list|,
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|load
argument_list|,
operator|==
argument_list|,
name|spa_load_guid
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rename the pool to a different name and then rename it back.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ztest_spa_rename
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|char
modifier|*
name|oldname
decl_stmt|,
modifier|*
name|newname
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
operator|(
name|void
operator|)
name|rw_wrlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
name|oldname
operator|=
name|ztest_opts
operator|.
name|zo_pool
expr_stmt|;
name|newname
operator|=
name|umem_alloc
argument_list|(
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|+
literal|5
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newname
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|newname
argument_list|,
literal|"_tmp"
argument_list|)
expr_stmt|;
comment|/* 	 * Do the rename 	 */
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|spa_rename
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Try to open it under the old name, which shouldn't exist 	 */
name|VERIFY3U
argument_list|(
name|ENOENT
argument_list|,
operator|==
argument_list|,
name|spa_open
argument_list|(
name|oldname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Open it under the new name and make sure it's still the same spa_t. 	 */
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|spa_open
argument_list|(
name|newname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|==
name|ztest_spa
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Rename it back to the original 	 */
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|spa_rename
argument_list|(
name|newname
argument_list|,
name|oldname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure it can still be opened 	 */
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|spa_open
argument_list|(
name|oldname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|==
name|ztest_spa
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|newname
argument_list|,
name|strlen
argument_list|(
name|newname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify pool integrity by running zdb.  */
end_comment

begin_function
specifier|static
name|void
name|ztest_run_zdb
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|char
name|zdb
index|[
name|MAXPATHLEN
operator|+
name|MAXNAMELEN
operator|+
literal|20
index|]
decl_stmt|;
name|char
name|zbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|bin
decl_stmt|;
name|char
modifier|*
name|ztest
decl_stmt|;
name|char
modifier|*
name|isa
decl_stmt|;
name|int
name|isalen
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|strlcpy
argument_list|(
name|zdb
argument_list|,
literal|"/usr/bin/ztest"
argument_list|,
sizeof|sizeof
argument_list|(
name|zdb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zdb lives in /usr/sbin, while ztest lives in /usr/bin */
name|bin
operator|=
name|strstr
argument_list|(
name|zdb
argument_list|,
literal|"/usr/bin/"
argument_list|)
expr_stmt|;
name|ztest
operator|=
name|strstr
argument_list|(
name|bin
argument_list|,
literal|"/ztest"
argument_list|)
expr_stmt|;
name|isa
operator|=
name|bin
operator|+
literal|8
expr_stmt|;
name|isalen
operator|=
name|ztest
operator|-
name|isa
expr_stmt|;
name|isa
operator|=
name|strdup
argument_list|(
name|isa
argument_list|)
expr_stmt|;
comment|/* LINTED */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bin
argument_list|,
literal|"/usr/sbin%.*s/zdb -bcc%s%s -d -U %s %s"
argument_list|,
name|isalen
argument_list|,
name|isa
argument_list|,
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|3
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|4
condition|?
literal|"v"
else|:
literal|""
argument_list|,
name|spa_config_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|5
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Executing %s\n"
argument_list|,
name|strstr
argument_list|(
name|zdb
argument_list|,
literal|"zdb "
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|popen
argument_list|(
name|zdb
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|zbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|zbuf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|3
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|zbuf
argument_list|)
expr_stmt|;
name|status
operator|=
name|pclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return;
name|ztest_dump_core
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"'%s' exit code %d"
argument_list|,
name|zdb
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"'%s' died with signal %d"
argument_list|,
name|zdb
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_walk_pool_directory
parameter_list|(
name|char
modifier|*
name|header
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|6
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|spa
operator|=
name|spa_next
argument_list|(
name|spa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|6
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_spa_import_export
parameter_list|(
name|char
modifier|*
name|oldname
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|newconfig
decl_stmt|;
name|uint64_t
name|pool_guid
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"import/export: old = %s, new = %s\n"
argument_list|,
name|oldname
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clean up from previous runs. 	 */
operator|(
name|void
operator|)
name|spa_destroy
argument_list|(
name|newname
argument_list|)
expr_stmt|;
comment|/* 	 * Get the pool's configuration and guid. 	 */
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|spa_open
argument_list|(
name|oldname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Kick off a scrub to tickle scrub/export races. 	 */
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|spa_scan
argument_list|(
name|spa
argument_list|,
name|POOL_SCAN_SCRUB
argument_list|)
expr_stmt|;
name|pool_guid
operator|=
name|spa_guid
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ztest_walk_pool_directory
argument_list|(
literal|"pools before export"
argument_list|)
expr_stmt|;
comment|/* 	 * Export it. 	 */
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|spa_export
argument_list|(
name|oldname
argument_list|,
operator|&
name|config
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|ztest_walk_pool_directory
argument_list|(
literal|"pools after export"
argument_list|)
expr_stmt|;
comment|/* 	 * Try to import it. 	 */
name|newconfig
operator|=
name|spa_tryimport
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|newconfig
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|newconfig
argument_list|)
expr_stmt|;
comment|/* 	 * Import it under the new name. 	 */
name|error
operator|=
name|spa_import
argument_list|(
name|newname
argument_list|,
name|config
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dump_nvlist
argument_list|(
name|config
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|B_FALSE
argument_list|,
literal|"couldn't import pool %s as %s: error %u"
argument_list|,
name|oldname
argument_list|,
name|newname
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|ztest_walk_pool_directory
argument_list|(
literal|"pools after import"
argument_list|)
expr_stmt|;
comment|/* 	 * Try to import it again -- should fail with EEXIST. 	 */
name|VERIFY3U
argument_list|(
name|EEXIST
argument_list|,
operator|==
argument_list|,
name|spa_import
argument_list|(
name|newname
argument_list|,
name|config
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Try to import it under a different name -- should fail with EEXIST. 	 */
name|VERIFY3U
argument_list|(
name|EEXIST
argument_list|,
operator|==
argument_list|,
name|spa_import
argument_list|(
name|oldname
argument_list|,
name|config
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that the pool is no longer visible under the old name. 	 */
name|VERIFY3U
argument_list|(
name|ENOENT
argument_list|,
operator|==
argument_list|,
name|spa_open
argument_list|(
name|oldname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that we can open and close the pool using the new name. 	 */
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|spa_open
argument_list|(
name|newname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pool_guid
operator|==
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_resume
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
if|if
condition|(
name|spa_suspended
argument_list|(
name|spa
argument_list|)
operator|&&
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|6
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"resuming from suspended state\n"
argument_list|)
expr_stmt|;
name|spa_vdev_state_enter
argument_list|(
name|spa
argument_list|,
name|SCL_NONE
argument_list|)
expr_stmt|;
name|vdev_clear
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ztest_resume_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|arg
decl_stmt|;
while|while
condition|(
operator|!
name|ztest_exiting
condition|)
block|{
if|if
condition|(
name|spa_suspended
argument_list|(
name|spa
argument_list|)
condition|)
name|ztest_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|poll
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* 		 * Periodically change the zfs_compressed_arc_enabled setting. 		 */
if|if
condition|(
name|ztest_random
argument_list|(
literal|10
argument_list|)
operator|==
literal|0
condition|)
name|zfs_compressed_arc_enabled
operator|=
name|ztest_random
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* 		 * Periodically change the zfs_abd_scatter_enabled setting. 		 */
if|if
condition|(
name|ztest_random
argument_list|(
literal|10
argument_list|)
operator|==
literal|0
condition|)
name|zfs_abd_scatter_enabled
operator|=
name|ztest_random
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ztest_deadman_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ztest_shared_t
modifier|*
name|zs
init|=
name|arg
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|ztest_spa
decl_stmt|;
name|hrtime_t
name|delta
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|delta
operator|=
name|zs
operator|->
name|zs_thread_stop
operator|-
name|zs
operator|->
name|zs_thread_start
operator|+
name|MSEC2NSEC
argument_list|(
name|zfs_deadman_synctime_ms
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|poll
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|NSEC2MSEC
argument_list|(
name|delta
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If the pool is suspended then fail immediately. Otherwise, 		 * check to see if the pool is making any progress. If 		 * vdev_deadman() discovers that there hasn't been any recent 		 * I/Os then it will end up aborting the tests. 		 */
if|if
condition|(
name|spa_suspended
argument_list|(
name|spa
argument_list|)
operator|||
name|spa
operator|->
name|spa_root_vdev
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"aborting test after %llu seconds because "
literal|"pool has transitioned to a suspended state."
argument_list|,
name|zfs_deadman_synctime_ms
operator|/
literal|1000
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|vdev_deadman
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|total
operator|+=
name|zfs_deadman_synctime_ms
operator|/
literal|1000
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ztest has been running for %lld seconds\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_execute
parameter_list|(
name|int
name|test
parameter_list|,
name|ztest_info_t
modifier|*
name|zi
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|ztest_ds_t
modifier|*
name|zd
init|=
operator|&
name|ztest_ds
index|[
name|id
operator|%
name|ztest_opts
operator|.
name|zo_datasets
index|]
decl_stmt|;
name|ztest_shared_callstate_t
modifier|*
name|zc
init|=
name|ZTEST_GET_SHARED_CALLSTATE
argument_list|(
name|test
argument_list|)
decl_stmt|;
name|hrtime_t
name|functime
init|=
name|gethrtime
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zi
operator|->
name|zi_iters
condition|;
name|i
operator|++
control|)
name|zi
operator|->
name|zi_func
argument_list|(
name|zd
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|functime
operator|=
name|gethrtime
argument_list|()
operator|-
name|functime
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|zc
operator|->
name|zc_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|zc
operator|->
name|zc_time
argument_list|,
name|functime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|4
condition|)
block|{
name|Dl_info
name|dli
decl_stmt|;
operator|(
name|void
operator|)
name|dladdr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|zi
operator|->
name|zi_func
argument_list|,
operator|&
name|dli
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%6.2f sec in %s\n"
argument_list|,
operator|(
name|double
operator|)
name|functime
operator|/
name|NANOSEC
argument_list|,
name|dli
operator|.
name|dli_sname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ztest_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|rand
decl_stmt|;
name|uint64_t
name|id
init|=
operator|(
name|uintptr_t
operator|)
name|arg
decl_stmt|;
name|ztest_shared_t
modifier|*
name|zs
init|=
name|ztest_shared
decl_stmt|;
name|uint64_t
name|call_next
decl_stmt|;
name|hrtime_t
name|now
decl_stmt|;
name|ztest_info_t
modifier|*
name|zi
decl_stmt|;
name|ztest_shared_callstate_t
modifier|*
name|zc
decl_stmt|;
while|while
condition|(
operator|(
name|now
operator|=
name|gethrtime
argument_list|()
operator|)
operator|<
name|zs
operator|->
name|zs_thread_stop
condition|)
block|{
comment|/* 		 * See if it's time to force a crash. 		 */
if|if
condition|(
name|now
operator|>
name|zs
operator|->
name|zs_thread_kill
condition|)
name|ztest_kill
argument_list|(
name|zs
argument_list|)
expr_stmt|;
comment|/* 		 * If we're getting ENOSPC with some regularity, stop. 		 */
if|if
condition|(
name|zs
operator|->
name|zs_enospc_count
operator|>
literal|10
condition|)
break|break;
comment|/* 		 * Pick a random function to execute. 		 */
name|rand
operator|=
name|ztest_random
argument_list|(
name|ZTEST_FUNCS
argument_list|)
expr_stmt|;
name|zi
operator|=
operator|&
name|ztest_info
index|[
name|rand
index|]
expr_stmt|;
name|zc
operator|=
name|ZTEST_GET_SHARED_CALLSTATE
argument_list|(
name|rand
argument_list|)
expr_stmt|;
name|call_next
operator|=
name|zc
operator|->
name|zc_next
expr_stmt|;
if|if
condition|(
name|now
operator|>=
name|call_next
operator|&&
name|atomic_cas_64
argument_list|(
operator|&
name|zc
operator|->
name|zc_next
argument_list|,
name|call_next
argument_list|,
name|call_next
operator|+
name|ztest_random
argument_list|(
literal|2
operator|*
name|zi
operator|->
name|zi_interval
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
argument_list|)
operator|==
name|call_next
condition|)
block|{
name|ztest_execute
argument_list|(
name|rand
argument_list|,
name|zi
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_dataset_name
parameter_list|(
name|char
modifier|*
name|dsname
parameter_list|,
name|char
modifier|*
name|pool
parameter_list|,
name|int
name|d
parameter_list|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|dsname
argument_list|,
name|ZFS_MAX_DATASET_NAME_LEN
argument_list|,
literal|"%s/ds_%d"
argument_list|,
name|pool
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_dataset_destroy
parameter_list|(
name|int
name|d
parameter_list|)
block|{
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|ztest_dataset_name
argument_list|(
name|name
argument_list|,
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|3
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Destroying %s to free up space\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Cleanup any non-standard clones and snapshots.  In general, 	 * ztest thread t operates on dataset (t % zopt_datasets), 	 * so there may be more than one thing to clean up. 	 */
for|for
control|(
name|int
name|t
init|=
name|d
init|;
name|t
operator|<
name|ztest_opts
operator|.
name|zo_threads
condition|;
name|t
operator|+=
name|ztest_opts
operator|.
name|zo_datasets
control|)
block|{
name|ztest_dsl_dataset_cleanup
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dmu_objset_find
argument_list|(
name|name
argument_list|,
name|ztest_objset_destroy_cb
argument_list|,
name|NULL
argument_list|,
name|DS_FIND_SNAPSHOTS
operator||
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_dataset_dirobj_verify
parameter_list|(
name|ztest_ds_t
modifier|*
name|zd
parameter_list|)
block|{
name|uint64_t
name|usedobjs
decl_stmt|,
name|dirobjs
decl_stmt|,
name|scratch
decl_stmt|;
comment|/* 	 * ZTEST_DIROBJ is the object directory for the entire dataset. 	 * Therefore, the number of objects in use should equal the 	 * number of ZTEST_DIROBJ entries, +1 for ZTEST_DIROBJ itself. 	 * If not, we have an object leak. 	 * 	 * Note that we can only check this in ztest_dataset_open(), 	 * when the open-context and syncing-context values agree. 	 * That's because zap_count() returns the open-context value, 	 * while dmu_objset_space() returns the rootbp fill count. 	 */
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_count
argument_list|(
name|zd
operator|->
name|zd_os
argument_list|,
name|ZTEST_DIROBJ
argument_list|,
operator|&
name|dirobjs
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_objset_space
argument_list|(
name|zd
operator|->
name|zd_os
argument_list|,
operator|&
name|scratch
argument_list|,
operator|&
name|scratch
argument_list|,
operator|&
name|usedobjs
argument_list|,
operator|&
name|scratch
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dirobjs
operator|+
literal|1
argument_list|,
operator|==
argument_list|,
name|usedobjs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ztest_dataset_open
parameter_list|(
name|int
name|d
parameter_list|)
block|{
name|ztest_ds_t
modifier|*
name|zd
init|=
operator|&
name|ztest_ds
index|[
name|d
index|]
decl_stmt|;
name|uint64_t
name|committed_seq
init|=
name|ZTEST_GET_SHARED_DS
argument_list|(
name|d
argument_list|)
operator|->
name|zd_seq
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ztest_dataset_name
argument_list|(
name|name
argument_list|,
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
name|d
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_rdlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|ztest_dataset_create
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
name|ztest_record_enospc
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|EEXIST
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dmu_objset_own
argument_list|(
name|name
argument_list|,
name|DMU_OST_OTHER
argument_list|,
name|B_FALSE
argument_list|,
name|zd
argument_list|,
operator|&
name|os
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rw_unlock
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
name|ztest_zd_init
argument_list|(
name|zd
argument_list|,
name|ZTEST_GET_SHARED_DS
argument_list|(
name|d
argument_list|)
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zd
operator|->
name|zd_zilog
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_header
operator|->
name|zh_claim_lr_seq
operator|!=
literal|0
operator|&&
name|zilog
operator|->
name|zl_header
operator|->
name|zh_claim_lr_seq
operator|<
name|committed_seq
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"missing log records: claimed %llu< committed %llu"
argument_list|,
name|zilog
operator|->
name|zl_header
operator|->
name|zh_claim_lr_seq
argument_list|,
name|committed_seq
argument_list|)
expr_stmt|;
name|ztest_dataset_dirobj_verify
argument_list|(
name|zd
argument_list|)
expr_stmt|;
name|zil_replay
argument_list|(
name|os
argument_list|,
name|zd
argument_list|,
name|ztest_replay_vector
argument_list|)
expr_stmt|;
name|ztest_dataset_dirobj_verify
argument_list|(
name|zd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|6
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s replay %llu blocks, %llu records, seq %llu\n"
argument_list|,
name|zd
operator|->
name|zd_name
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zilog
operator|->
name|zl_parse_blk_count
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zilog
operator|->
name|zl_parse_lr_count
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zilog
operator|->
name|zl_replaying_seq
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zil_open
argument_list|(
name|os
argument_list|,
name|ztest_get_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_replaying_seq
operator|!=
literal|0
operator|&&
name|zilog
operator|->
name|zl_replaying_seq
operator|<
name|committed_seq
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"missing log records: replayed %llu< committed %llu"
argument_list|,
name|zilog
operator|->
name|zl_replaying_seq
argument_list|,
name|committed_seq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_dataset_close
parameter_list|(
name|int
name|d
parameter_list|)
block|{
name|ztest_ds_t
modifier|*
name|zd
init|=
operator|&
name|ztest_ds
index|[
name|d
index|]
decl_stmt|;
name|zil_close
argument_list|(
name|zd
operator|->
name|zd_zilog
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|zd
operator|->
name|zd_os
argument_list|,
name|zd
argument_list|)
expr_stmt|;
name|ztest_zd_fini
argument_list|(
name|zd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Kick off threads to run tests on all datasets in parallel.  */
end_comment

begin_function
specifier|static
name|void
name|ztest_run
parameter_list|(
name|ztest_shared_t
modifier|*
name|zs
parameter_list|)
block|{
name|thread_t
modifier|*
name|tid
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|thread_t
name|resume_tid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ztest_exiting
operator|=
name|B_FALSE
expr_stmt|;
comment|/* 	 * Initialize parent/child shared state. 	 */
name|VERIFY
argument_list|(
name|_mutex_init
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|,
name|USYNC_THREAD
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|rwlock_init
argument_list|(
operator|&
name|ztest_name_lock
argument_list|,
name|USYNC_THREAD
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_thread_start
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|zs
operator|->
name|zs_thread_stop
operator|=
name|zs
operator|->
name|zs_thread_start
operator|+
name|ztest_opts
operator|.
name|zo_passtime
operator|*
name|NANOSEC
expr_stmt|;
name|zs
operator|->
name|zs_thread_stop
operator|=
name|MIN
argument_list|(
name|zs
operator|->
name|zs_thread_stop
argument_list|,
name|zs
operator|->
name|zs_proc_stop
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_thread_kill
operator|=
name|zs
operator|->
name|zs_thread_stop
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|100
argument_list|)
operator|<
name|ztest_opts
operator|.
name|zo_killrate
condition|)
block|{
name|zs
operator|->
name|zs_thread_kill
operator|-=
name|ztest_random
argument_list|(
name|ztest_opts
operator|.
name|zo_passtime
operator|*
name|NANOSEC
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|_mutex_init
argument_list|(
operator|&
name|zcl
operator|.
name|zcl_callbacks_lock
argument_list|,
name|USYNC_THREAD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zcl
operator|.
name|zcl_callbacks
argument_list|,
sizeof|sizeof
argument_list|(
name|ztest_cb_data_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|ztest_cb_data_t
argument_list|,
name|zcd_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Open our pool. 	 */
name|kernel_init
argument_list|(
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|spa_open
argument_list|(
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_debug
operator|=
name|B_TRUE
expr_stmt|;
name|metaslab_preload_limit
operator|=
name|ztest_random
argument_list|(
literal|20
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ztest_spa
operator|=
name|spa
expr_stmt|;
name|dmu_objset_stats_t
name|dds
decl_stmt|;
name|VERIFY0
argument_list|(
name|dmu_objset_own
argument_list|(
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
name|DMU_OST_ANY
argument_list|,
name|B_TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_pool_config_enter
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_objset_fast_stat
argument_list|(
name|os
argument_list|,
operator|&
name|dds
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_guid
operator|=
name|dds
operator|.
name|dds_guid
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_dedup_ditto
operator|=
literal|2
operator|*
name|ZIO_DEDUPDITTO_MIN
expr_stmt|;
comment|/* 	 * We don't expect the pool to suspend unless maxfaults == 0, 	 * in which case ztest_fault_inject() temporarily takes away 	 * the only valid replica. 	 */
if|if
condition|(
name|MAXFAULTS
argument_list|()
operator|==
literal|0
condition|)
name|spa
operator|->
name|spa_failmode
operator|=
name|ZIO_FAILURE_MODE_WAIT
expr_stmt|;
else|else
name|spa
operator|->
name|spa_failmode
operator|=
name|ZIO_FAILURE_MODE_PANIC
expr_stmt|;
comment|/* 	 * Create a thread to periodically resume suspended I/O. 	 */
name|VERIFY
argument_list|(
name|thr_create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ztest_resume_thread
argument_list|,
name|spa
argument_list|,
name|THR_BOUND
argument_list|,
operator|&
name|resume_tid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Create a deadman thread to abort() if we hang. 	 */
name|VERIFY
argument_list|(
name|thr_create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ztest_deadman_thread
argument_list|,
name|zs
argument_list|,
name|THR_BOUND
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that we can safely inquire about about any object, 	 * whether it's allocated or not.  To make it interesting, 	 * we probe a 5-wide window around each power of two. 	 * This hits all edge cases, including zero and the max. 	 */
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
literal|64
condition|;
name|t
operator|++
control|)
block|{
for|for
control|(
name|int
name|d
init|=
operator|-
literal|5
init|;
name|d
operator|<=
literal|5
condition|;
name|d
operator|++
control|)
block|{
name|error
operator|=
name|dmu_object_info
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
operator|(
literal|1ULL
operator|<<
name|t
operator|)
operator|+
name|d
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ENOENT
operator|||
name|error
operator|==
name|EINVAL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we got any ENOSPC errors on the previous run, destroy something. 	 */
if|if
condition|(
name|zs
operator|->
name|zs_enospc_count
operator|!=
literal|0
condition|)
block|{
name|int
name|d
init|=
name|ztest_random
argument_list|(
name|ztest_opts
operator|.
name|zo_datasets
argument_list|)
decl_stmt|;
name|ztest_dataset_destroy
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|zs
operator|->
name|zs_enospc_count
operator|=
literal|0
expr_stmt|;
name|tid
operator|=
name|umem_zalloc
argument_list|(
name|ztest_opts
operator|.
name|zo_threads
operator|*
sizeof|sizeof
argument_list|(
name|thread_t
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|4
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"starting main threads...\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Kick off all the tests that run in parallel. 	 */
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|ztest_opts
operator|.
name|zo_threads
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|t
operator|<
name|ztest_opts
operator|.
name|zo_datasets
operator|&&
name|ztest_dataset_open
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|VERIFY
argument_list|(
name|thr_create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ztest_thread
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|t
argument_list|,
name|THR_BOUND
argument_list|,
operator|&
name|tid
index|[
name|t
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for all of the tests to complete.  We go in reverse order 	 * so we don't close datasets while threads are still using them. 	 */
for|for
control|(
name|int
name|t
init|=
name|ztest_opts
operator|.
name|zo_threads
operator|-
literal|1
init|;
name|t
operator|>=
literal|0
condition|;
name|t
operator|--
control|)
block|{
name|VERIFY
argument_list|(
name|thr_join
argument_list|(
name|tid
index|[
name|t
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|ztest_opts
operator|.
name|zo_datasets
condition|)
name|ztest_dataset_close
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_alloc
operator|=
name|metaslab_class_get_alloc
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_space
operator|=
name|metaslab_class_get_space
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_dbgmsg_print
argument_list|(
name|FTAG
argument_list|)
expr_stmt|;
name|umem_free
argument_list|(
name|tid
argument_list|,
name|ztest_opts
operator|.
name|zo_threads
operator|*
sizeof|sizeof
argument_list|(
name|thread_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Kill the resume thread */
name|ztest_exiting
operator|=
name|B_TRUE
expr_stmt|;
name|VERIFY
argument_list|(
name|thr_join
argument_list|(
name|resume_tid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ztest_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Right before closing the pool, kick off a bunch of async I/O; 	 * spa_close() should wait for it to complete. 	 */
for|for
control|(
name|uint64_t
name|object
init|=
literal|1
init|;
name|object
operator|<
literal|50
condition|;
name|object
operator|++
control|)
block|{
name|dmu_prefetch
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1ULL
operator|<<
literal|20
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|)
expr_stmt|;
block|}
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that we can loop over all pools. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|spa
operator|=
name|spa_next
argument_list|(
name|NULL
argument_list|)
init|;
name|spa
operator|!=
name|NULL
condition|;
name|spa
operator|=
name|spa_next
argument_list|(
name|spa
argument_list|)
control|)
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>
literal|3
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"spa_next: found %s\n"
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that we can export the pool and reimport it under a 	 * different name. 	 */
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s_import"
argument_list|,
name|ztest_opts
operator|.
name|zo_pool
argument_list|)
expr_stmt|;
name|ztest_spa_import_export
argument_list|(
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ztest_spa_import_export
argument_list|(
name|name
argument_list|,
name|ztest_opts
operator|.
name|zo_pool
argument_list|)
expr_stmt|;
block|}
name|kernel_fini
argument_list|()
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|zcl
operator|.
name|zcl_callbacks
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_mutex_destroy
argument_list|(
operator|&
name|zcl
operator|.
name|zcl_callbacks_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rwlock_destroy
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_mutex_destroy
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_freeze
parameter_list|(
name|void
parameter_list|)
block|{
name|ztest_ds_t
modifier|*
name|zd
init|=
operator|&
name|ztest_ds
index|[
literal|0
index|]
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|numloops
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|3
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"testing spa_freeze()...\n"
argument_list|)
expr_stmt|;
name|kernel_init
argument_list|(
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|spa_open
argument_list|(
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|ztest_dataset_open
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_debug
operator|=
name|B_TRUE
expr_stmt|;
name|ztest_spa
operator|=
name|spa
expr_stmt|;
comment|/* 	 * Force the first log block to be transactionally allocated. 	 * We have to do this before we freeze the pool -- otherwise 	 * the log chain won't be anchored. 	 */
while|while
condition|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|zd
operator|->
name|zd_zilog
operator|->
name|zl_header
operator|->
name|zh_log
argument_list|)
condition|)
block|{
name|ztest_dmu_object_alloc_free
argument_list|(
name|zd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zil_commit
argument_list|(
name|zd
operator|->
name|zd_zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Freeze the pool.  This stops spa_sync() from doing anything, 	 * so that the only way to record changes from now on is the ZIL. 	 */
name|spa_freeze
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Because it is hard to predict how much space a write will actually 	 * require beforehand, we leave ourselves some fudge space to write over 	 * capacity. 	 */
name|uint64_t
name|capacity
init|=
name|metaslab_class_get_space
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|/
literal|2
decl_stmt|;
comment|/* 	 * Run tests that generate log records but don't alter the pool config 	 * or depend on DSL sync tasks (snapshots, objset create/destroy, etc). 	 * We do a txg_wait_synced() after each iteration to force the txg 	 * to increase well beyond the last synced value in the uberblock. 	 * The ZIL should be OK with that. 	 * 	 * Run a random number of times less than zo_maxloops and ensure we do 	 * not run out of space on the pool. 	 */
while|while
condition|(
name|ztest_random
argument_list|(
literal|10
argument_list|)
operator|!=
literal|0
operator|&&
name|numloops
operator|++
operator|<
name|ztest_opts
operator|.
name|zo_maxloops
operator|&&
name|metaslab_class_get_alloc
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|<
name|capacity
condition|)
block|{
name|ztest_od_t
name|od
decl_stmt|;
name|ztest_od_init
argument_list|(
operator|&
name|od
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|,
literal|0
argument_list|,
name|DMU_OT_UINT64_OTHER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|ztest_object_init
argument_list|(
name|zd
argument_list|,
operator|&
name|od
argument_list|,
sizeof|sizeof
argument_list|(
name|od
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|ztest_io
argument_list|(
name|zd
argument_list|,
name|od
operator|.
name|od_object
argument_list|,
name|ztest_random
argument_list|(
name|ZTEST_RANGE_LOCKS
argument_list|)
operator|<<
name|SPA_MAXBLOCKSHIFT
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Commit all of the changes we just generated. 	 */
name|zil_commit
argument_list|(
name|zd
operator|->
name|zd_zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Close our dataset and close the pool. 	 */
name|ztest_dataset_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|kernel_fini
argument_list|()
expr_stmt|;
comment|/* 	 * Open and close the pool and dataset to induce log replay. 	 */
name|kernel_init
argument_list|(
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|spa_open
argument_list|(
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_freeze_txg
argument_list|(
name|spa
argument_list|)
operator|==
name|UINT64_MAX
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|ztest_dataset_open
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ztest_dataset_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_debug
operator|=
name|B_TRUE
expr_stmt|;
name|ztest_spa
operator|=
name|spa
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ztest_reguid
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|kernel_fini
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_time
parameter_list|(
name|hrtime_t
name|t
parameter_list|,
name|char
modifier|*
name|timebuf
parameter_list|)
block|{
name|hrtime_t
name|s
init|=
name|t
operator|/
name|NANOSEC
decl_stmt|;
name|hrtime_t
name|m
init|=
name|s
operator|/
literal|60
decl_stmt|;
name|hrtime_t
name|h
init|=
name|m
operator|/
literal|60
decl_stmt|;
name|hrtime_t
name|d
init|=
name|h
operator|/
literal|24
decl_stmt|;
name|s
operator|-=
name|m
operator|*
literal|60
expr_stmt|;
name|m
operator|-=
name|h
operator|*
literal|60
expr_stmt|;
name|h
operator|-=
name|d
operator|*
literal|24
expr_stmt|;
name|timebuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|d
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|timebuf
argument_list|,
literal|"%llud%02lluh%02llum%02llus"
argument_list|,
name|d
argument_list|,
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|timebuf
argument_list|,
literal|"%lluh%02llum%02llus"
argument_list|,
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|timebuf
argument_list|,
literal|"%llum%02llus"
argument_list|,
name|m
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|timebuf
argument_list|,
literal|"%llus"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|nvlist_t
modifier|*
name|make_random_props
parameter_list|()
block|{
name|nvlist_t
modifier|*
name|props
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|props
operator|)
return|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
literal|"autoreplace"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|props
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a storage pool with the given name and initial vdev size.  * Then test spa_freeze() functionality.  */
end_comment

begin_function
specifier|static
name|void
name|ztest_init
parameter_list|(
name|ztest_shared_t
modifier|*
name|zs
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|,
modifier|*
name|props
decl_stmt|;
name|VERIFY
argument_list|(
name|_mutex_init
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|,
name|USYNC_THREAD
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|rwlock_init
argument_list|(
operator|&
name|ztest_name_lock
argument_list|,
name|USYNC_THREAD
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|kernel_init
argument_list|(
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Create the storage pool. 	 */
operator|(
name|void
operator|)
name|spa_destroy
argument_list|(
name|ztest_opts
operator|.
name|zo_pool
argument_list|)
expr_stmt|;
name|ztest_shared
operator|->
name|zs_vdev_next_leaf
operator|=
literal|0
expr_stmt|;
name|zs
operator|->
name|zs_splits
operator|=
literal|0
expr_stmt|;
name|zs
operator|->
name|zs_mirrors
operator|=
name|ztest_opts
operator|.
name|zo_mirrors
expr_stmt|;
name|nvroot
operator|=
name|make_vdev_root
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ztest_opts
operator|.
name|zo_vdev_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ztest_opts
operator|.
name|zo_raidz
argument_list|,
name|zs
operator|->
name|zs_mirrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|props
operator|=
name|make_random_props
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SPA_FEATURES
condition|;
name|i
operator|++
control|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"feature@%s"
argument_list|,
name|spa_feature_table
index|[
name|i
index|]
operator|.
name|fi_uname
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|spa_create
argument_list|(
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
name|nvroot
argument_list|,
name|props
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|spa_open
argument_list|(
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_metaslab_sz
operator|=
literal|1ULL
operator|<<
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_child
index|[
literal|0
index|]
operator|->
name|vdev_ms_shift
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|kernel_fini
argument_list|()
expr_stmt|;
name|ztest_run_zdb
argument_list|(
name|ztest_opts
operator|.
name|zo_pool
argument_list|)
expr_stmt|;
name|ztest_freeze
argument_list|()
expr_stmt|;
name|ztest_run_zdb
argument_list|(
name|ztest_opts
operator|.
name|zo_pool
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rwlock_destroy
argument_list|(
operator|&
name|ztest_name_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_mutex_destroy
argument_list|(
operator|&
name|ztest_vdev_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_data_fd
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|ztest_name_data
index|[]
init|=
literal|"/tmp/ztest.data.XXXXXX"
decl_stmt|;
name|ztest_fd_data
operator|=
name|mkstemp
argument_list|(
name|ztest_name_data
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|ztest_fd_data
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|ztest_name_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|shared_data_size
parameter_list|(
name|ztest_shared_hdr_t
modifier|*
name|hdr
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
name|hdr
operator|->
name|zh_hdr_size
expr_stmt|;
name|size
operator|+=
name|hdr
operator|->
name|zh_opts_size
expr_stmt|;
name|size
operator|+=
name|hdr
operator|->
name|zh_size
expr_stmt|;
name|size
operator|+=
name|hdr
operator|->
name|zh_stats_size
operator|*
name|hdr
operator|->
name|zh_stats_count
expr_stmt|;
name|size
operator|+=
name|hdr
operator|->
name|zh_ds_size
operator|*
name|hdr
operator|->
name|zh_ds_count
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_hdr
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|ztest_shared_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|(
name|void
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|P2ROUNDUP
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|getpagesize
argument_list|()
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|ztest_fd_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|!=
name|MAP_FAILED
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|ftruncate
argument_list|(
name|ztest_fd_data
argument_list|,
sizeof|sizeof
argument_list|(
name|ztest_shared_hdr_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|zh_hdr_size
operator|=
sizeof|sizeof
argument_list|(
name|ztest_shared_hdr_t
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|zh_opts_size
operator|=
sizeof|sizeof
argument_list|(
name|ztest_shared_opts_t
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|zh_size
operator|=
sizeof|sizeof
argument_list|(
name|ztest_shared_t
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|zh_stats_size
operator|=
sizeof|sizeof
argument_list|(
name|ztest_shared_callstate_t
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|zh_stats_count
operator|=
name|ZTEST_FUNCS
expr_stmt|;
name|hdr
operator|->
name|zh_ds_size
operator|=
sizeof|sizeof
argument_list|(
name|ztest_shared_ds_t
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|zh_ds_count
operator|=
name|ztest_opts
operator|.
name|zo_datasets
expr_stmt|;
name|size
operator|=
name|shared_data_size
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|ftruncate
argument_list|(
name|ztest_fd_data
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|hdr
argument_list|,
name|P2ROUNDUP
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|getpagesize
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_data
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|offset
decl_stmt|;
name|ztest_shared_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|hdr
operator|=
operator|(
name|void
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|P2ROUNDUP
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|getpagesize
argument_list|()
argument_list|)
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|ztest_fd_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|!=
name|MAP_FAILED
argument_list|)
expr_stmt|;
name|size
operator|=
name|shared_data_size
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|hdr
argument_list|,
name|P2ROUNDUP
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|getpagesize
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|ztest_shared_hdr
operator|=
operator|(
name|void
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|P2ROUNDUP
argument_list|(
name|size
argument_list|,
name|getpagesize
argument_list|()
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|ztest_fd_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|!=
name|MAP_FAILED
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|hdr
expr_stmt|;
name|offset
operator|=
name|hdr
operator|->
name|zh_hdr_size
expr_stmt|;
name|ztest_shared_opts
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|buf
index|[
name|offset
index|]
expr_stmt|;
name|offset
operator|+=
name|hdr
operator|->
name|zh_opts_size
expr_stmt|;
name|ztest_shared
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|buf
index|[
name|offset
index|]
expr_stmt|;
name|offset
operator|+=
name|hdr
operator|->
name|zh_size
expr_stmt|;
name|ztest_shared_callstate
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|buf
index|[
name|offset
index|]
expr_stmt|;
name|offset
operator|+=
name|hdr
operator|->
name|zh_stats_size
operator|*
name|hdr
operator|->
name|zh_stats_count
expr_stmt|;
name|ztest_shared_ds
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|buf
index|[
name|offset
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|exec_child
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|libpath
parameter_list|,
name|boolean_t
name|ignorekill
parameter_list|,
name|int
modifier|*
name|statusp
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|cmdbuf
init|=
name|NULL
decl_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|cmdbuf
operator|=
name|umem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|cmdbuf
argument_list|,
name|getexecname
argument_list|()
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|cmdbuf
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"fork failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* child */
name|char
modifier|*
name|emptyargv
index|[
literal|2
index|]
init|=
block|{
name|cmd
block|,
name|NULL
block|}
decl_stmt|;
name|char
name|fd_data_str
index|[
literal|12
index|]
decl_stmt|;
name|struct
name|rlimit
name|rl
init|=
block|{
literal|1024
block|,
literal|1024
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|setrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|rl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ztest_fd_rand
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|11
argument_list|,
operator|>=
argument_list|,
name|snprintf
argument_list|(
name|fd_data_str
argument_list|,
literal|12
argument_list|,
literal|"%d"
argument_list|,
name|ztest_fd_data
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|setenv
argument_list|(
literal|"ZTEST_FD_DATA"
argument_list|,
name|fd_data_str
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|enable_extended_FILE_stdio
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|libpath
operator|!=
name|NULL
condition|)
name|VERIFY
argument_list|(
literal|0
operator|==
name|setenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|,
name|libpath
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
operator|(
name|void
operator|)
name|execv
argument_list|(
name|cmd
argument_list|,
name|emptyargv
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|execvp
argument_list|(
name|cmd
argument_list|,
name|emptyargv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ztest_dump_core
operator|=
name|B_FALSE
expr_stmt|;
name|fatal
argument_list|(
name|B_TRUE
argument_list|,
literal|"exec failed: %s"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmdbuf
operator|!=
name|NULL
condition|)
block|{
name|umem_free
argument_list|(
name|cmdbuf
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|!=
name|pid
condition|)
continue|continue;
if|if
condition|(
name|statusp
operator|!=
name|NULL
condition|)
operator|*
name|statusp
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"child exited with code %d\n"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignorekill
operator|||
name|WTERMSIG
argument_list|(
name|status
argument_list|)
operator|!=
name|SIGKILL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"child died with signal %d\n"
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"something strange happened to child\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ztest_run_init
parameter_list|(
name|void
parameter_list|)
block|{
name|ztest_shared_t
modifier|*
name|zs
init|=
name|ztest_shared
decl_stmt|;
name|ASSERT
argument_list|(
name|ztest_opts
operator|.
name|zo_init
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Blow away any existing copy of zpool.cache 	 */
operator|(
name|void
operator|)
name|remove
argument_list|(
name|spa_config_path
argument_list|)
expr_stmt|;
comment|/* 	 * Create and initialize our storage pool. 	 */
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|ztest_opts
operator|.
name|zo_init
condition|;
name|i
operator|++
control|)
block|{
name|bzero
argument_list|(
name|zs
argument_list|,
sizeof|sizeof
argument_list|(
name|ztest_shared_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|3
operator|&&
name|ztest_opts
operator|.
name|zo_init
operator|!=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ztest_init(), pass %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|ztest_init
argument_list|(
name|zs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|kills
init|=
literal|0
decl_stmt|;
name|int
name|iters
init|=
literal|0
decl_stmt|;
name|int
name|older
init|=
literal|0
decl_stmt|;
name|int
name|newer
init|=
literal|0
decl_stmt|;
name|ztest_shared_t
modifier|*
name|zs
decl_stmt|;
name|ztest_info_t
modifier|*
name|zi
decl_stmt|;
name|ztest_shared_callstate_t
modifier|*
name|zc
decl_stmt|;
name|char
name|timebuf
index|[
literal|100
index|]
decl_stmt|;
name|char
name|numbuf
index|[
literal|6
index|]
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|boolean_t
name|hasalt
decl_stmt|;
name|char
modifier|*
name|fd_data_str
init|=
name|getenv
argument_list|(
literal|"ZTEST_FD_DATA"
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dprintf_setup
argument_list|(
operator|&
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|zfs_deadman_synctime_ms
operator|=
literal|300000
expr_stmt|;
name|ztest_fd_rand
operator|=
name|open
argument_list|(
literal|"/dev/urandom"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|ztest_fd_rand
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fd_data_str
condition|)
block|{
name|process_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|setup_data_fd
argument_list|()
expr_stmt|;
name|setup_hdr
argument_list|()
expr_stmt|;
name|setup_data
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ztest_opts
argument_list|,
name|ztest_shared_opts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ztest_shared_opts
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ztest_fd_data
operator|=
name|atoi
argument_list|(
name|fd_data_str
argument_list|)
expr_stmt|;
name|setup_data
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|ztest_shared_opts
argument_list|,
operator|&
name|ztest_opts
argument_list|,
sizeof|sizeof
argument_list|(
name|ztest_opts
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|ztest_opts
operator|.
name|zo_datasets
argument_list|,
operator|==
argument_list|,
name|ztest_shared_hdr
operator|->
name|zh_ds_count
argument_list|)
expr_stmt|;
comment|/* Override location of zpool.cache */
name|VERIFY3U
argument_list|(
name|asprintf
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|spa_config_path
argument_list|,
literal|"%s/zpool.cache"
argument_list|,
name|ztest_opts
operator|.
name|zo_dir
argument_list|)
argument_list|,
operator|!=
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ztest_ds
operator|=
name|umem_alloc
argument_list|(
name|ztest_opts
operator|.
name|zo_datasets
operator|*
sizeof|sizeof
argument_list|(
name|ztest_ds_t
argument_list|)
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
name|zs
operator|=
name|ztest_shared
expr_stmt|;
if|if
condition|(
name|fd_data_str
condition|)
block|{
name|metaslab_gang_bang
operator|=
name|ztest_opts
operator|.
name|zo_metaslab_gang_bang
expr_stmt|;
name|metaslab_df_alloc_threshold
operator|=
name|zs
operator|->
name|zs_metaslab_df_alloc_threshold
expr_stmt|;
if|if
condition|(
name|zs
operator|->
name|zs_do_init
condition|)
name|ztest_run_init
argument_list|()
expr_stmt|;
else|else
name|ztest_run
argument_list|(
name|zs
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|hasalt
operator|=
operator|(
name|strlen
argument_list|(
name|ztest_opts
operator|.
name|zo_alt_ztest
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%llu vdevs, %d datasets, %d threads,"
literal|" %llu seconds...\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|ztest_opts
operator|.
name|zo_vdevs
argument_list|,
name|ztest_opts
operator|.
name|zo_datasets
argument_list|,
name|ztest_opts
operator|.
name|zo_threads
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|ztest_opts
operator|.
name|zo_time
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
name|umem_alloc
argument_list|(
name|MAXNAMELEN
argument_list|,
name|UMEM_NOFAIL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|cmd
argument_list|,
name|getexecname
argument_list|()
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_do_init
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ztest_opts
operator|.
name|zo_alt_ztest
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Executing older ztest for "
literal|"initialization: %s\n"
argument_list|,
name|ztest_opts
operator|.
name|zo_alt_ztest
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
operator|!
name|exec_child
argument_list|(
name|ztest_opts
operator|.
name|zo_alt_ztest
argument_list|,
name|ztest_opts
operator|.
name|zo_alt_libpath
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VERIFY
argument_list|(
operator|!
name|exec_child
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zs
operator|->
name|zs_do_init
operator|=
name|B_FALSE
expr_stmt|;
name|zs
operator|->
name|zs_proc_start
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|zs
operator|->
name|zs_proc_stop
operator|=
name|zs
operator|->
name|zs_proc_start
operator|+
name|ztest_opts
operator|.
name|zo_time
operator|*
name|NANOSEC
expr_stmt|;
for|for
control|(
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
name|ZTEST_FUNCS
condition|;
name|f
operator|++
control|)
block|{
name|zi
operator|=
operator|&
name|ztest_info
index|[
name|f
index|]
expr_stmt|;
name|zc
operator|=
name|ZTEST_GET_SHARED_CALLSTATE
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|zs
operator|->
name|zs_proc_start
operator|+
name|zi
operator|->
name|zi_interval
index|[
literal|0
index|]
operator|>
name|zs
operator|->
name|zs_proc_stop
condition|)
name|zc
operator|->
name|zc_next
operator|=
name|UINT64_MAX
expr_stmt|;
else|else
name|zc
operator|->
name|zc_next
operator|=
name|zs
operator|->
name|zs_proc_start
operator|+
name|ztest_random
argument_list|(
literal|2
operator|*
name|zi
operator|->
name|zi_interval
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Run the tests in a loop.  These tests include fault injection 	 * to verify that self-healing data works, and forced crashes 	 * to verify that we never lose on-disk consistency. 	 */
while|while
condition|(
name|gethrtime
argument_list|()
operator|<
name|zs
operator|->
name|zs_proc_stop
condition|)
block|{
name|int
name|status
decl_stmt|;
name|boolean_t
name|killed
decl_stmt|;
comment|/* 		 * Initialize the workload counters for each function. 		 */
for|for
control|(
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
name|ZTEST_FUNCS
condition|;
name|f
operator|++
control|)
block|{
name|zc
operator|=
name|ZTEST_GET_SHARED_CALLSTATE
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_count
operator|=
literal|0
expr_stmt|;
name|zc
operator|->
name|zc_time
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Set the allocation switch size */
name|zs
operator|->
name|zs_metaslab_df_alloc_threshold
operator|=
name|ztest_random
argument_list|(
name|zs
operator|->
name|zs_metaslab_sz
operator|/
literal|4
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|hasalt
operator|||
name|ztest_random
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hasalt
operator|&&
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Executing newer ztest: %s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
name|newer
operator|++
expr_stmt|;
name|killed
operator|=
name|exec_child
argument_list|(
name|cmd
argument_list|,
name|NULL
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hasalt
operator|&&
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Executing older ztest: %s\n"
argument_list|,
name|ztest_opts
operator|.
name|zo_alt_ztest
argument_list|)
expr_stmt|;
block|}
name|older
operator|++
expr_stmt|;
name|killed
operator|=
name|exec_child
argument_list|(
name|ztest_opts
operator|.
name|zo_alt_ztest
argument_list|,
name|ztest_opts
operator|.
name|zo_alt_libpath
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|killed
condition|)
name|kills
operator|++
expr_stmt|;
name|iters
operator|++
expr_stmt|;
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|1
condition|)
block|{
name|hrtime_t
name|now
init|=
name|gethrtime
argument_list|()
decl_stmt|;
name|now
operator|=
name|MIN
argument_list|(
name|now
argument_list|,
name|zs
operator|->
name|zs_proc_stop
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
name|zs
operator|->
name|zs_proc_stop
operator|-
name|now
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
name|nicenum
argument_list|(
name|zs
operator|->
name|zs_space
argument_list|,
name|numbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Pass %3d, %8s, %3llu ENOSPC, "
literal|"%4.1f%% of %5s used, %3.0f%% done, %8s to go\n"
argument_list|,
name|iters
argument_list|,
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|?
literal|"Complete"
else|:
literal|"SIGKILL"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zs
operator|->
name|zs_enospc_count
argument_list|,
literal|100.0
operator|*
name|zs
operator|->
name|zs_alloc
operator|/
name|zs
operator|->
name|zs_space
argument_list|,
name|numbuf
argument_list|,
literal|100.0
operator|*
operator|(
name|now
operator|-
name|zs
operator|->
name|zs_proc_start
operator|)
operator|/
operator|(
name|ztest_opts
operator|.
name|zo_time
operator|*
name|NANOSEC
operator|)
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\nWorkload summary:\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%7s %9s   %s\n"
argument_list|,
literal|"Calls"
argument_list|,
literal|"Time"
argument_list|,
literal|"Function"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%7s %9s   %s\n"
argument_list|,
literal|"-----"
argument_list|,
literal|"----"
argument_list|,
literal|"--------"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
name|ZTEST_FUNCS
condition|;
name|f
operator|++
control|)
block|{
name|Dl_info
name|dli
decl_stmt|;
name|zi
operator|=
operator|&
name|ztest_info
index|[
name|f
index|]
expr_stmt|;
name|zc
operator|=
name|ZTEST_GET_SHARED_CALLSTATE
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
name|zc
operator|->
name|zc_time
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dladdr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|zi
operator|->
name|zi_func
argument_list|,
operator|&
name|dli
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%7llu %9s   %s\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zc
operator|->
name|zc_count
argument_list|,
name|timebuf
argument_list|,
name|dli
operator|.
name|dli_sname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * It's possible that we killed a child during a rename test, 		 * in which case we'll have a 'ztest_tmp' pool lying around 		 * instead of 'ztest'.  Do a blind rename in case this happened. 		 */
name|kernel_init
argument_list|(
name|FREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_open
argument_list|(
name|ztest_opts
operator|.
name|zo_pool
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
operator|==
literal|0
condition|)
block|{
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|tmpname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|kernel_fini
argument_list|()
expr_stmt|;
name|kernel_init
argument_list|(
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tmpname
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpname
argument_list|)
argument_list|,
literal|"%s_tmp"
argument_list|,
name|ztest_opts
operator|.
name|zo_pool
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_rename
argument_list|(
name|tmpname
argument_list|,
name|ztest_opts
operator|.
name|zo_pool
argument_list|)
expr_stmt|;
block|}
name|kernel_fini
argument_list|()
expr_stmt|;
name|ztest_run_zdb
argument_list|(
name|ztest_opts
operator|.
name|zo_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ztest_opts
operator|.
name|zo_verbose
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|hasalt
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d runs of older ztest: %s\n"
argument_list|,
name|older
argument_list|,
name|ztest_opts
operator|.
name|zo_alt_ztest
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d runs of newer ztest: %s\n"
argument_list|,
name|newer
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d killed, %d completed, %.0f%% kill rate\n"
argument_list|,
name|kills
argument_list|,
name|iters
operator|-
name|kills
argument_list|,
operator|(
literal|100.0
operator|*
name|kills
operator|)
operator|/
name|MAX
argument_list|(
literal|1
argument_list|,
name|iters
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|umem_free
argument_list|(
name|cmd
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

