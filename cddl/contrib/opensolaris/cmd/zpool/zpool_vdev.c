begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Functions to convert between a list of vdevs and an nvlist representing the  * configuration.  Each entry in the list can be one of:  *  * 	Device vdevs  * 		disk=(path=..., devid=...)  * 		file=(path=...)  *  * 	Group vdevs  * 		raidz[1|2]=(...)  * 		mirror=(...)  *  * 	Hot spares  *  * While the underlying implementation supports it, group vdevs cannot contain  * other group vdevs.  All userland verification of devices is contained within  * this file.  If successful, the nvlist returned can be passed directly to the  * kernel; we've done as much verification as possible in userland.  *  * Hot spares are a special case, and passed down as an array of disk vdevs, at  * the same level as the root of the vdev tree.  *  * The only function exported by this file is 'make_root_vdev'.  The  * function performs several passes:  *  * 	1. Construct the vdev specification.  Performs syntax validation and  *         makes sure each device is valid.  * 	2. Check for devices in use.  Using libdiskmgt, makes sure that no  *         devices are also in use.  Some can be overridden using the 'force'  *         flag, others cannot.  * 	3. Check for replication errors if the 'force' flag is not specified.  *         validates that the replication level is consistent across the  *         entire pool.  * 	4. Call libzfs to label any whole disks with an EFI label.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<devid.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<libnvpair.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/mntent.h>
end_include

begin_include
include|#
directive|include
file|<libgeom.h>
end_include

begin_include
include|#
directive|include
file|"zpool_util.h"
end_include

begin_comment
comment|/*  * For any given vdev specification, we can have multiple errors.  The  * vdev_error() function keeps track of whether we have seen an error yet, and  * prints out a header if its the first error we've seen.  */
end_comment

begin_decl_stmt
name|boolean_t
name|error_seen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|is_force
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*PRINTFLIKE1*/
end_comment

begin_function
specifier|static
name|void
name|vdev_error
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|error_seen
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid vdev specification\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_force
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-f' to override "
literal|"the following errors:\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"the following errors "
literal|"must be manually repaired:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|error_seen
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check that a file is valid.  All we can do in this case is check that it's  * not in use by another pool, and not in use by swap.  */
end_comment

begin_function
specifier|static
name|int
name|check_file
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|boolean_t
name|isspare
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
name|pool_state_t
name|state
decl_stmt|;
name|boolean_t
name|inuse
decl_stmt|;
if|#
directive|if
literal|0
block|if (dm_inuse_swap(file,&err)) { 		if (err) 			libdiskmgt_error(err); 		else 			vdev_error(gettext("%s is currently used by swap. " 			    "Please see swap(1M).\n"), file); 		return (-1); 	}
endif|#
directive|endif
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zpool_in_use
argument_list|(
name|g_zfs
argument_list|,
name|fd
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|inuse
argument_list|)
operator|==
literal|0
operator|&&
name|inuse
condition|)
block|{
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|POOL_STATE_ACTIVE
case|:
name|desc
operator|=
name|gettext
argument_list|(
literal|"active"
argument_list|)
expr_stmt|;
break|break;
case|case
name|POOL_STATE_EXPORTED
case|:
name|desc
operator|=
name|gettext
argument_list|(
literal|"exported"
argument_list|)
expr_stmt|;
break|break;
case|case
name|POOL_STATE_POTENTIALLY_ACTIVE
case|:
name|desc
operator|=
name|gettext
argument_list|(
literal|"potentially active"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|desc
operator|=
name|gettext
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Allow hot spares to be shared between pools. 		 */
if|if
condition|(
name|state
operator|==
name|POOL_STATE_SPARE
operator|&&
name|isspare
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|state
operator|==
name|POOL_STATE_ACTIVE
operator|||
name|state
operator|==
name|POOL_STATE_SPARE
operator|||
operator|!
name|force
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|POOL_STATE_SPARE
case|:
name|vdev_error
argument_list|(
name|gettext
argument_list|(
literal|"%s is reserved as a hot "
literal|"spare for pool %s\n"
argument_list|)
argument_list|,
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|vdev_error
argument_list|(
name|gettext
argument_list|(
literal|"%s is part of %s pool "
literal|"'%s'\n"
argument_list|)
argument_list|,
name|file
argument_list|,
name|desc
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_provider
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|boolean_t
name|isspare
parameter_list|)
block|{
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
argument_list|(
name|_PATH_DEV
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|check_file
argument_list|(
name|path
argument_list|,
name|force
argument_list|,
name|isspare
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * By "whole disk" we mean an entire physical disk (something we can  * label, toggle the write cache on, etc.) as opposed to the full  * capacity of a pseudo-device such as lofi or did.  We act as if we  * are labeling the disk, which should be a pretty good test of whether  * it's a viable device or not.  Returns B_TRUE if it is and B_FALSE if  * it isn't.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|is_whole_disk
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|g_open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|g_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a leaf vdev.  Determine if this is a GEOM provider.  * Valid forms for a leaf vdev are:  *  * 	/dev/xxx	Complete path to a GEOM provider  * 	xxx		Shorthand for /dev/xxx  */
end_comment

begin_function
specifier|static
name|nvlist_t
modifier|*
name|make_leaf_vdev
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|is_log
parameter_list|)
block|{
name|char
name|ident
index|[
name|DISK_IDENT_SIZE
index|]
decl_stmt|,
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat64
name|statbuf
decl_stmt|;
name|nvlist_t
modifier|*
name|vdev
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|wholedisk
init|=
name|B_FALSE
decl_stmt|;
comment|/* 	 * Determine what type of vdev this is, and put the full path into 	 * 'path'.  We detect whether this is a device of file afterwards by 	 * checking the st_mode of the file. 	 */
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* 		 * Complete device or file path.  Exact type is determined by 		 * examining the file descriptor afterwards. 		 */
name|wholedisk
operator|=
name|is_whole_disk
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wholedisk
operator|&&
operator|(
name|stat64
argument_list|(
name|arg
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot open '%s': %s\n"
argument_list|)
argument_list|,
name|arg
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|path
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This may be a short path for a device, or it could be total 		 * gibberish.  Check to see if it's a known device in 		 * /dev/dsk/.  As part of this check, see if we've been given a 		 * an entire disk (minus the slice number). 		 */
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
argument_list|(
name|_PATH_DEV
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|strlcpy
argument_list|(
name|path
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|wholedisk
operator|=
name|is_whole_disk
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wholedisk
operator|&&
operator|(
name|stat64
argument_list|(
name|path
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 			 * If we got ENOENT, then the user gave us 			 * gibberish, so try to direct them with a 			 * reasonable error message.  Otherwise, 			 * regurgitate strerror() since it's the best we 			 * can do. 			 */
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot open '%s': no such "
literal|"GEOM provider\n"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"must be a full path or "
literal|"shorthand device name\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot open '%s': %s\n"
argument_list|)
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * Determine whether this is a device or a file. 	 */
if|if
condition|(
name|wholedisk
condition|)
block|{
name|type
operator|=
name|VDEV_TYPE_DISK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|type
operator|=
name|VDEV_TYPE_FILE
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot use '%s': must be a "
literal|"GEOM provider or regular file\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Finally, we have the complete device or file, and we know that it is 	 * acceptable to use.  Construct the nvlist to describe this vdev.  All 	 * vdevs have a 'path' element, and devices also have a 'devid' element. 	 */
name|verify
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|vdev
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_string
argument_list|(
name|vdev
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_string
argument_list|(
name|vdev
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|vdev
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
name|is_log
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_DISK
argument_list|)
operator|==
literal|0
condition|)
name|verify
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|vdev
argument_list|,
name|ZPOOL_CONFIG_WHOLE_DISK
argument_list|,
operator|(
name|uint64_t
operator|)
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * For a whole disk, defer getting its devid until after labeling it. 	 */
if|if
condition|(
literal|1
operator|||
operator|(
name|S_ISBLK
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|wholedisk
operator|)
condition|)
block|{
comment|/* 		 * Get the devid for the device. 		 */
name|int
name|fd
decl_stmt|;
name|ddi_devid_t
name|devid
decl_stmt|;
name|char
modifier|*
name|minor
init|=
name|NULL
decl_stmt|,
modifier|*
name|devid_str
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot open '%s': "
literal|"%s\n"
argument_list|)
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|vdev
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|devid_get
argument_list|(
name|fd
argument_list|,
operator|&
name|devid
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|devid_get_minor_name
argument_list|(
name|fd
argument_list|,
operator|&
name|minor
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|devid_str
operator|=
name|devid_str_encode
argument_list|(
name|devid
argument_list|,
name|minor
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|verify
argument_list|(
name|nvlist_add_string
argument_list|(
name|vdev
argument_list|,
name|ZPOOL_CONFIG_DEVID
argument_list|,
name|devid_str
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devid_str
operator|!=
name|NULL
condition|)
name|devid_str_free
argument_list|(
name|devid_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|minor
operator|!=
name|NULL
condition|)
name|devid_str_free
argument_list|(
name|minor
argument_list|)
expr_stmt|;
name|devid_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|vdev
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Go through and verify the replication level of the pool is consistent.  * Performs the following checks:  *  * 	For the new spec, verifies that devices in mirrors and raidz are the  * 	same size.  *  * 	If the current configuration already has inconsistent replication  * 	levels, ignore any other potential problems in the new spec.  *  * 	Otherwise, make sure that the current spec (if there is one) and the new  * 	spec have consistent replication levels.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|replication_level
block|{
name|char
modifier|*
name|zprl_type
decl_stmt|;
name|uint64_t
name|zprl_children
decl_stmt|;
name|uint64_t
name|zprl_parity
decl_stmt|;
block|}
name|replication_level_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ZPOOL_FUZZ
value|(16 * 1024 * 1024)
end_define

begin_comment
comment|/*  * Given a list of toplevel vdevs, return the current replication level.  If  * the config is inconsistent, then NULL is returned.  If 'fatal' is set, then  * an error message will be displayed for each self-inconsistent vdev.  */
end_comment

begin_function
specifier|static
name|replication_level_t
modifier|*
name|get_replication
parameter_list|(
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|boolean_t
name|fatal
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|top
decl_stmt|;
name|uint_t
name|t
decl_stmt|,
name|toplevels
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|replication_level_t
name|lastrep
decl_stmt|,
name|rep
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|boolean_t
name|dontreport
decl_stmt|;
name|ret
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|replication_level_t
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|toplevels
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|lastrep
operator|.
name|zprl_type
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|toplevels
condition|;
name|t
operator|++
control|)
block|{
name|uint64_t
name|is_log
init|=
name|B_FALSE
decl_stmt|;
name|nv
operator|=
name|top
index|[
name|t
index|]
expr_stmt|;
comment|/* 		 * For separate logs we ignore the top level vdev replication 		 * constraints. 		 */
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|is_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_log
condition|)
continue|continue;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * This is a 'file' or 'disk' vdev. 			 */
name|rep
operator|.
name|zprl_type
operator|=
name|type
expr_stmt|;
name|rep
operator|.
name|zprl_children
operator|=
literal|1
expr_stmt|;
name|rep
operator|.
name|zprl_parity
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|vdev_size
decl_stmt|;
comment|/* 			 * This is a mirror or RAID-Z vdev.  Go through and make 			 * sure the contents are all the same (files vs. disks), 			 * keeping track of the number of elements in the 			 * process. 			 * 			 * We also check that the size of each vdev (if it can 			 * be determined) is the same. 			 */
name|rep
operator|.
name|zprl_type
operator|=
name|type
expr_stmt|;
name|rep
operator|.
name|zprl_children
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NPARITY
argument_list|,
operator|&
name|rep
operator|.
name|zprl_parity
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rep
operator|.
name|zprl_parity
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rep
operator|.
name|zprl_parity
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * The 'dontreport' variable indicates that we've 			 * already reported an error for this spec, so don't 			 * bother doing it again. 			 */
name|type
operator|=
name|NULL
expr_stmt|;
name|dontreport
operator|=
literal|0
expr_stmt|;
name|vdev_size
operator|=
operator|-
literal|1ULL
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|nvlist_t
modifier|*
name|cnv
init|=
name|child
index|[
name|c
index|]
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|stat64
name|statbuf
decl_stmt|;
name|uint64_t
name|size
init|=
operator|-
literal|1ULL
decl_stmt|;
name|char
modifier|*
name|childtype
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|err
decl_stmt|;
name|rep
operator|.
name|zprl_children
operator|++
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|cnv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|childtype
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * If this is a replacing or spare vdev, then 				 * get the real first child of the vdev. 				 */
if|if
condition|(
name|strcmp
argument_list|(
name|childtype
argument_list|,
name|VDEV_TYPE_REPLACING
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|childtype
argument_list|,
name|VDEV_TYPE_SPARE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|rchild
decl_stmt|;
name|uint_t
name|rchildren
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|cnv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|rchild
argument_list|,
operator|&
name|rchildren
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rchildren
operator|==
literal|2
argument_list|)
expr_stmt|;
name|cnv
operator|=
name|rchild
index|[
literal|0
index|]
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|cnv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|childtype
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|cnv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * If we have a raidz/mirror that combines disks 				 * with files, report it as an error. 				 */
if|if
condition|(
operator|!
name|dontreport
operator|&&
name|type
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|type
argument_list|,
name|childtype
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fatal
condition|)
name|vdev_error
argument_list|(
name|gettext
argument_list|(
literal|"mismatched replication "
literal|"level: %s contains both "
literal|"files and devices\n"
argument_list|)
argument_list|,
name|rep
operator|.
name|zprl_type
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
name|dontreport
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 				 * According to stat(2), the value of 'st_size' 				 * is undefined for block devices and character 				 * devices.  But there is no effective way to 				 * determine the real size in userland. 				 * 				 * Instead, we'll take advantage of an 				 * implementation detail of spec_size().  If the 				 * device is currently open, then we (should) 				 * return a valid size. 				 * 				 * If we still don't get a valid size (indicated 				 * by a size of 0 or MAXOFFSET_T), then ignore 				 * this device altogether. 				 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|err
operator|=
name|fstat64
argument_list|(
name|fd
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|S_ISCHR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|DIOCGMEDIASIZE
argument_list|,
operator|&
name|statbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|stat64
argument_list|(
name|path
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|statbuf
operator|.
name|st_size
operator|==
literal|0
condition|)
continue|continue;
name|size
operator|=
name|statbuf
operator|.
name|st_size
expr_stmt|;
comment|/* 				 * Also make sure that devices and 				 * slices have a consistent size.  If 				 * they differ by a significant amount 				 * (~16MB) then report an error. 				 */
if|if
condition|(
operator|!
name|dontreport
operator|&&
operator|(
name|vdev_size
operator|!=
operator|-
literal|1ULL
operator|&&
operator|(
name|labs
argument_list|(
name|size
operator|-
name|vdev_size
argument_list|)
operator|>
name|ZPOOL_FUZZ
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fatal
condition|)
name|vdev_error
argument_list|(
name|gettext
argument_list|(
literal|"%s contains devices of "
literal|"different sizes\n"
argument_list|)
argument_list|,
name|rep
operator|.
name|zprl_type
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
name|dontreport
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|type
operator|=
name|childtype
expr_stmt|;
name|vdev_size
operator|=
name|size
expr_stmt|;
block|}
block|}
comment|/* 		 * At this point, we have the replication of the last toplevel 		 * vdev in 'rep'.  Compare it to 'lastrep' to see if its 		 * different. 		 */
if|if
condition|(
name|lastrep
operator|.
name|zprl_type
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|lastrep
operator|.
name|zprl_type
argument_list|,
name|rep
operator|.
name|zprl_type
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fatal
condition|)
name|vdev_error
argument_list|(
name|gettext
argument_list|(
literal|"mismatched replication level: "
literal|"both %s and %s vdevs are "
literal|"present\n"
argument_list|)
argument_list|,
name|lastrep
operator|.
name|zprl_type
argument_list|,
name|rep
operator|.
name|zprl_type
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|lastrep
operator|.
name|zprl_parity
operator|!=
name|rep
operator|.
name|zprl_parity
condition|)
block|{
if|if
condition|(
name|ret
condition|)
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fatal
condition|)
name|vdev_error
argument_list|(
name|gettext
argument_list|(
literal|"mismatched replication level: "
literal|"both %llu and %llu device parity "
literal|"%s vdevs are present\n"
argument_list|)
argument_list|,
name|lastrep
operator|.
name|zprl_parity
argument_list|,
name|rep
operator|.
name|zprl_parity
argument_list|,
name|rep
operator|.
name|zprl_type
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|lastrep
operator|.
name|zprl_children
operator|!=
name|rep
operator|.
name|zprl_children
condition|)
block|{
if|if
condition|(
name|ret
condition|)
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fatal
condition|)
name|vdev_error
argument_list|(
name|gettext
argument_list|(
literal|"mismatched replication level: "
literal|"both %llu-way and %llu-way %s "
literal|"vdevs are present\n"
argument_list|)
argument_list|,
name|lastrep
operator|.
name|zprl_children
argument_list|,
name|rep
operator|.
name|zprl_children
argument_list|,
name|rep
operator|.
name|zprl_type
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|lastrep
operator|=
name|rep
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
operator|*
name|ret
operator|=
name|rep
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the replication level of the vdev spec against the current pool.  Calls  * get_replication() to make sure the new spec is self-consistent.  If the pool  * has a consistent replication level, then we ignore any errors.  Otherwise,  * report any difference between the two.  */
end_comment

begin_function
specifier|static
name|int
name|check_replication
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|nvlist_t
modifier|*
name|newroot
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|children
decl_stmt|;
name|replication_level_t
modifier|*
name|current
init|=
name|NULL
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * If we have a current pool configuration, check to see if it's 	 * self-consistent.  If not, simply return success. 	 */
if|if
condition|(
name|config
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|current
operator|=
name|get_replication
argument_list|(
name|nvroot
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * for spares there may be no children, and therefore no 	 * replication level to check 	 */
if|if
condition|(
operator|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|newroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|children
operator|==
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
name|current
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If all we have is logs then there's no replication level to check. 	 */
if|if
condition|(
name|num_logs
argument_list|(
name|newroot
argument_list|)
operator|==
name|children
condition|)
block|{
name|free
argument_list|(
name|current
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Get the replication level of the new vdev spec, reporting any 	 * inconsistencies found. 	 */
if|if
condition|(
operator|(
name|new
operator|=
name|get_replication
argument_list|(
name|newroot
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|current
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Check to see if the new vdev spec matches the replication level of 	 * the current pool. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|zprl_type
argument_list|,
name|new
operator|->
name|zprl_type
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_error
argument_list|(
name|gettext
argument_list|(
literal|"mismatched replication level: pool uses %s "
literal|"and new vdev is %s\n"
argument_list|)
argument_list|,
name|current
operator|->
name|zprl_type
argument_list|,
name|new
operator|->
name|zprl_type
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|->
name|zprl_parity
operator|!=
name|new
operator|->
name|zprl_parity
condition|)
block|{
name|vdev_error
argument_list|(
name|gettext
argument_list|(
literal|"mismatched replication level: pool uses %llu "
literal|"device parity and new vdev uses %llu\n"
argument_list|)
argument_list|,
name|current
operator|->
name|zprl_parity
argument_list|,
name|new
operator|->
name|zprl_parity
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|->
name|zprl_children
operator|!=
name|new
operator|->
name|zprl_children
condition|)
block|{
name|vdev_error
argument_list|(
name|gettext
argument_list|(
literal|"mismatched replication level: pool uses %llu-way "
literal|"%s and new vdev uses %llu-way %s\n"
argument_list|)
argument_list|,
name|current
operator|->
name|zprl_children
argument_list|,
name|current
operator|->
name|zprl_type
argument_list|,
name|new
operator|->
name|zprl_children
argument_list|,
name|new
operator|->
name|zprl_type
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|current
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if the given path is a hot spare within the given configuration.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|is_spare
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|pool_state_t
name|state
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|label
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|,
name|spareguid
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|nspares
decl_stmt|;
name|boolean_t
name|inuse
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|zpool_in_use
argument_list|(
name|g_zfs
argument_list|,
name|fd
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|inuse
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|inuse
operator|||
name|state
operator|!=
name|POOL_STATE_SPARE
operator|||
name|zpool_read_label
argument_list|(
name|fd
argument_list|,
operator|&
name|label
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|spareguid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|spareguid
operator|==
name|guid
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Go through and find any devices that are in use.  We rely on libdiskmgt for  * the majority of this task.  */
end_comment

begin_function
specifier|static
name|int
name|check_in_use
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|isreplacing
parameter_list|,
name|int
name|isspare
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|uint64_t
name|wholedisk
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * As a generic check, we look to see if this is a replace of a 		 * hot spare within the same pool.  If so, we allow it 		 * regardless of what libdiskmgt or zpool_in_use() says. 		 */
if|if
condition|(
name|isreplacing
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_spare
argument_list|(
name|config
argument_list|,
name|buf
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_DISK
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|check_provider
argument_list|(
name|path
argument_list|,
name|force
argument_list|,
name|isspare
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_FILE
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|check_file
argument_list|(
name|path
argument_list|,
name|force
argument_list|,
name|isspare
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|ret
operator|=
name|check_in_use
argument_list|(
name|config
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|force
argument_list|,
name|isreplacing
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|ret
operator|=
name|check_in_use
argument_list|(
name|config
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|force
argument_list|,
name|isreplacing
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|ret
operator|=
name|check_in_use
argument_list|(
name|config
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
name|force
argument_list|,
name|isreplacing
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|is_grouping
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|mindev
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"raidz"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"raidz1"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mindev
operator|!=
name|NULL
condition|)
operator|*
name|mindev
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|VDEV_TYPE_RAIDZ
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"raidz2"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mindev
operator|!=
name|NULL
condition|)
operator|*
name|mindev
operator|=
literal|3
expr_stmt|;
return|return
operator|(
name|VDEV_TYPE_RAIDZ
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"mirror"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mindev
operator|!=
name|NULL
condition|)
operator|*
name|mindev
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|VDEV_TYPE_MIRROR
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"spare"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mindev
operator|!=
name|NULL
condition|)
operator|*
name|mindev
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|VDEV_TYPE_SPARE
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"log"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mindev
operator|!=
name|NULL
condition|)
operator|*
name|mindev
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|VDEV_TYPE_LOG
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"cache"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mindev
operator|!=
name|NULL
condition|)
operator|*
name|mindev
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|VDEV_TYPE_L2CACHE
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct a syntactically valid vdev specification,  * and ensure that all devices and files exist and can be opened.  * Note: we don't bother freeing anything in the error paths  * because the program is just going to exit anyway.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|construct_spec
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|,
modifier|*
name|nv
decl_stmt|,
modifier|*
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|spares
decl_stmt|,
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|int
name|t
decl_stmt|,
name|toplevels
decl_stmt|,
name|mindev
decl_stmt|,
name|nspares
decl_stmt|,
name|nlogs
decl_stmt|,
name|nl2cache
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
name|uint64_t
name|is_log
decl_stmt|;
name|boolean_t
name|seen_logs
decl_stmt|;
name|top
operator|=
name|NULL
expr_stmt|;
name|toplevels
operator|=
literal|0
expr_stmt|;
name|spares
operator|=
name|NULL
expr_stmt|;
name|l2cache
operator|=
name|NULL
expr_stmt|;
name|nspares
operator|=
literal|0
expr_stmt|;
name|nlogs
operator|=
literal|0
expr_stmt|;
name|nl2cache
operator|=
literal|0
expr_stmt|;
name|is_log
operator|=
name|B_FALSE
expr_stmt|;
name|seen_logs
operator|=
name|B_FALSE
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|nv
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * If it's a mirror or raidz, the subsequent arguments are 		 * its leaves -- until we encounter the next mirror or raidz. 		 */
if|if
condition|(
operator|(
name|type
operator|=
name|is_grouping
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|mindev
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
init|=
name|NULL
decl_stmt|;
name|int
name|c
decl_stmt|,
name|children
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_SPARE
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|spares
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid vdev "
literal|"specification: 'spare' can be "
literal|"specified only once\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|is_log
operator|=
name|B_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_LOG
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|seen_logs
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid vdev "
literal|"specification: 'log' can be "
literal|"specified only once\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|seen_logs
operator|=
name|B_TRUE
expr_stmt|;
name|is_log
operator|=
name|B_TRUE
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* 				 * A log is not a real grouping device. 				 * We just set is_log and continue. 				 */
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_L2CACHE
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|l2cache
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid vdev "
literal|"specification: 'cache' can be "
literal|"specified only once\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|is_log
operator|=
name|B_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|is_log
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_MIRROR
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid vdev "
literal|"specification: unsupported 'log' "
literal|"device: %s\n"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|nlogs
operator|++
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|is_grouping
argument_list|(
name|argv
index|[
name|c
index|]
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
name|children
operator|++
expr_stmt|;
name|child
operator|=
name|realloc
argument_list|(
name|child
argument_list|,
name|children
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
name|zpool_no_memory
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|nv
operator|=
name|make_leaf_vdev
argument_list|(
name|argv
index|[
name|c
index|]
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|child
index|[
name|children
operator|-
literal|1
index|]
operator|=
name|nv
expr_stmt|;
block|}
if|if
condition|(
name|children
operator|<
name|mindev
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid vdev "
literal|"specification: %s requires at least %d "
literal|"devices\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|mindev
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|argc
operator|-=
name|c
expr_stmt|;
name|argv
operator|+=
name|c
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_SPARE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|spares
operator|=
name|child
expr_stmt|;
name|nspares
operator|=
name|children
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_L2CACHE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|l2cache
operator|=
name|child
expr_stmt|;
name|nl2cache
operator|=
name|children
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|verify
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
name|is_log
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NPARITY
argument_list|,
name|mindev
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|verify
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|child
argument_list|,
name|children
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * We have a device.  Pass off to make_leaf_vdev() to 			 * construct the appropriate nvlist describing the vdev. 			 */
if|if
condition|(
operator|(
name|nv
operator|=
name|make_leaf_vdev
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|is_log
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|is_log
condition|)
name|nlogs
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|toplevels
operator|++
expr_stmt|;
name|top
operator|=
name|realloc
argument_list|(
name|top
argument_list|,
name|toplevels
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
name|zpool_no_memory
argument_list|()
expr_stmt|;
name|top
index|[
name|toplevels
operator|-
literal|1
index|]
operator|=
name|nv
expr_stmt|;
block|}
if|if
condition|(
name|toplevels
operator|==
literal|0
operator|&&
name|nspares
operator|==
literal|0
operator|&&
name|nl2cache
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid vdev "
literal|"specification: at least one toplevel vdev must be "
literal|"specified\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|seen_logs
operator|&&
name|nlogs
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid vdev specification: "
literal|"log requires at least 1 device\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Finally, create nvroot and add all top-level vdevs to it. 	 */
name|verify
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvroot
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_string
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_ROOT
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|top
argument_list|,
name|toplevels
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nspares
operator|!=
literal|0
condition|)
name|verify
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl2cache
operator|!=
literal|0
condition|)
name|verify
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|l2cache
argument_list|,
name|nl2cache
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|toplevels
condition|;
name|t
operator|++
control|)
name|nvlist_free
argument_list|(
name|top
index|[
name|t
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nspares
condition|;
name|t
operator|++
control|)
name|nvlist_free
argument_list|(
name|spares
index|[
name|t
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nl2cache
condition|;
name|t
operator|++
control|)
name|nvlist_free
argument_list|(
name|l2cache
index|[
name|t
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spares
condition|)
name|free
argument_list|(
name|spares
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2cache
condition|)
name|free
argument_list|(
name|l2cache
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvroot
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get and validate the contents of the given vdev specification.  This ensures  * that the nvlist returned is well-formed, that all the devices exist, and that  * they are not currently in use by any other known consumer.  The 'poolconfig'  * parameter is the current configuration of the pool when adding devices  * existing pool, and is used to perform additional checks, such as changing the  * replication level of the pool.  It can be 'NULL' to indicate that this is a  * new pool.  The 'force' flag controls whether devices should be forcefully  * added, even if they appear in use.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|make_root_vdev
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|check_rep
parameter_list|,
name|boolean_t
name|isreplacing
parameter_list|,
name|boolean_t
name|dryrun
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|newroot
decl_stmt|;
name|nvlist_t
modifier|*
name|poolconfig
init|=
name|NULL
decl_stmt|;
name|is_force
operator|=
name|force
expr_stmt|;
comment|/* 	 * Construct the vdev specification.  If this is successful, we know 	 * that we have a valid specification, and that all devices can be 	 * opened. 	 */
if|if
condition|(
operator|(
name|newroot
operator|=
name|construct_spec
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|zhp
operator|&&
operator|(
operator|(
name|poolconfig
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Validate each device to make sure that its not shared with another 	 * subsystem.  We do this even if 'force' is set, because there are some 	 * uses (such as a dedicated dump device) that even '-f' cannot 	 * override. 	 */
if|if
condition|(
name|check_in_use
argument_list|(
name|poolconfig
argument_list|,
name|newroot
argument_list|,
name|force
argument_list|,
name|isreplacing
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|newroot
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Check the replication level of the given vdevs and report any errors 	 * found.  We include the existing pool spec, if any, as we need to 	 * catch changes against the existing replication level. 	 */
if|if
condition|(
name|check_rep
operator|&&
name|check_replication
argument_list|(
name|poolconfig
argument_list|,
name|newroot
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|newroot
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|newroot
operator|)
return|;
block|}
end_function

end_unit

