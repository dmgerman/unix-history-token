begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<libuutil.h>
end_include

begin_include
include|#
directive|include
file|<libnvpair.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<zone.h>
end_include

begin_include
include|#
directive|include
file|<sys/mntent.h>
end_include

begin_include
include|#
directive|include
file|<sys/mnttab.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|<libuutil.h>
end_include

begin_include
include|#
directive|include
file|"zfs_iter.h"
end_include

begin_include
include|#
directive|include
file|"zfs_util.h"
end_include

begin_decl_stmt
name|libzfs_handle_t
modifier|*
name|g_zfs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|mnttab_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|history_str
index|[
name|HIS_MAX_RECORD_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|zfs_do_clone
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_create
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_destroy
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_get
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_inherit
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_list
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_mount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_rename
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_rollback
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_set
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_upgrade
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_snapshot
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_unmount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_share
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_unshare
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_send
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_receive
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_promote
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_allow
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_unallow
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_jail
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_unjail
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Enable a reasonable set of defaults for libumem debugging on DEBUG builds.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|const
name|char
modifier|*
name|_umem_debug_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|"default,verbose"
operator|)
return|;
comment|/* $UMEM_DEBUG setting */
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|_umem_logging_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|"fail,contents"
operator|)
return|;
comment|/* $UMEM_LOGGING setting */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
enum|enum
block|{
name|HELP_CLONE
block|,
name|HELP_CREATE
block|,
name|HELP_DESTROY
block|,
name|HELP_GET
block|,
name|HELP_INHERIT
block|,
name|HELP_UPGRADE
block|,
name|HELP_JAIL
block|,
name|HELP_UNJAIL
block|,
name|HELP_LIST
block|,
name|HELP_MOUNT
block|,
name|HELP_PROMOTE
block|,
name|HELP_RECEIVE
block|,
name|HELP_RENAME
block|,
name|HELP_ROLLBACK
block|,
name|HELP_SEND
block|,
name|HELP_SET
block|,
name|HELP_SHARE
block|,
name|HELP_SNAPSHOT
block|,
name|HELP_UNMOUNT
block|,
name|HELP_UNSHARE
block|,
name|HELP_ALLOW
block|,
name|HELP_UNALLOW
block|}
name|zfs_help_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|zfs_command
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
name|zfs_help_t
name|usage
decl_stmt|;
block|}
name|zfs_command_t
typedef|;
end_typedef

begin_comment
comment|/*  * Master command table.  Each ZFS command has a name, associated function, and  * usage message.  The usage messages need to be internationalized, so we have  * to have a function to return the usage message based on a command index.  *  * These commands are organized according to how they are displayed in the usage  * message.  An empty command (one with a NULL name) indicates an empty line in  * the generic usage message.  */
end_comment

begin_decl_stmt
specifier|static
name|zfs_command_t
name|command_table
index|[]
init|=
block|{
block|{
literal|"create"
block|,
name|zfs_do_create
block|,
name|HELP_CREATE
block|}
block|,
block|{
literal|"destroy"
block|,
name|zfs_do_destroy
block|,
name|HELP_DESTROY
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"snapshot"
block|,
name|zfs_do_snapshot
block|,
name|HELP_SNAPSHOT
block|}
block|,
block|{
literal|"rollback"
block|,
name|zfs_do_rollback
block|,
name|HELP_ROLLBACK
block|}
block|,
block|{
literal|"clone"
block|,
name|zfs_do_clone
block|,
name|HELP_CLONE
block|}
block|,
block|{
literal|"promote"
block|,
name|zfs_do_promote
block|,
name|HELP_PROMOTE
block|}
block|,
block|{
literal|"rename"
block|,
name|zfs_do_rename
block|,
name|HELP_RENAME
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"list"
block|,
name|zfs_do_list
block|,
name|HELP_LIST
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"set"
block|,
name|zfs_do_set
block|,
name|HELP_SET
block|}
block|,
block|{
literal|"get"
block|,
name|zfs_do_get
block|,
name|HELP_GET
block|}
block|,
block|{
literal|"inherit"
block|,
name|zfs_do_inherit
block|,
name|HELP_INHERIT
block|}
block|,
block|{
literal|"upgrade"
block|,
name|zfs_do_upgrade
block|,
name|HELP_UPGRADE
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"mount"
block|,
name|zfs_do_mount
block|,
name|HELP_MOUNT
block|}
block|,
block|{
literal|"unmount"
block|,
name|zfs_do_unmount
block|,
name|HELP_UNMOUNT
block|}
block|,
block|{
literal|"share"
block|,
name|zfs_do_share
block|,
name|HELP_SHARE
block|}
block|,
block|{
literal|"unshare"
block|,
name|zfs_do_unshare
block|,
name|HELP_UNSHARE
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"send"
block|,
name|zfs_do_send
block|,
name|HELP_SEND
block|}
block|,
block|{
literal|"receive"
block|,
name|zfs_do_receive
block|,
name|HELP_RECEIVE
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"allow"
block|,
name|zfs_do_allow
block|,
name|HELP_ALLOW
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"unallow"
block|,
name|zfs_do_unallow
block|,
name|HELP_UNALLOW
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"jail"
block|,
name|zfs_do_jail
block|,
name|HELP_JAIL
block|}
block|,
block|{
literal|"unjail"
block|,
name|zfs_do_unjail
block|,
name|HELP_UNJAIL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NCOMMAND
value|(sizeof (command_table) / sizeof (command_table[0]))
end_define

begin_decl_stmt
name|zfs_command_t
modifier|*
name|current_command
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_usage
parameter_list|(
name|zfs_help_t
name|idx
parameter_list|)
block|{
switch|switch
condition|(
name|idx
condition|)
block|{
case|case
name|HELP_CLONE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tclone [-p] [-o property=value] ... "
literal|"<snapshot><filesystem|volume>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_CREATE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tcreate [-p] [-o property=value] ... "
literal|"<filesystem>\n"
literal|"\tcreate [-ps] [-b blocksize] [-o property=value] ... "
literal|"-V<size><volume>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_DESTROY
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tdestroy [-rRf] "
literal|"<filesystem|volume|snapshot>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_GET
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tget [-rHp] [-o field[,...]] "
literal|"[-s source[,...]]\n"
literal|"\t<\"all\" | property[,...]> "
literal|"[filesystem|volume|snapshot] ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_INHERIT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tinherit [-r]<property> "
literal|"<filesystem|volume|snapshot> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_UPGRADE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tupgrade [-v]\n"
literal|"\tupgrade [-r] [-V version]<-a | filesystem ...>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_JAIL
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tjail<jailid><filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_UNJAIL
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tunjail<jailid><filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_LIST
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tlist [-rH] [-o property[,...]] "
literal|"[-t type[,...]] [-s property] ...\n"
literal|"\t    [-S property] ... "
literal|"[filesystem|volume|snapshot] ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_MOUNT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tmount\n"
literal|"\tmount [-vO] [-o opts]<-a | filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_PROMOTE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tpromote<clone-filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_RECEIVE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\treceive [-vnF]<filesystem|volume|"
literal|"snapshot>\n"
literal|"\treceive [-vnF] -d<filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_RENAME
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\trename<filesystem|volume|snapshot> "
literal|"<filesystem|volume|snapshot>\n"
literal|"\trename -p<filesystem|volume><filesystem|volume>\n"
literal|"\trename -r<snapshot><snapshot>"
argument_list|)
operator|)
return|;
case|case
name|HELP_ROLLBACK
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\trollback [-rRf]<snapshot>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SEND
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tsend [-R] [-[iI] snapshot]<snapshot>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SET
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tset<property=value> "
literal|"<filesystem|volume|snapshot> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SHARE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tshare<-a | filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SNAPSHOT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tsnapshot [-r] [-o property=value] ... "
literal|"<filesystem@snapname|volume@snapname>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_UNMOUNT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tunmount [-f] "
literal|"<-a | filesystem|mountpoint>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_UNSHARE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tunshare [-f] "
literal|"<-a | filesystem|mountpoint>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_ALLOW
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tallow [-ldug] "
literal|"<\"everyone\"|user|group>[,...]<perm|@setname>[,...]\n"
literal|"\t<filesystem|volume>\n"
literal|"\tallow [-ld] -e<perm|@setname>[,...] "
literal|"<filesystem|volume>\n"
literal|"\tallow -c<perm|@setname>[,...]<filesystem|volume>\n"
literal|"\tallow -s @setname<perm|@setname>[,...] "
literal|"<filesystem|volume>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_UNALLOW
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tunallow [-rldug] "
literal|"<\"everyone\"|user|group>[,...]\n"
literal|"\t    [<perm|@setname>[,...]]<filesystem|volume>\n"
literal|"\tunallow [-rld] -e [<perm|@setname>[,...]] "
literal|"<filesystem|volume>\n"
literal|"\tunallow [-r] -c [<perm|@setname>[,...]] "
literal|"<filesystem|volume>\n"
literal|"\tunallow [-r] -s @setname [<perm|@setname>[,...]] "
literal|"<filesystem|volume>\n"
argument_list|)
operator|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Utility function to guarantee malloc() success.  */
end_comment

begin_function
name|void
modifier|*
name|safe_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"internal error: out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback routine that will print out information for each of  * the properties.  */
end_comment

begin_function
specifier|static
name|int
name|usage_prop_cb
parameter_list|(
name|int
name|prop
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|cb
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%-15s "
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" NO    "
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"YES    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_prop_inheritable
argument_list|(
name|prop
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  YES   "
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"   NO   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_prop_values
argument_list|(
name|prop
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"-\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_prop_values
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZPROP_CONT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Display usage message.  If we're inside a command, display only the usage for  * that command.  Otherwise, iterate over the entire command table and display  * a complete usage message.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|boolean_t
name|requested
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|boolean_t
name|show_properties
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|show_permissions
init|=
name|B_FALSE
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|requested
condition|?
name|stdout
else|:
name|stderr
decl_stmt|;
if|if
condition|(
name|current_command
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"usage: zfs command args ...\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"where 'command' is one of the following:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOMMAND
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|command_table
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|get_usage
argument_list|(
name|command_table
index|[
name|i
index|]
operator|.
name|usage
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nEach dataset is of the form: "
literal|"pool/[dataset/]*dataset[@name]\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"usage:\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|get_usage
argument_list|(
name|current_command
operator|->
name|usage
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_command
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"inherit"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|show_properties
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|current_command
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"allow"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"unallow"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|show_permissions
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|show_properties
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nThe following properties are supported:\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\t%-14s %s  %s   %s\n\n"
argument_list|,
literal|"PROPERTY"
argument_list|,
literal|"EDIT"
argument_list|,
literal|"INHERIT"
argument_list|,
literal|"VALUES"
argument_list|)
expr_stmt|;
comment|/* Iterate over all properties */
operator|(
name|void
operator|)
name|zprop_iter
argument_list|(
name|usage_prop_cb
argument_list|,
name|fp
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nSizes are specified in bytes "
literal|"with standard units such as K, M, G, etc.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nUser-defined properties can "
literal|"be specified by using a name containing a colon (:).\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|show_permissions
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nThe following permissions are supported:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_deleg_permissions
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * TRANSLATION NOTE: 		 * "zfs set|get" must not be localised this is the 		 * command name and arguments. 		 */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nFor the property list, run: zfs set|get\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nFor the delegated permission list, run:"
literal|" zfs allow|unallow\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * See comments at end of main(). 	 */
if|if
condition|(
name|getenv
argument_list|(
literal|"ZFS_ABORT"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dumping core by request\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
name|requested
condition|?
literal|0
else|:
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|parseprop
parameter_list|(
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|char
modifier|*
name|propname
init|=
name|optarg
decl_stmt|;
name|char
modifier|*
name|propval
decl_stmt|,
modifier|*
name|strval
decl_stmt|;
if|if
condition|(
operator|(
name|propval
operator|=
name|strchr
argument_list|(
name|propname
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing "
literal|"'=' for -o option\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|propval
operator|=
literal|'\0'
expr_stmt|;
name|propval
operator|++
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|propname
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"property '%s' "
literal|"specified multiple times\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|props
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal "
literal|"error: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs clone [-p] [-o prop=value] ...<snap><fs | vol>  *  * Given an existing dataset, create a writable copy whose initial contents  * are the same as the source.  The newly created dataset maintains a  * dependency on the original; the original cannot be destroyed so long as  * the clone exists.  *  * The '-p' flag creates all the non-existing ancestors of the target first.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_clone
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|parents
init|=
name|B_FALSE
decl_stmt|;
name|nvlist_t
modifier|*
name|props
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: "
literal|"out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"o:p"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'o'
case|:
if|if
condition|(
name|parseprop
argument_list|(
name|props
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
literal|'p'
case|:
name|parents
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing source dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing target dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
comment|/* open the source dataset */
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|parents
operator|&&
name|zfs_name_valid
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
condition|)
block|{
comment|/* 		 * Now create the ancestors of the target dataset.  If the 		 * target already exists and '-p' option was used we should not 		 * complain. 		 */
if|if
condition|(
name|zfs_dataset_exists
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zfs_create_ancestors
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* pass to libzfs */
name|ret
operator|=
name|zfs_clone
argument_list|(
name|zhp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|props
argument_list|)
expr_stmt|;
comment|/* create the mountpoint if necessary */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|zfs_handle_t
modifier|*
name|clone
decl_stmt|;
name|clone
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_mount
argument_list|(
name|clone
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|zfs_share
argument_list|(
name|clone
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|clone
argument_list|)
expr_stmt|;
block|}
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|!
name|ret
operator|)
return|;
name|usage
label|:
if|if
condition|(
name|zhp
condition|)
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs create [-p] [-o prop=value] ... fs  * zfs create [-ps] [-b blocksize] [-o prop=value] ... -V vol size  *  * Create a new dataset.  This command can be used to create filesystems  * and volumes.  Snapshot creation is handled by 'zfs snapshot'.  * For volumes, the user must specify a size to be used.  *  * The '-s' flag applies only to volumes, and indicates that we should not try  * to set the reservation for this volume.  By default we set a reservation  * equal to the size for any volume.  For pools with SPA_VERSION>=  * SPA_VERSION_REFRESERVATION, we set a refreservation instead.  *  * The '-p' flag creates all the non-existing ancestors of the target first.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_create
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_type_t
name|type
init|=
name|ZFS_TYPE_FILESYSTEM
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|volsize
decl_stmt|;
name|int
name|c
decl_stmt|;
name|boolean_t
name|noreserve
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|bflag
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|parents
init|=
name|B_FALSE
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|nvlist_t
modifier|*
name|props
decl_stmt|;
name|uint64_t
name|intval
decl_stmt|;
name|int
name|canmount
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: "
literal|"out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":V:b:so:p"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'V'
case|:
name|type
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
if|if
condition|(
name|zfs_nicestrtonum
argument_list|(
name|g_zfs
argument_list|,
name|optarg
argument_list|,
operator|&
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"bad volume "
literal|"size '%s': %s\n"
argument_list|)
argument_list|,
name|optarg
argument_list|,
name|libzfs_error_description
argument_list|(
name|g_zfs
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|,
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal "
literal|"error: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|volsize
operator|=
name|intval
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|parents
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|bflag
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|zfs_nicestrtonum
argument_list|(
name|g_zfs
argument_list|,
name|optarg
argument_list|,
operator|&
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"bad volume "
literal|"block size '%s': %s\n"
argument_list|)
argument_list|,
name|optarg
argument_list|,
name|libzfs_error_description
argument_list|(
name|g_zfs
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal "
literal|"error: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|parseprop
argument_list|(
name|props
argument_list|)
condition|)
goto|goto
name|error
goto|;
break|break;
case|case
literal|'s'
case|:
name|noreserve
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing size "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|bflag
operator|||
name|noreserve
operator|)
operator|&&
name|type
operator|!=
name|ZFS_TYPE_VOLUME
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"'-s' and '-b' can only be "
literal|"used when creating a volume\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing %s argument\n"
argument_list|)
argument_list|,
name|zfs_type_to_name
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
operator|&&
operator|!
name|noreserve
condition|)
block|{
name|zpool_handle_t
modifier|*
name|zpool_handle
decl_stmt|;
name|uint64_t
name|spa_version
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|zfs_prop_t
name|resv_prop
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
if|if
condition|(
name|p
operator|=
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|zpool_handle
operator|=
name|zpool_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|zpool_handle
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|spa_version
operator|=
name|zpool_get_prop_int
argument_list|(
name|zpool_handle
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zpool_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_version
operator|>=
name|SPA_VERSION_REFRESERVATION
condition|)
name|resv_prop
operator|=
name|ZFS_PROP_REFRESERVATION
expr_stmt|;
else|else
name|resv_prop
operator|=
name|ZFS_PROP_RESERVATION
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|resv_prop
argument_list|)
argument_list|,
operator|&
name|strval
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|resv_prop
argument_list|)
argument_list|,
name|volsize
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal "
literal|"error: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|parents
operator|&&
name|zfs_name_valid
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|type
argument_list|)
condition|)
block|{
comment|/* 		 * Now create the ancestors of target dataset.  If the target 		 * already exists and '-p' option was used we should not 		 * complain. 		 */
if|if
condition|(
name|zfs_dataset_exists
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|zfs_create_ancestors
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
comment|/* pass to libzfs */
if|if
condition|(
name|zfs_create
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|type
argument_list|,
name|props
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
comment|/* 	 * if the user doesn't want the dataset automatically mounted, 	 * then skip the mount/share step 	 */
name|canmount
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CANMOUNT
argument_list|)
expr_stmt|;
comment|/* 	 * Mount and/or share the new filesystem as appropriate.  We provide a 	 * verbose error message to let the user know that their filesystem was 	 * in fact created, even if we failed to mount or share it. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|canmount
operator|==
name|ZFS_CANMOUNT_ON
condition|)
block|{
if|if
condition|(
name|zfs_mount
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"filesystem "
literal|"successfully created, but not mounted\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_share
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"filesystem "
literal|"successfully created, but not shared\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|error
label|:
if|if
condition|(
name|zhp
condition|)
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
name|badusage
label|:
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs destroy [-rf]<fs, snap, vol>  *  * 	-r	Recursively destroy all children  * 	-R	Recursively destroy all dependents, including clones  * 	-f	Force unmounting of any dependents  *  * Destroys the given dataset.  By default, it will unmount any filesystems,  * and refuse to destroy a dataset that has any dependents.  A dependent can  * either be a child, or a clone of a child.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|destroy_cbdata
block|{
name|boolean_t
name|cb_first
decl_stmt|;
name|int
name|cb_force
decl_stmt|;
name|int
name|cb_recurse
decl_stmt|;
name|int
name|cb_error
decl_stmt|;
name|int
name|cb_needforce
decl_stmt|;
name|int
name|cb_doclones
decl_stmt|;
name|boolean_t
name|cb_closezhp
decl_stmt|;
name|zfs_handle_t
modifier|*
name|cb_target
decl_stmt|;
name|char
modifier|*
name|cb_snapname
decl_stmt|;
block|}
name|destroy_cbdata_t
typedef|;
end_typedef

begin_comment
comment|/*  * Check for any dependents based on the '-r' or '-R' flags.  */
end_comment

begin_function
specifier|static
name|int
name|destroy_check_dependent
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|destroy_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|tname
init|=
name|zfs_get_name
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|tname
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|tname
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|name
index|[
name|strlen
argument_list|(
name|tname
argument_list|)
index|]
operator|==
literal|'/'
operator|||
name|name
index|[
name|strlen
argument_list|(
name|tname
argument_list|)
index|]
operator|==
literal|'@'
operator|)
condition|)
block|{
comment|/* 		 * This is a direct descendant, not a clone somewhere else in 		 * the hierarchy. 		 */
if|if
condition|(
name|cbp
operator|->
name|cb_recurse
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot destroy '%s': "
literal|"%s has children\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
argument_list|,
name|zfs_type_to_name
argument_list|(
name|zfs_get_type
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-r' to destroy "
literal|"the following datasets:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is a clone.  We only want to report this if the '-r' 		 * wasn't specified, or the target is a snapshot. 		 */
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_recurse
operator|&&
name|zfs_get_type
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
operator|!=
name|ZFS_TYPE_SNAPSHOT
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot destroy '%s': "
literal|"%s has dependent clones\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
argument_list|,
name|zfs_type_to_name
argument_list|(
name|zfs_get_type
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-R' to destroy "
literal|"the following datasets:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|destroy_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|destroy_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
comment|/* 	 * Ignore pools (which we've already flagged as an error before getting 	 * here. 	 */
if|if
condition|(
name|strchr
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
operator|&&
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Bail out on the first error. 	 */
if|if
condition|(
name|zfs_unmount
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
name|cbp
operator|->
name|cb_force
condition|?
name|MS_FORCE
else|:
literal|0
argument_list|)
operator|!=
literal|0
operator|||
name|zfs_destroy
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|destroy_snap_clones
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|destroy_cbdata_t
modifier|*
name|cbp
init|=
name|arg
decl_stmt|;
name|char
name|thissnap
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|zfs_handle_t
modifier|*
name|szhp
decl_stmt|;
name|boolean_t
name|closezhp
init|=
name|cbp
operator|->
name|cb_closezhp
decl_stmt|;
name|int
name|rv
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|thissnap
argument_list|,
sizeof|sizeof
argument_list|(
name|thissnap
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_snapname
argument_list|)
expr_stmt|;
name|libzfs_print_on_error
argument_list|(
name|g_zfs
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|szhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|thissnap
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
name|libzfs_print_on_error
argument_list|(
name|g_zfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|szhp
condition|)
block|{
comment|/* 		 * Destroy any clones of this snapshot 		 */
if|if
condition|(
name|zfs_iter_dependents
argument_list|(
name|szhp
argument_list|,
name|B_FALSE
argument_list|,
name|destroy_callback
argument_list|,
name|cbp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|szhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|closezhp
condition|)
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zfs_close
argument_list|(
name|szhp
argument_list|)
expr_stmt|;
block|}
name|cbp
operator|->
name|cb_closezhp
operator|=
name|B_TRUE
expr_stmt|;
name|rv
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|destroy_snap_clones
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|closezhp
condition|)
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_destroy
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|destroy_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|c
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"frR"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|cb
operator|.
name|cb_force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|cb
operator|.
name|cb_recurse
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|cb
operator|.
name|cb_recurse
operator|=
literal|1
expr_stmt|;
name|cb
operator|.
name|cb_doclones
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing path argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we are doing recursive destroy of a snapshot, then the 	 * named snapshot may not exist.  Go straight to libzfs. 	 */
if|if
condition|(
name|cb
operator|.
name|cb_recurse
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'@'
argument_list|)
operator|)
condition|)
block|{
name|int
name|ret
decl_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_doclones
condition|)
block|{
name|cb
operator|.
name|cb_snapname
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|destroy_snap_clones
argument_list|(
name|zhp
argument_list|,
operator|&
name|cb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|ret
operator|=
name|zfs_destroy_snaps
argument_list|(
name|zhp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"no snapshots destroyed\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
block|}
comment|/* Open the given dataset */
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cb
operator|.
name|cb_target
operator|=
name|zhp
expr_stmt|;
comment|/* 	 * Perform an explicit check for pools before going any further. 	 */
if|if
condition|(
operator|!
name|cb
operator|.
name|cb_recurse
operator|&&
name|strchr
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
operator|&&
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot destroy '%s': "
literal|"operation does not apply to pools\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use 'zfs destroy -r "
literal|"%s' to destroy all datasets in the pool\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use 'zpool destroy %s' "
literal|"to destroy the pool itself\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Check for any dependents and/or clones. 	 */
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|.
name|cb_doclones
operator|&&
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_TRUE
argument_list|,
name|destroy_check_dependent
argument_list|,
operator|&
name|cb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cb
operator|.
name|cb_error
operator|||
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_FALSE
argument_list|,
name|destroy_callback
argument_list|,
operator|&
name|cb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Do the real thing.  The callback will close the handle regardless of 	 * whether it succeeds or not. 	 */
if|if
condition|(
name|destroy_callback
argument_list|(
name|zhp
argument_list|,
operator|&
name|cb
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs get [-rHp] [-o field[,field]...] [-s source[,source]...]  *< all | property[,property]...>< fs | snap | vol> ...  *  *	-r	recurse over any child datasets  *	-H	scripted mode.  Headers are stripped, and fields are separated  *		by tabs instead of spaces.  *	-o	Set of fields to display.  One of "name,property,value,source".  *		Default is all four.  *	-s	Set of sources to allow.  One of  *		"local,default,inherited,temporary,none".  Default is all  *		five.  *	-p	Display values in parsable (literal) format.  *  *  Prints properties for the given datasets.  The user can control which  *  columns to display as well as which property types to allow.  */
end_comment

begin_comment
comment|/*  * Invoked to display the properties for a single dataset.  */
end_comment

begin_function
specifier|static
name|int
name|get_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|char
name|buf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|zprop_source_t
name|sourcetype
decl_stmt|;
name|char
name|source
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|zprop_get_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
name|userprop
init|=
name|zfs_get_user_props
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
name|zprop_list_t
modifier|*
name|pl
init|=
name|cbp
operator|->
name|cb_proplist
decl_stmt|;
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
name|char
modifier|*
name|sourceval
decl_stmt|;
for|for
control|(
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
comment|/* 		 * Skip the special fake placeholder.  This will also skip over 		 * the name property when 'all' is specified. 		 */
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|==
name|ZFS_PROP_NAME
operator|&&
name|pl
operator|==
name|cbp
operator|->
name|cb_proplist
condition|)
continue|continue;
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|!=
name|ZPROP_INVAL
condition|)
block|{
if|if
condition|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_prop
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|sourcetype
argument_list|,
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|source
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_literal
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|pl_all
condition|)
continue|continue;
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"No such property '%s'\n"
argument_list|)
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sourcetype
operator|=
name|ZPROP_SRC_NONE
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zprop_print_one_property
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
argument_list|,
name|buf
argument_list|,
name|sourcetype
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|userprop
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
operator|&
name|propval
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|pl_all
condition|)
continue|continue;
name|sourcetype
operator|=
name|ZPROP_SRC_NONE
expr_stmt|;
name|strval
operator|=
literal|"-"
expr_stmt|;
block|}
else|else
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_SOURCE
argument_list|,
operator|&
name|sourceval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sourceval
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sourcetype
operator|=
name|ZPROP_SRC_LOCAL
expr_stmt|;
block|}
else|else
block|{
name|sourcetype
operator|=
name|ZPROP_SRC_INHERITED
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|source
argument_list|,
name|sourceval
argument_list|,
sizeof|sizeof
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|zprop_print_one_property
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
name|strval
argument_list|,
name|sourcetype
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_get
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zprop_get_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|fields
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|zprop_list_t
name|fake_name
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* 	 * Set up default columns and sources. 	 */
name|cb
operator|.
name|cb_sources
operator|=
name|ZPROP_SRC_ALL
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|0
index|]
operator|=
name|GET_COL_NAME
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|1
index|]
operator|=
name|GET_COL_PROPERTY
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|2
index|]
operator|=
name|GET_COL_VALUE
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|3
index|]
operator|=
name|GET_COL_SOURCE
expr_stmt|;
name|cb
operator|.
name|cb_type
operator|=
name|ZFS_TYPE_DATASET
expr_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":o:s:rHp"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'p'
case|:
name|cb
operator|.
name|cb_literal
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|flags
operator||=
name|ZFS_ITER_RECURSE
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|cb
operator|.
name|cb_scripted
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* 			 * Process the set of columns to display.  We zero out 			 * the structure to give us a blank slate. 			 */
name|bzero
argument_list|(
operator|&
name|cb
operator|.
name|cb_columns
argument_list|,
sizeof|sizeof
argument_list|(
name|cb
operator|.
name|cb_columns
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
block|{
specifier|static
name|char
modifier|*
name|col_subopts
index|[]
init|=
block|{
literal|"name"
block|,
literal|"property"
block|,
literal|"value"
block|,
literal|"source"
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too "
literal|"many fields given to -o "
literal|"option\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|optarg
argument_list|,
name|col_subopts
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_NAME
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_PROPERTY
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_VALUE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_SOURCE
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid column name "
literal|"'%s'\n"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
name|cb
operator|.
name|cb_sources
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
block|{
specifier|static
name|char
modifier|*
name|source_subopts
index|[]
init|=
block|{
literal|"local"
block|,
literal|"default"
block|,
literal|"inherited"
block|,
literal|"temporary"
block|,
literal|"none"
block|,
name|NULL
block|}
decl_stmt|;
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|optarg
argument_list|,
name|source_subopts
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZPROP_SRC_LOCAL
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZPROP_SRC_DEFAULT
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZPROP_SRC_INHERITED
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZPROP_SRC_TEMPORARY
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZPROP_SRC_NONE
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid source "
literal|"'%s'\n"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing property "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|fields
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|zprop_get_list
argument_list|(
name|g_zfs
argument_list|,
name|fields
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* 	 * As part of zfs_expand_proplist(), we keep track of the maximum column 	 * width for each property.  For the 'NAME' (and 'SOURCE') columns, we 	 * need to know the maximum name length.  However, the user likely did 	 * not specify 'name' as one of the properties to fetch, so we need to 	 * make sure we always include at least this property for 	 * print_get_headers() to work properly. 	 */
if|if
condition|(
name|cb
operator|.
name|cb_proplist
operator|!=
name|NULL
condition|)
block|{
name|fake_name
operator|.
name|pl_prop
operator|=
name|ZFS_PROP_NAME
expr_stmt|;
name|fake_name
operator|.
name|pl_width
operator|=
name|strlen
argument_list|(
name|gettext
argument_list|(
literal|"NAME"
argument_list|)
argument_list|)
expr_stmt|;
name|fake_name
operator|.
name|pl_next
operator|=
name|cb
operator|.
name|cb_proplist
expr_stmt|;
name|cb
operator|.
name|cb_proplist
operator|=
operator|&
name|fake_name
expr_stmt|;
block|}
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
comment|/* run for each object */
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|,
name|NULL
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
name|get_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_proplist
operator|==
operator|&
name|fake_name
condition|)
name|zprop_free_list
argument_list|(
name|fake_name
operator|.
name|pl_next
argument_list|)
expr_stmt|;
else|else
name|zprop_free_list
argument_list|(
name|cb
operator|.
name|cb_proplist
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * inherit [-r]<property><fs|vol> ...  *  * 	-r	Recurse over all children  *  * For each dataset specified on the command line, inherit the given property  * from its parent.  Inheriting a property at the pool level will cause it to  * use the default value.  The '-r' flag will recurse over all children, and is  * useful for setting a property on a hierarchy-wide basis, regardless of any  * local modifications for each dataset.  */
end_comment

begin_function
specifier|static
name|int
name|inherit_recurse_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|char
modifier|*
name|propname
init|=
name|data
decl_stmt|;
name|zfs_prop_t
name|prop
init|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
decl_stmt|;
comment|/* 	 * If we're doing it recursively, then ignore properties that 	 * are not valid for this type of dataset. 	 */
if|if
condition|(
name|prop
operator|!=
name|ZPROP_INVAL
operator|&&
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zfs_prop_inherit
argument_list|(
name|zhp
argument_list|,
name|propname
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|inherit_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|char
modifier|*
name|propname
init|=
name|data
decl_stmt|;
return|return
operator|(
name|zfs_prop_inherit
argument_list|(
name|zhp
argument_list|,
name|propname
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_inherit
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
name|char
modifier|*
name|propname
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
name|flags
operator||=
name|ZFS_ITER_RECURSE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing property argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|propname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
operator|)
operator|!=
name|ZPROP_INVAL
condition|)
block|{
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"%s property is read-only\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|zfs_prop_inheritable
argument_list|(
name|prop
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"'%s' property cannot "
literal|"be inherited\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_QUOTA
operator|||
name|prop
operator|==
name|ZFS_PROP_RESERVATION
operator|||
name|prop
operator|==
name|ZFS_PROP_REFQUOTA
operator|||
name|prop
operator|==
name|ZFS_PROP_REFRESERVATION
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use 'zfs set "
literal|"%s=none' to clear\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|zfs_prop_user
argument_list|(
name|propname
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid property '%s'\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|ZFS_ITER_RECURSE
condition|)
block|{
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|inherit_recurse_cb
argument_list|,
name|propname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|inherit_cb
argument_list|,
name|propname
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|upgrade_cbdata
block|{
name|uint64_t
name|cb_numupgraded
decl_stmt|;
name|uint64_t
name|cb_numsamegraded
decl_stmt|;
name|uint64_t
name|cb_numfailed
decl_stmt|;
name|uint64_t
name|cb_version
decl_stmt|;
name|boolean_t
name|cb_newer
decl_stmt|;
name|boolean_t
name|cb_foundone
decl_stmt|;
name|char
name|cb_lastfs
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
block|}
name|upgrade_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|same_pool
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|len1
init|=
name|strcspn
argument_list|(
name|name
argument_list|,
literal|"/@"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zhname
init|=
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
name|int
name|len2
init|=
name|strcspn
argument_list|(
name|zhname
argument_list|,
literal|"/@"
argument_list|)
decl_stmt|;
if|if
condition|(
name|len1
operator|!=
name|len2
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|zhname
argument_list|,
name|len1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgrade_list_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|upgrade_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
name|int
name|version
init|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VERSION
argument_list|)
decl_stmt|;
comment|/* list if it's old/new */
if|if
condition|(
operator|(
operator|!
name|cb
operator|->
name|cb_newer
operator|&&
name|version
operator|<
name|ZPL_VERSION
operator|)
operator|||
operator|(
name|cb
operator|->
name|cb_newer
operator|&&
name|version
operator|>
name|ZPL_VERSION
operator|)
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_newer
condition|)
block|{
name|str
operator|=
name|gettext
argument_list|(
literal|"The following filesystems are "
literal|"formatted using a newer software version and\n"
literal|"cannot be accessed on the current system.\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
name|gettext
argument_list|(
literal|"The following filesystems are "
literal|"out of date, and can be upgraded.  After being\n"
literal|"upgraded, these filesystems (and any 'zfs send' "
literal|"streams generated from\n"
literal|"subsequent snapshots) will no longer be "
literal|"accessible by older software versions.\n\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cb
operator|->
name|cb_foundone
condition|)
block|{
operator|(
name|void
operator|)
name|puts
argument_list|(
name|str
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"VER  FILESYSTEM\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"---  ------------\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_foundone
operator|=
name|B_TRUE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%2u   %s\n"
argument_list|,
name|version
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|upgrade_set_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|upgrade_cbdata_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
name|int
name|version
init|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_version
operator|>=
name|ZPL_VERSION_FUID
condition|)
block|{
name|int
name|spa_version
decl_stmt|;
if|if
condition|(
name|zfs_spa_version
argument_list|(
name|zhp
argument_list|,
operator|&
name|spa_version
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|spa_version
operator|<
name|SPA_VERSION_FUID
condition|)
block|{
comment|/* can't upgrade */
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"%s: can not be upgraded; "
literal|"the pool version needs to first be upgraded\nto "
literal|"version %d\n\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|SPA_VERSION_FUID
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_numfailed
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* upgrade */
if|if
condition|(
name|version
operator|<
name|cb
operator|->
name|cb_version
condition|)
block|{
name|char
name|verstr
index|[
literal|16
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|verstr
argument_list|,
sizeof|sizeof
argument_list|(
name|verstr
argument_list|)
argument_list|,
literal|"%llu"
argument_list|,
name|cb
operator|->
name|cb_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cb_lastfs
index|[
literal|0
index|]
operator|&&
operator|!
name|same_pool
argument_list|(
name|zhp
argument_list|,
name|cb
operator|->
name|cb_lastfs
argument_list|)
condition|)
block|{
comment|/* 			 * If they did "zfs upgrade -a", then we could 			 * be doing ioctls to different pools.  We need 			 * to log this history once to each pool. 			 */
name|verify
argument_list|(
name|zpool_stage_history
argument_list|(
name|g_zfs
argument_list|,
name|history_str
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zfs_prop_set
argument_list|(
name|zhp
argument_list|,
literal|"version"
argument_list|,
name|verstr
argument_list|)
operator|==
literal|0
condition|)
name|cb
operator|->
name|cb_numupgraded
operator|++
expr_stmt|;
else|else
name|cb
operator|->
name|cb_numfailed
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cb
operator|->
name|cb_lastfs
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|version
operator|>
name|cb
operator|->
name|cb_version
condition|)
block|{
comment|/* can't downgrade */
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"%s: can not be downgraded; "
literal|"it is already at version %u\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_numfailed
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|->
name|cb_numsamegraded
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs upgrade  * zfs upgrade -v  * zfs upgrade [-r] [-V<version>]<-a | filesystem>  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_upgrade
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|boolean_t
name|all
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|showversions
init|=
name|B_FALSE
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|upgrade_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|flags
init|=
name|ZFS_ITER_ARGS_CAN_BE_PATHS
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"rvV:a"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
name|flags
operator||=
name|ZFS_ITER_RECURSE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|showversions
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|zfs_prop_string_to_index
argument_list|(
name|ZFS_PROP_VERSION
argument_list|,
name|optarg
argument_list|,
operator|&
name|cb
operator|.
name|cb_version
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid version %s\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
name|all
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|all
operator|&&
operator|!
name|argc
operator|)
operator|&&
operator|(
operator|(
name|flags
operator|&
name|ZFS_ITER_RECURSE
operator|)
operator||
name|cb
operator|.
name|cb_version
operator|)
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|showversions
operator|&&
operator|(
name|flags
operator|&
name|ZFS_ITER_RECURSE
operator|||
name|all
operator|||
name|cb
operator|.
name|cb_version
operator|||
name|argc
operator|)
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|all
operator|||
name|argc
operator|)
operator|&&
operator|(
name|showversions
operator|)
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|all
operator|&&
name|argc
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|showversions
condition|)
block|{
comment|/* Show info on available versions. */
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"The following filesystem versions are "
literal|"supported:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"VER  DESCRIPTION\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"---  -----------------------------------------"
literal|"---------------\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 1   Initial ZFS filesystem version\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 2   Enhanced directory entries\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|" 3   Case insensitive and File system "
literal|"unique identifer (FUID)\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"\nFor more information on a particular "
literal|"version, including supported releases, see:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"http://www.opensolaris.org/os/community/zfs/"
literal|"version/zpl/N\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Where 'N' is the version number.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|||
name|all
condition|)
block|{
comment|/* Upgrade filesystems */
if|if
condition|(
name|cb
operator|.
name|cb_version
operator|==
literal|0
condition|)
name|cb
operator|.
name|cb_version
operator|=
name|ZPL_VERSION
expr_stmt|;
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|upgrade_set_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"%llu filesystems upgraded\n"
argument_list|)
argument_list|,
name|cb
operator|.
name|cb_numupgraded
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_numsamegraded
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"%llu filesystems already at "
literal|"this version\n"
argument_list|)
argument_list|,
name|cb
operator|.
name|cb_numsamegraded
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|.
name|cb_numfailed
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* List old-version filesytems */
name|boolean_t
name|found
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"This system is currently running "
literal|"ZFS filesystem version %llu.\n\n"
argument_list|)
argument_list|,
name|ZPL_VERSION
argument_list|)
expr_stmt|;
name|flags
operator||=
name|ZFS_ITER_RECURSE
expr_stmt|;
name|ret
operator|=
name|zfs_for_each
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|upgrade_list_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
name|found
operator|=
name|cb
operator|.
name|cb_foundone
expr_stmt|;
name|cb
operator|.
name|cb_foundone
operator|=
name|B_FALSE
expr_stmt|;
name|cb
operator|.
name|cb_newer
operator|=
name|B_TRUE
expr_stmt|;
name|ret
operator|=
name|zfs_for_each
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|upgrade_list_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|.
name|cb_foundone
operator|&&
operator|!
name|found
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"All filesystems are "
literal|"formatted with the current version.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * list [-rH] [-o property[,property]...] [-t type[,type]...]  *      [-s property [-s property]...] [-S property [-S property]...]  *<dataset> ...  *  * 	-r	Recurse over all children  * 	-H	Scripted mode; elide headers and separate columns by tabs  * 	-o	Control which fields to display.  * 	-t	Control which object types to display.  *	-s	Specify sort columns, descending order.  *	-S	Specify sort columns, ascending order.  *  * When given no arguments, lists all filesystems in the system.  * Otherwise, list the specified datasets, optionally recursing down them if  * '-r' is specified.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|list_cbdata
block|{
name|boolean_t
name|cb_first
decl_stmt|;
name|boolean_t
name|cb_scripted
decl_stmt|;
name|zprop_list_t
modifier|*
name|cb_proplist
decl_stmt|;
block|}
name|list_cbdata_t
typedef|;
end_typedef

begin_comment
comment|/*  * Given a list of columns to display, output appropriate headers for each one.  */
end_comment

begin_function
specifier|static
name|void
name|print_header
parameter_list|(
name|zprop_list_t
modifier|*
name|pl
parameter_list|)
block|{
name|char
name|headerbuf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
name|int
name|i
decl_stmt|;
name|boolean_t
name|first
init|=
name|B_TRUE
decl_stmt|;
name|boolean_t
name|right_justify
decl_stmt|;
for|for
control|(
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|right_justify
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|!=
name|ZPROP_INVAL
condition|)
block|{
name|header
operator|=
name|zfs_prop_column_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
expr_stmt|;
name|right_justify
operator|=
name|zfs_prop_align_right
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pl
operator|->
name|pl_user_prop
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
name|headerbuf
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|pl
operator|->
name|pl_user_prop
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|headerbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|header
operator|=
name|headerbuf
expr_stmt|;
block|}
if|if
condition|(
name|pl
operator|->
name|pl_next
operator|==
name|NULL
operator|&&
operator|!
name|right_justify
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|header
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|right_justify
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|pl
operator|->
name|pl_width
argument_list|,
name|header
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|pl
operator|->
name|pl_width
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a dataset and a list of fields, print out all the properties according  * to the described layout.  */
end_comment

begin_function
specifier|static
name|void
name|print_dataset
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zprop_list_t
modifier|*
name|pl
parameter_list|,
name|boolean_t
name|scripted
parameter_list|)
block|{
name|boolean_t
name|first
init|=
name|B_TRUE
decl_stmt|;
name|char
name|property
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|userprops
init|=
name|zfs_get_user_props
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|char
modifier|*
name|propstr
decl_stmt|;
name|boolean_t
name|right_justify
decl_stmt|;
name|int
name|width
decl_stmt|;
for|for
control|(
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
if|if
condition|(
name|scripted
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|right_justify
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|!=
name|ZPROP_INVAL
condition|)
block|{
if|if
condition|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_prop
argument_list|,
name|property
argument_list|,
sizeof|sizeof
argument_list|(
name|property
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
name|propstr
operator|=
literal|"-"
expr_stmt|;
else|else
name|propstr
operator|=
name|property
expr_stmt|;
name|right_justify
operator|=
name|zfs_prop_align_right
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|userprops
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
operator|&
name|propval
argument_list|)
operator|!=
literal|0
condition|)
name|propstr
operator|=
literal|"-"
expr_stmt|;
else|else
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|propstr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|width
operator|=
name|pl
operator|->
name|pl_width
expr_stmt|;
comment|/* 		 * If this is being called in scripted mode, or if this is the 		 * last column and it is left-justified, don't include a width 		 * format specifier. 		 */
if|if
condition|(
name|scripted
operator|||
operator|(
name|pl
operator|->
name|pl_next
operator|==
name|NULL
operator|&&
operator|!
name|right_justify
operator|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|propstr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|right_justify
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|width
argument_list|,
name|propstr
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|width
argument_list|,
name|propstr
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generic callback function to list a dataset or snapshot.  */
end_comment

begin_function
specifier|static
name|int
name|list_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|list_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
block|{
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_scripted
condition|)
name|print_header
argument_list|(
name|cbp
operator|->
name|cb_proplist
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|print_dataset
argument_list|(
name|zhp
argument_list|,
name|cbp
operator|->
name|cb_proplist
argument_list|,
name|cbp
operator|->
name|cb_scripted
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_list
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|boolean_t
name|scripted
init|=
name|B_FALSE
decl_stmt|;
specifier|static
name|char
name|default_fields
index|[]
init|=
literal|"name,used,available,referenced,mountpoint"
decl_stmt|;
name|int
name|types
init|=
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
decl_stmt|;
name|boolean_t
name|types_specified
init|=
name|B_FALSE
decl_stmt|;
name|char
modifier|*
name|fields
init|=
name|NULL
decl_stmt|;
name|list_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|zfs_sort_column_t
modifier|*
name|sortcol
init|=
name|NULL
decl_stmt|;
name|int
name|flags
init|=
name|ZFS_ITER_PROP_LISTSNAPS
operator||
name|ZFS_ITER_ARGS_CAN_BE_PATHS
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":o:rt:Hs:S:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'o'
case|:
name|fields
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|flags
operator||=
name|ZFS_ITER_RECURSE
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|scripted
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|zfs_add_sort_column
argument_list|(
operator|&
name|sortcol
argument_list|,
name|optarg
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid property '%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|zfs_add_sort_column
argument_list|(
operator|&
name|sortcol
argument_list|,
name|optarg
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid property '%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|types
operator|=
literal|0
expr_stmt|;
name|types_specified
operator|=
name|B_TRUE
expr_stmt|;
name|flags
operator|&=
operator|~
name|ZFS_ITER_PROP_LISTSNAPS
expr_stmt|;
while|while
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
block|{
specifier|static
name|char
modifier|*
name|type_subopts
index|[]
init|=
block|{
literal|"filesystem"
block|,
literal|"volume"
block|,
literal|"snapshot"
block|,
literal|"all"
block|,
name|NULL
block|}
decl_stmt|;
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|optarg
argument_list|,
name|type_subopts
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|types
operator||=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|types
operator||=
name|ZFS_TYPE_VOLUME
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|types
operator||=
name|ZFS_TYPE_SNAPSHOT
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|types
operator|=
name|ZFS_TYPE_DATASET
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid type '%s'\n"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|fields
operator|==
name|NULL
condition|)
name|fields
operator|=
name|default_fields
expr_stmt|;
comment|/* 	 * If "-o space" and no types were specified, don't display snapshots. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|fields
argument_list|,
literal|"space"
argument_list|)
operator|==
literal|0
operator|&&
name|types_specified
operator|==
name|B_FALSE
condition|)
name|types
operator|&=
operator|~
name|ZFS_TYPE_SNAPSHOT
expr_stmt|;
comment|/* 	 * If the user specifies '-o all', the zprop_get_list() doesn't 	 * normally include the name of the dataset.  For 'zfs list', we always 	 * want this property to be first. 	 */
if|if
condition|(
name|zprop_get_list
argument_list|(
name|g_zfs
argument_list|,
name|fields
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|cb
operator|.
name|cb_scripted
operator|=
name|scripted
expr_stmt|;
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|,
name|types
argument_list|,
name|sortcol
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
name|list_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
name|zprop_free_list
argument_list|(
name|cb
operator|.
name|cb_proplist
argument_list|)
expr_stmt|;
name|zfs_free_sort_columns
argument_list|(
name|sortcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|cb
operator|.
name|cb_first
operator|&&
operator|!
name|cb
operator|.
name|cb_scripted
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"no datasets available\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs rename<fs | snap | vol><fs | snap | vol>  * zfs rename -p<fs | vol><fs | vol>  * zfs rename -r<snap><snap>  *  * Renames the given dataset to another of the same type.  *  * The '-p' flag creates all the non-existing ancestors of the target first.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_rename
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|boolean_t
name|recurse
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|parents
init|=
name|B_FALSE
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"pr"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'p'
case|:
name|parents
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|recurse
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing source dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing target dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recurse
operator|&&
name|parents
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"-p and -r options are mutually "
literal|"exclusive\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recurse
operator|&&
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'@'
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"source dataset for recursive "
literal|"rename must be a snapshot\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|parents
condition|?
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
else|:
name|ZFS_TYPE_DATASET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If we were asked and the name looks good, try to create ancestors. */
if|if
condition|(
name|parents
operator|&&
name|zfs_name_valid
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
argument_list|)
operator|&&
name|zfs_create_ancestors
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ret
operator|=
operator|(
name|zfs_rename
argument_list|(
name|zhp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|recurse
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs promote<fs>  *  * Promotes the given clone fs to be the parent  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_promote
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* check options */
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing clone filesystem"
literal|" argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ret
operator|=
operator|(
name|zfs_promote
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs rollback [-rRf]<snapshot>  *  * 	-r	Delete any intervening snapshots before doing rollback  * 	-R	Delete any snapshots and their clones  * 	-f	ignored for backwards compatability  *  * Given a filesystem, rollback to a specific snapshot, discarding any changes  * since then and making it the active dataset.  If more recent snapshots exist,  * the command will complain unless the '-r' flag is given.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rollback_cbdata
block|{
name|uint64_t
name|cb_create
decl_stmt|;
name|boolean_t
name|cb_first
decl_stmt|;
name|int
name|cb_doclones
decl_stmt|;
name|char
modifier|*
name|cb_target
decl_stmt|;
name|int
name|cb_error
decl_stmt|;
name|boolean_t
name|cb_recurse
decl_stmt|;
name|boolean_t
name|cb_dependent
decl_stmt|;
block|}
name|rollback_cbdata_t
typedef|;
end_typedef

begin_comment
comment|/*  * Report any snapshots more recent than the one specified.  Used when '-r' is  * not specified.  We reuse this same callback for the snapshot dependents - if  * 'cb_dependent' is set, then this is a dependent and we should report it  * without checking the transaction group.  */
end_comment

begin_function
specifier|static
name|int
name|rollback_check
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rollback_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_doclones
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_dependent
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_target
argument_list|)
operator|!=
literal|0
operator|&&
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_SNAPSHOT
operator|&&
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
operator|>
name|cbp
operator|->
name|cb_create
condition|)
block|{
if|if
condition|(
name|cbp
operator|->
name|cb_first
operator|&&
operator|!
name|cbp
operator|->
name|cb_recurse
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"rollback to '%s': more recent snapshots "
literal|"exist\n"
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_target
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-r' to "
literal|"force deletion of the following "
literal|"snapshots:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cbp
operator|->
name|cb_recurse
condition|)
block|{
name|cbp
operator|->
name|cb_dependent
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_TRUE
argument_list|,
name|rollback_check
argument_list|,
name|cbp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cbp
operator|->
name|cb_dependent
operator|=
name|B_FALSE
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|cbp
operator|->
name|cb_first
operator|&&
name|cbp
operator|->
name|cb_recurse
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot rollback to "
literal|"'%s': clones of previous snapshots exist\n"
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_target
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-R' to "
literal|"force deletion of the following clones and "
literal|"dependents:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_rollback
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|c
decl_stmt|;
name|boolean_t
name|force
init|=
name|B_FALSE
decl_stmt|;
name|rollback_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|,
modifier|*
name|snap
decl_stmt|;
name|char
name|parentname
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|delim
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"rRf"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
name|cb
operator|.
name|cb_recurse
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|cb
operator|.
name|cb_recurse
operator|=
literal|1
expr_stmt|;
name|cb
operator|.
name|cb_doclones
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* open the snapshot */
if|if
condition|(
operator|(
name|snap
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* open the parent dataset */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|parentname
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|parentname
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|(
operator|(
name|delim
operator|=
name|strrchr
argument_list|(
name|parentname
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|delim
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|parentname
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zfs_close
argument_list|(
name|snap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Check for more recent snapshots and/or clones based on the presence 	 * of '-r' and '-R'. 	 */
name|cb
operator|.
name|cb_target
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|cb
operator|.
name|cb_create
operator|=
name|zfs_prop_get_int
argument_list|(
name|snap
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
name|cb
operator|.
name|cb_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_iter_children
argument_list|(
name|zhp
argument_list|,
name|rollback_check
argument_list|,
operator|&
name|cb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|ret
operator|=
name|cb
operator|.
name|cb_error
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Rollback parent to the given snapshot. 	 */
name|ret
operator|=
name|zfs_rollback
argument_list|(
name|zhp
argument_list|,
name|snap
argument_list|,
name|force
argument_list|)
expr_stmt|;
name|out
label|:
name|zfs_close
argument_list|(
name|snap
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs set property=value { fs | snap | vol } ...  *  * Sets the given property for all datasets specified on the command line.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|set_cbdata
block|{
name|char
modifier|*
name|cb_propname
decl_stmt|;
name|char
modifier|*
name|cb_value
decl_stmt|;
block|}
name|set_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|set_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|set_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
if|if
condition|(
name|zfs_prop_set
argument_list|(
name|zhp
argument_list|,
name|cbp
operator|->
name|cb_propname
argument_list|,
name|cbp
operator|->
name|cb_value
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|libzfs_errno
argument_list|(
name|g_zfs
argument_list|)
condition|)
block|{
case|case
name|EZFS_MOUNTFAILED
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"property may be set "
literal|"but unable to remount filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EZFS_SHARENFSFAILED
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"property may be set "
literal|"but unable to reshare filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_set
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|set_cbdata_t
name|cb
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* check for options */
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing property=value "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* validate property=value argument */
name|cb
operator|.
name|cb_propname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cb
operator|.
name|cb_value
operator|=
name|strchr
argument_list|(
name|cb
operator|.
name|cb_propname
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cb
operator|.
name|cb_value
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing value in "
literal|"property=value argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
operator|*
name|cb
operator|.
name|cb_value
operator|=
literal|'\0'
expr_stmt|;
name|cb
operator|.
name|cb_value
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cb
operator|.
name|cb_propname
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing property in property=value argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
operator|-
literal|2
argument_list|,
name|argv
operator|+
literal|2
argument_list|,
name|NULL
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|set_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs snapshot [-r] [-o prop=value] ...<fs@snap>  *  * Creates a snapshot with the given name.  While functionally equivalent to  * 'zfs create', it is a separate command to differentiate intent.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_snapshot
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|boolean_t
name|recursive
init|=
name|B_FALSE
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|c
decl_stmt|;
name|nvlist_t
modifier|*
name|props
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: "
literal|"out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ro:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'o'
case|:
if|if
condition|(
name|parseprop
argument_list|(
name|props
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
literal|'r'
case|:
name|recursive
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing snapshot argument\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
name|ret
operator|=
name|zfs_snapshot
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|recursive
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|recursive
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"no snapshots were created\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
name|usage
label|:
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs send [-v] -R [-i|-I<@snap>]<fs@snap>  * zfs send [-v] [-i|-I<@snap>]<fs@snap>  *  * Send a backup stream to stdout.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_send
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|fromname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|toname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|boolean_t
name|doall
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|replicate
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|fromorigin
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|verbose
init|=
name|B_FALSE
decl_stmt|;
name|int
name|c
decl_stmt|,
name|err
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":i:I:Rv"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|fromname
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|fromname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|fromname
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|fromname
operator|=
name|optarg
expr_stmt|;
name|doall
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|replicate
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing snapshot argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Error: Stream can not be written to a terminal.\n"
literal|"You must redirect standard output.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"argument must be a snapshot\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|toname
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If they specified the full path to the snapshot, chop off 	 * everything except the short name of the snapshot, but special 	 * case if they specify the origin. 	 */
if|if
condition|(
name|fromname
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|fromname
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|origin
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|zprop_source_t
name|src
decl_stmt|;
operator|(
name|void
operator|)
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ORIGIN
argument_list|,
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|origin
argument_list|)
argument_list|,
operator|&
name|src
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|origin
argument_list|,
name|fromname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fromname
operator|=
name|NULL
expr_stmt|;
name|fromorigin
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|fromname
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|fromname
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"incremental source must be "
literal|"in same filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|fromname
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|fromname
argument_list|,
literal|'@'
argument_list|)
operator|||
name|strchr
argument_list|(
name|fromname
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid incremental source\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|replicate
operator|&&
name|fromname
operator|==
name|NULL
condition|)
name|doall
operator|=
name|B_TRUE
expr_stmt|;
name|err
operator|=
name|zfs_send
argument_list|(
name|zhp
argument_list|,
name|fromname
argument_list|,
name|toname
argument_list|,
name|replicate
argument_list|,
name|doall
argument_list|,
name|fromorigin
argument_list|,
name|verbose
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs receive [-dnvF]<fs@snap>  *  * Restore a backup stream from stdin.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_receive
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|err
decl_stmt|;
name|recvflags_t
name|flags
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|flags
argument_list|,
sizeof|sizeof
argument_list|(
name|recvflags_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":dnuvF"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
name|flags
operator|.
name|isprefix
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|flags
operator|.
name|dryrun
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|flags
operator|.
name|nomount
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|flags
operator|.
name|verbose
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|flags
operator|.
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing snapshot argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Error: Backup stream can not be read "
literal|"from a terminal.\n"
literal|"You must redirect standard input.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|err
operator|=
name|zfs_receive
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|flags
argument_list|,
name|STDIN_FILENO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|allow_cb
block|{
name|int
name|a_permcnt
decl_stmt|;
name|size_t
name|a_treeoffset
decl_stmt|;
block|}
name|allow_cb_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|zfs_print_perms
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|)
block|{
name|zfs_perm_node_t
modifier|*
name|permnode
decl_stmt|;
name|permnode
operator|=
name|avl_first
argument_list|(
name|tree
argument_list|)
expr_stmt|;
while|while
condition|(
name|permnode
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|permnode
operator|->
name|z_pname
argument_list|)
expr_stmt|;
name|permnode
operator|=
name|AVL_NEXT
argument_list|(
name|tree
argument_list|,
name|permnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|permnode
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Iterate over user/groups/everyone/... and the call perm_iter  * function to print actual permission when tree has>0 nodes.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_iter_perms
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
name|banner
parameter_list|,
name|allow_cb_t
modifier|*
name|cb
parameter_list|)
block|{
name|zfs_allow_node_t
modifier|*
name|item
decl_stmt|;
name|avl_tree_t
modifier|*
name|ptree
decl_stmt|;
name|item
operator|=
name|avl_first
argument_list|(
name|tree
argument_list|)
expr_stmt|;
while|while
condition|(
name|item
condition|)
block|{
name|ptree
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|item
operator|+
name|cb
operator|->
name|a_treeoffset
operator|)
expr_stmt|;
if|if
condition|(
name|avl_numnodes
argument_list|(
name|ptree
argument_list|)
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|a_permcnt
operator|++
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|banner
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|item
operator|->
name|z_key
argument_list|)
expr_stmt|;
comment|/* 			 * Avoid an extra space being printed 			 * for "everyone" which is keyed with a null 			 * string 			 */
if|if
condition|(
name|item
operator|->
name|z_key
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|zfs_print_perms
argument_list|(
name|ptree
argument_list|)
expr_stmt|;
block|}
name|item
operator|=
name|AVL_NEXT
argument_list|(
name|tree
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|LINES
value|"-------------------------------------------------------------\n"
end_define

begin_function
specifier|static
name|int
name|zfs_print_allows
parameter_list|(
name|char
modifier|*
name|ds
parameter_list|)
block|{
name|zfs_allow_t
modifier|*
name|curperms
decl_stmt|,
modifier|*
name|perms
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|allow_cb_t
name|allowcb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|banner
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|ds
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strrchr
argument_list|(
name|ds
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Snapshots don't have 'allow'"
literal|" permissions\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|ds
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|zfs_perm_get
argument_list|(
name|zhp
argument_list|,
operator|&
name|perms
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Failed to retrieve 'allows' on %s\n"
argument_list|)
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|perms
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|LINES
argument_list|)
expr_stmt|;
for|for
control|(
name|curperms
operator|=
name|perms
init|;
name|curperms
condition|;
name|curperms
operator|=
name|curperms
operator|->
name|z_next
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|banner
argument_list|,
sizeof|sizeof
argument_list|(
name|banner
argument_list|)
argument_list|,
literal|"Permission sets on (%s)"
argument_list|,
name|curperms
operator|->
name|z_setpoint
argument_list|)
expr_stmt|;
name|allowcb
operator|.
name|a_treeoffset
operator|=
name|offsetof
argument_list|(
name|zfs_allow_node_t
argument_list|,
name|z_localdescend
argument_list|)
expr_stmt|;
name|allowcb
operator|.
name|a_permcnt
operator|=
literal|0
expr_stmt|;
name|zfs_iter_perms
argument_list|(
operator|&
name|curperms
operator|->
name|z_sets
argument_list|,
name|banner
argument_list|,
operator|&
name|allowcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|banner
argument_list|,
sizeof|sizeof
argument_list|(
name|banner
argument_list|)
argument_list|,
literal|"Create time permissions on (%s)"
argument_list|,
name|curperms
operator|->
name|z_setpoint
argument_list|)
expr_stmt|;
name|allowcb
operator|.
name|a_treeoffset
operator|=
name|offsetof
argument_list|(
name|zfs_allow_node_t
argument_list|,
name|z_localdescend
argument_list|)
expr_stmt|;
name|allowcb
operator|.
name|a_permcnt
operator|=
literal|0
expr_stmt|;
name|zfs_iter_perms
argument_list|(
operator|&
name|curperms
operator|->
name|z_crperms
argument_list|,
name|banner
argument_list|,
operator|&
name|allowcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|banner
argument_list|,
sizeof|sizeof
argument_list|(
name|banner
argument_list|)
argument_list|,
literal|"Local permissions on (%s)"
argument_list|,
name|curperms
operator|->
name|z_setpoint
argument_list|)
expr_stmt|;
name|allowcb
operator|.
name|a_treeoffset
operator|=
name|offsetof
argument_list|(
name|zfs_allow_node_t
argument_list|,
name|z_local
argument_list|)
expr_stmt|;
name|allowcb
operator|.
name|a_permcnt
operator|=
literal|0
expr_stmt|;
name|zfs_iter_perms
argument_list|(
operator|&
name|curperms
operator|->
name|z_user
argument_list|,
name|banner
argument_list|,
operator|&
name|allowcb
argument_list|)
expr_stmt|;
name|zfs_iter_perms
argument_list|(
operator|&
name|curperms
operator|->
name|z_group
argument_list|,
name|banner
argument_list|,
operator|&
name|allowcb
argument_list|)
expr_stmt|;
name|zfs_iter_perms
argument_list|(
operator|&
name|curperms
operator|->
name|z_everyone
argument_list|,
name|banner
argument_list|,
operator|&
name|allowcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|banner
argument_list|,
sizeof|sizeof
argument_list|(
name|banner
argument_list|)
argument_list|,
literal|"Descendent permissions on (%s)"
argument_list|,
name|curperms
operator|->
name|z_setpoint
argument_list|)
expr_stmt|;
name|allowcb
operator|.
name|a_treeoffset
operator|=
name|offsetof
argument_list|(
name|zfs_allow_node_t
argument_list|,
name|z_descend
argument_list|)
expr_stmt|;
name|allowcb
operator|.
name|a_permcnt
operator|=
literal|0
expr_stmt|;
name|zfs_iter_perms
argument_list|(
operator|&
name|curperms
operator|->
name|z_user
argument_list|,
name|banner
argument_list|,
operator|&
name|allowcb
argument_list|)
expr_stmt|;
name|zfs_iter_perms
argument_list|(
operator|&
name|curperms
operator|->
name|z_group
argument_list|,
name|banner
argument_list|,
operator|&
name|allowcb
argument_list|)
expr_stmt|;
name|zfs_iter_perms
argument_list|(
operator|&
name|curperms
operator|->
name|z_everyone
argument_list|,
name|banner
argument_list|,
operator|&
name|allowcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|banner
argument_list|,
sizeof|sizeof
argument_list|(
name|banner
argument_list|)
argument_list|,
literal|"Local+Descendent permissions on (%s)"
argument_list|,
name|curperms
operator|->
name|z_setpoint
argument_list|)
expr_stmt|;
name|allowcb
operator|.
name|a_treeoffset
operator|=
name|offsetof
argument_list|(
name|zfs_allow_node_t
argument_list|,
name|z_localdescend
argument_list|)
expr_stmt|;
name|allowcb
operator|.
name|a_permcnt
operator|=
literal|0
expr_stmt|;
name|zfs_iter_perms
argument_list|(
operator|&
name|curperms
operator|->
name|z_user
argument_list|,
name|banner
argument_list|,
operator|&
name|allowcb
argument_list|)
expr_stmt|;
name|zfs_iter_perms
argument_list|(
operator|&
name|curperms
operator|->
name|z_group
argument_list|,
name|banner
argument_list|,
operator|&
name|allowcb
argument_list|)
expr_stmt|;
name|zfs_iter_perms
argument_list|(
operator|&
name|curperms
operator|->
name|z_everyone
argument_list|,
name|banner
argument_list|,
operator|&
name|allowcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|LINES
argument_list|)
expr_stmt|;
block|}
name|zfs_free_allows
argument_list|(
name|perms
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ALLOWOPTIONS
value|"ldcsu:g:e"
end_define

begin_define
define|#
directive|define
name|UNALLOWOPTIONS
value|"ldcsu:g:er"
end_define

begin_comment
comment|/*  * Validate options, and build necessary datastructure to display/remove/add  * permissions.  * Returns 0 - If permissions should be added/removed  * Returns 1 - If permissions should be displayed.  * Returns -1 - on failure  */
end_comment

begin_function
name|int
name|parse_allow_args
parameter_list|(
name|int
modifier|*
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
index|[]
parameter_list|,
name|boolean_t
name|unallow
parameter_list|,
name|char
modifier|*
modifier|*
name|ds
parameter_list|,
name|int
modifier|*
name|recurse
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|zperms
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|options
init|=
name|unallow
condition|?
name|UNALLOWOPTIONS
else|:
name|ALLOWOPTIONS
decl_stmt|;
name|zfs_deleg_inherit_t
name|deleg_type
init|=
name|ZFS_DELEG_NONE
decl_stmt|;
name|zfs_deleg_who_type_t
name|who_type
init|=
name|ZFS_DELEG_WHO_UNKNOWN
decl_stmt|;
name|char
modifier|*
name|who
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|perms
init|=
name|NULL
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
operator|*
name|argc
argument_list|,
operator|*
name|argv
argument_list|,
name|options
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
if|if
condition|(
name|who_type
operator|==
name|ZFS_DELEG_CREATE
operator|||
name|who_type
operator|==
name|ZFS_DELEG_NAMED_SET
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|deleg_type
operator||=
name|ZFS_DELEG_PERM_LOCAL
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|who_type
operator|==
name|ZFS_DELEG_CREATE
operator|||
name|who_type
operator|==
name|ZFS_DELEG_NAMED_SET
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|deleg_type
operator||=
name|ZFS_DELEG_PERM_DESCENDENT
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|recurse
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|who_type
operator|!=
name|ZFS_DELEG_WHO_UNKNOWN
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleg_type
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|who_type
operator|=
name|ZFS_DELEG_CREATE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|who_type
operator|!=
name|ZFS_DELEG_WHO_UNKNOWN
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleg_type
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|who_type
operator|=
name|ZFS_DELEG_NAMED_SET
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|who_type
operator|!=
name|ZFS_DELEG_WHO_UNKNOWN
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|who_type
operator|=
name|ZFS_DELEG_USER
expr_stmt|;
name|who
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|who_type
operator|!=
name|ZFS_DELEG_WHO_UNKNOWN
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|who_type
operator|=
name|ZFS_DELEG_GROUP
expr_stmt|;
name|who
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|who_type
operator|!=
name|ZFS_DELEG_WHO_UNKNOWN
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|who_type
operator|=
name|ZFS_DELEG_EVERYONE
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|deleg_type
operator|==
literal|0
condition|)
name|deleg_type
operator|=
name|ZFS_DELEG_PERM_LOCALDESCENDENT
expr_stmt|;
operator|*
name|argc
operator|-=
name|optind
expr_stmt|;
operator|*
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|unallow
operator|==
name|B_FALSE
operator|&&
operator|*
name|argc
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Only print permissions if no options were processed 		 */
if|if
condition|(
name|optind
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * initialize variables for zfs_build_perms based on number 	 * of arguments. 	 * 3 arguments ==>	zfs [un]allow joe perm,perm,perm<dataset> or 	 *			zfs [un]allow -s @set1 perm,perm<dataset> 	 * 2 arguments ==>	zfs [un]allow -c perm,perm<dataset> or 	 *			zfs [un]allow -u|-g<name> perm<dataset> or 	 *			zfs [un]allow -e perm,perm<dataset> 	 *			zfs unallow joe<dataset> 	 *			zfs unallow -s @set1<dataset> 	 * 1 argument  ==>	zfs [un]allow -e<dataset> or 	 *			zfs [un]allow -c<dataset> 	 */
switch|switch
condition|(
operator|*
name|argc
condition|)
block|{
case|case
literal|3
case|:
name|perms
operator|=
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|who
operator|=
operator|(
operator|*
name|argv
operator|)
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|ds
operator|=
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
expr_stmt|;
comment|/* 		 * advance argc/argv for do_allow cases. 		 * for do_allow case make sure who have a know who type 		 * and its not a permission set. 		 */
if|if
condition|(
name|unallow
operator|==
name|B_TRUE
condition|)
block|{
operator|*
name|argc
operator|-=
literal|2
expr_stmt|;
operator|*
name|argv
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|who_type
operator|!=
name|ZFS_DELEG_WHO_UNKNOWN
operator|&&
name|who_type
operator|!=
name|ZFS_DELEG_NAMED_SET
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|unallow
operator|==
name|B_TRUE
operator|&&
operator|(
name|who_type
operator|==
name|ZFS_DELEG_EVERYONE
operator|||
name|who_type
operator|==
name|ZFS_DELEG_CREATE
operator|||
name|who
operator|!=
name|NULL
operator|)
condition|)
block|{
name|perms
operator|=
operator|(
operator|*
name|argv
operator|)
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|ds
operator|=
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|unallow
operator|==
name|B_FALSE
operator|&&
operator|(
name|who_type
operator|==
name|ZFS_DELEG_WHO_UNKNOWN
operator|||
name|who_type
operator|==
name|ZFS_DELEG_NAMED_SET
operator|)
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|who_type
operator|==
name|ZFS_DELEG_WHO_UNKNOWN
operator|||
name|who_type
operator|==
name|ZFS_DELEG_NAMED_SET
condition|)
name|who
operator|=
operator|(
operator|*
name|argv
operator|)
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|who_type
operator|!=
name|ZFS_DELEG_NAMED_SET
condition|)
name|perms
operator|=
operator|(
operator|*
name|argv
operator|)
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|ds
operator|=
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|unallow
operator|==
name|B_TRUE
condition|)
block|{
operator|(
operator|*
name|argc
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
name|argv
operator|)
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|unallow
operator|==
name|B_FALSE
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|who
operator|==
name|NULL
operator|&&
name|who_type
operator|!=
name|ZFS_DELEG_CREATE
operator|&&
name|who_type
operator|!=
name|ZFS_DELEG_EVERYONE
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
operator|*
name|ds
operator|=
operator|(
operator|*
name|argv
operator|)
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strrchr
argument_list|(
operator|*
name|ds
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Can't set or remove 'allow' permissions "
literal|"on snapshots.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
operator|*
name|ds
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|zfs_build_perms
argument_list|(
name|zhp
argument_list|,
name|who
argument_list|,
name|perms
argument_list|,
name|who_type
argument_list|,
name|deleg_type
argument_list|,
name|zperms
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_allow
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|ds
decl_stmt|;
name|nvlist_t
modifier|*
name|zperms
init|=
name|NULL
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|unused
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|parse_allow_args
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
name|B_FALSE
argument_list|,
operator|&
name|ds
argument_list|,
operator|&
name|unused
argument_list|,
operator|&
name|zperms
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
return|return
operator|(
name|zfs_print_allows
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|ds
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|zfs_perm_set
argument_list|(
name|zhp
argument_list|,
name|zperms
argument_list|)
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zperms
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|zperms
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unallow_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvp
init|=
operator|(
name|nvlist_t
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|zfs_perm_remove
argument_list|(
name|zhp
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Failed to remove permissions "
literal|"on %s\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_unallow
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|recurse
init|=
name|B_FALSE
decl_stmt|;
name|char
modifier|*
name|ds
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nvlist_t
modifier|*
name|zperms
init|=
name|NULL
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|parse_allow_args
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|ds
argument_list|,
operator|&
name|recurse
argument_list|,
operator|&
name|zperms
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|recurse
condition|)
name|flags
operator||=
name|ZFS_ITER_RECURSE
expr_stmt|;
name|error
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|unallow_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
name|zperms
argument_list|)
expr_stmt|;
if|if
condition|(
name|zperms
condition|)
name|nvlist_free
argument_list|(
name|zperms
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|get_all_cbdata
block|{
name|zfs_handle_t
modifier|*
modifier|*
name|cb_handles
decl_stmt|;
name|size_t
name|cb_alloc
decl_stmt|;
name|size_t
name|cb_used
decl_stmt|;
name|uint_t
name|cb_types
decl_stmt|;
name|boolean_t
name|cb_verbose
decl_stmt|;
block|}
name|get_all_cbdata_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CHECK_SPINNER
value|30
end_define

begin_define
define|#
directive|define
name|SPINNER_TIME
value|3
end_define

begin_comment
comment|/* seconds */
end_comment

begin_define
define|#
directive|define
name|MOUNT_TIME
value|5
end_define

begin_comment
comment|/* seconds */
end_comment

begin_function
specifier|static
name|int
name|get_one_dataset
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|static
name|char
name|spin
index|[]
init|=
block|{
literal|'-'
block|,
literal|'\\'
block|,
literal|'|'
block|,
literal|'/'
block|}
decl_stmt|;
specifier|static
name|int
name|spinval
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|spincheck
init|=
literal|0
decl_stmt|;
specifier|static
name|time_t
name|last_spin_time
init|=
operator|(
name|time_t
operator|)
literal|0
decl_stmt|;
name|get_all_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|zfs_type_t
name|type
init|=
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_verbose
condition|)
block|{
if|if
condition|(
operator|--
name|spincheck
operator|<
literal|0
condition|)
block|{
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|last_spin_time
operator|+
name|SPINNER_TIME
operator|<
name|now
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\b%c"
argument_list|,
name|spin
index|[
name|spinval
operator|++
operator|%
literal|4
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|last_spin_time
operator|=
name|now
expr_stmt|;
block|}
name|spincheck
operator|=
name|CHECK_SPINNER
expr_stmt|;
block|}
block|}
comment|/* 	 * Interate over any nested datasets. 	 */
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_FILESYSTEM
operator|&&
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|get_one_dataset
argument_list|,
name|data
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Skip any datasets whose type does not match. 	 */
if|if
condition|(
operator|(
name|type
operator|&
name|cbp
operator|->
name|cb_types
operator|)
operator|==
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cbp
operator|->
name|cb_alloc
operator|==
name|cbp
operator|->
name|cb_used
condition|)
block|{
name|zfs_handle_t
modifier|*
modifier|*
name|handles
decl_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_alloc
operator|==
literal|0
condition|)
name|cbp
operator|->
name|cb_alloc
operator|=
literal|64
expr_stmt|;
else|else
name|cbp
operator|->
name|cb_alloc
operator|*=
literal|2
expr_stmt|;
name|handles
operator|=
name|safe_malloc
argument_list|(
name|cbp
operator|->
name|cb_alloc
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_handles
condition|)
block|{
name|bcopy
argument_list|(
name|cbp
operator|->
name|cb_handles
argument_list|,
name|handles
argument_list|,
name|cbp
operator|->
name|cb_used
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cbp
operator|->
name|cb_handles
argument_list|)
expr_stmt|;
block|}
name|cbp
operator|->
name|cb_handles
operator|=
name|handles
expr_stmt|;
block|}
name|cbp
operator|->
name|cb_handles
index|[
name|cbp
operator|->
name|cb_used
operator|++
index|]
operator|=
name|zhp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_all_datasets
parameter_list|(
name|uint_t
name|types
parameter_list|,
name|zfs_handle_t
modifier|*
modifier|*
modifier|*
name|dslist
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|,
name|boolean_t
name|verbose
parameter_list|)
block|{
name|get_all_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|cb
operator|.
name|cb_types
operator|=
name|types
expr_stmt|;
name|cb
operator|.
name|cb_verbose
operator|=
name|verbose
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: *"
argument_list|,
name|gettext
argument_list|(
literal|"Reading ZFS config"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zfs_iter_root
argument_list|(
name|g_zfs
argument_list|,
name|get_one_dataset
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
operator|*
name|dslist
operator|=
name|cb
operator|.
name|cb_handles
expr_stmt|;
operator|*
name|count
operator|=
name|cb
operator|.
name|cb_used
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\b%s\n"
argument_list|,
name|gettext
argument_list|(
literal|"done."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dataset_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
modifier|*
name|za
init|=
operator|(
name|zfs_handle_t
operator|*
operator|*
operator|)
name|a
decl_stmt|;
name|zfs_handle_t
modifier|*
modifier|*
name|zb
init|=
operator|(
name|zfs_handle_t
operator|*
operator|*
operator|)
name|b
decl_stmt|;
name|char
name|mounta
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|mountb
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|boolean_t
name|gota
decl_stmt|,
name|gotb
decl_stmt|;
if|if
condition|(
operator|(
name|gota
operator|=
operator|(
name|zfs_get_type
argument_list|(
operator|*
name|za
argument_list|)
operator|==
name|ZFS_TYPE_FILESYSTEM
operator|)
operator|)
operator|!=
literal|0
condition|)
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
operator|*
name|za
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|mounta
argument_list|,
sizeof|sizeof
argument_list|(
name|mounta
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gotb
operator|=
operator|(
name|zfs_get_type
argument_list|(
operator|*
name|zb
argument_list|)
operator|==
name|ZFS_TYPE_FILESYSTEM
operator|)
operator|)
operator|!=
literal|0
condition|)
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
operator|*
name|zb
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|mountb
argument_list|,
sizeof|sizeof
argument_list|(
name|mountb
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gota
operator|&&
name|gotb
condition|)
return|return
operator|(
name|strcmp
argument_list|(
name|mounta
argument_list|,
name|mountb
argument_list|)
operator|)
return|;
if|if
condition|(
name|gota
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|gotb
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|strcmp
argument_list|(
name|zfs_get_name
argument_list|(
name|a
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|b
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic callback for sharing or mounting filesystems.  Because the code is so  * similar, we have a common function with an extra parameter to determine which  * mode we are using.  */
end_comment

begin_define
define|#
directive|define
name|OP_SHARE
value|0x1
end_define

begin_define
define|#
directive|define
name|OP_MOUNT
value|0x2
end_define

begin_comment
comment|/*  * Share or mount a dataset.  */
end_comment

begin_function
specifier|static
name|int
name|share_mount_one
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|protocol
parameter_list|,
name|boolean_t
name|explicit
parameter_list|,
specifier|const
name|char
modifier|*
name|options
parameter_list|)
block|{
name|char
name|mountpoint
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
name|shareopts
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
name|smbshareopts
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmdname
init|=
name|op
operator|==
name|OP_SHARE
condition|?
literal|"share"
else|:
literal|"mount"
decl_stmt|;
name|struct
name|mnttab
name|mnt
decl_stmt|;
name|uint64_t
name|zoned
decl_stmt|,
name|canmount
decl_stmt|;
name|zfs_type_t
name|type
init|=
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
name|boolean_t
name|shared_nfs
decl_stmt|,
name|shared_smb
decl_stmt|;
name|assert
argument_list|(
name|type
operator|&
operator|(
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
comment|/* 		 * Check to make sure we can mount/share this dataset.  If we 		 * are in the global zone and the filesystem is exported to a 		 * local zone, or if we are in a local zone and the 		 * filesystem is not exported, then it is an error. 		 */
name|zoned
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
expr_stmt|;
if|if
condition|(
name|zoned
operator|&&
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': "
literal|"dataset is exported to a local zone\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zoned
operator|&&
name|getzoneid
argument_list|()
operator|!=
name|GLOBAL_ZONEID
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': "
literal|"permission denied\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Ignore any filesystems which don't apply to us. This 		 * includes those with a legacy mountpoint, or those with 		 * legacy share options. 		 */
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|mountpoint
argument_list|,
sizeof|sizeof
argument_list|(
name|mountpoint
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARENFS
argument_list|,
name|shareopts
argument_list|,
sizeof|sizeof
argument_list|(
name|shareopts
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARESMB
argument_list|,
name|smbshareopts
argument_list|,
sizeof|sizeof
argument_list|(
name|smbshareopts
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|canmount
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CANMOUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_SHARE
operator|&&
name|strcmp
argument_list|(
name|shareopts
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|smbshareopts
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot share '%s': "
literal|"legacy share\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use share(1M) to "
literal|"share this filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * We cannot share or mount legacy filesystems. If the 		 * shareopts is non-legacy but the mountpoint is legacy, we 		 * treat it as a legacy share. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|mountpoint
argument_list|,
literal|"legacy"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': "
literal|"legacy mountpoint\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use %s(1M) to "
literal|"%s this filesystem\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|mountpoint
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': no "
literal|"mountpoint set\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * canmount	explicit	outcome 		 * on		no		pass through 		 * on		yes		pass through 		 * off		no		return 0 		 * off		yes		display error, return 1 		 * noauto	no		return 0 		 * noauto	yes		pass through 		 */
if|if
condition|(
name|canmount
operator|==
name|ZFS_CANMOUNT_OFF
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': "
literal|"'canmount' property is set to 'off'\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|canmount
operator|==
name|ZFS_CANMOUNT_NOAUTO
operator|&&
operator|!
name|explicit
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * At this point, we have verified that the mountpoint and/or 		 * shareopts are appropriate for auto management. If the 		 * filesystem is already mounted or shared, return (failing 		 * for explicit requests); otherwise mount or share the 		 * filesystem. 		 */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_SHARE
case|:
name|shared_nfs
operator|=
name|zfs_is_shared_nfs
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|shared_smb
operator|=
name|zfs_is_shared_smb
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|shared_nfs
operator|&&
name|shared_smb
operator|||
operator|(
name|shared_nfs
operator|&&
name|strcmp
argument_list|(
name|shareopts
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|smbshareopts
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|shared_smb
operator|&&
name|strcmp
argument_list|(
name|smbshareopts
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|shareopts
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot share "
literal|"'%s': filesystem already shared\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|zfs_is_mounted
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
operator|&&
name|zfs_mount
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|protocol
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|zfs_shareall
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|protocol
argument_list|,
literal|"nfs"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zfs_share_nfs
argument_list|(
name|zhp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|protocol
argument_list|,
literal|"smb"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zfs_share_smb
argument_list|(
name|zhp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot share "
literal|"'%s': invalid share type '%s' "
literal|"specified\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|OP_MOUNT
case|:
if|if
condition|(
name|options
operator|==
name|NULL
condition|)
name|mnt
operator|.
name|mnt_mntopts
operator|=
literal|""
expr_stmt|;
else|else
name|mnt
operator|.
name|mnt_mntopts
operator|=
operator|(
name|char
operator|*
operator|)
name|options
expr_stmt|;
if|if
condition|(
operator|!
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
name|MNTOPT_REMOUNT
argument_list|)
operator|&&
name|zfs_is_mounted
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot mount "
literal|"'%s': filesystem already mounted\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zfs_mount
argument_list|(
name|zhp
argument_list|,
name|options
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
block|}
else|else
block|{
name|assert
argument_list|(
name|op
operator|==
name|OP_SHARE
argument_list|)
expr_stmt|;
comment|/* 		 * Ignore any volumes that aren't shared. 		 */
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHAREISCSI
argument_list|,
name|shareopts
argument_list|,
sizeof|sizeof
argument_list|(
name|shareopts
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|shareopts
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot share '%s': "
literal|"'shareiscsi' property not set\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"set 'shareiscsi' "
literal|"property or use iscsitadm(1M) to share this "
literal|"volume\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zfs_is_shared_iscsi
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot share "
literal|"'%s': volume already shared\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zfs_share_iscsi
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reports progress in the form "(current/total)".  Not thread-safe.  */
end_comment

begin_function
specifier|static
name|void
name|report_mount_progress
parameter_list|(
name|int
name|current
parameter_list|,
name|int
name|total
parameter_list|)
block|{
specifier|static
name|int
name|len
decl_stmt|;
specifier|static
name|char
modifier|*
name|reverse
init|=
literal|"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
literal|"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
decl_stmt|;
specifier|static
name|time_t
name|last_progress_time
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
comment|/* report 1..n instead of 0..n-1 */
operator|++
name|current
expr_stmt|;
comment|/* display header if we're here for the first time */
if|if
condition|(
name|current
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"Mounting ZFS filesystems: "
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|!=
name|total
operator|&&
name|last_progress_time
operator|+
name|MOUNT_TIME
operator|>=
name|now
condition|)
block|{
comment|/* too soon to report again */
return|return;
block|}
name|last_progress_time
operator|=
name|now
expr_stmt|;
comment|/* back up to prepare for overwriting */
if|if
condition|(
name|len
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*.*s"
argument_list|,
name|len
argument_list|,
name|len
argument_list|,
name|reverse
argument_list|)
expr_stmt|;
comment|/* We put a newline at the end if this is the last one.  */
name|len
operator|=
name|printf
argument_list|(
literal|"(%d/%d)%s"
argument_list|,
name|current
argument_list|,
name|total
argument_list|,
name|current
operator|==
name|total
condition|?
literal|"\n"
else|:
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_options
parameter_list|(
name|char
modifier|*
name|mntopts
parameter_list|,
name|char
modifier|*
name|newopts
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|mntopts
argument_list|)
decl_stmt|;
comment|/* original length plus new string to append plus 1 for the comma */
if|if
condition|(
name|len
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|newopts
argument_list|)
operator|>=
name|MNT_LINE_MAX
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"the opts argument for "
literal|"'%c' option is too long (more than %d chars)\n"
argument_list|)
argument_list|,
literal|"-o"
argument_list|,
name|MNT_LINE_MAX
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|mntopts
condition|)
name|mntopts
index|[
name|len
operator|++
index|]
operator|=
literal|','
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|mntopts
index|[
name|len
index|]
argument_list|,
name|newopts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|share_mount
parameter_list|(
name|int
name|op
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|do_all
init|=
literal|0
decl_stmt|;
name|boolean_t
name|verbose
init|=
name|B_FALSE
decl_stmt|;
name|int
name|c
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
name|int
name|types
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|op
operator|==
name|OP_MOUNT
condition|?
literal|":avo:O"
else|:
literal|"a"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|do_all
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"empty mount "
literal|"options (-o) specified\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|==
name|NULL
condition|)
name|options
operator|=
name|safe_malloc
argument_list|(
name|MNT_LINE_MAX
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* option validation is done later */
name|append_options
argument_list|(
name|options
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|warnx
argument_list|(
literal|"no overlay mounts support on FreeBSD, ignoring"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|do_all
condition|)
block|{
name|zfs_handle_t
modifier|*
modifier|*
name|dslist
init|=
name|NULL
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|protocol
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_MOUNT
condition|)
block|{
name|types
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"nfs"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"smb"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|types
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"iscsi"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|types
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"share type "
literal|"must be 'nfs', 'smb' or 'iscsi'\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|protocol
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
else|else
block|{
name|types
operator|=
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|get_all_datasets
argument_list|(
name|types
argument_list|,
operator|&
name|dslist
argument_list|,
operator|&
name|count
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|qsort
argument_list|(
name|dslist
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|dataset_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|verbose
condition|)
name|report_mount_progress
argument_list|(
name|i
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|share_mount_one
argument_list|(
name|dslist
index|[
name|i
index|]
argument_list|,
name|op
argument_list|,
name|flags
argument_list|,
name|protocol
argument_list|,
name|B_FALSE
argument_list|,
name|options
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|zfs_close
argument_list|(
name|dslist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dslist
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|struct
name|statfs
modifier|*
name|sfs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|op
operator|==
name|OP_SHARE
operator|)
operator|||
operator|(
name|options
operator|!=
name|NULL
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing filesystem "
literal|"argument (specify -a for all)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * When mount is given no arguments, go through /etc/mnttab and 		 * display any active ZFS mounts.  We hide any snapshots, since 		 * they are controlled automatically. 		 */
if|if
condition|(
operator|(
name|n
operator|=
name|getmntinfo
argument_list|(
operator|&
name|sfs
argument_list|,
name|MNT_WAIT
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getmntinfo(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sfs
index|[
name|i
index|]
operator|.
name|f_fstypename
argument_list|,
name|MNTTYPE_ZFS
argument_list|)
operator|!=
literal|0
operator|||
name|strchr
argument_list|(
name|sfs
index|[
name|i
index|]
operator|.
name|f_mntfromname
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-30s  %s\n"
argument_list|,
name|sfs
index|[
name|i
index|]
operator|.
name|f_mntfromname
argument_list|,
name|sfs
index|[
name|i
index|]
operator|.
name|f_mntonname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|types
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_SHARE
condition|)
name|types
operator||=
name|ZFS_TYPE_VOLUME
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|types
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|share_mount_one
argument_list|(
name|zhp
argument_list|,
name|op
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|B_TRUE
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs mount -a [nfs | iscsi]  * zfs mount filesystem  *  * Mount all filesystems, or mount the given filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_mount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|share_mount
argument_list|(
name|OP_MOUNT
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs share -a [nfs | iscsi | smb]  * zfs share filesystem  *  * Share all filesystems, or share the given filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_share
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|share_mount
argument_list|(
name|OP_SHARE
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|unshare_unmount_node
block|{
name|zfs_handle_t
modifier|*
name|un_zhp
decl_stmt|;
name|char
modifier|*
name|un_mountp
decl_stmt|;
name|uu_avl_node_t
name|un_avlnode
decl_stmt|;
block|}
name|unshare_unmount_node_t
typedef|;
end_typedef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|unshare_unmount_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|larg
parameter_list|,
specifier|const
name|void
modifier|*
name|rarg
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
specifier|const
name|unshare_unmount_node_t
modifier|*
name|l
init|=
name|larg
decl_stmt|;
specifier|const
name|unshare_unmount_node_t
modifier|*
name|r
init|=
name|rarg
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|l
operator|->
name|un_mountp
argument_list|,
name|r
operator|->
name|un_mountp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convenience routine used by zfs_do_umount() and manual_unmount().  Given an  * absolute path, find the entry /etc/mnttab, verify that its a ZFS filesystem,  * and unmount it appropriately.  */
end_comment

begin_function
specifier|static
name|int
name|unshare_unmount_path
parameter_list|(
name|int
name|op
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|boolean_t
name|is_manual
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|stat64
name|statbuf
decl_stmt|;
name|struct
name|mnttab
name|search
init|=
block|{
literal|0
block|}
decl_stmt|,
name|entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmdname
init|=
operator|(
name|op
operator|==
name|OP_SHARE
operator|)
condition|?
literal|"unshare"
else|:
literal|"unmount"
decl_stmt|;
name|ino_t
name|path_inode
decl_stmt|;
comment|/* 	 * Search for the path in /etc/mnttab.  Rather than looking for the 	 * specific path, which can be fooled by non-standard paths (i.e. ".." 	 * or "//"), we stat() the path and search for the corresponding 	 * (major,minor) device pair. 	 */
if|if
condition|(
name|stat64
argument_list|(
name|path
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': %s\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|path_inode
operator|=
name|statbuf
operator|.
name|st_ino
expr_stmt|;
comment|/* 	 * Search for the given (major,minor) pair in the mount table. 	 */
name|search
operator|.
name|mnt_mountp
operator|=
name|path
expr_stmt|;
name|rewind
argument_list|(
name|mnttab_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|getmntany
argument_list|(
name|mnttab_file
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|search
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|OP_SHARE
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': not "
literal|"currently mounted\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"warning: %s not in mnttab\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|umount2
argument_list|(
name|path
argument_list|,
name|flags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"%s: %s\n"
argument_list|)
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|.
name|mnt_fstype
argument_list|,
name|MNTTYPE_ZFS
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': not a ZFS "
literal|"filesystem\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|entry
operator|.
name|mnt_special
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stat64
argument_list|(
name|entry
operator|.
name|mnt_mountp
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': %s\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|statbuf
operator|.
name|st_ino
operator|!=
name|path_inode
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"%s '%s': not a mountpoint\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|op
operator|==
name|OP_SHARE
condition|)
block|{
name|char
name|nfs_mnt_prop
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
name|smbshare_prop
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARENFS
argument_list|,
name|nfs_mnt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|nfs_mnt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARESMB
argument_list|,
name|smbshare_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|smbshare_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nfs_mnt_prop
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|smbshare_prop
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot unshare "
literal|"'%s': legacy share\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use "
literal|"unshare(1M) to unshare this filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zfs_is_shared
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot unshare '%s': "
literal|"not currently shared\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|zfs_unshareall_bypath
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
name|mtpt_prop
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|mtpt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|mtpt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_manual
condition|)
block|{
name|ret
operator|=
name|zfs_unmount
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|mtpt_prop
argument_list|,
literal|"legacy"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot unmount "
literal|"'%s': legacy mountpoint\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use umount(1M) "
literal|"to unmount this filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|zfs_unmountall
argument_list|(
name|zhp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic callback for unsharing or unmounting a filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|unshare_unmount
parameter_list|(
name|int
name|op
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|do_all
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|types
decl_stmt|,
name|c
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
name|nfsiscsi_mnt_prop
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
name|sharesmb
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|op
operator|==
name|OP_SHARE
condition|?
literal|"a"
else|:
literal|"af"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|do_all
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flags
operator|=
name|MS_FORCE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|do_all
condition|)
block|{
comment|/* 		 * We could make use of zfs_for_each() to walk all datasets in 		 * the system, but this would be very inefficient, especially 		 * since we would have to linearly search /etc/mnttab for each 		 * one.  Instead, do one pass through /etc/mnttab looking for 		 * zfs entries and call zfs_unmount() for each one. 		 * 		 * Things get a little tricky if the administrator has created 		 * mountpoints beneath other ZFS filesystems.  In this case, we 		 * have to unmount the deepest filesystems first.  To accomplish 		 * this, we place all the mountpoints in an AVL tree sorted by 		 * the special type (dataset name), and walk the result in 		 * reverse to make sure to get any snapshots first. 		 */
name|uu_avl_pool_t
modifier|*
name|pool
decl_stmt|;
name|uu_avl_t
modifier|*
name|tree
decl_stmt|;
name|unshare_unmount_node_t
modifier|*
name|node
decl_stmt|;
name|uu_avl_index_t
name|idx
decl_stmt|;
name|uu_avl_walk_t
modifier|*
name|walk
decl_stmt|;
name|struct
name|statfs
modifier|*
name|sfs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pool
operator|=
name|uu_avl_pool_create
argument_list|(
literal|"unmount_pool"
argument_list|,
sizeof|sizeof
argument_list|(
name|unshare_unmount_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|unshare_unmount_node_t
argument_list|,
name|un_avlnode
argument_list|)
argument_list|,
name|unshare_unmount_compare
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: "
literal|"out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tree
operator|=
name|uu_avl_create
argument_list|(
name|pool
argument_list|,
name|NULL
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: "
literal|"out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|getmntinfo
argument_list|(
operator|&
name|sfs
argument_list|,
name|MNT_WAIT
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: "
literal|"getmntinfo() failed\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* ignore non-ZFS entries */
if|if
condition|(
name|strcmp
argument_list|(
name|sfs
index|[
name|i
index|]
operator|.
name|f_fstypename
argument_list|,
name|MNTTYPE_ZFS
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* ignore snapshots */
if|if
condition|(
name|strchr
argument_list|(
name|sfs
index|[
name|i
index|]
operator|.
name|f_mntfromname
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|sfs
index|[
name|i
index|]
operator|.
name|f_mntfromname
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_SHARE
case|:
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARENFS
argument_list|,
name|nfsiscsi_mnt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsiscsi_mnt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nfsiscsi_mnt_prop
argument_list|,
literal|"off"
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARESMB
argument_list|,
name|nfsiscsi_mnt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsiscsi_mnt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nfsiscsi_mnt_prop
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
break|break;
case|case
name|OP_MOUNT
case|:
comment|/* Ignore legacy mounts */
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|nfsiscsi_mnt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsiscsi_mnt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nfsiscsi_mnt_prop
argument_list|,
literal|"legacy"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Ignore canmount=noauto mounts */
if|if
condition|(
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CANMOUNT
argument_list|)
operator|==
name|ZFS_CANMOUNT_NOAUTO
condition|)
continue|continue;
default|default:
break|break;
block|}
name|node
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|unshare_unmount_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|un_zhp
operator|=
name|zhp
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|->
name|un_mountp
operator|=
name|strdup
argument_list|(
name|sfs
index|[
name|i
index|]
operator|.
name|f_mntonname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error:"
literal|" out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|uu_avl_node_init
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|un_avlnode
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|uu_avl_find
argument_list|(
name|tree
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
operator|&
name|idx
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|uu_avl_insert
argument_list|(
name|tree
argument_list|,
name|node
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_close
argument_list|(
name|node
operator|->
name|un_zhp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|un_mountp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Walk the AVL tree in reverse, unmounting each filesystem and 		 * removing it from the AVL tree in the process. 		 */
if|if
condition|(
operator|(
name|walk
operator|=
name|uu_avl_walk_start
argument_list|(
name|tree
argument_list|,
name|UU_WALK_REVERSE
operator||
name|UU_WALK_ROBUST
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: out of memory"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|node
operator|=
name|uu_avl_walk_next
argument_list|(
name|walk
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|uu_avl_remove
argument_list|(
name|tree
argument_list|,
name|node
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_SHARE
case|:
if|if
condition|(
name|zfs_unshareall_bypath
argument_list|(
name|node
operator|->
name|un_zhp
argument_list|,
name|node
operator|->
name|un_mountp
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_MOUNT
case|:
if|if
condition|(
name|zfs_unmount
argument_list|(
name|node
operator|->
name|un_zhp
argument_list|,
name|node
operator|->
name|un_mountp
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|zfs_close
argument_list|(
name|node
operator|->
name|un_zhp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|un_mountp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|uu_avl_walk_end
argument_list|(
name|walk
argument_list|)
expr_stmt|;
name|uu_avl_destroy
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|uu_avl_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_SHARE
condition|)
block|{
comment|/* 			 * Finally, unshare any volumes shared via iSCSI. 			 */
name|zfs_handle_t
modifier|*
modifier|*
name|dslist
init|=
name|NULL
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|get_all_datasets
argument_list|(
name|ZFS_TYPE_VOLUME
argument_list|,
operator|&
name|dslist
argument_list|,
operator|&
name|count
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|qsort
argument_list|(
name|dslist
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|dataset_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zfs_unshare_iscsi
argument_list|(
name|dslist
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|zfs_close
argument_list|(
name|dslist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dslist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing filesystem argument\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We have an argument, but it may be a full path or a ZFS 		 * filesystem.  Pass full paths off to unmount_path() (shared by 		 * manual_unmount), otherwise open the filesystem and pass to 		 * zfs_unmount(). 		 */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
operator|(
name|unshare_unmount_path
argument_list|(
name|op
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|flags
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
name|types
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_SHARE
condition|)
name|types
operator||=
name|ZFS_TYPE_VOLUME
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|types
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|op
operator|==
name|OP_SHARE
condition|?
name|ZFS_PROP_SHARENFS
else|:
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|nfsiscsi_mnt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsiscsi_mnt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_SHARE
case|:
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARENFS
argument_list|,
name|nfsiscsi_mnt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsiscsi_mnt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARESMB
argument_list|,
name|sharesmb
argument_list|,
sizeof|sizeof
argument_list|(
name|sharesmb
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nfsiscsi_mnt_prop
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|sharesmb
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"unshare '%s': legacy share\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use "
literal|"unshare(1M) to unshare this "
literal|"filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zfs_is_shared
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"unshare '%s': not currently "
literal|"shared\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_unshareall
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|OP_MOUNT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|nfsiscsi_mnt_prop
argument_list|,
literal|"legacy"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"unmount '%s': legacy "
literal|"mountpoint\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use "
literal|"umount(1M) to unmount this "
literal|"filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zfs_is_mounted
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"unmount '%s': not currently "
literal|"mounted\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_unmountall
argument_list|(
name|zhp
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
name|assert
argument_list|(
name|op
operator|==
name|OP_SHARE
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHAREISCSI
argument_list|,
name|nfsiscsi_mnt_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsiscsi_mnt_prop
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nfsiscsi_mnt_prop
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot unshare "
literal|"'%s': 'shareiscsi' property not set\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"set "
literal|"'shareiscsi' property or use "
literal|"iscsitadm(1M) to share this volume\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zfs_is_shared_iscsi
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"unshare '%s': not currently shared\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_unshare_iscsi
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs unmount -a  * zfs unmount filesystem  *  * Unmount all filesystems, or a specific ZFS filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_unmount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|unshare_unmount
argument_list|(
name|OP_MOUNT
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs unshare -a  * zfs unshare filesystem  *  * Unshare all filesystems, or a specific ZFS filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_unshare
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|unshare_unmount
argument_list|(
name|OP_SHARE
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach/detach the given dataset to/from the given jail  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|do_jail
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|attach
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|jailid
decl_stmt|,
name|ret
decl_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument(s)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|jailid
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|jailid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid jailid\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ret
operator|=
operator|(
name|zfs_jail
argument_list|(
name|zhp
argument_list|,
name|jailid
argument_list|,
name|attach
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs jail jailid filesystem  *  * Attach the given dataset to the given jail  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_jail
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|do_jail
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs unjail jailid filesystem  *  * Detach the given dataset from the given jail  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_unjail
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|do_jail
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when invoked as /etc/fs/zfs/mount.  Do the mount if the mountpoint is  * 'legacy'.  Otherwise, complain that use should be using 'zfs mount'.  */
end_comment

begin_function
specifier|static
name|int
name|manual_mount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
name|mountpoint
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
name|mntopts
index|[
name|MNT_LINE_MAX
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|dataset
decl_stmt|,
modifier|*
name|path
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":mo:O"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'o'
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|mntopts
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|mntopts
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
if|#
directive|if
literal|0
comment|/* FreeBSD: No support for MS_OVERLAY. */
block|flags |= MS_OVERLAY;
endif|#
directive|endif
break|break;
case|case
literal|'m'
case|:
if|#
directive|if
literal|0
comment|/* FreeBSD: No support for MS_NOMNTTAB. */
block|flags |= MS_NOMNTTAB;
endif|#
directive|endif
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"usage: mount [-o opts] "
literal|"<path>\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check that we only have two arguments */
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing mountpoint argument\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: mount<dataset><mountpoint>\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
name|dataset
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|path
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* try to open the dataset */
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|dataset
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|mountpoint
argument_list|,
sizeof|sizeof
argument_list|(
name|mountpoint
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* check for legacy mountpoint and complain appropriately */
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mountpoint
argument_list|,
name|ZFS_MOUNTPOINT_LEGACY
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zmount
argument_list|(
name|dataset
argument_list|,
name|path
argument_list|,
name|flags
argument_list|,
name|MNTTYPE_ZFS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|mntopts
argument_list|,
sizeof|sizeof
argument_list|(
name|mntopts
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"mount failed: %s\n"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"filesystem '%s' cannot be "
literal|"mounted using 'mount -F zfs'\n"
argument_list|)
argument_list|,
name|dataset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Use 'zfs set mountpoint=%s' "
literal|"instead.\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"If you must use 'mount -F zfs' "
literal|"or /etc/vfstab, use 'zfs set mountpoint=legacy'.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"See zfs(1M) for more "
literal|"information.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when invoked as /etc/fs/zfs/umount.  Unlike a manual mount, we allow  * unmounts of non-legacy filesystems, as this is the dominant administrative  * interface.  */
end_comment

begin_function
specifier|static
name|int
name|manual_unmount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|flags
operator|=
name|MS_FORCE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"usage: unmount [-f] "
literal|"<path>\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check arguments */
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing path "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"usage: unmount [-f]<path>\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
return|return
operator|(
name|unshare_unmount_path
argument_list|(
name|OP_MOUNT
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|flags
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|volcheck
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|boolean_t
name|isinit
init|=
operator|*
operator|(
operator|(
name|boolean_t
operator|*
operator|)
name|data
operator|)
decl_stmt|;
if|if
condition|(
name|isinit
condition|)
return|return
operator|(
name|zpool_create_zvol_links
argument_list|(
name|zhp
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|zpool_remove_zvol_links
argument_list|(
name|zhp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all pools in the system and either create or destroy /dev/zvol  * links, depending on the value of 'isinit'.  */
end_comment

begin_function
specifier|static
name|int
name|do_volcheck
parameter_list|(
name|boolean_t
name|isinit
parameter_list|)
block|{
return|return
operator|(
name|zpool_iter
argument_list|(
name|g_zfs
argument_list|,
name|volcheck
argument_list|,
operator|&
name|isinit
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_command_idx
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|int
modifier|*
name|idx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOMMAND
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|command_table
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
name|command_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|idx
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|progname
decl_stmt|;
name|char
modifier|*
name|cmdname
decl_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdomain
argument_list|(
name|TEXT_DOMAIN
argument_list|)
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|g_zfs
operator|=
name|libzfs_init
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: failed to "
literal|"initialize ZFS library\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|zpool_set_history_str
argument_list|(
literal|"zfs"
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|history_str
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zpool_stage_history
argument_list|(
name|g_zfs
argument_list|,
name|history_str
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|libzfs_print_on_error
argument_list|(
name|g_zfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mnttab_file
operator|=
name|fopen
argument_list|(
name|MNTTAB
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: unable to "
literal|"open %s\n"
argument_list|)
argument_list|,
name|MNTTAB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * This command also doubles as the /etc/fs mount and unmount program. 	 * Determine if we should take this behavior based on argv[0]. 	 */
name|progname
operator|=
name|basename
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
literal|"mount"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|manual_mount
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
literal|"umount"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|manual_unmount
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Make sure the user has specified some command. 		 */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing command\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|cmdname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* 		 * The 'umount' command is an alias for 'unmount' 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"umount"
argument_list|)
operator|==
literal|0
condition|)
name|cmdname
operator|=
literal|"unmount"
expr_stmt|;
comment|/* 		 * The 'recv' command is an alias for 'receive' 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"recv"
argument_list|)
operator|==
literal|0
condition|)
name|cmdname
operator|=
literal|"receive"
expr_stmt|;
comment|/* 		 * Special case '-?' 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"-?"
argument_list|)
operator|==
literal|0
condition|)
name|usage
argument_list|(
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* 		 * 'volinit' and 'volfini' do not appear in the usage message, 		 * so we have to special case them here. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"volinit"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|do_volcheck
argument_list|(
name|B_TRUE
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"volfini"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|do_volcheck
argument_list|(
name|B_FALSE
argument_list|)
operator|)
return|;
comment|/* 		 * Run the appropriate command. 		 */
if|if
condition|(
name|find_command_idx
argument_list|(
name|cmdname
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_command
operator|=
operator|&
name|command_table
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
name|command_table
index|[
name|i
index|]
operator|.
name|func
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|cmdname
argument_list|,
literal|'='
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|verify
argument_list|(
name|find_command_idx
argument_list|(
literal|"set"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|current_command
operator|=
operator|&
name|command_table
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
name|command_table
index|[
name|i
index|]
operator|.
name|func
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"unrecognized "
literal|"command '%s'\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|mnttab_file
argument_list|)
expr_stmt|;
name|libzfs_fini
argument_list|(
name|g_zfs
argument_list|)
expr_stmt|;
comment|/* 	 * The 'ZFS_ABORT' environment variable causes us to dump core on exit 	 * for the purposes of running ::findleaks. 	 */
if|if
condition|(
name|getenv
argument_list|(
literal|"ZFS_ABORT"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dumping core by request\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

