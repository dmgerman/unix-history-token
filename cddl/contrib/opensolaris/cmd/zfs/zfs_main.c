begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<libuutil.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<zone.h>
end_include

begin_include
include|#
directive|include
file|<sys/mntent.h>
end_include

begin_include
include|#
directive|include
file|<sys/mnttab.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|"zfs_iter.h"
end_include

begin_include
include|#
directive|include
file|"zfs_util.h"
end_include

begin_decl_stmt
name|libzfs_handle_t
modifier|*
name|g_zfs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|mnttab_file
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|zfs_do_clone
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_create
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_destroy
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_get
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_inherit
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_list
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_mount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_rename
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_rollback
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_set
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_snapshot
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_unmount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_share
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_unshare
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_send
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_receive
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_promote
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_jail
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_do_unjail
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * These libumem hooks provide a reasonable set of defaults for the allocator's  * debugging facilities.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|_umem_debug_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|"default,verbose"
operator|)
return|;
comment|/* $UMEM_DEBUG setting */
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|_umem_logging_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|"fail,contents"
operator|)
return|;
comment|/* $UMEM_LOGGING setting */
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|HELP_CLONE
block|,
name|HELP_CREATE
block|,
name|HELP_DESTROY
block|,
name|HELP_GET
block|,
name|HELP_INHERIT
block|,
name|HELP_JAIL
block|,
name|HELP_UNJAIL
block|,
name|HELP_LIST
block|,
name|HELP_MOUNT
block|,
name|HELP_PROMOTE
block|,
name|HELP_RECEIVE
block|,
name|HELP_RENAME
block|,
name|HELP_ROLLBACK
block|,
name|HELP_SEND
block|,
name|HELP_SET
block|,
name|HELP_SHARE
block|,
name|HELP_SNAPSHOT
block|,
name|HELP_UNMOUNT
block|,
name|HELP_UNSHARE
block|}
name|zfs_help_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|zfs_command
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
name|zfs_help_t
name|usage
decl_stmt|;
block|}
name|zfs_command_t
typedef|;
end_typedef

begin_comment
comment|/*  * Master command table.  Each ZFS command has a name, associated function, and  * usage message.  The usage messages need to be internationalized, so we have  * to have a function to return the usage message based on a command index.  *  * These commands are organized according to how they are displayed in the usage  * message.  An empty command (one with a NULL name) indicates an empty line in  * the generic usage message.  */
end_comment

begin_decl_stmt
specifier|static
name|zfs_command_t
name|command_table
index|[]
init|=
block|{
block|{
literal|"create"
block|,
name|zfs_do_create
block|,
name|HELP_CREATE
block|}
block|,
block|{
literal|"destroy"
block|,
name|zfs_do_destroy
block|,
name|HELP_DESTROY
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"snapshot"
block|,
name|zfs_do_snapshot
block|,
name|HELP_SNAPSHOT
block|}
block|,
block|{
literal|"rollback"
block|,
name|zfs_do_rollback
block|,
name|HELP_ROLLBACK
block|}
block|,
block|{
literal|"clone"
block|,
name|zfs_do_clone
block|,
name|HELP_CLONE
block|}
block|,
block|{
literal|"promote"
block|,
name|zfs_do_promote
block|,
name|HELP_PROMOTE
block|}
block|,
block|{
literal|"rename"
block|,
name|zfs_do_rename
block|,
name|HELP_RENAME
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"list"
block|,
name|zfs_do_list
block|,
name|HELP_LIST
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"set"
block|,
name|zfs_do_set
block|,
name|HELP_SET
block|}
block|,
block|{
literal|"get"
block|,
name|zfs_do_get
block|,
name|HELP_GET
block|}
block|,
block|{
literal|"inherit"
block|,
name|zfs_do_inherit
block|,
name|HELP_INHERIT
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"mount"
block|,
name|zfs_do_mount
block|,
name|HELP_MOUNT
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"unmount"
block|,
name|zfs_do_unmount
block|,
name|HELP_UNMOUNT
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"share"
block|,
name|zfs_do_share
block|,
name|HELP_SHARE
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"unshare"
block|,
name|zfs_do_unshare
block|,
name|HELP_UNSHARE
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"send"
block|,
name|zfs_do_send
block|,
name|HELP_SEND
block|}
block|,
block|{
literal|"receive"
block|,
name|zfs_do_receive
block|,
name|HELP_RECEIVE
block|}
block|,
block|{
name|NULL
block|}
block|,
block|{
literal|"jail"
block|,
name|zfs_do_jail
block|,
name|HELP_JAIL
block|}
block|,
block|{
literal|"unjail"
block|,
name|zfs_do_unjail
block|,
name|HELP_UNJAIL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NCOMMAND
value|(sizeof (command_table) / sizeof (command_table[0]))
end_define

begin_decl_stmt
name|zfs_command_t
modifier|*
name|current_command
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_usage
parameter_list|(
name|zfs_help_t
name|idx
parameter_list|)
block|{
switch|switch
condition|(
name|idx
condition|)
block|{
case|case
name|HELP_CLONE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tclone<snapshot><filesystem|volume>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_CREATE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tcreate [[-o property=value] ... ] "
literal|"<filesystem>\n"
literal|"\tcreate [-s] [-b blocksize] [[-o property=value] ...]\n"
literal|"\t    -V<size><volume>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_DESTROY
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tdestroy [-rRf] "
literal|"<filesystem|volume|snapshot>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_GET
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tget [-rHp] [-o field[,field]...] "
literal|"[-s source[,source]...]\n"
literal|"\t<all | property[,property]...> "
literal|"[filesystem|volume|snapshot] ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_INHERIT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tinherit [-r]<property> "
literal|"<filesystem|volume> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_JAIL
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tjail<jailid><filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_UNJAIL
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tunjail<jailid><filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_LIST
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tlist [-rH] [-o property[,property]...] "
literal|"[-t type[,type]...]\n"
literal|"\t    [-s property [-s property]...]"
literal|" [-S property [-S property]...]\n"
literal|"\t    [filesystem|volume|snapshot] ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_MOUNT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tmount\n"
literal|"\tmount [-o opts] [-O] -a\n"
literal|"\tmount [-o opts] [-O]<filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_PROMOTE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tpromote<clone filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_RECEIVE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\treceive [-vnF]<filesystem|volume|"
literal|"snapshot>\n"
literal|"\treceive [-vnF] -d<filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_RENAME
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\trename<filesystem|volume|snapshot> "
literal|"<filesystem|volume|snapshot>\n"
literal|"\trename -r<snapshot><snapshot>"
argument_list|)
operator|)
return|;
case|case
name|HELP_ROLLBACK
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\trollback [-rRf]<snapshot>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SEND
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tsend [-i<snapshot>]<snapshot>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SET
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tset<property=value> "
literal|"<filesystem|volume> ...\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SHARE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tshare -a\n"
literal|"\tshare<filesystem>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_SNAPSHOT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tsnapshot [-r] "
literal|"<filesystem@name|volume@name>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_UNMOUNT
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tunmount [-f] -a\n"
literal|"\tunmount [-f]<filesystem|mountpoint>\n"
argument_list|)
operator|)
return|;
case|case
name|HELP_UNSHARE
case|:
return|return
operator|(
name|gettext
argument_list|(
literal|"\tunshare [-f] -a\n"
literal|"\tunshare [-f]<filesystem|mountpoint>\n"
argument_list|)
operator|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Utility function to guarantee malloc() success.  */
end_comment

begin_function
name|void
modifier|*
name|safe_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"internal error: out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback routinue that will print out information for each of the  * the properties.  */
end_comment

begin_function
specifier|static
name|zfs_prop_t
name|usage_prop_cb
parameter_list|(
name|zfs_prop_t
name|prop
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|cb
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%-13s  "
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  NO    "
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" YES    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_prop_inheritable
argument_list|(
name|prop
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  YES   "
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"   NO   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_prop_values
argument_list|(
name|prop
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"-\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_prop_values
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZFS_PROP_CONT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Display usage message.  If we're inside a command, display only the usage for  * that command.  Otherwise, iterate over the entire command table and display  * a complete usage message.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|boolean_t
name|requested
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|boolean_t
name|show_properties
init|=
name|B_FALSE
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|requested
condition|?
name|stdout
else|:
name|stderr
decl_stmt|;
if|if
condition|(
name|current_command
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"usage: zfs command args ...\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"where 'command' is one of the following:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOMMAND
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|command_table
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|get_usage
argument_list|(
name|command_table
index|[
name|i
index|]
operator|.
name|usage
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nEach dataset is of the form: "
literal|"pool/[dataset/]*dataset[@name]\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"usage:\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|get_usage
argument_list|(
name|current_command
operator|->
name|usage
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_command
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"get"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"inherit"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|current_command
operator|->
name|name
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|show_properties
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|show_properties
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nThe following properties are supported:\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\t%-13s  %s  %s   %s\n\n"
argument_list|,
literal|"PROPERTY"
argument_list|,
literal|"EDIT"
argument_list|,
literal|"INHERIT"
argument_list|,
literal|"VALUES"
argument_list|)
expr_stmt|;
comment|/* Iterate over all properties */
operator|(
name|void
operator|)
name|zfs_prop_iter
argument_list|(
name|usage_prop_cb
argument_list|,
name|fp
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nSizes are specified in bytes "
literal|"with standard units such as K, M, G, etc.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\n\nUser-defined properties can "
literal|"be specified by using a name containing a colon (:).\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * TRANSLATION NOTE: 		 * "zfs set|get" must not be localised this is the 		 * command name and arguments. 		 */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gettext
argument_list|(
literal|"\nFor the property list, run: zfs set|get\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * See comments at end of main(). 	 */
if|if
condition|(
name|getenv
argument_list|(
literal|"ZFS_ABORT"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dumping core by request\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
name|requested
condition|?
literal|0
else|:
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * zfs clone<fs, snap, vol> fs  *  * Given an existing dataset, create a writable copy whose initial contents  * are the same as the source.  The newly created dataset maintains a  * dependency on the original; the original cannot be destroyed so long as  * the clone exists.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_clone
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* check options */
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing source dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing target dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* open the source dataset */
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* pass to libzfs */
name|ret
operator|=
name|zfs_clone
argument_list|(
name|zhp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* create the mountpoint if necessary */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|zfs_handle_t
modifier|*
name|clone
init|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|ZFS_TYPE_ANY
argument_list|)
decl_stmt|;
if|if
condition|(
name|clone
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_mount
argument_list|(
name|clone
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|zfs_share
argument_list|(
name|clone
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|clone
argument_list|)
expr_stmt|;
block|}
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs create [-o prop=value] ... fs  * zfs create [-s] [-b blocksize] [-o prop=value] ... -V vol size  *  * Create a new dataset.  This command can be used to create filesystems  * and volumes.  Snapshot creation is handled by 'zfs snapshot'.  * For volumes, the user must specify a size to be used.  *  * The '-s' flag applies only to volumes, and indicates that we should not try  * to set the reservation for this volume.  By default we set a reservation  * equal to the size for any volume.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_create
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_type_t
name|type
init|=
name|ZFS_TYPE_FILESYSTEM
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|volsize
decl_stmt|;
name|int
name|c
decl_stmt|;
name|boolean_t
name|noreserve
init|=
name|B_FALSE
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|nvlist_t
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|intval
decl_stmt|;
name|char
modifier|*
name|propname
decl_stmt|;
name|char
modifier|*
name|propval
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: "
literal|"out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":V:b:so:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'V'
case|:
name|type
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
if|if
condition|(
name|zfs_nicestrtonum
argument_list|(
name|g_zfs
argument_list|,
name|optarg
argument_list|,
operator|&
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"bad volume "
literal|"size '%s': %s\n"
argument_list|)
argument_list|,
name|optarg
argument_list|,
name|libzfs_error_description
argument_list|(
name|g_zfs
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|,
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal "
literal|"error: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|volsize
operator|=
name|intval
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|zfs_nicestrtonum
argument_list|(
name|g_zfs
argument_list|,
name|optarg
argument_list|,
operator|&
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"bad volume "
literal|"block size '%s': %s\n"
argument_list|)
argument_list|,
name|optarg
argument_list|,
name|libzfs_error_description
argument_list|(
name|g_zfs
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal "
literal|"error: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
literal|'o'
case|:
name|propname
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
operator|(
name|propval
operator|=
name|strchr
argument_list|(
name|propname
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing "
literal|"'=' for -o option\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|propval
operator|=
literal|'\0'
expr_stmt|;
name|propval
operator|++
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|propname
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"property '%s' "
literal|"specified multiple times\n"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|props
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal "
literal|"error: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
literal|'s'
case|:
name|noreserve
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing size "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
block|}
if|if
condition|(
name|noreserve
operator|&&
name|type
operator|!=
name|ZFS_TYPE_VOLUME
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"'-s' can only be used when "
literal|"creating a volume\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing %s argument\n"
argument_list|)
argument_list|,
name|zfs_type_to_name
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badusage
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
operator|&&
operator|!
name|noreserve
operator|&&
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_RESERVATION
argument_list|)
argument_list|,
operator|&
name|strval
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_RESERVATION
argument_list|)
argument_list|,
name|volsize
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal "
literal|"error: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* pass to libzfs */
if|if
condition|(
name|zfs_create
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|type
argument_list|,
name|props
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|propval
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|propval
operator|-
literal|1
operator|)
operator|=
literal|'='
expr_stmt|;
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_ANY
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
comment|/* 	 * Mount and/or share the new filesystem as appropriate.  We provide a 	 * verbose error message to let the user know that their filesystem was 	 * in fact created, even if we failed to mount or share it. 	 */
if|if
condition|(
name|zfs_mount
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"filesystem successfully "
literal|"created, but not mounted\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_share
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"filesystem successfully "
literal|"created, but not shared\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|error
label|:
if|if
condition|(
name|zhp
condition|)
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
name|badusage
label|:
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs destroy [-rf]<fs, snap, vol>  *  * 	-r	Recursively destroy all children  * 	-R	Recursively destroy all dependents, including clones  * 	-f	Force unmounting of any dependents  *  * Destroys the given dataset.  By default, it will unmount any filesystems,  * and refuse to destroy a dataset that has any dependents.  A dependent can  * either be a child, or a clone of a child.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|destroy_cbdata
block|{
name|boolean_t
name|cb_first
decl_stmt|;
name|int
name|cb_force
decl_stmt|;
name|int
name|cb_recurse
decl_stmt|;
name|int
name|cb_error
decl_stmt|;
name|int
name|cb_needforce
decl_stmt|;
name|int
name|cb_doclones
decl_stmt|;
name|boolean_t
name|cb_closezhp
decl_stmt|;
name|zfs_handle_t
modifier|*
name|cb_target
decl_stmt|;
name|char
modifier|*
name|cb_snapname
decl_stmt|;
block|}
name|destroy_cbdata_t
typedef|;
end_typedef

begin_comment
comment|/*  * Check for any dependents based on the '-r' or '-R' flags.  */
end_comment

begin_function
specifier|static
name|int
name|destroy_check_dependent
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|destroy_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|tname
init|=
name|zfs_get_name
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|tname
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|tname
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|name
index|[
name|strlen
argument_list|(
name|tname
argument_list|)
index|]
operator|==
literal|'/'
operator|||
name|name
index|[
name|strlen
argument_list|(
name|tname
argument_list|)
index|]
operator|==
literal|'@'
operator|)
condition|)
block|{
comment|/* 		 * This is a direct descendant, not a clone somewhere else in 		 * the hierarchy. 		 */
if|if
condition|(
name|cbp
operator|->
name|cb_recurse
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot destroy '%s': "
literal|"%s has children\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
argument_list|,
name|zfs_type_to_name
argument_list|(
name|zfs_get_type
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-r' to destroy "
literal|"the following datasets:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is a clone.  We only want to report this if the '-r' 		 * wasn't specified, or the target is a snapshot. 		 */
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_recurse
operator|&&
name|zfs_get_type
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
operator|!=
name|ZFS_TYPE_SNAPSHOT
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot destroy '%s': "
literal|"%s has dependent clones\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
argument_list|,
name|zfs_type_to_name
argument_list|(
name|zfs_get_type
argument_list|(
name|cbp
operator|->
name|cb_target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-R' to destroy "
literal|"the following datasets:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|destroy_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|destroy_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
comment|/* 	 * Ignore pools (which we've already flagged as an error before getting 	 * here. 	 */
if|if
condition|(
name|strchr
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
operator|&&
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Bail out on the first error. 	 */
if|if
condition|(
name|zfs_unmount
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
name|cbp
operator|->
name|cb_force
condition|?
name|MS_FORCE
else|:
literal|0
argument_list|)
operator|!=
literal|0
operator|||
name|zfs_destroy
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|destroy_snap_clones
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|destroy_cbdata_t
modifier|*
name|cbp
init|=
name|arg
decl_stmt|;
name|char
name|thissnap
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|zfs_handle_t
modifier|*
name|szhp
decl_stmt|;
name|boolean_t
name|closezhp
init|=
name|cbp
operator|->
name|cb_closezhp
decl_stmt|;
name|int
name|rv
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|thissnap
argument_list|,
sizeof|sizeof
argument_list|(
name|thissnap
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_snapname
argument_list|)
expr_stmt|;
name|libzfs_print_on_error
argument_list|(
name|g_zfs
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|szhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|thissnap
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
name|libzfs_print_on_error
argument_list|(
name|g_zfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|szhp
condition|)
block|{
comment|/* 		 * Destroy any clones of this snapshot 		 */
if|if
condition|(
name|zfs_iter_dependents
argument_list|(
name|szhp
argument_list|,
name|B_FALSE
argument_list|,
name|destroy_callback
argument_list|,
name|cbp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|szhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|closezhp
condition|)
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zfs_close
argument_list|(
name|szhp
argument_list|)
expr_stmt|;
block|}
name|cbp
operator|->
name|cb_closezhp
operator|=
name|B_TRUE
expr_stmt|;
name|rv
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|destroy_snap_clones
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|closezhp
condition|)
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_destroy
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|destroy_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|c
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"frR"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|cb
operator|.
name|cb_force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|cb
operator|.
name|cb_recurse
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|cb
operator|.
name|cb_recurse
operator|=
literal|1
expr_stmt|;
name|cb
operator|.
name|cb_doclones
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing path argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we are doing recursive destroy of a snapshot, then the 	 * named snapshot may not exist.  Go straight to libzfs. 	 */
if|if
condition|(
name|cb
operator|.
name|cb_recurse
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'@'
argument_list|)
operator|)
condition|)
block|{
name|int
name|ret
decl_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_ANY
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_doclones
condition|)
block|{
name|cb
operator|.
name|cb_snapname
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|destroy_snap_clones
argument_list|(
name|zhp
argument_list|,
operator|&
name|cb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|ret
operator|=
name|zfs_destroy_snaps
argument_list|(
name|zhp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"no snapshots destroyed\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
block|}
comment|/* Open the given dataset */
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_ANY
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cb
operator|.
name|cb_target
operator|=
name|zhp
expr_stmt|;
comment|/* 	 * Perform an explicit check for pools before going any further. 	 */
if|if
condition|(
operator|!
name|cb
operator|.
name|cb_recurse
operator|&&
name|strchr
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
operator|&&
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot destroy '%s': "
literal|"operation does not apply to pools\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use 'zfs destroy -r "
literal|"%s' to destroy all datasets in the pool\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use 'zpool destroy %s' "
literal|"to destroy the pool itself\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Check for any dependents and/or clones. 	 */
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|.
name|cb_doclones
operator|&&
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_TRUE
argument_list|,
name|destroy_check_dependent
argument_list|,
operator|&
name|cb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cb
operator|.
name|cb_error
operator|||
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_FALSE
argument_list|,
name|destroy_callback
argument_list|,
operator|&
name|cb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Do the real thing.  The callback will close the handle regardless of 	 * whether it succeeds or not. 	 */
if|if
condition|(
name|destroy_callback
argument_list|(
name|zhp
argument_list|,
operator|&
name|cb
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs get [-rHp] [-o field[,field]...] [-s source[,source]...]  *< all | property[,property]...>< fs | snap | vol> ...  *  *	-r	recurse over any child datasets  *	-H	scripted mode.  Headers are stripped, and fields are separated  *		by tabs instead of spaces.  *	-o	Set of fields to display.  One of "name,property,value,source".  *		Default is all four.  *	-s	Set of sources to allow.  One of  *		"local,default,inherited,temporary,none".  Default is all  *		five.  *	-p	Display values in parsable (literal) format.  *  *  Prints properties for the given datasets.  The user can control which  *  columns to display as well as which property types to allow.  */
end_comment

begin_comment
comment|/*  * Invoked to display the properties for a single dataset.  */
end_comment

begin_function
specifier|static
name|int
name|get_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|char
name|buf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|zfs_source_t
name|sourcetype
decl_stmt|;
name|char
name|source
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|libzfs_get_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
name|userprop
init|=
name|zfs_get_user_props
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
name|zfs_proplist_t
modifier|*
name|pl
init|=
name|cbp
operator|->
name|cb_proplist
decl_stmt|;
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
name|char
modifier|*
name|sourceval
decl_stmt|;
for|for
control|(
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
comment|/* 		 * Skip the special fake placeholder.  This will also skip over 		 * the name property when 'all' is specified. 		 */
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|==
name|ZFS_PROP_NAME
operator|&&
name|pl
operator|==
name|cbp
operator|->
name|cb_proplist
condition|)
continue|continue;
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|!=
name|ZFS_PROP_INVAL
condition|)
block|{
if|if
condition|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_prop
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|sourcetype
argument_list|,
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|source
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_literal
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|pl_all
condition|)
continue|continue;
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|,
name|ZFS_TYPE_ANY
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"No such property '%s'\n"
argument_list|)
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sourcetype
operator|=
name|ZFS_SRC_NONE
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|libzfs_print_one_property
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
argument_list|,
name|buf
argument_list|,
name|sourcetype
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|userprop
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
operator|&
name|propval
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|pl_all
condition|)
continue|continue;
name|sourcetype
operator|=
name|ZFS_SRC_NONE
expr_stmt|;
name|strval
operator|=
literal|"-"
expr_stmt|;
block|}
else|else
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propval
argument_list|,
name|ZFS_PROP_VALUE
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propval
argument_list|,
name|ZFS_PROP_SOURCE
argument_list|,
operator|&
name|sourceval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sourceval
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sourcetype
operator|=
name|ZFS_SRC_LOCAL
expr_stmt|;
block|}
else|else
block|{
name|sourcetype
operator|=
name|ZFS_SRC_INHERITED
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|source
argument_list|,
name|sourceval
argument_list|,
sizeof|sizeof
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|libzfs_print_one_property
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
name|strval
argument_list|,
name|sourcetype
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_get
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|libzfs_get_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|boolean_t
name|recurse
init|=
name|B_FALSE
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|fields
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|zfs_proplist_t
name|fake_name
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* 	 * Set up default columns and sources. 	 */
name|cb
operator|.
name|cb_sources
operator|=
name|ZFS_SRC_ALL
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|0
index|]
operator|=
name|GET_COL_NAME
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|1
index|]
operator|=
name|GET_COL_PROPERTY
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|2
index|]
operator|=
name|GET_COL_VALUE
expr_stmt|;
name|cb
operator|.
name|cb_columns
index|[
literal|3
index|]
operator|=
name|GET_COL_SOURCE
expr_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":o:s:rHp"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'p'
case|:
name|cb
operator|.
name|cb_literal
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|recurse
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|cb
operator|.
name|cb_scripted
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* 			 * Process the set of columns to display.  We zero out 			 * the structure to give us a blank slate. 			 */
name|bzero
argument_list|(
operator|&
name|cb
operator|.
name|cb_columns
argument_list|,
sizeof|sizeof
argument_list|(
name|cb
operator|.
name|cb_columns
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
block|{
specifier|static
name|char
modifier|*
name|col_subopts
index|[]
init|=
block|{
literal|"name"
block|,
literal|"property"
block|,
literal|"value"
block|,
literal|"source"
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too "
literal|"many fields given to -o "
literal|"option\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|optarg
argument_list|,
name|col_subopts
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_NAME
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_PROPERTY
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_VALUE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|cb
operator|.
name|cb_columns
index|[
name|i
operator|++
index|]
operator|=
name|GET_COL_SOURCE
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid column name "
literal|"'%s'\n"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
name|cb
operator|.
name|cb_sources
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
block|{
specifier|static
name|char
modifier|*
name|source_subopts
index|[]
init|=
block|{
literal|"local"
block|,
literal|"default"
block|,
literal|"inherited"
block|,
literal|"temporary"
block|,
literal|"none"
block|,
name|NULL
block|}
decl_stmt|;
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|optarg
argument_list|,
name|source_subopts
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZFS_SRC_LOCAL
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZFS_SRC_DEFAULT
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZFS_SRC_INHERITED
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZFS_SRC_TEMPORARY
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cb
operator|.
name|cb_sources
operator||=
name|ZFS_SRC_NONE
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid source "
literal|"'%s'\n"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing property "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|fields
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|zfs_get_proplist
argument_list|(
name|g_zfs
argument_list|,
name|fields
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|)
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* 	 * As part of zfs_expand_proplist(), we keep track of the maximum column 	 * width for each property.  For the 'NAME' (and 'SOURCE') columns, we 	 * need to know the maximum name length.  However, the user likely did 	 * not specify 'name' as one of the properties to fetch, so we need to 	 * make sure we always include at least this property for 	 * print_get_headers() to work properly. 	 */
if|if
condition|(
name|cb
operator|.
name|cb_proplist
operator|!=
name|NULL
condition|)
block|{
name|fake_name
operator|.
name|pl_prop
operator|=
name|ZFS_PROP_NAME
expr_stmt|;
name|fake_name
operator|.
name|pl_width
operator|=
name|strlen
argument_list|(
name|gettext
argument_list|(
literal|"NAME"
argument_list|)
argument_list|)
expr_stmt|;
name|fake_name
operator|.
name|pl_next
operator|=
name|cb
operator|.
name|cb_proplist
expr_stmt|;
name|cb
operator|.
name|cb_proplist
operator|=
operator|&
name|fake_name
expr_stmt|;
block|}
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
comment|/* run for each object */
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|recurse
argument_list|,
name|ZFS_TYPE_ANY
argument_list|,
name|NULL
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
name|get_callback
argument_list|,
operator|&
name|cb
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_proplist
operator|==
operator|&
name|fake_name
condition|)
name|zfs_free_proplist
argument_list|(
name|fake_name
operator|.
name|pl_next
argument_list|)
expr_stmt|;
else|else
name|zfs_free_proplist
argument_list|(
name|cb
operator|.
name|cb_proplist
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * inherit [-r]<property><fs|vol> ...  *  * 	-r	Recurse over all children  *  * For each dataset specified on the command line, inherit the given property  * from its parent.  Inheriting a property at the pool level will cause it to  * use the default value.  The '-r' flag will recurse over all children, and is  * useful for setting a property on a hierarchy-wide basis, regardless of any  * local modifications for each dataset.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|inherit_cbdata
block|{
name|char
modifier|*
name|cb_propname
decl_stmt|;
name|boolean_t
name|cb_any_successful
decl_stmt|;
block|}
name|inherit_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|inherit_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|inherit_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|zfs_prop_inherit
argument_list|(
name|zhp
argument_list|,
name|cbp
operator|->
name|cb_propname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|cbp
operator|->
name|cb_any_successful
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_inherit
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|boolean_t
name|recurse
init|=
name|B_FALSE
decl_stmt|;
name|int
name|c
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
name|inherit_cbdata_t
name|cb
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
name|recurse
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing property argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|cb
operator|.
name|cb_propname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|cb
operator|.
name|cb_propname
argument_list|)
operator|)
operator|!=
name|ZFS_PROP_INVAL
condition|)
block|{
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"%s property is read-only\n"
argument_list|)
argument_list|,
name|cb
operator|.
name|cb_propname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|zfs_prop_inheritable
argument_list|(
name|prop
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"'%s' property cannot "
literal|"be inherited\n"
argument_list|)
argument_list|,
name|cb
operator|.
name|cb_propname
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_QUOTA
operator|||
name|prop
operator|==
name|ZFS_PROP_RESERVATION
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use 'zfs set "
literal|"%s=none' to clear\n"
argument_list|)
argument_list|,
name|cb
operator|.
name|cb_propname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|zfs_prop_user
argument_list|(
name|cb
operator|.
name|cb_propname
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid property '%s'\n"
argument_list|)
argument_list|,
name|cb
operator|.
name|cb_propname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|cb
operator|.
name|cb_any_successful
operator|=
name|B_FALSE
expr_stmt|;
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|recurse
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|inherit_callback
argument_list|,
operator|&
name|cb
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_any_successful
condition|)
block|{
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
name|optind
operator|+
literal|1
argument_list|,
name|argv
operator|-
name|optind
operator|-
literal|1
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * list [-rH] [-o property[,property]...] [-t type[,type]...]  *      [-s property [-s property]...] [-S property [-S property]...]  *<dataset> ...  *  * 	-r	Recurse over all children  * 	-H	Scripted mode; elide headers and separate colums by tabs  * 	-o	Control which fields to display.  * 	-t	Control which object types to display.  *	-s	Specify sort columns, descending order.  *	-S	Specify sort columns, ascending order.  *  * When given no arguments, lists all filesystems in the system.  * Otherwise, list the specified datasets, optionally recursing down them if  * '-r' is specified.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|list_cbdata
block|{
name|boolean_t
name|cb_first
decl_stmt|;
name|boolean_t
name|cb_scripted
decl_stmt|;
name|zfs_proplist_t
modifier|*
name|cb_proplist
decl_stmt|;
block|}
name|list_cbdata_t
typedef|;
end_typedef

begin_comment
comment|/*  * Given a list of columns to display, output appropriate headers for each one.  */
end_comment

begin_function
specifier|static
name|void
name|print_header
parameter_list|(
name|zfs_proplist_t
modifier|*
name|pl
parameter_list|)
block|{
name|char
name|headerbuf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
name|int
name|i
decl_stmt|;
name|boolean_t
name|first
init|=
name|B_TRUE
decl_stmt|;
name|boolean_t
name|right_justify
decl_stmt|;
for|for
control|(
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|right_justify
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|!=
name|ZFS_PROP_INVAL
condition|)
block|{
name|header
operator|=
name|zfs_prop_column_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
expr_stmt|;
name|right_justify
operator|=
name|zfs_prop_align_right
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pl
operator|->
name|pl_user_prop
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
name|headerbuf
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|pl
operator|->
name|pl_user_prop
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|headerbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|header
operator|=
name|headerbuf
expr_stmt|;
block|}
if|if
condition|(
name|pl
operator|->
name|pl_next
operator|==
name|NULL
operator|&&
operator|!
name|right_justify
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|header
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|right_justify
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|pl
operator|->
name|pl_width
argument_list|,
name|header
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|pl
operator|->
name|pl_width
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a dataset and a list of fields, print out all the properties according  * to the described layout.  */
end_comment

begin_function
specifier|static
name|void
name|print_dataset
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_proplist_t
modifier|*
name|pl
parameter_list|,
name|int
name|scripted
parameter_list|)
block|{
name|boolean_t
name|first
init|=
name|B_TRUE
decl_stmt|;
name|char
name|property
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|userprops
init|=
name|zfs_get_user_props
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|char
modifier|*
name|propstr
decl_stmt|;
name|boolean_t
name|right_justify
decl_stmt|;
name|int
name|width
decl_stmt|;
for|for
control|(
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
if|if
condition|(
name|scripted
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|right_justify
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|!=
name|ZFS_PROP_INVAL
condition|)
block|{
if|if
condition|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|pl
operator|->
name|pl_prop
argument_list|,
name|property
argument_list|,
sizeof|sizeof
argument_list|(
name|property
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
name|propstr
operator|=
literal|"-"
expr_stmt|;
else|else
name|propstr
operator|=
name|property
expr_stmt|;
name|right_justify
operator|=
name|zfs_prop_align_right
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|userprops
argument_list|,
name|pl
operator|->
name|pl_user_prop
argument_list|,
operator|&
name|propval
argument_list|)
operator|!=
literal|0
condition|)
name|propstr
operator|=
literal|"-"
expr_stmt|;
else|else
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propval
argument_list|,
name|ZFS_PROP_VALUE
argument_list|,
operator|&
name|propstr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|width
operator|=
name|pl
operator|->
name|pl_width
expr_stmt|;
comment|/* 		 * If this is being called in scripted mode, or if this is the 		 * last column and it is left-justified, don't include a width 		 * format specifier. 		 */
if|if
condition|(
name|scripted
operator|||
operator|(
name|pl
operator|->
name|pl_next
operator|==
name|NULL
operator|&&
operator|!
name|right_justify
operator|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|propstr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|right_justify
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|width
argument_list|,
name|propstr
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|width
argument_list|,
name|propstr
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generic callback function to list a dataset or snapshot.  */
end_comment

begin_function
specifier|static
name|int
name|list_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|list_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
block|{
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_scripted
condition|)
name|print_header
argument_list|(
name|cbp
operator|->
name|cb_proplist
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|print_dataset
argument_list|(
name|zhp
argument_list|,
name|cbp
operator|->
name|cb_proplist
argument_list|,
name|cbp
operator|->
name|cb_scripted
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_list
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|boolean_t
name|recurse
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|scripted
init|=
name|B_FALSE
decl_stmt|;
specifier|static
name|char
name|default_fields
index|[]
init|=
literal|"name,used,available,referenced,mountpoint"
decl_stmt|;
name|int
name|types
init|=
name|ZFS_TYPE_ANY
decl_stmt|;
name|char
modifier|*
name|fields
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|basic_fields
init|=
name|default_fields
decl_stmt|;
name|list_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|type_subopts
index|[]
init|=
block|{
literal|"filesystem"
block|,
literal|"volume"
block|,
literal|"snapshot"
block|,
name|NULL
block|}
decl_stmt|;
name|zfs_sort_column_t
modifier|*
name|sortcol
init|=
name|NULL
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":o:rt:Hs:S:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'o'
case|:
name|fields
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|recurse
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|scripted
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|zfs_add_sort_column
argument_list|(
operator|&
name|sortcol
argument_list|,
name|optarg
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid property '%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|zfs_add_sort_column
argument_list|(
operator|&
name|sortcol
argument_list|,
name|optarg
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid property '%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|types
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|optarg
argument_list|,
name|type_subopts
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|types
operator||=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|types
operator||=
name|ZFS_TYPE_VOLUME
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|types
operator||=
name|ZFS_TYPE_SNAPSHOT
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid type '%s'\n"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|fields
operator|==
name|NULL
condition|)
name|fields
operator|=
name|basic_fields
expr_stmt|;
comment|/* 	 * If the user specifies '-o all', the zfs_get_proplist() doesn't 	 * normally include the name of the dataset.  For 'zfs list', we always 	 * want this property to be first. 	 */
if|if
condition|(
name|zfs_get_proplist
argument_list|(
name|g_zfs
argument_list|,
name|fields
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|)
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|cb
operator|.
name|cb_scripted
operator|=
name|scripted
expr_stmt|;
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|recurse
argument_list|,
name|types
argument_list|,
name|sortcol
argument_list|,
operator|&
name|cb
operator|.
name|cb_proplist
argument_list|,
name|list_callback
argument_list|,
operator|&
name|cb
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|zfs_free_proplist
argument_list|(
name|cb
operator|.
name|cb_proplist
argument_list|)
expr_stmt|;
name|zfs_free_sort_columns
argument_list|(
name|sortcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|cb
operator|.
name|cb_first
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|gettext
argument_list|(
literal|"no datasets available\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs rename [-r]<fs | snap | vol><fs | snap | vol>  *  * Renames the given dataset to another of the same type.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_rename
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|recurse
init|=
literal|0
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
name|recurse
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing source dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing target dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recurse
operator|&&
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'@'
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"source dataset for recursive "
literal|"rename must be a snapshot\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_ANY
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ret
operator|=
operator|(
name|zfs_rename
argument_list|(
name|zhp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|recurse
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs promote<fs>  *  * Promotes the given clone fs to be the parent  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_promote
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* check options */
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing clone filesystem"
literal|" argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ret
operator|=
operator|(
name|zfs_promote
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs rollback [-rfR]<snapshot>  *  * 	-r	Delete any intervening snapshots before doing rollback  * 	-R	Delete any snapshots and their clones  * 	-f	Force unmount filesystems, even if they are in use.  *  * Given a filesystem, rollback to a specific snapshot, discarding any changes  * since then and making it the active dataset.  If more recent snapshots exist,  * the command will complain unless the '-r' flag is given.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rollback_cbdata
block|{
name|uint64_t
name|cb_create
decl_stmt|;
name|boolean_t
name|cb_first
decl_stmt|;
name|int
name|cb_doclones
decl_stmt|;
name|char
modifier|*
name|cb_target
decl_stmt|;
name|int
name|cb_error
decl_stmt|;
name|boolean_t
name|cb_recurse
decl_stmt|;
name|boolean_t
name|cb_dependent
decl_stmt|;
block|}
name|rollback_cbdata_t
typedef|;
end_typedef

begin_comment
comment|/*  * Report any snapshots more recent than the one specified.  Used when '-r' is  * not specified.  We reuse this same callback for the snapshot dependents - if  * 'cb_dependent' is set, then this is a dependent and we should report it  * without checking the transaction group.  */
end_comment

begin_function
specifier|static
name|int
name|rollback_check
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rollback_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_doclones
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|cbp
operator|->
name|cb_dependent
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_target
argument_list|)
operator|!=
literal|0
operator|&&
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_SNAPSHOT
operator|&&
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
operator|>
name|cbp
operator|->
name|cb_create
condition|)
block|{
if|if
condition|(
name|cbp
operator|->
name|cb_first
operator|&&
operator|!
name|cbp
operator|->
name|cb_recurse
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"rollback to '%s': more recent snapshots "
literal|"exist\n"
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_target
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-r' to "
literal|"force deletion of the following "
literal|"snapshots:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cbp
operator|->
name|cb_recurse
condition|)
block|{
name|cbp
operator|->
name|cb_dependent
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_TRUE
argument_list|,
name|rollback_check
argument_list|,
name|cbp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cbp
operator|->
name|cb_dependent
operator|=
name|B_FALSE
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|cbp
operator|->
name|cb_first
operator|&&
name|cbp
operator|->
name|cb_recurse
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot rollback to "
literal|"'%s': clones of previous snapshots exist\n"
argument_list|)
argument_list|,
name|cbp
operator|->
name|cb_target
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use '-R' to "
literal|"force deletion of the following clones and "
literal|"dependents:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_rollback
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|c
decl_stmt|;
name|rollback_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|,
modifier|*
name|snap
decl_stmt|;
name|char
name|parentname
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|delim
decl_stmt|;
name|int
name|force
init|=
literal|0
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"rfR"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|cb
operator|.
name|cb_recurse
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|cb
operator|.
name|cb_recurse
operator|=
literal|1
expr_stmt|;
name|cb
operator|.
name|cb_doclones
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* open the snapshot */
if|if
condition|(
operator|(
name|snap
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* open the parent dataset */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|parentname
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|parentname
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|(
operator|(
name|delim
operator|=
name|strrchr
argument_list|(
name|parentname
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|delim
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|parentname
argument_list|,
name|ZFS_TYPE_ANY
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zfs_close
argument_list|(
name|snap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Check for more recent snapshots and/or clones based on the presence 	 * of '-r' and '-R'. 	 */
name|cb
operator|.
name|cb_target
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|cb
operator|.
name|cb_create
operator|=
name|zfs_prop_get_int
argument_list|(
name|snap
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
name|cb
operator|.
name|cb_first
operator|=
name|B_TRUE
expr_stmt|;
name|cb
operator|.
name|cb_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_iter_children
argument_list|(
name|zhp
argument_list|,
name|rollback_check
argument_list|,
operator|&
name|cb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|ret
operator|=
name|cb
operator|.
name|cb_error
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Rollback parent to the given snapshot. 	 */
name|ret
operator|=
name|zfs_rollback
argument_list|(
name|zhp
argument_list|,
name|snap
argument_list|,
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|zfs_close
argument_list|(
name|snap
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs set property=value { fs | snap | vol } ...  *  * Sets the given property for all datasets specified on the command line.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|set_cbdata
block|{
name|char
modifier|*
name|cb_propname
decl_stmt|;
name|char
modifier|*
name|cb_value
decl_stmt|;
name|boolean_t
name|cb_any_successful
decl_stmt|;
block|}
name|set_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|set_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|set_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
if|if
condition|(
name|zfs_prop_set
argument_list|(
name|zhp
argument_list|,
name|cbp
operator|->
name|cb_propname
argument_list|,
name|cbp
operator|->
name|cb_value
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|libzfs_errno
argument_list|(
name|g_zfs
argument_list|)
condition|)
block|{
case|case
name|EZFS_MOUNTFAILED
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"property may be set "
literal|"but unable to remount filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EZFS_SHARENFSFAILED
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"property may be set "
literal|"but unable to reshare filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cbp
operator|->
name|cb_any_successful
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_do_set
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|set_cbdata_t
name|cb
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* check for options */
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing property=value "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* validate property=value argument */
name|cb
operator|.
name|cb_propname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|.
name|cb_value
operator|=
name|strchr
argument_list|(
name|cb
operator|.
name|cb_propname
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing value in "
literal|"property=value argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
operator|*
name|cb
operator|.
name|cb_value
operator|=
literal|'\0'
expr_stmt|;
name|cb
operator|.
name|cb_value
operator|++
expr_stmt|;
name|cb
operator|.
name|cb_any_successful
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
operator|*
name|cb
operator|.
name|cb_propname
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing property in property=value argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|zfs_for_each
argument_list|(
name|argc
operator|-
literal|2
argument_list|,
name|argv
operator|+
literal|2
argument_list|,
name|B_FALSE
argument_list|,
name|ZFS_TYPE_ANY
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|set_callback
argument_list|,
operator|&
name|cb
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_any_successful
condition|)
block|{
operator|*
operator|(
name|cb
operator|.
name|cb_value
operator|-
literal|1
operator|)
operator|=
literal|'='
expr_stmt|;
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs snapshot [-r]<fs@snap>  *  * Creates a snapshot with the given name.  While functionally equivalent to  * 'zfs create', it is a separate command to diffferentiate intent.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_snapshot
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|recursive
init|=
name|B_FALSE
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":r"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
name|recursive
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing snapshot argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|zfs_snapshot
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|recursive
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"no snapshots were created\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs send [-i<@snap>]<fs@snap>  *  * Send a backup stream to stdout.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_send
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|fromname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|err
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":i:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|fromname
condition|)
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
name|fromname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing snapshot argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Error: Stream can not be written to a terminal.\n"
literal|"You must redirect standard output.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If they specified the full path to the snapshot, chop off 	 * everything except the short name of the snapshot. 	 */
if|if
condition|(
name|fromname
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|fromname
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
name|fromname
operator|&&
name|strncmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|fromname
argument_list|,
name|cp
operator|-
name|fromname
operator|+
literal|1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"incremental source must be "
literal|"in same filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|fromname
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|fromname
argument_list|,
literal|'@'
argument_list|)
operator|||
name|strchr
argument_list|(
name|fromname
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid incremental source\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
name|zfs_send
argument_list|(
name|zhp
argument_list|,
name|fromname
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs receive<fs@snap>  *  * Restore a backup stream from stdin.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_receive
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|err
decl_stmt|;
name|boolean_t
name|isprefix
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|dryrun
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|verbose
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|force
init|=
name|B_FALSE
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":dnvF"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
name|isprefix
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|dryrun
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|force
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing snapshot argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Error: Backup stream can not be read "
literal|"from a terminal.\n"
literal|"You must redirect standard input.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|err
operator|=
name|zfs_receive
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|isprefix
argument_list|,
name|verbose
argument_list|,
name|dryrun
argument_list|,
name|force
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
operator|+
name|optind
argument_list|,
name|argv
operator|-
name|optind
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|get_all_cbdata
block|{
name|zfs_handle_t
modifier|*
modifier|*
name|cb_handles
decl_stmt|;
name|size_t
name|cb_alloc
decl_stmt|;
name|size_t
name|cb_used
decl_stmt|;
name|uint_t
name|cb_types
decl_stmt|;
block|}
name|get_all_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|get_one_dataset
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|get_all_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|zfs_type_t
name|type
init|=
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
comment|/* 	 * Interate over any nested datasets. 	 */
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_FILESYSTEM
operator|&&
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|get_one_dataset
argument_list|,
name|data
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Skip any datasets whose type does not match. 	 */
if|if
condition|(
operator|(
name|type
operator|&
name|cbp
operator|->
name|cb_types
operator|)
operator|==
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cbp
operator|->
name|cb_alloc
operator|==
name|cbp
operator|->
name|cb_used
condition|)
block|{
name|zfs_handle_t
modifier|*
modifier|*
name|handles
decl_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_alloc
operator|==
literal|0
condition|)
name|cbp
operator|->
name|cb_alloc
operator|=
literal|64
expr_stmt|;
else|else
name|cbp
operator|->
name|cb_alloc
operator|*=
literal|2
expr_stmt|;
name|handles
operator|=
name|safe_malloc
argument_list|(
name|cbp
operator|->
name|cb_alloc
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_handles
condition|)
block|{
name|bcopy
argument_list|(
name|cbp
operator|->
name|cb_handles
argument_list|,
name|handles
argument_list|,
name|cbp
operator|->
name|cb_used
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cbp
operator|->
name|cb_handles
argument_list|)
expr_stmt|;
block|}
name|cbp
operator|->
name|cb_handles
operator|=
name|handles
expr_stmt|;
block|}
name|cbp
operator|->
name|cb_handles
index|[
name|cbp
operator|->
name|cb_used
operator|++
index|]
operator|=
name|zhp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_all_datasets
parameter_list|(
name|uint_t
name|types
parameter_list|,
name|zfs_handle_t
modifier|*
modifier|*
modifier|*
name|dslist
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|)
block|{
name|get_all_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|cb
operator|.
name|cb_types
operator|=
name|types
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_iter_root
argument_list|(
name|g_zfs
argument_list|,
name|get_one_dataset
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
operator|*
name|dslist
operator|=
name|cb
operator|.
name|cb_handles
expr_stmt|;
operator|*
name|count
operator|=
name|cb
operator|.
name|cb_used
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dataset_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
modifier|*
name|za
init|=
operator|(
name|zfs_handle_t
operator|*
operator|*
operator|)
name|a
decl_stmt|;
name|zfs_handle_t
modifier|*
modifier|*
name|zb
init|=
operator|(
name|zfs_handle_t
operator|*
operator|*
operator|)
name|b
decl_stmt|;
name|char
name|mounta
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|mountb
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|boolean_t
name|gota
decl_stmt|,
name|gotb
decl_stmt|;
if|if
condition|(
operator|(
name|gota
operator|=
operator|(
name|zfs_get_type
argument_list|(
operator|*
name|za
argument_list|)
operator|==
name|ZFS_TYPE_FILESYSTEM
operator|)
operator|)
operator|!=
literal|0
condition|)
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
operator|*
name|za
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|mounta
argument_list|,
sizeof|sizeof
argument_list|(
name|mounta
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gotb
operator|=
operator|(
name|zfs_get_type
argument_list|(
operator|*
name|zb
argument_list|)
operator|==
name|ZFS_TYPE_FILESYSTEM
operator|)
operator|)
operator|!=
literal|0
condition|)
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
operator|*
name|zb
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|mountb
argument_list|,
sizeof|sizeof
argument_list|(
name|mountb
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gota
operator|&&
name|gotb
condition|)
return|return
operator|(
name|strcmp
argument_list|(
name|mounta
argument_list|,
name|mountb
argument_list|)
operator|)
return|;
if|if
condition|(
name|gota
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|gotb
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|strcmp
argument_list|(
name|zfs_get_name
argument_list|(
name|a
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|b
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic callback for sharing or mounting filesystems.  Because the code is so  * similar, we have a common function with an extra parameter to determine which  * mode we are using.  */
end_comment

begin_define
define|#
directive|define
name|OP_SHARE
value|0x1
end_define

begin_define
define|#
directive|define
name|OP_MOUNT
value|0x2
end_define

begin_comment
comment|/*  * Share or mount a dataset.  */
end_comment

begin_function
specifier|static
name|int
name|share_mount_one
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|flags
parameter_list|,
name|boolean_t
name|explicit
parameter_list|,
specifier|const
name|char
modifier|*
name|options
parameter_list|)
block|{
name|char
name|mountpoint
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
name|shareopts
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmdname
init|=
name|op
operator|==
name|OP_SHARE
condition|?
literal|"share"
else|:
literal|"mount"
decl_stmt|;
name|struct
name|mnttab
name|mnt
decl_stmt|;
name|uint64_t
name|zoned
decl_stmt|,
name|canmount
decl_stmt|;
name|zfs_type_t
name|type
init|=
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|type
operator|&
operator|(
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
comment|/* 		 * Check to make sure we can mount/share this dataset.  If we 		 * are in the global zone and the filesystem is exported to a 		 * local zone, or if we are in a local zone and the 		 * filesystem is not exported, then it is an error. 		 */
name|zoned
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
expr_stmt|;
if|if
condition|(
name|zoned
operator|&&
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': "
literal|"dataset is exported to a local zone\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zoned
operator|&&
name|getzoneid
argument_list|()
operator|!=
name|GLOBAL_ZONEID
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': "
literal|"permission denied\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Ignore any filesystems which don't apply to us. This 		 * includes those with a legacy mountpoint, or those with 		 * legacy share options. 		 */
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|mountpoint
argument_list|,
sizeof|sizeof
argument_list|(
name|mountpoint
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHARENFS
argument_list|,
name|shareopts
argument_list|,
sizeof|sizeof
argument_list|(
name|shareopts
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|canmount
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CANMOUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_SHARE
operator|&&
name|strcmp
argument_list|(
name|shareopts
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot share '%s': "
literal|"legacy share\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use share(1M) to "
literal|"share this filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * We cannot share or mount legacy filesystems. If the 		 * shareopts is non-legacy but the mountpoint is legacy, we 		 * treat it as a legacy share. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|mountpoint
argument_list|,
literal|"legacy"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': "
literal|"legacy mountpoint\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use %s to "
literal|"%s this filesystem\n"
argument_list|)
argument_list|,
name|op
operator|==
name|OP_SHARE
condition|?
literal|"share(1M)"
else|:
literal|"mount(1M)"
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|mountpoint
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': no "
literal|"mountpoint set\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|canmount
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': "
literal|"'canmount' property is set to 'off'\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * At this point, we have verified that the mountpoint and/or 		 * shareopts are appropriate for auto management. If the 		 * filesystem is already mounted or shared, return (failing 		 * for explicit requests); otherwise mount or share the 		 * filesystem. 		 */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_SHARE
case|:
if|if
condition|(
name|zfs_is_shared_nfs
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot share "
literal|"'%s': filesystem already shared\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|zfs_is_mounted
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
operator|&&
name|zfs_mount
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|zfs_share_nfs
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|OP_MOUNT
case|:
if|if
condition|(
name|options
operator|==
name|NULL
condition|)
name|mnt
operator|.
name|mnt_mntopts
operator|=
literal|""
expr_stmt|;
else|else
name|mnt
operator|.
name|mnt_mntopts
operator|=
operator|(
name|char
operator|*
operator|)
name|options
expr_stmt|;
if|if
condition|(
operator|!
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
name|MNTOPT_REMOUNT
argument_list|)
operator|&&
name|zfs_is_mounted
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot mount "
literal|"'%s': filesystem already mounted\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zfs_mount
argument_list|(
name|zhp
argument_list|,
name|options
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
block|}
else|else
block|{
name|assert
argument_list|(
name|op
operator|==
name|OP_SHARE
argument_list|)
expr_stmt|;
comment|/* 		 * Ignore any volumes that aren't shared. 		 */
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHAREISCSI
argument_list|,
name|shareopts
argument_list|,
sizeof|sizeof
argument_list|(
name|shareopts
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|shareopts
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot share '%s': "
literal|"'shareiscsi' property not set\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"set 'shareiscsi' "
literal|"property or use iscsitadm(1M) to share this "
literal|"volume\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zfs_is_shared_iscsi
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot share "
literal|"'%s': volume already shared\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zfs_share_iscsi
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|share_mount
parameter_list|(
name|int
name|op
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|do_all
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
name|int
name|types
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|op
operator|==
name|OP_MOUNT
condition|?
literal|":ao:O"
else|:
literal|"a"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|do_all
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|options
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|warnx
argument_list|(
literal|"no overlay mounts support on FreeBSD, ignoring"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|do_all
condition|)
block|{
name|zfs_handle_t
modifier|*
modifier|*
name|dslist
init|=
name|NULL
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_MOUNT
condition|)
block|{
name|types
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"nfs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|types
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"iscsi"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|types
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"share type "
literal|"must be 'nfs' or 'iscsi'\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
else|else
block|{
name|types
operator|=
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|get_all_datasets
argument_list|(
name|types
argument_list|,
operator|&
name|dslist
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|qsort
argument_list|(
name|dslist
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|dataset_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|share_mount_one
argument_list|(
name|dslist
index|[
name|i
index|]
argument_list|,
name|op
argument_list|,
name|flags
argument_list|,
name|B_FALSE
argument_list|,
name|options
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|zfs_close
argument_list|(
name|dslist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dslist
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|struct
name|statfs
modifier|*
name|sfs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_SHARE
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing filesystem "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * When mount is given no arguments, go through /etc/mnttab and 		 * display any active ZFS mounts.  We hide any snapshots, since 		 * they are controlled automatically. 		 */
if|if
condition|(
operator|(
name|n
operator|=
name|getmntinfo
argument_list|(
operator|&
name|sfs
argument_list|,
name|MNT_WAIT
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getmntinfo(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sfs
index|[
name|i
index|]
operator|.
name|f_fstypename
argument_list|,
name|MNTTYPE_ZFS
argument_list|)
operator|!=
literal|0
operator|||
name|strchr
argument_list|(
name|sfs
index|[
name|i
index|]
operator|.
name|f_mntfromname
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-30s  %s\n"
argument_list|,
name|sfs
index|[
name|i
index|]
operator|.
name|f_mntfromname
argument_list|,
name|sfs
index|[
name|i
index|]
operator|.
name|f_mntonname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|types
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_SHARE
condition|)
name|types
operator||=
name|ZFS_TYPE_VOLUME
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|types
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|share_mount_one
argument_list|(
name|zhp
argument_list|,
name|op
argument_list|,
name|flags
argument_list|,
name|B_TRUE
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs mount -a [nfs | iscsi]  * zfs mount filesystem  *  * Mount all filesystems, or mount the given filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_mount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|share_mount
argument_list|(
name|OP_MOUNT
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs share -a [nfs | iscsi]  * zfs share filesystem  *  * Share all filesystems, or share the given filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_share
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|share_mount
argument_list|(
name|OP_SHARE
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|unshare_unmount_node
block|{
name|zfs_handle_t
modifier|*
name|un_zhp
decl_stmt|;
name|char
modifier|*
name|un_mountp
decl_stmt|;
name|uu_avl_node_t
name|un_avlnode
decl_stmt|;
block|}
name|unshare_unmount_node_t
typedef|;
end_typedef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|unshare_unmount_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|larg
parameter_list|,
specifier|const
name|void
modifier|*
name|rarg
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
specifier|const
name|unshare_unmount_node_t
modifier|*
name|l
init|=
name|larg
decl_stmt|;
specifier|const
name|unshare_unmount_node_t
modifier|*
name|r
init|=
name|rarg
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|l
operator|->
name|un_mountp
argument_list|,
name|r
operator|->
name|un_mountp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convenience routine used by zfs_do_umount() and manual_unmount().  Given an  * absolute path, find the entry /etc/mnttab, verify that its a ZFS filesystem,  * and unmount it appropriately.  */
end_comment

begin_function
specifier|static
name|int
name|unshare_unmount_path
parameter_list|(
name|int
name|op
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|boolean_t
name|is_manual
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|mnttab
name|search
init|=
block|{
literal|0
block|}
decl_stmt|,
name|entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmdname
init|=
operator|(
name|op
operator|==
name|OP_SHARE
operator|)
condition|?
literal|"unshare"
else|:
literal|"unmount"
decl_stmt|;
name|char
name|property
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
comment|/* 	 * Search for the given (major,minor) pair in the mount table. 	 */
name|search
operator|.
name|mnt_mountp
operator|=
name|path
expr_stmt|;
name|rewind
argument_list|(
name|mnttab_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|getmntany
argument_list|(
name|mnttab_file
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|search
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': not "
literal|"currently mounted\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|.
name|mnt_fstype
argument_list|,
name|MNTTYPE_ZFS
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot %s '%s': not a ZFS "
literal|"filesystem\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|entry
operator|.
name|mnt_special
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|op
operator|==
name|OP_SHARE
condition|?
name|ZFS_PROP_SHARENFS
else|:
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|property
argument_list|,
sizeof|sizeof
argument_list|(
name|property
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_SHARE
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|property
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot unshare "
literal|"'%s': legacy share\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use "
literal|"unshare(1M) to unshare this filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zfs_is_shared_nfs
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot unshare '%s': "
literal|"not currently shared\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|zfs_unshareall_nfs
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|is_manual
condition|)
block|{
name|ret
operator|=
name|zfs_unmount
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|property
argument_list|,
literal|"legacy"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot unmount "
literal|"'%s': legacy mountpoint\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use umount(1M) "
literal|"to unmount this filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|zfs_unmountall
argument_list|(
name|zhp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic callback for unsharing or unmounting a filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|unshare_unmount
parameter_list|(
name|int
name|op
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|do_all
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|types
decl_stmt|,
name|c
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
name|property
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|op
operator|==
name|OP_SHARE
condition|?
literal|"a"
else|:
literal|"af"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|do_all
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flags
operator|=
name|MS_FORCE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|do_all
condition|)
block|{
comment|/* 		 * We could make use of zfs_for_each() to walk all datasets in 		 * the system, but this would be very inefficient, especially 		 * since we would have to linearly search /etc/mnttab for each 		 * one.  Instead, do one pass through /etc/mnttab looking for 		 * zfs entries and call zfs_unmount() for each one. 		 * 		 * Things get a little tricky if the administrator has created 		 * mountpoints beneath other ZFS filesystems.  In this case, we 		 * have to unmount the deepest filesystems first.  To accomplish 		 * this, we place all the mountpoints in an AVL tree sorted by 		 * the special type (dataset name), and walk the result in 		 * reverse to make sure to get any snapshots first. 		 */
name|uu_avl_pool_t
modifier|*
name|pool
decl_stmt|;
name|uu_avl_t
modifier|*
name|tree
decl_stmt|;
name|unshare_unmount_node_t
modifier|*
name|node
decl_stmt|;
name|uu_avl_index_t
name|idx
decl_stmt|;
name|uu_avl_walk_t
modifier|*
name|walk
decl_stmt|;
name|struct
name|statfs
modifier|*
name|sfs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pool
operator|=
name|uu_avl_pool_create
argument_list|(
literal|"unmount_pool"
argument_list|,
sizeof|sizeof
argument_list|(
name|unshare_unmount_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|unshare_unmount_node_t
argument_list|,
name|un_avlnode
argument_list|)
argument_list|,
name|unshare_unmount_compare
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: "
literal|"out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tree
operator|=
name|uu_avl_create
argument_list|(
name|pool
argument_list|,
name|NULL
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: "
literal|"out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|getmntinfo
argument_list|(
operator|&
name|sfs
argument_list|,
name|MNT_WAIT
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: "
literal|"getmntinfo() failed\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* ignore non-ZFS entries */
if|if
condition|(
name|strcmp
argument_list|(
name|sfs
index|[
name|i
index|]
operator|.
name|f_fstypename
argument_list|,
name|MNTTYPE_ZFS
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* ignore snapshots */
if|if
condition|(
name|strchr
argument_list|(
name|sfs
index|[
name|i
index|]
operator|.
name|f_mntfromname
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|sfs
index|[
name|i
index|]
operator|.
name|f_mntfromname
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|op
operator|==
name|OP_SHARE
condition|?
name|ZFS_PROP_SHARENFS
else|:
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|property
argument_list|,
sizeof|sizeof
argument_list|(
name|property
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Ignore legacy mounts and shares */
if|if
condition|(
operator|(
name|op
operator|==
name|OP_SHARE
operator|&&
name|strcmp
argument_list|(
name|property
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|op
operator|==
name|OP_MOUNT
operator|&&
name|strcmp
argument_list|(
name|property
argument_list|,
literal|"legacy"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|node
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|unshare_unmount_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|un_zhp
operator|=
name|zhp
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|->
name|un_mountp
operator|=
name|strdup
argument_list|(
name|sfs
index|[
name|i
index|]
operator|.
name|f_mntonname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error:"
literal|" out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|uu_avl_node_init
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|un_avlnode
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|uu_avl_find
argument_list|(
name|tree
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
operator|&
name|idx
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|uu_avl_insert
argument_list|(
name|tree
argument_list|,
name|node
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_close
argument_list|(
name|node
operator|->
name|un_zhp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|un_mountp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Walk the AVL tree in reverse, unmounting each filesystem and 		 * removing it from the AVL tree in the process. 		 */
if|if
condition|(
operator|(
name|walk
operator|=
name|uu_avl_walk_start
argument_list|(
name|tree
argument_list|,
name|UU_WALK_REVERSE
operator||
name|UU_WALK_ROBUST
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: out of memory"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|node
operator|=
name|uu_avl_walk_next
argument_list|(
name|walk
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|uu_avl_remove
argument_list|(
name|tree
argument_list|,
name|node
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_SHARE
case|:
if|if
condition|(
name|zfs_unshare_nfs
argument_list|(
name|node
operator|->
name|un_zhp
argument_list|,
name|node
operator|->
name|un_mountp
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_MOUNT
case|:
if|if
condition|(
name|zfs_unmount
argument_list|(
name|node
operator|->
name|un_zhp
argument_list|,
name|node
operator|->
name|un_mountp
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|zfs_close
argument_list|(
name|node
operator|->
name|un_zhp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|un_mountp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|uu_avl_walk_end
argument_list|(
name|walk
argument_list|)
expr_stmt|;
name|uu_avl_destroy
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|uu_avl_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_SHARE
condition|)
block|{
comment|/* 			 * Finally, unshare any volumes shared via iSCSI. 			 */
name|zfs_handle_t
modifier|*
modifier|*
name|dslist
init|=
name|NULL
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|get_all_datasets
argument_list|(
name|ZFS_TYPE_VOLUME
argument_list|,
operator|&
name|dslist
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|qsort
argument_list|(
name|dslist
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|dataset_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zfs_unshare_iscsi
argument_list|(
name|dslist
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|zfs_close
argument_list|(
name|dslist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dslist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing filesystem argument\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We have an argument, but it may be a full path or a ZFS 		 * filesystem.  Pass full paths off to unmount_path() (shared by 		 * manual_unmount), otherwise open the filesystem and pass to 		 * zfs_unmount(). 		 */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
operator|(
name|unshare_unmount_path
argument_list|(
name|op
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|flags
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
name|types
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_SHARE
condition|)
name|types
operator||=
name|ZFS_TYPE_VOLUME
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|types
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|op
operator|==
name|OP_SHARE
condition|?
name|ZFS_PROP_SHARENFS
else|:
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|property
argument_list|,
sizeof|sizeof
argument_list|(
name|property
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_SHARE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|property
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"unshare '%s': legacy share\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use "
literal|"unshare(1M) to unshare this "
literal|"filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zfs_is_shared_nfs
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"unshare '%s': not currently "
literal|"shared\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_unshareall_nfs
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|OP_MOUNT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|property
argument_list|,
literal|"legacy"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"unmount '%s': legacy "
literal|"mountpoint\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"use "
literal|"umount(1M) to unmount this "
literal|"filesystem\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zfs_is_mounted
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"unmount '%s': not currently "
literal|"mounted\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_unmountall
argument_list|(
name|zhp
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
name|assert
argument_list|(
name|op
operator|==
name|OP_SHARE
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_SHAREISCSI
argument_list|,
name|property
argument_list|,
sizeof|sizeof
argument_list|(
name|property
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|property
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot unshare "
literal|"'%s': 'shareiscsi' property not set\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"set "
literal|"'shareiscsi' property or use "
literal|"iscsitadm(1M) to share this volume\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zfs_is_shared_iscsi
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"cannot "
literal|"unshare '%s': not currently shared\n"
argument_list|)
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_unshare_iscsi
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs unmount -a  * zfs unmount filesystem  *  * Unmount all filesystems, or a specific ZFS filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_unmount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|unshare_unmount
argument_list|(
name|OP_MOUNT
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs unshare -a  * zfs unshare filesystem  *  * Unshare all filesystems, or a specific ZFS filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_unshare
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|unshare_unmount
argument_list|(
name|OP_SHARE
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach/detach the given dataset to/from the given jail  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|do_jail
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|attach
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|jailid
decl_stmt|,
name|ret
decl_stmt|;
comment|/* check number of arguments */
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument(s)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|jailid
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|jailid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid jailid\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ret
operator|=
operator|(
name|zfs_jail
argument_list|(
name|zhp
argument_list|,
name|jailid
argument_list|,
name|attach
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|zpool_log_history
argument_list|(
name|g_zfs
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs jail jailid filesystem  *  * Attach the given dataset to the given jail  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_jail
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|do_jail
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs unjail jailid filesystem  *  * Detach the given dataset from the given jail  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_do_unjail
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|do_jail
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when invoked as /etc/fs/zfs/mount.  Do the mount if the mountpoint is  * 'legacy'.  Otherwise, complain that use should be using 'zfs mount'.  */
end_comment

begin_function
specifier|static
name|int
name|manual_mount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
name|mountpoint
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
name|mntopts
index|[
name|MNT_LINE_MAX
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|dataset
decl_stmt|,
modifier|*
name|path
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":mo:O"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'o'
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|mntopts
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|mntopts
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
if|#
directive|if
literal|0
comment|/* FreeBSD: No support for MS_OVERLAY. */
block|flags |= MS_OVERLAY;
endif|#
directive|endif
break|break;
case|case
literal|'m'
case|:
if|#
directive|if
literal|0
comment|/* FreeBSD: No support for MS_NOMNTTAB. */
block|flags |= MS_NOMNTTAB;
endif|#
directive|endif
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing argument for "
literal|"'%c' option\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"usage: mount [-o opts] "
literal|"<path>\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check that we only have two arguments */
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing dataset "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing mountpoint argument\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: mount<dataset><mountpoint>\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
name|dataset
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|path
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* try to open the dataset */
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|dataset
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|mountpoint
argument_list|,
sizeof|sizeof
argument_list|(
name|mountpoint
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* check for legacy mountpoint and complain appropriately */
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mountpoint
argument_list|,
name|ZFS_MOUNTPOINT_LEGACY
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zmount
argument_list|(
name|dataset
argument_list|,
name|path
argument_list|,
name|flags
argument_list|,
name|MNTTYPE_ZFS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|mntopts
argument_list|,
sizeof|sizeof
argument_list|(
name|mntopts
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"mount failed: %s\n"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"filesystem '%s' cannot be "
literal|"mounted using 'mount -F zfs'\n"
argument_list|)
argument_list|,
name|dataset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"Use 'zfs set mountpoint=%s' "
literal|"instead.\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"If you must use 'mount -F zfs' "
literal|"or /etc/vfstab, use 'zfs set mountpoint=legacy'.\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"See zfs(1M) for more "
literal|"information.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when invoked as /etc/fs/zfs/umount.  Unlike a manual mount, we allow  * unmounts of non-legacy filesystems, as this is the dominant administrative  * interface.  */
end_comment

begin_function
specifier|static
name|int
name|manual_unmount
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* check options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|flags
operator|=
name|MS_FORCE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"invalid option '%c'\n"
argument_list|)
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"usage: unmount [-f] "
literal|"<path>\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* check arguments */
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing path "
literal|"argument\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"too many arguments\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"usage: unmount [-f]<path>\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
return|return
operator|(
name|unshare_unmount_path
argument_list|(
name|OP_MOUNT
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|flags
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|volcheck
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|boolean_t
name|isinit
init|=
operator|*
operator|(
operator|(
name|boolean_t
operator|*
operator|)
name|data
operator|)
decl_stmt|;
if|if
condition|(
name|isinit
condition|)
return|return
operator|(
name|zpool_create_zvol_links
argument_list|(
name|zhp
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|zpool_remove_zvol_links
argument_list|(
name|zhp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all pools in the system and either create or destroy /dev/zvol  * links, depending on the value of 'isinit'.  */
end_comment

begin_function
specifier|static
name|int
name|do_volcheck
parameter_list|(
name|boolean_t
name|isinit
parameter_list|)
block|{
return|return
operator|(
name|zpool_iter
argument_list|(
name|g_zfs
argument_list|,
name|volcheck
argument_list|,
operator|&
name|isinit
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|progname
decl_stmt|;
name|char
modifier|*
name|cmdname
decl_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdomain
argument_list|(
name|TEXT_DOMAIN
argument_list|)
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|g_zfs
operator|=
name|libzfs_init
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: failed to "
literal|"initialize ZFS library\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|libzfs_print_on_error
argument_list|(
name|g_zfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mnttab_file
operator|=
name|fopen
argument_list|(
name|MNTTAB
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: unable to "
literal|"open %s\n"
argument_list|)
argument_list|,
name|MNTTAB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * This command also doubles as the /etc/fs mount and unmount program. 	 * Determine if we should take this behavior based on argv[0]. 	 */
name|progname
operator|=
name|basename
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
literal|"mount"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|manual_mount
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
literal|"umount"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|manual_unmount
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Make sure the user has specified some command. 		 */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"missing command\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|cmdname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* 		 * The 'umount' command is an alias for 'unmount' 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"umount"
argument_list|)
operator|==
literal|0
condition|)
name|cmdname
operator|=
literal|"unmount"
expr_stmt|;
comment|/* 		 * The 'recv' command is an alias for 'receive' 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"recv"
argument_list|)
operator|==
literal|0
condition|)
name|cmdname
operator|=
literal|"receive"
expr_stmt|;
comment|/* 		 * Special case '-?' 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"-?"
argument_list|)
operator|==
literal|0
condition|)
name|usage
argument_list|(
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* 		 * 'volinit' and 'volfini' do not appear in the usage message, 		 * so we have to special case them here. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"volinit"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|do_volcheck
argument_list|(
name|B_TRUE
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"volfini"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|do_volcheck
argument_list|(
name|B_FALSE
argument_list|)
operator|)
return|;
comment|/* 		 * Run the appropriate command. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOMMAND
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|command_table
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
name|command_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_command
operator|=
operator|&
name|command_table
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
name|command_table
index|[
name|i
index|]
operator|.
name|func
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|NCOMMAND
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"unrecognized "
literal|"command '%s'\n"
argument_list|)
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|mnttab_file
argument_list|)
expr_stmt|;
name|libzfs_fini
argument_list|(
name|g_zfs
argument_list|)
expr_stmt|;
comment|/* 	 * The 'ZFS_ABORT' environment variable causes us to dump core on exit 	 * for the purposes of running ::findleaks. 	 */
if|if
condition|(
name|getenv
argument_list|(
literal|"ZFS_ABORT"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dumping core by request\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

