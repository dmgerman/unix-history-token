begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<dtrace.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<libproc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|dtrace_cmd
block|{
name|void
function_decl|(
modifier|*
name|dc_func
function_decl|)
parameter_list|(
name|struct
name|dtrace_cmd
modifier|*
parameter_list|)
function_decl|;
comment|/* function to compile arg */
name|dtrace_probespec_t
name|dc_spec
decl_stmt|;
comment|/* probe specifier context */
name|char
modifier|*
name|dc_arg
decl_stmt|;
comment|/* argument from main argv */
specifier|const
name|char
modifier|*
name|dc_name
decl_stmt|;
comment|/* name for error messages */
specifier|const
name|char
modifier|*
name|dc_desc
decl_stmt|;
comment|/* desc for error messages */
name|dtrace_prog_t
modifier|*
name|dc_prog
decl_stmt|;
comment|/* program compiled from arg */
name|char
name|dc_ofile
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* derived output file name */
block|}
name|dtrace_cmd_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DMODE_VERS
value|0
end_define

begin_comment
comment|/* display version information and exit (-V) */
end_comment

begin_define
define|#
directive|define
name|DMODE_EXEC
value|1
end_define

begin_comment
comment|/* compile program for enabling (-a/e/E) */
end_comment

begin_define
define|#
directive|define
name|DMODE_ANON
value|2
end_define

begin_comment
comment|/* compile program for anonymous tracing (-A) */
end_comment

begin_define
define|#
directive|define
name|DMODE_LINK
value|3
end_define

begin_comment
comment|/* compile program for linking with ELF (-G) */
end_comment

begin_define
define|#
directive|define
name|DMODE_LIST
value|4
end_define

begin_comment
comment|/* compile program and list probes (-l) */
end_comment

begin_define
define|#
directive|define
name|DMODE_HEADER
value|5
end_define

begin_comment
comment|/* compile program for headergen (-h) */
end_comment

begin_define
define|#
directive|define
name|E_SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|E_ERROR
value|1
end_define

begin_define
define|#
directive|define
name|E_USAGE
value|2
end_define

begin_define
define|#
directive|define
name|IMPATIENT_LIMIT
value|2
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|DTRACE_OPTSTR
index|[]
init|=
literal|"3:6:aAb:Bc:CD:ef:FGhHi:I:lL:m:n:o:p:P:qs:SU:vVwx:X:Z"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|g_argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|g_objv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_objc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_cmd_t
modifier|*
name|g_cmdv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_cmdc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ps_prochandle
modifier|*
modifier|*
name|g_psv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_psc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_pslive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|g_pname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_quiet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_flowindent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_impatient
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_newline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_total
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_cflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_oflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_exec
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_mode
init|=
name|DMODE_EXEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_status
init|=
name|E_SUCCESS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_grabanon
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|g_ofile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|g_ofp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_hdl_t
modifier|*
name|g_dtp
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|g_etcfile
init|=
literal|"/etc/system"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|g_etcbegin
init|=
literal|"* vvvv Added by DTrace"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|g_etcend
init|=
literal|"* ^^^^ Added by DTrace"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|g_etc
index|[]
init|=
block|{
literal|"*"
block|,
literal|"* The following forceload directives were added by dtrace(1M) to allow for"
block|,
literal|"* tracing during boot.  If these directives are removed, the system will"
block|,
literal|"* continue to function, but tracing will not occur during boot as desired."
block|,
literal|"* To remove these directives (and this block comment) automatically, run"
block|,
literal|"* \"dtrace -A\" without additional arguments.  See the \"Anonymous Tracing\""
block|,
literal|"* chapter of the Solaris Dynamic Tracing Guide for details."
block|,
literal|"*"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|usage
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|predact
index|[]
init|=
literal|"[[ predicate ] action ]"
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Usage: %s [-32|-64] [-aACeFGhHlqSvVwZ] "
literal|"[-b bufsz] [-c cmd] [-D name[=def]]\n\t[-I path] [-L path] "
literal|"[-o output] [-p pid] [-s script] [-U name]\n\t"
literal|"[-x opt[=val]] [-X a|c|s|t]\n\n"
literal|"\t[-P provider %s]\n"
literal|"\t[-m [ provider: ] module %s]\n"
literal|"\t[-f [[ provider: ] module: ] func %s]\n"
literal|"\t[-n [[[ provider: ] module: ] func: ] name %s]\n"
literal|"\t[-i probe-id %s] [ args ... ]\n\n"
argument_list|,
name|g_pname
argument_list|,
name|predact
argument_list|,
name|predact
argument_list|,
name|predact
argument_list|,
name|predact
argument_list|,
name|predact
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tpredicate -> '/' D-expression '/'\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t   action -> '{' D-statements '}'\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
literal|"\t-32 generate 32-bit D programs and ELF files\n"
literal|"\t-64 generate 64-bit D programs and ELF files\n\n"
literal|"\t-a  claim anonymous tracing state\n"
literal|"\t-A  generate driver.conf(4) directives for anonymous tracing\n"
literal|"\t-b  set trace buffer size\n"
literal|"\t-c  run specified command and exit upon its completion\n"
literal|"\t-C  run cpp(1) preprocessor on script files\n"
literal|"\t-D  define symbol when invoking preprocessor\n"
literal|"\t-e  exit after compiling request but prior to enabling probes\n"
literal|"\t-f  enable or list probes matching the specified function name\n"
literal|"\t-F  coalesce trace output by function\n"
literal|"\t-G  generate an ELF file containing embedded dtrace program\n"
literal|"\t-h  generate a header file with definitions for static probes\n"
literal|"\t-H  print included files when invoking preprocessor\n"
literal|"\t-i  enable or list probes matching the specified probe id\n"
literal|"\t-I  add include directory to preprocessor search path\n"
literal|"\t-l  list probes matching specified criteria\n"
literal|"\t-L  add library directory to library search path\n"
literal|"\t-m  enable or list probes matching the specified module name\n"
literal|"\t-n  enable or list probes matching the specified probe name\n"
literal|"\t-o  set output file\n"
literal|"\t-p  grab specified process-ID and cache its symbol tables\n"
literal|"\t-P  enable or list probes matching the specified provider name\n"
literal|"\t-q  set quiet mode (only output explicitly traced data)\n"
literal|"\t-s  enable or list probes according to the specified D script\n"
literal|"\t-S  print D compiler intermediate code\n"
literal|"\t-U  undefine symbol when invoking preprocessor\n"
literal|"\t-v  set verbose mode (report stability attributes, arguments)\n"
literal|"\t-V  report DTrace API version\n"
literal|"\t-w  permit destructive actions\n"
literal|"\t-x  enable or modify compiler and tracing options\n"
literal|"\t-X  specify ISO C conformance settings for preprocessor\n"
literal|"\t-Z  permit probe descriptions that match zero probes\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_USAGE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|verror
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|int
name|error
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|g_pname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|strlen
argument_list|(
name|fmt
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE1*/
end_comment

begin_function
specifier|static
name|void
name|fatal
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|verror
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|E_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE1*/
end_comment

begin_function
specifier|static
name|void
name|dfatal
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|NEED_ERRLOC
argument_list|)
name|char
modifier|*
name|p_errfile
init|=
name|NULL
decl_stmt|;
name|int
name|errline
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|g_pname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|!=
name|NULL
operator|&&
name|fmt
index|[
name|strlen
argument_list|(
name|fmt
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|dtrace_errmsg
argument_list|(
name|g_dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|g_dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|dtrace_errmsg
argument_list|(
name|g_dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|g_dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|NEED_ERRLOC
argument_list|)
name|dt_get_errloc
argument_list|(
name|g_dtp
argument_list|,
operator|&
name|p_errfile
argument_list|,
operator|&
name|errline
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_errfile
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"File '%s', line %d\n"
argument_list|,
name|p_errfile
argument_list|,
name|errline
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Close the DTrace handle to ensure that any controlled processes are 	 * correctly restored and continued. 	 */
name|dtrace_close
argument_list|(
name|g_dtp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|E_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE1*/
end_comment

begin_function
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|verror
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE1*/
end_comment

begin_function
specifier|static
name|void
name|notice
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|g_quiet
condition|)
return|return;
comment|/* -q or quiet pragma suppresses notice()s */
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|verror
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE1*/
end_comment

begin_function
specifier|static
name|void
name|oprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|g_ofp
operator|==
name|NULL
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|n
operator|=
name|vfprintf
argument_list|(
name|g_ofp
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|fatal
argument_list|(
literal|"failed to write to %s"
argument_list|,
name|g_ofile
condition|?
name|g_ofile
else|:
literal|"<stdout>"
argument_list|)
expr_stmt|;
block|}
name|clearerr
argument_list|(
name|g_ofp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|make_argv
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ws
init|=
literal|"\f\n\r\t\v "
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|/
literal|2
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|p
operator|=
name|strtok
argument_list|(
name|s
argument_list|,
name|ws
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|ws
argument_list|)
control|)
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|s
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|argv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dof_prune
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|size_t
name|sz
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|mark
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|msg
init|=
literal|0
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * This is okay only if the file doesn't exist at all. 		 */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|fatal
argument_list|(
literal|"failed to open %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"failed to fstat %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
operator|(
name|sz
operator|=
name|sbuf
operator|.
name|st_size
operator|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"failed to allocate memory for %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
operator|!=
name|sz
condition|)
name|fatal
argument_list|(
literal|"failed to read %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|buf
index|[
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"failed to open %s for writing"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
literal|"dof-data-"
argument_list|)
expr_stmt|;
for|for
control|(
name|mark
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|buf
index|[
name|i
index|]
argument_list|,
literal|"dof-data-"
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* 		 * This is only a match if it's in the 0th column. 		 */
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
continue|continue;
if|if
condition|(
name|msg
operator|++
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"cleaned up old anonymous "
literal|"enabling in %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We have a match.  First write out our data up until now. 		 */
if|if
condition|(
name|i
operator|!=
name|mark
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|buf
index|[
name|mark
index|]
argument_list|,
name|i
operator|-
name|mark
argument_list|)
operator|!=
name|i
operator|-
name|mark
condition|)
name|fatal
argument_list|(
literal|"failed to write to %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now scan forward until we scan past a newline. 		 */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|sz
operator|&&
name|buf
index|[
name|j
index|]
operator|!=
literal|'\n'
condition|;
name|j
operator|++
control|)
continue|continue;
comment|/* 		 * Reset our mark. 		 */
if|if
condition|(
operator|(
name|mark
operator|=
name|j
operator|+
literal|1
operator|)
operator|>=
name|sz
condition|)
break|break;
name|i
operator|=
name|j
expr_stmt|;
block|}
if|if
condition|(
name|mark
operator|<
name|sz
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|buf
index|[
name|mark
index|]
argument_list|,
name|sz
operator|-
name|mark
argument_list|)
operator|!=
name|sz
operator|-
name|mark
condition|)
name|fatal
argument_list|(
literal|"failed to write to %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_function
specifier|static
name|void
name|etcsystem_prune
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|fname
init|=
name|g_etcfile
decl_stmt|,
modifier|*
name|tmpname
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"failed to open %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"failed to fstat %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
operator|(
name|sz
operator|=
name|sbuf
operator|.
name|st_size
operator|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"failed to allocate memory for %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
operator|!=
name|sz
condition|)
name|fatal
argument_list|(
literal|"failed to read %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|buf
index|[
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|start
operator|=
name|strstr
argument_list|(
name|buf
argument_list|,
name|g_etcbegin
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|!=
name|sz
condition|)
block|{
name|fatal
argument_list|(
literal|"embedded nul byte in %s; manual repair of %s "
literal|"required\n"
argument_list|,
name|fname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|start
operator|+
literal|1
argument_list|,
name|g_etcbegin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"multiple start sentinels in %s; manual repair of %s "
literal|"required\n"
argument_list|,
name|fname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|end
operator|=
name|strstr
argument_list|(
name|buf
argument_list|,
name|g_etcend
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"missing end sentinel in %s; manual repair of %s "
literal|"required\n"
argument_list|,
name|fname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|>
name|end
condition|)
block|{
name|fatal
argument_list|(
literal|"end sentinel preceeds start sentinel in %s; manual "
literal|"repair of %s required\n"
argument_list|,
name|fname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
name|end
operator|+=
name|strlen
argument_list|(
name|g_etcend
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|end
argument_list|,
name|start
argument_list|,
name|strlen
argument_list|(
name|end
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tmpname
operator|=
name|alloca
argument_list|(
name|sz
operator|=
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tmpname
argument_list|,
name|sz
argument_list|,
literal|"%s.dtrace.%d"
argument_list|,
name|fname
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|tmpname
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|sbuf
operator|.
name|st_mode
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"failed to create %s"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|<
name|strlen
argument_list|(
name|buf
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"failed to write to %s"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|chown
argument_list|(
name|tmpname
argument_list|,
name|sbuf
operator|.
name|st_uid
argument_list|,
name|sbuf
operator|.
name|st_gid
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"failed to chown(2) %s to uid %d, gid %d"
argument_list|,
name|tmpname
argument_list|,
operator|(
name|int
operator|)
name|sbuf
operator|.
name|st_uid
argument_list|,
operator|(
name|int
operator|)
name|sbuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rename
argument_list|(
name|tmpname
argument_list|,
name|fname
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"rename of %s to %s failed"
argument_list|,
name|tmpname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"cleaned up forceload directives in %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|etcsystem_add
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|mods
index|[
literal|20
index|]
decl_stmt|;
name|int
name|nmods
decl_stmt|,
name|line
decl_stmt|;
if|if
condition|(
operator|(
name|g_ofp
operator|=
name|fopen
argument_list|(
name|g_ofile
operator|=
name|g_etcfile
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"failed to open output file '%s'"
argument_list|,
name|g_ofile
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"%s\n"
argument_list|,
name|g_etcbegin
argument_list|)
expr_stmt|;
for|for
control|(
name|line
operator|=
literal|0
init|;
name|g_etc
index|[
name|line
index|]
operator|!=
name|NULL
condition|;
name|line
operator|++
control|)
name|oprintf
argument_list|(
literal|"%s\n"
argument_list|,
name|g_etc
index|[
name|line
index|]
argument_list|)
expr_stmt|;
name|nmods
operator|=
name|dtrace_provider_modules
argument_list|(
name|g_dtp
argument_list|,
name|mods
argument_list|,
sizeof|sizeof
argument_list|(
name|mods
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmods
operator|>=
sizeof|sizeof
argument_list|(
name|mods
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"unexpectedly large number of modules!"
argument_list|)
expr_stmt|;
name|mods
index|[
name|nmods
operator|++
index|]
operator|=
literal|"dtrace"
expr_stmt|;
for|for
control|(
name|line
operator|=
literal|0
init|;
name|line
operator|<
name|nmods
condition|;
name|line
operator|++
control|)
name|oprintf
argument_list|(
literal|"forceload: drv/%s\n"
argument_list|,
name|mods
index|[
name|line
index|]
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"%s\n"
argument_list|,
name|g_etcend
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|g_ofp
argument_list|)
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
literal|"failed to close output file '%s'"
argument_list|,
name|g_ofile
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"added forceload directives to %s\n"
argument_list|,
name|g_ofile
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|print_probe_info
parameter_list|(
specifier|const
name|dtrace_probeinfo_t
modifier|*
name|p
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|oprintf
argument_list|(
literal|"\n\tProbe Description Attributes\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\t\tIdentifier Names: %s\n"
argument_list|,
name|dtrace_stability_name
argument_list|(
name|p
operator|->
name|dtp_attr
operator|.
name|dtat_name
argument_list|)
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\t\tData Semantics:   %s\n"
argument_list|,
name|dtrace_stability_name
argument_list|(
name|p
operator|->
name|dtp_attr
operator|.
name|dtat_data
argument_list|)
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\t\tDependency Class: %s\n"
argument_list|,
name|dtrace_class_name
argument_list|(
name|p
operator|->
name|dtp_attr
operator|.
name|dtat_class
argument_list|)
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\n\tArgument Attributes\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\t\tIdentifier Names: %s\n"
argument_list|,
name|dtrace_stability_name
argument_list|(
name|p
operator|->
name|dtp_arga
operator|.
name|dtat_name
argument_list|)
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\t\tData Semantics:   %s\n"
argument_list|,
name|dtrace_stability_name
argument_list|(
name|p
operator|->
name|dtp_arga
operator|.
name|dtat_data
argument_list|)
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\t\tDependency Class: %s\n"
argument_list|,
name|dtrace_class_name
argument_list|(
name|p
operator|->
name|dtp_arga
operator|.
name|dtat_class
argument_list|)
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\n\tArgument Types\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|dtp_argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctf_type_name
argument_list|(
name|p
operator|->
name|dtp_argv
index|[
name|i
index|]
operator|.
name|dtt_ctfp
argument_list|,
name|p
operator|->
name|dtp_argv
index|[
name|i
index|]
operator|.
name|dtt_type
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"(unknown)"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\t\targs[%d]: %s\n"
argument_list|,
name|i
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|dtp_argc
operator|==
literal|0
condition|)
name|oprintf
argument_list|(
literal|"\t\tNone\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|info_stmt
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_prog_t
modifier|*
name|pgp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|stp
parameter_list|,
name|dtrace_ecbdesc_t
modifier|*
modifier|*
name|last
parameter_list|)
block|{
name|dtrace_ecbdesc_t
modifier|*
name|edp
init|=
name|stp
operator|->
name|dtsd_ecbdesc
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
name|pdp
init|=
operator|&
name|edp
operator|->
name|dted_probe
decl_stmt|;
name|dtrace_probeinfo_t
name|p
decl_stmt|;
if|if
condition|(
name|edp
operator|==
operator|*
name|last
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|oprintf
argument_list|(
literal|"\n%s:%s:%s:%s\n"
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|,
name|pdp
operator|->
name|dtpd_mod
argument_list|,
name|pdp
operator|->
name|dtpd_func
argument_list|,
name|pdp
operator|->
name|dtpd_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_probe_info
argument_list|(
name|dtp
argument_list|,
name|pdp
argument_list|,
operator|&
name|p
argument_list|)
operator|==
literal|0
condition|)
name|print_probe_info
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
operator|*
name|last
operator|=
name|edp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Execute the specified program by enabling the corresponding instrumentation.  * If -e has been specified, we get the program info but do not enable it.  If  * -v has been specified, we print a stability report for the program.  */
end_comment

begin_function
specifier|static
name|void
name|exec_prog
parameter_list|(
specifier|const
name|dtrace_cmd_t
modifier|*
name|dcp
parameter_list|)
block|{
name|dtrace_ecbdesc_t
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
name|dtrace_proginfo_t
name|dpi
decl_stmt|;
if|if
condition|(
operator|!
name|g_exec
condition|)
block|{
name|dtrace_program_info
argument_list|(
name|g_dtp
argument_list|,
name|dcp
operator|->
name|dc_prog
argument_list|,
operator|&
name|dpi
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dtrace_program_exec
argument_list|(
name|g_dtp
argument_list|,
name|dcp
operator|->
name|dc_prog
argument_list|,
operator|&
name|dpi
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|dfatal
argument_list|(
literal|"failed to enable '%s'"
argument_list|,
name|dcp
operator|->
name|dc_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notice
argument_list|(
literal|"%s '%s' matched %u probe%s\n"
argument_list|,
name|dcp
operator|->
name|dc_desc
argument_list|,
name|dcp
operator|->
name|dc_name
argument_list|,
name|dpi
operator|.
name|dpi_matches
argument_list|,
name|dpi
operator|.
name|dpi_matches
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g_verbose
condition|)
block|{
name|oprintf
argument_list|(
literal|"\nStability attributes for %s %s:\n"
argument_list|,
name|dcp
operator|->
name|dc_desc
argument_list|,
name|dcp
operator|->
name|dc_name
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\n\tMinimum Probe Description Attributes\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\t\tIdentifier Names: %s\n"
argument_list|,
name|dtrace_stability_name
argument_list|(
name|dpi
operator|.
name|dpi_descattr
operator|.
name|dtat_name
argument_list|)
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\t\tData Semantics:   %s\n"
argument_list|,
name|dtrace_stability_name
argument_list|(
name|dpi
operator|.
name|dpi_descattr
operator|.
name|dtat_data
argument_list|)
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\t\tDependency Class: %s\n"
argument_list|,
name|dtrace_class_name
argument_list|(
name|dpi
operator|.
name|dpi_descattr
operator|.
name|dtat_class
argument_list|)
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\n\tMinimum Statement Attributes\n"
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\t\tIdentifier Names: %s\n"
argument_list|,
name|dtrace_stability_name
argument_list|(
name|dpi
operator|.
name|dpi_stmtattr
operator|.
name|dtat_name
argument_list|)
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\t\tData Semantics:   %s\n"
argument_list|,
name|dtrace_stability_name
argument_list|(
name|dpi
operator|.
name|dpi_stmtattr
operator|.
name|dtat_data
argument_list|)
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\t\tDependency Class: %s\n"
argument_list|,
name|dtrace_class_name
argument_list|(
name|dpi
operator|.
name|dpi_stmtattr
operator|.
name|dtat_class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_exec
condition|)
block|{
operator|(
name|void
operator|)
name|dtrace_stmt_iter
argument_list|(
name|g_dtp
argument_list|,
name|dcp
operator|->
name|dc_prog
argument_list|,
operator|(
name|dtrace_stmt_f
operator|*
operator|)
name|info_stmt
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
block|}
else|else
name|oprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|g_total
operator|+=
name|dpi
operator|.
name|dpi_matches
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out the specified DOF buffer as a set of ASCII bytes appropriate for  * storing in a driver.conf(4) file associated with the dtrace driver.  */
end_comment

begin_function
specifier|static
name|void
name|anon_prog
parameter_list|(
specifier|const
name|dtrace_cmd_t
modifier|*
name|dcp
parameter_list|,
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|const
name|uchar_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|dof
operator|==
name|NULL
condition|)
name|dfatal
argument_list|(
literal|"failed to create DOF image for '%s'"
argument_list|,
name|dcp
operator|->
name|dc_name
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|uchar_t
operator|*
operator|)
name|dof
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|dof
operator|->
name|dofh_loadsz
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|oprintf
argument_list|(
literal|"dof-data-%d=0x%x"
argument_list|,
name|n
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|q
condition|)
name|oprintf
argument_list|(
literal|",0x%x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * On FreeBSD, the DOF data is handled as a kernel environment (kenv) 	 * string. We use two hex characters per DOF byte. 	 */
name|oprintf
argument_list|(
literal|"dof-data-%d=%02x"
argument_list|,
name|n
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|q
condition|)
name|oprintf
argument_list|(
literal|"%02x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dtrace_dof_destroy
argument_list|(
name|g_dtp
argument_list|,
name|dof
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Link the specified D program in DOF form into an ELF file for use in either  * helpers, userland provider definitions, or both.  If -o was specified, that  * path is used as the output file name.  If -o wasn't specified and the input  * program is from a script whose name is %.d, use basename(%.o) as the output  * file name.  Otherwise we use "d.out" as the default output file name.  */
end_comment

begin_function
specifier|static
name|void
name|link_prog
parameter_list|(
name|dtrace_cmd_t
modifier|*
name|dcp
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|g_cmdc
operator|==
literal|1
operator|&&
name|g_ofile
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dcp
operator|->
name|dc_ofile
argument_list|,
name|g_ofile
argument_list|,
sizeof|sizeof
argument_list|(
name|dcp
operator|->
name|dc_ofile
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|dcp
operator|->
name|dc_arg
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".d"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* strip .d suffix */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|dcp
operator|->
name|dc_ofile
argument_list|,
sizeof|sizeof
argument_list|(
name|dcp
operator|->
name|dc_ofile
argument_list|)
argument_list|,
literal|"%s.o"
argument_list|,
name|basename
argument_list|(
name|dcp
operator|->
name|dc_arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g_cmdc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|dcp
operator|->
name|dc_ofile
argument_list|,
sizeof|sizeof
argument_list|(
name|dcp
operator|->
name|dc_ofile
argument_list|)
argument_list|,
literal|"d.out.%td"
argument_list|,
name|dcp
operator|-
name|g_cmdv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|dcp
operator|->
name|dc_ofile
argument_list|,
sizeof|sizeof
argument_list|(
name|dcp
operator|->
name|dc_ofile
argument_list|)
argument_list|,
literal|"d.out"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_program_link
argument_list|(
name|g_dtp
argument_list|,
name|dcp
operator|->
name|dc_prog
argument_list|,
name|DTRACE_D_PROBES
argument_list|,
name|dcp
operator|->
name|dc_ofile
argument_list|,
name|g_objc
argument_list|,
name|g_objv
argument_list|)
operator|!=
literal|0
condition|)
name|dfatal
argument_list|(
literal|"failed to link %s %s"
argument_list|,
name|dcp
operator|->
name|dc_desc
argument_list|,
name|dcp
operator|->
name|dc_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|list_probe
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_probeinfo_t
name|p
decl_stmt|;
name|oprintf
argument_list|(
literal|"%5d %10s %17s %33s %s\n"
argument_list|,
name|pdp
operator|->
name|dtpd_id
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|,
name|pdp
operator|->
name|dtpd_mod
argument_list|,
name|pdp
operator|->
name|dtpd_func
argument_list|,
name|pdp
operator|->
name|dtpd_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_verbose
operator|&&
name|dtrace_probe_info
argument_list|(
name|dtp
argument_list|,
name|pdp
argument_list|,
operator|&
name|p
argument_list|)
operator|==
literal|0
condition|)
name|print_probe_info
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|list_stmt
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_prog_t
modifier|*
name|pgp
parameter_list|,
name|dtrace_stmtdesc_t
modifier|*
name|stp
parameter_list|,
name|dtrace_ecbdesc_t
modifier|*
modifier|*
name|last
parameter_list|)
block|{
name|dtrace_ecbdesc_t
modifier|*
name|edp
init|=
name|stp
operator|->
name|dtsd_ecbdesc
decl_stmt|;
if|if
condition|(
name|edp
operator|==
operator|*
name|last
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dtrace_probe_iter
argument_list|(
name|g_dtp
argument_list|,
operator|&
name|edp
operator|->
name|dted_probe
argument_list|,
name|list_probe
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"failed to match %s:%s:%s:%s: %s\n"
argument_list|,
name|edp
operator|->
name|dted_probe
operator|.
name|dtpd_provider
argument_list|,
name|edp
operator|->
name|dted_probe
operator|.
name|dtpd_mod
argument_list|,
name|edp
operator|->
name|dted_probe
operator|.
name|dtpd_func
argument_list|,
name|edp
operator|->
name|dted_probe
operator|.
name|dtpd_name
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|last
operator|=
name|edp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * List the probes corresponding to the specified program by iterating over  * each statement and then matching probes to the statement probe descriptions.  */
end_comment

begin_function
specifier|static
name|void
name|list_prog
parameter_list|(
specifier|const
name|dtrace_cmd_t
modifier|*
name|dcp
parameter_list|)
block|{
name|dtrace_ecbdesc_t
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|dtrace_stmt_iter
argument_list|(
name|g_dtp
argument_list|,
name|dcp
operator|->
name|dc_prog
argument_list|,
operator|(
name|dtrace_stmt_f
operator|*
operator|)
name|list_stmt
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|compile_file
parameter_list|(
name|dtrace_cmd_t
modifier|*
name|dcp
parameter_list|)
block|{
name|char
modifier|*
name|arg0
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|dcp
operator|->
name|dc_arg
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"failed to open %s"
argument_list|,
name|dcp
operator|->
name|dc_arg
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|g_argv
index|[
literal|0
index|]
expr_stmt|;
name|g_argv
index|[
literal|0
index|]
operator|=
name|dcp
operator|->
name|dc_arg
expr_stmt|;
if|if
condition|(
operator|(
name|dcp
operator|->
name|dc_prog
operator|=
name|dtrace_program_fcompile
argument_list|(
name|g_dtp
argument_list|,
name|fp
argument_list|,
name|g_cflags
argument_list|,
name|g_argc
argument_list|,
name|g_argv
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dfatal
argument_list|(
literal|"failed to compile script %s"
argument_list|,
name|dcp
operator|->
name|dc_arg
argument_list|)
expr_stmt|;
name|g_argv
index|[
literal|0
index|]
operator|=
name|arg0
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|dcp
operator|->
name|dc_desc
operator|=
literal|"script"
expr_stmt|;
name|dcp
operator|->
name|dc_name
operator|=
name|dcp
operator|->
name|dc_arg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|compile_str
parameter_list|(
name|dtrace_cmd_t
modifier|*
name|dcp
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|dcp
operator|->
name|dc_prog
operator|=
name|dtrace_program_strcompile
argument_list|(
name|g_dtp
argument_list|,
name|dcp
operator|->
name|dc_arg
argument_list|,
name|dcp
operator|->
name|dc_spec
argument_list|,
name|g_cflags
operator||
name|DTRACE_C_PSPEC
argument_list|,
name|g_argc
argument_list|,
name|g_argv
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dfatal
argument_list|(
literal|"invalid probe specifier %s"
argument_list|,
name|dcp
operator|->
name|dc_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strpbrk
argument_list|(
name|dcp
operator|->
name|dc_arg
argument_list|,
literal|"{/;"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* crop name for reporting */
name|dcp
operator|->
name|dc_desc
operator|=
literal|"description"
expr_stmt|;
name|dcp
operator|->
name|dc_name
operator|=
name|dcp
operator|->
name|dc_arg
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|prochandler
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|P
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
specifier|const
name|psinfo_t
modifier|*
name|prp
init|=
name|Ppsinfo
argument_list|(
name|P
argument_list|)
decl_stmt|;
name|int
name|pid
init|=
name|Pstatus
argument_list|(
name|P
argument_list|)
operator|->
name|pr_pid
decl_stmt|;
name|char
name|name
index|[
name|SIG2STR_MAX
index|]
decl_stmt|;
else|#
directive|else
name|int
name|wstatus
init|=
name|proc_getwstat
argument_list|(
name|P
argument_list|)
decl_stmt|;
name|int
name|pid
init|=
name|proc_getpid
argument_list|(
name|P
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|notice
argument_list|(
literal|"pid %d: %s\n"
argument_list|,
name|pid
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
switch|switch
condition|(
name|Pstate
argument_list|(
name|P
argument_list|)
condition|)
block|{
else|#
directive|else
switch|switch
condition|(
name|proc_state
argument_list|(
name|P
argument_list|)
condition|)
block|{
endif|#
directive|endif
case|case
name|PS_UNDEAD
case|:
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
comment|/* 		 * Ideally we would like to always report pr_wstat here, but it 		 * isn't possible given current /proc semantics.  If we grabbed 		 * the process, Ppsinfo() will either fail or return a zeroed 		 * psinfo_t depending on how far the parent is in reaping it. 		 * When /proc provides a stable pr_wstat in the status file, 		 * this code can be improved by examining this new pr_wstat. 		 */
if|if
condition|(
name|prp
operator|!=
name|NULL
operator|&&
name|WIFSIGNALED
argument_list|(
name|prp
operator|->
name|pr_wstat
argument_list|)
condition|)
block|{
name|notice
argument_list|(
literal|"pid %d terminated by %s\n"
argument_list|,
name|pid
argument_list|,
name|proc_signame
argument_list|(
name|WTERMSIG
argument_list|(
name|prp
operator|->
name|pr_wstat
argument_list|)
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|wstatus
argument_list|)
condition|)
block|{
name|notice
argument_list|(
literal|"pid %d terminated by %d\n"
argument_list|,
name|pid
argument_list|,
name|WTERMSIG
argument_list|(
name|wstatus
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
block|}
elseif|else
if|if
condition|(
name|prp
operator|!=
name|NULL
operator|&&
name|WEXITSTATUS
argument_list|(
name|prp
operator|->
name|pr_wstat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|notice
argument_list|(
literal|"pid %d exited with status %d\n"
argument_list|,
name|pid
argument_list|,
name|WEXITSTATUS
argument_list|(
name|prp
operator|->
name|pr_wstat
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
block|}
elseif|else
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|wstatus
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|notice
argument_list|(
literal|"pid %d exited with status %d\n"
argument_list|,
name|pid
argument_list|,
name|WEXITSTATUS
argument_list|(
name|wstatus
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|notice
argument_list|(
literal|"pid %d has exited\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
name|g_pslive
operator|--
expr_stmt|;
break|break;
case|case
name|PS_LOST
case|:
name|notice
argument_list|(
literal|"pid %d exec'd a set-id or unobservable program\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|g_pslive
operator|--
expr_stmt|;
break|break;
block|}
block|}
comment|/*ARGSUSED*/
specifier|static
name|int
name|errhandler
parameter_list|(
specifier|const
name|dtrace_errdata_t
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|error
argument_list|(
name|data
operator|->
name|dteda_msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|DTRACE_HANDLE_OK
operator|)
return|;
block|}
comment|/*ARGSUSED*/
specifier|static
name|int
name|drophandler
parameter_list|(
specifier|const
name|dtrace_dropdata_t
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|error
argument_list|(
name|data
operator|->
name|dtdda_msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|DTRACE_HANDLE_OK
operator|)
return|;
block|}
comment|/*ARGSUSED*/
specifier|static
name|int
name|setopthandler
parameter_list|(
specifier|const
name|dtrace_setoptdata_t
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|data
operator|->
name|dtsda_option
argument_list|,
literal|"quiet"
argument_list|)
operator|==
literal|0
condition|)
name|g_quiet
operator|=
name|data
operator|->
name|dtsda_newval
operator|!=
name|DTRACEOPT_UNSET
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|data
operator|->
name|dtsda_option
argument_list|,
literal|"flowindent"
argument_list|)
operator|==
literal|0
condition|)
name|g_flowindent
operator|=
name|data
operator|->
name|dtsda_newval
operator|!=
name|DTRACEOPT_UNSET
expr_stmt|;
return|return
operator|(
name|DTRACE_HANDLE_OK
operator|)
return|;
block|}
define|#
directive|define
name|BUFDUMPHDR
parameter_list|(
name|hdr
parameter_list|)
define|\
value|(void) printf("%s: %s%s\n", g_pname, hdr, strlen(hdr)> 0 ? ":" : "");
define|#
directive|define
name|BUFDUMPSTR
parameter_list|(
name|ptr
parameter_list|,
name|field
parameter_list|)
define|\
value|(void) printf("%s: %20s => ", g_pname, #field);	\ 	if ((ptr)->field != NULL) {			\ 		const char *c = (ptr)->field;		\ 		(void) printf("\"");			\ 		do {					\ 			if (*c == '\n') {		\ 				(void) printf("\\n");	\ 				continue;		\ 			}				\ 							\ 			(void) printf("%c", *c);	\ 		} while (*c++ != '\0');			\ 		(void) printf("\"\n");			\ 	} else {					\ 		(void) printf("<NULL>\n");		\ 	}
define|#
directive|define
name|BUFDUMPASSTR
parameter_list|(
name|ptr
parameter_list|,
name|field
parameter_list|,
name|str
parameter_list|)
define|\
value|(void) printf("%s: %20s => %s\n", g_pname, #field, str);
define|#
directive|define
name|BUFDUMP
parameter_list|(
name|ptr
parameter_list|,
name|field
parameter_list|)
define|\
value|(void) printf("%s: %20s => %lld\n", g_pname, #field, \ 	    (long long)(ptr)->field);
define|#
directive|define
name|BUFDUMPPTR
parameter_list|(
name|ptr
parameter_list|,
name|field
parameter_list|)
define|\
value|(void) printf("%s: %20s => %s\n", g_pname, #field, \ 	    (ptr)->field != NULL ? "<non-NULL>" : "<NULL>");
comment|/*ARGSUSED*/
specifier|static
name|int
name|bufhandler
parameter_list|(
specifier|const
name|dtrace_bufdata_t
modifier|*
name|bufdata
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|dtrace_aggdata_t
modifier|*
name|agg
init|=
name|bufdata
operator|->
name|dtbda_aggdata
decl_stmt|;
specifier|const
name|dtrace_recdesc_t
modifier|*
name|rec
init|=
name|bufdata
operator|->
name|dtbda_recdesc
decl_stmt|;
specifier|const
name|dtrace_probedesc_t
modifier|*
name|pd
decl_stmt|;
name|uint32_t
name|flags
init|=
name|bufdata
operator|->
name|dtbda_flags
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|c
init|=
name|buf
decl_stmt|,
modifier|*
name|end
init|=
name|c
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|printed
decl_stmt|;
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
block|}
name|flagnames
index|[]
init|=
block|{
block|{
literal|"AGGVAL"
block|,
name|DTRACE_BUFDATA_AGGVAL
block|}
block|,
block|{
literal|"AGGKEY"
block|,
name|DTRACE_BUFDATA_AGGKEY
block|}
block|,
block|{
literal|"AGGFORMAT"
block|,
name|DTRACE_BUFDATA_AGGFORMAT
block|}
block|,
block|{
literal|"AGGLAST"
block|,
name|DTRACE_BUFDATA_AGGLAST
block|}
block|,
block|{
literal|"???"
block|,
name|UINT32_MAX
block|}
block|,
block|{
name|NULL
block|}
block|}
struct|;
if|if
condition|(
name|bufdata
operator|->
name|dtbda_probe
operator|!=
name|NULL
condition|)
block|{
name|pd
operator|=
name|bufdata
operator|->
name|dtbda_probe
operator|->
name|dtpda_pdesc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|agg
operator|!=
name|NULL
condition|)
block|{
name|pd
operator|=
name|agg
operator|->
name|dtada_pdesc
expr_stmt|;
block|}
else|else
block|{
name|pd
operator|=
name|NULL
expr_stmt|;
block|}
name|BUFDUMPHDR
argument_list|(
literal|">>> Called buffer handler"
argument_list|)
expr_stmt|;
name|BUFDUMPHDR
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|BUFDUMPHDR
argument_list|(
literal|"  dtrace_bufdata"
argument_list|)
expr_stmt|;
name|BUFDUMPSTR
argument_list|(
name|bufdata
argument_list|,
name|dtbda_buffered
argument_list|)
expr_stmt|;
name|BUFDUMPPTR
argument_list|(
name|bufdata
argument_list|,
name|dtbda_probe
argument_list|)
expr_stmt|;
name|BUFDUMPPTR
argument_list|(
name|bufdata
argument_list|,
name|dtbda_aggdata
argument_list|)
expr_stmt|;
name|BUFDUMPPTR
argument_list|(
name|bufdata
argument_list|,
name|dtbda_recdesc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
name|end
operator|-
name|c
argument_list|,
literal|"0x%x "
argument_list|,
name|bufdata
operator|->
name|dtbda_flags
argument_list|)
expr_stmt|;
name|c
operator|+=
name|strlen
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|printed
operator|=
literal|0
init|;
name|flagnames
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|flagnames
index|[
name|i
index|]
operator|.
name|value
operator|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
name|end
operator|-
name|c
argument_list|,
literal|"%s%s"
argument_list|,
name|printed
operator|++
condition|?
literal|" | "
else|:
literal|"("
argument_list|,
name|flagnames
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|c
operator|+=
name|strlen
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|flagnames
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
if|if
condition|(
name|printed
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
name|end
operator|-
name|c
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|BUFDUMPASSTR
argument_list|(
name|bufdata
argument_list|,
name|dtbda_flags
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|BUFDUMPHDR
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|!=
name|NULL
condition|)
block|{
name|BUFDUMPHDR
argument_list|(
literal|"  dtrace_probedesc"
argument_list|)
expr_stmt|;
name|BUFDUMPSTR
argument_list|(
name|pd
argument_list|,
name|dtpd_provider
argument_list|)
expr_stmt|;
name|BUFDUMPSTR
argument_list|(
name|pd
argument_list|,
name|dtpd_mod
argument_list|)
expr_stmt|;
name|BUFDUMPSTR
argument_list|(
name|pd
argument_list|,
name|dtpd_func
argument_list|)
expr_stmt|;
name|BUFDUMPSTR
argument_list|(
name|pd
argument_list|,
name|dtpd_name
argument_list|)
expr_stmt|;
name|BUFDUMPHDR
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rec
operator|!=
name|NULL
condition|)
block|{
name|BUFDUMPHDR
argument_list|(
literal|"  dtrace_recdesc"
argument_list|)
expr_stmt|;
name|BUFDUMP
argument_list|(
name|rec
argument_list|,
name|dtrd_action
argument_list|)
expr_stmt|;
name|BUFDUMP
argument_list|(
name|rec
argument_list|,
name|dtrd_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|agg
operator|!=
name|NULL
condition|)
block|{
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|int
name|lim
init|=
name|rec
operator|->
name|dtrd_size
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d (data: "
argument_list|,
name|rec
operator|->
name|dtrd_offset
argument_list|)
expr_stmt|;
name|c
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|lim
operator|>
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
name|lim
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|agg
operator|->
name|dtada_data
operator|+
name|rec
operator|->
name|dtrd_offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
name|end
operator|-
name|c
argument_list|,
literal|"%s%02x"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|""
else|:
literal|" "
argument_list|,
operator|*
name|data
operator|++
argument_list|)
expr_stmt|;
name|c
operator|+=
name|strlen
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
name|end
operator|-
name|c
argument_list|,
literal|"%s)"
argument_list|,
name|lim
operator|<
name|rec
operator|->
name|dtrd_size
condition|?
literal|" ..."
else|:
literal|""
argument_list|)
expr_stmt|;
name|BUFDUMPASSTR
argument_list|(
name|rec
argument_list|,
name|dtrd_offset
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BUFDUMP
argument_list|(
name|rec
argument_list|,
name|dtrd_offset
argument_list|)
expr_stmt|;
block|}
name|BUFDUMPHDR
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|agg
operator|!=
name|NULL
condition|)
block|{
name|dtrace_aggdesc_t
modifier|*
name|desc
init|=
name|agg
operator|->
name|dtada_desc
decl_stmt|;
name|BUFDUMPHDR
argument_list|(
literal|"  dtrace_aggdesc"
argument_list|)
expr_stmt|;
name|BUFDUMPSTR
argument_list|(
name|desc
argument_list|,
name|dtagd_name
argument_list|)
expr_stmt|;
name|BUFDUMP
argument_list|(
name|desc
argument_list|,
name|dtagd_varid
argument_list|)
expr_stmt|;
name|BUFDUMP
argument_list|(
name|desc
argument_list|,
name|dtagd_id
argument_list|)
expr_stmt|;
name|BUFDUMP
argument_list|(
name|desc
argument_list|,
name|dtagd_nrecs
argument_list|)
expr_stmt|;
name|BUFDUMPHDR
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|DTRACE_HANDLE_OK
operator|)
return|;
block|}
comment|/*ARGSUSED*/
specifier|static
name|int
name|chewrec
parameter_list|(
specifier|const
name|dtrace_probedata_t
modifier|*
name|data
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
name|rec
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_actkind_t
name|act
decl_stmt|;
name|uintptr_t
name|addr
decl_stmt|;
if|if
condition|(
name|rec
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We have processed the final record; output the newline if 		 * we're not in quiet mode. 		 */
if|if
condition|(
operator|!
name|g_quiet
condition|)
name|oprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DTRACE_CONSUME_NEXT
operator|)
return|;
block|}
name|act
operator|=
name|rec
operator|->
name|dtrd_action
expr_stmt|;
name|addr
operator|=
operator|(
name|uintptr_t
operator|)
name|data
operator|->
name|dtpda_data
expr_stmt|;
if|if
condition|(
name|act
operator|==
name|DTRACEACT_EXIT
condition|)
block|{
name|g_status
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
return|return
operator|(
name|DTRACE_CONSUME_NEXT
operator|)
return|;
block|}
return|return
operator|(
name|DTRACE_CONSUME_THIS
operator|)
return|;
block|}
comment|/*ARGSUSED*/
specifier|static
name|int
name|chew
parameter_list|(
specifier|const
name|dtrace_probedata_t
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_probedesc_t
modifier|*
name|pd
init|=
name|data
operator|->
name|dtpda_pdesc
decl_stmt|;
name|processorid_t
name|cpu
init|=
name|data
operator|->
name|dtpda_cpu
decl_stmt|;
specifier|static
name|int
name|heading
decl_stmt|;
if|if
condition|(
name|g_impatient
condition|)
block|{
name|g_newline
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|DTRACE_CONSUME_ABORT
operator|)
return|;
block|}
if|if
condition|(
name|heading
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|g_flowindent
condition|)
block|{
if|if
condition|(
operator|!
name|g_quiet
condition|)
block|{
name|oprintf
argument_list|(
literal|"%3s %6s %32s\n"
argument_list|,
literal|"CPU"
argument_list|,
literal|"ID"
argument_list|,
literal|"FUNCTION:NAME"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|oprintf
argument_list|(
literal|"%3s %-41s\n"
argument_list|,
literal|"CPU"
argument_list|,
literal|"FUNCTION"
argument_list|)
expr_stmt|;
block|}
name|heading
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|g_flowindent
condition|)
block|{
if|if
condition|(
operator|!
name|g_quiet
condition|)
block|{
name|char
name|name
index|[
name|DTRACE_FUNCNAMELEN
operator|+
name|DTRACE_NAMELEN
operator|+
literal|2
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s:%s"
argument_list|,
name|pd
operator|->
name|dtpd_func
argument_list|,
name|pd
operator|->
name|dtpd_name
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"%3d %6d %32s "
argument_list|,
name|cpu
argument_list|,
name|pd
operator|->
name|dtpd_id
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|indent
init|=
name|data
operator|->
name|dtpda_indent
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|dtpda_flow
operator|==
name|DTRACEFLOW_NONE
condition|)
block|{
name|len
operator|=
name|indent
operator|+
name|DTRACE_FUNCNAMELEN
operator|+
name|DTRACE_NAMELEN
operator|+
literal|5
expr_stmt|;
name|name
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
literal|"%*s%s%s:%s"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|data
operator|->
name|dtpda_prefix
argument_list|,
name|pd
operator|->
name|dtpd_func
argument_list|,
name|pd
operator|->
name|dtpd_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|indent
operator|+
name|DTRACE_FUNCNAMELEN
operator|+
literal|5
expr_stmt|;
name|name
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
literal|"%*s%s%s"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|data
operator|->
name|dtpda_prefix
argument_list|,
name|pd
operator|->
name|dtpd_func
argument_list|)
expr_stmt|;
block|}
name|oprintf
argument_list|(
literal|"%3d %-41s "
argument_list|,
name|cpu
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|DTRACE_CONSUME_THIS
operator|)
return|;
block|}
specifier|static
name|void
name|go
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|optname
decl_stmt|;
name|dtrace_optval_t
name|val
decl_stmt|;
block|}
name|bufs
index|[]
init|=
block|{
block|{
literal|"buffer size"
block|,
literal|"bufsize"
block|}
block|,
block|{
literal|"aggregation size"
block|,
literal|"aggsize"
block|}
block|,
block|{
literal|"speculation size"
block|,
literal|"specsize"
block|}
block|,
block|{
literal|"dynamic variable size"
block|,
literal|"dynvarsize"
block|}
block|,
block|{
name|NULL
block|}
block|}
struct|,
name|rates
index|[]
init|=
block|{
block|{
literal|"cleaning rate"
block|,
literal|"cleanrate"
block|}
block|,
block|{
literal|"status rate"
block|,
literal|"statusrate"
block|}
block|,
block|{
name|NULL
block|}
block|}
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bufs
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dtrace_getopt
argument_list|(
name|g_dtp
argument_list|,
name|bufs
index|[
name|i
index|]
operator|.
name|optname
argument_list|,
operator|&
name|bufs
index|[
name|i
index|]
operator|.
name|val
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"couldn't get option %s"
argument_list|,
name|bufs
index|[
name|i
index|]
operator|.
name|optname
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|rates
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dtrace_getopt
argument_list|(
name|g_dtp
argument_list|,
name|rates
index|[
name|i
index|]
operator|.
name|optname
argument_list|,
operator|&
name|rates
index|[
name|i
index|]
operator|.
name|val
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"couldn't get option %s"
argument_list|,
name|rates
index|[
name|i
index|]
operator|.
name|optname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_go
argument_list|(
name|g_dtp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfatal
argument_list|(
literal|"could not enable tracing"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bufs
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_optval_t
name|j
init|=
literal|0
decl_stmt|,
name|mul
init|=
literal|10
decl_stmt|;
name|dtrace_optval_t
name|nsize
decl_stmt|;
if|if
condition|(
name|bufs
index|[
name|i
index|]
operator|.
name|val
operator|==
name|DTRACEOPT_UNSET
condition|)
continue|continue;
operator|(
name|void
operator|)
name|dtrace_getopt
argument_list|(
name|g_dtp
argument_list|,
name|bufs
index|[
name|i
index|]
operator|.
name|optname
argument_list|,
operator|&
name|nsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsize
operator|==
name|DTRACEOPT_UNSET
operator|||
name|nsize
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|nsize
operator|>=
name|bufs
index|[
name|i
index|]
operator|.
name|val
operator|-
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
continue|continue;
for|for
control|(
init|;
operator|(
name|INT64_C
argument_list|(
literal|1
argument_list|)
operator|<<
name|mul
operator|)
operator|<=
name|nsize
condition|;
name|j
operator|++
operator|,
name|mul
operator|+=
literal|10
control|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|nsize
operator|&
operator|(
operator|(
name|INT64_C
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|mul
operator|-
literal|10
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%s lowered to %lld%c\n"
argument_list|,
name|bufs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|long
name|long
operator|)
name|nsize
operator|>>
operator|(
name|mul
operator|-
literal|10
operator|)
argument_list|,
literal|" kmgtpe"
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"%s lowered to %lld bytes\n"
argument_list|,
name|bufs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|long
name|long
operator|)
name|nsize
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|rates
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_optval_t
name|nval
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
name|rates
index|[
name|i
index|]
operator|.
name|val
operator|==
name|DTRACEOPT_UNSET
condition|)
continue|continue;
operator|(
name|void
operator|)
name|dtrace_getopt
argument_list|(
name|g_dtp
argument_list|,
name|rates
index|[
name|i
index|]
operator|.
name|optname
argument_list|,
operator|&
name|nval
argument_list|)
expr_stmt|;
if|if
condition|(
name|nval
operator|==
name|DTRACEOPT_UNSET
operator|||
name|nval
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|rates
index|[
name|i
index|]
operator|.
name|val
operator|==
name|nval
condition|)
continue|continue;
name|dir
operator|=
name|nval
operator|>
name|rates
index|[
name|i
index|]
operator|.
name|val
condition|?
literal|"reduced"
else|:
literal|"increased"
expr_stmt|;
if|if
condition|(
name|nval
operator|<=
name|NANOSEC
operator|&&
operator|(
name|NANOSEC
operator|%
name|nval
operator|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s %s to %lld hz\n"
argument_list|,
name|rates
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|dir
argument_list|,
operator|(
name|long
name|long
operator|)
name|NANOSEC
operator|/
operator|(
name|long
name|long
operator|)
name|nval
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|nval
operator|%
name|NANOSEC
operator|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s %s to once every %lld seconds\n"
argument_list|,
name|rates
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|dir
argument_list|,
operator|(
name|long
name|long
operator|)
name|nval
operator|/
operator|(
name|long
name|long
operator|)
name|NANOSEC
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|error
argument_list|(
literal|"%s %s to once every %lld nanoseconds\n"
argument_list|,
name|rates
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|dir
argument_list|,
operator|(
name|long
name|long
operator|)
name|nval
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*ARGSUSED*/
specifier|static
name|void
name|intr
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
if|if
condition|(
operator|!
name|g_intr
condition|)
name|g_newline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|g_intr
operator|++
operator|>
name|IMPATIENT_LIMIT
condition|)
name|g_impatient
operator|=
literal|1
expr_stmt|;
block|}
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|dtrace_bufdesc_t
name|buf
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|,
name|oact
decl_stmt|;
name|dtrace_status_t
name|status
index|[
literal|2
index|]
decl_stmt|;
name|dtrace_optval_t
name|opt
decl_stmt|;
name|dtrace_cmd_t
modifier|*
name|dcp
decl_stmt|;
name|g_ofp
operator|=
name|stdout
expr_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|,
name|mode
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|v
decl_stmt|;
name|struct
name|ps_prochandle
modifier|*
name|P
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|g_pname
operator|=
name|basename
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
return|return
operator|(
name|usage
argument_list|(
name|stderr
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|g_argv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|argc
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|g_cmdv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_cmd_t
argument_list|)
operator|*
name|argc
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|g_psv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ps_prochandle
operator|*
argument_list|)
operator|*
name|argc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"failed to allocate memory for arguments"
argument_list|)
expr_stmt|;
name|g_argv
index|[
name|g_argc
operator|++
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* propagate argv[0] to D as $0/$$0 */
name|argv
index|[
literal|0
index|]
operator|=
name|g_pname
expr_stmt|;
comment|/* rewrite argv[0] for getopt errors */
name|bzero
argument_list|(
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Make an initial pass through argv[] processing any arguments that 	 * affect our behavior mode (g_mode) and flags used for dtrace_open(). 	 * We also accumulate arguments that are not affiliated with getopt 	 * options into g_argv[], and abort if any invalid options are found. 	 */
for|for
control|(
name|optind
operator|=
literal|1
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|DTRACE_OPTSTR
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'3'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"2"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: illegal option -- 3%s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
operator|(
name|usage
argument_list|(
name|stderr
argument_list|)
operator|)
return|;
block|}
name|g_oflags
operator|&=
operator|~
name|DTRACE_O_LP64
expr_stmt|;
name|g_oflags
operator||=
name|DTRACE_O_ILP32
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"4"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: illegal option -- 6%s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
operator|(
name|usage
argument_list|(
name|stderr
argument_list|)
operator|)
return|;
block|}
name|g_oflags
operator|&=
operator|~
name|DTRACE_O_ILP32
expr_stmt|;
name|g_oflags
operator||=
name|DTRACE_O_LP64
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|g_grabanon
operator|++
expr_stmt|;
comment|/* also checked in pass 2 below */
break|break;
case|case
literal|'A'
case|:
name|g_mode
operator|=
name|DMODE_ANON
expr_stmt|;
name|g_exec
operator|=
literal|0
expr_stmt|;
name|mode
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|g_exec
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|g_mode
operator|=
name|DMODE_HEADER
expr_stmt|;
name|g_oflags
operator||=
name|DTRACE_O_NODEV
expr_stmt|;
name|g_cflags
operator||=
name|DTRACE_C_ZDEFS
expr_stmt|;
comment|/* -h implies -Z */
name|g_exec
operator|=
literal|0
expr_stmt|;
name|mode
operator|++
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|g_mode
operator|=
name|DMODE_LINK
expr_stmt|;
name|g_oflags
operator||=
name|DTRACE_O_NODEV
expr_stmt|;
name|g_cflags
operator||=
name|DTRACE_C_ZDEFS
expr_stmt|;
comment|/* -G implies -Z */
name|g_exec
operator|=
literal|0
expr_stmt|;
name|mode
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|g_mode
operator|=
name|DMODE_LIST
expr_stmt|;
name|g_cflags
operator||=
name|DTRACE_C_ZDEFS
expr_stmt|;
comment|/* -l implies -Z */
name|mode
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|g_mode
operator|=
name|DMODE_VERS
expr_stmt|;
name|mode
operator|++
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|strchr
argument_list|(
name|DTRACE_OPTSTR
argument_list|,
name|c
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|usage
argument_list|(
name|stderr
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|g_argv
index|[
name|g_argc
operator|++
index|]
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: only one of the [-AGhlV] options "
literal|"can be specified at a time\n"
argument_list|,
name|g_pname
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_USAGE
operator|)
return|;
block|}
if|if
condition|(
name|g_mode
operator|==
name|DMODE_VERS
condition|)
return|return
operator|(
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|g_pname
argument_list|,
name|_dtrace_version
argument_list|)
operator|<=
literal|0
operator|)
return|;
comment|/* 	 * If we're in linker mode and the data model hasn't been specified, 	 * we try to guess the appropriate setting by examining the object 	 * files. We ignore certain errors since we'll catch them later when 	 * we actually process the object files. 	 */
if|if
condition|(
name|g_mode
operator|==
name|DMODE_LINK
operator|&&
operator|(
name|g_oflags
operator|&
operator|(
name|DTRACE_O_ILP32
operator||
name|DTRACE_O_LP64
operator|)
operator|)
operator|==
literal|0
operator|&&
name|elf_version
argument_list|(
name|EV_CURRENT
argument_list|)
operator|!=
name|EV_NONE
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|Elf
modifier|*
name|elf
decl_stmt|;
name|GElf_Ehdr
name|ehdr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|g_argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open64
argument_list|(
name|g_argv
index|[
name|i
index|]
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
operator|(
name|elf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|ELF_C_READ
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|elf_kind
argument_list|(
name|elf
argument_list|)
operator|!=
name|ELF_K_ELF
operator|||
name|gelf_getehdr
argument_list|(
name|elf
argument_list|,
operator|&
name|ehdr
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|elf
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|elf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|)
block|{
if|if
condition|(
name|g_oflags
operator|&
name|DTRACE_O_ILP32
condition|)
block|{
name|fatal
argument_list|(
literal|"can't mix 32-bit and 64-bit "
literal|"object files\n"
argument_list|)
expr_stmt|;
block|}
name|g_oflags
operator||=
name|DTRACE_O_LP64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS32
condition|)
block|{
if|if
condition|(
name|g_oflags
operator|&
name|DTRACE_O_LP64
condition|)
block|{
name|fatal
argument_list|(
literal|"can't mix 32-bit and 64-bit "
literal|"object files\n"
argument_list|)
expr_stmt|;
block|}
name|g_oflags
operator||=
name|DTRACE_O_ILP32
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
comment|/* 	 * Open libdtrace.  If we are not actually going to be enabling any 	 * instrumentation attempt to reopen libdtrace using DTRACE_O_NODEV. 	 */
while|while
condition|(
operator|(
name|g_dtp
operator|=
name|dtrace_open
argument_list|(
name|DTRACE_VERSION
argument_list|,
name|g_oflags
argument_list|,
operator|&
name|err
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|g_oflags
operator|&
name|DTRACE_O_NODEV
operator|)
operator|&&
operator|!
name|g_exec
operator|&&
operator|!
name|g_grabanon
condition|)
block|{
name|g_oflags
operator||=
name|DTRACE_O_NODEV
expr_stmt|;
continue|continue;
block|}
name|fatal
argument_list|(
literal|"failed to initialize dtrace: %s\n"
argument_list|,
name|dtrace_errmsg
argument_list|(
name|NULL
argument_list|,
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
comment|/* XXX The 32-bit seems to need more buffer space by default -sson */
operator|(
name|void
operator|)
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"bufsize"
argument_list|,
literal|"12m"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"aggsize"
argument_list|,
literal|"12m"
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"bufsize"
argument_list|,
literal|"4m"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"aggsize"
argument_list|,
literal|"4m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If -G is specified, enable -xlink=dynamic and -xunodefs to permit 	 * references to undefined symbols to remain as unresolved relocations. 	 * If -A is specified, enable -xlink=primary to permit static linking 	 * only to kernel symbols that are defined in a primary kernel module. 	 */
if|if
condition|(
name|g_mode
operator|==
name|DMODE_LINK
condition|)
block|{
operator|(
name|void
operator|)
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"linkmode"
argument_list|,
literal|"dynamic"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"unodefs"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Use the remaining arguments as the list of object files 		 * when in linker mode. 		 */
name|g_objc
operator|=
name|g_argc
operator|-
literal|1
expr_stmt|;
name|g_objv
operator|=
name|g_argv
operator|+
literal|1
expr_stmt|;
comment|/* 		 * We still use g_argv[0], the name of the executable. 		 */
name|g_argc
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g_mode
operator|==
name|DMODE_ANON
condition|)
operator|(
name|void
operator|)
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"linkmode"
argument_list|,
literal|"primary"
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we have libdtrace open, make a second pass through argv[] 	 * to perform any dtrace_setopt() calls and change any compiler flags. 	 * We also accumulate any program specifications into our g_cmdv[] at 	 * this time; these will compiled as part of the fourth processing pass. 	 */
for|for
control|(
name|optind
operator|=
literal|1
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|DTRACE_OPTSTR
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"grabanon"
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|dfatal
argument_list|(
literal|"failed to set -a"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"bufsize"
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
name|dfatal
argument_list|(
literal|"failed to set -b %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|g_ofp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|g_cflags
operator||=
name|DTRACE_C_CPP
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"define"
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
name|dfatal
argument_list|(
literal|"failed to set -D %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|dcp
operator|=
operator|&
name|g_cmdv
index|[
name|g_cmdc
operator|++
index|]
expr_stmt|;
name|dcp
operator|->
name|dc_func
operator|=
name|compile_str
expr_stmt|;
name|dcp
operator|->
name|dc_spec
operator|=
name|DTRACE_PROBESPEC_FUNC
expr_stmt|;
name|dcp
operator|->
name|dc_arg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"flowindent"
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|dfatal
argument_list|(
literal|"failed to set -F"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"cpphdrs"
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|dfatal
argument_list|(
literal|"failed to set -H"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|dcp
operator|=
operator|&
name|g_cmdv
index|[
name|g_cmdc
operator|++
index|]
expr_stmt|;
name|dcp
operator|->
name|dc_func
operator|=
name|compile_str
expr_stmt|;
name|dcp
operator|->
name|dc_spec
operator|=
name|DTRACE_PROBESPEC_NAME
expr_stmt|;
name|dcp
operator|->
name|dc_arg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"incdir"
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
name|dfatal
argument_list|(
literal|"failed to set -I %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"libdir"
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
name|dfatal
argument_list|(
literal|"failed to set -L %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|dcp
operator|=
operator|&
name|g_cmdv
index|[
name|g_cmdc
operator|++
index|]
expr_stmt|;
name|dcp
operator|->
name|dc_func
operator|=
name|compile_str
expr_stmt|;
name|dcp
operator|->
name|dc_spec
operator|=
name|DTRACE_PROBESPEC_MOD
expr_stmt|;
name|dcp
operator|->
name|dc_arg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|dcp
operator|=
operator|&
name|g_cmdv
index|[
name|g_cmdc
operator|++
index|]
expr_stmt|;
name|dcp
operator|->
name|dc_func
operator|=
name|compile_str
expr_stmt|;
name|dcp
operator|->
name|dc_spec
operator|=
name|DTRACE_PROBESPEC_NAME
expr_stmt|;
name|dcp
operator|->
name|dc_arg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|dcp
operator|=
operator|&
name|g_cmdv
index|[
name|g_cmdc
operator|++
index|]
expr_stmt|;
name|dcp
operator|->
name|dc_func
operator|=
name|compile_str
expr_stmt|;
name|dcp
operator|->
name|dc_spec
operator|=
name|DTRACE_PROBESPEC_PROVIDER
expr_stmt|;
name|dcp
operator|->
name|dc_arg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"quiet"
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|dfatal
argument_list|(
literal|"failed to set -q"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|g_ofile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|dcp
operator|=
operator|&
name|g_cmdv
index|[
name|g_cmdc
operator|++
index|]
expr_stmt|;
name|dcp
operator|->
name|dc_func
operator|=
name|compile_file
expr_stmt|;
name|dcp
operator|->
name|dc_spec
operator|=
name|DTRACE_PROBESPEC_NONE
expr_stmt|;
name|dcp
operator|->
name|dc_arg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|g_cflags
operator||=
name|DTRACE_C_DIFV
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"undef"
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
name|dfatal
argument_list|(
literal|"failed to set -U %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|g_verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"destructive"
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|dfatal
argument_list|(
literal|"failed to set -w"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
name|optarg
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|dfatal
argument_list|(
literal|"failed to set -x %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"stdc"
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
name|dfatal
argument_list|(
literal|"failed to set -X %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|g_cflags
operator||=
name|DTRACE_C_ZDEFS
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|strchr
argument_list|(
name|DTRACE_OPTSTR
argument_list|,
name|c
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|usage
argument_list|(
name|stderr
argument_list|)
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|g_ofp
operator|==
name|NULL
operator|&&
name|g_mode
operator|!=
name|DMODE_EXEC
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -B not valid in combination"
literal|" with [-AGl] options\n"
argument_list|,
name|g_pname
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_USAGE
operator|)
return|;
block|}
if|if
condition|(
name|g_ofp
operator|==
name|NULL
operator|&&
name|g_ofile
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -B not valid in combination"
literal|" with -o option\n"
argument_list|,
name|g_pname
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_USAGE
operator|)
return|;
block|}
comment|/* 	 * In our third pass we handle any command-line options related to 	 * grabbing or creating victim processes.  The behavior of these calls 	 * may been affected by any library options set by the second pass. 	 */
for|for
control|(
name|optind
operator|=
literal|1
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|DTRACE_OPTSTR
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
if|if
condition|(
operator|(
name|v
operator|=
name|make_argv
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"failed to allocate memory"
argument_list|)
expr_stmt|;
name|P
operator|=
name|dtrace_proc_create
argument_list|(
name|g_dtp
argument_list|,
name|v
index|[
literal|0
index|]
argument_list|,
name|v
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|P
operator|==
name|NULL
condition|)
name|dfatal
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* dtrace_errmsg() only */
name|g_psv
index|[
name|g_psc
operator|++
index|]
operator|=
name|P
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|errno
operator|=
literal|0
expr_stmt|;
name|pid
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
name|p
operator|==
name|optarg
operator|||
name|p
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|fatal
argument_list|(
literal|"invalid pid: %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|P
operator|=
name|dtrace_proc_grab
argument_list|(
name|g_dtp
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|P
operator|==
name|NULL
condition|)
name|dfatal
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* dtrace_errmsg() only */
name|g_psv
index|[
name|g_psc
operator|++
index|]
operator|=
name|P
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * In our fourth pass we finish g_cmdv[] by calling dc_func to convert 	 * each string or file specification into a compiled program structure. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g_cmdc
condition|;
name|i
operator|++
control|)
name|g_cmdv
index|[
name|i
index|]
operator|.
name|dc_func
argument_list|(
operator|&
name|g_cmdv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_mode
operator|!=
name|DMODE_LIST
condition|)
block|{
if|if
condition|(
name|dtrace_handle_err
argument_list|(
name|g_dtp
argument_list|,
operator|&
name|errhandler
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfatal
argument_list|(
literal|"failed to establish error handler"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_handle_drop
argument_list|(
name|g_dtp
argument_list|,
operator|&
name|drophandler
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfatal
argument_list|(
literal|"failed to establish drop handler"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_handle_proc
argument_list|(
name|g_dtp
argument_list|,
operator|&
name|prochandler
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfatal
argument_list|(
literal|"failed to establish proc handler"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_handle_setopt
argument_list|(
name|g_dtp
argument_list|,
operator|&
name|setopthandler
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfatal
argument_list|(
literal|"failed to establish setopt handler"
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_ofp
operator|==
name|NULL
operator|&&
name|dtrace_handle_buffered
argument_list|(
name|g_dtp
argument_list|,
operator|&
name|bufhandler
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfatal
argument_list|(
literal|"failed to establish buffered handler"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dtrace_getopt
argument_list|(
name|g_dtp
argument_list|,
literal|"flowindent"
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|g_flowindent
operator|=
name|opt
operator|!=
name|DTRACEOPT_UNSET
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_getopt
argument_list|(
name|g_dtp
argument_list|,
literal|"grabanon"
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|g_grabanon
operator|=
name|opt
operator|!=
name|DTRACEOPT_UNSET
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_getopt
argument_list|(
name|g_dtp
argument_list|,
literal|"quiet"
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|g_quiet
operator|=
name|opt
operator|!=
name|DTRACEOPT_UNSET
expr_stmt|;
comment|/* 	 * Now make a fifth and final pass over the options that have been 	 * turned into programs and saved in g_cmdv[], performing any mode- 	 * specific processing.  If g_mode is DMODE_EXEC, we will break out 	 * of the switch() and continue on to the data processing loop.  For 	 * other modes, we will exit dtrace once mode-specific work is done. 	 */
switch|switch
condition|(
name|g_mode
condition|)
block|{
case|case
name|DMODE_EXEC
case|:
if|if
condition|(
name|g_ofile
operator|!=
name|NULL
operator|&&
operator|(
name|g_ofp
operator|=
name|fopen
argument_list|(
name|g_ofile
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"failed to open output file '%s'"
argument_list|,
name|g_ofile
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g_cmdc
condition|;
name|i
operator|++
control|)
name|exec_prog
argument_list|(
operator|&
name|g_cmdv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
operator|&&
operator|!
name|g_grabanon
condition|)
block|{
name|dtrace_close
argument_list|(
name|g_dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|g_status
operator|)
return|;
block|}
break|break;
case|case
name|DMODE_ANON
case|:
if|if
condition|(
name|g_ofile
operator|==
name|NULL
condition|)
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|g_ofile
operator|=
literal|"/kernel/drv/dtrace.conf"
expr_stmt|;
else|#
directive|else
comment|/* 			 * On FreeBSD, anonymous DOF data is written to 			 * the DTrace DOF file that the boot loader will 			 * read if booting with the DTrace option. 			 */
name|g_ofile
operator|=
literal|"/boot/dtrace.dof"
expr_stmt|;
endif|#
directive|endif
name|dof_prune
argument_list|(
name|g_ofile
argument_list|)
expr_stmt|;
comment|/* strip out any old DOF directives */
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|etcsystem_prune
argument_list|()
expr_stmt|;
comment|/* string out any forceload directives */
endif|#
directive|endif
if|if
condition|(
name|g_cmdc
operator|==
literal|0
condition|)
block|{
name|dtrace_close
argument_list|(
name|g_dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|g_status
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|g_ofp
operator|=
name|fopen
argument_list|(
name|g_ofile
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"failed to open output file '%s'"
argument_list|,
name|g_ofile
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g_cmdc
condition|;
name|i
operator|++
control|)
block|{
name|anon_prog
argument_list|(
operator|&
name|g_cmdv
index|[
name|i
index|]
argument_list|,
name|dtrace_dof_create
argument_list|(
name|g_dtp
argument_list|,
name|g_cmdv
index|[
name|i
index|]
operator|.
name|dc_prog
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Dump out the DOF corresponding to the error handler and the 		 * current options as the final DOF property in the .conf file. 		 */
name|anon_prog
argument_list|(
name|NULL
argument_list|,
name|dtrace_geterr_dof
argument_list|(
name|g_dtp
argument_list|)
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|anon_prog
argument_list|(
name|NULL
argument_list|,
name|dtrace_getopt_dof
argument_list|(
name|g_dtp
argument_list|)
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|g_ofp
argument_list|)
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
literal|"failed to close output file '%s'"
argument_list|,
name|g_ofile
argument_list|)
expr_stmt|;
comment|/* 		 * These messages would use notice() rather than error(), but 		 * we don't want them suppressed when -A is run on a D program 		 * that itself contains a #pragma D option quiet. 		 */
name|error
argument_list|(
literal|"saved anonymous enabling in %s\n"
argument_list|,
name|g_ofile
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|etcsystem_add
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"run update_drv(1M) or reboot to enable changes\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dtrace_close
argument_list|(
name|g_dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|g_status
operator|)
return|;
case|case
name|DMODE_LINK
case|:
if|if
condition|(
name|g_cmdc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -G requires one or more "
literal|"scripts or enabling options\n"
argument_list|,
name|g_pname
argument_list|)
expr_stmt|;
name|dtrace_close
argument_list|(
name|g_dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_USAGE
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g_cmdc
condition|;
name|i
operator|++
control|)
name|link_prog
argument_list|(
operator|&
name|g_cmdv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_cmdc
operator|>
literal|1
operator|&&
name|g_ofile
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
modifier|*
name|objv
init|=
name|alloca
argument_list|(
name|g_cmdc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g_cmdc
condition|;
name|i
operator|++
control|)
name|objv
index|[
name|i
index|]
operator|=
name|g_cmdv
index|[
name|i
index|]
operator|.
name|dc_ofile
expr_stmt|;
if|if
condition|(
name|dtrace_program_link
argument_list|(
name|g_dtp
argument_list|,
name|NULL
argument_list|,
name|DTRACE_D_PROBES
argument_list|,
name|g_ofile
argument_list|,
name|g_cmdc
argument_list|,
name|objv
argument_list|)
operator|!=
literal|0
condition|)
name|dfatal
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* dtrace_errmsg() only */
block|}
name|dtrace_close
argument_list|(
name|g_dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|g_status
operator|)
return|;
case|case
name|DMODE_LIST
case|:
if|if
condition|(
name|g_ofile
operator|!=
name|NULL
operator|&&
operator|(
name|g_ofp
operator|=
name|fopen
argument_list|(
name|g_ofile
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"failed to open output file '%s'"
argument_list|,
name|g_ofile
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"%5s %10s %17s %33s %s\n"
argument_list|,
literal|"ID"
argument_list|,
literal|"PROVIDER"
argument_list|,
literal|"MODULE"
argument_list|,
literal|"FUNCTION"
argument_list|,
literal|"NAME"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g_cmdc
condition|;
name|i
operator|++
control|)
name|list_prog
argument_list|(
operator|&
name|g_cmdv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_cmdc
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|dtrace_probe_iter
argument_list|(
name|g_dtp
argument_list|,
name|NULL
argument_list|,
name|list_probe
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_close
argument_list|(
name|g_dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|g_status
operator|)
return|;
case|case
name|DMODE_HEADER
case|:
if|if
condition|(
name|g_cmdc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -h requires one or more "
literal|"scripts or enabling options\n"
argument_list|,
name|g_pname
argument_list|)
expr_stmt|;
name|dtrace_close
argument_list|(
name|g_dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_USAGE
operator|)
return|;
block|}
if|if
condition|(
name|g_ofile
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|g_cmdc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -h requires an "
literal|"output file if multiple scripts are "
literal|"specified\n"
argument_list|,
name|g_pname
argument_list|)
expr_stmt|;
name|dtrace_close
argument_list|(
name|g_dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_USAGE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|g_cmdv
index|[
literal|0
index|]
operator|.
name|dc_arg
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".d"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -h requires an "
literal|"output file if no scripts are "
literal|"specified\n"
argument_list|,
name|g_pname
argument_list|)
expr_stmt|;
name|dtrace_close
argument_list|(
name|g_dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_USAGE
operator|)
return|;
block|}
name|p
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* strip .d suffix */
name|g_ofile
operator|=
name|p
operator|=
name|g_cmdv
index|[
literal|0
index|]
operator|.
name|dc_ofile
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|g_cmdv
index|[
literal|0
index|]
operator|.
name|dc_ofile
argument_list|)
argument_list|,
literal|"%s.h"
argument_list|,
name|basename
argument_list|(
name|g_cmdv
index|[
literal|0
index|]
operator|.
name|dc_arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|g_ofp
operator|=
name|fopen
argument_list|(
name|g_ofile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"failed to open header file '%s'"
argument_list|,
name|g_ofile
argument_list|)
expr_stmt|;
name|oprintf
argument_list|(
literal|"/*\n * Generated by dtrace(1M).\n */\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_program_header
argument_list|(
name|g_dtp
argument_list|,
name|g_ofp
argument_list|,
name|g_ofile
argument_list|)
operator|!=
literal|0
operator|||
name|fclose
argument_list|(
name|g_ofp
argument_list|)
operator|==
name|EOF
condition|)
name|dfatal
argument_list|(
literal|"failed to create header file %s"
argument_list|,
name|g_ofile
argument_list|)
expr_stmt|;
name|dtrace_close
argument_list|(
name|g_dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|g_status
operator|)
return|;
block|}
comment|/* 	 * If -a and -Z were not specified and no probes have been matched, no 	 * probe criteria was specified on the command line and we abort. 	 */
if|if
condition|(
name|g_total
operator|==
literal|0
operator|&&
operator|!
name|g_grabanon
operator|&&
operator|!
operator|(
name|g_cflags
operator|&
name|DTRACE_C_ZDEFS
operator|)
condition|)
name|dfatal
argument_list|(
literal|"no probes %s\n"
argument_list|,
name|g_cmdc
condition|?
literal|"matched"
else|:
literal|"specified"
argument_list|)
expr_stmt|;
comment|/* 	 * Start tracing.  Once we dtrace_go(), reload any options that affect 	 * our globals in case consuming anonymous state has changed them. 	 */
name|go
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_getopt
argument_list|(
name|g_dtp
argument_list|,
literal|"flowindent"
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|g_flowindent
operator|=
name|opt
operator|!=
name|DTRACEOPT_UNSET
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_getopt
argument_list|(
name|g_dtp
argument_list|,
literal|"grabanon"
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|g_grabanon
operator|=
name|opt
operator|!=
name|DTRACEOPT_UNSET
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_getopt
argument_list|(
name|g_dtp
argument_list|,
literal|"quiet"
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|g_quiet
operator|=
name|opt
operator|!=
name|DTRACEOPT_UNSET
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_getopt
argument_list|(
name|g_dtp
argument_list|,
literal|"destructive"
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|!=
name|DTRACEOPT_UNSET
condition|)
name|notice
argument_list|(
literal|"allowing destructive actions\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|intr
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
name|NULL
argument_list|,
operator|&
name|oact
argument_list|)
operator|==
literal|0
operator|&&
name|oact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
name|NULL
argument_list|,
operator|&
name|oact
argument_list|)
operator|==
literal|0
operator|&&
name|oact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|sigaction
argument_list|(
name|SIGUSR1
argument_list|,
name|NULL
argument_list|,
operator|&
name|oact
argument_list|)
operator|==
literal|0
operator|&&
name|oact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGUSR1
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now that tracing is active and we are ready to consume trace data, 	 * continue any grabbed or created processes, setting them running 	 * using the /proc control mechanism inside of libdtrace. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g_psc
condition|;
name|i
operator|++
control|)
name|dtrace_proc_continue
argument_list|(
name|g_dtp
argument_list|,
name|g_psv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g_pslive
operator|=
name|g_psc
expr_stmt|;
comment|/* count for prochandler() */
do|do
block|{
if|if
condition|(
operator|!
name|g_intr
operator|&&
operator|!
name|done
condition|)
name|dtrace_sleep
argument_list|(
name|g_dtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_newline
condition|)
block|{
comment|/* 			 * Output a newline just to make the output look 			 * slightly cleaner.  Note that we do this even in 			 * "quiet" mode... 			 */
name|oprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|g_newline
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|||
name|g_intr
operator|||
operator|(
name|g_psc
operator|!=
literal|0
operator|&&
name|g_pslive
operator|==
literal|0
operator|)
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dtrace_stop
argument_list|(
name|g_dtp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfatal
argument_list|(
literal|"couldn't stop tracing"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|dtrace_work
argument_list|(
name|g_dtp
argument_list|,
name|g_ofp
argument_list|,
name|chew
argument_list|,
name|chewrec
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
case|case
name|DTRACE_WORKSTATUS_DONE
case|:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DTRACE_WORKSTATUS_OKAY
case|:
break|break;
default|default:
if|if
condition|(
operator|!
name|g_impatient
operator|&&
name|dtrace_errno
argument_list|(
name|g_dtp
argument_list|)
operator|!=
name|EINTR
condition|)
name|dfatal
argument_list|(
literal|"processing aborted"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g_ofp
operator|!=
name|NULL
operator|&&
name|fflush
argument_list|(
name|g_ofp
argument_list|)
operator|==
name|EOF
condition|)
name|clearerr
argument_list|(
name|g_ofp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
name|oprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_impatient
condition|)
block|{
if|if
condition|(
name|dtrace_aggregate_print
argument_list|(
name|g_dtp
argument_list|,
name|g_ofp
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|dtrace_errno
argument_list|(
name|g_dtp
argument_list|)
operator|!=
name|EINTR
condition|)
name|dfatal
argument_list|(
literal|"failed to print aggregations"
argument_list|)
expr_stmt|;
block|}
name|dtrace_close
argument_list|(
name|g_dtp
argument_list|)
expr_stmt|;
return|return
operator|(
name|g_status
operator|)
return|;
block|}
end_function

end_unit

