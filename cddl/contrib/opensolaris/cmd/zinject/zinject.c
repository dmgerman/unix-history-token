begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * ZFS Fault Injector  *  * This userland component takes a set of options and uses libzpool to translate  * from a user-visible object type and name to an internal representation.  * There are two basic types of faults: device faults and data faults.  *  *  * DEVICE FAULTS  *  * Errors can be injected into a particular vdev using the '-d' option.  This  * option takes a path or vdev GUID to uniquely identify the device within a  * pool.  There are two types of errors that can be injected, EIO and ENXIO,  * that can be controlled through the '-e' option.  The default is ENXIO.  For  * EIO failures, any attempt to read data from the device will return EIO, but  * subsequent attempt to reopen the device will succeed.  For ENXIO failures,  * any attempt to read from the device will return EIO, but any attempt to  * reopen the device will also return ENXIO.  * For label faults, the -L option must be specified. This allows faults  * to be injected into either the nvlist or uberblock region of all the labels  * for the specified device.  *  * This form of the command looks like:  *  * 	zinject -d device [-e errno] [-L<uber | nvlist>] pool  *  *  * DATA FAULTS  *  * We begin with a tuple of the form:  *  *<type,level,range,object>  *  * 	type	A string describing the type of data to target.  Each type  * 		implicitly describes how to interpret 'object'. Currently,  * 		the following values are supported:  *  * 		data		User data for a file  * 		dnode		Dnode for a file or directory  *  *		The following MOS objects are special.  Instead of injecting  *		errors on a particular object or blkid, we inject errors across  *		all objects of the given type.  *  * 		mos		Any data in the MOS  * 		mosdir		object directory  * 		config		pool configuration  * 		bplist		blkptr list  * 		spacemap	spacemap  * 		metaslab	metaslab  * 		errlog		persistent error log  *  * 	level	Object level.  Defaults to '0', not applicable to all types.  If  * 		a range is given, this corresponds to the indirect block  * 		corresponding to the specific range.  *  *	range	A numerical range [start,end) within the object.  Defaults to  *		the full size of the file.  *  * 	object	A string describing the logical location of the object.  For  * 		files and directories (currently the only supported types),  * 		this is the path of the object on disk.  *  * This is translated, via libzpool, into the following internal representation:  *  *<type,objset,object,level,range>  *  * These types should be self-explanatory.  This tuple is then passed to the  * kernel via a special ioctl() to initiate fault injection for the given  * object.  Note that 'type' is not strictly necessary for fault injection, but  * is used when translating existing faults into a human-readable string.  *  *  * The command itself takes one of the forms:  *  * 	zinject  * 	zinject<-a | -u pool>  * 	zinject -c<id|all>  * 	zinject [-q]<-t type> [-f freq] [-u] [-a] [-m] [-e errno] [-l level]  *	    [-r range]<object>  * 	zinject [-f freq] [-a] [-m] [-u] -b objset:object:level:start:end pool  *  * With no arguments, the command prints all currently registered injection  * handlers, with their numeric identifiers.  *  * The '-c' option will clear the given handler, or all handlers if 'all' is  * specified.  *  * The '-e' option takes a string describing the errno to simulate.  This must  * be either 'io' or 'checksum'.  In most cases this will result in the same  * behavior, but RAID-Z will produce a different set of ereports for this  * situation.  *  * The '-a', '-u', and '-m' flags toggle internal flush behavior.  If '-a' is  * specified, then the ARC cache is flushed appropriately.  If '-u' is  * specified, then the underlying SPA is unloaded.  Either of these flags can be  * specified independently of any other handlers.  The '-m' flag automatically  * does an unmount and remount of the underlying dataset to aid in flushing the  * cache.  *  * The '-f' flag controls the frequency of errors injected, expressed as a  * integer percentage between 1 and 100.  The default is 100.  *  * The this form is responsible for actually injecting the handler into the  * framework.  It takes the arguments described above, translates them to the  * internal tuple using libzpool, and then issues an ioctl() to register the  * handler.  *  * The final form can target a specific bookmark, regardless of whether a  * human-readable interface has been designed.  It allows developers to specify  * a particular block by number.  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_undef
undef|#
directive|undef
name|verify
end_undef

begin_comment
comment|/* both libzfs.h and zfs_context.h want to define this */
end_comment

begin_include
include|#
directive|include
file|"zinject.h"
end_include

begin_decl_stmt
name|libzfs_handle_t
modifier|*
name|g_zfs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_fd
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ECKSUM
end_ifndef

begin_define
define|#
directive|define
name|ECKSUM
value|EBADE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|errtable
index|[
name|TYPE_INVAL
index|]
init|=
block|{
literal|"data"
block|,
literal|"dnode"
block|,
literal|"mos"
block|,
literal|"mosdir"
block|,
literal|"metaslab"
block|,
literal|"config"
block|,
literal|"bplist"
block|,
literal|"spacemap"
block|,
literal|"errlog"
block|,
literal|"uber"
block|,
literal|"nvlist"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|err_type_t
name|name_to_type
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_INVAL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|errtable
index|[
name|i
index|]
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
name|TYPE_INVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|type_to_name
parameter_list|(
name|uint64_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DMU_OT_OBJECT_DIRECTORY
case|:
return|return
operator|(
literal|"mosdir"
operator|)
return|;
case|case
name|DMU_OT_OBJECT_ARRAY
case|:
return|return
operator|(
literal|"metaslab"
operator|)
return|;
case|case
name|DMU_OT_PACKED_NVLIST
case|:
return|return
operator|(
literal|"config"
operator|)
return|;
case|case
name|DMU_OT_BPLIST
case|:
return|return
operator|(
literal|"bplist"
operator|)
return|;
case|case
name|DMU_OT_SPACE_MAP
case|:
return|return
operator|(
literal|"spacemap"
operator|)
return|;
case|case
name|DMU_OT_ERROR_LOG
case|:
return|return
operator|(
literal|"errlog"
operator|)
return|;
default|default:
return|return
operator|(
literal|"-"
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print usage message.  */
end_comment

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"usage:\n"
literal|"\n"
literal|"\tzinject\n"
literal|"\n"
literal|"\t\tList all active injection records.\n"
literal|"\n"
literal|"\tzinject -c<id|all>\n"
literal|"\n"
literal|"\t\tClear the particular record (if given a numeric ID), or\n"
literal|"\t\tall records if 'all' is specificed.\n"
literal|"\n"
literal|"\tzinject -d device [-e errno] [-L<nvlist|uber>] pool\n"
literal|"\t\tInject a fault into a particular device or the device's\n"
literal|"\t\tlabel.  Label injection can either be 'nvlist' or 'uber'.\n"
literal|"\t\t'errno' can either be 'nxio' (the default) or 'io'.\n"
literal|"\n"
literal|"\tzinject -b objset:object:level:blkid pool\n"
literal|"\n"
literal|"\t\tInject an error into pool 'pool' with the numeric bookmark\n"
literal|"\t\tspecified by the remaining tuple.  Each number is in\n"
literal|"\t\thexidecimal, and only one block can be specified.\n"
literal|"\n"
literal|"\tzinject [-q]<-t type> [-e errno] [-l level] [-r range]\n"
literal|"\t    [-a] [-m] [-u] [-f freq]<object>\n"
literal|"\n"
literal|"\t\tInject an error into the object specified by the '-t' option\n"
literal|"\t\tand the object descriptor.  The 'object' parameter is\n"
literal|"\t\tinterperted depending on the '-t' option.\n"
literal|"\n"
literal|"\t\t-q\tQuiet mode.  Only print out the handler number added.\n"
literal|"\t\t-e\tInject a specific error.  Must be either 'io' or\n"
literal|"\t\t\t'checksum'.  Default is 'io'.\n"
literal|"\t\t-l\tInject error at a particular block level. Default is "
literal|"0.\n"
literal|"\t\t-m\tAutomatically remount underlying filesystem.\n"
literal|"\t\t-r\tInject error over a particular logical range of an\n"
literal|"\t\t\tobject.  Will be translated to the appropriate blkid\n"
literal|"\t\t\trange according to the object's properties.\n"
literal|"\t\t-a\tFlush the ARC cache.  Can be specified without any\n"
literal|"\t\t\tassociated object.\n"
literal|"\t\t-u\tUnload the associated pool.  Can be specified with only\n"
literal|"\t\t\ta pool object.\n"
literal|"\t\t-f\tOnly inject errors a fraction of the time.  Expressed as\n"
literal|"\t\t\ta percentage between 1 and 100.\n"
literal|"\n"
literal|"\t-t data\t\tInject an error into the plain file contents of a\n"
literal|"\t\t\tfile.  The object must be specified as a complete path\n"
literal|"\t\t\tto a file on a ZFS filesystem.\n"
literal|"\n"
literal|"\t-t dnode\tInject an error into the metadnode in the block\n"
literal|"\t\t\tcorresponding to the dnode for a file or directory.  The\n"
literal|"\t\t\t'-r' option is incompatible with this mode.  The object\n"
literal|"\t\t\tis specified as a complete path to a file or directory\n"
literal|"\t\t\ton a ZFS filesystem.\n"
literal|"\n"
literal|"\t-t<mos>\tInject errors into the MOS for objects of the given\n"
literal|"\t\t\ttype.  Valid types are: mos, mosdir, config, bplist,\n"
literal|"\t\t\tspacemap, metaslab, errlog.  The only valid<object> is\n"
literal|"\t\t\tthe poolname.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iter_handlers
parameter_list|(
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|zinject_record_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ioctl
argument_list|(
name|zfs_fd
argument_list|,
name|ZFS_IOC_INJECT_LIST_NEXT
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|ret
operator|=
name|func
argument_list|(
operator|(
name|int
operator|)
name|zc
operator|.
name|zc_guid
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
operator|&
name|zc
operator|.
name|zc_inject_record
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_data_handler
parameter_list|(
name|int
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|zinject_record_t
modifier|*
name|record
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
modifier|*
name|count
init|=
name|data
decl_stmt|;
if|if
condition|(
name|record
operator|->
name|zi_guid
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|count
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%3s  %-15s  %-6s  %-6s  %-8s  %3s  %-15s\n"
argument_list|,
literal|"ID"
argument_list|,
literal|"POOL"
argument_list|,
literal|"OBJSET"
argument_list|,
literal|"OBJECT"
argument_list|,
literal|"TYPE"
argument_list|,
literal|"LVL"
argument_list|,
literal|"RANGE"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"---  ---------------  ------  "
literal|"------  --------  ---  ---------------\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|count
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%3d  %-15s  %-6llu  %-6llu  %-8s  %3d  "
argument_list|,
name|id
argument_list|,
name|pool
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|record
operator|->
name|zi_objset
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|record
operator|->
name|zi_object
argument_list|,
name|type_to_name
argument_list|(
name|record
operator|->
name|zi_type
argument_list|)
argument_list|,
name|record
operator|->
name|zi_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|record
operator|->
name|zi_start
operator|==
literal|0
operator|&&
name|record
operator|->
name|zi_end
operator|==
operator|-
literal|1ULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"all\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"[%llu, %llu]\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|record
operator|->
name|zi_start
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|record
operator|->
name|zi_end
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_device_handler
parameter_list|(
name|int
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|zinject_record_t
modifier|*
name|record
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
modifier|*
name|count
init|=
name|data
decl_stmt|;
if|if
condition|(
name|record
operator|->
name|zi_guid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|count
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%3s  %-15s  %s\n"
argument_list|,
literal|"ID"
argument_list|,
literal|"POOL"
argument_list|,
literal|"GUID"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"---  ---------------  ----------------\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|count
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%3d  %-15s  %llx\n"
argument_list|,
name|id
argument_list|,
name|pool
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|record
operator|->
name|zi_guid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print all registered error handlers.  Returns the number of handlers  * registered.  */
end_comment

begin_function
specifier|static
name|int
name|print_all_handlers
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|iter_handlers
argument_list|(
name|print_device_handler
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|iter_handlers
argument_list|(
name|print_data_handler
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|cancel_one_handler
parameter_list|(
name|int
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|zinject_record_t
modifier|*
name|record
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
decl_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
operator|(
name|uint64_t
operator|)
name|id
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zfs_fd
argument_list|,
name|ZFS_IOC_CLEAR_FAULT
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"failed to remove handler %d: %s\n"
argument_list|,
name|id
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all fault injection handlers.  */
end_comment

begin_function
specifier|static
name|int
name|cancel_all_handlers
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
init|=
name|iter_handlers
argument_list|(
name|cancel_one_handler
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"removed all registered handlers\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a specific fault injection handler.  */
end_comment

begin_function
specifier|static
name|int
name|cancel_handler
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
decl_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
operator|(
name|uint64_t
operator|)
name|id
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zfs_fd
argument_list|,
name|ZFS_IOC_CLEAR_FAULT
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"failed to remove handler %d: %s\n"
argument_list|,
name|id
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"removed handler %d\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register a new fault injection handler.  */
end_comment

begin_function
specifier|static
name|int
name|register_handler
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|int
name|flags
parameter_list|,
name|zinject_record_t
modifier|*
name|record
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_inject_record
operator|=
operator|*
name|record
expr_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zfs_fd
argument_list|,
name|ZFS_IOC_INJECT_FAULT
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"failed to add handler: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|ZINJECT_NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|quiet
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%llu\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zc
operator|.
name|zc_guid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Added handler %llu with the following "
literal|"properties:\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zc
operator|.
name|zc_guid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  pool: %s\n"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|record
operator|->
name|zi_guid
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  vdev: %llx\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|record
operator|->
name|zi_guid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"objset: %llu\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|record
operator|->
name|zi_objset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"object: %llu\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|record
operator|->
name|zi_object
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  type: %llu\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|record
operator|->
name|zi_type
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" level: %d\n"
argument_list|,
name|record
operator|->
name|zi_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|record
operator|->
name|zi_start
operator|==
literal|0
operator|&&
name|record
operator|->
name|zi_end
operator|==
operator|-
literal|1ULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" range: all\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" range: [%llu, %llu)\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|record
operator|->
name|zi_start
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|record
operator|->
name|zi_end
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|range
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cancel
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|raw
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|device
init|=
name|NULL
decl_stmt|;
name|int
name|level
init|=
literal|0
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|domount
init|=
literal|0
decl_stmt|;
name|err_type_t
name|type
init|=
name|TYPE_INVAL
decl_stmt|;
name|err_type_t
name|label
init|=
name|TYPE_INVAL
decl_stmt|;
name|zinject_record_t
name|record
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|pool
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|char
name|dataset
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|g_zfs
operator|=
name|libzfs_init
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"internal error: failed to "
literal|"initialize ZFS library\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|libzfs_print_on_error
argument_list|(
name|g_zfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zfs_fd
operator|=
name|open
argument_list|(
name|ZFS_DEV
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"failed to open ZFS device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
comment|/* 		 * No arguments.  Print the available handlers.  If there are no 		 * available handlers, direct the user to '-h' for help 		 * information. 		 */
if|if
condition|(
name|print_all_handlers
argument_list|()
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"No handlers registered.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Run 'zinject -h' for usage "
literal|"information.\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":ab:d:f:qhc:t:l:mr:e:uL:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|flags
operator||=
name|ZINJECT_FLUSH_ARC
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|raw
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cancel
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|device
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"io"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"checksum"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ECKSUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"nxio"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid error type "
literal|"'%s': must be 'io', 'checksum' or "
literal|"'nxio'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|'f'
case|:
name|record
operator|.
name|zi_freq
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|record
operator|.
name|zi_freq
operator|<
literal|1
operator|||
name|record
operator|.
name|zi_freq
operator|>
literal|100
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"frequency range must "
literal|"be in the range (0, 100]\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'l'
case|:
name|level
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid level '%s': "
literal|"must be an integer\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|'m'
case|:
name|domount
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|range
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|(
name|type
operator|=
name|name_to_type
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|TYPE_INVAL
operator|&&
operator|!
name|MOS_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid type '%s'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|'u'
case|:
name|flags
operator||=
name|ZINJECT_UNLOAD_SPA
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
operator|(
name|label
operator|=
name|name_to_type
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|TYPE_INVAL
operator|&&
operator|!
name|LABEL_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid label type "
literal|"'%s'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"option -%c requires an "
literal|"operand\n"
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid option '%c'\n"
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|cancel
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * '-c' is invalid with any other options. 		 */
if|if
condition|(
name|raw
operator|!=
name|NULL
operator|||
name|range
operator|!=
name|NULL
operator|||
name|type
operator|!=
name|TYPE_INVAL
operator|||
name|level
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cancel (-c) incompatible with "
literal|"any other options\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"extraneous argument to '-c'\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cancel
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|cancel_all_handlers
argument_list|()
operator|)
return|;
block|}
else|else
block|{
name|int
name|id
init|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|cancel
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid handle id '%s':"
literal|" must be an integer or 'all'\n"
argument_list|,
name|cancel
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|cancel_handler
argument_list|(
name|id
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Device (-d) injection uses a completely different mechanism 		 * for doing injection, so handle it separately here. 		 */
if|if
condition|(
name|raw
operator|!=
name|NULL
operator|||
name|range
operator|!=
name|NULL
operator|||
name|type
operator|!=
name|TYPE_INVAL
operator|||
name|level
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"device (-d) incompatible with "
literal|"data error injection\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"device (-d) injection requires "
literal|"a single pool name\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pool
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dataset
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ECKSUM
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"device error type must be "
literal|"'io' or 'nxio'\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|translate_device
argument_list|(
name|pool
argument_list|,
name|device
argument_list|,
name|label
argument_list|,
operator|&
name|record
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|raw
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|range
operator|!=
name|NULL
operator|||
name|type
operator|!=
name|TYPE_INVAL
operator|||
name|level
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"raw (-b) format with "
literal|"any other options\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"raw (-b) format expects a "
literal|"single pool name\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pool
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dataset
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENXIO
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"data error type must be "
literal|"'checksum' or 'io'\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|translate_raw
argument_list|(
name|raw
argument_list|,
operator|&
name|record
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TYPE_INVAL
condition|)
block|{
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"at least one of '-b', '-d', "
literal|"'-t', '-a', or '-u' must be specified\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
operator|(
name|flags
operator|&
name|ZINJECT_UNLOAD_SPA
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pool
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dataset
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"extraneous argument for "
literal|"'-f'\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
name|flags
operator||=
name|ZINJECT_NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"missing object\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|==
name|ENXIO
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"data error type must be "
literal|"'checksum' or 'io'\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|translate_record
argument_list|(
name|type
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|range
argument_list|,
name|level
argument_list|,
operator|&
name|record
argument_list|,
name|pool
argument_list|,
name|dataset
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
block|}
comment|/* 	 * If this is pool-wide metadata, unmount everything.  The ioctl() will 	 * unload the pool, so that we trigger spa-wide reopen of metadata next 	 * time we access the pool. 	 */
if|if
condition|(
name|dataset
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|domount
condition|)
block|{
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|dataset
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|zfs_unmount
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|record
operator|.
name|zi_error
operator|=
name|error
expr_stmt|;
name|ret
operator|=
name|register_handler
argument_list|(
name|pool
argument_list|,
name|flags
argument_list|,
operator|&
name|record
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataset
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|domount
condition|)
name|ret
operator|=
operator|(
name|zfs_mount
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|libzfs_fini
argument_list|(
name|g_zfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

