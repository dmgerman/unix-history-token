begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<gelf.h>
end_include

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_include
include|#
directive|include
file|"ctf_headers.h"
end_include

begin_include
include|#
directive|include
file|"utils.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_define
define|#
directive|define
name|WARN
parameter_list|(
name|x
parameter_list|)
value|{ warn(x); return (E_ERROR); }
end_define

begin_comment
comment|/*  * Flags that indicate what data is to be displayed.  An explicit `all' value is  * provided to allow the code to distinguish between a request for everything  * (currently requested by invoking ctfdump without flags) and individual  * requests for all of the types of data (an invocation with all flags).  In the  * former case, we want to be able to implicitly adjust the definition of `all'  * based on the CTF version of the file being dumped.  For example, if a v2 file  * is being dumped, `all' includes F_LABEL - a request to dump the label  * section.  If a v1 file is being dumped, `all' does not include F_LABEL,  * because v1 CTF doesn't support labels.  We need to be able to distinguish  * between `ctfdump foo', which has an implicit request for labels if `foo'  * supports them, and `ctfdump -l foo', which has an explicity request.  In the  * latter case, we exit with an error if `foo' is a v1 CTF file.  */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|F_DATA
init|=
literal|0x01
block|,
comment|/* show data object section */
name|F_FUNC
init|=
literal|0x02
block|,
comment|/* show function section */
name|F_HDR
init|=
literal|0x04
block|,
comment|/* show header */
name|F_STR
init|=
literal|0x08
block|,
comment|/* show string table */
name|F_TYPES
init|=
literal|0x10
block|,
comment|/* show type section */
name|F_STATS
init|=
literal|0x20
block|,
comment|/* show statistics */
name|F_LABEL
init|=
literal|0x40
block|,
comment|/* show label section */
name|F_ALL
init|=
literal|0x80
block|,
comment|/* explicit request for `all' */
name|F_ALLMSK
init|=
literal|0xff
comment|/* show all sections and statistics */
block|}
name|flags
init|=
literal|0
enum|;
end_enum

begin_struct
specifier|static
struct|struct
block|{
name|ulong_t
name|s_ndata
decl_stmt|;
comment|/* total number of data objects */
name|ulong_t
name|s_nfunc
decl_stmt|;
comment|/* total number of functions */
name|ulong_t
name|s_nargs
decl_stmt|;
comment|/* total number of function arguments */
name|ulong_t
name|s_argmax
decl_stmt|;
comment|/* longest argument list */
name|ulong_t
name|s_ntypes
decl_stmt|;
comment|/* total number of types */
name|ulong_t
name|s_types
index|[
literal|16
index|]
decl_stmt|;
comment|/* number of types by kind */
name|ulong_t
name|s_nsmem
decl_stmt|;
comment|/* total number of struct members */
name|ulong_t
name|s_nsbytes
decl_stmt|;
comment|/* total size of all structs */
name|ulong_t
name|s_smmax
decl_stmt|;
comment|/* largest struct in terms of members */
name|ulong_t
name|s_sbmax
decl_stmt|;
comment|/* largest struct in terms of bytes */
name|ulong_t
name|s_numem
decl_stmt|;
comment|/* total number of union members */
name|ulong_t
name|s_nubytes
decl_stmt|;
comment|/* total size of all unions */
name|ulong_t
name|s_ummax
decl_stmt|;
comment|/* largest union in terms of members */
name|ulong_t
name|s_ubmax
decl_stmt|;
comment|/* largest union in terms of bytes */
name|ulong_t
name|s_nemem
decl_stmt|;
comment|/* total number of enum members */
name|ulong_t
name|s_emmax
decl_stmt|;
comment|/* largest enum in terms of members */
name|ulong_t
name|s_nstr
decl_stmt|;
comment|/* total number of strings */
name|size_t
name|s_strlen
decl_stmt|;
comment|/* total length of all strings */
name|size_t
name|s_strmax
decl_stmt|;
comment|/* longest string length */
block|}
name|stats
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|ctf_data
block|{
name|caddr_t
name|cd_ctfdata
decl_stmt|;
comment|/* Pointer to the CTF data */
name|size_t
name|cd_ctflen
decl_stmt|;
comment|/* Length of CTF data */
comment|/* 	 * cd_symdata will be non-NULL if the CTF data is being retrieved from 	 * an ELF file with a symbol table.  cd_strdata and cd_nsyms should be 	 * used only if cd_symdata is non-NULL. 	 */
name|Elf_Data
modifier|*
name|cd_symdata
decl_stmt|;
comment|/* Symbol table */
name|Elf_Data
modifier|*
name|cd_strdata
decl_stmt|;
comment|/* Symbol table strings */
name|int
name|cd_nsyms
decl_stmt|;
comment|/* Number of symbol table entries */
block|}
name|ctf_data_t
typedef|;
end_typedef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ref_to_str
parameter_list|(
name|uint_t
name|name
parameter_list|,
specifier|const
name|ctf_header_t
modifier|*
name|hp
parameter_list|,
specifier|const
name|ctf_data_t
modifier|*
name|cd
parameter_list|)
block|{
name|size_t
name|offset
init|=
name|CTF_NAME_OFFSET
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|cd
operator|->
name|cd_ctfdata
operator|+
name|hp
operator|->
name|cth_stroff
operator|+
name|offset
decl_stmt|;
if|if
condition|(
name|CTF_NAME_STID
argument_list|(
name|name
argument_list|)
operator|!=
name|CTF_STRTAB_0
condition|)
return|return
operator|(
literal|"<< ??? - name in external strtab>>"
operator|)
return|;
if|if
condition|(
name|offset
operator|>=
name|hp
operator|->
name|cth_strlen
condition|)
return|return
operator|(
literal|"<< ??? - name exceeds strlab len>>"
operator|)
return|;
if|if
condition|(
name|hp
operator|->
name|cth_stroff
operator|+
name|offset
operator|>=
name|cd
operator|->
name|cd_ctflen
condition|)
return|return
operator|(
literal|"<< ??? - file truncated>>"
operator|)
return|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|"(anon)"
operator|)
return|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|int_encoding_to_str
parameter_list|(
name|uint_t
name|encoding
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|encoding
operator|==
literal|0
operator|||
operator|(
name|encoding
operator|&
operator|~
operator|(
name|CTF_INT_SIGNED
operator||
name|CTF_INT_CHAR
operator||
name|CTF_INT_BOOL
operator||
name|CTF_INT_VARARGS
operator|)
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|" 0x%x"
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|encoding
operator|&
name|CTF_INT_SIGNED
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" SIGNED"
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoding
operator|&
name|CTF_INT_CHAR
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" CHAR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoding
operator|&
name|CTF_INT_BOOL
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" BOOL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoding
operator|&
name|CTF_INT_VARARGS
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" VARARGS"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|fp_encoding_to_str
parameter_list|(
name|uint_t
name|encoding
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|encs
index|[]
init|=
block|{
name|NULL
block|,
literal|"SINGLE"
block|,
literal|"DOUBLE"
block|,
literal|"COMPLEX"
block|,
literal|"DCOMPLEX"
block|,
literal|"LDCOMPLEX"
block|,
literal|"LDOUBLE"
block|,
literal|"INTERVAL"
block|,
literal|"DINTERVAL"
block|,
literal|"LDINTERVAL"
block|,
literal|"IMAGINARY"
block|,
literal|"DIMAGINARY"
block|,
literal|"LDIMAGINARY"
block|}
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|encoding
operator|<
literal|1
operator|||
name|encoding
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|encs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
return|return
operator|(
name|encs
index|[
name|encoding
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_line
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|line
index|[]
init|=
literal|"----------------------------------------"
literal|"----------------------------------------"
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%s%.*s\n\n"
argument_list|,
name|s
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|78
operator|-
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_header
parameter_list|(
specifier|const
name|ctf_header_t
modifier|*
name|hp
parameter_list|,
specifier|const
name|ctf_data_t
modifier|*
name|cd
parameter_list|)
block|{
name|print_line
argument_list|(
literal|"- CTF Header "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  cth_magic    = 0x%04x\n"
argument_list|,
name|hp
operator|->
name|cth_magic
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  cth_version  = %u\n"
argument_list|,
name|hp
operator|->
name|cth_version
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  cth_flags    = 0x%02x\n"
argument_list|,
name|hp
operator|->
name|cth_flags
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  cth_parlabel = %s\n"
argument_list|,
name|ref_to_str
argument_list|(
name|hp
operator|->
name|cth_parlabel
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  cth_parname  = %s\n"
argument_list|,
name|ref_to_str
argument_list|(
name|hp
operator|->
name|cth_parname
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  cth_lbloff   = %u\n"
argument_list|,
name|hp
operator|->
name|cth_lbloff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  cth_objtoff  = %u\n"
argument_list|,
name|hp
operator|->
name|cth_objtoff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  cth_funcoff  = %u\n"
argument_list|,
name|hp
operator|->
name|cth_funcoff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  cth_typeoff  = %u\n"
argument_list|,
name|hp
operator|->
name|cth_typeoff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  cth_stroff   = %u\n"
argument_list|,
name|hp
operator|->
name|cth_stroff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  cth_strlen   = %u\n"
argument_list|,
name|hp
operator|->
name|cth_strlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_labeltable
parameter_list|(
specifier|const
name|ctf_header_t
modifier|*
name|hp
parameter_list|,
specifier|const
name|ctf_data_t
modifier|*
name|cd
parameter_list|)
block|{
name|void
modifier|*
name|v
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|cd
operator|->
name|cd_ctfdata
operator|+
name|hp
operator|->
name|cth_lbloff
operator|)
decl_stmt|;
specifier|const
name|ctf_lblent_t
modifier|*
name|ctl
init|=
name|v
decl_stmt|;
name|ulong_t
name|i
decl_stmt|,
name|n
init|=
operator|(
name|hp
operator|->
name|cth_objtoff
operator|-
name|hp
operator|->
name|cth_lbloff
operator|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|ctl
argument_list|)
decl_stmt|;
name|print_line
argument_list|(
literal|"- Label Table "
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_lbloff
operator|&
literal|3
condition|)
name|WARN
argument_list|(
literal|"cth_lbloff is not aligned properly\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_lbloff
operator|>=
name|cd
operator|->
name|cd_ctflen
condition|)
name|WARN
argument_list|(
literal|"file is truncated or cth_lbloff is corrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_objtoff
operator|>=
name|cd
operator|->
name|cd_ctflen
condition|)
name|WARN
argument_list|(
literal|"file is truncated or cth_objtoff is corrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_lbloff
operator|>
name|hp
operator|->
name|cth_objtoff
condition|)
name|WARN
argument_list|(
literal|"file is corrupt -- cth_lbloff> cth_objtoff\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|ctl
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  %5u %s\n"
argument_list|,
name|ctl
operator|->
name|ctl_typeidx
argument_list|,
name|ref_to_str
argument_list|(
name|ctl
operator|->
name|ctl_label
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|E_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given the current symbol index (-1 to start at the beginning of the symbol  * table) and the type of symbol to match, this function returns the index of  * the next matching symbol (if any), and places the name of that symbol in  * *namep.  If no symbol is found, -1 is returned.  */
end_comment

begin_function
specifier|static
name|int
name|next_sym
parameter_list|(
specifier|const
name|ctf_data_t
modifier|*
name|cd
parameter_list|,
specifier|const
name|int
name|symidx
parameter_list|,
specifier|const
name|uchar_t
name|matchtype
parameter_list|,
name|char
modifier|*
modifier|*
name|namep
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|symidx
operator|+
literal|1
init|;
name|i
operator|<
name|cd
operator|->
name|cd_nsyms
condition|;
name|i
operator|++
control|)
block|{
name|GElf_Sym
name|sym
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
if|if
condition|(
name|gelf_getsym
argument_list|(
name|cd
operator|->
name|cd_symdata
argument_list|,
name|i
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|cd
operator|->
name|cd_strdata
operator|->
name|d_buf
operator|+
name|sym
operator|.
name|st_name
expr_stmt|;
name|type
operator|=
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
expr_stmt|;
comment|/* 		 * Skip various types of symbol table entries. 		 */
if|if
condition|(
name|type
operator|!=
name|matchtype
operator|||
name|ignore_symbol
argument_list|(
operator|&
name|sym
argument_list|,
name|name
argument_list|)
condition|)
continue|continue;
comment|/* Found one */
operator|*
name|namep
operator|=
name|name
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_data
parameter_list|(
specifier|const
name|ctf_header_t
modifier|*
name|hp
parameter_list|,
specifier|const
name|ctf_data_t
modifier|*
name|cd
parameter_list|)
block|{
name|void
modifier|*
name|v
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|cd
operator|->
name|cd_ctfdata
operator|+
name|hp
operator|->
name|cth_objtoff
operator|)
decl_stmt|;
specifier|const
name|ushort_t
modifier|*
name|idp
init|=
name|v
decl_stmt|;
name|ulong_t
name|n
init|=
operator|(
name|hp
operator|->
name|cth_funcoff
operator|-
name|hp
operator|->
name|cth_objtoff
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
name|print_line
argument_list|(
literal|"- Data Objects "
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_objtoff
operator|&
literal|1
condition|)
name|WARN
argument_list|(
literal|"cth_objtoff is not aligned properly\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_objtoff
operator|>=
name|cd
operator|->
name|cd_ctflen
condition|)
name|WARN
argument_list|(
literal|"file is truncated or cth_objtoff is corrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_funcoff
operator|>=
name|cd
operator|->
name|cd_ctflen
condition|)
name|WARN
argument_list|(
literal|"file is truncated or cth_funcoff is corrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_objtoff
operator|>
name|hp
operator|->
name|cth_funcoff
condition|)
name|WARN
argument_list|(
literal|"file is corrupt -- cth_objtoff> cth_funcoff\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
name|int
name|symidx
decl_stmt|,
name|len
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|symidx
operator|=
operator|-
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|n
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nextsym
decl_stmt|;
if|if
condition|(
name|cd
operator|->
name|cd_symdata
operator|==
name|NULL
operator|||
operator|(
name|nextsym
operator|=
name|next_sym
argument_list|(
name|cd
argument_list|,
name|symidx
argument_list|,
name|STT_OBJECT
argument_list|,
operator|&
name|name
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|name
operator|=
name|NULL
expr_stmt|;
else|else
name|symidx
operator|=
name|nextsym
expr_stmt|;
name|len
operator|=
name|printf
argument_list|(
literal|"  [%u] %u"
argument_list|,
name|i
argument_list|,
operator|*
name|idp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s (%u)"
argument_list|,
operator|(
literal|15
operator|-
name|len
operator|)
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|symidx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
name|stats
operator|.
name|s_ndata
operator|=
name|n
expr_stmt|;
return|return
operator|(
name|E_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_funcs
parameter_list|(
specifier|const
name|ctf_header_t
modifier|*
name|hp
parameter_list|,
specifier|const
name|ctf_data_t
modifier|*
name|cd
parameter_list|)
block|{
name|void
modifier|*
name|v
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|cd
operator|->
name|cd_ctfdata
operator|+
name|hp
operator|->
name|cth_funcoff
operator|)
decl_stmt|;
specifier|const
name|ushort_t
modifier|*
name|fp
init|=
name|v
decl_stmt|;
name|v
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|cd
operator|->
name|cd_ctfdata
operator|+
name|hp
operator|->
name|cth_typeoff
operator|)
expr_stmt|;
specifier|const
name|ushort_t
modifier|*
name|end
init|=
name|v
decl_stmt|;
name|ulong_t
name|id
decl_stmt|;
name|int
name|symidx
decl_stmt|;
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
name|print_line
argument_list|(
literal|"- Functions "
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_funcoff
operator|&
literal|1
condition|)
name|WARN
argument_list|(
literal|"cth_funcoff is not aligned properly\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_funcoff
operator|>=
name|cd
operator|->
name|cd_ctflen
condition|)
name|WARN
argument_list|(
literal|"file is truncated or cth_funcoff is corrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_typeoff
operator|>=
name|cd
operator|->
name|cd_ctflen
condition|)
name|WARN
argument_list|(
literal|"file is truncated or cth_typeoff is corrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_funcoff
operator|>
name|hp
operator|->
name|cth_typeoff
condition|)
name|WARN
argument_list|(
literal|"file is corrupt -- cth_funcoff> cth_typeoff\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|symidx
operator|=
operator|-
literal|1
operator|,
name|id
operator|=
literal|0
init|;
name|fp
operator|<
name|end
condition|;
name|id
operator|++
control|)
block|{
name|ushort_t
name|info
init|=
operator|*
name|fp
operator|++
decl_stmt|;
name|ushort_t
name|kind
init|=
name|CTF_INFO_KIND
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|ushort_t
name|n
init|=
name|CTF_INFO_VLEN
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|ushort_t
name|i
decl_stmt|;
name|int
name|nextsym
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|cd
operator|->
name|cd_symdata
operator|==
name|NULL
operator|||
operator|(
name|nextsym
operator|=
name|next_sym
argument_list|(
name|cd
argument_list|,
name|symidx
argument_list|,
name|STT_FUNC
argument_list|,
operator|&
name|name
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|name
operator|=
name|NULL
expr_stmt|;
else|else
name|symidx
operator|=
name|nextsym
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_UNKNOWN
operator|&&
name|n
operator|==
literal|0
condition|)
continue|continue;
comment|/* skip padding */
if|if
condition|(
name|kind
operator|!=
name|CTF_K_FUNCTION
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  [%lu] unexpected kind -- %u\n"
argument_list|,
name|id
argument_list|,
name|kind
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|fp
operator|+
name|n
operator|>
name|end
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  [%lu] vlen %u extends past section "
literal|"boundary\n"
argument_list|,
name|id
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  [%lu] FUNC "
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(%s) "
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"returns: %u args: ("
argument_list|,
operator|*
name|fp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%u"
argument_list|,
operator|*
name|fp
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|", %u"
argument_list|,
operator|*
name|fp
operator|++
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fp
operator|+=
name|n
operator|+
literal|1
expr_stmt|;
comment|/* skip to next function definition */
name|stats
operator|.
name|s_nfunc
operator|++
expr_stmt|;
name|stats
operator|.
name|s_nargs
operator|+=
name|n
expr_stmt|;
name|stats
operator|.
name|s_argmax
operator|=
name|MAX
argument_list|(
name|stats
operator|.
name|s_argmax
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|E_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_types
parameter_list|(
specifier|const
name|ctf_header_t
modifier|*
name|hp
parameter_list|,
specifier|const
name|ctf_data_t
modifier|*
name|cd
parameter_list|)
block|{
name|void
modifier|*
name|v
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|cd
operator|->
name|cd_ctfdata
operator|+
name|hp
operator|->
name|cth_typeoff
operator|)
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
init|=
name|v
decl_stmt|;
name|v
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|cd
operator|->
name|cd_ctfdata
operator|+
name|hp
operator|->
name|cth_stroff
operator|)
expr_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|end
init|=
name|v
decl_stmt|;
name|ulong_t
name|id
decl_stmt|;
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
name|print_line
argument_list|(
literal|"- Types "
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_typeoff
operator|&
literal|3
condition|)
name|WARN
argument_list|(
literal|"cth_typeoff is not aligned properly\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_typeoff
operator|>=
name|cd
operator|->
name|cd_ctflen
condition|)
name|WARN
argument_list|(
literal|"file is truncated or cth_typeoff is corrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_stroff
operator|>=
name|cd
operator|->
name|cd_ctflen
condition|)
name|WARN
argument_list|(
literal|"file is truncated or cth_stroff is corrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_typeoff
operator|>
name|hp
operator|->
name|cth_stroff
condition|)
name|WARN
argument_list|(
literal|"file is corrupt -- cth_typeoff> cth_stroff\n"
argument_list|)
expr_stmt|;
name|id
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_parlabel
operator|||
name|hp
operator|->
name|cth_parname
condition|)
name|id
operator|+=
literal|1
operator|<<
name|CTF_PARENT_SHIFT
expr_stmt|;
for|for
control|(
comment|/* */
init|;
name|tp
operator|<
name|end
condition|;
name|id
operator|++
control|)
block|{
name|ulong_t
name|i
decl_stmt|,
name|n
init|=
name|CTF_INFO_VLEN
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|increment
decl_stmt|,
name|vlen
init|=
literal|0
decl_stmt|;
name|int
name|kind
init|=
name|CTF_INFO_KIND
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
union|union
block|{
specifier|const
name|void
modifier|*
name|ptr
decl_stmt|;
name|ctf_array_t
modifier|*
name|ap
decl_stmt|;
specifier|const
name|ctf_member_t
modifier|*
name|mp
decl_stmt|;
specifier|const
name|ctf_lmember_t
modifier|*
name|lmp
decl_stmt|;
specifier|const
name|ctf_enum_t
modifier|*
name|ep
decl_stmt|;
specifier|const
name|ushort_t
modifier|*
name|argp
decl_stmt|;
block|}
name|u
union|;
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  %c%lu%c "
argument_list|,
literal|"[<"
index|[
name|CTF_INFO_ISROOT
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
index|]
argument_list|,
name|id
argument_list|,
literal|"]>"
index|[
name|CTF_INFO_ISROOT
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|ctt_size
operator|==
name|CTF_LSIZE_SENT
condition|)
block|{
name|increment
operator|=
sizeof|sizeof
argument_list|(
name|ctf_type_t
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|size_t
operator|)
name|CTF_TYPE_LSIZE
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|increment
operator|=
sizeof|sizeof
argument_list|(
name|ctf_stype_t
argument_list|)
expr_stmt|;
name|size
operator|=
name|tp
operator|->
name|ctt_size
expr_stmt|;
block|}
name|u
operator|.
name|ptr
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|tp
operator|+
name|increment
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
name|uint_t
name|encoding
init|=
operator|*
operator|(
operator|(
specifier|const
name|uint_t
operator|*
operator|)
name|u
operator|.
name|ptr
operator|)
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"INTEGER %s encoding=%s offset=%u"
literal|" bits=%u"
argument_list|,
name|ref_to_str
argument_list|(
name|tp
operator|->
name|ctt_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|,
name|int_encoding_to_str
argument_list|(
name|CTF_INT_ENCODING
argument_list|(
name|encoding
argument_list|)
argument_list|)
argument_list|,
name|CTF_INT_OFFSET
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|CTF_INT_BITS
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|vlen
operator|=
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FLOAT
case|:
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
name|uint_t
name|encoding
init|=
operator|*
operator|(
operator|(
specifier|const
name|uint_t
operator|*
operator|)
name|u
operator|.
name|ptr
operator|)
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"FLOAT %s encoding=%s offset=%u "
literal|"bits=%u"
argument_list|,
name|ref_to_str
argument_list|(
name|tp
operator|->
name|ctt_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|,
name|fp_encoding_to_str
argument_list|(
name|CTF_FP_ENCODING
argument_list|(
name|encoding
argument_list|)
argument_list|)
argument_list|,
name|CTF_FP_OFFSET
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|CTF_FP_BITS
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|vlen
operator|=
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"POINTER %s refers to %u"
argument_list|,
name|ref_to_str
argument_list|(
name|tp
operator|->
name|ctt_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_ARRAY
case|:
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ARRAY %s content: %u index: %u "
literal|"nelems: %u\n"
argument_list|,
name|ref_to_str
argument_list|(
name|tp
operator|->
name|ctt_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|,
name|u
operator|.
name|ap
operator|->
name|cta_contents
argument_list|,
name|u
operator|.
name|ap
operator|->
name|cta_index
argument_list|,
name|u
operator|.
name|ap
operator|->
name|cta_nelems
argument_list|)
expr_stmt|;
block|}
name|vlen
operator|=
sizeof|sizeof
argument_list|(
name|ctf_array_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"FUNCTION %s returns: %u args: ("
argument_list|,
name|ref_to_str
argument_list|(
name|tp
operator|->
name|ctt_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%u"
argument_list|,
operator|*
name|u
operator|.
name|argp
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|u
operator|.
name|argp
operator|++
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|", %u"
argument_list|,
operator|*
name|u
operator|.
name|argp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|vlen
operator|=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|n
operator|+
operator|(
name|n
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
if|if
condition|(
name|kind
operator|==
name|CTF_K_STRUCT
condition|)
block|{
name|stats
operator|.
name|s_nsmem
operator|+=
name|n
expr_stmt|;
name|stats
operator|.
name|s_smmax
operator|=
name|MAX
argument_list|(
name|stats
operator|.
name|s_smmax
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|stats
operator|.
name|s_nsbytes
operator|+=
name|size
expr_stmt|;
name|stats
operator|.
name|s_sbmax
operator|=
name|MAX
argument_list|(
name|stats
operator|.
name|s_sbmax
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"STRUCT"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stats
operator|.
name|s_numem
operator|+=
name|n
expr_stmt|;
name|stats
operator|.
name|s_ummax
operator|=
name|MAX
argument_list|(
name|stats
operator|.
name|s_ummax
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|stats
operator|.
name|s_nubytes
operator|+=
name|size
expr_stmt|;
name|stats
operator|.
name|s_ubmax
operator|=
name|MAX
argument_list|(
name|stats
operator|.
name|s_ubmax
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"UNION"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %s (%zd bytes)\n"
argument_list|,
name|ref_to_str
argument_list|(
name|tp
operator|->
name|ctt_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|CTF_LSTRUCT_THRESH
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|u
operator|.
name|lmp
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s type=%u off=%llu\n"
argument_list|,
name|ref_to_str
argument_list|(
name|u
operator|.
name|lmp
operator|->
name|ctlm_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|,
name|u
operator|.
name|lmp
operator|->
name|ctlm_type
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|CTF_LMEM_OFFSET
argument_list|(
name|u
operator|.
name|lmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|u
operator|.
name|mp
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s type=%u off=%u\n"
argument_list|,
name|ref_to_str
argument_list|(
name|u
operator|.
name|mp
operator|->
name|ctm_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|,
name|u
operator|.
name|mp
operator|->
name|ctm_type
argument_list|,
name|u
operator|.
name|mp
operator|->
name|ctm_offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|vlen
operator|=
name|n
operator|*
operator|(
name|size
operator|>=
name|CTF_LSTRUCT_THRESH
condition|?
sizeof|sizeof
argument_list|(
name|ctf_lmember_t
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|ctf_member_t
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ENUM
case|:
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ENUM %s\n"
argument_list|,
name|ref_to_str
argument_list|(
name|tp
operator|->
name|ctt_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|u
operator|.
name|ep
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s = %d\n"
argument_list|,
name|ref_to_str
argument_list|(
name|u
operator|.
name|ep
operator|->
name|cte_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|,
name|u
operator|.
name|ep
operator|->
name|cte_value
argument_list|)
expr_stmt|;
block|}
block|}
name|stats
operator|.
name|s_nemem
operator|+=
name|n
expr_stmt|;
name|stats
operator|.
name|s_emmax
operator|=
name|MAX
argument_list|(
name|stats
operator|.
name|s_emmax
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|vlen
operator|=
sizeof|sizeof
argument_list|(
name|ctf_enum_t
argument_list|)
operator|*
name|n
expr_stmt|;
break|break;
case|case
name|CTF_K_FORWARD
case|:
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"FORWARD %s"
argument_list|,
name|ref_to_str
argument_list|(
name|tp
operator|->
name|ctt_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_TYPEDEF
case|:
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"TYPEDEF %s refers to %u"
argument_list|,
name|ref_to_str
argument_list|(
name|tp
operator|->
name|ctt_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_VOLATILE
case|:
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"VOLATILE %s refers to %u"
argument_list|,
name|ref_to_str
argument_list|(
name|tp
operator|->
name|ctt_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_CONST
case|:
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"CONST %s refers to %u"
argument_list|,
name|ref_to_str
argument_list|(
name|tp
operator|->
name|ctt_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_RESTRICT
case|:
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"RESTRICT %s refers to %u"
argument_list|,
name|ref_to_str
argument_list|(
name|tp
operator|->
name|ctt_name
argument_list|,
name|hp
argument_list|,
name|cd
argument_list|)
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_UNKNOWN
case|:
break|break;
comment|/* hole in type id space */
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"unexpected kind %u\n"
argument_list|,
name|kind
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|stats
operator|.
name|s_ntypes
operator|++
expr_stmt|;
name|stats
operator|.
name|s_types
index|[
name|kind
index|]
operator|++
expr_stmt|;
name|tp
operator|=
operator|(
name|ctf_type_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|+
name|vlen
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|E_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_strtab
parameter_list|(
specifier|const
name|ctf_header_t
modifier|*
name|hp
parameter_list|,
specifier|const
name|ctf_data_t
modifier|*
name|cd
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|,
name|off
decl_stmt|,
name|len
init|=
name|hp
operator|->
name|cth_strlen
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|cd
operator|->
name|cd_ctfdata
operator|+
name|hp
operator|->
name|cth_stroff
decl_stmt|;
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
name|print_line
argument_list|(
literal|"- String Table "
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_stroff
operator|>=
name|cd
operator|->
name|cd_ctflen
condition|)
name|WARN
argument_list|(
literal|"file is truncated or cth_stroff is corrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|cth_stroff
operator|+
name|hp
operator|->
name|cth_strlen
operator|>
name|cd
operator|->
name|cd_ctflen
condition|)
name|WARN
argument_list|(
literal|"file is truncated or cth_strlen is corrupt\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|len
operator|!=
literal|0
condition|;
name|off
operator|+=
name|n
control|)
block|{
if|if
condition|(
name|flags
operator|!=
name|F_STATS
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  [%lu] %s\n"
argument_list|,
operator|(
name|ulong_t
operator|)
name|off
argument_list|,
name|s
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|?
literal|"\\0"
else|:
name|s
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
name|s
operator|+=
name|n
expr_stmt|;
name|stats
operator|.
name|s_nstr
operator|++
expr_stmt|;
name|stats
operator|.
name|s_strlen
operator|+=
name|n
expr_stmt|;
name|stats
operator|.
name|s_strmax
operator|=
name|MAX
argument_list|(
name|stats
operator|.
name|s_strmax
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|E_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|long_stat
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ulong_t
name|value
parameter_list|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  %-36s= %lu\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fp_stat
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|float
name|value
parameter_list|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  %-36s= %.2f\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|print_line
argument_list|(
literal|"- CTF Statistics "
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of data objects"
argument_list|,
name|stats
operator|.
name|s_ndata
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of functions"
argument_list|,
name|stats
operator|.
name|s_nfunc
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of function arguments"
argument_list|,
name|stats
operator|.
name|s_nargs
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"maximum argument list length"
argument_list|,
name|stats
operator|.
name|s_argmax
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
operator|.
name|s_nfunc
operator|!=
literal|0
condition|)
block|{
name|fp_stat
argument_list|(
literal|"average argument list length"
argument_list|,
operator|(
name|float
operator|)
name|stats
operator|.
name|s_nargs
operator|/
operator|(
name|float
operator|)
name|stats
operator|.
name|s_nfunc
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of types"
argument_list|,
name|stats
operator|.
name|s_ntypes
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of integers"
argument_list|,
name|stats
operator|.
name|s_types
index|[
name|CTF_K_INTEGER
index|]
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of floats"
argument_list|,
name|stats
operator|.
name|s_types
index|[
name|CTF_K_FLOAT
index|]
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of pointers"
argument_list|,
name|stats
operator|.
name|s_types
index|[
name|CTF_K_POINTER
index|]
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of arrays"
argument_list|,
name|stats
operator|.
name|s_types
index|[
name|CTF_K_ARRAY
index|]
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of func types"
argument_list|,
name|stats
operator|.
name|s_types
index|[
name|CTF_K_FUNCTION
index|]
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of structs"
argument_list|,
name|stats
operator|.
name|s_types
index|[
name|CTF_K_STRUCT
index|]
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of unions"
argument_list|,
name|stats
operator|.
name|s_types
index|[
name|CTF_K_UNION
index|]
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of enums"
argument_list|,
name|stats
operator|.
name|s_types
index|[
name|CTF_K_ENUM
index|]
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of forward tags"
argument_list|,
name|stats
operator|.
name|s_types
index|[
name|CTF_K_FORWARD
index|]
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of typedefs"
argument_list|,
name|stats
operator|.
name|s_types
index|[
name|CTF_K_TYPEDEF
index|]
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of volatile types"
argument_list|,
name|stats
operator|.
name|s_types
index|[
name|CTF_K_VOLATILE
index|]
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of const types"
argument_list|,
name|stats
operator|.
name|s_types
index|[
name|CTF_K_CONST
index|]
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of restrict types"
argument_list|,
name|stats
operator|.
name|s_types
index|[
name|CTF_K_RESTRICT
index|]
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of unknowns (holes)"
argument_list|,
name|stats
operator|.
name|s_types
index|[
name|CTF_K_UNKNOWN
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of struct members"
argument_list|,
name|stats
operator|.
name|s_nsmem
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"maximum number of struct members"
argument_list|,
name|stats
operator|.
name|s_smmax
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total size of all structs"
argument_list|,
name|stats
operator|.
name|s_nsbytes
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"maximum size of a struct"
argument_list|,
name|stats
operator|.
name|s_sbmax
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
operator|.
name|s_types
index|[
name|CTF_K_STRUCT
index|]
operator|!=
literal|0
condition|)
block|{
name|fp_stat
argument_list|(
literal|"average number of struct members"
argument_list|,
operator|(
name|float
operator|)
name|stats
operator|.
name|s_nsmem
operator|/
operator|(
name|float
operator|)
name|stats
operator|.
name|s_types
index|[
name|CTF_K_STRUCT
index|]
argument_list|)
expr_stmt|;
name|fp_stat
argument_list|(
literal|"average size of a struct"
argument_list|,
operator|(
name|float
operator|)
name|stats
operator|.
name|s_nsbytes
operator|/
operator|(
name|float
operator|)
name|stats
operator|.
name|s_types
index|[
name|CTF_K_STRUCT
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of union members"
argument_list|,
name|stats
operator|.
name|s_numem
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"maximum number of union members"
argument_list|,
name|stats
operator|.
name|s_ummax
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total size of all unions"
argument_list|,
name|stats
operator|.
name|s_nubytes
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"maximum size of a union"
argument_list|,
name|stats
operator|.
name|s_ubmax
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
operator|.
name|s_types
index|[
name|CTF_K_UNION
index|]
operator|!=
literal|0
condition|)
block|{
name|fp_stat
argument_list|(
literal|"average number of union members"
argument_list|,
operator|(
name|float
operator|)
name|stats
operator|.
name|s_numem
operator|/
operator|(
name|float
operator|)
name|stats
operator|.
name|s_types
index|[
name|CTF_K_UNION
index|]
argument_list|)
expr_stmt|;
name|fp_stat
argument_list|(
literal|"average size of a union"
argument_list|,
operator|(
name|float
operator|)
name|stats
operator|.
name|s_nubytes
operator|/
operator|(
name|float
operator|)
name|stats
operator|.
name|s_types
index|[
name|CTF_K_UNION
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of enum members"
argument_list|,
name|stats
operator|.
name|s_nemem
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"maximum number of enum members"
argument_list|,
name|stats
operator|.
name|s_emmax
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
operator|.
name|s_types
index|[
name|CTF_K_ENUM
index|]
operator|!=
literal|0
condition|)
block|{
name|fp_stat
argument_list|(
literal|"average number of enum members"
argument_list|,
operator|(
name|float
operator|)
name|stats
operator|.
name|s_nemem
operator|/
operator|(
name|float
operator|)
name|stats
operator|.
name|s_types
index|[
name|CTF_K_ENUM
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"total number of unique strings"
argument_list|,
name|stats
operator|.
name|s_nstr
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"bytes of string data"
argument_list|,
name|stats
operator|.
name|s_strlen
argument_list|)
expr_stmt|;
name|long_stat
argument_list|(
literal|"maximum string length"
argument_list|,
name|stats
operator|.
name|s_strmax
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
operator|.
name|s_nstr
operator|!=
literal|0
condition|)
block|{
name|fp_stat
argument_list|(
literal|"average string length"
argument_list|,
operator|(
name|float
operator|)
name|stats
operator|.
name|s_strlen
operator|/
operator|(
name|float
operator|)
name|stats
operator|.
name|s_nstr
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_usage
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Usage: %s [-dfhlsSt] [-u file] file\n"
argument_list|,
name|getpname
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t-d  dump data object section\n"
literal|"\t-f  dump function section\n"
literal|"\t-h  dump file header\n"
literal|"\t-l  dump label table\n"
literal|"\t-s  dump string table\n"
literal|"\t-S  dump statistics\n"
literal|"\t-t  dump type section\n"
literal|"\t-u  save uncompressed CTF to a file\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|E_USAGE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Elf_Scn
modifier|*
name|findelfscn
parameter_list|(
name|Elf
modifier|*
name|elf
parameter_list|,
name|GElf_Ehdr
modifier|*
name|ehdr
parameter_list|,
specifier|const
name|char
modifier|*
name|secname
parameter_list|)
block|{
name|GElf_Shdr
name|shdr
decl_stmt|;
name|Elf_Scn
modifier|*
name|scn
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
for|for
control|(
name|scn
operator|=
name|NULL
init|;
operator|(
name|scn
operator|=
name|elf_nextscn
argument_list|(
name|elf
argument_list|,
name|scn
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|shdr
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|elf
argument_list|,
name|ehdr
operator|->
name|e_shstrndx
argument_list|,
name|shdr
operator|.
name|sh_name
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|secname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|scn
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|ufile
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|,
name|fd
decl_stmt|,
name|ufd
decl_stmt|;
name|ctf_data_t
name|cd
decl_stmt|;
specifier|const
name|ctf_preamble_t
modifier|*
name|pp
decl_stmt|;
name|ctf_header_t
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|Elf
modifier|*
name|elf
decl_stmt|;
name|GElf_Ehdr
name|ehdr
decl_stmt|;
operator|(
name|void
operator|)
name|elf_version
argument_list|(
name|EV_CURRENT
argument_list|)
expr_stmt|;
for|for
control|(
name|opterr
operator|=
literal|0
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"dfhlsStu:"
argument_list|)
operator|)
operator|!=
operator|(
name|int
operator|)
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
name|flags
operator||=
name|F_DATA
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flags
operator||=
name|F_FUNC
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|flags
operator||=
name|F_HDR
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|flags
operator||=
name|F_LABEL
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|flags
operator||=
name|F_STR
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|flags
operator||=
name|F_STATS
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|flags
operator||=
name|F_TYPES
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|ufile
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|optopt
operator|==
literal|'?'
condition|)
return|return
operator|(
name|print_usage
argument_list|(
name|stdout
argument_list|,
literal|1
argument_list|)
operator|)
return|;
name|warn
argument_list|(
literal|"illegal option -- %c\n"
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
return|return
operator|(
name|print_usage
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
return|return
operator|(
name|print_usage
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
operator|)
return|;
name|filename
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
return|return
operator|(
name|print_usage
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
operator|)
return|;
if|if
condition|(
name|flags
operator|==
literal|0
operator|&&
name|ufile
operator|==
name|NULL
condition|)
name|flags
operator|=
name|F_ALLMSK
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|die
argument_list|(
literal|"failed to open %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|ELF_C_READ
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|gelf_getehdr
argument_list|(
name|elf
argument_list|,
operator|&
name|ehdr
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|Elf_Data
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|Elf_Scn
modifier|*
name|ctfscn
init|=
name|findelfscn
argument_list|(
name|elf
argument_list|,
operator|&
name|ehdr
argument_list|,
literal|".SUNW_ctf"
argument_list|)
decl_stmt|;
name|Elf_Scn
modifier|*
name|symscn
decl_stmt|;
name|GElf_Shdr
name|ctfshdr
decl_stmt|;
if|if
condition|(
name|ctfscn
operator|==
name|NULL
operator|||
operator|(
name|dp
operator|=
name|elf_getdata
argument_list|(
name|ctfscn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|die
argument_list|(
literal|"%s does not contain .SUNW_ctf data\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|cd
operator|.
name|cd_ctfdata
operator|=
name|dp
operator|->
name|d_buf
expr_stmt|;
name|cd
operator|.
name|cd_ctflen
operator|=
name|dp
operator|->
name|d_size
expr_stmt|;
comment|/* 		 * If the sh_link field of the CTF section header is non-zero 		 * it indicates which section contains the symbol table that 		 * should be used. We default to the .symtab section if sh_link 		 * is zero or if there's an error reading the section header. 		 */
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|ctfscn
argument_list|,
operator|&
name|ctfshdr
argument_list|)
operator|!=
name|NULL
operator|&&
name|ctfshdr
operator|.
name|sh_link
operator|!=
literal|0
condition|)
block|{
name|symscn
operator|=
name|elf_getscn
argument_list|(
name|elf
argument_list|,
name|ctfshdr
operator|.
name|sh_link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symscn
operator|=
name|findelfscn
argument_list|(
name|elf
argument_list|,
operator|&
name|ehdr
argument_list|,
literal|".symtab"
argument_list|)
expr_stmt|;
block|}
comment|/* If we found a symbol table, find the corresponding strings */
if|if
condition|(
name|symscn
operator|!=
name|NULL
condition|)
block|{
name|GElf_Shdr
name|shdr
decl_stmt|;
name|Elf_Scn
modifier|*
name|symstrscn
decl_stmt|;
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|symscn
argument_list|,
operator|&
name|shdr
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|symstrscn
operator|=
name|elf_getscn
argument_list|(
name|elf
argument_list|,
name|shdr
operator|.
name|sh_link
argument_list|)
expr_stmt|;
name|cd
operator|.
name|cd_nsyms
operator|=
name|shdr
operator|.
name|sh_size
operator|/
name|shdr
operator|.
name|sh_entsize
expr_stmt|;
name|cd
operator|.
name|cd_symdata
operator|=
name|elf_getdata
argument_list|(
name|symscn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cd
operator|.
name|cd_strdata
operator|=
name|elf_getdata
argument_list|(
name|symstrscn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|die
argument_list|(
literal|"failed to fstat %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|cd
operator|.
name|cd_ctflen
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|cd
operator|.
name|cd_ctfdata
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|cd
operator|.
name|cd_ctflen
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|.
name|cd_ctfdata
operator|==
name|MAP_FAILED
condition|)
name|die
argument_list|(
literal|"failed to mmap %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get a pointer to the CTF data buffer and interpret the first portion 	 * as a ctf_header_t.  Validate the magic number and size. 	 */
if|if
condition|(
name|cd
operator|.
name|cd_ctflen
operator|<
sizeof|sizeof
argument_list|(
name|ctf_preamble_t
argument_list|)
condition|)
name|die
argument_list|(
literal|"%s does not contain a CTF preamble\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|void
modifier|*
name|v
init|=
operator|(
name|void
operator|*
operator|)
name|cd
operator|.
name|cd_ctfdata
decl_stmt|;
name|pp
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|ctp_magic
operator|!=
name|CTF_MAGIC
condition|)
name|die
argument_list|(
literal|"%s does not appear to contain CTF data\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|ctp_version
operator|==
name|CTF_VERSION
condition|)
block|{
name|v
operator|=
operator|(
name|void
operator|*
operator|)
name|cd
operator|.
name|cd_ctfdata
expr_stmt|;
name|hp
operator|=
name|v
expr_stmt|;
name|cd
operator|.
name|cd_ctfdata
operator|=
operator|(
name|caddr_t
operator|)
name|cd
operator|.
name|cd_ctfdata
operator|+
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|.
name|cd_ctflen
operator|<
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
condition|)
block|{
name|die
argument_list|(
literal|"%s does not contain a v%d CTF header\n"
argument_list|,
name|filename
argument_list|,
name|CTF_VERSION
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|die
argument_list|(
literal|"%s contains unsupported CTF version %d\n"
argument_list|,
name|filename
argument_list|,
name|pp
operator|->
name|ctp_version
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the data buffer is compressed, then malloc a buffer large enough 	 * to hold the decompressed data, and use zlib to decompress it. 	 */
if|if
condition|(
name|hp
operator|->
name|cth_flags
operator|&
name|CTF_F_COMPRESS
condition|)
block|{
name|z_stream
name|zstr
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|hp
operator|->
name|cth_stroff
operator|+
name|hp
operator|->
name|cth_strlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|die
argument_list|(
literal|"failed to allocate decompression buffer"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|zstr
argument_list|,
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
argument_list|)
expr_stmt|;
name|zstr
operator|.
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
name|cd
operator|.
name|cd_ctfdata
expr_stmt|;
name|zstr
operator|.
name|avail_in
operator|=
name|cd
operator|.
name|cd_ctflen
expr_stmt|;
name|zstr
operator|.
name|next_out
operator|=
name|buf
expr_stmt|;
name|zstr
operator|.
name|avail_out
operator|=
name|hp
operator|->
name|cth_stroff
operator|+
name|hp
operator|->
name|cth_strlen
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|inflateInit
argument_list|(
operator|&
name|zstr
argument_list|)
operator|)
operator|!=
name|Z_OK
condition|)
name|die
argument_list|(
literal|"failed to initialize zlib: %s\n"
argument_list|,
name|zError
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|inflate
argument_list|(
operator|&
name|zstr
argument_list|,
name|Z_FINISH
argument_list|)
operator|)
operator|!=
name|Z_STREAM_END
condition|)
name|die
argument_list|(
literal|"failed to decompress CTF data: %s\n"
argument_list|,
name|zError
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|inflateEnd
argument_list|(
operator|&
name|zstr
argument_list|)
operator|)
operator|!=
name|Z_OK
condition|)
name|die
argument_list|(
literal|"failed to finish decompression: %s\n"
argument_list|,
name|zError
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|.
name|total_out
operator|!=
name|hp
operator|->
name|cth_stroff
operator|+
name|hp
operator|->
name|cth_strlen
condition|)
name|die
argument_list|(
literal|"CTF data is corrupt -- short decompression\n"
argument_list|)
expr_stmt|;
name|cd
operator|.
name|cd_ctfdata
operator|=
name|buf
expr_stmt|;
name|cd
operator|.
name|cd_ctflen
operator|=
name|hp
operator|->
name|cth_stroff
operator|+
name|hp
operator|->
name|cth_strlen
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|F_HDR
condition|)
name|error
operator||=
name|print_header
argument_list|(
name|hp
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|F_LABEL
operator|)
condition|)
name|error
operator||=
name|print_labeltable
argument_list|(
name|hp
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|F_DATA
operator||
name|F_STATS
operator|)
condition|)
name|error
operator||=
name|read_data
argument_list|(
name|hp
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|F_FUNC
operator||
name|F_STATS
operator|)
condition|)
name|error
operator||=
name|read_funcs
argument_list|(
name|hp
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|F_TYPES
operator||
name|F_STATS
operator|)
condition|)
name|error
operator||=
name|read_types
argument_list|(
name|hp
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|F_STR
operator||
name|F_STATS
operator|)
condition|)
name|error
operator||=
name|read_strtab
argument_list|(
name|hp
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|F_STATS
condition|)
name|error
operator||=
name|print_stats
argument_list|()
expr_stmt|;
comment|/* 	 * If the -u option is specified, write the uncompressed CTF data to a 	 * raw CTF file.  CTF data can already be extracted compressed by 	 * applying elfdump -w -N .SUNW_ctf to an ELF file, so we don't bother. 	 */
if|if
condition|(
name|ufile
operator|!=
name|NULL
condition|)
block|{
name|ctf_header_t
name|h
decl_stmt|;
name|bcopy
argument_list|(
name|hp
argument_list|,
operator|&
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|cth_flags
operator|&=
operator|~
name|CTF_F_COMPRESS
expr_stmt|;
if|if
condition|(
operator|(
name|ufd
operator|=
name|open
argument_list|(
name|ufile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|write
argument_list|(
name|ufd
argument_list|,
operator|&
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|h
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|h
argument_list|)
operator|||
name|write
argument_list|(
name|ufd
argument_list|,
name|cd
operator|.
name|cd_ctfdata
argument_list|,
name|cd
operator|.
name|cd_ctflen
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|cd
operator|.
name|cd_ctflen
condition|)
block|{
name|warn
argument_list|(
literal|"failed to write CTF data to '%s'"
argument_list|,
name|ufile
argument_list|)
expr_stmt|;
name|error
operator||=
name|E_ERROR
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|ufd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|elf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

