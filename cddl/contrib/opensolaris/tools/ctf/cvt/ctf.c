begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Create and parse buffers containing CTF data.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_include
include|#
directive|include
file|<elf.h>
end_include

begin_include
include|#
directive|include
file|"ctf_headers.h"
end_include

begin_include
include|#
directive|include
file|"ctftools.h"
end_include

begin_include
include|#
directive|include
file|"strtab.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_comment
comment|/*  * Name of the file currently being read, used to print error messages.  We  * assume that only one file will be read at a time, and thus make no attempt  * to allow curfile to be used simultaneously by multiple threads.  *  * The value is only valid during a call to ctf_load.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|curfile
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CTF_BUF_CHUNK_SIZE
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|RES_BUF_CHUNK_SIZE
value|(64 * 1024)
end_define

begin_struct
struct|struct
name|ctf_buf
block|{
name|strtab_t
name|ctb_strtab
decl_stmt|;
comment|/* string table */
name|caddr_t
name|ctb_base
decl_stmt|;
comment|/* pointer to base of buffer */
name|caddr_t
name|ctb_end
decl_stmt|;
comment|/* pointer to end of buffer */
name|caddr_t
name|ctb_ptr
decl_stmt|;
comment|/* pointer to empty buffer space */
name|size_t
name|ctb_size
decl_stmt|;
comment|/* size of buffer */
name|int
name|nptent
decl_stmt|;
comment|/* number of processed types */
name|int
name|ntholes
decl_stmt|;
comment|/* number of type holes */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Macros to reverse byte order  */
end_comment

begin_define
define|#
directive|define
name|BSWAP_8
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xff)
end_define

begin_define
define|#
directive|define
name|BSWAP_16
parameter_list|(
name|x
parameter_list|)
value|((BSWAP_8(x)<< 8) | BSWAP_8((x)>> 8))
end_define

begin_define
define|#
directive|define
name|BSWAP_32
parameter_list|(
name|x
parameter_list|)
value|((BSWAP_16(x)<< 16) | BSWAP_16((x)>> 16))
end_define

begin_define
define|#
directive|define
name|SWAP_16
parameter_list|(
name|x
parameter_list|)
value|(x) = BSWAP_16(x)
end_define

begin_define
define|#
directive|define
name|SWAP_32
parameter_list|(
name|x
parameter_list|)
value|(x) = BSWAP_32(x)
end_define

begin_decl_stmt
specifier|static
name|int
name|target_requires_swap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*PRINTFLIKE1*/
end_comment

begin_function
specifier|static
name|void
name|parseterminate
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|static
name|char
name|msgbuf
index|[
literal|1024
index|]
decl_stmt|;
comment|/* sigh */
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|curfile
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctf_buf_grow
parameter_list|(
name|ctf_buf_t
modifier|*
name|b
parameter_list|)
block|{
name|off_t
name|ptroff
init|=
name|b
operator|->
name|ctb_ptr
operator|-
name|b
operator|->
name|ctb_base
decl_stmt|;
name|b
operator|->
name|ctb_size
operator|+=
name|CTF_BUF_CHUNK_SIZE
expr_stmt|;
name|b
operator|->
name|ctb_base
operator|=
name|xrealloc
argument_list|(
name|b
operator|->
name|ctb_base
argument_list|,
name|b
operator|->
name|ctb_size
argument_list|)
expr_stmt|;
name|b
operator|->
name|ctb_end
operator|=
name|b
operator|->
name|ctb_base
operator|+
name|b
operator|->
name|ctb_size
expr_stmt|;
name|b
operator|->
name|ctb_ptr
operator|=
name|b
operator|->
name|ctb_base
operator|+
name|ptroff
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ctf_buf_t
modifier|*
name|ctf_buf_new
parameter_list|(
name|void
parameter_list|)
block|{
name|ctf_buf_t
modifier|*
name|b
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ctf_buf_t
argument_list|)
argument_list|)
decl_stmt|;
name|strtab_create
argument_list|(
operator|&
name|b
operator|->
name|ctb_strtab
argument_list|)
expr_stmt|;
name|ctf_buf_grow
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctf_buf_free
parameter_list|(
name|ctf_buf_t
modifier|*
name|b
parameter_list|)
block|{
name|strtab_destroy
argument_list|(
operator|&
name|b
operator|->
name|ctb_strtab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
operator|->
name|ctb_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint_t
name|ctf_buf_cur
parameter_list|(
name|ctf_buf_t
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|b
operator|->
name|ctb_ptr
operator|-
name|b
operator|->
name|ctb_base
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctf_buf_write
parameter_list|(
name|ctf_buf_t
modifier|*
name|b
parameter_list|,
name|void
specifier|const
modifier|*
name|p
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
while|while
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|ctb_ptr
operator|==
name|b
operator|->
name|ctb_end
condition|)
name|ctf_buf_grow
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|len
operator|=
name|MIN
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|b
operator|->
name|ctb_end
operator|-
name|b
operator|->
name|ctb_ptr
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|b
operator|->
name|ctb_ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|b
operator|->
name|ctb_ptr
operator|+=
name|len
expr_stmt|;
name|p
operator|=
operator|(
name|char
specifier|const
operator|*
operator|)
name|p
operator|+
name|len
expr_stmt|;
name|n
operator|-=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|write_label
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|labelent_t
modifier|*
name|le
init|=
name|arg1
decl_stmt|;
name|ctf_buf_t
modifier|*
name|b
init|=
name|arg2
decl_stmt|;
name|ctf_lblent_t
name|ctl
decl_stmt|;
name|ctl
operator|.
name|ctl_label
operator|=
name|strtab_insert
argument_list|(
operator|&
name|b
operator|->
name|ctb_strtab
argument_list|,
name|le
operator|->
name|le_name
argument_list|)
expr_stmt|;
name|ctl
operator|.
name|ctl_typeidx
operator|=
name|le
operator|->
name|le_idx
expr_stmt|;
if|if
condition|(
name|target_requires_swap
condition|)
block|{
name|SWAP_32
argument_list|(
name|ctl
operator|.
name|ctl_label
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|ctl
operator|.
name|ctl_typeidx
argument_list|)
expr_stmt|;
block|}
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
operator|&
name|ctl
argument_list|,
sizeof|sizeof
argument_list|(
name|ctl
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_objects
parameter_list|(
name|iidesc_t
modifier|*
name|idp
parameter_list|,
name|ctf_buf_t
modifier|*
name|b
parameter_list|)
block|{
name|ushort_t
name|id
init|=
operator|(
name|idp
condition|?
name|idp
operator|->
name|ii_dtype
operator|->
name|t_id
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|target_requires_swap
condition|)
block|{
name|SWAP_16
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
operator|&
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Wrote object %s (%d)\n"
argument_list|,
operator|(
name|idp
condition|?
name|idp
operator|->
name|ii_name
else|:
literal|"(null)"
operator|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_functions
parameter_list|(
name|iidesc_t
modifier|*
name|idp
parameter_list|,
name|ctf_buf_t
modifier|*
name|b
parameter_list|)
block|{
name|ushort_t
name|fdata
index|[
literal|2
index|]
decl_stmt|;
name|ushort_t
name|id
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|idp
condition|)
block|{
name|fdata
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
operator|&
name|fdata
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fdata
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Wrote function (null)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|nargs
operator|=
name|idp
operator|->
name|ii_nargs
operator|+
operator|(
name|idp
operator|->
name|ii_vargs
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|>
name|CTF_MAX_VLEN
condition|)
block|{
name|terminate
argument_list|(
literal|"function %s has too many args: %d> %d\n"
argument_list|,
name|idp
operator|->
name|ii_name
argument_list|,
name|nargs
argument_list|,
name|CTF_MAX_VLEN
argument_list|)
expr_stmt|;
block|}
name|fdata
index|[
literal|0
index|]
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_FUNCTION
argument_list|,
literal|1
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|fdata
index|[
literal|1
index|]
operator|=
name|idp
operator|->
name|ii_dtype
operator|->
name|t_id
expr_stmt|;
if|if
condition|(
name|target_requires_swap
condition|)
block|{
name|SWAP_16
argument_list|(
name|fdata
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|SWAP_16
argument_list|(
name|fdata
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
name|fdata
argument_list|,
sizeof|sizeof
argument_list|(
name|fdata
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idp
operator|->
name|ii_nargs
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
name|idp
operator|->
name|ii_args
index|[
name|i
index|]
operator|->
name|t_id
expr_stmt|;
if|if
condition|(
name|target_requires_swap
condition|)
block|{
name|SWAP_16
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
operator|&
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idp
operator|->
name|ii_vargs
condition|)
block|{
name|id
operator|=
literal|0
expr_stmt|;
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
operator|&
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Wrote function %s (%d args)\n"
argument_list|,
name|idp
operator|->
name|ii_name
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Depending on the size of the type being described, either a ctf_stype_t (for  * types with size< CTF_LSTRUCT_THRESH) or a ctf_type_t (all others) will be  * written.  We isolate the determination here so the rest of the writer code  * doesn't need to care.  */
end_comment

begin_function
specifier|static
name|void
name|write_sized_type_rec
parameter_list|(
name|ctf_buf_t
modifier|*
name|b
parameter_list|,
name|ctf_type_t
modifier|*
name|ctt
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|>
name|CTF_MAX_SIZE
condition|)
block|{
name|ctt
operator|->
name|ctt_size
operator|=
name|CTF_LSIZE_SENT
expr_stmt|;
name|ctt
operator|->
name|ctt_lsizehi
operator|=
name|CTF_SIZE_TO_LSIZE_HI
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|ctt
operator|->
name|ctt_lsizelo
operator|=
name|CTF_SIZE_TO_LSIZE_LO
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_requires_swap
condition|)
block|{
name|SWAP_32
argument_list|(
name|ctt
operator|->
name|ctt_name
argument_list|)
expr_stmt|;
name|SWAP_16
argument_list|(
name|ctt
operator|->
name|ctt_info
argument_list|)
expr_stmt|;
name|SWAP_16
argument_list|(
name|ctt
operator|->
name|ctt_size
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|ctt
operator|->
name|ctt_lsizehi
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|ctt
operator|->
name|ctt_lsizelo
argument_list|)
expr_stmt|;
block|}
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
name|ctt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctt
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctf_stype_t
modifier|*
name|cts
init|=
operator|(
name|ctf_stype_t
operator|*
operator|)
name|ctt
decl_stmt|;
name|cts
operator|->
name|ctt_size
operator|=
operator|(
name|ushort_t
operator|)
name|size
expr_stmt|;
if|if
condition|(
name|target_requires_swap
condition|)
block|{
name|SWAP_32
argument_list|(
name|cts
operator|->
name|ctt_name
argument_list|)
expr_stmt|;
name|SWAP_16
argument_list|(
name|cts
operator|->
name|ctt_info
argument_list|)
expr_stmt|;
name|SWAP_16
argument_list|(
name|cts
operator|->
name|ctt_size
argument_list|)
expr_stmt|;
block|}
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
name|cts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cts
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_unsized_type_rec
parameter_list|(
name|ctf_buf_t
modifier|*
name|b
parameter_list|,
name|ctf_type_t
modifier|*
name|ctt
parameter_list|)
block|{
name|ctf_stype_t
modifier|*
name|cts
init|=
operator|(
name|ctf_stype_t
operator|*
operator|)
name|ctt
decl_stmt|;
if|if
condition|(
name|target_requires_swap
condition|)
block|{
name|SWAP_32
argument_list|(
name|cts
operator|->
name|ctt_name
argument_list|)
expr_stmt|;
name|SWAP_16
argument_list|(
name|cts
operator|->
name|ctt_info
argument_list|)
expr_stmt|;
name|SWAP_16
argument_list|(
name|cts
operator|->
name|ctt_size
argument_list|)
expr_stmt|;
block|}
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
name|cts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cts
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_type
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tp
init|=
name|arg1
decl_stmt|;
name|ctf_buf_t
modifier|*
name|b
init|=
name|arg2
decl_stmt|;
name|elist_t
modifier|*
name|ep
decl_stmt|;
name|mlist_t
modifier|*
name|mp
decl_stmt|;
name|intr_t
modifier|*
name|ip
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|uint_t
name|encoding
decl_stmt|;
name|uint_t
name|data
decl_stmt|;
name|int
name|isroot
init|=
name|tp
operator|->
name|t_flags
operator|&
name|TDESC_F_ISROOT
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ctf_type_t
name|ctt
decl_stmt|;
name|ctf_array_t
name|cta
decl_stmt|;
name|ctf_member_t
name|ctm
decl_stmt|;
name|ctf_lmember_t
name|ctlm
decl_stmt|;
name|ctf_enum_t
name|cte
decl_stmt|;
name|ushort_t
name|id
decl_stmt|;
name|ctlm
operator|.
name|ctlm_pad
operator|=
literal|0
expr_stmt|;
comment|/* 	 * There shouldn't be any holes in the type list (where a hole is 	 * defined as two consecutive tdescs without consecutive ids), but 	 * check for them just in case.  If we do find holes, we need to make 	 * fake entries to fill the holes, or we won't be able to reconstruct 	 * the tree from the written data. 	 */
if|if
condition|(
operator|++
name|b
operator|->
name|nptent
operator|<
name|CTF_TYPE_TO_INDEX
argument_list|(
name|tp
operator|->
name|t_id
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"genctf: type hole from %d< x< %d\n"
argument_list|,
name|b
operator|->
name|nptent
operator|-
literal|1
argument_list|,
name|CTF_TYPE_TO_INDEX
argument_list|(
name|tp
operator|->
name|t_id
argument_list|)
argument_list|)
expr_stmt|;
name|ctt
operator|.
name|ctt_name
operator|=
name|CTF_TYPE_NAME
argument_list|(
name|CTF_STRTAB_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctt
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|nptent
operator|<
name|CTF_TYPE_TO_INDEX
argument_list|(
name|tp
operator|->
name|t_id
argument_list|)
condition|)
block|{
name|write_sized_type_rec
argument_list|(
name|b
argument_list|,
operator|&
name|ctt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|b
operator|->
name|nptent
operator|++
expr_stmt|;
block|}
block|}
name|offset
operator|=
name|strtab_insert
argument_list|(
operator|&
name|b
operator|->
name|ctb_strtab
argument_list|,
name|tp
operator|->
name|t_name
argument_list|)
expr_stmt|;
name|ctt
operator|.
name|ctt_name
operator|=
name|CTF_TYPE_NAME
argument_list|(
name|CTF_STRTAB_0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tp
operator|->
name|t_type
condition|)
block|{
case|case
name|INTRINSIC
case|:
name|ip
operator|=
name|tp
operator|->
name|t_intr
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|intr_type
operator|==
name|INTR_INT
condition|)
name|ctt
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_INTEGER
argument_list|,
name|isroot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|ctt
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_FLOAT
argument_list|,
name|isroot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_sized_type_rec
argument_list|(
name|b
argument_list|,
operator|&
name|ctt
argument_list|,
name|tp
operator|->
name|t_size
argument_list|)
expr_stmt|;
name|encoding
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|intr_type
operator|==
name|INTR_INT
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|intr_signed
condition|)
name|encoding
operator||=
name|CTF_INT_SIGNED
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|intr_iformat
operator|==
literal|'c'
condition|)
name|encoding
operator||=
name|CTF_INT_CHAR
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|intr_iformat
operator|==
literal|'b'
condition|)
name|encoding
operator||=
name|CTF_INT_BOOL
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|intr_iformat
operator|==
literal|'v'
condition|)
name|encoding
operator||=
name|CTF_INT_VARARGS
expr_stmt|;
block|}
else|else
name|encoding
operator|=
name|ip
operator|->
name|intr_fformat
expr_stmt|;
name|data
operator|=
name|CTF_INT_DATA
argument_list|(
name|encoding
argument_list|,
name|ip
operator|->
name|intr_offset
argument_list|,
name|ip
operator|->
name|intr_nbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_requires_swap
condition|)
block|{
name|SWAP_32
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
operator|&
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER
case|:
name|ctt
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_POINTER
argument_list|,
name|isroot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctt
operator|.
name|ctt_type
operator|=
name|tp
operator|->
name|t_tdesc
operator|->
name|t_id
expr_stmt|;
name|write_unsized_type_rec
argument_list|(
name|b
argument_list|,
operator|&
name|ctt
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY
case|:
name|ctt
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_ARRAY
argument_list|,
name|isroot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_sized_type_rec
argument_list|(
name|b
argument_list|,
operator|&
name|ctt
argument_list|,
name|tp
operator|->
name|t_size
argument_list|)
expr_stmt|;
name|cta
operator|.
name|cta_contents
operator|=
name|tp
operator|->
name|t_ardef
operator|->
name|ad_contents
operator|->
name|t_id
expr_stmt|;
name|cta
operator|.
name|cta_index
operator|=
name|tp
operator|->
name|t_ardef
operator|->
name|ad_idxtype
operator|->
name|t_id
expr_stmt|;
name|cta
operator|.
name|cta_nelems
operator|=
name|tp
operator|->
name|t_ardef
operator|->
name|ad_nelems
expr_stmt|;
if|if
condition|(
name|target_requires_swap
condition|)
block|{
name|SWAP_16
argument_list|(
name|cta
operator|.
name|cta_contents
argument_list|)
expr_stmt|;
name|SWAP_16
argument_list|(
name|cta
operator|.
name|cta_index
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|cta
operator|.
name|cta_nelems
argument_list|)
expr_stmt|;
block|}
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
operator|&
name|cta
argument_list|,
sizeof|sizeof
argument_list|(
name|cta
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRUCT
case|:
case|case
name|UNION
case|:
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mp
operator|=
name|tp
operator|->
name|t_members
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|ml_next
control|)
name|i
operator|++
expr_stmt|;
comment|/* count up struct or union members */
if|if
condition|(
name|i
operator|>
name|CTF_MAX_VLEN
condition|)
block|{
name|terminate
argument_list|(
literal|"sou %s has too many members: %d> %d\n"
argument_list|,
name|tdesc_name
argument_list|(
name|tp
argument_list|)
argument_list|,
name|i
argument_list|,
name|CTF_MAX_VLEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_type
operator|==
name|STRUCT
condition|)
name|ctt
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_STRUCT
argument_list|,
name|isroot
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|ctt
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_UNION
argument_list|,
name|isroot
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|write_sized_type_rec
argument_list|(
name|b
argument_list|,
operator|&
name|ctt
argument_list|,
name|tp
operator|->
name|t_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
block|{
for|for
control|(
name|mp
operator|=
name|tp
operator|->
name|t_members
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|ml_next
control|)
block|{
name|offset
operator|=
name|strtab_insert
argument_list|(
operator|&
name|b
operator|->
name|ctb_strtab
argument_list|,
name|mp
operator|->
name|ml_name
argument_list|)
expr_stmt|;
name|ctm
operator|.
name|ctm_name
operator|=
name|CTF_TYPE_NAME
argument_list|(
name|CTF_STRTAB_0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ctm
operator|.
name|ctm_type
operator|=
name|mp
operator|->
name|ml_type
operator|->
name|t_id
expr_stmt|;
name|ctm
operator|.
name|ctm_offset
operator|=
name|mp
operator|->
name|ml_offset
expr_stmt|;
if|if
condition|(
name|target_requires_swap
condition|)
block|{
name|SWAP_32
argument_list|(
name|ctm
operator|.
name|ctm_name
argument_list|)
expr_stmt|;
name|SWAP_16
argument_list|(
name|ctm
operator|.
name|ctm_type
argument_list|)
expr_stmt|;
name|SWAP_16
argument_list|(
name|ctm
operator|.
name|ctm_offset
argument_list|)
expr_stmt|;
block|}
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
operator|&
name|ctm
argument_list|,
sizeof|sizeof
argument_list|(
name|ctm
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|mp
operator|=
name|tp
operator|->
name|t_members
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|ml_next
control|)
block|{
name|offset
operator|=
name|strtab_insert
argument_list|(
operator|&
name|b
operator|->
name|ctb_strtab
argument_list|,
name|mp
operator|->
name|ml_name
argument_list|)
expr_stmt|;
name|ctlm
operator|.
name|ctlm_name
operator|=
name|CTF_TYPE_NAME
argument_list|(
name|CTF_STRTAB_0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ctlm
operator|.
name|ctlm_type
operator|=
name|mp
operator|->
name|ml_type
operator|->
name|t_id
expr_stmt|;
name|ctlm
operator|.
name|ctlm_offsethi
operator|=
name|CTF_OFFSET_TO_LMEMHI
argument_list|(
name|mp
operator|->
name|ml_offset
argument_list|)
expr_stmt|;
name|ctlm
operator|.
name|ctlm_offsetlo
operator|=
name|CTF_OFFSET_TO_LMEMLO
argument_list|(
name|mp
operator|->
name|ml_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_requires_swap
condition|)
block|{
name|SWAP_32
argument_list|(
name|ctlm
operator|.
name|ctlm_name
argument_list|)
expr_stmt|;
name|SWAP_16
argument_list|(
name|ctlm
operator|.
name|ctlm_type
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|ctlm
operator|.
name|ctlm_offsethi
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|ctlm
operator|.
name|ctlm_offsetlo
argument_list|)
expr_stmt|;
block|}
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
operator|&
name|ctlm
argument_list|,
sizeof|sizeof
argument_list|(
name|ctlm
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ENUM
case|:
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ep
operator|=
name|tp
operator|->
name|t_emem
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|ep
operator|->
name|el_next
control|)
name|i
operator|++
expr_stmt|;
comment|/* count up enum members */
if|if
condition|(
name|i
operator|>
name|CTF_MAX_VLEN
condition|)
block|{
name|warning
argument_list|(
literal|"enum %s has too many values: %d> %d\n"
argument_list|,
name|tdesc_name
argument_list|(
name|tp
argument_list|)
argument_list|,
name|i
argument_list|,
name|CTF_MAX_VLEN
argument_list|)
expr_stmt|;
name|i
operator|=
name|CTF_MAX_VLEN
expr_stmt|;
block|}
name|ctt
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_ENUM
argument_list|,
name|isroot
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|write_sized_type_rec
argument_list|(
name|b
argument_list|,
operator|&
name|ctt
argument_list|,
name|tp
operator|->
name|t_size
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|tp
operator|->
name|t_emem
init|;
name|ep
operator|!=
name|NULL
operator|&&
name|i
operator|>
literal|0
condition|;
name|ep
operator|=
name|ep
operator|->
name|el_next
control|)
block|{
name|offset
operator|=
name|strtab_insert
argument_list|(
operator|&
name|b
operator|->
name|ctb_strtab
argument_list|,
name|ep
operator|->
name|el_name
argument_list|)
expr_stmt|;
name|cte
operator|.
name|cte_name
operator|=
name|CTF_TYPE_NAME
argument_list|(
name|CTF_STRTAB_0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|cte
operator|.
name|cte_value
operator|=
name|ep
operator|->
name|el_number
expr_stmt|;
if|if
condition|(
name|target_requires_swap
condition|)
block|{
name|SWAP_32
argument_list|(
name|cte
operator|.
name|cte_name
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|cte
operator|.
name|cte_value
argument_list|)
expr_stmt|;
block|}
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
operator|&
name|cte
argument_list|,
sizeof|sizeof
argument_list|(
name|cte
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|FORWARD
case|:
name|ctt
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_FORWARD
argument_list|,
name|isroot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctt
operator|.
name|ctt_type
operator|=
literal|0
expr_stmt|;
name|write_unsized_type_rec
argument_list|(
name|b
argument_list|,
operator|&
name|ctt
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPEDEF
case|:
name|ctt
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_TYPEDEF
argument_list|,
name|isroot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctt
operator|.
name|ctt_type
operator|=
name|tp
operator|->
name|t_tdesc
operator|->
name|t_id
expr_stmt|;
name|write_unsized_type_rec
argument_list|(
name|b
argument_list|,
operator|&
name|ctt
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOLATILE
case|:
name|ctt
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_VOLATILE
argument_list|,
name|isroot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctt
operator|.
name|ctt_type
operator|=
name|tp
operator|->
name|t_tdesc
operator|->
name|t_id
expr_stmt|;
name|write_unsized_type_rec
argument_list|(
name|b
argument_list|,
operator|&
name|ctt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|ctt
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_CONST
argument_list|,
name|isroot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctt
operator|.
name|ctt_type
operator|=
name|tp
operator|->
name|t_tdesc
operator|->
name|t_id
expr_stmt|;
name|write_unsized_type_rec
argument_list|(
name|b
argument_list|,
operator|&
name|ctt
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION
case|:
name|i
operator|=
name|tp
operator|->
name|t_fndef
operator|->
name|fn_nargs
operator|+
name|tp
operator|->
name|t_fndef
operator|->
name|fn_vargs
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|CTF_MAX_VLEN
condition|)
block|{
name|terminate
argument_list|(
literal|"function %s has too many args: %d> %d\n"
argument_list|,
name|tdesc_name
argument_list|(
name|tp
argument_list|)
argument_list|,
name|i
argument_list|,
name|CTF_MAX_VLEN
argument_list|)
expr_stmt|;
block|}
name|ctt
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_FUNCTION
argument_list|,
name|isroot
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ctt
operator|.
name|ctt_type
operator|=
name|tp
operator|->
name|t_fndef
operator|->
name|fn_ret
operator|->
name|t_id
expr_stmt|;
name|write_unsized_type_rec
argument_list|(
name|b
argument_list|,
operator|&
name|ctt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|tp
operator|->
name|t_fndef
operator|->
name|fn_nargs
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
name|tp
operator|->
name|t_fndef
operator|->
name|fn_args
index|[
name|i
index|]
operator|->
name|t_id
expr_stmt|;
if|if
condition|(
name|target_requires_swap
condition|)
block|{
name|SWAP_16
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
operator|&
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_fndef
operator|->
name|fn_vargs
condition|)
block|{
name|id
operator|=
literal|0
expr_stmt|;
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
operator|&
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|1
condition|)
block|{
name|id
operator|=
literal|0
expr_stmt|;
name|ctf_buf_write
argument_list|(
name|b
argument_list|,
operator|&
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RESTRICT
case|:
name|ctt
operator|.
name|ctt_info
operator|=
name|CTF_TYPE_INFO
argument_list|(
name|CTF_K_RESTRICT
argument_list|,
name|isroot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctt
operator|.
name|ctt_type
operator|=
name|tp
operator|->
name|t_tdesc
operator|->
name|t_id
expr_stmt|;
name|write_unsized_type_rec
argument_list|(
name|b
argument_list|,
operator|&
name|ctt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warning
argument_list|(
literal|"Can't write unknown type %d\n"
argument_list|,
name|tp
operator|->
name|t_type
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Wrote type %d %s\n"
argument_list|,
name|tp
operator|->
name|t_id
argument_list|,
name|tdesc_name
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|resbuf
block|{
name|caddr_t
name|rb_base
decl_stmt|;
name|caddr_t
name|rb_ptr
decl_stmt|;
name|size_t
name|rb_size
decl_stmt|;
name|z_stream
name|rb_zstr
decl_stmt|;
block|}
name|resbuf_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|rbzs_grow
parameter_list|(
name|resbuf_t
modifier|*
name|rb
parameter_list|)
block|{
name|off_t
name|ptroff
init|=
operator|(
name|caddr_t
operator|)
name|rb
operator|->
name|rb_zstr
operator|.
name|next_out
operator|-
name|rb
operator|->
name|rb_base
decl_stmt|;
name|rb
operator|->
name|rb_size
operator|+=
name|RES_BUF_CHUNK_SIZE
expr_stmt|;
name|rb
operator|->
name|rb_base
operator|=
name|xrealloc
argument_list|(
name|rb
operator|->
name|rb_base
argument_list|,
name|rb
operator|->
name|rb_size
argument_list|)
expr_stmt|;
name|rb
operator|->
name|rb_ptr
operator|=
name|rb
operator|->
name|rb_base
operator|+
name|ptroff
expr_stmt|;
name|rb
operator|->
name|rb_zstr
operator|.
name|next_out
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|rb
operator|->
name|rb_ptr
operator|)
expr_stmt|;
name|rb
operator|->
name|rb_zstr
operator|.
name|avail_out
operator|+=
name|RES_BUF_CHUNK_SIZE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|compress_start
parameter_list|(
name|resbuf_t
modifier|*
name|rb
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|rb
operator|->
name|rb_zstr
operator|.
name|zalloc
operator|=
operator|(
name|alloc_func
operator|)
literal|0
expr_stmt|;
name|rb
operator|->
name|rb_zstr
operator|.
name|zfree
operator|=
operator|(
name|free_func
operator|)
literal|0
expr_stmt|;
name|rb
operator|->
name|rb_zstr
operator|.
name|opaque
operator|=
operator|(
name|voidpf
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|deflateInit
argument_list|(
operator|&
name|rb
operator|->
name|rb_zstr
argument_list|,
name|Z_BEST_COMPRESSION
argument_list|)
operator|)
operator|!=
name|Z_OK
condition|)
name|parseterminate
argument_list|(
literal|"zlib start failed: %s"
argument_list|,
name|zError
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|compress_buffer
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|n
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|resbuf_t
modifier|*
name|rb
init|=
operator|(
name|resbuf_t
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rb
operator|->
name|rb_zstr
operator|.
name|next_out
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|rb
operator|->
name|rb_ptr
expr_stmt|;
name|rb
operator|->
name|rb_zstr
operator|.
name|avail_out
operator|=
name|rb
operator|->
name|rb_size
operator|-
operator|(
name|rb
operator|->
name|rb_ptr
operator|-
name|rb
operator|->
name|rb_base
operator|)
expr_stmt|;
name|rb
operator|->
name|rb_zstr
operator|.
name|next_in
operator|=
name|buf
expr_stmt|;
name|rb
operator|->
name|rb_zstr
operator|.
name|avail_in
operator|=
name|n
expr_stmt|;
while|while
condition|(
name|rb
operator|->
name|rb_zstr
operator|.
name|avail_in
condition|)
block|{
if|if
condition|(
name|rb
operator|->
name|rb_zstr
operator|.
name|avail_out
operator|==
literal|0
condition|)
name|rbzs_grow
argument_list|(
name|rb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|deflate
argument_list|(
operator|&
name|rb
operator|->
name|rb_zstr
argument_list|,
name|Z_NO_FLUSH
argument_list|)
operator|)
operator|!=
name|Z_OK
condition|)
name|parseterminate
argument_list|(
literal|"zlib deflate failed: %s"
argument_list|,
name|zError
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rb
operator|->
name|rb_ptr
operator|=
operator|(
name|caddr_t
operator|)
name|rb
operator|->
name|rb_zstr
operator|.
name|next_out
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|compress_flush
parameter_list|(
name|resbuf_t
modifier|*
name|rb
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|rb
operator|->
name|rb_zstr
operator|.
name|avail_out
operator|==
literal|0
condition|)
name|rbzs_grow
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|rc
operator|=
name|deflate
argument_list|(
operator|&
name|rb
operator|->
name|rb_zstr
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|Z_FULL_FLUSH
operator|&&
name|rc
operator|==
name|Z_BUF_ERROR
operator|)
operator|||
operator|(
name|type
operator|==
name|Z_FINISH
operator|&&
name|rc
operator|==
name|Z_STREAM_END
operator|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|rc
operator|!=
name|Z_OK
condition|)
name|parseterminate
argument_list|(
literal|"zlib finish failed: %s"
argument_list|,
name|zError
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rb
operator|->
name|rb_ptr
operator|=
operator|(
name|caddr_t
operator|)
name|rb
operator|->
name|rb_zstr
operator|.
name|next_out
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|compress_end
parameter_list|(
name|resbuf_t
modifier|*
name|rb
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|compress_flush
argument_list|(
name|rb
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|deflateEnd
argument_list|(
operator|&
name|rb
operator|->
name|rb_zstr
argument_list|)
operator|)
operator|!=
name|Z_OK
condition|)
name|parseterminate
argument_list|(
literal|"zlib end failed: %s"
argument_list|,
name|zError
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pad the buffer to a power-of-2 boundary  */
end_comment

begin_function
specifier|static
name|void
name|pad_buffer
parameter_list|(
name|ctf_buf_t
modifier|*
name|buf
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|uint_t
name|cur
init|=
name|ctf_buf_cur
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|ssize_t
name|topad
init|=
operator|(
name|align
operator|-
operator|(
name|cur
operator|%
name|align
operator|)
operator|)
operator|%
name|align
decl_stmt|;
specifier|static
specifier|const
name|char
name|pad
index|[
literal|8
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
while|while
condition|(
name|topad
operator|>
literal|0
condition|)
block|{
name|ctf_buf_write
argument_list|(
name|buf
argument_list|,
name|pad
argument_list|,
operator|(
name|topad
operator|>
literal|8
condition|?
literal|8
else|:
name|topad
operator|)
argument_list|)
expr_stmt|;
name|topad
operator|-=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|bcopy_data
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|n
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|caddr_t
modifier|*
name|posp
init|=
operator|(
name|caddr_t
operator|*
operator|)
name|data
decl_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
operator|*
name|posp
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|posp
operator|+=
name|n
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|caddr_t
name|write_buffer
parameter_list|(
name|ctf_header_t
modifier|*
name|h
parameter_list|,
name|ctf_buf_t
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|resszp
parameter_list|)
block|{
name|caddr_t
name|outbuf
decl_stmt|;
name|caddr_t
name|bufpos
decl_stmt|;
name|outbuf
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
operator|+
operator|(
name|buf
operator|->
name|ctb_ptr
operator|-
name|buf
operator|->
name|ctb_base
operator|)
operator|+
name|buf
operator|->
name|ctb_strtab
operator|.
name|str_size
argument_list|)
expr_stmt|;
name|bufpos
operator|=
name|outbuf
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy_data
argument_list|(
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
argument_list|,
operator|&
name|bufpos
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy_data
argument_list|(
name|buf
operator|->
name|ctb_base
argument_list|,
name|buf
operator|->
name|ctb_ptr
operator|-
name|buf
operator|->
name|ctb_base
argument_list|,
operator|&
name|bufpos
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strtab_write
argument_list|(
operator|&
name|buf
operator|->
name|ctb_strtab
argument_list|,
name|bcopy_data
argument_list|,
operator|&
name|bufpos
argument_list|)
expr_stmt|;
operator|*
name|resszp
operator|=
name|bufpos
operator|-
name|outbuf
expr_stmt|;
return|return
operator|(
name|outbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the compression buffer, and fill it with the CTF and string  * table data.  We flush the compression state between the two so the  * dictionary used for the string tables won't be polluted with values  * that made sense for the CTF data.  */
end_comment

begin_function
specifier|static
name|caddr_t
name|write_compressed_buffer
parameter_list|(
name|ctf_header_t
modifier|*
name|h
parameter_list|,
name|ctf_buf_t
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|resszp
parameter_list|)
block|{
name|resbuf_t
name|resbuf
decl_stmt|;
name|resbuf
operator|.
name|rb_size
operator|=
name|RES_BUF_CHUNK_SIZE
expr_stmt|;
name|resbuf
operator|.
name|rb_base
operator|=
name|xmalloc
argument_list|(
name|resbuf
operator|.
name|rb_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|h
argument_list|,
name|resbuf
operator|.
name|rb_base
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
argument_list|)
expr_stmt|;
name|resbuf
operator|.
name|rb_ptr
operator|=
name|resbuf
operator|.
name|rb_base
operator|+
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
expr_stmt|;
name|compress_start
argument_list|(
operator|&
name|resbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|compress_buffer
argument_list|(
name|buf
operator|->
name|ctb_base
argument_list|,
name|buf
operator|->
name|ctb_ptr
operator|-
name|buf
operator|->
name|ctb_base
argument_list|,
operator|&
name|resbuf
argument_list|)
expr_stmt|;
name|compress_flush
argument_list|(
operator|&
name|resbuf
argument_list|,
name|Z_FULL_FLUSH
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strtab_write
argument_list|(
operator|&
name|buf
operator|->
name|ctb_strtab
argument_list|,
name|compress_buffer
argument_list|,
operator|&
name|resbuf
argument_list|)
expr_stmt|;
name|compress_end
argument_list|(
operator|&
name|resbuf
argument_list|)
expr_stmt|;
operator|*
name|resszp
operator|=
operator|(
name|resbuf
operator|.
name|rb_ptr
operator|-
name|resbuf
operator|.
name|rb_base
operator|)
expr_stmt|;
return|return
operator|(
name|resbuf
operator|.
name|rb_base
operator|)
return|;
block|}
end_function

begin_function
name|caddr_t
name|ctf_gen
parameter_list|(
name|iiburst_t
modifier|*
name|iiburst
parameter_list|,
name|size_t
modifier|*
name|resszp
parameter_list|,
name|int
name|do_compress
parameter_list|)
block|{
name|ctf_buf_t
modifier|*
name|buf
init|=
name|ctf_buf_new
argument_list|()
decl_stmt|;
name|ctf_header_t
name|h
decl_stmt|;
name|caddr_t
name|outbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|target_requires_swap
operator|=
name|do_compress
operator|&
name|CTF_SWAP_BYTES
expr_stmt|;
name|do_compress
operator|&=
operator|~
name|CTF_SWAP_BYTES
expr_stmt|;
comment|/* 	 * Prepare the header, and create the CTF output buffers.  The data 	 * object section and function section are both lists of 2-byte 	 * integers; we pad these out to the next 4-byte boundary if needed. 	 */
name|h
operator|.
name|cth_magic
operator|=
name|CTF_MAGIC
expr_stmt|;
name|h
operator|.
name|cth_version
operator|=
name|CTF_VERSION
expr_stmt|;
name|h
operator|.
name|cth_flags
operator|=
name|do_compress
condition|?
name|CTF_F_COMPRESS
else|:
literal|0
expr_stmt|;
name|h
operator|.
name|cth_parlabel
operator|=
name|strtab_insert
argument_list|(
operator|&
name|buf
operator|->
name|ctb_strtab
argument_list|,
name|iiburst
operator|->
name|iib_td
operator|->
name|td_parlabel
argument_list|)
expr_stmt|;
name|h
operator|.
name|cth_parname
operator|=
name|strtab_insert
argument_list|(
operator|&
name|buf
operator|->
name|ctb_strtab
argument_list|,
name|iiburst
operator|->
name|iib_td
operator|->
name|td_parname
argument_list|)
expr_stmt|;
name|h
operator|.
name|cth_lbloff
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|list_iter
argument_list|(
name|iiburst
operator|->
name|iib_td
operator|->
name|td_labels
argument_list|,
name|write_label
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|pad_buffer
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|h
operator|.
name|cth_objtoff
operator|=
name|ctf_buf_cur
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iiburst
operator|->
name|iib_nobjts
condition|;
name|i
operator|++
control|)
name|write_objects
argument_list|(
name|iiburst
operator|->
name|iib_objts
index|[
name|i
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|pad_buffer
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|h
operator|.
name|cth_funcoff
operator|=
name|ctf_buf_cur
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iiburst
operator|->
name|iib_nfuncs
condition|;
name|i
operator|++
control|)
name|write_functions
argument_list|(
name|iiburst
operator|->
name|iib_funcs
index|[
name|i
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|pad_buffer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|h
operator|.
name|cth_typeoff
operator|=
name|ctf_buf_cur
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|list_iter
argument_list|(
name|iiburst
operator|->
name|iib_types
argument_list|,
name|write_type
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"CTF wrote %d types\n"
argument_list|,
name|list_count
argument_list|(
name|iiburst
operator|->
name|iib_types
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|.
name|cth_stroff
operator|=
name|ctf_buf_cur
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|h
operator|.
name|cth_strlen
operator|=
name|strtab_size
argument_list|(
operator|&
name|buf
operator|->
name|ctb_strtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_requires_swap
condition|)
block|{
name|SWAP_16
argument_list|(
name|h
operator|.
name|cth_preamble
operator|.
name|ctp_magic
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|h
operator|.
name|cth_parlabel
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|h
operator|.
name|cth_parname
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|h
operator|.
name|cth_lbloff
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|h
operator|.
name|cth_objtoff
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|h
operator|.
name|cth_funcoff
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|h
operator|.
name|cth_typeoff
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|h
operator|.
name|cth_stroff
argument_list|)
expr_stmt|;
name|SWAP_32
argument_list|(
name|h
operator|.
name|cth_strlen
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We only do compression for ctfmerge, as ctfconvert is only 	 * supposed to be used on intermediary build objects. This is 	 * significantly faster. 	 */
if|if
condition|(
name|do_compress
condition|)
name|outbuf
operator|=
name|write_compressed_buffer
argument_list|(
operator|&
name|h
argument_list|,
name|buf
argument_list|,
name|resszp
argument_list|)
expr_stmt|;
else|else
name|outbuf
operator|=
name|write_buffer
argument_list|(
operator|&
name|h
argument_list|,
name|buf
argument_list|,
name|resszp
argument_list|)
expr_stmt|;
name|ctf_buf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|outbuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_ctt_size
parameter_list|(
name|ctf_type_t
modifier|*
name|ctt
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|,
name|size_t
modifier|*
name|incrementp
parameter_list|)
block|{
if|if
condition|(
name|ctt
operator|->
name|ctt_size
operator|==
name|CTF_LSIZE_SENT
condition|)
block|{
operator|*
name|sizep
operator|=
operator|(
name|size_t
operator|)
name|CTF_TYPE_LSIZE
argument_list|(
name|ctt
argument_list|)
expr_stmt|;
operator|*
name|incrementp
operator|=
sizeof|sizeof
argument_list|(
name|ctf_type_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|sizep
operator|=
name|ctt
operator|->
name|ctt_size
expr_stmt|;
operator|*
name|incrementp
operator|=
sizeof|sizeof
argument_list|(
name|ctf_stype_t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|count_types
parameter_list|(
name|ctf_header_t
modifier|*
name|h
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|caddr_t
name|dptr
init|=
name|data
operator|+
name|h
operator|->
name|cth_typeoff
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|dptr
operator|=
name|data
operator|+
name|h
operator|->
name|cth_typeoff
expr_stmt|;
while|while
condition|(
name|dptr
operator|<
name|data
operator|+
name|h
operator|->
name|cth_stroff
condition|)
block|{
name|void
modifier|*
name|v
init|=
operator|(
name|void
operator|*
operator|)
name|dptr
decl_stmt|;
name|ctf_type_t
modifier|*
name|ctt
init|=
name|v
decl_stmt|;
name|size_t
name|vlen
init|=
name|CTF_INFO_VLEN
argument_list|(
name|ctt
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
name|get_ctt_size
argument_list|(
name|ctt
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CTF_INFO_KIND
argument_list|(
name|ctt
operator|->
name|ctt_info
argument_list|)
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
name|dptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
case|case
name|CTF_K_FORWARD
case|:
case|case
name|CTF_K_TYPEDEF
case|:
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
case|case
name|CTF_K_FUNCTION
case|:
name|dptr
operator|+=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|vlen
operator|+
operator|(
name|vlen
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|dptr
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_array_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
if|if
condition|(
name|size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
name|dptr
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_member_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
else|else
name|dptr
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_lmember_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
break|break;
case|case
name|CTF_K_ENUM
case|:
name|dptr
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_enum_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
break|break;
case|case
name|CTF_K_UNKNOWN
case|:
break|break;
default|default:
name|parseterminate
argument_list|(
literal|"Unknown CTF type %d (#%d) at %#x"
argument_list|,
name|CTF_INFO_KIND
argument_list|(
name|ctt
operator|->
name|ctt_info
argument_list|)
argument_list|,
name|count
argument_list|,
name|dptr
operator|-
name|data
argument_list|)
expr_stmt|;
block|}
name|dptr
operator|+=
name|increment
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|"CTF read %d types\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Resurrect the labels stored in the CTF data, returning the index associated  * with a label provided by the caller.  There are several cases, outlined  * below.  Note that, given two labels, the one associated with the lesser type  * index is considered to be older than the other.  *  *  1. matchlbl == NULL - return the index of the most recent label.  *  2. matchlbl == "BASE" - return the index of the oldest label.  *  3. matchlbl != NULL, but doesn't match any labels in the section - warn  *	the user, and proceed as if matchlbl == "BASE" (for safety).  *  4. matchlbl != NULL, and matches one of the labels in the section - return  *	the type index associated with the label.  */
end_comment

begin_function
specifier|static
name|int
name|resurrect_labels
parameter_list|(
name|ctf_header_t
modifier|*
name|h
parameter_list|,
name|tdata_t
modifier|*
name|td
parameter_list|,
name|caddr_t
name|ctfdata
parameter_list|,
name|char
modifier|*
name|matchlbl
parameter_list|)
block|{
name|caddr_t
name|buf
init|=
name|ctfdata
operator|+
name|h
operator|->
name|cth_lbloff
decl_stmt|;
name|caddr_t
name|sbuf
init|=
name|ctfdata
operator|+
name|h
operator|->
name|cth_stroff
decl_stmt|;
name|size_t
name|bufsz
init|=
name|h
operator|->
name|cth_objtoff
operator|-
name|h
operator|->
name|cth_lbloff
decl_stmt|;
name|int
name|lastidx
init|=
literal|0
decl_stmt|,
name|baseidx
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|baselabel
init|=
name|NULL
decl_stmt|;
name|ctf_lblent_t
modifier|*
name|ctl
decl_stmt|;
name|void
modifier|*
name|v
init|=
operator|(
name|void
operator|*
operator|)
name|buf
decl_stmt|;
for|for
control|(
name|ctl
operator|=
name|v
init|;
operator|(
name|caddr_t
operator|)
name|ctl
operator|<
name|buf
operator|+
name|bufsz
condition|;
name|ctl
operator|++
control|)
block|{
name|char
modifier|*
name|label
init|=
name|sbuf
operator|+
name|ctl
operator|->
name|ctl_label
decl_stmt|;
name|lastidx
operator|=
name|ctl
operator|->
name|ctl_typeidx
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Resurrected label %s type idx %d\n"
argument_list|,
name|label
argument_list|,
name|lastidx
argument_list|)
expr_stmt|;
name|tdata_label_add
argument_list|(
name|td
argument_list|,
name|label
argument_list|,
name|lastidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|baseidx
operator|==
operator|-
literal|1
condition|)
block|{
name|baseidx
operator|=
name|lastidx
expr_stmt|;
name|baselabel
operator|=
name|label
expr_stmt|;
if|if
condition|(
name|matchlbl
operator|!=
name|NULL
operator|&&
name|streq
argument_list|(
name|matchlbl
argument_list|,
literal|"BASE"
argument_list|)
condition|)
return|return
operator|(
name|lastidx
operator|)
return|;
block|}
if|if
condition|(
name|matchlbl
operator|!=
name|NULL
operator|&&
name|streq
argument_list|(
name|label
argument_list|,
name|matchlbl
argument_list|)
condition|)
return|return
operator|(
name|lastidx
operator|)
return|;
block|}
if|if
condition|(
name|matchlbl
operator|!=
name|NULL
condition|)
block|{
comment|/* User provided a label that didn't match */
name|warning
argument_list|(
literal|"%s: Cannot find label `%s' - using base (%s)\n"
argument_list|,
name|curfile
argument_list|,
name|matchlbl
argument_list|,
operator|(
name|baselabel
condition|?
name|baselabel
else|:
literal|"NONE"
operator|)
argument_list|)
expr_stmt|;
name|tdata_label_free
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|tdata_label_add
argument_list|(
name|td
argument_list|,
name|baselabel
argument_list|,
name|baseidx
argument_list|)
expr_stmt|;
return|return
operator|(
name|baseidx
operator|)
return|;
block|}
return|return
operator|(
name|lastidx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|resurrect_objects
parameter_list|(
name|ctf_header_t
modifier|*
name|h
parameter_list|,
name|tdata_t
modifier|*
name|td
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|tdarr
parameter_list|,
name|int
name|tdsize
parameter_list|,
name|caddr_t
name|ctfdata
parameter_list|,
name|symit_data_t
modifier|*
name|si
parameter_list|)
block|{
name|caddr_t
name|buf
init|=
name|ctfdata
operator|+
name|h
operator|->
name|cth_objtoff
decl_stmt|;
name|size_t
name|bufsz
init|=
name|h
operator|->
name|cth_funcoff
operator|-
name|h
operator|->
name|cth_objtoff
decl_stmt|;
name|caddr_t
name|dptr
decl_stmt|;
name|symit_reset
argument_list|(
name|si
argument_list|)
expr_stmt|;
for|for
control|(
name|dptr
operator|=
name|buf
init|;
name|dptr
operator|<
name|buf
operator|+
name|bufsz
condition|;
name|dptr
operator|+=
literal|2
control|)
block|{
name|void
modifier|*
name|v
init|=
operator|(
name|void
operator|*
operator|)
name|dptr
decl_stmt|;
name|ushort_t
name|id
init|=
operator|*
operator|(
operator|(
name|ushort_t
operator|*
operator|)
name|v
operator|)
decl_stmt|;
name|iidesc_t
modifier|*
name|ii
decl_stmt|;
name|GElf_Sym
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sym
operator|=
name|symit_next
argument_list|(
name|si
argument_list|,
name|STT_OBJECT
argument_list|)
operator|)
operator|&&
name|id
operator|!=
literal|0
condition|)
block|{
name|parseterminate
argument_list|(
literal|"Unexpected end of object symbols at %x of %x"
argument_list|,
name|dptr
operator|-
name|buf
argument_list|,
name|bufsz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Skipping null object\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|id
operator|>=
name|tdsize
condition|)
block|{
name|parseterminate
argument_list|(
literal|"Reference to invalid type %d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|ii
operator|=
name|iidesc_new
argument_list|(
name|symit_name
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_dtype
operator|=
name|tdarr
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|GELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
condition|)
block|{
name|ii
operator|->
name|ii_type
operator|=
name|II_SVAR
expr_stmt|;
name|ii
operator|->
name|ii_owner
operator|=
name|xstrdup
argument_list|(
name|symit_curfile
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ii
operator|->
name|ii_type
operator|=
name|II_GVAR
expr_stmt|;
name|hash_add
argument_list|(
name|td
operator|->
name|td_iihash
argument_list|,
name|ii
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Resurrected %s object %s (%d) from %s\n"
argument_list|,
operator|(
name|ii
operator|->
name|ii_type
operator|==
name|II_GVAR
condition|?
literal|"global"
else|:
literal|"static"
operator|)
argument_list|,
name|ii
operator|->
name|ii_name
argument_list|,
name|id
argument_list|,
operator|(
name|ii
operator|->
name|ii_owner
condition|?
name|ii
operator|->
name|ii_owner
else|:
literal|"(none)"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|resurrect_functions
parameter_list|(
name|ctf_header_t
modifier|*
name|h
parameter_list|,
name|tdata_t
modifier|*
name|td
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|tdarr
parameter_list|,
name|int
name|tdsize
parameter_list|,
name|caddr_t
name|ctfdata
parameter_list|,
name|symit_data_t
modifier|*
name|si
parameter_list|)
block|{
name|caddr_t
name|buf
init|=
name|ctfdata
operator|+
name|h
operator|->
name|cth_funcoff
decl_stmt|;
name|size_t
name|bufsz
init|=
name|h
operator|->
name|cth_typeoff
operator|-
name|h
operator|->
name|cth_funcoff
decl_stmt|;
name|caddr_t
name|dptr
init|=
name|buf
decl_stmt|;
name|iidesc_t
modifier|*
name|ii
decl_stmt|;
name|ushort_t
name|info
decl_stmt|;
name|ushort_t
name|retid
decl_stmt|;
name|GElf_Sym
modifier|*
name|sym
decl_stmt|;
name|int
name|i
decl_stmt|;
name|symit_reset
argument_list|(
name|si
argument_list|)
expr_stmt|;
while|while
condition|(
name|dptr
operator|<
name|buf
operator|+
name|bufsz
condition|)
block|{
name|void
modifier|*
name|v
init|=
operator|(
name|void
operator|*
operator|)
name|dptr
decl_stmt|;
name|info
operator|=
operator|*
operator|(
operator|(
name|ushort_t
operator|*
operator|)
name|v
operator|)
expr_stmt|;
name|dptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sym
operator|=
name|symit_next
argument_list|(
name|si
argument_list|,
name|STT_FUNC
argument_list|)
operator|)
operator|&&
name|info
operator|!=
literal|0
condition|)
name|parseterminate
argument_list|(
literal|"Unexpected end of function symbols"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Skipping null function (%s)\n"
argument_list|,
name|symit_name
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|v
operator|=
operator|(
name|void
operator|*
operator|)
name|dptr
expr_stmt|;
name|retid
operator|=
operator|*
operator|(
operator|(
name|ushort_t
operator|*
operator|)
name|v
operator|)
expr_stmt|;
name|dptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|retid
operator|>=
name|tdsize
condition|)
name|parseterminate
argument_list|(
literal|"Reference to invalid type %d"
argument_list|,
name|retid
argument_list|)
expr_stmt|;
name|ii
operator|=
name|iidesc_new
argument_list|(
name|symit_name
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_dtype
operator|=
name|tdarr
index|[
name|retid
index|]
expr_stmt|;
if|if
condition|(
name|GELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
condition|)
block|{
name|ii
operator|->
name|ii_type
operator|=
name|II_SFUN
expr_stmt|;
name|ii
operator|->
name|ii_owner
operator|=
name|xstrdup
argument_list|(
name|symit_curfile
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ii
operator|->
name|ii_type
operator|=
name|II_GFUN
expr_stmt|;
name|ii
operator|->
name|ii_nargs
operator|=
name|CTF_INFO_VLEN
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_nargs
condition|)
name|ii
operator|->
name|ii_args
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
operator|*
argument_list|)
operator|*
name|ii
operator|->
name|ii_nargs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ii
operator|->
name|ii_nargs
condition|;
name|i
operator|++
operator|,
name|dptr
operator|+=
literal|2
control|)
block|{
name|v
operator|=
operator|(
name|void
operator|*
operator|)
name|dptr
expr_stmt|;
name|ushort_t
name|id
init|=
operator|*
operator|(
operator|(
name|ushort_t
operator|*
operator|)
name|v
operator|)
decl_stmt|;
if|if
condition|(
name|id
operator|>=
name|tdsize
condition|)
name|parseterminate
argument_list|(
literal|"Reference to invalid type %d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_args
index|[
name|i
index|]
operator|=
name|tdarr
index|[
name|id
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ii
operator|->
name|ii_nargs
operator|&&
name|ii
operator|->
name|ii_args
index|[
name|ii
operator|->
name|ii_nargs
operator|-
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|ii
operator|->
name|ii_nargs
operator|--
expr_stmt|;
name|ii
operator|->
name|ii_vargs
operator|=
literal|1
expr_stmt|;
block|}
name|hash_add
argument_list|(
name|td
operator|->
name|td_iihash
argument_list|,
name|ii
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Resurrected %s function %s (%d, %d args)\n"
argument_list|,
operator|(
name|ii
operator|->
name|ii_type
operator|==
name|II_GFUN
condition|?
literal|"global"
else|:
literal|"static"
operator|)
argument_list|,
name|ii
operator|->
name|ii_name
argument_list|,
name|retid
argument_list|,
name|ii
operator|->
name|ii_nargs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|resurrect_types
parameter_list|(
name|ctf_header_t
modifier|*
name|h
parameter_list|,
name|tdata_t
modifier|*
name|td
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|tdarr
parameter_list|,
name|int
name|tdsize
parameter_list|,
name|caddr_t
name|ctfdata
parameter_list|,
name|int
name|maxid
parameter_list|)
block|{
name|caddr_t
name|buf
init|=
name|ctfdata
operator|+
name|h
operator|->
name|cth_typeoff
decl_stmt|;
name|size_t
name|bufsz
init|=
name|h
operator|->
name|cth_stroff
operator|-
name|h
operator|->
name|cth_typeoff
decl_stmt|;
name|caddr_t
name|sbuf
init|=
name|ctfdata
operator|+
name|h
operator|->
name|cth_stroff
decl_stmt|;
name|caddr_t
name|dptr
init|=
name|buf
decl_stmt|;
name|tdesc_t
modifier|*
name|tdp
decl_stmt|;
name|uint_t
name|data
decl_stmt|;
name|uint_t
name|encoding
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
name|int
name|tcnt
decl_stmt|;
name|int
name|iicnt
init|=
literal|0
decl_stmt|;
name|tid_t
name|tid
decl_stmt|,
name|argid
decl_stmt|;
name|int
name|kind
decl_stmt|,
name|vlen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|elist_t
modifier|*
modifier|*
name|epp
decl_stmt|;
name|mlist_t
modifier|*
modifier|*
name|mpp
decl_stmt|;
name|intr_t
modifier|*
name|ip
decl_stmt|;
name|ctf_type_t
modifier|*
name|ctt
decl_stmt|;
name|ctf_array_t
modifier|*
name|cta
decl_stmt|;
name|ctf_enum_t
modifier|*
name|cte
decl_stmt|;
comment|/* 	 * A maxid of zero indicates a request to resurrect all types, so reset 	 * maxid to the maximum type id. 	 */
if|if
condition|(
name|maxid
operator|==
literal|0
condition|)
name|maxid
operator|=
name|CTF_MAX_TYPE
expr_stmt|;
for|for
control|(
name|dptr
operator|=
name|buf
operator|,
name|tcnt
operator|=
literal|0
operator|,
name|tid
operator|=
literal|1
init|;
name|dptr
operator|<
name|buf
operator|+
name|bufsz
condition|;
name|tcnt
operator|++
operator|,
name|tid
operator|++
control|)
block|{
if|if
condition|(
name|tid
operator|>
name|maxid
condition|)
break|break;
if|if
condition|(
name|tid
operator|>=
name|tdsize
condition|)
name|parseterminate
argument_list|(
literal|"Reference to invalid type %d"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|void
modifier|*
name|v
init|=
operator|(
name|void
operator|*
operator|)
name|dptr
decl_stmt|;
name|ctt
operator|=
name|v
expr_stmt|;
name|get_ctt_size
argument_list|(
name|ctt
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
name|dptr
operator|+=
name|increment
expr_stmt|;
name|tdp
operator|=
name|tdarr
index|[
name|tid
index|]
expr_stmt|;
if|if
condition|(
name|CTF_NAME_STID
argument_list|(
name|ctt
operator|->
name|ctt_name
argument_list|)
operator|!=
name|CTF_STRTAB_0
condition|)
name|parseterminate
argument_list|(
literal|"Unable to cope with non-zero strtab id"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CTF_NAME_OFFSET
argument_list|(
name|ctt
operator|->
name|ctt_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tdp
operator|->
name|t_name
operator|=
name|xstrdup
argument_list|(
name|sbuf
operator|+
name|CTF_NAME_OFFSET
argument_list|(
name|ctt
operator|->
name|ctt_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tdp
operator|->
name|t_name
operator|=
name|NULL
expr_stmt|;
name|kind
operator|=
name|CTF_INFO_KIND
argument_list|(
name|ctt
operator|->
name|ctt_info
argument_list|)
expr_stmt|;
name|vlen
operator|=
name|CTF_INFO_VLEN
argument_list|(
name|ctt
operator|->
name|ctt_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
name|tdp
operator|->
name|t_type
operator|=
name|INTRINSIC
expr_stmt|;
name|tdp
operator|->
name|t_size
operator|=
name|size
expr_stmt|;
name|v
operator|=
operator|(
name|void
operator|*
operator|)
name|dptr
expr_stmt|;
name|data
operator|=
operator|*
operator|(
operator|(
name|uint_t
operator|*
operator|)
name|v
operator|)
expr_stmt|;
name|dptr
operator|+=
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
expr_stmt|;
name|encoding
operator|=
name|CTF_INT_ENCODING
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|ip
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|intr_t
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|intr_type
operator|=
name|INTR_INT
expr_stmt|;
name|ip
operator|->
name|intr_signed
operator|=
operator|(
name|encoding
operator|&
name|CTF_INT_SIGNED
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|encoding
operator|&
name|CTF_INT_CHAR
condition|)
name|ip
operator|->
name|intr_iformat
operator|=
literal|'c'
expr_stmt|;
elseif|else
if|if
condition|(
name|encoding
operator|&
name|CTF_INT_BOOL
condition|)
name|ip
operator|->
name|intr_iformat
operator|=
literal|'b'
expr_stmt|;
elseif|else
if|if
condition|(
name|encoding
operator|&
name|CTF_INT_VARARGS
condition|)
name|ip
operator|->
name|intr_iformat
operator|=
literal|'v'
expr_stmt|;
else|else
name|ip
operator|->
name|intr_iformat
operator|=
literal|'\0'
expr_stmt|;
name|ip
operator|->
name|intr_offset
operator|=
name|CTF_INT_OFFSET
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|ip
operator|->
name|intr_nbits
operator|=
name|CTF_INT_BITS
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_intr
operator|=
name|ip
expr_stmt|;
break|break;
case|case
name|CTF_K_FLOAT
case|:
name|tdp
operator|->
name|t_type
operator|=
name|INTRINSIC
expr_stmt|;
name|tdp
operator|->
name|t_size
operator|=
name|size
expr_stmt|;
name|v
operator|=
operator|(
name|void
operator|*
operator|)
name|dptr
expr_stmt|;
name|data
operator|=
operator|*
operator|(
operator|(
name|uint_t
operator|*
operator|)
name|v
operator|)
expr_stmt|;
name|dptr
operator|+=
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
expr_stmt|;
name|ip
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|intr_t
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|intr_type
operator|=
name|INTR_REAL
expr_stmt|;
name|ip
operator|->
name|intr_fformat
operator|=
name|CTF_FP_ENCODING
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|ip
operator|->
name|intr_offset
operator|=
name|CTF_FP_OFFSET
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|ip
operator|->
name|intr_nbits
operator|=
name|CTF_FP_BITS
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_intr
operator|=
name|ip
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
name|tdp
operator|->
name|t_type
operator|=
name|POINTER
expr_stmt|;
name|tdp
operator|->
name|t_tdesc
operator|=
name|tdarr
index|[
name|ctt
operator|->
name|ctt_type
index|]
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|tdp
operator|->
name|t_type
operator|=
name|ARRAY
expr_stmt|;
name|tdp
operator|->
name|t_size
operator|=
name|size
expr_stmt|;
name|v
operator|=
operator|(
name|void
operator|*
operator|)
name|dptr
expr_stmt|;
name|cta
operator|=
name|v
expr_stmt|;
name|dptr
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_array_t
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_ardef
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ardef_t
argument_list|)
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_ardef
operator|->
name|ad_contents
operator|=
name|tdarr
index|[
name|cta
operator|->
name|cta_contents
index|]
expr_stmt|;
name|tdp
operator|->
name|t_ardef
operator|->
name|ad_idxtype
operator|=
name|tdarr
index|[
name|cta
operator|->
name|cta_index
index|]
expr_stmt|;
name|tdp
operator|->
name|t_ardef
operator|->
name|ad_nelems
operator|=
name|cta
operator|->
name|cta_nelems
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
name|tdp
operator|->
name|t_type
operator|=
operator|(
name|kind
operator|==
name|CTF_K_STRUCT
condition|?
name|STRUCT
else|:
name|UNION
operator|)
expr_stmt|;
name|tdp
operator|->
name|t_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mpp
operator|=
operator|&
name|tdp
operator|->
name|t_members
init|;
name|i
operator|<
name|vlen
condition|;
name|i
operator|++
operator|,
name|mpp
operator|=
operator|&
operator|(
operator|(
operator|*
name|mpp
operator|)
operator|->
name|ml_next
operator|)
control|)
block|{
name|v
operator|=
operator|(
name|void
operator|*
operator|)
name|dptr
expr_stmt|;
name|ctf_member_t
modifier|*
name|ctm
init|=
name|v
decl_stmt|;
name|dptr
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_member_t
argument_list|)
expr_stmt|;
operator|*
name|mpp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mlist_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mpp
operator|)
operator|->
name|ml_name
operator|=
name|xstrdup
argument_list|(
name|sbuf
operator|+
name|ctm
operator|->
name|ctm_name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mpp
operator|)
operator|->
name|ml_type
operator|=
name|tdarr
index|[
name|ctm
operator|->
name|ctm_type
index|]
expr_stmt|;
operator|(
operator|*
name|mpp
operator|)
operator|->
name|ml_offset
operator|=
name|ctm
operator|->
name|ctm_offset
expr_stmt|;
operator|(
operator|*
name|mpp
operator|)
operator|->
name|ml_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mpp
operator|=
operator|&
name|tdp
operator|->
name|t_members
init|;
name|i
operator|<
name|vlen
condition|;
name|i
operator|++
operator|,
name|mpp
operator|=
operator|&
operator|(
operator|(
operator|*
name|mpp
operator|)
operator|->
name|ml_next
operator|)
control|)
block|{
name|v
operator|=
operator|(
name|void
operator|*
operator|)
name|dptr
expr_stmt|;
name|ctf_lmember_t
modifier|*
name|ctlm
init|=
name|v
decl_stmt|;
name|dptr
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_lmember_t
argument_list|)
expr_stmt|;
operator|*
name|mpp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mlist_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mpp
operator|)
operator|->
name|ml_name
operator|=
name|xstrdup
argument_list|(
name|sbuf
operator|+
name|ctlm
operator|->
name|ctlm_name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mpp
operator|)
operator|->
name|ml_type
operator|=
name|tdarr
index|[
name|ctlm
operator|->
name|ctlm_type
index|]
expr_stmt|;
operator|(
operator|*
name|mpp
operator|)
operator|->
name|ml_offset
operator|=
operator|(
name|int
operator|)
name|CTF_LMEM_OFFSET
argument_list|(
name|ctlm
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mpp
operator|)
operator|->
name|ml_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|*
name|mpp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|CTF_K_ENUM
case|:
name|tdp
operator|->
name|t_type
operator|=
name|ENUM
expr_stmt|;
name|tdp
operator|->
name|t_size
operator|=
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|epp
operator|=
operator|&
name|tdp
operator|->
name|t_emem
init|;
name|i
operator|<
name|vlen
condition|;
name|i
operator|++
operator|,
name|epp
operator|=
operator|&
operator|(
operator|(
operator|*
name|epp
operator|)
operator|->
name|el_next
operator|)
control|)
block|{
name|v
operator|=
operator|(
name|void
operator|*
operator|)
name|dptr
expr_stmt|;
name|cte
operator|=
name|v
expr_stmt|;
name|dptr
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_enum_t
argument_list|)
expr_stmt|;
operator|*
name|epp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|elist_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|epp
operator|)
operator|->
name|el_name
operator|=
name|xstrdup
argument_list|(
name|sbuf
operator|+
name|cte
operator|->
name|cte_name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|epp
operator|)
operator|->
name|el_number
operator|=
name|cte
operator|->
name|cte_value
expr_stmt|;
block|}
operator|*
name|epp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|CTF_K_FORWARD
case|:
name|tdp
operator|->
name|t_type
operator|=
name|FORWARD
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|td
operator|->
name|td_fwdlist
argument_list|,
name|tdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_TYPEDEF
case|:
name|tdp
operator|->
name|t_type
operator|=
name|TYPEDEF
expr_stmt|;
name|tdp
operator|->
name|t_tdesc
operator|=
name|tdarr
index|[
name|ctt
operator|->
name|ctt_type
index|]
expr_stmt|;
break|break;
case|case
name|CTF_K_VOLATILE
case|:
name|tdp
operator|->
name|t_type
operator|=
name|VOLATILE
expr_stmt|;
name|tdp
operator|->
name|t_tdesc
operator|=
name|tdarr
index|[
name|ctt
operator|->
name|ctt_type
index|]
expr_stmt|;
break|break;
case|case
name|CTF_K_CONST
case|:
name|tdp
operator|->
name|t_type
operator|=
name|CONST
expr_stmt|;
name|tdp
operator|->
name|t_tdesc
operator|=
name|tdarr
index|[
name|ctt
operator|->
name|ctt_type
index|]
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|tdp
operator|->
name|t_type
operator|=
name|FUNCTION
expr_stmt|;
name|tdp
operator|->
name|t_fndef
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fndef_t
argument_list|)
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_fndef
operator|->
name|fn_ret
operator|=
name|tdarr
index|[
name|ctt
operator|->
name|ctt_type
index|]
expr_stmt|;
name|v
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|dptr
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|vlen
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|vlen
operator|>
literal|0
operator|&&
operator|*
operator|(
name|ushort_t
operator|*
operator|)
name|v
operator|==
literal|0
condition|)
name|tdp
operator|->
name|t_fndef
operator|->
name|fn_vargs
operator|=
literal|1
expr_stmt|;
name|tdp
operator|->
name|t_fndef
operator|->
name|fn_nargs
operator|=
name|vlen
operator|-
name|tdp
operator|->
name|t_fndef
operator|->
name|fn_vargs
expr_stmt|;
name|tdp
operator|->
name|t_fndef
operator|->
name|fn_args
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
argument_list|)
operator|*
name|vlen
operator|-
name|tdp
operator|->
name|t_fndef
operator|->
name|fn_vargs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vlen
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
operator|(
name|void
operator|*
operator|)
name|dptr
expr_stmt|;
name|argid
operator|=
operator|*
operator|(
name|ushort_t
operator|*
operator|)
name|v
expr_stmt|;
name|dptr
operator|+=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|argid
operator|!=
literal|0
condition|)
name|tdp
operator|->
name|t_fndef
operator|->
name|fn_args
index|[
name|i
index|]
operator|=
name|tdarr
index|[
name|argid
index|]
expr_stmt|;
block|}
if|if
condition|(
name|vlen
operator|&
literal|1
condition|)
name|dptr
operator|+=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_RESTRICT
case|:
name|tdp
operator|->
name|t_type
operator|=
name|RESTRICT
expr_stmt|;
name|tdp
operator|->
name|t_tdesc
operator|=
name|tdarr
index|[
name|ctt
operator|->
name|ctt_type
index|]
expr_stmt|;
break|break;
case|case
name|CTF_K_UNKNOWN
case|:
break|break;
default|default:
name|warning
argument_list|(
literal|"Can't parse unknown CTF type %d\n"
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CTF_INFO_ISROOT
argument_list|(
name|ctt
operator|->
name|ctt_info
argument_list|)
condition|)
block|{
name|iidesc_t
modifier|*
name|ii
init|=
name|iidesc_new
argument_list|(
name|tdp
operator|->
name|t_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_type
operator|==
name|STRUCT
operator|||
name|tdp
operator|->
name|t_type
operator|==
name|UNION
operator|||
name|tdp
operator|->
name|t_type
operator|==
name|ENUM
condition|)
name|ii
operator|->
name|ii_type
operator|=
name|II_SOU
expr_stmt|;
else|else
name|ii
operator|->
name|ii_type
operator|=
name|II_TYPE
expr_stmt|;
name|ii
operator|->
name|ii_dtype
operator|=
name|tdp
expr_stmt|;
name|hash_add
argument_list|(
name|td
operator|->
name|td_iihash
argument_list|,
name|ii
argument_list|)
expr_stmt|;
name|iicnt
operator|++
expr_stmt|;
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Resurrected %d %stype %s (%d)\n"
argument_list|,
name|tdp
operator|->
name|t_type
argument_list|,
operator|(
name|CTF_INFO_ISROOT
argument_list|(
name|ctt
operator|->
name|ctt_info
argument_list|)
condition|?
literal|"root "
else|:
literal|""
operator|)
argument_list|,
name|tdesc_name
argument_list|(
name|tdp
argument_list|)
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Resurrected %d types (%d were roots)\n"
argument_list|,
name|tcnt
argument_list|,
name|iicnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For lack of other inspiration, we're going to take the boring route.  We  * count the number of types.  This lets us malloc that many tdesc structs  * before we start filling them in.  This has the advantage of allowing us to  * avoid a merge-esque remap step.  */
end_comment

begin_function
specifier|static
name|tdata_t
modifier|*
name|ctf_parse
parameter_list|(
name|ctf_header_t
modifier|*
name|h
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|symit_data_t
modifier|*
name|si
parameter_list|,
name|char
modifier|*
name|label
parameter_list|)
block|{
name|tdata_t
modifier|*
name|td
init|=
name|tdata_new
argument_list|()
decl_stmt|;
name|tdesc_t
modifier|*
modifier|*
name|tdarr
decl_stmt|;
name|int
name|ntypes
init|=
name|count_types
argument_list|(
name|h
argument_list|,
name|buf
argument_list|)
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|i
decl_stmt|;
comment|/* shudder */
name|tdarr
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
operator|*
argument_list|)
operator|*
operator|(
name|ntypes
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|tdarr
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|ntypes
condition|;
name|i
operator|++
control|)
block|{
name|tdarr
index|[
name|i
index|]
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|tdarr
index|[
name|i
index|]
operator|->
name|t_id
operator|=
name|i
expr_stmt|;
block|}
name|td
operator|->
name|td_parlabel
operator|=
name|xstrdup
argument_list|(
name|buf
operator|+
name|h
operator|->
name|cth_stroff
operator|+
name|h
operator|->
name|cth_parlabel
argument_list|)
expr_stmt|;
comment|/* we have the technology - we can rebuild them */
name|idx
operator|=
name|resurrect_labels
argument_list|(
name|h
argument_list|,
name|td
argument_list|,
name|buf
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|resurrect_objects
argument_list|(
name|h
argument_list|,
name|td
argument_list|,
name|tdarr
argument_list|,
name|ntypes
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|resurrect_functions
argument_list|(
name|h
argument_list|,
name|td
argument_list|,
name|tdarr
argument_list|,
name|ntypes
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|resurrect_types
argument_list|(
name|h
argument_list|,
name|td
argument_list|,
name|tdarr
argument_list|,
name|ntypes
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tdarr
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_nextid
operator|=
name|ntypes
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|td
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|decompress_ctf
parameter_list|(
name|caddr_t
name|cbuf
parameter_list|,
name|size_t
name|cbufsz
parameter_list|,
name|caddr_t
name|dbuf
parameter_list|,
name|size_t
name|dbufsz
parameter_list|)
block|{
name|z_stream
name|zstr
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|zstr
operator|.
name|zalloc
operator|=
operator|(
name|alloc_func
operator|)
literal|0
expr_stmt|;
name|zstr
operator|.
name|zfree
operator|=
operator|(
name|free_func
operator|)
literal|0
expr_stmt|;
name|zstr
operator|.
name|opaque
operator|=
operator|(
name|voidpf
operator|)
literal|0
expr_stmt|;
name|zstr
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|cbuf
expr_stmt|;
name|zstr
operator|.
name|avail_in
operator|=
name|cbufsz
expr_stmt|;
name|zstr
operator|.
name|next_out
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|dbuf
expr_stmt|;
name|zstr
operator|.
name|avail_out
operator|=
name|dbufsz
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|inflateInit
argument_list|(
operator|&
name|zstr
argument_list|)
operator|)
operator|!=
name|Z_OK
operator|||
operator|(
name|rc
operator|=
name|inflate
argument_list|(
operator|&
name|zstr
argument_list|,
name|Z_NO_FLUSH
argument_list|)
operator|)
operator|!=
name|Z_STREAM_END
operator|||
operator|(
name|rc
operator|=
name|inflateEnd
argument_list|(
operator|&
name|zstr
argument_list|)
operator|)
operator|!=
name|Z_OK
condition|)
block|{
name|warning
argument_list|(
literal|"CTF decompress zlib error %s\n"
argument_list|,
name|zError
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|"reflated %lu bytes to %lu, pointer at %d\n"
argument_list|,
name|zstr
operator|.
name|total_in
argument_list|,
name|zstr
operator|.
name|total_out
argument_list|,
operator|(
name|caddr_t
operator|)
name|zstr
operator|.
name|next_in
operator|-
name|cbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|zstr
operator|.
name|total_out
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reconstruct the type tree from a given buffer of CTF data.  Only the types  * up to the type associated with the provided label, inclusive, will be  * reconstructed.  If a NULL label is provided, all types will be reconstructed.  *  * This function won't work on files that have been uniquified.  */
end_comment

begin_function
name|tdata_t
modifier|*
name|ctf_load
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|size_t
name|bufsz
parameter_list|,
name|symit_data_t
modifier|*
name|si
parameter_list|,
name|char
modifier|*
name|label
parameter_list|)
block|{
name|ctf_header_t
modifier|*
name|h
decl_stmt|;
name|caddr_t
name|ctfdata
decl_stmt|;
name|size_t
name|ctfdatasz
decl_stmt|;
name|tdata_t
modifier|*
name|td
decl_stmt|;
name|curfile
operator|=
name|file
expr_stmt|;
if|if
condition|(
name|bufsz
operator|<
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
condition|)
name|parseterminate
argument_list|(
literal|"Corrupt CTF - short header"
argument_list|)
expr_stmt|;
name|void
modifier|*
name|v
init|=
operator|(
name|void
operator|*
operator|)
name|buf
decl_stmt|;
name|h
operator|=
name|v
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
expr_stmt|;
name|bufsz
operator|-=
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|cth_magic
operator|!=
name|CTF_MAGIC
condition|)
name|parseterminate
argument_list|(
literal|"Corrupt CTF - bad magic 0x%x"
argument_list|,
name|h
operator|->
name|cth_magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|cth_version
operator|!=
name|CTF_VERSION
condition|)
name|parseterminate
argument_list|(
literal|"Unknown CTF version %d"
argument_list|,
name|h
operator|->
name|cth_version
argument_list|)
expr_stmt|;
name|ctfdatasz
operator|=
name|h
operator|->
name|cth_stroff
operator|+
name|h
operator|->
name|cth_strlen
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|cth_flags
operator|&
name|CTF_F_COMPRESS
condition|)
block|{
name|size_t
name|actual
decl_stmt|;
name|ctfdata
operator|=
name|xmalloc
argument_list|(
name|ctfdatasz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|actual
operator|=
name|decompress_ctf
argument_list|(
name|buf
argument_list|,
name|bufsz
argument_list|,
name|ctfdata
argument_list|,
name|ctfdatasz
argument_list|)
operator|)
operator|!=
name|ctfdatasz
condition|)
block|{
name|parseterminate
argument_list|(
literal|"Corrupt CTF - short decompression "
literal|"(was %d, expecting %d)"
argument_list|,
name|actual
argument_list|,
name|ctfdatasz
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ctfdata
operator|=
name|buf
expr_stmt|;
name|ctfdatasz
operator|=
name|bufsz
expr_stmt|;
block|}
name|td
operator|=
name|ctf_parse
argument_list|(
name|h
argument_list|,
name|ctfdata
argument_list|,
name|si
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|cth_flags
operator|&
name|CTF_F_COMPRESS
condition|)
name|free
argument_list|(
name|ctfdata
argument_list|)
expr_stmt|;
name|curfile
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|td
operator|)
return|;
block|}
end_function

end_unit

