begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * This file contains routines that merge one tdata_t tree, called the child,  * into another, called the parent.  Note that these names are used mainly for  * convenience and to represent the direction of the merge.  They are not meant  * to imply any relationship between the tdata_t graphs prior to the merge.  *  * tdata_t structures contain two main elements - a hash of iidesc_t nodes, and  * a directed graph of tdesc_t nodes, pointed to by the iidesc_t nodes.  Simply  * put, we merge the tdesc_t graphs, followed by the iidesc_t nodes, and then we  * clean up loose ends.  *  * The algorithm is as follows:  *  * 1. Mapping iidesc_t nodes  *  * For each child iidesc_t node, we first try to map its tdesc_t subgraph  * against the tdesc_t graph in the parent.  For each node in the child subgraph  * that exists in the parent, a mapping between the two (between their type IDs)  * is established.  For the child nodes that cannot be mapped onto existing  * parent nodes, a mapping is established between the child node ID and a  * newly-allocated ID that the node will use when it is re-created in the  * parent.  These unmappable nodes are added to the md_tdtba (tdesc_t To Be  * Added) hash, which tracks nodes that need to be created in the parent.  *  * If all of the nodes in the subgraph for an iidesc_t in the child can be  * mapped to existing nodes in the parent, then we can try to map the child  * iidesc_t onto an iidesc_t in the parent.  If we cannot find an equivalent  * iidesc_t, or if we were not able to completely map the tdesc_t subgraph(s),  * then we add this iidesc_t to the md_iitba (iidesc_t To Be Added) list.  This  * list tracks iidesc_t nodes that are to be created in the parent.  *  * While visiting the tdesc_t nodes, we may discover a forward declaration (a  * FORWARD tdesc_t) in the parent that is resolved in the child.  That is, there  * may be a structure or union definition in the child with the same name as the  * forward declaration in the parent.  If we find such a node, we record an  * association in the md_fdida (Forward => Definition ID Association) list  * between the parent ID of the forward declaration and the ID that the  * definition will use when re-created in the parent.  *  * 2. Creating new tdesc_t nodes (the md_tdtba hash)  *  * We have now attempted to map all tdesc_t nodes from the child into the  * parent, and have, in md_tdtba, a hash of all tdesc_t nodes that need to be  * created (or, as we so wittily call it, conjured) in the parent.  We iterate  * through this hash, creating the indicated tdesc_t nodes.  For a given tdesc_t  * node, conjuring requires two steps - the copying of the common tdesc_t data  * (name, type, etc) from the child node, and the creation of links from the  * newly-created node to the parent equivalents of other tdesc_t nodes pointed  * to by node being conjured.  Note that in some cases, the targets of these  * links will be on the md_tdtba hash themselves, and may not have been created  * yet.  As such, we can't establish the links from these new nodes into the  * parent graph.  We therefore conjure them with links to nodes in the *child*  * graph, and add pointers to the links to be created to the md_tdtbr (tdesc_t  * To Be Remapped) hash.  For example, a POINTER tdesc_t that could not be  * resolved would have its&tdesc_t->t_tdesc added to md_tdtbr.  *  * 3. Creating new iidesc_t nodes (the md_iitba list)  *  * When we have completed step 2, all tdesc_t nodes have been created (or  * already existed) in the parent.  Some of them may have incorrect links (the  * members of the md_tdtbr list), but they've all been created.  As such, we can  * create all of the iidesc_t nodes, as we can attach the tdesc_t subgraph  * pointers correctly.  We create each node, and attach the pointers to the  * appropriate parts of the parent tdesc_t graph.  *  * 4. Resolving newly-created tdesc_t node links (the md_tdtbr list)  *  * As in step 3, we rely on the fact that all of the tdesc_t nodes have been  * created.  Each entry in the md_tdtbr list is a pointer to where a link into  * the parent will be established.  As saved in the md_tdtbr list, these  * pointers point into the child tdesc_t subgraph.  We can thus get the target  * type ID from the child, look at the ID mapping to determine the desired link  * target, and redirect the link accordingly.  *  * 5. Parent => child forward declaration resolution  *  * If entries were made in the md_fdida list in step 1, we have forward  * declarations in the parent that need to be resolved to their definitions  * re-created in step 2 from the child.  Using the md_fdida list, we can locate  * the definition for the forward declaration, and we can redirect all inbound  * edges to the forward declaration node to the actual definition.  *  * A pox on the house of anyone who changes the algorithm without updating  * this comment.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|"ctf_headers.h"
end_include

begin_include
include|#
directive|include
file|"ctftools.h"
end_include

begin_include
include|#
directive|include
file|"list.h"
end_include

begin_include
include|#
directive|include
file|"alist.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"traverse.h"
end_include

begin_typedef
typedef|typedef
name|struct
name|equiv_data
name|equiv_data_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|merge_cb_data
name|merge_cb_data_t
typedef|;
end_typedef

begin_comment
comment|/*  * There are two traversals in this file, for equivalency and for tdesc_t  * re-creation, that do not fit into the tdtraverse() framework.  We have our  * own traversal mechanism and ops vector here for those two cases.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|tdesc_ops
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
function_decl|(
modifier|*
name|equiv
function_decl|)
parameter_list|(
name|tdesc_t
modifier|*
parameter_list|,
name|tdesc_t
modifier|*
parameter_list|,
name|equiv_data_t
modifier|*
parameter_list|)
function_decl|;
name|tdesc_t
modifier|*
function_decl|(
modifier|*
name|conjure
function_decl|)
parameter_list|(
name|tdesc_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|merge_cb_data_t
modifier|*
parameter_list|)
function_decl|;
block|}
name|tdesc_ops_t
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|tdesc_ops_t
name|tdesc_ops
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The workhorse structure of tdata_t merging.  Holds all lists of nodes to be  * processed during various phases of the merge algorithm.  */
end_comment

begin_struct
struct|struct
name|merge_cb_data
block|{
name|tdata_t
modifier|*
name|md_parent
decl_stmt|;
name|tdata_t
modifier|*
name|md_tgt
decl_stmt|;
name|alist_t
modifier|*
name|md_ta
decl_stmt|;
comment|/* Type Association */
name|alist_t
modifier|*
name|md_fdida
decl_stmt|;
comment|/* Forward -> Definition ID Association */
name|list_t
modifier|*
modifier|*
name|md_iitba
decl_stmt|;
comment|/* iidesc_t nodes To Be Added to the parent */
name|hash_t
modifier|*
name|md_tdtba
decl_stmt|;
comment|/* tdesc_t nodes To Be Added to the parent */
name|list_t
modifier|*
modifier|*
name|md_tdtbr
decl_stmt|;
comment|/* tdesc_t nodes To Be Remapped */
name|int
name|md_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* merge_cb_data_t */
end_comment

begin_comment
comment|/*  * When we first create a tdata_t from stabs data, we will have duplicate nodes.  * Normal merges, however, assume that the child tdata_t is already self-unique,  * and for speed reasons do not attempt to self-uniquify.  If this flag is set,  * the merge algorithm will self-uniquify by avoiding the insertion of  * duplicates in the md_tdtdba list.  */
end_comment

begin_define
define|#
directive|define
name|MCD_F_SELFUNIQUIFY
value|0x1
end_define

begin_comment
comment|/*  * When we merge the CTF data for the modules, we don't want it to contain any  * data that can be found in the reference module (usually genunix).  If this  * flag is set, we're doing a merge between the fully merged tdata_t for this  * module and the tdata_t for the reference module, with the data unique to this  * module ending up in a third tdata_t.  It is this third tdata_t that will end  * up in the .SUNW_ctf section for the module.  */
end_comment

begin_define
define|#
directive|define
name|MCD_F_REFMERGE
value|0x2
end_define

begin_comment
comment|/*  * Mapping of child type IDs to parent type IDs  */
end_comment

begin_function
specifier|static
name|void
name|add_mapping
parameter_list|(
name|alist_t
modifier|*
name|ta
parameter_list|,
name|tid_t
name|srcid
parameter_list|,
name|tid_t
name|tgtid
parameter_list|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Adding mapping %u<%x> => %u<%x>\n"
argument_list|,
name|srcid
argument_list|,
name|srcid
argument_list|,
name|tgtid
argument_list|,
name|tgtid
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|alist_find
argument_list|(
name|ta
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|srcid
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|srcid
operator|!=
literal|0
operator|&&
name|tgtid
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|alist_add
argument_list|(
name|ta
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|srcid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|tgtid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tid_t
name|get_mapping
parameter_list|(
name|alist_t
modifier|*
name|ta
parameter_list|,
name|int
name|srcid
parameter_list|)
block|{
name|void
modifier|*
name|ltgtid
decl_stmt|;
if|if
condition|(
name|alist_find
argument_list|(
name|ta
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|srcid
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ltgtid
argument_list|)
condition|)
return|return
operator|(
operator|(
name|uintptr_t
operator|)
name|ltgtid
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determining equivalence of tdesc_t subgraphs  */
end_comment

begin_struct
struct|struct
name|equiv_data
block|{
name|alist_t
modifier|*
name|ed_ta
decl_stmt|;
name|tdesc_t
modifier|*
name|ed_node
decl_stmt|;
name|tdesc_t
modifier|*
name|ed_tgt
decl_stmt|;
name|int
name|ed_clear_mark
decl_stmt|;
name|int
name|ed_cur_mark
decl_stmt|;
name|int
name|ed_selfuniquify
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* equiv_data_t */
end_comment

begin_function_decl
specifier|static
name|int
name|equiv_node
parameter_list|(
name|tdesc_t
modifier|*
parameter_list|,
name|tdesc_t
modifier|*
parameter_list|,
name|equiv_data_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*ARGSUSED2*/
end_comment

begin_function
specifier|static
name|int
name|equiv_intrinsic
parameter_list|(
name|tdesc_t
modifier|*
name|stdp
parameter_list|,
name|tdesc_t
modifier|*
name|ttdp
parameter_list|,
name|equiv_data_t
modifier|*
name|ed
name|__unused
parameter_list|)
block|{
name|intr_t
modifier|*
name|si
init|=
name|stdp
operator|->
name|t_intr
decl_stmt|;
name|intr_t
modifier|*
name|ti
init|=
name|ttdp
operator|->
name|t_intr
decl_stmt|;
if|if
condition|(
name|si
operator|->
name|intr_type
operator|!=
name|ti
operator|->
name|intr_type
operator|||
name|si
operator|->
name|intr_signed
operator|!=
name|ti
operator|->
name|intr_signed
operator|||
name|si
operator|->
name|intr_offset
operator|!=
name|ti
operator|->
name|intr_offset
operator|||
name|si
operator|->
name|intr_nbits
operator|!=
name|ti
operator|->
name|intr_nbits
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|si
operator|->
name|intr_type
operator|==
name|INTR_INT
operator|&&
name|si
operator|->
name|intr_iformat
operator|!=
name|ti
operator|->
name|intr_iformat
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|si
operator|->
name|intr_type
operator|==
name|INTR_REAL
operator|&&
name|si
operator|->
name|intr_fformat
operator|!=
name|ti
operator|->
name|intr_fformat
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|equiv_plain
parameter_list|(
name|tdesc_t
modifier|*
name|stdp
parameter_list|,
name|tdesc_t
modifier|*
name|ttdp
parameter_list|,
name|equiv_data_t
modifier|*
name|ed
parameter_list|)
block|{
return|return
operator|(
name|equiv_node
argument_list|(
name|stdp
operator|->
name|t_tdesc
argument_list|,
name|ttdp
operator|->
name|t_tdesc
argument_list|,
name|ed
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|equiv_function
parameter_list|(
name|tdesc_t
modifier|*
name|stdp
parameter_list|,
name|tdesc_t
modifier|*
name|ttdp
parameter_list|,
name|equiv_data_t
modifier|*
name|ed
parameter_list|)
block|{
name|fndef_t
modifier|*
name|fn1
init|=
name|stdp
operator|->
name|t_fndef
decl_stmt|,
modifier|*
name|fn2
init|=
name|ttdp
operator|->
name|t_fndef
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fn1
operator|->
name|fn_nargs
operator|!=
name|fn2
operator|->
name|fn_nargs
operator|||
name|fn1
operator|->
name|fn_vargs
operator|!=
name|fn2
operator|->
name|fn_vargs
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|equiv_node
argument_list|(
name|fn1
operator|->
name|fn_ret
argument_list|,
name|fn2
operator|->
name|fn_ret
argument_list|,
name|ed
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|fn1
operator|->
name|fn_nargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|equiv_node
argument_list|(
name|fn1
operator|->
name|fn_args
index|[
name|i
index|]
argument_list|,
name|fn2
operator|->
name|fn_args
index|[
name|i
index|]
argument_list|,
name|ed
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|equiv_array
parameter_list|(
name|tdesc_t
modifier|*
name|stdp
parameter_list|,
name|tdesc_t
modifier|*
name|ttdp
parameter_list|,
name|equiv_data_t
modifier|*
name|ed
parameter_list|)
block|{
name|ardef_t
modifier|*
name|ar1
init|=
name|stdp
operator|->
name|t_ardef
decl_stmt|,
modifier|*
name|ar2
init|=
name|ttdp
operator|->
name|t_ardef
decl_stmt|;
if|if
condition|(
operator|!
name|equiv_node
argument_list|(
name|ar1
operator|->
name|ad_contents
argument_list|,
name|ar2
operator|->
name|ad_contents
argument_list|,
name|ed
argument_list|)
operator|||
operator|!
name|equiv_node
argument_list|(
name|ar1
operator|->
name|ad_idxtype
argument_list|,
name|ar2
operator|->
name|ad_idxtype
argument_list|,
name|ed
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ar1
operator|->
name|ad_nelems
operator|!=
name|ar2
operator|->
name|ad_nelems
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|equiv_su
parameter_list|(
name|tdesc_t
modifier|*
name|stdp
parameter_list|,
name|tdesc_t
modifier|*
name|ttdp
parameter_list|,
name|equiv_data_t
modifier|*
name|ed
parameter_list|)
block|{
name|mlist_t
modifier|*
name|ml1
init|=
name|stdp
operator|->
name|t_members
decl_stmt|,
modifier|*
name|ml2
init|=
name|ttdp
operator|->
name|t_members
decl_stmt|;
name|mlist_t
modifier|*
name|olm1
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|ml1
operator|&&
name|ml2
condition|)
block|{
if|if
condition|(
name|ml1
operator|->
name|ml_offset
operator|!=
name|ml2
operator|->
name|ml_offset
operator|||
name|strcmp
argument_list|(
name|ml1
operator|->
name|ml_name
argument_list|,
name|ml2
operator|->
name|ml_name
argument_list|)
operator|!=
literal|0
operator|||
name|ml1
operator|->
name|ml_size
operator|!=
name|ml2
operator|->
name|ml_size
operator|||
operator|!
name|equiv_node
argument_list|(
name|ml1
operator|->
name|ml_type
argument_list|,
name|ml2
operator|->
name|ml_type
argument_list|,
name|ed
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|olm1
operator|=
name|ml1
expr_stmt|;
name|ml1
operator|=
name|ml1
operator|->
name|ml_next
expr_stmt|;
name|ml2
operator|=
name|ml2
operator|->
name|ml_next
expr_stmt|;
block|}
if|if
condition|(
name|ml1
operator|||
name|ml2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED2*/
end_comment

begin_function
specifier|static
name|int
name|equiv_enum
parameter_list|(
name|tdesc_t
modifier|*
name|stdp
parameter_list|,
name|tdesc_t
modifier|*
name|ttdp
parameter_list|,
name|equiv_data_t
modifier|*
name|ed
name|__unused
parameter_list|)
block|{
name|elist_t
modifier|*
name|el1
init|=
name|stdp
operator|->
name|t_emem
decl_stmt|;
name|elist_t
modifier|*
name|el2
init|=
name|ttdp
operator|->
name|t_emem
decl_stmt|;
while|while
condition|(
name|el1
operator|&&
name|el2
condition|)
block|{
if|if
condition|(
name|el1
operator|->
name|el_number
operator|!=
name|el2
operator|->
name|el_number
operator|||
name|strcmp
argument_list|(
name|el1
operator|->
name|el_name
argument_list|,
name|el2
operator|->
name|el_name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|el1
operator|=
name|el1
operator|->
name|el_next
expr_stmt|;
name|el2
operator|=
name|el2
operator|->
name|el_next
expr_stmt|;
block|}
if|if
condition|(
name|el1
operator|||
name|el2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|equiv_assert
parameter_list|(
name|tdesc_t
modifier|*
name|stdp
name|__unused
parameter_list|,
name|tdesc_t
modifier|*
name|ttdp
name|__unused
parameter_list|,
name|equiv_data_t
modifier|*
name|ed
name|__unused
parameter_list|)
block|{
comment|/* foul, evil, and very bad - this is a "shouldn't happen" */
name|assert
argument_list|(
literal|1
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwd_equiv
parameter_list|(
name|tdesc_t
modifier|*
name|ctdp
parameter_list|,
name|tdesc_t
modifier|*
name|mtdp
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|defn
init|=
operator|(
name|ctdp
operator|->
name|t_type
operator|==
name|FORWARD
condition|?
name|mtdp
else|:
name|ctdp
operator|)
decl_stmt|;
return|return
operator|(
name|defn
operator|->
name|t_type
operator|==
name|STRUCT
operator|||
name|defn
operator|->
name|t_type
operator|==
name|UNION
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|equiv_node
parameter_list|(
name|tdesc_t
modifier|*
name|ctdp
parameter_list|,
name|tdesc_t
modifier|*
name|mtdp
parameter_list|,
name|equiv_data_t
modifier|*
name|ed
parameter_list|)
block|{
name|int
function_decl|(
modifier|*
name|equiv
function_decl|)
parameter_list|(
name|tdesc_t
modifier|*
parameter_list|,
name|tdesc_t
modifier|*
parameter_list|,
name|equiv_data_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|mapping
decl_stmt|;
if|if
condition|(
name|ctdp
operator|->
name|t_emark
operator|>
name|ed
operator|->
name|ed_clear_mark
operator|||
name|mtdp
operator|->
name|t_emark
operator|>
name|ed
operator|->
name|ed_clear_mark
condition|)
return|return
operator|(
name|ctdp
operator|->
name|t_emark
operator|==
name|mtdp
operator|->
name|t_emark
operator|)
return|;
comment|/* 	 * In normal (non-self-uniquify) mode, we don't want to do equivalency 	 * checking on a subgraph that has already been checked.  If a mapping 	 * has already been established for a given child node, we can simply 	 * compare the mapping for the child node with the ID of the parent 	 * node.  If we are in self-uniquify mode, then we're comparing two 	 * subgraphs within the child graph, and thus need to ignore any 	 * type mappings that have been created, as they are only valid into the 	 * parent. 	 */
if|if
condition|(
operator|(
name|mapping
operator|=
name|get_mapping
argument_list|(
name|ed
operator|->
name|ed_ta
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|mapping
operator|==
name|mtdp
operator|->
name|t_id
operator|&&
operator|!
name|ed
operator|->
name|ed_selfuniquify
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|streq
argument_list|(
name|ctdp
operator|->
name|t_name
argument_list|,
name|mtdp
operator|->
name|t_name
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ctdp
operator|->
name|t_type
operator|!=
name|mtdp
operator|->
name|t_type
condition|)
block|{
if|if
condition|(
name|ctdp
operator|->
name|t_type
operator|==
name|FORWARD
operator|||
name|mtdp
operator|->
name|t_type
operator|==
name|FORWARD
condition|)
return|return
operator|(
name|fwd_equiv
argument_list|(
name|ctdp
argument_list|,
name|mtdp
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ctdp
operator|->
name|t_emark
operator|=
name|ed
operator|->
name|ed_cur_mark
expr_stmt|;
name|mtdp
operator|->
name|t_emark
operator|=
name|ed
operator|->
name|ed_cur_mark
expr_stmt|;
name|ed
operator|->
name|ed_cur_mark
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|equiv
operator|=
name|tdesc_ops
index|[
name|ctdp
operator|->
name|t_type
index|]
operator|.
name|equiv
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|equiv
argument_list|(
name|ctdp
argument_list|,
name|mtdp
argument_list|,
name|ed
argument_list|)
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We perform an equivalency check on two subgraphs by traversing through them  * in lockstep.  If a given node is equivalent in both the parent and the child,  * we mark it in both subgraphs, using the t_emark field, with a monotonically  * increasing number.  If, in the course of the traversal, we reach a node that  * we have visited and numbered during this equivalency check, we have a cycle.  * If the previously-visited nodes don't have the same emark, then the edges  * that brought us to these nodes are not equivalent, and so the check ends.  * If the emarks are the same, the edges are equivalent.  We then backtrack and  * continue the traversal.  If we have exhausted all edges in the subgraph, and  * have not found any inequivalent nodes, then the subgraphs are equivalent.  */
end_comment

begin_function
specifier|static
name|int
name|equiv_cb
parameter_list|(
name|void
modifier|*
name|bucket
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|equiv_data_t
modifier|*
name|ed
init|=
name|arg
decl_stmt|;
name|tdesc_t
modifier|*
name|mtdp
init|=
name|bucket
decl_stmt|;
name|tdesc_t
modifier|*
name|ctdp
init|=
name|ed
operator|->
name|ed_node
decl_stmt|;
name|ed
operator|->
name|ed_clear_mark
operator|=
name|ed
operator|->
name|ed_cur_mark
operator|+
literal|1
expr_stmt|;
name|ed
operator|->
name|ed_cur_mark
operator|=
name|ed
operator|->
name|ed_clear_mark
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|equiv_node
argument_list|(
name|ctdp
argument_list|,
name|mtdp
argument_list|,
name|ed
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"equiv_node matched %d<%x> %d<%x>\n"
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|,
name|mtdp
operator|->
name|t_id
argument_list|,
name|mtdp
operator|->
name|t_id
argument_list|)
expr_stmt|;
name|ed
operator|->
name|ed_tgt
operator|=
name|mtdp
expr_stmt|;
comment|/* matched.  stop looking */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
specifier|static
name|int
name|map_td_tree_pre
parameter_list|(
name|tdesc_t
modifier|*
name|ctdp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|ctdpp
name|__unused
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|merge_cb_data_t
modifier|*
name|mcd
init|=
name|private
decl_stmt|;
if|if
condition|(
name|get_mapping
argument_list|(
name|mcd
operator|->
name|md_ta
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|)
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
specifier|static
name|int
name|map_td_tree_post
parameter_list|(
name|tdesc_t
modifier|*
name|ctdp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|ctdpp
name|__unused
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|merge_cb_data_t
modifier|*
name|mcd
init|=
name|private
decl_stmt|;
name|equiv_data_t
name|ed
decl_stmt|;
name|ed
operator|.
name|ed_ta
operator|=
name|mcd
operator|->
name|md_ta
expr_stmt|;
name|ed
operator|.
name|ed_clear_mark
operator|=
name|mcd
operator|->
name|md_parent
operator|->
name|td_curemark
expr_stmt|;
name|ed
operator|.
name|ed_cur_mark
operator|=
name|mcd
operator|->
name|md_parent
operator|->
name|td_curemark
operator|+
literal|1
expr_stmt|;
name|ed
operator|.
name|ed_node
operator|=
name|ctdp
expr_stmt|;
name|ed
operator|.
name|ed_selfuniquify
operator|=
literal|0
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"map_td_tree_post on %d<%x> %s\n"
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|,
name|tdesc_name
argument_list|(
name|ctdp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_find_iter
argument_list|(
name|mcd
operator|->
name|md_parent
operator|->
name|td_layouthash
argument_list|,
name|ctdp
argument_list|,
name|equiv_cb
argument_list|,
operator|&
name|ed
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* We found an equivalent node */
if|if
condition|(
name|ed
operator|.
name|ed_tgt
operator|->
name|t_type
operator|==
name|FORWARD
operator|&&
name|ctdp
operator|->
name|t_type
operator|!=
name|FORWARD
condition|)
block|{
name|int
name|id
init|=
name|mcd
operator|->
name|md_tgt
operator|->
name|td_nextid
operator|++
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Creating new defn type %d<%x>\n"
argument_list|,
name|id
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|add_mapping
argument_list|(
name|mcd
operator|->
name|md_ta
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|alist_add
argument_list|(
name|mcd
operator|->
name|md_fdida
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|ulong_t
operator|)
name|ed
operator|.
name|ed_tgt
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|ulong_t
operator|)
name|id
argument_list|)
expr_stmt|;
name|hash_add
argument_list|(
name|mcd
operator|->
name|md_tdtba
argument_list|,
name|ctdp
argument_list|)
expr_stmt|;
block|}
else|else
name|add_mapping
argument_list|(
name|mcd
operator|->
name|md_ta
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|,
name|ed
operator|.
name|ed_tgt
operator|->
name|t_id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|debug_level
operator|>
literal|1
operator|&&
name|hash_iter
argument_list|(
name|mcd
operator|->
name|md_parent
operator|->
name|td_idhash
argument_list|,
name|equiv_cb
argument_list|,
operator|&
name|ed
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * We didn't find an equivalent node by looking through the 		 * layout hash, but we somehow found it by performing an 		 * exhaustive search through the entire graph.  This usually 		 * means that the "name" hash function is broken. 		 */
name|aborterr
argument_list|(
literal|"Second pass for %d (%s) == %d\n"
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|,
name|tdesc_name
argument_list|(
name|ctdp
argument_list|)
argument_list|,
name|ed
operator|.
name|ed_tgt
operator|->
name|t_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|id
init|=
name|mcd
operator|->
name|md_tgt
operator|->
name|td_nextid
operator|++
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Creating new type %d<%x>\n"
argument_list|,
name|id
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|add_mapping
argument_list|(
name|mcd
operator|->
name|md_ta
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|hash_add
argument_list|(
name|mcd
operator|->
name|md_tdtba
argument_list|,
name|ctdp
argument_list|)
expr_stmt|;
block|}
name|mcd
operator|->
name|md_parent
operator|->
name|td_curemark
operator|=
name|ed
operator|.
name|ed_cur_mark
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
specifier|static
name|int
name|map_td_tree_self_post
parameter_list|(
name|tdesc_t
modifier|*
name|ctdp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|ctdpp
name|__unused
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|merge_cb_data_t
modifier|*
name|mcd
init|=
name|private
decl_stmt|;
name|equiv_data_t
name|ed
decl_stmt|;
name|ed
operator|.
name|ed_ta
operator|=
name|mcd
operator|->
name|md_ta
expr_stmt|;
name|ed
operator|.
name|ed_clear_mark
operator|=
name|mcd
operator|->
name|md_parent
operator|->
name|td_curemark
expr_stmt|;
name|ed
operator|.
name|ed_cur_mark
operator|=
name|mcd
operator|->
name|md_parent
operator|->
name|td_curemark
operator|+
literal|1
expr_stmt|;
name|ed
operator|.
name|ed_node
operator|=
name|ctdp
expr_stmt|;
name|ed
operator|.
name|ed_selfuniquify
operator|=
literal|1
expr_stmt|;
name|ed
operator|.
name|ed_tgt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hash_find_iter
argument_list|(
name|mcd
operator|->
name|md_tdtba
argument_list|,
name|ctdp
argument_list|,
name|equiv_cb
argument_list|,
operator|&
name|ed
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Self check found %d<%x> in %d<%x>\n"
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|,
name|ed
operator|.
name|ed_tgt
operator|->
name|t_id
argument_list|,
name|ed
operator|.
name|ed_tgt
operator|->
name|t_id
argument_list|)
expr_stmt|;
name|add_mapping
argument_list|(
name|mcd
operator|->
name|md_ta
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|,
name|get_mapping
argument_list|(
name|mcd
operator|->
name|md_ta
argument_list|,
name|ed
operator|.
name|ed_tgt
operator|->
name|t_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|debug_level
operator|>
literal|1
operator|&&
name|hash_iter
argument_list|(
name|mcd
operator|->
name|md_tdtba
argument_list|,
name|equiv_cb
argument_list|,
operator|&
name|ed
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * We didn't find an equivalent node using the quick way (going 		 * through the hash normally), but we did find it by iterating 		 * through the entire hash.  This usually means that the hash 		 * function is broken. 		 */
name|aborterr
argument_list|(
literal|"Self-unique second pass for %d<%x> (%s) == %d<%x>\n"
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|,
name|tdesc_name
argument_list|(
name|ctdp
argument_list|)
argument_list|,
name|ed
operator|.
name|ed_tgt
operator|->
name|t_id
argument_list|,
name|ed
operator|.
name|ed_tgt
operator|->
name|t_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|id
init|=
name|mcd
operator|->
name|md_tgt
operator|->
name|td_nextid
operator|++
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Creating new type %d<%x>\n"
argument_list|,
name|id
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|add_mapping
argument_list|(
name|mcd
operator|->
name|md_ta
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|hash_add
argument_list|(
name|mcd
operator|->
name|md_tdtba
argument_list|,
name|ctdp
argument_list|)
expr_stmt|;
block|}
name|mcd
operator|->
name|md_parent
operator|->
name|td_curemark
operator|=
name|ed
operator|.
name|ed_cur_mark
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|tdtrav_cb_f
name|map_pre
index|[]
init|=
block|{
name|NULL
block|,
name|map_td_tree_pre
block|,
comment|/* intrinsic */
name|map_td_tree_pre
block|,
comment|/* pointer */
name|map_td_tree_pre
block|,
comment|/* array */
name|map_td_tree_pre
block|,
comment|/* function */
name|map_td_tree_pre
block|,
comment|/* struct */
name|map_td_tree_pre
block|,
comment|/* union */
name|map_td_tree_pre
block|,
comment|/* enum */
name|map_td_tree_pre
block|,
comment|/* forward */
name|map_td_tree_pre
block|,
comment|/* typedef */
name|tdtrav_assert
block|,
comment|/* typedef_unres */
name|map_td_tree_pre
block|,
comment|/* volatile */
name|map_td_tree_pre
block|,
comment|/* const */
name|map_td_tree_pre
comment|/* restrict */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tdtrav_cb_f
name|map_post
index|[]
init|=
block|{
name|NULL
block|,
name|map_td_tree_post
block|,
comment|/* intrinsic */
name|map_td_tree_post
block|,
comment|/* pointer */
name|map_td_tree_post
block|,
comment|/* array */
name|map_td_tree_post
block|,
comment|/* function */
name|map_td_tree_post
block|,
comment|/* struct */
name|map_td_tree_post
block|,
comment|/* union */
name|map_td_tree_post
block|,
comment|/* enum */
name|map_td_tree_post
block|,
comment|/* forward */
name|map_td_tree_post
block|,
comment|/* typedef */
name|tdtrav_assert
block|,
comment|/* typedef_unres */
name|map_td_tree_post
block|,
comment|/* volatile */
name|map_td_tree_post
block|,
comment|/* const */
name|map_td_tree_post
comment|/* restrict */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tdtrav_cb_f
name|map_self_post
index|[]
init|=
block|{
name|NULL
block|,
name|map_td_tree_self_post
block|,
comment|/* intrinsic */
name|map_td_tree_self_post
block|,
comment|/* pointer */
name|map_td_tree_self_post
block|,
comment|/* array */
name|map_td_tree_self_post
block|,
comment|/* function */
name|map_td_tree_self_post
block|,
comment|/* struct */
name|map_td_tree_self_post
block|,
comment|/* union */
name|map_td_tree_self_post
block|,
comment|/* enum */
name|map_td_tree_self_post
block|,
comment|/* forward */
name|map_td_tree_self_post
block|,
comment|/* typedef */
name|tdtrav_assert
block|,
comment|/* typedef_unres */
name|map_td_tree_self_post
block|,
comment|/* volatile */
name|map_td_tree_self_post
block|,
comment|/* const */
name|map_td_tree_self_post
comment|/* restrict */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Determining equivalence of iidesc_t nodes  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|iifind_data
block|{
name|iidesc_t
modifier|*
name|iif_template
decl_stmt|;
name|alist_t
modifier|*
name|iif_ta
decl_stmt|;
name|int
name|iif_newidx
decl_stmt|;
name|int
name|iif_refmerge
decl_stmt|;
block|}
name|iifind_data_t
typedef|;
end_typedef

begin_comment
comment|/*  * Check to see if this iidesc_t (node) - the current one on the list we're  * iterating through - matches the target one (iif->iif_template).  Return -1  * if it matches, to stop the iteration.  */
end_comment

begin_function
specifier|static
name|int
name|iidesc_match
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|iidesc_t
modifier|*
name|node
init|=
name|data
decl_stmt|;
name|iifind_data_t
modifier|*
name|iif
init|=
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|ii_type
operator|!=
name|iif
operator|->
name|iif_template
operator|->
name|ii_type
operator|||
operator|!
name|streq
argument_list|(
name|node
operator|->
name|ii_name
argument_list|,
name|iif
operator|->
name|iif_template
operator|->
name|ii_name
argument_list|)
operator|||
name|node
operator|->
name|ii_dtype
operator|->
name|t_id
operator|!=
name|iif
operator|->
name|iif_newidx
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|node
operator|->
name|ii_type
operator|==
name|II_SVAR
operator|||
name|node
operator|->
name|ii_type
operator|==
name|II_SFUN
operator|)
operator|&&
operator|!
name|streq
argument_list|(
name|node
operator|->
name|ii_owner
argument_list|,
name|iif
operator|->
name|iif_template
operator|->
name|ii_owner
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|node
operator|->
name|ii_nargs
operator|!=
name|iif
operator|->
name|iif_template
operator|->
name|ii_nargs
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|ii_nargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|get_mapping
argument_list|(
name|iif
operator|->
name|iif_ta
argument_list|,
name|iif
operator|->
name|iif_template
operator|->
name|ii_args
index|[
name|i
index|]
operator|->
name|t_id
argument_list|)
operator|!=
name|node
operator|->
name|ii_args
index|[
name|i
index|]
operator|->
name|t_id
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|iif
operator|->
name|iif_refmerge
condition|)
block|{
switch|switch
condition|(
name|iif
operator|->
name|iif_template
operator|->
name|ii_type
condition|)
block|{
case|case
name|II_GFUN
case|:
case|case
name|II_SFUN
case|:
case|case
name|II_GVAR
case|:
case|case
name|II_SVAR
case|:
name|debug
argument_list|(
literal|3
argument_list|,
literal|"suppressing duping of %d %s from %s\n"
argument_list|,
name|iif
operator|->
name|iif_template
operator|->
name|ii_type
argument_list|,
name|iif
operator|->
name|iif_template
operator|->
name|ii_name
argument_list|,
operator|(
name|iif
operator|->
name|iif_template
operator|->
name|ii_owner
condition|?
name|iif
operator|->
name|iif_template
operator|->
name|ii_owner
else|:
literal|"NULL"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|II_NOT
case|:
case|case
name|II_PSYM
case|:
case|case
name|II_SOU
case|:
case|case
name|II_TYPE
case|:
break|break;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|merge_type_cb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|iidesc_t
modifier|*
name|sii
init|=
name|data
decl_stmt|;
name|merge_cb_data_t
modifier|*
name|mcd
init|=
name|arg
decl_stmt|;
name|iifind_data_t
name|iif
decl_stmt|;
name|tdtrav_cb_f
modifier|*
name|post
decl_stmt|;
name|post
operator|=
operator|(
name|mcd
operator|->
name|md_flags
operator|&
name|MCD_F_SELFUNIQUIFY
condition|?
name|map_self_post
else|:
name|map_post
operator|)
expr_stmt|;
comment|/* Map the tdesc nodes */
operator|(
name|void
operator|)
name|iitraverse
argument_list|(
name|sii
argument_list|,
operator|&
name|mcd
operator|->
name|md_parent
operator|->
name|td_curvgen
argument_list|,
name|NULL
argument_list|,
name|map_pre
argument_list|,
name|post
argument_list|,
name|mcd
argument_list|)
expr_stmt|;
comment|/* Map the iidesc nodes */
name|iif
operator|.
name|iif_template
operator|=
name|sii
expr_stmt|;
name|iif
operator|.
name|iif_ta
operator|=
name|mcd
operator|->
name|md_ta
expr_stmt|;
name|iif
operator|.
name|iif_newidx
operator|=
name|get_mapping
argument_list|(
name|mcd
operator|->
name|md_ta
argument_list|,
name|sii
operator|->
name|ii_dtype
operator|->
name|t_id
argument_list|)
expr_stmt|;
name|iif
operator|.
name|iif_refmerge
operator|=
operator|(
name|mcd
operator|->
name|md_flags
operator|&
name|MCD_F_REFMERGE
operator|)
expr_stmt|;
if|if
condition|(
name|hash_match
argument_list|(
name|mcd
operator|->
name|md_parent
operator|->
name|td_iihash
argument_list|,
name|sii
argument_list|,
name|iidesc_match
argument_list|,
operator|&
name|iif
argument_list|)
operator|==
literal|1
condition|)
comment|/* successfully mapped */
return|return
operator|(
literal|1
operator|)
return|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"tba %s (%d)\n"
argument_list|,
operator|(
name|sii
operator|->
name|ii_name
condition|?
name|sii
operator|->
name|ii_name
else|:
literal|"(anon)"
operator|)
argument_list|,
name|sii
operator|->
name|ii_type
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
name|mcd
operator|->
name|md_iitba
argument_list|,
name|sii
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remap_node
parameter_list|(
name|tdesc_t
modifier|*
modifier|*
name|tgtp
parameter_list|,
name|tdesc_t
modifier|*
name|oldtgt
parameter_list|,
name|int
name|selftid
parameter_list|,
name|tdesc_t
modifier|*
name|newself
parameter_list|,
name|merge_cb_data_t
modifier|*
name|mcd
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tgt
init|=
name|NULL
decl_stmt|;
name|tdesc_t
name|template
decl_stmt|;
name|int
name|oldid
init|=
name|oldtgt
operator|->
name|t_id
decl_stmt|;
if|if
condition|(
name|oldid
operator|==
name|selftid
condition|)
block|{
operator|*
name|tgtp
operator|=
name|newself
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|template
operator|.
name|t_id
operator|=
name|get_mapping
argument_list|(
name|mcd
operator|->
name|md_ta
argument_list|,
name|oldid
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|aborterr
argument_list|(
literal|"failed to get mapping for tid %d<%x>\n"
argument_list|,
name|oldid
argument_list|,
name|oldid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash_find
argument_list|(
name|mcd
operator|->
name|md_parent
operator|->
name|td_idhash
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|template
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|tgt
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|mcd
operator|->
name|md_flags
operator|&
name|MCD_F_REFMERGE
operator|)
operator|||
operator|!
name|hash_find
argument_list|(
name|mcd
operator|->
name|md_tgt
operator|->
name|td_idhash
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|template
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|tgt
argument_list|)
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Remap couldn't find %d<%x> (from %d<%x>)\n"
argument_list|,
name|template
operator|.
name|t_id
argument_list|,
name|template
operator|.
name|t_id
argument_list|,
name|oldid
argument_list|,
name|oldid
argument_list|)
expr_stmt|;
operator|*
name|tgtp
operator|=
name|oldtgt
expr_stmt|;
name|list_add
argument_list|(
name|mcd
operator|->
name|md_tdtbr
argument_list|,
name|tgtp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|tgtp
operator|=
name|tgt
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|conjure_template
parameter_list|(
name|tdesc_t
modifier|*
name|old
parameter_list|,
name|int
name|newselfid
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|new
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|t_name
operator|=
name|old
operator|->
name|t_name
condition|?
name|xstrdup
argument_list|(
name|old
operator|->
name|t_name
argument_list|)
else|:
name|NULL
expr_stmt|;
name|new
operator|->
name|t_type
operator|=
name|old
operator|->
name|t_type
expr_stmt|;
name|new
operator|->
name|t_size
operator|=
name|old
operator|->
name|t_size
expr_stmt|;
name|new
operator|->
name|t_id
operator|=
name|newselfid
expr_stmt|;
name|new
operator|->
name|t_flags
operator|=
name|old
operator|->
name|t_flags
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED2*/
end_comment

begin_function
specifier|static
name|tdesc_t
modifier|*
name|conjure_intrinsic
parameter_list|(
name|tdesc_t
modifier|*
name|old
parameter_list|,
name|int
name|newselfid
parameter_list|,
name|merge_cb_data_t
modifier|*
name|mcd
name|__unused
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|new
init|=
name|conjure_template
argument_list|(
name|old
argument_list|,
name|newselfid
argument_list|)
decl_stmt|;
name|new
operator|->
name|t_intr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|intr_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|old
operator|->
name|t_intr
argument_list|,
name|new
operator|->
name|t_intr
argument_list|,
sizeof|sizeof
argument_list|(
name|intr_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|conjure_plain
parameter_list|(
name|tdesc_t
modifier|*
name|old
parameter_list|,
name|int
name|newselfid
parameter_list|,
name|merge_cb_data_t
modifier|*
name|mcd
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|new
init|=
name|conjure_template
argument_list|(
name|old
argument_list|,
name|newselfid
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|remap_node
argument_list|(
operator|&
name|new
operator|->
name|t_tdesc
argument_list|,
name|old
operator|->
name|t_tdesc
argument_list|,
name|old
operator|->
name|t_id
argument_list|,
name|new
argument_list|,
name|mcd
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|conjure_function
parameter_list|(
name|tdesc_t
modifier|*
name|old
parameter_list|,
name|int
name|newselfid
parameter_list|,
name|merge_cb_data_t
modifier|*
name|mcd
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|new
init|=
name|conjure_template
argument_list|(
name|old
argument_list|,
name|newselfid
argument_list|)
decl_stmt|;
name|fndef_t
modifier|*
name|nfn
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fndef_t
argument_list|)
argument_list|)
decl_stmt|;
name|fndef_t
modifier|*
name|ofn
init|=
name|old
operator|->
name|t_fndef
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|remap_node
argument_list|(
operator|&
name|nfn
operator|->
name|fn_ret
argument_list|,
name|ofn
operator|->
name|fn_ret
argument_list|,
name|old
operator|->
name|t_id
argument_list|,
name|new
argument_list|,
name|mcd
argument_list|)
expr_stmt|;
name|nfn
operator|->
name|fn_nargs
operator|=
name|ofn
operator|->
name|fn_nargs
expr_stmt|;
name|nfn
operator|->
name|fn_vargs
operator|=
name|ofn
operator|->
name|fn_vargs
expr_stmt|;
if|if
condition|(
name|nfn
operator|->
name|fn_nargs
operator|>
literal|0
condition|)
name|nfn
operator|->
name|fn_args
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
operator|*
argument_list|)
operator|*
name|ofn
operator|->
name|fn_nargs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ofn
operator|->
name|fn_nargs
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|remap_node
argument_list|(
operator|&
name|nfn
operator|->
name|fn_args
index|[
name|i
index|]
argument_list|,
name|ofn
operator|->
name|fn_args
index|[
name|i
index|]
argument_list|,
name|old
operator|->
name|t_id
argument_list|,
name|new
argument_list|,
name|mcd
argument_list|)
expr_stmt|;
block|}
name|new
operator|->
name|t_fndef
operator|=
name|nfn
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|conjure_array
parameter_list|(
name|tdesc_t
modifier|*
name|old
parameter_list|,
name|int
name|newselfid
parameter_list|,
name|merge_cb_data_t
modifier|*
name|mcd
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|new
init|=
name|conjure_template
argument_list|(
name|old
argument_list|,
name|newselfid
argument_list|)
decl_stmt|;
name|ardef_t
modifier|*
name|nar
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ardef_t
argument_list|)
argument_list|)
decl_stmt|;
name|ardef_t
modifier|*
name|oar
init|=
name|old
operator|->
name|t_ardef
decl_stmt|;
operator|(
name|void
operator|)
name|remap_node
argument_list|(
operator|&
name|nar
operator|->
name|ad_contents
argument_list|,
name|oar
operator|->
name|ad_contents
argument_list|,
name|old
operator|->
name|t_id
argument_list|,
name|new
argument_list|,
name|mcd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remap_node
argument_list|(
operator|&
name|nar
operator|->
name|ad_idxtype
argument_list|,
name|oar
operator|->
name|ad_idxtype
argument_list|,
name|old
operator|->
name|t_id
argument_list|,
name|new
argument_list|,
name|mcd
argument_list|)
expr_stmt|;
name|nar
operator|->
name|ad_nelems
operator|=
name|oar
operator|->
name|ad_nelems
expr_stmt|;
name|new
operator|->
name|t_ardef
operator|=
name|nar
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|conjure_su
parameter_list|(
name|tdesc_t
modifier|*
name|old
parameter_list|,
name|int
name|newselfid
parameter_list|,
name|merge_cb_data_t
modifier|*
name|mcd
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|new
init|=
name|conjure_template
argument_list|(
name|old
argument_list|,
name|newselfid
argument_list|)
decl_stmt|;
name|mlist_t
modifier|*
name|omem
decl_stmt|,
modifier|*
modifier|*
name|nmemp
decl_stmt|;
for|for
control|(
name|omem
operator|=
name|old
operator|->
name|t_members
operator|,
name|nmemp
operator|=
operator|&
name|new
operator|->
name|t_members
init|;
name|omem
condition|;
name|omem
operator|=
name|omem
operator|->
name|ml_next
operator|,
name|nmemp
operator|=
operator|&
operator|(
operator|(
operator|*
name|nmemp
operator|)
operator|->
name|ml_next
operator|)
control|)
block|{
operator|*
name|nmemp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mlist_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|nmemp
operator|)
operator|->
name|ml_offset
operator|=
name|omem
operator|->
name|ml_offset
expr_stmt|;
operator|(
operator|*
name|nmemp
operator|)
operator|->
name|ml_size
operator|=
name|omem
operator|->
name|ml_size
expr_stmt|;
operator|(
operator|*
name|nmemp
operator|)
operator|->
name|ml_name
operator|=
name|xstrdup
argument_list|(
name|omem
operator|->
name|ml_name
condition|?
name|omem
operator|->
name|ml_name
else|:
literal|"empty omem->ml_name"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remap_node
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|nmemp
operator|)
operator|->
name|ml_type
operator|)
argument_list|,
name|omem
operator|->
name|ml_type
argument_list|,
name|old
operator|->
name|t_id
argument_list|,
name|new
argument_list|,
name|mcd
argument_list|)
expr_stmt|;
block|}
operator|*
name|nmemp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED2*/
end_comment

begin_function
specifier|static
name|tdesc_t
modifier|*
name|conjure_enum
parameter_list|(
name|tdesc_t
modifier|*
name|old
parameter_list|,
name|int
name|newselfid
parameter_list|,
name|merge_cb_data_t
modifier|*
name|mcd
name|__unused
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|new
init|=
name|conjure_template
argument_list|(
name|old
argument_list|,
name|newselfid
argument_list|)
decl_stmt|;
name|elist_t
modifier|*
name|oel
decl_stmt|,
modifier|*
modifier|*
name|nelp
decl_stmt|;
for|for
control|(
name|oel
operator|=
name|old
operator|->
name|t_emem
operator|,
name|nelp
operator|=
operator|&
name|new
operator|->
name|t_emem
init|;
name|oel
condition|;
name|oel
operator|=
name|oel
operator|->
name|el_next
operator|,
name|nelp
operator|=
operator|&
operator|(
operator|(
operator|*
name|nelp
operator|)
operator|->
name|el_next
operator|)
control|)
block|{
operator|*
name|nelp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|elist_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|nelp
operator|)
operator|->
name|el_name
operator|=
name|xstrdup
argument_list|(
name|oel
operator|->
name|el_name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|nelp
operator|)
operator|->
name|el_number
operator|=
name|oel
operator|->
name|el_number
expr_stmt|;
block|}
operator|*
name|nelp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED2*/
end_comment

begin_function
specifier|static
name|tdesc_t
modifier|*
name|conjure_forward
parameter_list|(
name|tdesc_t
modifier|*
name|old
parameter_list|,
name|int
name|newselfid
parameter_list|,
name|merge_cb_data_t
modifier|*
name|mcd
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|new
init|=
name|conjure_template
argument_list|(
name|old
argument_list|,
name|newselfid
argument_list|)
decl_stmt|;
name|list_add
argument_list|(
operator|&
name|mcd
operator|->
name|md_tgt
operator|->
name|td_fwdlist
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|tdesc_t
modifier|*
name|conjure_assert
parameter_list|(
name|tdesc_t
modifier|*
name|old
name|__unused
parameter_list|,
name|int
name|newselfid
name|__unused
parameter_list|,
name|merge_cb_data_t
modifier|*
name|mcd
name|__unused
parameter_list|)
block|{
name|assert
argument_list|(
literal|1
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|iidesc_t
modifier|*
name|conjure_iidesc
parameter_list|(
name|iidesc_t
modifier|*
name|old
parameter_list|,
name|merge_cb_data_t
modifier|*
name|mcd
parameter_list|)
block|{
name|iidesc_t
modifier|*
name|new
init|=
name|iidesc_dup
argument_list|(
name|old
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|remap_node
argument_list|(
operator|&
name|new
operator|->
name|ii_dtype
argument_list|,
name|old
operator|->
name|ii_dtype
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|mcd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new
operator|->
name|ii_nargs
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|remap_node
argument_list|(
operator|&
name|new
operator|->
name|ii_args
index|[
name|i
index|]
argument_list|,
name|old
operator|->
name|ii_args
index|[
name|i
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|mcd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwd_redir
parameter_list|(
name|tdesc_t
modifier|*
name|fwd
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|fwdp
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|alist_t
modifier|*
name|map
init|=
name|private
decl_stmt|;
name|void
modifier|*
name|defn
decl_stmt|;
if|if
condition|(
operator|!
name|alist_find
argument_list|(
name|map
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fwd
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|defn
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Redirecting an edge to %s\n"
argument_list|,
name|tdesc_name
argument_list|(
name|defn
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|fwdp
operator|=
name|defn
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|tdtrav_cb_f
name|fwd_redir_cbs
index|[]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
comment|/* intrinsic */
name|NULL
block|,
comment|/* pointer */
name|NULL
block|,
comment|/* array */
name|NULL
block|,
comment|/* function */
name|NULL
block|,
comment|/* struct */
name|NULL
block|,
comment|/* union */
name|NULL
block|,
comment|/* enum */
name|fwd_redir
block|,
comment|/* forward */
name|NULL
block|,
comment|/* typedef */
name|tdtrav_assert
block|,
comment|/* typedef_unres */
name|NULL
block|,
comment|/* volatile */
name|NULL
block|,
comment|/* const */
name|NULL
comment|/* restrict */
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|redir_mstr_data
block|{
name|tdata_t
modifier|*
name|rmd_tgt
decl_stmt|;
name|alist_t
modifier|*
name|rmd_map
decl_stmt|;
block|}
name|redir_mstr_data_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|redir_mstr_fwd_cb
parameter_list|(
name|void
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|fwd
init|=
name|name
decl_stmt|;
name|int
name|defnid
init|=
operator|(
name|uintptr_t
operator|)
name|value
decl_stmt|;
name|redir_mstr_data_t
modifier|*
name|rmd
init|=
name|arg
decl_stmt|;
name|tdesc_t
name|template
decl_stmt|;
name|tdesc_t
modifier|*
name|defn
decl_stmt|;
name|template
operator|.
name|t_id
operator|=
name|defnid
expr_stmt|;
if|if
condition|(
operator|!
name|hash_find
argument_list|(
name|rmd
operator|->
name|rmd_tgt
operator|->
name|td_idhash
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|template
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|defn
argument_list|)
condition|)
block|{
name|aborterr
argument_list|(
literal|"Couldn't unforward %d (%s)\n"
argument_list|,
name|defnid
argument_list|,
name|tdesc_name
argument_list|(
name|defn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Forward map: resolved %d to %s\n"
argument_list|,
name|defnid
argument_list|,
name|tdesc_name
argument_list|(
name|defn
argument_list|)
argument_list|)
expr_stmt|;
name|alist_add
argument_list|(
name|rmd
operator|->
name|rmd_map
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fwd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|defn
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|redir_mstr_fwds
parameter_list|(
name|merge_cb_data_t
modifier|*
name|mcd
parameter_list|)
block|{
name|redir_mstr_data_t
name|rmd
decl_stmt|;
name|alist_t
modifier|*
name|map
init|=
name|alist_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|rmd
operator|.
name|rmd_tgt
operator|=
name|mcd
operator|->
name|md_tgt
expr_stmt|;
name|rmd
operator|.
name|rmd_map
operator|=
name|map
expr_stmt|;
if|if
condition|(
name|alist_iter
argument_list|(
name|mcd
operator|->
name|md_fdida
argument_list|,
name|redir_mstr_fwd_cb
argument_list|,
operator|&
name|rmd
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|iitraverse_hash
argument_list|(
name|mcd
operator|->
name|md_tgt
operator|->
name|td_iihash
argument_list|,
operator|&
name|mcd
operator|->
name|md_tgt
operator|->
name|td_curvgen
argument_list|,
name|fwd_redir_cbs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
name|alist_free
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_iitba_cb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|merge_cb_data_t
modifier|*
name|mcd
init|=
name|private
decl_stmt|;
name|iidesc_t
modifier|*
name|tba
init|=
name|data
decl_stmt|;
name|iidesc_t
modifier|*
name|new
decl_stmt|;
name|iifind_data_t
name|iif
decl_stmt|;
name|int
name|newidx
decl_stmt|;
name|newidx
operator|=
name|get_mapping
argument_list|(
name|mcd
operator|->
name|md_ta
argument_list|,
name|tba
operator|->
name|ii_dtype
operator|->
name|t_id
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|newidx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|list_remove
argument_list|(
name|mcd
operator|->
name|md_iitba
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|iif
operator|.
name|iif_template
operator|=
name|tba
expr_stmt|;
name|iif
operator|.
name|iif_ta
operator|=
name|mcd
operator|->
name|md_ta
expr_stmt|;
name|iif
operator|.
name|iif_newidx
operator|=
name|newidx
expr_stmt|;
name|iif
operator|.
name|iif_refmerge
operator|=
operator|(
name|mcd
operator|->
name|md_flags
operator|&
name|MCD_F_REFMERGE
operator|)
expr_stmt|;
if|if
condition|(
name|hash_match
argument_list|(
name|mcd
operator|->
name|md_parent
operator|->
name|td_iihash
argument_list|,
name|tba
argument_list|,
name|iidesc_match
argument_list|,
operator|&
name|iif
argument_list|)
operator|==
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"iidesc_t %s already exists\n"
argument_list|,
operator|(
name|tba
operator|->
name|ii_name
condition|?
name|tba
operator|->
name|ii_name
else|:
literal|"(anon)"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|new
operator|=
name|conjure_iidesc
argument_list|(
name|tba
argument_list|,
name|mcd
argument_list|)
expr_stmt|;
name|hash_add
argument_list|(
name|mcd
operator|->
name|md_tgt
operator|->
name|td_iihash
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_tdesc
parameter_list|(
name|tdesc_t
modifier|*
name|oldtdp
parameter_list|,
name|int
name|newid
parameter_list|,
name|merge_cb_data_t
modifier|*
name|mcd
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|newtdp
decl_stmt|;
name|tdesc_t
name|template
decl_stmt|;
name|template
operator|.
name|t_id
operator|=
name|newid
expr_stmt|;
name|assert
argument_list|(
name|hash_find
argument_list|(
name|mcd
operator|->
name|md_parent
operator|->
name|td_idhash
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|template
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"trying to conjure %d %s (%d,<%x>) as %d,<%x>\n"
argument_list|,
name|oldtdp
operator|->
name|t_type
argument_list|,
name|tdesc_name
argument_list|(
name|oldtdp
argument_list|)
argument_list|,
name|oldtdp
operator|->
name|t_id
argument_list|,
name|oldtdp
operator|->
name|t_id
argument_list|,
name|newid
argument_list|,
name|newid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newtdp
operator|=
name|tdesc_ops
index|[
name|oldtdp
operator|->
name|t_type
index|]
operator|.
name|conjure
argument_list|(
name|oldtdp
argument_list|,
name|newid
argument_list|,
name|mcd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* couldn't map everything */
return|return
operator|(
literal|0
operator|)
return|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"succeeded\n"
argument_list|)
expr_stmt|;
name|hash_add
argument_list|(
name|mcd
operator|->
name|md_tgt
operator|->
name|td_idhash
argument_list|,
name|newtdp
argument_list|)
expr_stmt|;
name|hash_add
argument_list|(
name|mcd
operator|->
name|md_tgt
operator|->
name|td_layouthash
argument_list|,
name|newtdp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_tdtba_cb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp
init|=
name|data
decl_stmt|;
name|merge_cb_data_t
modifier|*
name|mcd
init|=
name|arg
decl_stmt|;
name|int
name|newid
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|newid
operator|=
name|get_mapping
argument_list|(
name|mcd
operator|->
name|md_ta
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|newid
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|add_tdesc
argument_list|(
name|tdp
argument_list|,
name|newid
argument_list|,
name|mcd
argument_list|)
operator|)
condition|)
name|hash_remove
argument_list|(
name|mcd
operator|->
name|md_tdtba
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tdp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_tdtbr_cb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tdesc_t
modifier|*
modifier|*
name|tdpp
init|=
name|data
decl_stmt|;
name|merge_cb_data_t
modifier|*
name|mcd
init|=
name|arg
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Remapping %s (%d)\n"
argument_list|,
name|tdesc_name
argument_list|(
operator|*
name|tdpp
argument_list|)
argument_list|,
operator|(
operator|*
name|tdpp
operator|)
operator|->
name|t_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remap_node
argument_list|(
name|tdpp
argument_list|,
operator|*
name|tdpp
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|mcd
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|list_remove
argument_list|(
name|mcd
operator|->
name|md_tdtbr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tdpp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|merge_types
parameter_list|(
name|hash_t
modifier|*
name|src
parameter_list|,
name|merge_cb_data_t
modifier|*
name|mcd
parameter_list|)
block|{
name|list_t
modifier|*
name|iitba
init|=
name|NULL
decl_stmt|;
name|list_t
modifier|*
name|tdtbr
init|=
name|NULL
decl_stmt|;
name|int
name|iirc
decl_stmt|,
name|tdrc
decl_stmt|;
name|mcd
operator|->
name|md_iitba
operator|=
operator|&
name|iitba
expr_stmt|;
name|mcd
operator|->
name|md_tdtba
operator|=
name|hash_new
argument_list|(
name|TDATA_LAYOUT_HASH_SIZE
argument_list|,
name|tdesc_layouthash
argument_list|,
name|tdesc_layoutcmp
argument_list|)
expr_stmt|;
name|mcd
operator|->
name|md_tdtbr
operator|=
operator|&
name|tdtbr
expr_stmt|;
operator|(
name|void
operator|)
name|hash_iter
argument_list|(
name|src
argument_list|,
name|merge_type_cb
argument_list|,
name|mcd
argument_list|)
expr_stmt|;
name|tdrc
operator|=
name|hash_iter
argument_list|(
name|mcd
operator|->
name|md_tdtba
argument_list|,
name|add_tdtba_cb
argument_list|,
name|mcd
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"add_tdtba_cb added %d items\n"
argument_list|,
name|tdrc
argument_list|)
expr_stmt|;
name|iirc
operator|=
name|list_iter
argument_list|(
operator|*
name|mcd
operator|->
name|md_iitba
argument_list|,
name|add_iitba_cb
argument_list|,
name|mcd
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"add_iitba_cb added %d items\n"
argument_list|,
name|iirc
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|list_count
argument_list|(
operator|*
name|mcd
operator|->
name|md_iitba
argument_list|)
operator|==
literal|0
operator|&&
name|hash_count
argument_list|(
name|mcd
operator|->
name|md_tdtba
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tdrc
operator|=
name|list_iter
argument_list|(
operator|*
name|mcd
operator|->
name|md_tdtbr
argument_list|,
name|add_tdtbr_cb
argument_list|,
name|mcd
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"add_tdtbr_cb added %d items\n"
argument_list|,
name|tdrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_count
argument_list|(
operator|*
name|mcd
operator|->
name|md_tdtbr
argument_list|)
operator|!=
literal|0
condition|)
name|aborterr
argument_list|(
literal|"Couldn't remap all nodes\n"
argument_list|)
expr_stmt|;
comment|/* 	 * We now have an alist of master forwards and the ids of the new master 	 * definitions for those forwards in mcd->md_fdida.  By this point, 	 * we're guaranteed that all of the master definitions referenced in 	 * fdida have been added to the master tree.  We now traverse through 	 * the master tree, redirecting all edges inbound to forwards that have 	 * definitions to those definitions. 	 */
if|if
condition|(
name|mcd
operator|->
name|md_parent
operator|==
name|mcd
operator|->
name|md_tgt
condition|)
block|{
name|redir_mstr_fwds
argument_list|(
name|mcd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|merge_into_master
parameter_list|(
name|tdata_t
modifier|*
name|cur
parameter_list|,
name|tdata_t
modifier|*
name|mstr
parameter_list|,
name|tdata_t
modifier|*
name|tgt
parameter_list|,
name|int
name|selfuniquify
parameter_list|)
block|{
name|merge_cb_data_t
name|mcd
decl_stmt|;
name|cur
operator|->
name|td_ref
operator|++
expr_stmt|;
name|mstr
operator|->
name|td_ref
operator|++
expr_stmt|;
if|if
condition|(
name|tgt
condition|)
name|tgt
operator|->
name|td_ref
operator|++
expr_stmt|;
name|assert
argument_list|(
name|cur
operator|->
name|td_ref
operator|==
literal|1
operator|&&
name|mstr
operator|->
name|td_ref
operator|==
literal|1
operator|&&
operator|(
name|tgt
operator|==
name|NULL
operator|||
name|tgt
operator|->
name|td_ref
operator|==
literal|1
operator|)
argument_list|)
expr_stmt|;
name|mcd
operator|.
name|md_parent
operator|=
name|mstr
expr_stmt|;
name|mcd
operator|.
name|md_tgt
operator|=
operator|(
name|tgt
condition|?
name|tgt
else|:
name|mstr
operator|)
expr_stmt|;
name|mcd
operator|.
name|md_ta
operator|=
name|alist_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mcd
operator|.
name|md_fdida
operator|=
name|alist_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mcd
operator|.
name|md_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|selfuniquify
condition|)
name|mcd
operator|.
name|md_flags
operator||=
name|MCD_F_SELFUNIQUIFY
expr_stmt|;
if|if
condition|(
name|tgt
condition|)
name|mcd
operator|.
name|md_flags
operator||=
name|MCD_F_REFMERGE
expr_stmt|;
name|mstr
operator|->
name|td_curvgen
operator|=
name|MAX
argument_list|(
name|mstr
operator|->
name|td_curvgen
argument_list|,
name|cur
operator|->
name|td_curvgen
argument_list|)
expr_stmt|;
name|mstr
operator|->
name|td_curemark
operator|=
name|MAX
argument_list|(
name|mstr
operator|->
name|td_curemark
argument_list|,
name|cur
operator|->
name|td_curemark
argument_list|)
expr_stmt|;
name|merge_types
argument_list|(
name|cur
operator|->
name|td_iihash
argument_list|,
operator|&
name|mcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>=
literal|3
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Type association stats\n"
argument_list|)
expr_stmt|;
name|alist_stats
argument_list|(
name|mcd
operator|.
name|md_ta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Layout hash stats\n"
argument_list|)
expr_stmt|;
name|hash_stats
argument_list|(
name|mcd
operator|.
name|md_tgt
operator|->
name|td_layouthash
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|alist_free
argument_list|(
name|mcd
operator|.
name|md_fdida
argument_list|)
expr_stmt|;
name|alist_free
argument_list|(
name|mcd
operator|.
name|md_ta
argument_list|)
expr_stmt|;
name|cur
operator|->
name|td_ref
operator|--
expr_stmt|;
name|mstr
operator|->
name|td_ref
operator|--
expr_stmt|;
if|if
condition|(
name|tgt
condition|)
name|tgt
operator|->
name|td_ref
operator|--
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|tdesc_ops_t
name|tdesc_ops
index|[]
init|=
block|{
block|{
literal|"ERROR! BAD tdesc TYPE"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"intrinsic"
block|,
name|equiv_intrinsic
block|,
name|conjure_intrinsic
block|}
block|,
block|{
literal|"pointer"
block|,
name|equiv_plain
block|,
name|conjure_plain
block|}
block|,
block|{
literal|"array"
block|,
name|equiv_array
block|,
name|conjure_array
block|}
block|,
block|{
literal|"function"
block|,
name|equiv_function
block|,
name|conjure_function
block|}
block|,
block|{
literal|"struct"
block|,
name|equiv_su
block|,
name|conjure_su
block|}
block|,
block|{
literal|"union"
block|,
name|equiv_su
block|,
name|conjure_su
block|}
block|,
block|{
literal|"enum"
block|,
name|equiv_enum
block|,
name|conjure_enum
block|}
block|,
block|{
literal|"forward"
block|,
name|NULL
block|,
name|conjure_forward
block|}
block|,
block|{
literal|"typedef"
block|,
name|equiv_plain
block|,
name|conjure_plain
block|}
block|,
block|{
literal|"typedef_unres"
block|,
name|equiv_assert
block|,
name|conjure_assert
block|}
block|,
block|{
literal|"volatile"
block|,
name|equiv_plain
block|,
name|conjure_plain
block|}
block|,
block|{
literal|"const"
block|,
name|equiv_plain
block|,
name|conjure_plain
block|}
block|,
block|{
literal|"restrict"
block|,
name|equiv_plain
block|,
name|conjure_plain
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

