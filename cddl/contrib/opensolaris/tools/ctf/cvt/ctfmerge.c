begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * Given several files containing CTF data, merge and uniquify that data into  * a single CTF section in an output file.  *  * Merges can proceed independently.  As such, we perform the merges in parallel  * using a worker thread model.  A given glob of CTF data (either all of the CTF  * data from a single input file, or the result of one or more merges) can only  * be involved in a single merge at any given time, so the process decreases in  * parallelism, especially towards the end, as more and more files are  * consolidated, finally resulting in a single merge of two large CTF graphs.  * Unfortunately, the last merge is also the slowest, as the two graphs being  * merged are each the product of merges of half of the input files.  *  * The algorithm consists of two phases, described in detail below.  The first  * phase entails the merging of CTF data in groups of eight.  The second phase  * takes the results of Phase I, and merges them two at a time.  This disparity  * is due to an observation that the merge time increases at least quadratically  * with the size of the CTF data being merged.  As such, merges of CTF graphs  * newly read from input files are much faster than merges of CTF graphs that  * are themselves the results of prior merges.  *  * A further complication is the need to ensure the repeatability of CTF merges.  * That is, a merge should produce the same output every time, given the same  * input.  In both phases, this consistency requirement is met by imposing an  * ordering on the merge process, thus ensuring that a given set of input files  * are merged in the same order every time.  *  *   Phase I  *  *   The main thread reads the input files one by one, transforming the CTF  *   data they contain into tdata structures.  When a given file has been read  *   and parsed, it is placed on the work queue for retrieval by worker threads.  *  *   Central to Phase I is the Work In Progress (wip) array, which is used to  *   merge batches of files in a predictable order.  Files are read by the main  *   thread, and are merged into wip array elements in round-robin order.  When  *   the number of files merged into a given array slot equals the batch size,  *   the merged CTF graph in that array is added to the done slot in order by  *   array slot.  *  *   For example, consider a case where we have five input files, a batch size  *   of two, a wip array size of two, and two worker threads (T1 and T2).  *  *    1. The wip array elements are assigned initial batch numbers 0 and 1.  *    2. T1 reads an input file from the input queue (wq_queue).  This is the  *       first input file, so it is placed into wip[0].  The second file is  *       similarly read and placed into wip[1].  The wip array slots now contain  *       one file each (wip_nmerged == 1).  *    3. T1 reads the third input file, which it merges into wip[0].  The  *       number of files in wip[0] is equal to the batch size.  *    4. T2 reads the fourth input file, which it merges into wip[1].  wip[1]  *       is now full too.  *    5. T2 attempts to place the contents of wip[1] on the done queue  *       (wq_done_queue), but it can't, since the batch ID for wip[1] is 1.  *       Batch 0 needs to be on the done queue before batch 1 can be added, so  *       T2 blocks on wip[1]'s cv.  *    6. T1 attempts to place the contents of wip[0] on the done queue, and  *       succeeds, updating wq_lastdonebatch to 0.  It clears wip[0], and sets  *       its batch ID to 2.  T1 then signals wip[1]'s cv to awaken T2.  *    7. T2 wakes up, notices that wq_lastdonebatch is 0, which means that  *       batch 1 can now be added.  It adds wip[1] to the done queue, clears  *       wip[1], and sets its batch ID to 3.  It signals wip[0]'s cv, and  *       restarts.  *  *   The above process continues until all input files have been consumed.  At  *   this point, a pair of barriers are used to allow a single thread to move  *   any partial batches from the wip array to the done array in batch ID order.  *   When this is complete, wq_done_queue is moved to wq_queue, and Phase II  *   begins.  *  *	Locking Semantics (Phase I)  *  *	The input queue (wq_queue) and the done queue (wq_done_queue) are  *	protected by separate mutexes - wq_queue_lock and wq_done_queue.  wip  *	array slots are protected by their own mutexes, which must be grabbed  *	before releasing the input queue lock.  The wip array lock is dropped  *	when the thread restarts the loop.  If the array slot was full, the  *	array lock will be held while the slot contents are added to the done  *	queue.  The done queue lock is used to protect the wip slot cv's.  *  *	The pow number is protected by the queue lock.  The master batch ID  *	and last completed batch (wq_lastdonebatch) counters are protected *in  *	Phase I* by the done queue lock.  *  *   Phase II  *  *   When Phase II begins, the queue consists of the merged batches from the  *   first phase.  Assume we have five batches:  *  *	Q:	a b c d e  *  *   Using the same batch ID mechanism we used in Phase I, but without the wip  *   array, worker threads remove two entries at a time from the beginning of  *   the queue.  These two entries are merged, and are added back to the tail  *   of the queue, as follows:  *  *	Q:	a b c d e	# start  *	Q:	c d e ab	# a, b removed, merged, added to end  *	Q:	e ab cd		# c, d removed, merged, added to end  *	Q:	cd eab		# e, ab removed, merged, added to end  *	Q:	cdeab		# cd, eab removed, merged, added to end  *  *   When one entry remains on the queue, with no merges outstanding, Phase II  *   finishes.  We pre-determine the stopping point by pre-calculating the  *   number of nodes that will appear on the list.  In the example above, the  *   number (wq_ninqueue) is 9.  When ninqueue is 1, we conclude Phase II by  *   signaling the main thread via wq_done_cv.  *  *	Locking Semantics (Phase II)  *  *	The queue (wq_queue), ninqueue, and the master batch ID and last  *	completed batch counters are protected by wq_queue_lock.  The done  *	queue and corresponding lock are unused in Phase II as is the wip array.  *  *   Uniquification  *  *   We want the CTF data that goes into a given module to be as small as  *   possible.  For example, we don't want it to contain any type data that may  *   be present in another common module.  As such, after creating the master  *   tdata_t for a given module, we can, if requested by the user, uniquify it  *   against the tdata_t from another module (genunix in the case of the SunOS  *   kernel).  We perform a merge between the tdata_t for this module and the  *   tdata_t from genunix.  Nodes found in this module that are not present in  *   genunix are added to a third tdata_t - the uniquified tdata_t.  *  *   Additive Merges  *  *   In some cases, for example if we are issuing a new version of a common  *   module in a patch, we need to make sure that the CTF data already present  *   in that module does not change.  Changes to this data would void the CTF  *   data in any module that uniquified against the common module.  To preserve  *   the existing data, we can perform what is known as an additive merge.  In  *   this case, a final uniquification is performed against the CTF data in the  *   previous version of the module.  The result will be the placement of new  *   and changed data after the existing data, thus preserving the existing type  *   ID space.  *  *   Saving the result  *  *   When the merges are complete, the resulting tdata_t is placed into the  *   output file, replacing the .SUNW_ctf section (if any) already in that file.  *  * The person who changes the merging thread code in this file without updating  * this comment will not live to see the stock hit five.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<synch.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/sysconf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ctf_headers.h"
end_include

begin_include
include|#
directive|include
file|"ctftools.h"
end_include

begin_include
include|#
directive|include
file|"ctfmerge.h"
end_include

begin_include
include|#
directive|include
file|"traverse.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"fifo.h"
end_include

begin_include
include|#
directive|include
file|"barrier.h"
end_include

begin_pragma
pragma|#
directive|pragma
name|init
name|(
name|bigheap
name|)
end_pragma

begin_define
define|#
directive|define
name|MERGE_PHASE1_BATCH_SIZE
value|8
end_define

begin_define
define|#
directive|define
name|MERGE_PHASE1_MAX_SLOTS
value|5
end_define

begin_define
define|#
directive|define
name|MERGE_INPUT_THROTTLE_LEN
value|10
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|outfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tmpname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dynsym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug_level
init|=
name|DEBUG_LEVEL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|maxpgsize
init|=
literal|0x400000
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-fgstv] -l label | -L labelenv -o outfile file ...\n"
literal|"       %s [-fgstv] -l label | -L labelenv -o outfile -d uniqfile\n"
literal|"       %*s [-g] [-D uniqlabel] file ...\n"
literal|"       %s [-fgstv] -l label | -L labelenv -o outfile -w withfile "
literal|"file ...\n"
literal|"       %s [-g] -c srcfile destfile\n"
literal|"\n"
literal|"  Note: if -L labelenv is specified and labelenv is not set in\n"
literal|"  the environment, a default value is used.\n"
argument_list|,
name|progname
argument_list|,
name|progname
argument_list|,
name|strlen
argument_list|(
name|progname
argument_list|)
argument_list|,
literal|" "
argument_list|,
name|progname
argument_list|,
name|progname
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_function
specifier|static
name|void
name|bigheap
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|big
decl_stmt|,
modifier|*
name|size
decl_stmt|;
name|int
name|sizes
decl_stmt|;
name|struct
name|memcntl_mha
name|mha
decl_stmt|;
comment|/* 	 * First, get the available pagesizes. 	 */
if|if
condition|(
operator|(
name|sizes
operator|=
name|getpagesizes
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|sizes
operator|==
literal|1
operator|||
operator|(
name|size
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
name|sizes
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|getpagesizes
argument_list|(
name|size
argument_list|,
name|sizes
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
while|while
condition|(
name|size
index|[
name|sizes
operator|-
literal|1
index|]
operator|>
name|maxpgsize
condition|)
name|sizes
operator|--
expr_stmt|;
comment|/* set big to the largest allowed page size */
name|big
operator|=
name|size
index|[
name|sizes
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|big
operator|&
operator|(
name|big
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* 		 * The largest page size is not a power of two for some 		 * inexplicable reason; return. 		 */
return|return;
block|}
comment|/* 	 * Now, align our break to the largest page size. 	 */
if|if
condition|(
name|brk
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|big
operator|-
literal|1
operator|)
operator|)
operator|+
name|big
operator|)
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * set the preferred page size for the heap 	 */
name|mha
operator|.
name|mha_cmd
operator|=
name|MHA_MAPSIZE_BSSBRK
expr_stmt|;
name|mha
operator|.
name|mha_flags
operator|=
literal|0
expr_stmt|;
name|mha
operator|.
name|mha_pagesize
operator|=
name|big
expr_stmt|;
operator|(
name|void
operator|)
name|memcntl
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|MC_HAT_ADVISE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|mha
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|finalize_phase_one
parameter_list|(
name|workqueue_t
modifier|*
name|wq
parameter_list|)
block|{
name|int
name|startslot
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * wip slots are cleared out only when maxbatchsz td's have been merged 	 * into them.  We're not guaranteed that the number of files we're 	 * merging is a multiple of maxbatchsz, so there will be some partial 	 * groups in the wip array.  Move them to the done queue in batch ID 	 * order, starting with the slot containing the next batch that would 	 * have been placed on the done queue, followed by the others. 	 * One thread will be doing this while the others wait at the barrier 	 * back in worker_thread(), so we don't need to worry about pesky things 	 * like locks. 	 */
for|for
control|(
name|startslot
operator|=
operator|-
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wq
operator|->
name|wq_nwipslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wq
operator|->
name|wq_wip
index|[
name|i
index|]
operator|.
name|wip_batchid
operator|==
name|wq
operator|->
name|wq_lastdonebatch
operator|+
literal|1
condition|)
block|{
name|startslot
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|assert
argument_list|(
name|startslot
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|startslot
init|;
name|i
operator|<
name|startslot
operator|+
name|wq
operator|->
name|wq_nwipslots
condition|;
name|i
operator|++
control|)
block|{
name|int
name|slotnum
init|=
name|i
operator|%
name|wq
operator|->
name|wq_nwipslots
decl_stmt|;
name|wip_t
modifier|*
name|wipslot
init|=
operator|&
name|wq
operator|->
name|wq_wip
index|[
name|slotnum
index|]
decl_stmt|;
if|if
condition|(
name|wipslot
operator|->
name|wip_td
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"clearing slot %d (%d) (saving %d)\n"
argument_list|,
name|slotnum
argument_list|,
name|i
argument_list|,
name|wipslot
operator|->
name|wip_nmerged
argument_list|)
expr_stmt|;
block|}
else|else
name|debug
argument_list|(
literal|2
argument_list|,
literal|"clearing slot %d (%d)\n"
argument_list|,
name|slotnum
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|wipslot
operator|->
name|wip_td
operator|!=
name|NULL
condition|)
block|{
name|fifo_add
argument_list|(
name|wq
operator|->
name|wq_donequeue
argument_list|,
name|wipslot
operator|->
name|wip_td
argument_list|)
expr_stmt|;
name|wq
operator|->
name|wq_wip
index|[
name|slotnum
index|]
operator|.
name|wip_td
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|wq
operator|->
name|wq_lastdonebatch
operator|=
name|wq
operator|->
name|wq_next_batchid
operator|++
expr_stmt|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"phase one done: donequeue has %d items\n"
argument_list|,
name|fifo_len
argument_list|(
name|wq
operator|->
name|wq_donequeue
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_phase_two
parameter_list|(
name|workqueue_t
modifier|*
name|wq
parameter_list|)
block|{
name|int
name|num
decl_stmt|;
comment|/* 	 * We're going to continually merge the first two entries on the queue, 	 * placing the result on the end, until there's nothing left to merge. 	 * At that point, everything will have been merged into one.  The 	 * initial value of ninqueue needs to be equal to the total number of 	 * entries that will show up on the queue, both at the start of the 	 * phase and as generated by merges during the phase. 	 */
name|wq
operator|->
name|wq_ninqueue
operator|=
name|num
operator|=
name|fifo_len
argument_list|(
name|wq
operator|->
name|wq_donequeue
argument_list|)
expr_stmt|;
while|while
condition|(
name|num
operator|!=
literal|1
condition|)
block|{
name|wq
operator|->
name|wq_ninqueue
operator|+=
name|num
operator|/
literal|2
expr_stmt|;
name|num
operator|=
name|num
operator|/
literal|2
operator|+
name|num
operator|%
literal|2
expr_stmt|;
block|}
comment|/* 	 * Move the done queue to the work queue.  We won't be using the done 	 * queue in phase 2. 	 */
name|assert
argument_list|(
name|fifo_len
argument_list|(
name|wq
operator|->
name|wq_queue
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|fifo_free
argument_list|(
name|wq
operator|->
name|wq_queue
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wq
operator|->
name|wq_queue
operator|=
name|wq
operator|->
name|wq_donequeue
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wip_save_work
parameter_list|(
name|workqueue_t
modifier|*
name|wq
parameter_list|,
name|wip_t
modifier|*
name|slot
parameter_list|,
name|int
name|slotnum
parameter_list|)
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|wq
operator|->
name|wq_donequeue_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|wq
operator|->
name|wq_lastdonebatch
operator|+
literal|1
operator|<
name|slot
operator|->
name|wip_batchid
condition|)
name|pthread_cond_wait
argument_list|(
operator|&
name|slot
operator|->
name|wip_cv
argument_list|,
operator|&
name|wq
operator|->
name|wq_donequeue_lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|wq
operator|->
name|wq_lastdonebatch
operator|+
literal|1
operator|==
name|slot
operator|->
name|wip_batchid
argument_list|)
expr_stmt|;
name|fifo_add
argument_list|(
name|wq
operator|->
name|wq_donequeue
argument_list|,
name|slot
operator|->
name|wip_td
argument_list|)
expr_stmt|;
name|wq
operator|->
name|wq_lastdonebatch
operator|++
expr_stmt|;
name|pthread_cond_signal
argument_list|(
operator|&
name|wq
operator|->
name|wq_wip
index|[
operator|(
name|slotnum
operator|+
literal|1
operator|)
operator|%
name|wq
operator|->
name|wq_nwipslots
index|]
operator|.
name|wip_cv
argument_list|)
expr_stmt|;
comment|/* reset the slot for next use */
name|slot
operator|->
name|wip_td
operator|=
name|NULL
expr_stmt|;
name|slot
operator|->
name|wip_batchid
operator|=
name|wq
operator|->
name|wq_next_batchid
operator|++
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|wq
operator|->
name|wq_donequeue_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wip_add_work
parameter_list|(
name|wip_t
modifier|*
name|slot
parameter_list|,
name|tdata_t
modifier|*
name|pow
parameter_list|)
block|{
if|if
condition|(
name|slot
operator|->
name|wip_td
operator|==
name|NULL
condition|)
block|{
name|slot
operator|->
name|wip_td
operator|=
name|pow
expr_stmt|;
name|slot
operator|->
name|wip_nmerged
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%d: merging %p into %p\n"
argument_list|,
name|pthread_self
argument_list|()
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pow
argument_list|,
operator|(
name|void
operator|*
operator|)
name|slot
operator|->
name|wip_td
argument_list|)
expr_stmt|;
name|merge_into_master
argument_list|(
name|pow
argument_list|,
name|slot
operator|->
name|wip_td
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tdata_free
argument_list|(
name|pow
argument_list|)
expr_stmt|;
name|slot
operator|->
name|wip_nmerged
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|worker_runphase1
parameter_list|(
name|workqueue_t
modifier|*
name|wq
parameter_list|)
block|{
name|wip_t
modifier|*
name|wipslot
decl_stmt|;
name|tdata_t
modifier|*
name|pow
decl_stmt|;
name|int
name|wipslotnum
decl_stmt|,
name|pownum
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|fifo_empty
argument_list|(
name|wq
operator|->
name|wq_queue
argument_list|)
condition|)
block|{
if|if
condition|(
name|wq
operator|->
name|wq_nomorefiles
operator|==
literal|1
condition|)
block|{
name|pthread_cond_broadcast
argument_list|(
operator|&
name|wq
operator|->
name|wq_work_avail
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
comment|/* on to phase 2 ... */
return|return;
block|}
name|pthread_cond_wait
argument_list|(
operator|&
name|wq
operator|->
name|wq_work_avail
argument_list|,
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
block|}
comment|/* there's work to be done! */
name|pow
operator|=
name|fifo_remove
argument_list|(
name|wq
operator|->
name|wq_queue
argument_list|)
expr_stmt|;
name|pownum
operator|=
name|wq
operator|->
name|wq_nextpownum
operator|++
expr_stmt|;
name|pthread_cond_broadcast
argument_list|(
operator|&
name|wq
operator|->
name|wq_work_removed
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pow
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* merge it into the right slot */
name|wipslotnum
operator|=
name|pownum
operator|%
name|wq
operator|->
name|wq_nwipslots
expr_stmt|;
name|wipslot
operator|=
operator|&
name|wq
operator|->
name|wq_wip
index|[
name|wipslotnum
index|]
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|wipslot
operator|->
name|wip_lock
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
name|wip_add_work
argument_list|(
name|wipslot
argument_list|,
name|pow
argument_list|)
expr_stmt|;
if|if
condition|(
name|wipslot
operator|->
name|wip_nmerged
operator|==
name|wq
operator|->
name|wq_maxbatchsz
condition|)
name|wip_save_work
argument_list|(
name|wq
argument_list|,
name|wipslot
argument_list|,
name|wipslotnum
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|wipslot
operator|->
name|wip_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|worker_runphase2
parameter_list|(
name|workqueue_t
modifier|*
name|wq
parameter_list|)
block|{
name|tdata_t
modifier|*
name|pow1
decl_stmt|,
modifier|*
name|pow2
decl_stmt|;
name|int
name|batchid
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|wq
operator|->
name|wq_ninqueue
operator|==
literal|1
condition|)
block|{
name|pthread_cond_broadcast
argument_list|(
operator|&
name|wq
operator|->
name|wq_work_avail
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%d: entering p2 completion barrier\n"
argument_list|,
name|pthread_self
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|barrier_wait
argument_list|(
operator|&
name|wq
operator|->
name|wq_bar1
argument_list|)
condition|)
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
name|wq
operator|->
name|wq_alldone
operator|=
literal|1
expr_stmt|;
name|pthread_cond_signal
argument_list|(
operator|&
name|wq
operator|->
name|wq_alldone_cv
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|fifo_len
argument_list|(
name|wq
operator|->
name|wq_queue
argument_list|)
operator|<
literal|2
condition|)
block|{
name|pthread_cond_wait
argument_list|(
operator|&
name|wq
operator|->
name|wq_work_avail
argument_list|,
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* there's work to be done! */
name|pow1
operator|=
name|fifo_remove
argument_list|(
name|wq
operator|->
name|wq_queue
argument_list|)
expr_stmt|;
name|pow2
operator|=
name|fifo_remove
argument_list|(
name|wq
operator|->
name|wq_queue
argument_list|)
expr_stmt|;
name|wq
operator|->
name|wq_ninqueue
operator|-=
literal|2
expr_stmt|;
name|batchid
operator|=
name|wq
operator|->
name|wq_next_batchid
operator|++
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%d: merging %p into %p\n"
argument_list|,
name|pthread_self
argument_list|()
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pow1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pow2
argument_list|)
expr_stmt|;
name|merge_into_master
argument_list|(
name|pow1
argument_list|,
name|pow2
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tdata_free
argument_list|(
name|pow1
argument_list|)
expr_stmt|;
comment|/* 		 * merging is complete.  place at the tail of the queue in 		 * proper order. 		 */
name|pthread_mutex_lock
argument_list|(
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|wq
operator|->
name|wq_lastdonebatch
operator|+
literal|1
operator|!=
name|batchid
condition|)
block|{
name|pthread_cond_wait
argument_list|(
operator|&
name|wq
operator|->
name|wq_done_cv
argument_list|,
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
block|}
name|wq
operator|->
name|wq_lastdonebatch
operator|=
name|batchid
expr_stmt|;
name|fifo_add
argument_list|(
name|wq
operator|->
name|wq_queue
argument_list|,
name|pow2
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%d: added %p to queue, len now %d, ninqueue %d\n"
argument_list|,
name|pthread_self
argument_list|()
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pow2
argument_list|,
name|fifo_len
argument_list|(
name|wq
operator|->
name|wq_queue
argument_list|)
argument_list|,
name|wq
operator|->
name|wq_ninqueue
argument_list|)
expr_stmt|;
name|pthread_cond_broadcast
argument_list|(
operator|&
name|wq
operator|->
name|wq_done_cv
argument_list|)
expr_stmt|;
name|pthread_cond_signal
argument_list|(
operator|&
name|wq
operator|->
name|wq_work_avail
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Main loop for worker threads.  */
end_comment

begin_function
specifier|static
name|void
name|worker_thread
parameter_list|(
name|workqueue_t
modifier|*
name|wq
parameter_list|)
block|{
name|worker_runphase1
argument_list|(
name|wq
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%d: entering first barrier\n"
argument_list|,
name|pthread_self
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|barrier_wait
argument_list|(
operator|&
name|wq
operator|->
name|wq_bar1
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%d: doing work in first barrier\n"
argument_list|,
name|pthread_self
argument_list|()
argument_list|)
expr_stmt|;
name|finalize_phase_one
argument_list|(
name|wq
argument_list|)
expr_stmt|;
name|init_phase_two
argument_list|(
name|wq
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%d: ninqueue is %d, %d on queue\n"
argument_list|,
name|pthread_self
argument_list|()
argument_list|,
name|wq
operator|->
name|wq_ninqueue
argument_list|,
name|fifo_len
argument_list|(
name|wq
operator|->
name|wq_queue
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%d: entering second barrier\n"
argument_list|,
name|pthread_self
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|barrier_wait
argument_list|(
operator|&
name|wq
operator|->
name|wq_bar2
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"%d: phase 1 complete\n"
argument_list|,
name|pthread_self
argument_list|()
argument_list|)
expr_stmt|;
name|worker_runphase2
argument_list|(
name|wq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pass a tdata_t tree, built from an input file, off to the work queue for  * consumption by worker threads.  */
end_comment

begin_function
specifier|static
name|int
name|merge_ctf_cb
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|workqueue_t
modifier|*
name|wq
init|=
name|arg
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Adding tdata %p for processing\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|td
argument_list|)
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|fifo_len
argument_list|(
name|wq
operator|->
name|wq_queue
argument_list|)
operator|>
name|wq
operator|->
name|wq_ithrottle
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"Throttling input (len = %d, throttle = %d)\n"
argument_list|,
name|fifo_len
argument_list|(
name|wq
operator|->
name|wq_queue
argument_list|)
argument_list|,
name|wq
operator|->
name|wq_ithrottle
argument_list|)
expr_stmt|;
name|pthread_cond_wait
argument_list|(
operator|&
name|wq
operator|->
name|wq_work_removed
argument_list|,
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
block|}
name|fifo_add
argument_list|(
name|wq
operator|->
name|wq_queue
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"Thread %d announcing %s\n"
argument_list|,
name|pthread_self
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pthread_cond_broadcast
argument_list|(
operator|&
name|wq
operator|->
name|wq_work_avail
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This program is intended to be invoked from a Makefile, as part of the build.  * As such, in the event of a failure or user-initiated interrupt (^C), we need  * to ensure that a subsequent re-make will cause ctfmerge to be executed again.  * Unfortunately, ctfmerge will usually be invoked directly after (and as part  * of the same Makefile rule as) a link, and will operate on the linked file  * in place.  If we merely exit upon receipt of a SIGINT, a subsequent make  * will notice that the *linked* file is newer than the object files, and thus  * will not reinvoke ctfmerge.  The only way to ensure that a subsequent make  * reinvokes ctfmerge, is to remove the file to which we are adding CTF  * data (confusingly named the output file).  This means that the link will need  * to happen again, but links are generally fast, and we can't allow the merge  * to be skipped.  *  * Another possibility would be to block SIGINT entirely - to always run to  * completion.  The run time of ctfmerge can, however, be measured in minutes  * in some cases, so this is not a valid option.  */
end_comment

begin_function
specifier|static
name|void
name|handle_sig
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|terminate
argument_list|(
literal|"Caught signal %d - exiting\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|terminate_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|dounlink
init|=
name|getenv
argument_list|(
literal|"CTFMERGE_TERMINATE_NO_UNLINK"
argument_list|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|tmpname
operator|!=
name|NULL
operator|&&
name|dounlink
condition|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
name|NULL
condition|)
return|return;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|dounlink
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Removing %s\n"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|copy_ctf_data
parameter_list|(
name|char
modifier|*
name|srcfile
parameter_list|,
name|char
modifier|*
name|destfile
parameter_list|,
name|int
name|keep_stabs
parameter_list|)
block|{
name|tdata_t
modifier|*
name|srctd
decl_stmt|;
if|if
condition|(
name|read_ctf
argument_list|(
operator|&
name|srcfile
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|read_ctf_save_cb
argument_list|,
operator|&
name|srctd
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|terminate
argument_list|(
literal|"No CTF data found in source file %s\n"
argument_list|,
name|srcfile
argument_list|)
expr_stmt|;
name|tmpname
operator|=
name|mktmpname
argument_list|(
name|destfile
argument_list|,
literal|".ctf"
argument_list|)
expr_stmt|;
name|write_ctf
argument_list|(
name|srctd
argument_list|,
name|destfile
argument_list|,
name|tmpname
argument_list|,
name|CTF_COMPRESS
operator||
name|keep_stabs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tmpname
argument_list|,
name|destfile
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|terminate
argument_list|(
literal|"Couldn't rename temp file %s to %s"
argument_list|,
name|tmpname
argument_list|,
name|destfile
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|tdata_free
argument_list|(
name|srctd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wq_init
parameter_list|(
name|workqueue_t
modifier|*
name|wq
parameter_list|,
name|int
name|nfiles
parameter_list|)
block|{
name|int
name|throttle
decl_stmt|,
name|nslots
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"CTFMERGE_MAX_SLOTS"
argument_list|)
condition|)
name|nslots
operator|=
name|atoi
argument_list|(
name|getenv
argument_list|(
literal|"CTFMERGE_MAX_SLOTS"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|nslots
operator|=
name|MERGE_PHASE1_MAX_SLOTS
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"CTFMERGE_PHASE1_BATCH_SIZE"
argument_list|)
condition|)
name|wq
operator|->
name|wq_maxbatchsz
operator|=
name|atoi
argument_list|(
name|getenv
argument_list|(
literal|"CTFMERGE_PHASE1_BATCH_SIZE"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|wq
operator|->
name|wq_maxbatchsz
operator|=
name|MERGE_PHASE1_BATCH_SIZE
expr_stmt|;
name|nslots
operator|=
name|MIN
argument_list|(
name|nslots
argument_list|,
operator|(
name|nfiles
operator|+
name|wq
operator|->
name|wq_maxbatchsz
operator|-
literal|1
operator|)
operator|/
name|wq
operator|->
name|wq_maxbatchsz
argument_list|)
expr_stmt|;
name|wq
operator|->
name|wq_wip
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|wip_t
argument_list|)
operator|*
name|nslots
argument_list|)
expr_stmt|;
name|wq
operator|->
name|wq_nwipslots
operator|=
name|nslots
expr_stmt|;
name|wq
operator|->
name|wq_nthreads
operator|=
name|MIN
argument_list|(
name|sysconf
argument_list|(
name|_SC_NPROCESSORS_ONLN
argument_list|)
operator|*
literal|3
operator|/
literal|2
argument_list|,
name|nslots
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"CTFMERGE_INPUT_THROTTLE"
argument_list|)
condition|)
name|throttle
operator|=
name|atoi
argument_list|(
name|getenv
argument_list|(
literal|"CTFMERGE_INPUT_THROTTLE"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|throttle
operator|=
name|MERGE_INPUT_THROTTLE_LEN
expr_stmt|;
name|wq
operator|->
name|wq_ithrottle
operator|=
name|throttle
operator|*
name|wq
operator|->
name|wq_nthreads
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"Using %d slots, %d threads\n"
argument_list|,
name|wq
operator|->
name|wq_nwipslots
argument_list|,
name|wq
operator|->
name|wq_nthreads
argument_list|)
expr_stmt|;
name|wq
operator|->
name|wq_next_batchid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nslots
condition|;
name|i
operator|++
control|)
block|{
name|pthread_mutex_init
argument_list|(
operator|&
name|wq
operator|->
name|wq_wip
index|[
name|i
index|]
operator|.
name|wip_lock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wq
operator|->
name|wq_wip
index|[
name|i
index|]
operator|.
name|wip_batchid
operator|=
name|wq
operator|->
name|wq_next_batchid
operator|++
expr_stmt|;
block|}
name|pthread_mutex_init
argument_list|(
operator|&
name|wq
operator|->
name|wq_queue_lock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wq
operator|->
name|wq_queue
operator|=
name|fifo_new
argument_list|()
expr_stmt|;
name|pthread_cond_init
argument_list|(
operator|&
name|wq
operator|->
name|wq_work_avail
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_cond_init
argument_list|(
operator|&
name|wq
operator|->
name|wq_work_removed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wq
operator|->
name|wq_ninqueue
operator|=
name|nfiles
expr_stmt|;
name|wq
operator|->
name|wq_nextpownum
operator|=
literal|0
expr_stmt|;
name|pthread_mutex_init
argument_list|(
operator|&
name|wq
operator|->
name|wq_donequeue_lock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wq
operator|->
name|wq_donequeue
operator|=
name|fifo_new
argument_list|()
expr_stmt|;
name|wq
operator|->
name|wq_lastdonebatch
operator|=
operator|-
literal|1
expr_stmt|;
name|pthread_cond_init
argument_list|(
operator|&
name|wq
operator|->
name|wq_done_cv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_cond_init
argument_list|(
operator|&
name|wq
operator|->
name|wq_alldone_cv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wq
operator|->
name|wq_alldone
operator|=
literal|0
expr_stmt|;
name|barrier_init
argument_list|(
operator|&
name|wq
operator|->
name|wq_bar1
argument_list|,
name|wq
operator|->
name|wq_nthreads
argument_list|)
expr_stmt|;
name|barrier_init
argument_list|(
operator|&
name|wq
operator|->
name|wq_bar2
argument_list|,
name|wq
operator|->
name|wq_nthreads
argument_list|)
expr_stmt|;
name|wq
operator|->
name|wq_nomorefiles
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_threads
parameter_list|(
name|workqueue_t
modifier|*
name|wq
parameter_list|)
block|{
name|pthread_t
name|thrid
decl_stmt|;
name|sigset_t
name|sets
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sets
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sets
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sets
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sets
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|pthread_sigmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|sets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wq
operator|->
name|wq_nthreads
condition|;
name|i
operator|++
control|)
block|{
name|pthread_create
argument_list|(
operator|&
name|thrid
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
call|(
modifier|*
call|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|worker_thread
argument_list|,
name|wq
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|handle_sig
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGQUIT
argument_list|,
name|handle_sig
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGTERM
argument_list|,
name|handle_sig
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handle_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|handle_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|handle_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pthread_sigmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|sets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|strcompare
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|char
modifier|*
name|s1
init|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|p1
operator|)
decl_stmt|;
name|char
modifier|*
name|s2
init|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|p2
operator|)
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|workqueue_t
name|wq
decl_stmt|;
name|tdata_t
modifier|*
name|mstrtd
decl_stmt|,
modifier|*
name|savetd
decl_stmt|;
name|char
modifier|*
name|uniqfile
init|=
name|NULL
decl_stmt|,
modifier|*
name|uniqlabel
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|withfile
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|label
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|ifiles
decl_stmt|,
modifier|*
modifier|*
name|tifiles
decl_stmt|;
name|int
name|verbose
init|=
literal|0
decl_stmt|,
name|docopy
init|=
literal|0
decl_stmt|;
name|int
name|write_fuzzy_match
init|=
literal|0
decl_stmt|;
name|int
name|keep_stabs
init|=
literal|0
decl_stmt|;
name|int
name|require_ctf
init|=
literal|0
decl_stmt|;
name|int
name|nifiles
decl_stmt|,
name|nielems
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|tidx
decl_stmt|,
name|err
decl_stmt|;
name|progname
operator|=
name|basename
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"CTFMERGE_DEBUG_LEVEL"
argument_list|)
condition|)
name|debug_level
operator|=
name|atoi
argument_list|(
name|getenv
argument_list|(
literal|"CTFMERGE_DEBUG_LEVEL"
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|":cd:D:fgl:L:o:tvw:s"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|docopy
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Uniquify against `uniqfile' */
name|uniqfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* Uniquify against label `uniqlabel' in `uniqfile' */
name|uniqlabel
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|write_fuzzy_match
operator|=
name|CTF_FUZZY_MATCH
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|keep_stabs
operator|=
name|CTF_KEEP_STABS
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Label merged types with `label' */
name|label
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Label merged types with getenv(`label`) */
if|if
condition|(
operator|(
name|label
operator|=
name|getenv
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|label
operator|=
name|CTF_DEFAULT_LABEL
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* Place merged types in CTF section in `outfile' */
name|outfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Insist *all* object files built from C have CTF */
name|require_ctf
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* More debugging information */
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Additive merge with data from `withfile' */
name|withfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* use the dynsym rather than the symtab */
name|dynsym
operator|=
name|CTF_USE_DYNSYM
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Validate arguments */
if|if
condition|(
name|docopy
condition|)
block|{
if|if
condition|(
name|uniqfile
operator|!=
name|NULL
operator|||
name|uniqlabel
operator|!=
name|NULL
operator|||
name|label
operator|!=
name|NULL
operator|||
name|outfile
operator|!=
name|NULL
operator|||
name|withfile
operator|!=
name|NULL
operator|||
name|dynsym
operator|!=
literal|0
condition|)
name|err
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|-
name|optind
operator|!=
literal|2
condition|)
name|err
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|uniqfile
operator|!=
name|NULL
operator|&&
name|withfile
operator|!=
name|NULL
condition|)
name|err
operator|++
expr_stmt|;
if|if
condition|(
name|uniqlabel
operator|!=
name|NULL
operator|&&
name|uniqfile
operator|==
name|NULL
condition|)
name|err
operator|++
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
name|NULL
operator|||
name|label
operator|==
name|NULL
condition|)
name|err
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|-
name|optind
operator|==
literal|0
condition|)
name|err
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getenv
argument_list|(
literal|"STRIPSTABS_KEEP_STABS"
argument_list|)
operator|!=
name|NULL
condition|)
name|keep_stabs
operator|=
name|CTF_KEEP_STABS
expr_stmt|;
if|if
condition|(
name|uniqfile
operator|&&
name|access
argument_list|(
name|uniqfile
argument_list|,
name|R_OK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Uniquification file %s couldn't be opened and "
literal|"will be ignored.\n"
argument_list|,
name|uniqfile
argument_list|)
expr_stmt|;
name|uniqfile
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|withfile
operator|&&
name|access
argument_list|(
name|withfile
argument_list|,
name|R_OK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"With file %s couldn't be opened and will be "
literal|"ignored.\n"
argument_list|,
name|withfile
argument_list|)
expr_stmt|;
name|withfile
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|outfile
operator|&&
name|access
argument_list|(
name|outfile
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
operator|!=
literal|0
condition|)
name|terminate
argument_list|(
literal|"Cannot open output file %s for r/w"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
comment|/* 	 * This is ugly, but we don't want to have to have a separate tool 	 * (yet) just for copying an ELF section with our specific requirements, 	 * so we shoe-horn a copier into ctfmerge. 	 */
if|if
condition|(
name|docopy
condition|)
block|{
name|copy_ctf_data
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|,
name|keep_stabs
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|set_terminate_cleanup
argument_list|(
name|terminate_cleanup
argument_list|)
expr_stmt|;
comment|/* Sort the input files and strip out duplicates */
name|nifiles
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|ifiles
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|nifiles
argument_list|)
expr_stmt|;
name|tifiles
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|nifiles
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nifiles
condition|;
name|i
operator|++
control|)
name|tifiles
index|[
name|i
index|]
operator|=
name|argv
index|[
name|optind
operator|+
name|i
index|]
expr_stmt|;
name|qsort
argument_list|(
name|tifiles
argument_list|,
name|nifiles
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|strcompare
argument_list|)
expr_stmt|;
name|ifiles
index|[
literal|0
index|]
operator|=
name|tifiles
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|tidx
operator|=
literal|1
init|;
name|tidx
operator|<
name|nifiles
condition|;
name|tidx
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ifiles
index|[
name|idx
index|]
argument_list|,
name|tifiles
index|[
name|tidx
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|ifiles
index|[
operator|++
name|idx
index|]
operator|=
name|tifiles
index|[
name|tidx
index|]
expr_stmt|;
block|}
name|nifiles
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
comment|/* Make sure they all exist */
if|if
condition|(
operator|(
name|nielems
operator|=
name|count_files
argument_list|(
name|ifiles
argument_list|,
name|nifiles
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|terminate
argument_list|(
literal|"Some input files were inaccessible\n"
argument_list|)
expr_stmt|;
comment|/* Prepare for the merge */
name|wq_init
argument_list|(
operator|&
name|wq
argument_list|,
name|nielems
argument_list|)
expr_stmt|;
name|start_threads
argument_list|(
operator|&
name|wq
argument_list|)
expr_stmt|;
comment|/* 	 * Start the merge 	 * 	 * We're reading everything from each of the object files, so we 	 * don't need to specify labels. 	 */
if|if
condition|(
name|read_ctf
argument_list|(
name|ifiles
argument_list|,
name|nifiles
argument_list|,
name|NULL
argument_list|,
name|merge_ctf_cb
argument_list|,
operator|&
name|wq
argument_list|,
name|require_ctf
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If we're verifying that C files have CTF, it's safe to 		 * assume that in this case, we're building only from assembly 		 * inputs. 		 */
if|if
condition|(
name|require_ctf
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|"No ctf sections found to merge\n"
argument_list|)
expr_stmt|;
block|}
name|pthread_mutex_lock
argument_list|(
operator|&
name|wq
operator|.
name|wq_queue_lock
argument_list|)
expr_stmt|;
name|wq
operator|.
name|wq_nomorefiles
operator|=
literal|1
expr_stmt|;
name|pthread_cond_broadcast
argument_list|(
operator|&
name|wq
operator|.
name|wq_work_avail
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|wq
operator|.
name|wq_queue_lock
argument_list|)
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|wq
operator|.
name|wq_queue_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|wq
operator|.
name|wq_alldone
operator|==
literal|0
condition|)
name|pthread_cond_wait
argument_list|(
operator|&
name|wq
operator|.
name|wq_alldone_cv
argument_list|,
operator|&
name|wq
operator|.
name|wq_queue_lock
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|wq
operator|.
name|wq_queue_lock
argument_list|)
expr_stmt|;
comment|/* 	 * All requested files have been merged, with the resulting tree in 	 * mstrtd.  savetd is the tree that will be placed into the output file. 	 * 	 * Regardless of whether we're doing a normal uniquification or an 	 * additive merge, we need a type tree that has been uniquified 	 * against uniqfile or withfile, as appropriate. 	 * 	 * If we're doing a uniquification, we stuff the resulting tree into 	 * outfile.  Otherwise, we add the tree to the tree already in withfile. 	 */
name|assert
argument_list|(
name|fifo_len
argument_list|(
name|wq
operator|.
name|wq_queue
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|mstrtd
operator|=
name|fifo_remove
argument_list|(
name|wq
operator|.
name|wq_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
name|debug_level
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"Statistics for td %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mstrtd
argument_list|)
expr_stmt|;
name|iidesc_stats
argument_list|(
name|mstrtd
operator|->
name|td_iihash
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uniqfile
operator|!=
name|NULL
operator|||
name|withfile
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|reffile
decl_stmt|,
modifier|*
name|reflabel
init|=
name|NULL
decl_stmt|;
name|tdata_t
modifier|*
name|reftd
decl_stmt|;
if|if
condition|(
name|uniqfile
operator|!=
name|NULL
condition|)
block|{
name|reffile
operator|=
name|uniqfile
expr_stmt|;
name|reflabel
operator|=
name|uniqlabel
expr_stmt|;
block|}
else|else
name|reffile
operator|=
name|withfile
expr_stmt|;
if|if
condition|(
name|read_ctf
argument_list|(
operator|&
name|reffile
argument_list|,
literal|1
argument_list|,
name|reflabel
argument_list|,
name|read_ctf_save_cb
argument_list|,
operator|&
name|reftd
argument_list|,
name|require_ctf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|terminate
argument_list|(
literal|"No CTF data found in reference file %s\n"
argument_list|,
name|reffile
argument_list|)
expr_stmt|;
block|}
name|savetd
operator|=
name|tdata_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|CTF_TYPE_ISCHILD
argument_list|(
name|reftd
operator|->
name|td_nextid
argument_list|)
condition|)
name|terminate
argument_list|(
literal|"No room for additional types in master\n"
argument_list|)
expr_stmt|;
name|savetd
operator|->
name|td_nextid
operator|=
name|withfile
condition|?
name|reftd
operator|->
name|td_nextid
else|:
name|CTF_INDEX_TO_TYPE
argument_list|(
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|merge_into_master
argument_list|(
name|mstrtd
argument_list|,
name|reftd
argument_list|,
name|savetd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tdata_label_add
argument_list|(
name|savetd
argument_list|,
name|label
argument_list|,
name|CTF_LABEL_LASTIDX
argument_list|)
expr_stmt|;
if|if
condition|(
name|withfile
condition|)
block|{
comment|/* 			 * savetd holds the new data to be added to the withfile 			 */
name|tdata_t
modifier|*
name|withtd
init|=
name|reftd
decl_stmt|;
name|tdata_merge
argument_list|(
name|withtd
argument_list|,
name|savetd
argument_list|)
expr_stmt|;
name|savetd
operator|=
name|withtd
expr_stmt|;
block|}
else|else
block|{
name|char
name|uniqname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|labelent_t
modifier|*
name|parle
decl_stmt|;
name|parle
operator|=
name|tdata_label_top
argument_list|(
name|reftd
argument_list|)
expr_stmt|;
name|savetd
operator|->
name|td_parlabel
operator|=
name|xstrdup
argument_list|(
name|parle
operator|->
name|le_name
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|uniqname
argument_list|,
name|reffile
argument_list|,
sizeof|sizeof
argument_list|(
name|uniqname
argument_list|)
argument_list|)
expr_stmt|;
name|uniqname
index|[
name|MAXPATHLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|savetd
operator|->
name|td_parname
operator|=
name|xstrdup
argument_list|(
name|basename
argument_list|(
name|uniqname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * No post processing.  Write the merged tree as-is into the 		 * output file. 		 */
name|tdata_label_free
argument_list|(
name|mstrtd
argument_list|)
expr_stmt|;
name|tdata_label_add
argument_list|(
name|mstrtd
argument_list|,
name|label
argument_list|,
name|CTF_LABEL_LASTIDX
argument_list|)
expr_stmt|;
name|savetd
operator|=
name|mstrtd
expr_stmt|;
block|}
name|tmpname
operator|=
name|mktmpname
argument_list|(
name|outfile
argument_list|,
literal|".ctf"
argument_list|)
expr_stmt|;
name|write_ctf
argument_list|(
name|savetd
argument_list|,
name|outfile
argument_list|,
name|tmpname
argument_list|,
name|CTF_COMPRESS
operator||
name|write_fuzzy_match
operator||
name|dynsym
operator||
name|keep_stabs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tmpname
argument_list|,
name|outfile
argument_list|)
operator|!=
literal|0
condition|)
name|terminate
argument_list|(
literal|"Couldn't rename output temp file %s"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

