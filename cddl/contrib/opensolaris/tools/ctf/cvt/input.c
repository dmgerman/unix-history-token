begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * Routines for retrieving CTF data from a .SUNW_ctf ELF section  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<gelf.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"ctftools.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_typedef
typedef|typedef
name|int
name|read_cb_f
parameter_list|(
name|tdata_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * Return the source types that the object was generated from.  */
end_comment

begin_function
name|source_types_t
name|built_source_types
parameter_list|(
name|Elf
modifier|*
name|elf
parameter_list|,
name|char
specifier|const
modifier|*
name|file
parameter_list|)
block|{
name|source_types_t
name|types
init|=
name|SOURCE_NONE
decl_stmt|;
name|symit_data_t
modifier|*
name|si
decl_stmt|;
if|if
condition|(
operator|(
name|si
operator|=
name|symit_new
argument_list|(
name|elf
argument_list|,
name|file
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|SOURCE_NONE
operator|)
return|;
while|while
condition|(
name|symit_next
argument_list|(
name|si
argument_list|,
name|STT_FILE
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|symit_name
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
operator|||
name|name
index|[
name|len
operator|-
literal|2
index|]
operator|!=
literal|'.'
condition|)
block|{
name|types
operator||=
name|SOURCE_UNKNOWN
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|name
index|[
name|len
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'c'
case|:
name|types
operator||=
name|SOURCE_C
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* ignore */
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|types
operator||=
name|SOURCE_S
expr_stmt|;
break|break;
default|default:
name|types
operator||=
name|SOURCE_UNKNOWN
expr_stmt|;
block|}
block|}
name|symit_free
argument_list|(
name|si
argument_list|)
expr_stmt|;
return|return
operator|(
name|types
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_file
parameter_list|(
name|Elf
modifier|*
name|elf
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|read_cb_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|require_ctf
parameter_list|)
block|{
name|Elf_Scn
modifier|*
name|ctfscn
decl_stmt|;
name|Elf_Data
modifier|*
name|ctfdata
init|=
name|NULL
decl_stmt|;
name|symit_data_t
modifier|*
name|si
init|=
name|NULL
decl_stmt|;
name|int
name|ctfscnidx
decl_stmt|;
name|tdata_t
modifier|*
name|td
decl_stmt|;
if|if
condition|(
operator|(
name|ctfscnidx
operator|=
name|findelfsecidx
argument_list|(
name|elf
argument_list|,
name|file
argument_list|,
literal|".SUNW_ctf"
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|require_ctf
operator|&&
operator|(
name|built_source_types
argument_list|(
name|elf
argument_list|,
name|file
argument_list|)
operator|&
name|SOURCE_C
operator|)
condition|)
block|{
name|terminate
argument_list|(
literal|"Input file %s was partially built from "
literal|"C sources, but no CTF data was present\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ctfscn
operator|=
name|elf_getscn
argument_list|(
name|elf
argument_list|,
name|ctfscnidx
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|ctfdata
operator|=
name|elf_getdata
argument_list|(
name|ctfscn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|elfterminate
argument_list|(
name|file
argument_list|,
literal|"Cannot read CTF section"
argument_list|)
expr_stmt|;
comment|/* Reconstruction of type tree */
if|if
condition|(
operator|(
name|si
operator|=
name|symit_new
argument_list|(
name|elf
argument_list|,
name|file
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"%s has no symbol table - skipping"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|td
operator|=
name|ctf_load
argument_list|(
name|file
argument_list|,
name|ctfdata
operator|->
name|d_buf
argument_list|,
name|ctfdata
operator|->
name|d_size
argument_list|,
name|si
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|tdata_build_hashes
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|symit_free
argument_list|(
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|func
argument_list|(
name|td
argument_list|,
name|file
argument_list|,
name|arg
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_archive
parameter_list|(
name|int
name|fd
parameter_list|,
name|Elf
modifier|*
name|elf
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|read_cb_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|require_ctf
parameter_list|)
block|{
name|Elf
modifier|*
name|melf
decl_stmt|;
name|Elf_Cmd
name|cmd
init|=
name|ELF_C_READ
decl_stmt|;
name|Elf_Arhdr
modifier|*
name|arh
decl_stmt|;
name|int
name|secnum
init|=
literal|1
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|melf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|cmd
argument_list|,
name|elf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|arh
operator|=
name|elf_getarhdr
argument_list|(
name|melf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elfterminate
argument_list|(
name|file
argument_list|,
literal|"Can't get archive header for "
literal|"member %d"
argument_list|,
name|secnum
argument_list|)
expr_stmt|;
block|}
comment|/* skip special sections - their names begin with "/" */
if|if
condition|(
operator|*
name|arh
operator|->
name|ar_name
operator|!=
literal|'/'
condition|)
block|{
name|size_t
name|memlen
init|=
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|arh
operator|->
name|ar_name
argument_list|)
operator|+
literal|1
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|memname
init|=
name|xmalloc
argument_list|(
name|memlen
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|memname
argument_list|,
name|memlen
argument_list|,
literal|"%s(%s)"
argument_list|,
name|file
argument_list|,
name|arh
operator|->
name|ar_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|elf_kind
argument_list|(
name|melf
argument_list|)
condition|)
block|{
case|case
name|ELF_K_AR
case|:
name|rc
operator|=
name|read_archive
argument_list|(
name|fd
argument_list|,
name|melf
argument_list|,
name|memname
argument_list|,
name|label
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|require_ctf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELF_K_ELF
case|:
name|rc
operator|=
name|read_file
argument_list|(
name|melf
argument_list|,
name|memname
argument_list|,
name|label
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|require_ctf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|terminate
argument_list|(
literal|"%s: Unknown elf kind %d\n"
argument_list|,
name|memname
argument_list|,
name|elf_kind
argument_list|(
name|melf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|memname
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
name|elf_next
argument_list|(
name|melf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|melf
argument_list|)
expr_stmt|;
name|secnum
operator|++
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
else|else
name|found
operator|+=
name|rc
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_ctf_common
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|read_cb_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|require_ctf
parameter_list|)
block|{
name|Elf
modifier|*
name|elf
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Reading %s (label %s)\n"
argument_list|,
name|file
argument_list|,
operator|(
name|label
condition|?
name|label
else|:
literal|"NONE"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_version
argument_list|(
name|EV_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|terminate
argument_list|(
literal|"%s: Cannot open for reading"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|ELF_C_READ
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|elfterminate
argument_list|(
name|file
argument_list|,
literal|"Cannot read"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|elf_kind
argument_list|(
name|elf
argument_list|)
condition|)
block|{
case|case
name|ELF_K_AR
case|:
name|found
operator|=
name|read_archive
argument_list|(
name|fd
argument_list|,
name|elf
argument_list|,
name|file
argument_list|,
name|label
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|require_ctf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELF_K_ELF
case|:
name|found
operator|=
name|read_file
argument_list|(
name|elf
argument_list|,
name|file
argument_list|,
name|label
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|require_ctf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|terminate
argument_list|(
literal|"%s: Unknown elf kind %d\n"
argument_list|,
name|file
argument_list|,
name|elf_kind
argument_list|(
name|elf
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|elf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|read_ctf_save_cb
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|char
modifier|*
name|name
name|__unused
parameter_list|,
name|void
modifier|*
name|retp
parameter_list|)
block|{
name|tdata_t
modifier|*
modifier|*
name|tdp
init|=
name|retp
decl_stmt|;
operator|*
name|tdp
operator|=
name|td
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|read_ctf
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|,
name|int
name|n
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|read_cb_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|require_ctf
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|found
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|read_ctf_common
argument_list|(
name|files
index|[
name|i
index|]
argument_list|,
name|label
argument_list|,
name|func
argument_list|,
name|private
argument_list|,
name|require_ctf
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|found
operator|+=
name|rc
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|count_archive
parameter_list|(
name|int
name|fd
parameter_list|,
name|Elf
modifier|*
name|elf
parameter_list|,
name|char
modifier|*
name|file
parameter_list|)
block|{
name|Elf
modifier|*
name|melf
decl_stmt|;
name|Elf_Cmd
name|cmd
init|=
name|ELF_C_READ
decl_stmt|;
name|Elf_Arhdr
modifier|*
name|arh
decl_stmt|;
name|int
name|nfiles
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|melf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|cmd
argument_list|,
name|elf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|arh
operator|=
name|elf_getarhdr
argument_list|(
name|melf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Can't process input archive %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|arh
operator|->
name|ar_name
operator|!=
literal|'/'
condition|)
name|nfiles
operator|++
expr_stmt|;
name|cmd
operator|=
name|elf_next
argument_list|(
name|melf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|melf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|>
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|nfiles
operator|)
return|;
block|}
end_function

begin_function
name|int
name|count_files
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|nfiles
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|Elf
modifier|*
name|elf
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|rc
decl_stmt|,
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|elf_version
argument_list|(
name|EV_CURRENT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|file
init|=
name|files
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Can't read input file %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|elf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|ELF_C_READ
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Can't open input file %s: %s\n"
argument_list|,
name|file
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|elf_kind
argument_list|(
name|elf
argument_list|)
condition|)
block|{
case|case
name|ELF_K_AR
case|:
if|if
condition|(
operator|(
name|rc
operator|=
name|count_archive
argument_list|(
name|fd
argument_list|,
name|elf
argument_list|,
name|file
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
operator|++
expr_stmt|;
else|else
name|nfiles
operator|+=
name|rc
expr_stmt|;
break|break;
case|case
name|ELF_K_ELF
case|:
name|nfiles
operator|++
expr_stmt|;
break|break;
default|default:
name|warning
argument_list|(
literal|"Input file %s is corrupt\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|elf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|>
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|debug
argument_list|(
literal|2
argument_list|,
literal|"Found %d files in %d input files\n"
argument_list|,
name|nfiles
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|nfiles
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|symit_data
block|{
name|GElf_Shdr
name|si_shdr
decl_stmt|;
name|Elf_Data
modifier|*
name|si_symd
decl_stmt|;
name|Elf_Data
modifier|*
name|si_strd
decl_stmt|;
name|GElf_Sym
name|si_cursym
decl_stmt|;
name|char
modifier|*
name|si_curname
decl_stmt|;
name|char
modifier|*
name|si_curfile
decl_stmt|;
name|int
name|si_nument
decl_stmt|;
name|int
name|si_next
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|symit_data_t
modifier|*
name|symit_new
parameter_list|(
name|Elf
modifier|*
name|elf
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|symit_data_t
modifier|*
name|si
decl_stmt|;
name|Elf_Scn
modifier|*
name|scn
decl_stmt|;
name|int
name|symtabidx
decl_stmt|;
if|if
condition|(
operator|(
name|symtabidx
operator|=
name|findelfsecidx
argument_list|(
name|elf
argument_list|,
name|file
argument_list|,
literal|".symtab"
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|si
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|symit_data_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scn
operator|=
name|elf_getscn
argument_list|(
name|elf
argument_list|,
name|symtabidx
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|si
operator|->
name|si_shdr
argument_list|)
operator|==
name|NULL
operator|||
operator|(
name|si
operator|->
name|si_symd
operator|=
name|elf_getdata
argument_list|(
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|elfterminate
argument_list|(
name|file
argument_list|,
literal|"Cannot read .symtab"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scn
operator|=
name|elf_getscn
argument_list|(
name|elf
argument_list|,
name|si
operator|->
name|si_shdr
operator|.
name|sh_link
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|si
operator|->
name|si_strd
operator|=
name|elf_getdata
argument_list|(
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|elfterminate
argument_list|(
name|file
argument_list|,
literal|"Cannot read strings for .symtab"
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_nument
operator|=
name|si
operator|->
name|si_shdr
operator|.
name|sh_size
operator|/
name|si
operator|->
name|si_shdr
operator|.
name|sh_entsize
expr_stmt|;
return|return
operator|(
name|si
operator|)
return|;
block|}
end_function

begin_function
name|void
name|symit_free
parameter_list|(
name|symit_data_t
modifier|*
name|si
parameter_list|)
block|{
name|free
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|symit_reset
parameter_list|(
name|symit_data_t
modifier|*
name|si
parameter_list|)
block|{
name|si
operator|->
name|si_next
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|symit_curfile
parameter_list|(
name|symit_data_t
modifier|*
name|si
parameter_list|)
block|{
return|return
operator|(
name|si
operator|->
name|si_curfile
operator|)
return|;
block|}
end_function

begin_function
name|GElf_Sym
modifier|*
name|symit_next
parameter_list|(
name|symit_data_t
modifier|*
name|si
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|GElf_Sym
name|sym
decl_stmt|;
name|int
name|check_sym
init|=
operator|(
name|type
operator|==
name|STT_OBJECT
operator|||
name|type
operator|==
name|STT_FUNC
operator|)
decl_stmt|;
for|for
control|(
init|;
name|si
operator|->
name|si_next
operator|<
name|si
operator|->
name|si_nument
condition|;
name|si
operator|->
name|si_next
operator|++
control|)
block|{
name|gelf_getsym
argument_list|(
name|si
operator|->
name|si_symd
argument_list|,
name|si
operator|->
name|si_next
argument_list|,
operator|&
name|si
operator|->
name|si_cursym
argument_list|)
expr_stmt|;
name|gelf_getsym
argument_list|(
name|si
operator|->
name|si_symd
argument_list|,
name|si
operator|->
name|si_next
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_curname
operator|=
operator|(
name|caddr_t
operator|)
name|si
operator|->
name|si_strd
operator|->
name|d_buf
operator|+
name|sym
operator|.
name|st_name
expr_stmt|;
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_FILE
condition|)
name|si
operator|->
name|si_curfile
operator|=
name|si
operator|->
name|si_curname
expr_stmt|;
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|!=
name|type
operator|||
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
continue|continue;
if|if
condition|(
name|check_sym
operator|&&
name|ignore_symbol
argument_list|(
operator|&
name|sym
argument_list|,
name|si
operator|->
name|si_curname
argument_list|)
condition|)
continue|continue;
name|si
operator|->
name|si_next
operator|++
expr_stmt|;
return|return
operator|(
operator|&
name|si
operator|->
name|si_cursym
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|symit_name
parameter_list|(
name|symit_data_t
modifier|*
name|si
parameter_list|)
block|{
return|return
operator|(
name|si
operator|->
name|si_curname
operator|)
return|;
block|}
end_function

end_unit

