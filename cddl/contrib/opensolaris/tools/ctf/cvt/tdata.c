begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * Routines for manipulating tdesc and tdata structures  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|"ctftools.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"traverse.h"
end_include

begin_comment
comment|/*  * The layout hash is used during the equivalency checking.  We have a node in  * the child graph that may be equivalent to a node in the parent graph.  To  * find the corresponding node (if any) in the parent, we need a quick way to  * get to all nodes in the parent that look like the node in the child.  Since a  * large number of nodes don't have names, we need to incorporate the layout of  * the node into the hash.  If we don't, we'll end up with the vast majority of  * nodes in bucket zero, with one or two nodes in each of the remaining buckets.  *  * There are a couple of constraints, both of which concern forward  * declarations.  Recall that a forward declaration tdesc is equivalent to a  * tdesc that actually defines the structure or union.  As such, we cannot  * incorporate anything into the hash for a named struct or union node that  * couldn't be found by looking at the forward, and vice versa.  */
end_comment

begin_function
name|int
name|tdesc_layouthash
parameter_list|(
name|int
name|nbuckets
parameter_list|,
name|void
modifier|*
name|node
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp
init|=
name|node
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|ulong_t
name|h
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_name
condition|)
name|name
operator|=
name|tdp
operator|->
name|t_name
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|tdp
operator|->
name|t_type
condition|)
block|{
case|case
name|POINTER
case|:
case|case
name|TYPEDEF
case|:
case|case
name|VOLATILE
case|:
case|case
name|CONST
case|:
case|case
name|RESTRICT
case|:
name|name
operator|=
name|tdp
operator|->
name|t_tdesc
operator|->
name|t_name
expr_stmt|;
break|break;
case|case
name|FUNCTION
case|:
name|h
operator|=
name|tdp
operator|->
name|t_fndef
operator|->
name|fn_nargs
operator|+
name|tdp
operator|->
name|t_fndef
operator|->
name|fn_vargs
expr_stmt|;
name|name
operator|=
name|tdp
operator|->
name|t_fndef
operator|->
name|fn_ret
operator|->
name|t_name
expr_stmt|;
break|break;
case|case
name|ARRAY
case|:
name|h
operator|=
name|tdp
operator|->
name|t_ardef
operator|->
name|ad_nelems
expr_stmt|;
name|name
operator|=
name|tdp
operator|->
name|t_ardef
operator|->
name|ad_contents
operator|->
name|t_name
expr_stmt|;
break|break;
case|case
name|STRUCT
case|:
case|case
name|UNION
case|:
comment|/* 			 * Unnamed structures, which cannot have forward 			 * declarations pointing to them.  We can therefore 			 * incorporate the name of the first member into 			 * the hash value. 			 */
name|name
operator|=
name|tdp
operator|->
name|t_members
operator|->
name|ml_name
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
comment|/* Use the first element in the hash value */
name|name
operator|=
name|tdp
operator|->
name|t_emem
operator|->
name|el_name
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Intrinsics, forwards, and typedefs all have 			 * names. 			 */
name|warning
argument_list|(
literal|"Unexpected unnamed %d tdesc (ID %d)\n"
argument_list|,
name|tdp
operator|->
name|t_type
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
condition|)
return|return
operator|(
name|hash_name
argument_list|(
name|nbuckets
argument_list|,
name|name
argument_list|)
operator|)
return|;
return|return
operator|(
name|h
operator|%
name|nbuckets
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tdesc_layoutcmp
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp1
init|=
name|arg1
decl_stmt|,
modifier|*
name|tdp2
init|=
name|arg2
decl_stmt|;
if|if
condition|(
name|tdp1
operator|->
name|t_name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tdp2
operator|->
name|t_name
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tdp2
operator|->
name|t_name
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|strcmp
argument_list|(
name|tdp1
operator|->
name|t_name
argument_list|,
name|tdp2
operator|->
name|t_name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tdesc_idhash
parameter_list|(
name|int
name|nbuckets
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp
init|=
name|data
decl_stmt|;
return|return
operator|(
name|tdp
operator|->
name|t_id
operator|%
name|nbuckets
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tdesc_idcmp
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp1
init|=
name|arg1
decl_stmt|,
modifier|*
name|tdp2
init|=
name|arg2
decl_stmt|;
if|if
condition|(
name|tdp1
operator|->
name|t_id
operator|==
name|tdp2
operator|->
name|t_id
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|tdp1
operator|->
name|t_id
operator|>
name|tdp2
operator|->
name|t_id
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tdesc_namehash
parameter_list|(
name|int
name|nbuckets
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp
init|=
name|data
decl_stmt|;
name|ulong_t
name|h
decl_stmt|,
name|g
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_name
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|h
operator|=
literal|0
operator|,
name|c
operator|=
name|tdp
operator|->
name|t_name
init|;
operator|*
name|c
condition|;
name|c
operator|++
control|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
operator|*
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
operator|(
name|h
operator|&
literal|0xf0000000
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|h
operator|^=
operator|(
name|g
operator|>>
literal|24
operator|)
expr_stmt|;
name|h
operator|^=
name|g
expr_stmt|;
block|}
block|}
return|return
operator|(
name|h
operator|%
name|nbuckets
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tdesc_namecmp
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp1
init|=
name|arg1
decl_stmt|,
modifier|*
name|tdp2
init|=
name|arg2
decl_stmt|;
return|return
operator|(
operator|!
name|streq
argument_list|(
name|tdp1
operator|->
name|t_name
argument_list|,
name|tdp2
operator|->
name|t_name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
name|int
name|tdesc_print
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp
init|=
name|data
decl_stmt|;
name|printf
argument_list|(
literal|"%7d %s\n"
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|,
name|tdesc_name
argument_list|(
name|tdp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_intr
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|free
argument_list|(
name|tdp
operator|->
name|t_intr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_ardef
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|free
argument_list|(
name|tdp
operator|->
name|t_ardef
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_mlist
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|mlist_t
modifier|*
name|ml
init|=
name|tdp
operator|->
name|t_members
decl_stmt|;
name|mlist_t
modifier|*
name|oml
decl_stmt|;
while|while
condition|(
name|ml
condition|)
block|{
name|oml
operator|=
name|ml
expr_stmt|;
name|ml
operator|=
name|ml
operator|->
name|ml_next
expr_stmt|;
if|if
condition|(
name|oml
operator|->
name|ml_name
condition|)
name|free
argument_list|(
name|oml
operator|->
name|ml_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oml
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_elist
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|elist_t
modifier|*
name|el
init|=
name|tdp
operator|->
name|t_emem
decl_stmt|;
name|elist_t
modifier|*
name|oel
decl_stmt|;
while|while
condition|(
name|el
condition|)
block|{
name|oel
operator|=
name|el
expr_stmt|;
name|el
operator|=
name|el
operator|->
name|el_next
expr_stmt|;
if|if
condition|(
name|oel
operator|->
name|el_name
condition|)
name|free
argument_list|(
name|oel
operator|->
name|el_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|free_cbs
index|[]
function_decl|)
parameter_list|(
name|tdesc_t
modifier|*
parameter_list|)
init|=
block|{
name|NULL
operator|,
function_decl|free_intr
operator|,
function_decl|NULL
operator|,
function_decl|free_ardef
operator|,
function_decl|NULL
operator|,
function_decl|free_mlist
operator|,
function_decl|free_mlist
operator|,
function_decl|free_elist
operator|,
function_decl|NULL
operator|,
function_decl|NULL
operator|,
function_decl|NULL
operator|,
function_decl|NULL
operator|,
function_decl|NULL
operator|,
function_decl|NULL
end_function_decl

begin_comment
unit|};
comment|/*ARGSUSED1*/
end_comment

begin_function
specifier|static
name|int
name|tdesc_free_cb
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
if|if
condition|(
name|tdp
operator|->
name|t_name
condition|)
name|free
argument_list|(
name|tdp
operator|->
name|t_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_cbs
index|[
name|tdp
operator|->
name|t_type
index|]
condition|)
name|free_cbs
index|[
name|tdp
operator|->
name|t_type
index|]
operator|(
name|tdp
operator|)
expr_stmt|;
name|free
argument_list|(
name|tdp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tdesc_free
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|tdesc_free_cb
argument_list|(
name|tdp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdata_label_cmp
parameter_list|(
name|labelent_t
modifier|*
name|le1
parameter_list|,
name|labelent_t
modifier|*
name|le2
parameter_list|)
block|{
return|return
operator|(
name|le1
operator|->
name|le_idx
operator|-
name|le2
operator|->
name|le_idx
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tdata_label_add
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|labelent_t
modifier|*
name|le
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|le
argument_list|)
argument_list|)
decl_stmt|;
name|le
operator|->
name|le_name
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|le
operator|->
name|le_idx
operator|=
operator|(
name|idx
operator|==
operator|-
literal|1
condition|?
name|td
operator|->
name|td_nextid
operator|-
literal|1
else|:
name|idx
operator|)
expr_stmt|;
name|slist_add
argument_list|(
operator|&
name|td
operator|->
name|td_labels
argument_list|,
name|le
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|tdata_label_cmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdata_label_top_cb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|labelent_t
modifier|*
name|le
init|=
name|data
decl_stmt|;
name|labelent_t
modifier|*
modifier|*
name|topp
init|=
name|arg
decl_stmt|;
operator|*
name|topp
operator|=
name|le
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|labelent_t
modifier|*
name|tdata_label_top
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|)
block|{
name|labelent_t
modifier|*
name|top
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|list_iter
argument_list|(
name|td
operator|->
name|td_labels
argument_list|,
name|tdata_label_top_cb
argument_list|,
operator|&
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdata_label_find_cb
parameter_list|(
name|labelent_t
modifier|*
name|le
parameter_list|,
name|labelent_t
modifier|*
name|tmpl
parameter_list|)
block|{
return|return
operator|(
name|streq
argument_list|(
name|le
operator|->
name|le_name
argument_list|,
name|tmpl
operator|->
name|le_name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tdata_label_find
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|char
modifier|*
name|label
parameter_list|)
block|{
name|labelent_t
name|let
decl_stmt|;
name|labelent_t
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|label
argument_list|,
literal|"BASE"
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|(
name|labelent_t
operator|*
operator|)
name|list_first
argument_list|(
name|td
operator|->
name|td_labels
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
condition|?
name|ret
operator|->
name|le_idx
else|:
operator|-
literal|1
operator|)
return|;
block|}
name|let
operator|.
name|le_name
operator|=
name|label
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ret
operator|=
operator|(
name|labelent_t
operator|*
operator|)
name|list_find
argument_list|(
name|td
operator|->
name|td_labels
argument_list|,
operator|&
name|let
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|tdata_label_find_cb
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|ret
operator|->
name|le_idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdata_label_newmax_cb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|labelent_t
modifier|*
name|le
init|=
name|data
decl_stmt|;
name|int
modifier|*
name|newmaxp
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|le
operator|->
name|le_idx
operator|>
operator|*
name|newmaxp
condition|)
block|{
name|le
operator|->
name|le_idx
operator|=
operator|*
name|newmaxp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tdata_label_newmax
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|int
name|newmax
parameter_list|)
block|{
operator|(
name|void
operator|)
name|list_iter
argument_list|(
name|td
operator|->
name|td_labels
argument_list|,
name|tdata_label_newmax_cb
argument_list|,
operator|&
name|newmax
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
specifier|static
name|void
name|tdata_label_free_cb
parameter_list|(
name|labelent_t
modifier|*
name|le
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
if|if
condition|(
name|le
operator|->
name|le_name
condition|)
name|free
argument_list|(
name|le
operator|->
name|le_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|le
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tdata_label_free
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|)
block|{
name|list_free
argument_list|(
name|td
operator|->
name|td_labels
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|tdata_label_free_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_labels
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|tdata_t
modifier|*
name|tdata_new
parameter_list|(
name|void
parameter_list|)
block|{
name|tdata_t
modifier|*
name|new
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdata_t
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|td_layouthash
operator|=
name|hash_new
argument_list|(
name|TDATA_LAYOUT_HASH_SIZE
argument_list|,
name|tdesc_layouthash
argument_list|,
name|tdesc_layoutcmp
argument_list|)
expr_stmt|;
name|new
operator|->
name|td_idhash
operator|=
name|hash_new
argument_list|(
name|TDATA_ID_HASH_SIZE
argument_list|,
name|tdesc_idhash
argument_list|,
name|tdesc_idcmp
argument_list|)
expr_stmt|;
comment|/* 	 * This is also traversed as a list, but amortized O(1) 	 * lookup massively impacts part of the merge phase, so 	 * we store the iidescs as a hash. 	 */
name|new
operator|->
name|td_iihash
operator|=
name|hash_new
argument_list|(
name|IIDESC_HASH_SIZE
argument_list|,
name|iidesc_hash
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|->
name|td_nextid
operator|=
literal|1
expr_stmt|;
name|new
operator|->
name|td_curvgen
operator|=
literal|1
expr_stmt|;
name|pthread_mutex_init
argument_list|(
operator|&
name|new
operator|->
name|td_mergelock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tdata_free
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|)
block|{
name|hash_free
argument_list|(
name|td
operator|->
name|td_iihash
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|iidesc_free
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hash_free
argument_list|(
name|td
operator|->
name|td_layouthash
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|tdesc_free_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hash_free
argument_list|(
name|td
operator|->
name|td_idhash
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_free
argument_list|(
name|td
operator|->
name|td_fwdlist
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tdata_label_free
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|td
operator|->
name|td_parlabel
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|td
operator|->
name|td_parname
argument_list|)
expr_stmt|;
name|pthread_mutex_destroy
argument_list|(
operator|&
name|td
operator|->
name|td_mergelock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
specifier|static
name|int
name|build_hashes
parameter_list|(
name|tdesc_t
modifier|*
name|ctdp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|ctdpp
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|tdata_t
modifier|*
name|td
init|=
name|private
decl_stmt|;
name|hash_add
argument_list|(
name|td
operator|->
name|td_idhash
argument_list|,
name|ctdp
argument_list|)
expr_stmt|;
name|hash_add
argument_list|(
name|td
operator|->
name|td_layouthash
argument_list|,
name|ctdp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|tdtrav_cb_f
name|build_hashes_cbs
index|[]
init|=
block|{
name|NULL
block|,
name|build_hashes
block|,
comment|/* intrinsic */
name|build_hashes
block|,
comment|/* pointer */
name|build_hashes
block|,
comment|/* array */
name|build_hashes
block|,
comment|/* function */
name|build_hashes
block|,
comment|/* struct */
name|build_hashes
block|,
comment|/* union */
name|build_hashes
block|,
comment|/* enum */
name|build_hashes
block|,
comment|/* forward */
name|build_hashes
block|,
comment|/* typedef */
name|tdtrav_assert
block|,
comment|/* typedef_unres */
name|build_hashes
block|,
comment|/* volatile */
name|build_hashes
block|,
comment|/* const */
name|build_hashes
comment|/* restrict */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tdata_build_hashes_common
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|hash_t
modifier|*
name|hash
parameter_list|)
block|{
operator|(
name|void
operator|)
name|iitraverse_hash
argument_list|(
name|hash
argument_list|,
operator|&
name|td
operator|->
name|td_curvgen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|build_hashes_cbs
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tdata_build_hashes
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|)
block|{
name|tdata_build_hashes_common
argument_list|(
name|td
argument_list|,
name|td
operator|->
name|td_iihash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Merge td2 into td1.  td2 is destroyed by the merge */
end_comment

begin_function
name|void
name|tdata_merge
parameter_list|(
name|tdata_t
modifier|*
name|td1
parameter_list|,
name|tdata_t
modifier|*
name|td2
parameter_list|)
block|{
name|td1
operator|->
name|td_curemark
operator|=
name|MAX
argument_list|(
name|td1
operator|->
name|td_curemark
argument_list|,
name|td2
operator|->
name|td_curemark
argument_list|)
expr_stmt|;
name|td1
operator|->
name|td_curvgen
operator|=
name|MAX
argument_list|(
name|td1
operator|->
name|td_curvgen
argument_list|,
name|td2
operator|->
name|td_curvgen
argument_list|)
expr_stmt|;
name|td1
operator|->
name|td_nextid
operator|=
name|MAX
argument_list|(
name|td1
operator|->
name|td_nextid
argument_list|,
name|td2
operator|->
name|td_nextid
argument_list|)
expr_stmt|;
name|hash_merge
argument_list|(
name|td1
operator|->
name|td_iihash
argument_list|,
name|td2
operator|->
name|td_iihash
argument_list|)
expr_stmt|;
comment|/* Add td2's type tree to the hashes */
name|tdata_build_hashes_common
argument_list|(
name|td1
argument_list|,
name|td2
operator|->
name|td_iihash
argument_list|)
expr_stmt|;
name|list_concat
argument_list|(
operator|&
name|td1
operator|->
name|td_fwdlist
argument_list|,
name|td2
operator|->
name|td_fwdlist
argument_list|)
expr_stmt|;
name|td2
operator|->
name|td_fwdlist
operator|=
name|NULL
expr_stmt|;
name|slist_merge
argument_list|(
operator|&
name|td1
operator|->
name|td_labels
argument_list|,
name|td2
operator|->
name|td_labels
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|tdata_label_cmp
argument_list|)
expr_stmt|;
name|td2
operator|->
name|td_labels
operator|=
name|NULL
expr_stmt|;
comment|/* free the td2 hashes (data is now part of td1) */
name|hash_free
argument_list|(
name|td2
operator|->
name|td_layouthash
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|td2
operator|->
name|td_layouthash
operator|=
name|NULL
expr_stmt|;
name|hash_free
argument_list|(
name|td2
operator|->
name|td_iihash
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|td2
operator|->
name|td_iihash
operator|=
name|NULL
expr_stmt|;
name|tdata_free
argument_list|(
name|td2
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

