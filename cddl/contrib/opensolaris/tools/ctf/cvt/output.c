begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * Routines for preparing tdata trees for conversion into CTF data, and  * for placing the resulting data into an output file.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libelf.h>
end_include

begin_include
include|#
directive|include
file|<gelf.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"ctftools.h"
end_include

begin_include
include|#
directive|include
file|"list.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"traverse.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_typedef
typedef|typedef
struct|struct
name|iidesc_match
block|{
name|int
name|iim_fuzzy
decl_stmt|;
name|iidesc_t
modifier|*
name|iim_ret
decl_stmt|;
name|char
modifier|*
name|iim_name
decl_stmt|;
name|char
modifier|*
name|iim_file
decl_stmt|;
name|uchar_t
name|iim_bind
decl_stmt|;
block|}
name|iidesc_match_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|burst_iitypes
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|iidesc_t
modifier|*
name|ii
init|=
name|data
decl_stmt|;
name|iiburst_t
modifier|*
name|iiburst
init|=
name|arg
decl_stmt|;
switch|switch
condition|(
name|ii
operator|->
name|ii_type
condition|)
block|{
case|case
name|II_GFUN
case|:
case|case
name|II_SFUN
case|:
case|case
name|II_GVAR
case|:
case|case
name|II_SVAR
case|:
if|if
condition|(
operator|!
operator|(
name|ii
operator|->
name|ii_flags
operator|&
name|IIDESC_F_USED
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
break|break;
block|}
name|ii
operator|->
name|ii_dtype
operator|->
name|t_flags
operator||=
name|TDESC_F_ISROOT
expr_stmt|;
operator|(
name|void
operator|)
name|iitraverse_td
argument_list|(
name|ii
argument_list|,
name|iiburst
operator|->
name|iib_tdtd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
specifier|static
name|int
name|save_type_by_id
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|tdpp
name|__unused
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|iiburst_t
modifier|*
name|iiburst
init|=
name|private
decl_stmt|;
comment|/* 	 * Doing this on every node is horribly inefficient, but given that 	 * we may be suppressing some types, we can't trust nextid in the 	 * tdata_t. 	 */
if|if
condition|(
name|tdp
operator|->
name|t_id
operator|>
name|iiburst
operator|->
name|iib_maxtypeid
condition|)
name|iiburst
operator|->
name|iib_maxtypeid
operator|=
name|tdp
operator|->
name|t_id
expr_stmt|;
name|slist_add
argument_list|(
operator|&
name|iiburst
operator|->
name|iib_types
argument_list|,
name|tdp
argument_list|,
name|tdesc_idcmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|tdtrav_cb_f
name|burst_types_cbs
index|[]
init|=
block|{
name|NULL
block|,
name|save_type_by_id
block|,
comment|/* intrinsic */
name|save_type_by_id
block|,
comment|/* pointer */
name|save_type_by_id
block|,
comment|/* array */
name|save_type_by_id
block|,
comment|/* function */
name|save_type_by_id
block|,
comment|/* struct */
name|save_type_by_id
block|,
comment|/* union */
name|save_type_by_id
block|,
comment|/* enum */
name|save_type_by_id
block|,
comment|/* forward */
name|save_type_by_id
block|,
comment|/* typedef */
name|tdtrav_assert
block|,
comment|/* typedef_unres */
name|save_type_by_id
block|,
comment|/* volatile */
name|save_type_by_id
block|,
comment|/* const */
name|save_type_by_id
comment|/* restrict */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|iiburst_t
modifier|*
name|iiburst_new
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|iiburst_t
modifier|*
name|iiburst
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|iiburst_t
argument_list|)
argument_list|)
decl_stmt|;
name|iiburst
operator|->
name|iib_td
operator|=
name|td
expr_stmt|;
name|iiburst
operator|->
name|iib_funcs
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|iidesc_t
operator|*
argument_list|)
operator|*
name|max
argument_list|)
expr_stmt|;
name|iiburst
operator|->
name|iib_nfuncs
operator|=
literal|0
expr_stmt|;
name|iiburst
operator|->
name|iib_objts
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|iidesc_t
operator|*
argument_list|)
operator|*
name|max
argument_list|)
expr_stmt|;
name|iiburst
operator|->
name|iib_nobjts
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|iiburst
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iiburst_types
parameter_list|(
name|iiburst_t
modifier|*
name|iiburst
parameter_list|)
block|{
name|tdtrav_data_t
name|tdtd
decl_stmt|;
name|tdtrav_init
argument_list|(
operator|&
name|tdtd
argument_list|,
operator|&
name|iiburst
operator|->
name|iib_td
operator|->
name|td_curvgen
argument_list|,
name|NULL
argument_list|,
name|burst_types_cbs
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|iiburst
argument_list|)
expr_stmt|;
name|iiburst
operator|->
name|iib_tdtd
operator|=
operator|&
name|tdtd
expr_stmt|;
operator|(
name|void
operator|)
name|hash_iter
argument_list|(
name|iiburst
operator|->
name|iib_td
operator|->
name|td_iihash
argument_list|,
name|burst_iitypes
argument_list|,
name|iiburst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iiburst_free
parameter_list|(
name|iiburst_t
modifier|*
name|iiburst
parameter_list|)
block|{
name|free
argument_list|(
name|iiburst
operator|->
name|iib_funcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iiburst
operator|->
name|iib_objts
argument_list|)
expr_stmt|;
name|list_free
argument_list|(
name|iiburst
operator|->
name|iib_types
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iiburst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * See if this iidesc matches the ELF symbol data we pass in.  *  * A fuzzy match is where we have a local symbol matching the name of a  * global type description. This is common when a mapfile is used for a  * DSO, but we don't accept it by default.  *  * A weak fuzzy match is when a weak symbol was resolved and matched to  * a global type description.  */
end_comment

begin_function
specifier|static
name|int
name|matching_iidesc
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|iidesc_t
modifier|*
name|iidesc
init|=
name|arg1
decl_stmt|;
name|iidesc_match_t
modifier|*
name|match
init|=
name|arg2
decl_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|iidesc
operator|->
name|ii_name
argument_list|,
name|match
operator|->
name|iim_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|iidesc
operator|->
name|ii_type
condition|)
block|{
case|case
name|II_GFUN
case|:
case|case
name|II_GVAR
case|:
if|if
condition|(
name|match
operator|->
name|iim_bind
operator|==
name|STB_GLOBAL
condition|)
block|{
name|match
operator|->
name|iim_ret
operator|=
name|iidesc
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|match
operator|->
name|iim_fuzzy
operator|&&
name|match
operator|->
name|iim_ret
operator|==
name|NULL
condition|)
block|{
name|match
operator|->
name|iim_ret
operator|=
name|iidesc
expr_stmt|;
comment|/* continue to look for strong match */
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|II_SFUN
case|:
case|case
name|II_SVAR
case|:
if|if
condition|(
name|match
operator|->
name|iim_bind
operator|==
name|STB_LOCAL
operator|&&
name|match
operator|->
name|iim_file
operator|!=
name|NULL
operator|&&
name|streq
argument_list|(
name|iidesc
operator|->
name|ii_owner
argument_list|,
name|match
operator|->
name|iim_file
argument_list|)
condition|)
block|{
name|match
operator|->
name|iim_ret
operator|=
name|iidesc
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|iidesc_t
modifier|*
name|find_iidesc
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|iidesc_match_t
modifier|*
name|match
parameter_list|)
block|{
name|match
operator|->
name|iim_ret
operator|=
name|NULL
expr_stmt|;
name|iter_iidescs_by_name
argument_list|(
name|td
argument_list|,
name|match
operator|->
name|iim_name
argument_list|,
name|matching_iidesc
argument_list|,
name|match
argument_list|)
expr_stmt|;
return|return
operator|(
name|match
operator|->
name|iim_ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If we have a weak symbol, attempt to find the strong symbol it will  * resolve to.  Note: the code where this actually happens is in  * sym_process() in cmd/sgs/libld/common/syms.c  *  * Finding the matching symbol is unfortunately not trivial.  For a  * symbol to be a candidate, it must:  *  * - have the same type (function, object)  * - have the same value (address)  * - have the same size  * - not be another weak symbol  * - belong to the same section (checked via section index)  *  * If such a candidate is global, then we assume we've found it.  The  * linker generates the symbol table such that the curfile might be  * incorrect; this is OK for global symbols, since find_iidesc() doesn't  * need to check for the source file for the symbol.  *  * We might have found a strong local symbol, where the curfile is  * accurate and matches that of the weak symbol.  We assume this is a  * reasonable match.  *  * If we've got a local symbol with a non-matching curfile, there are  * two possibilities.  Either this is a completely different symbol, or  * it's a once-global symbol that was scoped to local via a mapfile.  In  * the latter case, curfile is likely inaccurate since the linker does  * not preserve the needed curfile in the order of the symbol table (see  * the comments about locally scoped symbols in libld's update_osym()).  * As we can't tell this case from the former one, we use this symbol  * iff no other matching symbol is found.  *  * What we really need here is a SUNW section containing weak<->strong  * mappings that we can consume.  */
end_comment

begin_function
specifier|static
name|int
name|check_for_weak
parameter_list|(
name|GElf_Sym
modifier|*
name|weak
parameter_list|,
name|char
specifier|const
modifier|*
name|weakfile
parameter_list|,
name|Elf_Data
modifier|*
name|data
parameter_list|,
name|int
name|nent
parameter_list|,
name|Elf_Data
modifier|*
name|strdata
parameter_list|,
name|GElf_Sym
modifier|*
name|retsym
parameter_list|,
name|char
modifier|*
modifier|*
name|curfilep
parameter_list|)
block|{
name|char
modifier|*
name|curfile
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tmpfile1
init|=
name|NULL
decl_stmt|;
name|GElf_Sym
name|tmpsym
decl_stmt|;
name|int
name|candidate
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tmpsym
operator|.
name|st_info
operator|=
literal|0
expr_stmt|;
name|tmpsym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GELF_ST_BIND
argument_list|(
name|weak
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_WEAK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nent
condition|;
name|i
operator|++
control|)
block|{
name|GElf_Sym
name|sym
decl_stmt|;
name|uchar_t
name|type
decl_stmt|;
if|if
condition|(
name|gelf_getsym
argument_list|(
name|data
argument_list|,
name|i
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|type
operator|=
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|STT_FILE
condition|)
name|curfile
operator|=
operator|(
name|char
operator|*
operator|)
name|strdata
operator|->
name|d_buf
operator|+
name|sym
operator|.
name|st_name
expr_stmt|;
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|weak
operator|->
name|st_info
argument_list|)
operator|!=
name|type
operator|||
name|weak
operator|->
name|st_value
operator|!=
name|sym
operator|.
name|st_value
condition|)
continue|continue;
if|if
condition|(
name|weak
operator|->
name|st_size
operator|!=
name|sym
operator|.
name|st_size
condition|)
continue|continue;
if|if
condition|(
name|GELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STB_WEAK
condition|)
continue|continue;
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|!=
name|weak
operator|->
name|st_shndx
condition|)
continue|continue;
if|if
condition|(
name|GELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
operator|&&
operator|(
name|curfile
operator|==
name|NULL
operator|||
name|weakfile
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|curfile
argument_list|,
name|weakfile
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|candidate
operator|=
literal|1
expr_stmt|;
name|tmpfile1
operator|=
name|curfile
expr_stmt|;
name|tmpsym
operator|=
name|sym
expr_stmt|;
continue|continue;
block|}
operator|*
name|curfilep
operator|=
name|curfile
expr_stmt|;
operator|*
name|retsym
operator|=
name|sym
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|candidate
condition|)
block|{
operator|*
name|curfilep
operator|=
name|tmpfile1
expr_stmt|;
operator|*
name|retsym
operator|=
name|tmpsym
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When we've found the underlying symbol's type description  * for a weak symbol, we need to copy it and rename it to match  * the weak symbol. We also need to add it to the td so it's  * handled along with the others later.  */
end_comment

begin_function
specifier|static
name|iidesc_t
modifier|*
name|copy_from_strong
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|GElf_Sym
modifier|*
name|sym
parameter_list|,
name|iidesc_t
modifier|*
name|strongdesc
parameter_list|,
specifier|const
name|char
modifier|*
name|weakname
parameter_list|,
specifier|const
name|char
modifier|*
name|weakfile
parameter_list|)
block|{
name|iidesc_t
modifier|*
name|new
init|=
name|iidesc_dup_rename
argument_list|(
name|strongdesc
argument_list|,
name|weakname
argument_list|,
name|weakfile
argument_list|)
decl_stmt|;
name|uchar_t
name|type
init|=
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|STT_OBJECT
case|:
name|new
operator|->
name|ii_type
operator|=
name|II_GVAR
expr_stmt|;
break|break;
case|case
name|STT_FUNC
case|:
name|new
operator|->
name|ii_type
operator|=
name|II_GFUN
expr_stmt|;
break|break;
block|}
name|hash_add
argument_list|(
name|td
operator|->
name|td_iihash
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process the symbol table of the output file, associating each symbol  * with a type description if possible, and sorting them into functions  * and data, maintaining symbol table order.  */
end_comment

begin_function
specifier|static
name|iiburst_t
modifier|*
name|sort_iidescs
parameter_list|(
name|Elf
modifier|*
name|elf
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|tdata_t
modifier|*
name|td
parameter_list|,
name|int
name|fuzzymatch
parameter_list|,
name|int
name|dynsym
parameter_list|)
block|{
name|iiburst_t
modifier|*
name|iiburst
decl_stmt|;
name|Elf_Scn
modifier|*
name|scn
decl_stmt|;
name|GElf_Shdr
name|shdr
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|,
modifier|*
name|strdata
decl_stmt|;
name|int
name|i
decl_stmt|,
name|stidx
decl_stmt|;
name|int
name|nent
decl_stmt|;
name|iidesc_match_t
name|match
decl_stmt|;
name|match
operator|.
name|iim_fuzzy
operator|=
name|fuzzymatch
expr_stmt|;
name|match
operator|.
name|iim_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|stidx
operator|=
name|findelfsecidx
argument_list|(
name|elf
argument_list|,
name|file
argument_list|,
name|dynsym
condition|?
literal|".dynsym"
else|:
literal|".symtab"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|terminate
argument_list|(
literal|"%s: Can't open symbol table\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|scn
operator|=
name|elf_getscn
argument_list|(
name|elf
argument_list|,
name|stidx
argument_list|)
expr_stmt|;
name|data
operator|=
name|elf_getdata
argument_list|(
name|scn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|shdr
argument_list|)
expr_stmt|;
name|nent
operator|=
name|shdr
operator|.
name|sh_size
operator|/
name|shdr
operator|.
name|sh_entsize
expr_stmt|;
name|scn
operator|=
name|elf_getscn
argument_list|(
name|elf
argument_list|,
name|shdr
operator|.
name|sh_link
argument_list|)
expr_stmt|;
name|strdata
operator|=
name|elf_getdata
argument_list|(
name|scn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|iiburst
operator|=
name|iiburst_new
argument_list|(
name|td
argument_list|,
name|nent
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nent
condition|;
name|i
operator|++
control|)
block|{
name|GElf_Sym
name|sym
decl_stmt|;
name|char
modifier|*
name|bname
decl_stmt|;
name|iidesc_t
modifier|*
modifier|*
name|tolist
decl_stmt|;
name|GElf_Sym
name|ssym
decl_stmt|;
name|iidesc_match_t
name|smatch
decl_stmt|;
name|int
modifier|*
name|curr
decl_stmt|;
name|iidesc_t
modifier|*
name|iidesc
decl_stmt|;
if|if
condition|(
name|gelf_getsym
argument_list|(
name|data
argument_list|,
name|i
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
name|NULL
condition|)
name|elfterminate
argument_list|(
name|file
argument_list|,
literal|"Couldn't read symbol %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|match
operator|.
name|iim_name
operator|=
operator|(
name|char
operator|*
operator|)
name|strdata
operator|->
name|d_buf
operator|+
name|sym
operator|.
name|st_name
expr_stmt|;
name|match
operator|.
name|iim_bind
operator|=
name|GELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STT_FILE
case|:
name|bname
operator|=
name|strrchr
argument_list|(
name|match
operator|.
name|iim_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|match
operator|.
name|iim_file
operator|=
name|bname
operator|==
name|NULL
condition|?
name|match
operator|.
name|iim_name
else|:
name|bname
operator|+
literal|1
expr_stmt|;
continue|continue;
case|case
name|STT_OBJECT
case|:
name|tolist
operator|=
name|iiburst
operator|->
name|iib_objts
expr_stmt|;
name|curr
operator|=
operator|&
name|iiburst
operator|->
name|iib_nobjts
expr_stmt|;
break|break;
case|case
name|STT_FUNC
case|:
name|tolist
operator|=
name|iiburst
operator|->
name|iib_funcs
expr_stmt|;
name|curr
operator|=
operator|&
name|iiburst
operator|->
name|iib_nfuncs
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
if|if
condition|(
name|ignore_symbol
argument_list|(
operator|&
name|sym
argument_list|,
name|match
operator|.
name|iim_name
argument_list|)
condition|)
continue|continue;
name|iidesc
operator|=
name|find_iidesc
argument_list|(
name|td
argument_list|,
operator|&
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
name|iidesc
operator|!=
name|NULL
condition|)
block|{
name|tolist
index|[
operator|*
name|curr
index|]
operator|=
name|iidesc
expr_stmt|;
name|iidesc
operator|->
name|ii_flags
operator||=
name|IIDESC_F_USED
expr_stmt|;
operator|(
operator|*
name|curr
operator|)
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|check_for_weak
argument_list|(
operator|&
name|sym
argument_list|,
name|match
operator|.
name|iim_file
argument_list|,
name|data
argument_list|,
name|nent
argument_list|,
name|strdata
argument_list|,
operator|&
name|ssym
argument_list|,
operator|&
name|smatch
operator|.
name|iim_file
argument_list|)
condition|)
block|{
operator|(
operator|*
name|curr
operator|)
operator|++
expr_stmt|;
continue|continue;
block|}
name|smatch
operator|.
name|iim_fuzzy
operator|=
name|fuzzymatch
expr_stmt|;
name|smatch
operator|.
name|iim_name
operator|=
operator|(
name|char
operator|*
operator|)
name|strdata
operator|->
name|d_buf
operator|+
name|ssym
operator|.
name|st_name
expr_stmt|;
name|smatch
operator|.
name|iim_bind
operator|=
name|GELF_ST_BIND
argument_list|(
name|ssym
operator|.
name|st_info
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Weak symbol %s resolved to %s\n"
argument_list|,
name|match
operator|.
name|iim_name
argument_list|,
name|smatch
operator|.
name|iim_name
argument_list|)
expr_stmt|;
name|iidesc
operator|=
name|find_iidesc
argument_list|(
name|td
argument_list|,
operator|&
name|smatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|iidesc
operator|!=
name|NULL
condition|)
block|{
name|tolist
index|[
operator|*
name|curr
index|]
operator|=
name|copy_from_strong
argument_list|(
name|td
argument_list|,
operator|&
name|sym
argument_list|,
name|iidesc
argument_list|,
name|match
operator|.
name|iim_name
argument_list|,
name|match
operator|.
name|iim_file
argument_list|)
expr_stmt|;
name|tolist
index|[
operator|*
name|curr
index|]
operator|->
name|ii_flags
operator||=
name|IIDESC_F_USED
expr_stmt|;
block|}
operator|(
operator|*
name|curr
operator|)
operator|++
expr_stmt|;
block|}
comment|/* 	 * Stabs are generated for every function declared in a given C source 	 * file.  When converting an object file, we may encounter a stab that 	 * has no symbol table entry because the optimizer has decided to omit 	 * that item (for example, an unreferenced static function).  We may 	 * see iidescs that do not have an associated symtab entry, and so 	 * we do not write records for those functions into the CTF data. 	 * All others get marked as a root by this function. 	 */
name|iiburst_types
argument_list|(
name|iiburst
argument_list|)
expr_stmt|;
comment|/* 	 * By not adding some of the functions and/or objects, we may have 	 * caused some types that were referenced solely by those 	 * functions/objects to be suppressed.  This could cause a label, 	 * generated prior to the evisceration, to be incorrect.  Find the 	 * highest type index, and change the label indicies to be no higher 	 * than this value. 	 */
name|tdata_label_newmax
argument_list|(
name|td
argument_list|,
name|iiburst
operator|->
name|iib_maxtypeid
argument_list|)
expr_stmt|;
return|return
operator|(
name|iiburst
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_file
parameter_list|(
name|Elf
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|srcname
parameter_list|,
name|Elf
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|dstname
parameter_list|,
name|caddr_t
name|ctfdata
parameter_list|,
name|size_t
name|ctfsize
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|GElf_Ehdr
name|sehdr
decl_stmt|,
name|dehdr
decl_stmt|;
name|Elf_Scn
modifier|*
name|sscn
decl_stmt|,
modifier|*
name|dscn
decl_stmt|;
name|Elf_Data
modifier|*
name|sdata
decl_stmt|,
modifier|*
name|ddata
decl_stmt|;
name|GElf_Shdr
name|shdr
decl_stmt|;
name|GElf_Word
name|symtab_type
decl_stmt|;
name|int
name|symtab_idx
init|=
operator|-
literal|1
decl_stmt|;
name|off_t
name|new_offset
init|=
literal|0
decl_stmt|;
name|off_t
name|ctfnameoff
init|=
literal|0
decl_stmt|;
name|int
name|dynsym
init|=
operator|(
name|flags
operator|&
name|CTF_USE_DYNSYM
operator|)
decl_stmt|;
name|int
name|keep_stabs
init|=
operator|(
name|flags
operator|&
name|CTF_KEEP_STABS
operator|)
decl_stmt|;
name|int
modifier|*
name|secxlate
decl_stmt|;
name|int
name|srcidx
decl_stmt|,
name|dstidx
decl_stmt|;
name|int
name|curnmoff
init|=
literal|0
decl_stmt|;
name|int
name|changing
init|=
literal|0
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|gelf_newehdr
argument_list|(
name|dst
argument_list|,
name|gelf_getclass
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
name|elfterminate
argument_list|(
name|dstname
argument_list|,
literal|"Cannot copy ehdr to temp file"
argument_list|)
expr_stmt|;
name|gelf_getehdr
argument_list|(
name|src
argument_list|,
operator|&
name|sehdr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dehdr
argument_list|,
operator|&
name|sehdr
argument_list|,
sizeof|sizeof
argument_list|(
name|GElf_Ehdr
argument_list|)
argument_list|)
expr_stmt|;
name|gelf_update_ehdr
argument_list|(
name|dst
argument_list|,
operator|&
name|dehdr
argument_list|)
expr_stmt|;
name|symtab_type
operator|=
name|dynsym
condition|?
name|SHT_DYNSYM
else|:
name|SHT_SYMTAB
expr_stmt|;
comment|/* 	 * Neither the existing stab sections nor the SUNW_ctf sections (new or 	 * existing) are SHF_ALLOC'd, so they won't be in areas referenced by 	 * program headers.  As such, we can just blindly copy the program 	 * headers from the existing file to the new file. 	 */
if|if
condition|(
name|sehdr
operator|.
name|e_phnum
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|elf_flagelf
argument_list|(
name|dst
argument_list|,
name|ELF_C_SET
argument_list|,
name|ELF_F_LAYOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|gelf_newphdr
argument_list|(
name|dst
argument_list|,
name|sehdr
operator|.
name|e_phnum
argument_list|)
operator|==
name|NULL
condition|)
name|elfterminate
argument_list|(
name|dstname
argument_list|,
literal|"Cannot make phdrs in temp file"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sehdr
operator|.
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
name|GElf_Phdr
name|phdr
decl_stmt|;
name|gelf_getphdr
argument_list|(
name|src
argument_list|,
name|i
argument_list|,
operator|&
name|phdr
argument_list|)
expr_stmt|;
name|gelf_update_phdr
argument_list|(
name|dst
argument_list|,
name|i
argument_list|,
operator|&
name|phdr
argument_list|)
expr_stmt|;
block|}
block|}
name|secxlate
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|sehdr
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
for|for
control|(
name|srcidx
operator|=
name|dstidx
operator|=
literal|0
init|;
name|srcidx
operator|<
name|sehdr
operator|.
name|e_shnum
condition|;
name|srcidx
operator|++
control|)
block|{
name|Elf_Scn
modifier|*
name|scn
init|=
name|elf_getscn
argument_list|(
name|src
argument_list|,
name|srcidx
argument_list|)
decl_stmt|;
name|GElf_Shdr
name|shdr1
decl_stmt|;
name|char
modifier|*
name|sname
decl_stmt|;
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|shdr1
argument_list|)
expr_stmt|;
name|sname
operator|=
name|elf_strptr
argument_list|(
name|src
argument_list|,
name|sehdr
operator|.
name|e_shstrndx
argument_list|,
name|shdr1
operator|.
name|sh_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sname
operator|==
name|NULL
condition|)
block|{
name|elfterminate
argument_list|(
name|srcname
argument_list|,
literal|"Can't find string at %u"
argument_list|,
name|shdr1
operator|.
name|sh_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|sname
argument_list|,
name|CTF_ELF_SCN_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|secxlate
index|[
name|srcidx
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|keep_stabs
operator|&&
operator|(
name|strncmp
argument_list|(
name|sname
argument_list|,
literal|".stab"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|sname
argument_list|,
literal|".debug"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|sname
argument_list|,
literal|".rel.debug"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|sname
argument_list|,
literal|".rela.debug"
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|secxlate
index|[
name|srcidx
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dynsym
operator|&&
name|shdr1
operator|.
name|sh_type
operator|==
name|SHT_SYMTAB
condition|)
block|{
comment|/* 			 * If we're building CTF against the dynsym, 			 * we'll rip out the symtab so debuggers aren't 			 * confused. 			 */
name|secxlate
index|[
name|srcidx
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|secxlate
index|[
name|srcidx
index|]
operator|=
name|dstidx
operator|++
expr_stmt|;
name|curnmoff
operator|+=
name|strlen
argument_list|(
name|sname
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|new_offset
operator|=
operator|(
name|off_t
operator|)
name|dehdr
operator|.
name|e_phoff
expr_stmt|;
block|}
for|for
control|(
name|srcidx
operator|=
literal|1
init|;
name|srcidx
operator|<
name|sehdr
operator|.
name|e_shnum
condition|;
name|srcidx
operator|++
control|)
block|{
name|char
modifier|*
name|sname
decl_stmt|;
name|sscn
operator|=
name|elf_getscn
argument_list|(
name|src
argument_list|,
name|srcidx
argument_list|)
expr_stmt|;
name|gelf_getshdr
argument_list|(
name|sscn
argument_list|,
operator|&
name|shdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|secxlate
index|[
name|srcidx
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|changing
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|dscn
operator|=
name|elf_newscn
argument_list|(
name|dst
argument_list|)
expr_stmt|;
comment|/* 		 * If this file has program headers, we need to explicitly lay 		 * out sections.  If none of the sections prior to this one have 		 * been removed, then we can just use the existing location.  If 		 * one or more sections have been changed, then we need to 		 * adjust this one to avoid holes. 		 */
if|if
condition|(
name|changing
operator|&&
name|sehdr
operator|.
name|e_phnum
operator|!=
literal|0
condition|)
block|{
name|pad
operator|=
name|new_offset
operator|%
name|shdr
operator|.
name|sh_addralign
expr_stmt|;
if|if
condition|(
name|pad
condition|)
name|new_offset
operator|+=
name|shdr
operator|.
name|sh_addralign
operator|-
name|pad
expr_stmt|;
name|shdr
operator|.
name|sh_offset
operator|=
name|new_offset
expr_stmt|;
block|}
name|shdr
operator|.
name|sh_link
operator|=
name|secxlate
index|[
name|shdr
operator|.
name|sh_link
index|]
expr_stmt|;
if|if
condition|(
name|shdr
operator|.
name|sh_type
operator|==
name|SHT_REL
operator|||
name|shdr
operator|.
name|sh_type
operator|==
name|SHT_RELA
condition|)
name|shdr
operator|.
name|sh_info
operator|=
name|secxlate
index|[
name|shdr
operator|.
name|sh_info
index|]
expr_stmt|;
name|sname
operator|=
name|elf_strptr
argument_list|(
name|src
argument_list|,
name|sehdr
operator|.
name|e_shstrndx
argument_list|,
name|shdr
operator|.
name|sh_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sname
operator|==
name|NULL
condition|)
block|{
name|elfterminate
argument_list|(
name|srcname
argument_list|,
literal|"Can't find string at %u"
argument_list|,
name|shdr
operator|.
name|sh_name
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|illumos
if|if
condition|(
name|gelf_update_shdr
argument_list|(
name|dscn
argument_list|,
operator|&
name|shdr
argument_list|)
operator|==
literal|0
condition|)
name|elfterminate
argument_list|(
name|dstname
argument_list|,
literal|"Cannot update sect %s"
argument_list|,
name|sname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sdata
operator|=
name|elf_getdata
argument_list|(
name|sscn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|elfterminate
argument_list|(
name|srcname
argument_list|,
literal|"Cannot get sect %s data"
argument_list|,
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ddata
operator|=
name|elf_newdata
argument_list|(
name|dscn
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|elfterminate
argument_list|(
name|dstname
argument_list|,
literal|"Can't make sect %s data"
argument_list|,
name|sname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|bcopy
argument_list|(
name|sdata
argument_list|,
name|ddata
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Data
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 		 * FreeBSD's Elf_Data has private fields which the 		 * elf_* routines manage. Simply copying the  		 * entire structure corrupts the data. So we need 		 * to copy the public fields explictly. 		 */
name|ddata
operator|->
name|d_align
operator|=
name|sdata
operator|->
name|d_align
expr_stmt|;
name|ddata
operator|->
name|d_off
operator|=
name|sdata
operator|->
name|d_off
expr_stmt|;
name|ddata
operator|->
name|d_size
operator|=
name|sdata
operator|->
name|d_size
expr_stmt|;
name|ddata
operator|->
name|d_type
operator|=
name|sdata
operator|->
name|d_type
expr_stmt|;
name|ddata
operator|->
name|d_version
operator|=
name|sdata
operator|->
name|d_version
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|srcidx
operator|==
name|sehdr
operator|.
name|e_shstrndx
condition|)
block|{
name|char
name|seclen
init|=
name|strlen
argument_list|(
name|CTF_ELF_SCN_NAME
argument_list|)
decl_stmt|;
name|ddata
operator|->
name|d_buf
operator|=
name|xmalloc
argument_list|(
name|ddata
operator|->
name|d_size
operator|+
name|shdr
operator|.
name|sh_size
operator|+
name|seclen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sdata
operator|->
name|d_buf
argument_list|,
name|ddata
operator|->
name|d_buf
argument_list|,
name|shdr
operator|.
name|sh_size
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ddata
operator|->
name|d_buf
operator|+
name|shdr
operator|.
name|sh_size
argument_list|,
name|CTF_ELF_SCN_NAME
argument_list|)
expr_stmt|;
name|ctfnameoff
operator|=
operator|(
name|off_t
operator|)
name|shdr
operator|.
name|sh_size
expr_stmt|;
name|shdr
operator|.
name|sh_size
operator|+=
name|seclen
operator|+
literal|1
expr_stmt|;
name|ddata
operator|->
name|d_size
operator|+=
name|seclen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sehdr
operator|.
name|e_phnum
operator|!=
literal|0
condition|)
name|changing
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|shdr
operator|.
name|sh_type
operator|==
name|symtab_type
operator|&&
name|shdr
operator|.
name|sh_entsize
operator|!=
literal|0
condition|)
block|{
name|int
name|nsym
init|=
name|shdr
operator|.
name|sh_size
operator|/
name|shdr
operator|.
name|sh_entsize
decl_stmt|;
name|symtab_idx
operator|=
name|secxlate
index|[
name|srcidx
index|]
expr_stmt|;
name|ddata
operator|->
name|d_buf
operator|=
name|xmalloc
argument_list|(
name|shdr
operator|.
name|sh_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sdata
operator|->
name|d_buf
argument_list|,
name|ddata
operator|->
name|d_buf
argument_list|,
name|shdr
operator|.
name|sh_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsym
condition|;
name|i
operator|++
control|)
block|{
name|GElf_Sym
name|sym
decl_stmt|;
name|short
name|newscn
decl_stmt|;
if|if
condition|(
name|gelf_getsym
argument_list|(
name|ddata
argument_list|,
name|i
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"Could not get symbol %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|>=
name|SHN_LORESERVE
condition|)
continue|continue;
if|if
condition|(
operator|(
name|newscn
operator|=
name|secxlate
index|[
name|sym
operator|.
name|st_shndx
index|]
operator|)
operator|!=
name|sym
operator|.
name|st_shndx
condition|)
block|{
name|sym
operator|.
name|st_shndx
operator|=
operator|(
name|newscn
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
name|newscn
operator|)
expr_stmt|;
name|gelf_update_sym
argument_list|(
name|ddata
argument_list|,
name|i
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|illumos
if|if
condition|(
name|ddata
operator|->
name|d_buf
operator|==
name|NULL
operator|&&
name|sdata
operator|->
name|d_buf
operator|!=
name|NULL
condition|)
block|{
name|ddata
operator|->
name|d_buf
operator|=
name|xmalloc
argument_list|(
name|shdr
operator|.
name|sh_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sdata
operator|->
name|d_buf
argument_list|,
name|ddata
operator|->
name|d_buf
argument_list|,
name|shdr
operator|.
name|sh_size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|gelf_update_shdr
argument_list|(
name|dscn
argument_list|,
operator|&
name|shdr
argument_list|)
operator|==
literal|0
condition|)
name|elfterminate
argument_list|(
name|dstname
argument_list|,
literal|"Cannot update sect %s"
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|new_offset
operator|=
operator|(
name|off_t
operator|)
name|shdr
operator|.
name|sh_offset
expr_stmt|;
if|if
condition|(
name|shdr
operator|.
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|new_offset
operator|+=
name|shdr
operator|.
name|sh_size
expr_stmt|;
block|}
if|if
condition|(
name|symtab_idx
operator|==
operator|-
literal|1
condition|)
block|{
name|terminate
argument_list|(
literal|"%s: Cannot find %s section\n"
argument_list|,
name|srcname
argument_list|,
name|dynsym
condition|?
literal|"SHT_DYNSYM"
else|:
literal|"SHT_SYMTAB"
argument_list|)
expr_stmt|;
block|}
comment|/* Add the ctf section */
name|dscn
operator|=
name|elf_newscn
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|gelf_getshdr
argument_list|(
name|dscn
argument_list|,
operator|&
name|shdr
argument_list|)
expr_stmt|;
name|shdr
operator|.
name|sh_name
operator|=
name|ctfnameoff
expr_stmt|;
name|shdr
operator|.
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|shdr
operator|.
name|sh_size
operator|=
name|ctfsize
expr_stmt|;
name|shdr
operator|.
name|sh_link
operator|=
name|symtab_idx
expr_stmt|;
name|shdr
operator|.
name|sh_addralign
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|changing
operator|&&
name|sehdr
operator|.
name|e_phnum
operator|!=
literal|0
condition|)
block|{
name|pad
operator|=
name|new_offset
operator|%
name|shdr
operator|.
name|sh_addralign
expr_stmt|;
if|if
condition|(
name|pad
condition|)
name|new_offset
operator|+=
name|shdr
operator|.
name|sh_addralign
operator|-
name|pad
expr_stmt|;
name|shdr
operator|.
name|sh_offset
operator|=
name|new_offset
expr_stmt|;
name|new_offset
operator|+=
name|shdr
operator|.
name|sh_size
expr_stmt|;
block|}
name|ddata
operator|=
name|elf_newdata
argument_list|(
name|dscn
argument_list|)
expr_stmt|;
name|ddata
operator|->
name|d_buf
operator|=
name|ctfdata
expr_stmt|;
name|ddata
operator|->
name|d_size
operator|=
name|ctfsize
expr_stmt|;
name|ddata
operator|->
name|d_align
operator|=
name|shdr
operator|.
name|sh_addralign
expr_stmt|;
name|ddata
operator|->
name|d_off
operator|=
literal|0
expr_stmt|;
name|gelf_update_shdr
argument_list|(
name|dscn
argument_list|,
operator|&
name|shdr
argument_list|)
expr_stmt|;
comment|/* update the section header location */
if|if
condition|(
name|sehdr
operator|.
name|e_phnum
operator|!=
literal|0
condition|)
block|{
name|size_t
name|align
init|=
name|gelf_fsize
argument_list|(
name|dst
argument_list|,
name|ELF_T_ADDR
argument_list|,
literal|1
argument_list|,
name|EV_CURRENT
argument_list|)
decl_stmt|;
name|size_t
name|r
init|=
name|new_offset
operator|%
name|align
decl_stmt|;
if|if
condition|(
name|r
condition|)
name|new_offset
operator|+=
name|align
operator|-
name|r
expr_stmt|;
name|dehdr
operator|.
name|e_shoff
operator|=
name|new_offset
expr_stmt|;
block|}
comment|/* commit to disk */
name|dehdr
operator|.
name|e_shstrndx
operator|=
name|secxlate
index|[
name|sehdr
operator|.
name|e_shstrndx
index|]
expr_stmt|;
name|gelf_update_ehdr
argument_list|(
name|dst
argument_list|,
operator|&
name|dehdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_update
argument_list|(
name|dst
argument_list|,
name|ELF_C_WRITE
argument_list|)
operator|<
literal|0
condition|)
name|elfterminate
argument_list|(
name|dstname
argument_list|,
literal|"Cannot finalize temp file"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|secxlate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|caddr_t
name|make_ctf_data
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|Elf
modifier|*
name|elf
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|iiburst_t
modifier|*
name|iiburst
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|iiburst
operator|=
name|sort_iidescs
argument_list|(
name|elf
argument_list|,
name|file
argument_list|,
name|td
argument_list|,
name|flags
operator|&
name|CTF_FUZZY_MATCH
argument_list|,
name|flags
operator|&
name|CTF_USE_DYNSYM
argument_list|)
expr_stmt|;
name|data
operator|=
name|ctf_gen
argument_list|(
name|iiburst
argument_list|,
name|lenp
argument_list|,
name|flags
operator|&
operator|(
name|CTF_COMPRESS
operator||
name|CTF_SWAP_BYTES
operator|)
argument_list|)
expr_stmt|;
name|iiburst_free
argument_list|(
name|iiburst
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
name|void
name|write_ctf
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
specifier|const
name|char
modifier|*
name|curname
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|Elf
modifier|*
name|elf
init|=
name|NULL
decl_stmt|;
name|Elf
modifier|*
name|telf
init|=
name|NULL
decl_stmt|;
name|GElf_Ehdr
name|ehdr
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|tfd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|byteorder
decl_stmt|;
operator|(
name|void
operator|)
name|elf_version
argument_list|(
name|EV_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|curname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|terminate
argument_list|(
literal|"%s: Cannot open for re-reading"
argument_list|,
name|curname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|ELF_C_READ
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|elfterminate
argument_list|(
name|curname
argument_list|,
literal|"Cannot re-read"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tfd
operator|=
name|open
argument_list|(
name|newname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|terminate
argument_list|(
literal|"Cannot open temp file %s for writing"
argument_list|,
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|telf
operator|=
name|elf_begin
argument_list|(
name|tfd
argument_list|,
name|ELF_C_WRITE
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|elfterminate
argument_list|(
name|curname
argument_list|,
literal|"Cannot write"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gelf_getehdr
argument_list|(
name|elf
argument_list|,
operator|&
name|ehdr
argument_list|)
condition|)
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|_BIG_ENDIAN
name|byteorder
operator|=
name|ELFDATA2MSB
expr_stmt|;
else|#
directive|else
name|byteorder
operator|=
name|ELFDATA2LSB
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If target and host has the same byte order 		 * clear byte swapping request 		 */
if|if
condition|(
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|==
name|byteorder
condition|)
name|flags
operator|&=
operator|~
name|CTF_SWAP_BYTES
expr_stmt|;
block|}
else|else
name|elfterminate
argument_list|(
name|curname
argument_list|,
literal|"Failed to get EHDR"
argument_list|)
expr_stmt|;
name|data
operator|=
name|make_ctf_data
argument_list|(
name|td
argument_list|,
name|elf
argument_list|,
name|curname
argument_list|,
operator|&
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|write_file
argument_list|(
name|elf
argument_list|,
name|curname
argument_list|,
name|telf
argument_list|,
name|newname
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|elf_end
argument_list|(
name|telf
argument_list|)
expr_stmt|;
name|elf_end
argument_list|(
name|elf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|tfd
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

