begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * DWARF to tdata conversion  *  * For the most part, conversion is straightforward, proceeding in two passes.  * On the first pass, we iterate through every die, creating new type nodes as  * necessary.  Referenced tdesc_t's are created in an uninitialized state, thus  * allowing type reference pointers to be filled in.  If the tdesc_t  * corresponding to a given die can be completely filled out (sizes and offsets  * calculated, and so forth) without using any referenced types, the tdesc_t is  * marked as resolved.  Consider an array type.  If the type corresponding to  * the array contents has not yet been processed, we will create a blank tdesc  * for the contents type (only the type ID will be filled in, relying upon the  * later portion of the first pass to encounter and complete the referenced  * type).  We will then attempt to determine the size of the array.  If the  * array has a byte size attribute, we will have completely characterized the  * array type, and will be able to mark it as resolved.  The lack of a byte  * size attribute, on the other hand, will prevent us from fully resolving the  * type, as the size will only be calculable with reference to the contents  * type, which has not, as yet, been encountered.  The array type will thus be  * left without the resolved flag, and the first pass will continue.  *  * When we begin the second pass, we will have created tdesc_t nodes for every  * type in the section.  We will traverse the tree, from the iidescs down,  * processing each unresolved node.  As the referenced nodes will have been  * populated, the array type used in our example above will be able to use the  * size of the referenced types (if available) to determine its own type.  The  * traversal will be repeated until all types have been resolved or we have  * failed to make progress.  When all tdescs have been resolved, the conversion  * is complete.  *  * There are, as always, a few special cases that are handled during the first  * and second passes:  *  *  1. Empty enums - GCC will occasionally emit an enum without any members.  *     Later on in the file, it will emit the same enum type, though this time  *     with the full complement of members.  All references to the memberless  *     enum need to be redirected to the full definition.  During the first  *     pass, each enum is entered in dm_enumhash, along with a pointer to its  *     corresponding tdesc_t.  If, during the second pass, we encounter a  *     memberless enum, we use the hash to locate the full definition.  All  *     tdescs referencing the empty enum are then redirected.  *  *  2. Forward declarations - If the compiler sees a forward declaration for  *     a structure, followed by the definition of that structure, it will emit  *     DWARF data for both the forward declaration and the definition.  We need  *     to resolve the forward declarations when possible, by redirecting  *     forward-referencing tdescs to the actual struct/union definitions.  This  *     redirection is done completely within the first pass.  We begin by  *     recording all forward declarations in dw_fwdhash.  When we define a  *     structure, we check to see if there have been any corresponding forward  *     declarations.  If so, we redirect the tdescs which referenced the forward  *     declarations to the structure or union definition.  *  * XXX see if a post traverser will allow the elimination of repeated pass 2  * traversals.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libelf.h>
end_include

begin_include
include|#
directive|include
file|<libdwarf.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<dwarf.h>
end_include

begin_include
include|#
directive|include
file|"ctf_headers.h"
end_include

begin_include
include|#
directive|include
file|"ctftools.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"list.h"
end_include

begin_include
include|#
directive|include
file|"traverse.h"
end_include

begin_comment
comment|/* The version of DWARF which we support. */
end_comment

begin_define
define|#
directive|define
name|DWARF_VERSION
value|2
end_define

begin_comment
comment|/*  * We need to define a couple of our own intrinsics, to smooth out some of the  * differences between the GCC and DevPro DWARF emitters.  See the referenced  * routines and the special cases in the file comment for more details.  *  * Type IDs are 32 bits wide.  We're going to use the top of that field to  * indicate types that we've created ourselves.  */
end_comment

begin_define
define|#
directive|define
name|TID_FILEMAX
value|0x3fffffff
end_define

begin_comment
comment|/* highest tid from file */
end_comment

begin_define
define|#
directive|define
name|TID_VOID
value|0x40000001
end_define

begin_comment
comment|/* see die_void() */
end_comment

begin_define
define|#
directive|define
name|TID_LONG
value|0x40000002
end_define

begin_comment
comment|/* see die_array() */
end_comment

begin_define
define|#
directive|define
name|TID_MFGTID_BASE
value|0x40000003
end_define

begin_comment
comment|/* first mfg'd tid */
end_comment

begin_comment
comment|/*  * To reduce the staggering amount of error-handling code that would otherwise  * be required, the attribute-retrieval routines handle most of their own  * errors.  If the following flag is supplied as the value of the `req'  * argument, they will also handle the absence of a requested attribute by  * terminating the program.  */
end_comment

begin_define
define|#
directive|define
name|DW_ATTR_REQ
value|1
end_define

begin_define
define|#
directive|define
name|TDESC_HASH_BUCKETS
value|511
end_define

begin_typedef
typedef|typedef
struct|struct
name|dwarf
block|{
name|Dwarf_Debug
name|dw_dw
decl_stmt|;
comment|/* for libdwarf */
name|Dwarf_Error
name|dw_err
decl_stmt|;
comment|/* for libdwarf */
name|Dwarf_Off
name|dw_maxoff
decl_stmt|;
comment|/* highest legal offset in this cu */
name|tdata_t
modifier|*
name|dw_td
decl_stmt|;
comment|/* root of the tdesc/iidesc tree */
name|hash_t
modifier|*
name|dw_tidhash
decl_stmt|;
comment|/* hash of tdescs by t_id */
name|hash_t
modifier|*
name|dw_fwdhash
decl_stmt|;
comment|/* hash of fwd decls by name */
name|hash_t
modifier|*
name|dw_enumhash
decl_stmt|;
comment|/* hash of memberless enums by name */
name|tdesc_t
modifier|*
name|dw_void
decl_stmt|;
comment|/* manufactured void type */
name|tdesc_t
modifier|*
name|dw_long
decl_stmt|;
comment|/* manufactured long type for arrays */
name|size_t
name|dw_ptrsz
decl_stmt|;
comment|/* size of a pointer in this file */
name|tid_t
name|dw_mfgtid_last
decl_stmt|;
comment|/* last mfg'd type ID used */
name|uint_t
name|dw_nunres
decl_stmt|;
comment|/* count of unresolved types */
name|char
modifier|*
name|dw_cuname
decl_stmt|;
comment|/* name of compilation unit */
block|}
name|dwarf_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|die_create_one
parameter_list|(
name|dwarf_t
modifier|*
parameter_list|,
name|Dwarf_Die
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|die_create
parameter_list|(
name|dwarf_t
modifier|*
parameter_list|,
name|Dwarf_Die
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|tid_t
name|mfgtid_next
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|)
block|{
return|return
operator|(
operator|++
name|dw
operator|->
name|dw_mfgtid_last
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tdesc_add
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|hash_add
argument_list|(
name|dw
operator|->
name|dw_tidhash
argument_list|,
name|tdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|tdesc_lookup
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|tdesc_t
name|tmpl
decl_stmt|;
name|void
modifier|*
name|tdp
decl_stmt|;
name|tmpl
operator|.
name|t_id
operator|=
name|tid
expr_stmt|;
if|if
condition|(
name|hash_find
argument_list|(
name|dw
operator|->
name|dw_tidhash
argument_list|,
operator|&
name|tmpl
argument_list|,
operator|&
name|tdp
argument_list|)
condition|)
return|return
operator|(
name|tdp
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Resolve a tdesc down to a node which should have a size.  Returns the size,  * zero if the size hasn't yet been determined.  */
end_comment

begin_function
specifier|static
name|size_t
name|tdesc_size
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|tdp
operator|->
name|t_type
condition|)
block|{
case|case
name|INTRINSIC
case|:
case|case
name|POINTER
case|:
case|case
name|ARRAY
case|:
case|case
name|FUNCTION
case|:
case|case
name|STRUCT
case|:
case|case
name|UNION
case|:
case|case
name|ENUM
case|:
return|return
operator|(
name|tdp
operator|->
name|t_size
operator|)
return|;
case|case
name|FORWARD
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TYPEDEF
case|:
case|case
name|VOLATILE
case|:
case|case
name|CONST
case|:
case|case
name|RESTRICT
case|:
name|tdp
operator|=
name|tdp
operator|->
name|t_tdesc
expr_stmt|;
continue|continue;
case|case
literal|0
case|:
comment|/* not yet defined */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|terminate
argument_list|(
literal|"tdp %u: tdesc_size on unknown type %d\n"
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|,
name|tdp
operator|->
name|t_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|size_t
name|tdesc_bitsize
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|tdp
operator|->
name|t_type
condition|)
block|{
case|case
name|INTRINSIC
case|:
return|return
operator|(
name|tdp
operator|->
name|t_intr
operator|->
name|intr_nbits
operator|)
return|;
case|case
name|ARRAY
case|:
case|case
name|FUNCTION
case|:
case|case
name|STRUCT
case|:
case|case
name|UNION
case|:
case|case
name|ENUM
case|:
case|case
name|POINTER
case|:
return|return
operator|(
name|tdp
operator|->
name|t_size
operator|*
name|NBBY
operator|)
return|;
case|case
name|FORWARD
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TYPEDEF
case|:
case|case
name|VOLATILE
case|:
case|case
name|RESTRICT
case|:
case|case
name|CONST
case|:
name|tdp
operator|=
name|tdp
operator|->
name|t_tdesc
expr_stmt|;
continue|continue;
case|case
literal|0
case|:
comment|/* not yet defined */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|terminate
argument_list|(
literal|"tdp %u: tdesc_bitsize on unknown type %d\n"
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|,
name|tdp
operator|->
name|t_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|tdesc_basetype
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|tdp
operator|->
name|t_type
condition|)
block|{
case|case
name|TYPEDEF
case|:
case|case
name|VOLATILE
case|:
case|case
name|RESTRICT
case|:
case|case
name|CONST
case|:
name|tdp
operator|=
name|tdp
operator|->
name|t_tdesc
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* not yet defined */
return|return
operator|(
name|NULL
operator|)
return|;
default|default:
return|return
operator|(
name|tdp
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|Dwarf_Off
name|die_off
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|)
block|{
name|Dwarf_Off
name|off
decl_stmt|;
if|if
condition|(
name|dwarf_dieoffset
argument_list|(
name|die
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
return|return
operator|(
name|off
operator|)
return|;
name|terminate
argument_list|(
literal|"failed to get offset for die: %s\n"
argument_list|,
name|dwarf_errmsg
argument_list|(
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Dwarf_Die
name|die_sibling
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|)
block|{
name|Dwarf_Die
name|sib
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|dwarf_siblingof
argument_list|(
name|dw
operator|->
name|dw_dw
argument_list|,
name|die
argument_list|,
operator|&
name|sib
argument_list|,
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
operator|)
operator|==
name|DW_DLV_OK
condition|)
return|return
operator|(
name|sib
operator|)
return|;
elseif|else
if|if
condition|(
name|rc
operator|==
name|DW_DLV_NO_ENTRY
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|terminate
argument_list|(
literal|"die %llu: failed to find type sibling: %s\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|,
name|dwarf_errmsg
argument_list|(
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Dwarf_Die
name|die_child
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|)
block|{
name|Dwarf_Die
name|child
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|dwarf_child
argument_list|(
name|die
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
operator|)
operator|==
name|DW_DLV_OK
condition|)
return|return
operator|(
name|child
operator|)
return|;
elseif|else
if|if
condition|(
name|rc
operator|==
name|DW_DLV_NO_ENTRY
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|terminate
argument_list|(
literal|"die %llu: failed to find type child: %s\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|,
name|dwarf_errmsg
argument_list|(
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Dwarf_Half
name|die_tag
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|)
block|{
name|Dwarf_Half
name|tag
decl_stmt|;
if|if
condition|(
name|dwarf_tag
argument_list|(
name|die
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
return|return
operator|(
name|tag
operator|)
return|;
name|terminate
argument_list|(
literal|"die %llu: failed to get tag for type: %s\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|,
name|dwarf_errmsg
argument_list|(
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Dwarf_Attribute
name|die_attr
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Half
name|name
parameter_list|,
name|int
name|req
parameter_list|)
block|{
name|Dwarf_Attribute
name|attr
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|name
argument_list|,
operator|&
name|attr
argument_list|,
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
operator|)
operator|==
name|DW_DLV_OK
condition|)
block|{
return|return
operator|(
name|attr
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|DW_DLV_NO_ENTRY
condition|)
block|{
if|if
condition|(
name|req
condition|)
block|{
name|terminate
argument_list|(
literal|"die %llu: no attr 0x%x\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|terminate
argument_list|(
literal|"die %llu: failed to get attribute for type: %s\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|,
name|dwarf_errmsg
argument_list|(
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|die_signed
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Half
name|name
parameter_list|,
name|Dwarf_Signed
modifier|*
name|valp
parameter_list|,
name|int
name|req
parameter_list|)
block|{
operator|*
name|valp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dwarf_attrval_signed
argument_list|(
name|die
argument_list|,
name|name
argument_list|,
name|valp
argument_list|,
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
operator|!=
name|DWARF_E_NONE
condition|)
block|{
if|if
condition|(
name|req
condition|)
name|terminate
argument_list|(
literal|"die %llu: failed to get signed: %s\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|,
name|dwarf_errmsg
argument_list|(
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|die_unsigned
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Half
name|name
parameter_list|,
name|Dwarf_Unsigned
modifier|*
name|valp
parameter_list|,
name|int
name|req
parameter_list|)
block|{
operator|*
name|valp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|name
argument_list|,
name|valp
argument_list|,
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
operator|!=
name|DWARF_E_NONE
condition|)
block|{
if|if
condition|(
name|req
condition|)
name|terminate
argument_list|(
literal|"die %llu: failed to get unsigned: %s\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|,
name|dwarf_errmsg
argument_list|(
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|die_bool
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Half
name|name
parameter_list|,
name|Dwarf_Bool
modifier|*
name|valp
parameter_list|,
name|int
name|req
parameter_list|)
block|{
operator|*
name|valp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dwarf_attrval_flag
argument_list|(
name|die
argument_list|,
name|name
argument_list|,
name|valp
argument_list|,
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
operator|!=
name|DWARF_E_NONE
condition|)
block|{
if|if
condition|(
name|req
condition|)
name|terminate
argument_list|(
literal|"die %llu: failed to get flag: %s\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|,
name|dwarf_errmsg
argument_list|(
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|die_string
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Half
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|strp
parameter_list|,
name|int
name|req
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dwarf_attrval_string
argument_list|(
name|die
argument_list|,
name|name
argument_list|,
operator|&
name|str
argument_list|,
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
operator|!=
name|DWARF_E_NONE
operator|||
name|str
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|req
condition|)
name|terminate
argument_list|(
literal|"die %llu: failed to get string: %s\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|,
name|dwarf_errmsg
argument_list|(
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|strp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
operator|*
name|strp
operator|=
name|xstrdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Dwarf_Off
name|die_attr_ref
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Half
name|name
parameter_list|)
block|{
name|Dwarf_Off
name|off
decl_stmt|;
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|name
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
operator|!=
name|DWARF_E_NONE
condition|)
block|{
name|terminate
argument_list|(
literal|"die %llu: failed to get ref: %s\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|,
name|dwarf_errmsg
argument_list|(
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|off
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|die_name
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|die_string
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|DW_AT_name
argument_list|,
operator|&
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|die_isdecl
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|)
block|{
name|Dwarf_Bool
name|val
decl_stmt|;
return|return
operator|(
name|die_bool
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|DW_AT_declaration
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|)
operator|&&
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|die_isglobal
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|)
block|{
name|Dwarf_Signed
name|vis
decl_stmt|;
name|Dwarf_Bool
name|ext
decl_stmt|;
comment|/* 	 * Some compilers (gcc) use DW_AT_external to indicate function 	 * visibility.  Others (Sun) use DW_AT_visibility. 	 */
if|if
condition|(
name|die_signed
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|DW_AT_visibility
argument_list|,
operator|&
name|vis
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|vis
operator|==
name|DW_VIS_exported
operator|)
return|;
else|else
return|return
operator|(
name|die_bool
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|DW_AT_external
argument_list|,
operator|&
name|ext
argument_list|,
literal|0
argument_list|)
operator|&&
name|ext
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|die_add
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
argument_list|)
argument_list|)
decl_stmt|;
name|tdp
operator|->
name|t_id
operator|=
name|off
expr_stmt|;
name|tdesc_add
argument_list|(
name|dw
argument_list|,
name|tdp
argument_list|)
expr_stmt|;
return|return
operator|(
name|tdp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|die_lookup_pass1
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Half
name|name
parameter_list|)
block|{
name|Dwarf_Off
name|ref
init|=
name|die_attr_ref
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|tdesc_t
modifier|*
name|tdp
decl_stmt|;
if|if
condition|(
operator|(
name|tdp
operator|=
name|tdesc_lookup
argument_list|(
name|dw
argument_list|,
name|ref
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|tdp
operator|)
return|;
return|return
operator|(
name|die_add
argument_list|(
name|dw
argument_list|,
name|ref
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|die_mem_offset
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Half
name|name
parameter_list|,
name|Dwarf_Unsigned
modifier|*
name|valp
parameter_list|,
name|int
name|req
name|__unused
parameter_list|)
block|{
name|Dwarf_Locdesc
modifier|*
name|loc
init|=
name|NULL
decl_stmt|;
name|Dwarf_Signed
name|locnum
init|=
literal|0
decl_stmt|;
name|Dwarf_Attribute
name|at
decl_stmt|;
name|Dwarf_Half
name|form
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|DW_AT_data_member_location
condition|)
name|terminate
argument_list|(
literal|"die %llu: can only process attribute "
literal|"DW_AT_data_member_location\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|at
operator|=
name|die_attr
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dwarf_whatform
argument_list|(
name|at
argument_list|,
operator|&
name|form
argument_list|,
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_block
case|:
case|case
name|DW_FORM_block1
case|:
case|case
name|DW_FORM_block2
case|:
case|case
name|DW_FORM_block4
case|:
comment|/* 		 * GCC in base and Clang (3.3 or below) generates 		 * DW_AT_data_member_location attribute with DW_FORM_block* 		 * form. The attribute contains one DW_OP_plus_uconst 		 * operator. The member offset stores in the operand. 		 */
if|if
condition|(
name|dwarf_locdesc
argument_list|(
name|die
argument_list|,
name|name
argument_list|,
operator|&
name|loc
argument_list|,
operator|&
name|locnum
argument_list|,
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|locnum
operator|!=
literal|1
operator|||
name|loc
operator|->
name|ld_s
operator|->
name|lr_atom
operator|!=
name|DW_OP_plus_uconst
condition|)
block|{
name|terminate
argument_list|(
literal|"die %llu: cannot parse member offset\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|valp
operator|=
name|loc
operator|->
name|ld_s
operator|->
name|lr_number
expr_stmt|;
break|break;
case|case
name|DW_FORM_data1
case|:
case|case
name|DW_FORM_data2
case|:
case|case
name|DW_FORM_data4
case|:
case|case
name|DW_FORM_data8
case|:
case|case
name|DW_FORM_udata
case|:
comment|/* 		 * Clang 3.4 generates DW_AT_data_member_location attribute 		 * with DW_FORM_data* form (constant class). The attribute 		 * stores a contant value which is the member offset. 		 */
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|name
argument_list|,
name|valp
argument_list|,
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
name|terminate
argument_list|(
literal|"die %llu: cannot parse member offset with form "
literal|"%u\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loc
operator|!=
name|NULL
condition|)
if|if
condition|(
name|dwarf_locdesc_free
argument_list|(
name|loc
argument_list|,
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
name|terminate
argument_list|(
literal|"die %llu: cannot free location descriptor: %s\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|,
name|dwarf_errmsg
argument_list|(
operator|&
name|dw
operator|->
name|dw_err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|tdesc_intr_common
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|int
name|tid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp
decl_stmt|;
name|intr_t
modifier|*
name|intr
decl_stmt|;
name|intr
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|intr_t
argument_list|)
argument_list|)
expr_stmt|;
name|intr
operator|->
name|intr_type
operator|=
name|INTR_INT
expr_stmt|;
name|intr
operator|->
name|intr_signed
operator|=
literal|1
expr_stmt|;
name|intr
operator|->
name|intr_nbits
operator|=
name|sz
operator|*
name|NBBY
expr_stmt|;
name|tdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_size
operator|=
name|sz
expr_stmt|;
name|tdp
operator|->
name|t_id
operator|=
name|tid
expr_stmt|;
name|tdp
operator|->
name|t_type
operator|=
name|INTRINSIC
expr_stmt|;
name|tdp
operator|->
name|t_intr
operator|=
name|intr
expr_stmt|;
name|tdp
operator|->
name|t_flags
operator|=
name|TDESC_F_RESOLVED
expr_stmt|;
name|tdesc_add
argument_list|(
name|dw
argument_list|,
name|tdp
argument_list|)
expr_stmt|;
return|return
operator|(
name|tdp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Manufacture a void type.  Used for gcc-emitted stabs, where the lack of a  * type reference implies a reference to a void type.  A void *, for example  * will be represented by a pointer die without a DW_AT_type.  CTF requires  * that pointer nodes point to something, so we'll create a void for use as  * the target.  Note that the DWARF data may already create a void type.  Ours  * would then be a duplicate, but it'll be removed in the self-uniquification  * merge performed at the completion of DWARF->tdesc conversion.  */
end_comment

begin_function
specifier|static
name|tdesc_t
modifier|*
name|tdesc_intr_void
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|)
block|{
if|if
condition|(
name|dw
operator|->
name|dw_void
operator|==
name|NULL
condition|)
name|dw
operator|->
name|dw_void
operator|=
name|tdesc_intr_common
argument_list|(
name|dw
argument_list|,
name|TID_VOID
argument_list|,
literal|"void"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|dw
operator|->
name|dw_void
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|tdesc_intr_long
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|)
block|{
if|if
condition|(
name|dw
operator|->
name|dw_long
operator|==
name|NULL
condition|)
block|{
name|dw
operator|->
name|dw_long
operator|=
name|tdesc_intr_common
argument_list|(
name|dw
argument_list|,
name|TID_LONG
argument_list|,
literal|"long"
argument_list|,
name|dw
operator|->
name|dw_ptrsz
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dw
operator|->
name|dw_long
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Used for creating bitfield types.  We create a copy of an existing intrinsic,  * adjusting the size of the copy to match what the caller requested.  The  * caller can then use the copy as the type for a bitfield structure member.  */
end_comment

begin_function
specifier|static
name|tdesc_t
modifier|*
name|tdesc_intr_clone
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|tdesc_t
modifier|*
name|old
parameter_list|,
name|size_t
name|bitsz
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|new
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|old
operator|->
name|t_flags
operator|&
name|TDESC_F_RESOLVED
operator|)
condition|)
block|{
name|terminate
argument_list|(
literal|"tdp %u: attempt to make a bit field from an "
literal|"unresolved type\n"
argument_list|,
name|old
operator|->
name|t_id
argument_list|)
expr_stmt|;
block|}
name|new
operator|->
name|t_name
operator|=
name|xstrdup
argument_list|(
name|old
operator|->
name|t_name
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_size
operator|=
name|old
operator|->
name|t_size
expr_stmt|;
name|new
operator|->
name|t_id
operator|=
name|mfgtid_next
argument_list|(
name|dw
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_type
operator|=
name|INTRINSIC
expr_stmt|;
name|new
operator|->
name|t_flags
operator|=
name|TDESC_F_RESOLVED
expr_stmt|;
name|new
operator|->
name|t_intr
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|intr_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|old
operator|->
name|t_intr
argument_list|,
name|new
operator|->
name|t_intr
argument_list|,
sizeof|sizeof
argument_list|(
name|intr_t
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_intr
operator|->
name|intr_nbits
operator|=
name|bitsz
expr_stmt|;
name|tdesc_add
argument_list|(
name|dw
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tdesc_array_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|dim
parameter_list|,
name|tdesc_t
modifier|*
name|arrtdp
parameter_list|,
name|tdesc_t
modifier|*
name|dimtdp
parameter_list|)
block|{
name|Dwarf_Unsigned
name|uval
decl_stmt|;
name|Dwarf_Signed
name|sval
decl_stmt|;
name|tdesc_t
modifier|*
name|ctdp
init|=
name|NULL
decl_stmt|;
name|Dwarf_Die
name|dim2
decl_stmt|;
name|ardef_t
modifier|*
name|ar
decl_stmt|;
if|if
condition|(
operator|(
name|dim2
operator|=
name|die_sibling
argument_list|(
name|dw
argument_list|,
name|dim
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ctdp
operator|=
name|arrtdp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|die_tag
argument_list|(
name|dw
argument_list|,
name|dim2
argument_list|)
operator|==
name|DW_TAG_subrange_type
condition|)
block|{
name|ctdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|ctdp
operator|->
name|t_id
operator|=
name|mfgtid_next
argument_list|(
name|dw
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: creating new type %u for sub-dimension\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|dim2
argument_list|)
argument_list|,
name|ctdp
operator|->
name|t_id
argument_list|)
expr_stmt|;
name|tdesc_array_create
argument_list|(
name|dw
argument_list|,
name|dim2
argument_list|,
name|arrtdp
argument_list|,
name|ctdp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|terminate
argument_list|(
literal|"die %llu: unexpected non-subrange node in array\n"
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|dim2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dimtdp
operator|->
name|t_type
operator|=
name|ARRAY
expr_stmt|;
name|dimtdp
operator|->
name|t_ardef
operator|=
name|ar
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ardef_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Array bounds can be signed or unsigned, but there are several kinds 	 * of signless forms (data1, data2, etc) that take their sign from the 	 * routine that is trying to interpret them.  That is, data1 can be 	 * either signed or unsigned, depending on whether you use the signed or 	 * unsigned accessor function.  GCC will use the signless forms to store 	 * unsigned values which have their high bit set, so we need to try to 	 * read them first as unsigned to get positive values.  We could also 	 * try signed first, falling back to unsigned if we got a negative 	 * value. 	 */
if|if
condition|(
name|die_unsigned
argument_list|(
name|dw
argument_list|,
name|dim
argument_list|,
name|DW_AT_upper_bound
argument_list|,
operator|&
name|uval
argument_list|,
literal|0
argument_list|)
condition|)
name|ar
operator|->
name|ad_nelems
operator|=
name|uval
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|die_signed
argument_list|(
name|dw
argument_list|,
name|dim
argument_list|,
name|DW_AT_upper_bound
argument_list|,
operator|&
name|sval
argument_list|,
literal|0
argument_list|)
condition|)
name|ar
operator|->
name|ad_nelems
operator|=
name|sval
operator|+
literal|1
expr_stmt|;
else|else
name|ar
operator|->
name|ad_nelems
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Different compilers use different index types.  Force the type to be 	 * a common, known value (long). 	 */
name|ar
operator|->
name|ad_idxtype
operator|=
name|tdesc_intr_long
argument_list|(
name|dw
argument_list|)
expr_stmt|;
name|ar
operator|->
name|ad_contents
operator|=
name|ctdp
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|ad_contents
operator|->
name|t_size
operator|!=
literal|0
condition|)
block|{
name|dimtdp
operator|->
name|t_size
operator|=
name|ar
operator|->
name|ad_contents
operator|->
name|t_size
operator|*
name|ar
operator|->
name|ad_nelems
expr_stmt|;
name|dimtdp
operator|->
name|t_flags
operator||=
name|TDESC_F_RESOLVED
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Create a tdesc from an array node.  Some arrays will come with byte size  * attributes, and thus can be resolved immediately.  Others don't, and will  * need to wait until the second pass for resolution.  */
end_comment

begin_function
specifier|static
name|void
name|die_array_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|arr
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|arrtdp
init|=
name|die_lookup_pass1
argument_list|(
name|dw
argument_list|,
name|arr
argument_list|,
name|DW_AT_type
argument_list|)
decl_stmt|;
name|Dwarf_Unsigned
name|uval
decl_stmt|;
name|Dwarf_Die
name|dim
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu<%llx>: creating array\n"
argument_list|,
name|off
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dim
operator|=
name|die_child
argument_list|(
name|dw
argument_list|,
name|arr
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|die_tag
argument_list|(
name|dw
argument_list|,
name|dim
argument_list|)
operator|!=
name|DW_TAG_subrange_type
condition|)
name|terminate
argument_list|(
literal|"die %llu: failed to retrieve array bounds\n"
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|tdesc_array_create
argument_list|(
name|dw
argument_list|,
name|dim
argument_list|,
name|arrtdp
argument_list|,
name|tdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|die_unsigned
argument_list|(
name|dw
argument_list|,
name|arr
argument_list|,
name|DW_AT_byte_size
argument_list|,
operator|&
name|uval
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tdesc_t
modifier|*
name|dimtdp
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|tdp
operator|->
name|t_size
operator|=
name|uval
expr_stmt|;
comment|/* 		 * Ensure that sub-dimensions have sizes too before marking 		 * as resolved. 		 */
name|flags
operator|=
name|TDESC_F_RESOLVED
expr_stmt|;
for|for
control|(
name|dimtdp
operator|=
name|tdp
operator|->
name|t_ardef
operator|->
name|ad_contents
init|;
name|dimtdp
operator|->
name|t_type
operator|==
name|ARRAY
condition|;
name|dimtdp
operator|=
name|dimtdp
operator|->
name|t_ardef
operator|->
name|ad_contents
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|dimtdp
operator|->
name|t_flags
operator|&
name|TDESC_F_RESOLVED
operator|)
condition|)
block|{
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|tdp
operator|->
name|t_flags
operator||=
name|flags
expr_stmt|;
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu<%llx>: array nelems %u size %u\n"
argument_list|,
name|off
argument_list|,
name|off
argument_list|,
name|tdp
operator|->
name|t_ardef
operator|->
name|ad_nelems
argument_list|,
name|tdp
operator|->
name|t_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
specifier|static
name|int
name|die_array_resolve
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|tdpp
name|__unused
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|dwarf_t
modifier|*
name|dw
init|=
name|private
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_flags
operator|&
name|TDESC_F_RESOLVED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"trying to resolve array %d (cont %d)\n"
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|,
name|tdp
operator|->
name|t_ardef
operator|->
name|ad_contents
operator|->
name|t_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sz
operator|=
name|tdesc_size
argument_list|(
name|tdp
operator|->
name|t_ardef
operator|->
name|ad_contents
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"unable to resolve array %s (%d) contents %d\n"
argument_list|,
name|tdesc_name
argument_list|(
name|tdp
argument_list|)
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|,
name|tdp
operator|->
name|t_ardef
operator|->
name|ad_contents
operator|->
name|t_id
argument_list|)
expr_stmt|;
name|dw
operator|->
name|dw_nunres
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|tdp
operator|->
name|t_size
operator|=
name|sz
operator|*
name|tdp
operator|->
name|t_ardef
operator|->
name|ad_nelems
expr_stmt|;
name|tdp
operator|->
name|t_flags
operator||=
name|TDESC_F_RESOLVED
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"resolved array %d: %u bytes\n"
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|,
name|tdp
operator|->
name|t_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
specifier|static
name|int
name|die_array_failed
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|tdpp
name|__unused
parameter_list|,
name|void
modifier|*
name|private
name|__unused
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|cont
init|=
name|tdp
operator|->
name|t_ardef
operator|->
name|ad_contents
decl_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_flags
operator|&
name|TDESC_F_RESOLVED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Array %d: failed to size contents type %s (%d)\n"
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|,
name|tdesc_name
argument_list|(
name|cont
argument_list|)
argument_list|,
name|cont
operator|->
name|t_id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Most enums (those with members) will be resolved during this first pass.  * Others - those without members (see the file comment) - won't be, and will  * need to wait until the second pass when they can be matched with their full  * definitions.  */
end_comment

begin_function
specifier|static
name|void
name|die_enum_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|Dwarf_Die
name|mem
decl_stmt|;
name|Dwarf_Unsigned
name|uval
decl_stmt|;
name|Dwarf_Signed
name|sval
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: creating enum\n"
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_type
operator|=
name|ENUM
expr_stmt|;
operator|(
name|void
operator|)
name|die_unsigned
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|,
operator|&
name|uval
argument_list|,
name|DW_ATTR_REQ
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_size
operator|=
name|uval
expr_stmt|;
if|if
condition|(
operator|(
name|mem
operator|=
name|die_child
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|elist_t
modifier|*
modifier|*
name|elastp
init|=
operator|&
name|tdp
operator|->
name|t_emem
decl_stmt|;
do|do
block|{
name|elist_t
modifier|*
name|el
decl_stmt|;
if|if
condition|(
name|die_tag
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|)
operator|!=
name|DW_TAG_enumerator
condition|)
block|{
comment|/* Nested type declaration */
name|die_create_one
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|el
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|elist_t
argument_list|)
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_name
operator|=
name|die_name
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|die_signed
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|,
name|DW_AT_const_value
argument_list|,
operator|&
name|sval
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|el
operator|->
name|el_number
operator|=
name|sval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|die_unsigned
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|,
name|DW_AT_const_value
argument_list|,
operator|&
name|uval
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|el
operator|->
name|el_number
operator|=
name|uval
expr_stmt|;
block|}
else|else
block|{
name|terminate
argument_list|(
literal|"die %llu: enum %llu: member without "
literal|"value\n"
argument_list|,
name|off
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: enum %llu: created %s = %d\n"
argument_list|,
name|off
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|)
argument_list|,
name|el
operator|->
name|el_name
argument_list|,
name|el
operator|->
name|el_number
argument_list|)
expr_stmt|;
operator|*
name|elastp
operator|=
name|el
expr_stmt|;
name|elastp
operator|=
operator|&
name|el
operator|->
name|el_next
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|mem
operator|=
name|die_sibling
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
name|hash_add
argument_list|(
name|dw
operator|->
name|dw_enumhash
argument_list|,
name|tdp
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_flags
operator||=
name|TDESC_F_RESOLVED
expr_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_name
operator|!=
name|NULL
condition|)
block|{
name|iidesc_t
modifier|*
name|ii
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|iidesc_t
argument_list|)
argument_list|)
decl_stmt|;
name|ii
operator|->
name|ii_type
operator|=
name|II_SOU
expr_stmt|;
name|ii
operator|->
name|ii_name
operator|=
name|xstrdup
argument_list|(
name|tdp
operator|->
name|t_name
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_dtype
operator|=
name|tdp
expr_stmt|;
name|iidesc_add
argument_list|(
name|dw
operator|->
name|dw_td
operator|->
name|td_iihash
argument_list|,
name|ii
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|die_enum_match
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|tdp
init|=
name|arg1
decl_stmt|,
modifier|*
modifier|*
name|fullp
init|=
name|arg2
decl_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_emem
operator|!=
name|NULL
condition|)
block|{
operator|*
name|fullp
operator|=
name|tdp
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* stop the iteration */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
specifier|static
name|int
name|die_enum_resolve
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|tdpp
name|__unused
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|dwarf_t
modifier|*
name|dw
init|=
name|private
decl_stmt|;
name|tdesc_t
modifier|*
name|full
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_flags
operator|&
name|TDESC_F_RESOLVED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|hash_find_iter
argument_list|(
name|dw
operator|->
name|dw_enumhash
argument_list|,
name|tdp
argument_list|,
name|die_enum_match
argument_list|,
operator|&
name|full
argument_list|)
expr_stmt|;
comment|/* 	 * The answer to this one won't change from iteration to iteration, 	 * so don't even try. 	 */
if|if
condition|(
name|full
operator|==
name|NULL
condition|)
block|{
name|terminate
argument_list|(
literal|"tdp %u: enum %s has no members\n"
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|,
name|tdesc_name
argument_list|(
name|tdp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|"tdp %u: enum %s redirected to %u\n"
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|,
name|tdesc_name
argument_list|(
name|tdp
argument_list|)
argument_list|,
name|full
operator|->
name|t_id
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_flags
operator||=
name|TDESC_F_RESOLVED
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|die_fwd_map
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|fwd
init|=
name|arg1
decl_stmt|,
modifier|*
name|sou
init|=
name|arg2
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"tdp %u: mapped forward %s to sou %u\n"
argument_list|,
name|fwd
operator|->
name|t_id
argument_list|,
name|tdesc_name
argument_list|(
name|fwd
argument_list|)
argument_list|,
name|sou
operator|->
name|t_id
argument_list|)
expr_stmt|;
name|fwd
operator|->
name|t_tdesc
operator|=
name|sou
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Structures and unions will never be resolved during the first pass, as we  * won't be able to fully determine the member sizes.  The second pass, which  * have access to sizing information, will be able to complete the resolution.  */
end_comment

begin_function
specifier|static
name|void
name|die_sou_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|str
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|typename
parameter_list|)
block|{
name|Dwarf_Unsigned
name|sz
decl_stmt|,
name|bitsz
decl_stmt|,
name|bitoff
decl_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|_LITTLE_ENDIAN
name|Dwarf_Unsigned
name|bysz
decl_stmt|;
endif|#
directive|endif
name|Dwarf_Die
name|mem
decl_stmt|;
name|mlist_t
modifier|*
name|ml
decl_stmt|,
modifier|*
modifier|*
name|mlastp
decl_stmt|;
name|iidesc_t
modifier|*
name|ii
decl_stmt|;
name|tdp
operator|->
name|t_type
operator|=
operator|(
name|die_isdecl
argument_list|(
name|dw
argument_list|,
name|str
argument_list|)
condition|?
name|FORWARD
else|:
name|type
operator|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: creating %s %s\n"
argument_list|,
name|off
argument_list|,
operator|(
name|tdp
operator|->
name|t_type
operator|==
name|FORWARD
condition|?
literal|"forward decl"
else|:
name|typename
operator|)
argument_list|,
name|tdesc_name
argument_list|(
name|tdp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_type
operator|==
name|FORWARD
condition|)
block|{
name|hash_add
argument_list|(
name|dw
operator|->
name|dw_fwdhash
argument_list|,
name|tdp
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|hash_find_iter
argument_list|(
name|dw
operator|->
name|dw_fwdhash
argument_list|,
name|tdp
argument_list|,
name|die_fwd_map
argument_list|,
name|tdp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|die_unsigned
argument_list|(
name|dw
argument_list|,
name|str
argument_list|,
name|DW_AT_byte_size
argument_list|,
operator|&
name|sz
argument_list|,
name|DW_ATTR_REQ
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_size
operator|=
name|sz
expr_stmt|;
comment|/* 	 * GCC allows empty SOUs as an extension. 	 */
if|if
condition|(
operator|(
name|mem
operator|=
name|die_child
argument_list|(
name|dw
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|mlastp
operator|=
operator|&
name|tdp
operator|->
name|t_members
expr_stmt|;
do|do
block|{
name|Dwarf_Off
name|memoff
init|=
name|die_off
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|)
decl_stmt|;
name|Dwarf_Half
name|tag
init|=
name|die_tag
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|)
decl_stmt|;
name|Dwarf_Unsigned
name|mloff
decl_stmt|;
if|if
condition|(
name|tag
operator|!=
name|DW_TAG_member
condition|)
block|{
comment|/* Nested type declaration */
name|die_create_one
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: mem %llu: creating member\n"
argument_list|,
name|off
argument_list|,
name|memoff
argument_list|)
expr_stmt|;
name|ml
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mlist_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * This could be a GCC anon struct/union member, so we'll allow 		 * an empty name, even though nothing can really handle them 		 * properly.  Note that some versions of GCC miss out debug 		 * info for anon structs, though recent versions are fixed (gcc 		 * bug 11816). 		 */
if|if
condition|(
operator|(
name|ml
operator|->
name|ml_name
operator|=
name|die_name
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ml
operator|->
name|ml_name
operator|=
name|NULL
expr_stmt|;
name|ml
operator|->
name|ml_type
operator|=
name|die_lookup_pass1
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|,
name|DW_AT_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|die_mem_offset
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|,
name|DW_AT_data_member_location
argument_list|,
operator|&
name|mloff
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: got mloff %llx\n"
argument_list|,
name|off
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|mloff
argument_list|)
expr_stmt|;
name|ml
operator|->
name|ml_offset
operator|=
name|mloff
operator|*
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|die_unsigned
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|,
name|DW_AT_bit_size
argument_list|,
operator|&
name|bitsz
argument_list|,
literal|0
argument_list|)
condition|)
name|ml
operator|->
name|ml_size
operator|=
name|bitsz
expr_stmt|;
else|else
name|ml
operator|->
name|ml_size
operator|=
name|tdesc_bitsize
argument_list|(
name|ml
operator|->
name|ml_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|die_unsigned
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|,
name|DW_AT_bit_offset
argument_list|,
operator|&
name|bitoff
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|_BIG_ENDIAN
name|ml
operator|->
name|ml_offset
operator|+=
name|bitoff
expr_stmt|;
else|#
directive|else
comment|/* 			 * Note that Clang 3.4 will sometimes generate 			 * member DIE before generating the DIE for the 			 * member's type. The code can not handle this 			 * properly so that tdesc_bitsize(ml->ml_type) will 			 * return 0 because ml->ml_type is unknown. As a 			 * result, a wrong member offset will be calculated. 			 * To workaround this, we can instead try to 			 * retrieve the value of DW_AT_byte_size attribute 			 * which stores the byte size of the space occupied 			 * by the type. If this attribute exists, its value 			 * should equal to tdesc_bitsize(ml->ml_type)/NBBY. 			 */
if|if
condition|(
name|die_unsigned
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|,
name|DW_AT_byte_size
argument_list|,
operator|&
name|bysz
argument_list|,
literal|0
argument_list|)
operator|&&
name|bysz
operator|>
literal|0
condition|)
name|ml
operator|->
name|ml_offset
operator|+=
name|bysz
operator|*
name|NBBY
operator|-
name|bitoff
operator|-
name|ml
operator|->
name|ml_size
expr_stmt|;
else|else
name|ml
operator|->
name|ml_offset
operator|+=
name|tdesc_bitsize
argument_list|(
name|ml
operator|->
name|ml_type
argument_list|)
operator|-
name|bitoff
operator|-
name|ml
operator|->
name|ml_size
expr_stmt|;
endif|#
directive|endif
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: mem %llu: created \"%s\" (off %u sz %u)\n"
argument_list|,
name|off
argument_list|,
name|memoff
argument_list|,
name|ml
operator|->
name|ml_name
argument_list|,
name|ml
operator|->
name|ml_offset
argument_list|,
name|ml
operator|->
name|ml_size
argument_list|)
expr_stmt|;
operator|*
name|mlastp
operator|=
name|ml
expr_stmt|;
name|mlastp
operator|=
operator|&
name|ml
operator|->
name|ml_next
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|mem
operator|=
name|die_sibling
argument_list|(
name|dw
argument_list|,
name|mem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* 	 * GCC will attempt to eliminate unused types, thus decreasing the 	 * size of the emitted dwarf.  That is, if you declare a foo_t in your 	 * header, include said header in your source file, and neglect to 	 * actually use (directly or indirectly) the foo_t in the source file, 	 * the foo_t won't make it into the emitted DWARF.  So, at least, goes 	 * the theory. 	 * 	 * Occasionally, it'll emit the DW_TAG_structure_type for the foo_t, 	 * and then neglect to emit the members.  Strangely, the loner struct 	 * tag will always be followed by a proper nested declaration of 	 * something else.  This is clearly a bug, but we're not going to have 	 * time to get it fixed before this goo goes back, so we'll have to work 	 * around it.  If we see a no-membered struct with a nested declaration 	 * (i.e. die_child of the struct tag won't be null), we'll ignore it. 	 * Being paranoid, we won't simply remove it from the hash.  Instead, 	 * we'll decline to create an iidesc for it, thus ensuring that this 	 * type won't make it into the output file.  To be safe, we'll also 	 * change the name. 	 */
if|if
condition|(
name|tdp
operator|->
name|t_members
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|old
init|=
name|tdesc_name
argument_list|(
name|tdp
argument_list|)
decl_stmt|;
name|size_t
name|newsz
init|=
literal|7
operator|+
name|strlen
argument_list|(
name|old
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
name|newsz
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|new
argument_list|,
name|newsz
argument_list|,
literal|"orphan %s"
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: worked around %s %s\n"
argument_list|,
name|off
argument_list|,
name|typename
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tdp
operator|->
name|t_name
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_name
operator|=
name|new
expr_stmt|;
return|return;
block|}
name|out
label|:
if|if
condition|(
name|tdp
operator|->
name|t_name
operator|!=
name|NULL
condition|)
block|{
name|ii
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|iidesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_type
operator|=
name|II_SOU
expr_stmt|;
name|ii
operator|->
name|ii_name
operator|=
name|xstrdup
argument_list|(
name|tdp
operator|->
name|t_name
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_dtype
operator|=
name|tdp
expr_stmt|;
name|iidesc_add
argument_list|(
name|dw
operator|->
name|dw_td
operator|->
name|td_iihash
argument_list|,
name|ii
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|die_struct_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|die_sou_create
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|off
argument_list|,
name|tdp
argument_list|,
name|STRUCT
argument_list|,
literal|"struct"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|die_union_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|die_sou_create
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|off
argument_list|,
name|tdp
argument_list|,
name|UNION
argument_list|,
literal|"union"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
specifier|static
name|int
name|die_sou_resolve
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|tdpp
name|__unused
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|dwarf_t
modifier|*
name|dw
init|=
name|private
decl_stmt|;
name|mlist_t
modifier|*
name|ml
decl_stmt|;
name|tdesc_t
modifier|*
name|mt
decl_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_flags
operator|&
name|TDESC_F_RESOLVED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"resolving sou %s\n"
argument_list|,
name|tdesc_name
argument_list|(
name|tdp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ml
operator|=
name|tdp
operator|->
name|t_members
init|;
name|ml
operator|!=
name|NULL
condition|;
name|ml
operator|=
name|ml
operator|->
name|ml_next
control|)
block|{
if|if
condition|(
name|ml
operator|->
name|ml_size
operator|==
literal|0
condition|)
block|{
name|mt
operator|=
name|tdesc_basetype
argument_list|(
name|ml
operator|->
name|ml_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ml
operator|->
name|ml_size
operator|=
name|tdesc_bitsize
argument_list|(
name|mt
argument_list|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* 			 * For empty members, or GCC/C99 flexible array 			 * members, a size of 0 is correct. 			 */
if|if
condition|(
name|mt
operator|->
name|t_members
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|mt
operator|->
name|t_type
operator|==
name|ARRAY
operator|&&
name|mt
operator|->
name|t_ardef
operator|->
name|ad_nelems
operator|==
literal|0
condition|)
continue|continue;
name|dw
operator|->
name|dw_nunres
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|mt
operator|=
name|tdesc_basetype
argument_list|(
name|ml
operator|->
name|ml_type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dw
operator|->
name|dw_nunres
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ml
operator|->
name|ml_size
operator|!=
literal|0
operator|&&
name|mt
operator|->
name|t_type
operator|==
name|INTRINSIC
operator|&&
name|mt
operator|->
name|t_intr
operator|->
name|intr_nbits
operator|!=
name|ml
operator|->
name|ml_size
condition|)
block|{
comment|/* 			 * This member is a bitfield, and needs to reference 			 * an intrinsic type with the same width.  If the 			 * currently-referenced type isn't of the same width, 			 * we'll copy it, adjusting the width of the copy to 			 * the size we'd like. 			 */
name|debug
argument_list|(
literal|3
argument_list|,
literal|"tdp %u: creating bitfield for %d bits\n"
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|,
name|ml
operator|->
name|ml_size
argument_list|)
expr_stmt|;
name|ml
operator|->
name|ml_type
operator|=
name|tdesc_intr_clone
argument_list|(
name|dw
argument_list|,
name|mt
argument_list|,
name|ml
operator|->
name|ml_size
argument_list|)
expr_stmt|;
block|}
block|}
name|tdp
operator|->
name|t_flags
operator||=
name|TDESC_F_RESOLVED
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
specifier|static
name|int
name|die_sou_failed
parameter_list|(
name|tdesc_t
modifier|*
name|tdp
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|tdpp
name|__unused
parameter_list|,
name|void
modifier|*
name|private
name|__unused
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|typename
init|=
operator|(
name|tdp
operator|->
name|t_type
operator|==
name|STRUCT
condition|?
literal|"struct"
else|:
literal|"union"
operator|)
decl_stmt|;
name|mlist_t
modifier|*
name|ml
decl_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_flags
operator|&
name|TDESC_F_RESOLVED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|ml
operator|=
name|tdp
operator|->
name|t_members
init|;
name|ml
operator|!=
name|NULL
condition|;
name|ml
operator|=
name|ml
operator|->
name|ml_next
control|)
block|{
if|if
condition|(
name|ml
operator|->
name|ml_size
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %d<%x>: failed to size member \"%s\" "
literal|"of type %s (%d<%x>)\n"
argument_list|,
name|typename
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|,
name|tdp
operator|->
name|t_id
argument_list|,
name|ml
operator|->
name|ml_name
argument_list|,
name|tdesc_name
argument_list|(
name|ml
operator|->
name|ml_type
argument_list|)
argument_list|,
name|ml
operator|->
name|ml_type
operator|->
name|t_id
argument_list|,
name|ml
operator|->
name|ml_type
operator|->
name|t_id
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|die_funcptr_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|Dwarf_Attribute
name|attr
decl_stmt|;
name|Dwarf_Half
name|tag
decl_stmt|;
name|Dwarf_Die
name|arg
decl_stmt|;
name|fndef_t
modifier|*
name|fn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu<%llx>: creating function pointer\n"
argument_list|,
name|off
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* 	 * We'll begin by processing any type definition nodes that may be 	 * lurking underneath this one. 	 */
for|for
control|(
name|arg
operator|=
name|die_child
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|die_sibling
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|tag
operator|=
name|die_tag
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
operator|)
operator|!=
name|DW_TAG_formal_parameter
operator|&&
name|tag
operator|!=
name|DW_TAG_unspecified_parameters
condition|)
block|{
comment|/* Nested type declaration */
name|die_create_one
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|die_isdecl
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
condition|)
block|{
comment|/* 		 * This is a prototype.  We don't add prototypes to the 		 * tree, so we're going to drop the tdesc.  Unfortunately, 		 * it has already been added to the tree.  Nobody will reference 		 * it, though, and it will be leaked. 		 */
return|return;
block|}
name|fn
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fndef_t
argument_list|)
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_type
operator|=
name|FUNCTION
expr_stmt|;
if|if
condition|(
operator|(
name|attr
operator|=
name|die_attr
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|DW_AT_type
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fn
operator|->
name|fn_ret
operator|=
name|die_lookup_pass1
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|DW_AT_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fn
operator|->
name|fn_ret
operator|=
name|tdesc_intr_void
argument_list|(
name|dw
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Count the arguments to the function, then read them in. 	 */
for|for
control|(
name|fn
operator|->
name|fn_nargs
operator|=
literal|0
operator|,
name|arg
operator|=
name|die_child
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|die_sibling
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|tag
operator|=
name|die_tag
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
operator|)
operator|==
name|DW_TAG_formal_parameter
condition|)
name|fn
operator|->
name|fn_nargs
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|tag
operator|==
name|DW_TAG_unspecified_parameters
operator|&&
name|fn
operator|->
name|fn_nargs
operator|>
literal|0
condition|)
name|fn
operator|->
name|fn_vargs
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fn
operator|->
name|fn_nargs
operator|!=
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: adding %d argument%s\n"
argument_list|,
name|off
argument_list|,
name|fn
operator|->
name|fn_nargs
argument_list|,
operator|(
name|fn
operator|->
name|fn_nargs
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|fn
operator|->
name|fn_args
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
operator|*
argument_list|)
operator|*
name|fn
operator|->
name|fn_nargs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|arg
operator|=
name|die_child
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
init|;
name|arg
operator|!=
name|NULL
operator|&&
name|i
operator|<
operator|(
name|int
operator|)
name|fn
operator|->
name|fn_nargs
condition|;
name|arg
operator|=
name|die_sibling
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
control|)
block|{
if|if
condition|(
name|die_tag
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
operator|!=
name|DW_TAG_formal_parameter
condition|)
continue|continue;
name|fn
operator|->
name|fn_args
index|[
name|i
operator|++
index|]
operator|=
name|die_lookup_pass1
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|,
name|DW_AT_type
argument_list|)
expr_stmt|;
block|}
block|}
name|tdp
operator|->
name|t_fndef
operator|=
name|fn
expr_stmt|;
name|tdp
operator|->
name|t_flags
operator||=
name|TDESC_F_RESOLVED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * GCC and DevPro use different names for the base types.  While the terms are  * the same, they are arranged in a different order.  Some terms, such as int,  * are implied in one, and explicitly named in the other.  Given a base type  * as input, this routine will return a common name, along with an intr_t  * that reflects said name.  */
end_comment

begin_function
specifier|static
name|intr_t
modifier|*
name|die_base_name_parse
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|newp
parameter_list|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|base
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
name|int
name|nlong
init|=
literal|0
decl_stmt|,
name|nshort
init|=
literal|0
decl_stmt|,
name|nchar
init|=
literal|0
decl_stmt|,
name|nint
init|=
literal|0
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
name|char
name|fmt
init|=
literal|'\0'
decl_stmt|;
name|intr_t
modifier|*
name|intr
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
condition|)
name|terminate
argument_list|(
literal|"base type name \"%s\" is too long\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|strtok
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" "
argument_list|)
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|c
argument_list|,
literal|"signed"
argument_list|)
operator|==
literal|0
condition|)
name|sign
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|c
argument_list|,
literal|"unsigned"
argument_list|)
operator|==
literal|0
condition|)
name|sign
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|c
argument_list|,
literal|"long"
argument_list|)
operator|==
literal|0
condition|)
name|nlong
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|c
argument_list|,
literal|"char"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nchar
operator|++
expr_stmt|;
name|fmt
operator|=
literal|'c'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|c
argument_list|,
literal|"short"
argument_list|)
operator|==
literal|0
condition|)
name|nshort
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|c
argument_list|,
literal|"int"
argument_list|)
operator|==
literal|0
condition|)
name|nint
operator|++
expr_stmt|;
else|else
block|{
comment|/* 			 * If we don't recognize any of the tokens, we'll tell 			 * the caller to fall back to the dwarf-provided 			 * encoding information. 			 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|nchar
operator|>
literal|1
operator|||
name|nshort
operator|>
literal|1
operator|||
name|nint
operator|>
literal|1
operator|||
name|nlong
operator|>
literal|2
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|nchar
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nlong
operator|>
literal|0
operator|||
name|nshort
operator|>
literal|0
operator|||
name|nint
operator|>
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|base
operator|=
literal|"char"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nshort
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nlong
operator|>
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|base
operator|=
literal|"short"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nlong
operator|>
literal|0
condition|)
block|{
name|base
operator|=
literal|"long"
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
literal|"int"
expr_stmt|;
block|}
name|intr
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|intr_t
argument_list|)
argument_list|)
expr_stmt|;
name|intr
operator|->
name|intr_type
operator|=
name|INTR_INT
expr_stmt|;
name|intr
operator|->
name|intr_signed
operator|=
name|sign
expr_stmt|;
name|intr
operator|->
name|intr_iformat
operator|=
name|fmt
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s%s"
argument_list|,
operator|(
name|sign
condition|?
literal|""
else|:
literal|"unsigned "
operator|)
argument_list|,
operator|(
name|nlong
operator|>
literal|1
condition|?
literal|"long "
else|:
literal|""
operator|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
operator|*
name|newp
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|intr
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|fp_size_map
block|{
name|size_t
name|fsm_typesz
index|[
literal|2
index|]
decl_stmt|;
comment|/* size of {32,64} type */
name|uint_t
name|fsm_enc
index|[
literal|3
index|]
decl_stmt|;
comment|/* CTF_FP_* for {bare,cplx,imagry} type */
block|}
name|fp_size_map_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|fp_size_map_t
name|fp_encodings
index|[]
init|=
block|{
block|{
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
name|CTF_FP_SINGLE
block|,
name|CTF_FP_CPLX
block|,
name|CTF_FP_IMAGRY
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|8
block|}
block|,
block|{
name|CTF_FP_DOUBLE
block|,
name|CTF_FP_DCPLX
block|,
name|CTF_FP_DIMAGRY
block|}
block|}
block|,
ifdef|#
directive|ifdef
name|__sparc
block|{
block|{
literal|16
block|,
literal|16
block|}
block|,
block|{
name|CTF_FP_LDOUBLE
block|,
name|CTF_FP_LDCPLX
block|,
name|CTF_FP_LDIMAGRY
block|}
block|}
block|,
else|#
directive|else
block|{
block|{
literal|12
block|,
literal|16
block|}
block|,
block|{
name|CTF_FP_LDOUBLE
block|,
name|CTF_FP_LDCPLX
block|,
name|CTF_FP_LDIMAGRY
block|}
block|}
block|,
endif|#
directive|endif
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint_t
name|die_base_type2enc
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|Dwarf_Signed
name|enc
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
specifier|const
name|fp_size_map_t
modifier|*
name|map
init|=
name|fp_encodings
decl_stmt|;
name|uint_t
name|szidx
init|=
name|dw
operator|->
name|dw_ptrsz
operator|==
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
decl_stmt|;
name|uint_t
name|mult
init|=
literal|1
decl_stmt|,
name|col
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|enc
operator|==
name|DW_ATE_complex_float
condition|)
block|{
name|mult
operator|=
literal|2
expr_stmt|;
name|col
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|enc
operator|==
name|DW_ATE_imaginary_float
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|||
name|enc
operator|==
name|DW_ATE_SUN_imaginary_float
endif|#
directive|endif
condition|)
name|col
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|map
operator|->
name|fsm_typesz
index|[
name|szidx
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|map
operator|->
name|fsm_typesz
index|[
name|szidx
index|]
operator|*
name|mult
operator|==
name|sz
condition|)
return|return
operator|(
name|map
operator|->
name|fsm_enc
index|[
name|col
index|]
operator|)
return|;
name|map
operator|++
expr_stmt|;
block|}
name|terminate
argument_list|(
literal|"die %llu: unrecognized real type size %u\n"
argument_list|,
name|off
argument_list|,
name|sz
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|intr_t
modifier|*
name|die_base_from_dwarf
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|base
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|intr_t
modifier|*
name|intr
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|intr_t
argument_list|)
argument_list|)
decl_stmt|;
name|Dwarf_Signed
name|enc
decl_stmt|;
operator|(
name|void
operator|)
name|die_signed
argument_list|(
name|dw
argument_list|,
name|base
argument_list|,
name|DW_AT_encoding
argument_list|,
operator|&
name|enc
argument_list|,
name|DW_ATTR_REQ
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|enc
condition|)
block|{
case|case
name|DW_ATE_unsigned
case|:
case|case
name|DW_ATE_address
case|:
name|intr
operator|->
name|intr_type
operator|=
name|INTR_INT
expr_stmt|;
break|break;
case|case
name|DW_ATE_unsigned_char
case|:
name|intr
operator|->
name|intr_type
operator|=
name|INTR_INT
expr_stmt|;
name|intr
operator|->
name|intr_iformat
operator|=
literal|'c'
expr_stmt|;
break|break;
case|case
name|DW_ATE_signed
case|:
name|intr
operator|->
name|intr_type
operator|=
name|INTR_INT
expr_stmt|;
name|intr
operator|->
name|intr_signed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_ATE_signed_char
case|:
name|intr
operator|->
name|intr_type
operator|=
name|INTR_INT
expr_stmt|;
name|intr
operator|->
name|intr_signed
operator|=
literal|1
expr_stmt|;
name|intr
operator|->
name|intr_iformat
operator|=
literal|'c'
expr_stmt|;
break|break;
case|case
name|DW_ATE_boolean
case|:
name|intr
operator|->
name|intr_type
operator|=
name|INTR_INT
expr_stmt|;
name|intr
operator|->
name|intr_signed
operator|=
literal|1
expr_stmt|;
name|intr
operator|->
name|intr_iformat
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
name|DW_ATE_float
case|:
case|case
name|DW_ATE_complex_float
case|:
case|case
name|DW_ATE_imaginary_float
case|:
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
case|case
name|DW_ATE_SUN_imaginary_float
case|:
case|case
name|DW_ATE_SUN_interval_float
case|:
endif|#
directive|endif
name|intr
operator|->
name|intr_type
operator|=
name|INTR_REAL
expr_stmt|;
name|intr
operator|->
name|intr_signed
operator|=
literal|1
expr_stmt|;
name|intr
operator|->
name|intr_fformat
operator|=
name|die_base_type2enc
argument_list|(
name|dw
argument_list|,
name|off
argument_list|,
name|enc
argument_list|,
name|sz
argument_list|)
expr_stmt|;
break|break;
default|default:
name|terminate
argument_list|(
literal|"die %llu: unknown base type encoding 0x%llx\n"
argument_list|,
name|off
argument_list|,
name|enc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|intr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|die_base_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|base
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|Dwarf_Unsigned
name|sz
decl_stmt|;
name|intr_t
modifier|*
name|intr
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: creating base type\n"
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* 	 * The compilers have their own clever (internally inconsistent) ideas 	 * as to what base types should look like.  Some times gcc will, for 	 * example, use DW_ATE_signed_char for char.  Other times, however, it 	 * will use DW_ATE_signed.  Needless to say, this causes some problems 	 * down the road, particularly with merging.  We do, however, use the 	 * DWARF idea of type sizes, as this allows us to avoid caring about 	 * the data model. 	 */
operator|(
name|void
operator|)
name|die_unsigned
argument_list|(
name|dw
argument_list|,
name|base
argument_list|,
name|DW_AT_byte_size
argument_list|,
operator|&
name|sz
argument_list|,
name|DW_ATTR_REQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdp
operator|->
name|t_name
operator|==
name|NULL
condition|)
name|terminate
argument_list|(
literal|"die %llu: base type without name\n"
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* XXX make a name parser for float too */
if|if
condition|(
operator|(
name|intr
operator|=
name|die_base_name_parse
argument_list|(
name|tdp
operator|->
name|t_name
argument_list|,
operator|&
name|new
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Found it.  We'll use the parsed version */
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: name \"%s\" remapped to \"%s\"\n"
argument_list|,
name|off
argument_list|,
name|tdesc_name
argument_list|(
name|tdp
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tdp
operator|->
name|t_name
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_name
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We didn't recognize the type, so we'll create an intr_t 		 * based on the DWARF data. 		 */
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: using dwarf data for base \"%s\"\n"
argument_list|,
name|off
argument_list|,
name|tdesc_name
argument_list|(
name|tdp
argument_list|)
argument_list|)
expr_stmt|;
name|intr
operator|=
name|die_base_from_dwarf
argument_list|(
name|dw
argument_list|,
name|base
argument_list|,
name|off
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
name|intr
operator|->
name|intr_nbits
operator|=
name|sz
operator|*
literal|8
expr_stmt|;
name|tdp
operator|->
name|t_type
operator|=
name|INTRINSIC
expr_stmt|;
name|tdp
operator|->
name|t_intr
operator|=
name|intr
expr_stmt|;
name|tdp
operator|->
name|t_size
operator|=
name|sz
expr_stmt|;
name|tdp
operator|->
name|t_flags
operator||=
name|TDESC_F_RESOLVED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|die_through_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|typename
parameter_list|)
block|{
name|Dwarf_Attribute
name|attr
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu<%llx>: creating %s type %d\n"
argument_list|,
name|off
argument_list|,
name|off
argument_list|,
name|typename
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|attr
operator|=
name|die_attr
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|DW_AT_type
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|tdp
operator|->
name|t_tdesc
operator|=
name|die_lookup_pass1
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|DW_AT_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tdp
operator|->
name|t_tdesc
operator|=
name|tdesc_intr_void
argument_list|(
name|dw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|POINTER
condition|)
name|tdp
operator|->
name|t_size
operator|=
name|dw
operator|->
name|dw_ptrsz
expr_stmt|;
name|tdp
operator|->
name|t_flags
operator||=
name|TDESC_F_RESOLVED
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPEDEF
condition|)
block|{
name|iidesc_t
modifier|*
name|ii
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|iidesc_t
argument_list|)
argument_list|)
decl_stmt|;
name|ii
operator|->
name|ii_type
operator|=
name|II_TYPE
expr_stmt|;
name|ii
operator|->
name|ii_name
operator|=
name|xstrdup
argument_list|(
name|tdp
operator|->
name|t_name
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_dtype
operator|=
name|tdp
expr_stmt|;
name|iidesc_add
argument_list|(
name|dw
operator|->
name|dw_td
operator|->
name|td_iihash
argument_list|,
name|ii
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|die_typedef_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|die_through_create
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|off
argument_list|,
name|tdp
argument_list|,
name|TYPEDEF
argument_list|,
literal|"typedef"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|die_const_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|die_through_create
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|off
argument_list|,
name|tdp
argument_list|,
name|CONST
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|die_pointer_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|die_through_create
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|off
argument_list|,
name|tdp
argument_list|,
name|POINTER
argument_list|,
literal|"pointer"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|die_restrict_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|die_through_create
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|off
argument_list|,
name|tdp
argument_list|,
name|RESTRICT
argument_list|,
literal|"restrict"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|die_volatile_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
parameter_list|)
block|{
name|die_through_create
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|off
argument_list|,
name|tdp
argument_list|,
name|VOLATILE
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED3*/
end_comment

begin_function
specifier|static
name|void
name|die_function_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
name|__unused
parameter_list|)
block|{
name|Dwarf_Die
name|arg
decl_stmt|;
name|Dwarf_Half
name|tag
decl_stmt|;
name|iidesc_t
modifier|*
name|ii
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu<%llx>: creating function definition\n"
argument_list|,
name|off
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* 	 * We'll begin by processing any type definition nodes that may be 	 * lurking underneath this one. 	 */
for|for
control|(
name|arg
operator|=
name|die_child
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|die_sibling
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|tag
operator|=
name|die_tag
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
operator|)
operator|!=
name|DW_TAG_formal_parameter
operator|&&
name|tag
operator|!=
name|DW_TAG_variable
condition|)
block|{
comment|/* Nested type declaration */
name|die_create_one
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|die_isdecl
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
operator|||
operator|(
name|name
operator|=
name|die_name
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We process neither prototypes nor subprograms without 		 * names. 		 */
return|return;
block|}
name|ii
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|iidesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_type
operator|=
name|die_isglobal
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
condition|?
name|II_GFUN
else|:
name|II_SFUN
expr_stmt|;
name|ii
operator|->
name|ii_name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_type
operator|==
name|II_SFUN
condition|)
name|ii
operator|->
name|ii_owner
operator|=
name|xstrdup
argument_list|(
name|dw
operator|->
name|dw_cuname
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: function %s is %s\n"
argument_list|,
name|off
argument_list|,
name|ii
operator|->
name|ii_name
argument_list|,
operator|(
name|ii
operator|->
name|ii_type
operator|==
name|II_GFUN
condition|?
literal|"global"
else|:
literal|"static"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|die_attr
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|DW_AT_type
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL
condition|)
name|ii
operator|->
name|ii_dtype
operator|=
name|die_lookup_pass1
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|DW_AT_type
argument_list|)
expr_stmt|;
else|else
name|ii
operator|->
name|ii_dtype
operator|=
name|tdesc_intr_void
argument_list|(
name|dw
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|die_child
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|die_sibling
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
control|)
block|{
name|char
modifier|*
name|name1
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: looking at sub member at %llu\n"
argument_list|,
name|off
argument_list|,
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|die_tag
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
operator|!=
name|DW_TAG_formal_parameter
condition|)
continue|continue;
if|if
condition|(
operator|(
name|name1
operator|=
name|die_name
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|terminate
argument_list|(
literal|"die %llu: func arg %d has no name\n"
argument_list|,
name|off
argument_list|,
name|ii
operator|->
name|ii_nargs
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name1
argument_list|,
literal|"..."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|name1
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_vargs
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|ii
operator|->
name|ii_nargs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ii
operator|->
name|ii_nargs
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: function has %d argument%s\n"
argument_list|,
name|off
argument_list|,
name|ii
operator|->
name|ii_nargs
argument_list|,
operator|(
name|ii
operator|->
name|ii_nargs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_args
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
argument_list|)
operator|*
name|ii
operator|->
name|ii_nargs
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|die_child
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|arg
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|ii
operator|->
name|ii_nargs
condition|;
name|arg
operator|=
name|die_sibling
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
control|)
block|{
if|if
condition|(
name|die_tag
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|)
operator|!=
name|DW_TAG_formal_parameter
condition|)
continue|continue;
name|ii
operator|->
name|ii_args
index|[
name|i
operator|++
index|]
operator|=
name|die_lookup_pass1
argument_list|(
name|dw
argument_list|,
name|arg
argument_list|,
name|DW_AT_type
argument_list|)
expr_stmt|;
block|}
block|}
name|iidesc_add
argument_list|(
name|dw
operator|->
name|dw_td
operator|->
name|td_iihash
argument_list|,
name|ii
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED3*/
end_comment

begin_function
specifier|static
name|void
name|die_variable_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
name|__unused
parameter_list|)
block|{
name|iidesc_t
modifier|*
name|ii
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu: creating object definition\n"
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|die_isdecl
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
operator|||
operator|(
name|name
operator|=
name|die_name
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* skip prototypes and nameless objects */
name|ii
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|iidesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_type
operator|=
name|die_isglobal
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
condition|?
name|II_GVAR
else|:
name|II_SVAR
expr_stmt|;
name|ii
operator|->
name|ii_name
operator|=
name|name
expr_stmt|;
name|ii
operator|->
name|ii_dtype
operator|=
name|die_lookup_pass1
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|DW_AT_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_type
operator|==
name|II_SVAR
condition|)
name|ii
operator|->
name|ii_owner
operator|=
name|xstrdup
argument_list|(
name|dw
operator|->
name|dw_cuname
argument_list|)
expr_stmt|;
name|iidesc_add
argument_list|(
name|dw
operator|->
name|dw_td
operator|->
name|td_iihash
argument_list|,
name|ii
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED2*/
end_comment

begin_function
specifier|static
name|int
name|die_fwd_resolve
parameter_list|(
name|tdesc_t
modifier|*
name|fwd
parameter_list|,
name|tdesc_t
modifier|*
modifier|*
name|fwdp
parameter_list|,
name|void
modifier|*
name|private
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|fwd
operator|->
name|t_flags
operator|&
name|TDESC_F_RESOLVED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|fwd
operator|->
name|t_tdesc
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"tdp %u: unforwarded %s\n"
argument_list|,
name|fwd
operator|->
name|t_id
argument_list|,
name|tdesc_name
argument_list|(
name|fwd
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|fwdp
operator|=
name|fwd
operator|->
name|t_tdesc
expr_stmt|;
block|}
name|fwd
operator|->
name|t_flags
operator||=
name|TDESC_F_RESOLVED
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|die_lexblk_descend
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Off
name|off
name|__unused
parameter_list|,
name|tdesc_t
modifier|*
name|tdp
name|__unused
parameter_list|)
block|{
name|Dwarf_Die
name|child
init|=
name|die_child
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
name|die_create
argument_list|(
name|dw
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Used to map the die to a routine which can parse it, using the tag to do the  * mapping.  While the processing of most tags entails the creation of a tdesc,  * there are a few which don't - primarily those which result in the creation of  * iidescs which refer to existing tdescs.  */
end_comment

begin_define
define|#
directive|define
name|DW_F_NOTDP
value|0x1
end_define

begin_comment
comment|/* Don't create a tdesc for the creator */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|die_creator
block|{
name|Dwarf_Half
name|dc_tag
decl_stmt|;
name|uint16_t
name|dc_flags
decl_stmt|;
name|void
function_decl|(
modifier|*
name|dc_create
function_decl|)
parameter_list|(
name|dwarf_t
modifier|*
parameter_list|,
name|Dwarf_Die
parameter_list|,
name|Dwarf_Off
parameter_list|,
name|tdesc_t
modifier|*
parameter_list|)
function_decl|;
block|}
name|die_creator_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|die_creator_t
name|die_creators
index|[]
init|=
block|{
block|{
name|DW_TAG_array_type
block|,
literal|0
block|,
name|die_array_create
block|}
block|,
block|{
name|DW_TAG_enumeration_type
block|,
literal|0
block|,
name|die_enum_create
block|}
block|,
block|{
name|DW_TAG_lexical_block
block|,
name|DW_F_NOTDP
block|,
name|die_lexblk_descend
block|}
block|,
block|{
name|DW_TAG_pointer_type
block|,
literal|0
block|,
name|die_pointer_create
block|}
block|,
block|{
name|DW_TAG_structure_type
block|,
literal|0
block|,
name|die_struct_create
block|}
block|,
block|{
name|DW_TAG_subroutine_type
block|,
literal|0
block|,
name|die_funcptr_create
block|}
block|,
block|{
name|DW_TAG_typedef
block|,
literal|0
block|,
name|die_typedef_create
block|}
block|,
block|{
name|DW_TAG_union_type
block|,
literal|0
block|,
name|die_union_create
block|}
block|,
block|{
name|DW_TAG_base_type
block|,
literal|0
block|,
name|die_base_create
block|}
block|,
block|{
name|DW_TAG_const_type
block|,
literal|0
block|,
name|die_const_create
block|}
block|,
block|{
name|DW_TAG_subprogram
block|,
name|DW_F_NOTDP
block|,
name|die_function_create
block|}
block|,
block|{
name|DW_TAG_variable
block|,
name|DW_F_NOTDP
block|,
name|die_variable_create
block|}
block|,
block|{
name|DW_TAG_volatile_type
block|,
literal|0
block|,
name|die_volatile_create
block|}
block|,
block|{
name|DW_TAG_restrict_type
block|,
literal|0
block|,
name|die_restrict_create
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|die_creator_t
modifier|*
name|die_tag2ctor
parameter_list|(
name|Dwarf_Half
name|tag
parameter_list|)
block|{
specifier|const
name|die_creator_t
modifier|*
name|dc
decl_stmt|;
for|for
control|(
name|dc
operator|=
name|die_creators
init|;
name|dc
operator|->
name|dc_create
operator|!=
name|NULL
condition|;
name|dc
operator|++
control|)
block|{
if|if
condition|(
name|dc
operator|->
name|dc_tag
operator|==
name|tag
condition|)
return|return
operator|(
name|dc
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|die_create_one
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|)
block|{
name|Dwarf_Off
name|off
init|=
name|die_off
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
decl_stmt|;
specifier|const
name|die_creator_t
modifier|*
name|dc
decl_stmt|;
name|Dwarf_Half
name|tag
decl_stmt|;
name|tdesc_t
modifier|*
name|tdp
decl_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"die %llu<%llx>: create_one\n"
argument_list|,
name|off
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>
name|dw
operator|->
name|dw_maxoff
condition|)
block|{
name|terminate
argument_list|(
literal|"illegal die offset %llu (max %llu)\n"
argument_list|,
name|off
argument_list|,
name|dw
operator|->
name|dw_maxoff
argument_list|)
expr_stmt|;
block|}
name|tag
operator|=
name|die_tag
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dc
operator|=
name|die_tag2ctor
argument_list|(
name|tag
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"die %llu: ignoring tag type %x\n"
argument_list|,
name|off
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|tdp
operator|=
name|tdesc_lookup
argument_list|(
name|dw
argument_list|,
name|off
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|dc
operator|->
name|dc_flags
operator|&
name|DW_F_NOTDP
operator|)
condition|)
block|{
name|tdp
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|t_id
operator|=
name|off
expr_stmt|;
name|tdesc_add
argument_list|(
name|dw
argument_list|,
name|tdp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tdp
operator|!=
name|NULL
condition|)
name|tdp
operator|->
name|t_name
operator|=
name|die_name
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
expr_stmt|;
name|dc
operator|->
name|dc_create
argument_list|(
name|dw
argument_list|,
name|die
argument_list|,
name|off
argument_list|,
name|tdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|die_create
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|)
block|{
do|do
block|{
name|die_create_one
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|die
operator|=
name|die_sibling
argument_list|(
name|dw
argument_list|,
name|die
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_decl_stmt
specifier|static
name|tdtrav_cb_f
name|die_resolvers
index|[]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
comment|/* intrinsic */
name|NULL
block|,
comment|/* pointer */
name|die_array_resolve
block|,
comment|/* array */
name|NULL
block|,
comment|/* function */
name|die_sou_resolve
block|,
comment|/* struct */
name|die_sou_resolve
block|,
comment|/* union */
name|die_enum_resolve
block|,
comment|/* enum */
name|die_fwd_resolve
block|,
comment|/* forward */
name|NULL
block|,
comment|/* typedef */
name|NULL
block|,
comment|/* typedef unres */
name|NULL
block|,
comment|/* volatile */
name|NULL
block|,
comment|/* const */
name|NULL
block|,
comment|/* restrict */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tdtrav_cb_f
name|die_fail_reporters
index|[]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
comment|/* intrinsic */
name|NULL
block|,
comment|/* pointer */
name|die_array_failed
block|,
comment|/* array */
name|NULL
block|,
comment|/* function */
name|die_sou_failed
block|,
comment|/* struct */
name|die_sou_failed
block|,
comment|/* union */
name|NULL
block|,
comment|/* enum */
name|NULL
block|,
comment|/* forward */
name|NULL
block|,
comment|/* typedef */
name|NULL
block|,
comment|/* typedef unres */
name|NULL
block|,
comment|/* volatile */
name|NULL
block|,
comment|/* const */
name|NULL
block|,
comment|/* restrict */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|die_resolve
parameter_list|(
name|dwarf_t
modifier|*
name|dw
parameter_list|)
block|{
name|int
name|last
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|pass
init|=
literal|0
decl_stmt|;
do|do
block|{
name|pass
operator|++
expr_stmt|;
name|dw
operator|->
name|dw_nunres
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|iitraverse_hash
argument_list|(
name|dw
operator|->
name|dw_td
operator|->
name|td_iihash
argument_list|,
operator|&
name|dw
operator|->
name|dw_td
operator|->
name|td_curvgen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|die_resolvers
argument_list|,
name|dw
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"resolve: pass %d, %u left\n"
argument_list|,
name|pass
argument_list|,
name|dw
operator|->
name|dw_nunres
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|dw
operator|->
name|dw_nunres
operator|==
name|last
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: failed to resolve the following "
literal|"types:\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|iitraverse_hash
argument_list|(
name|dw
operator|->
name|dw_td
operator|->
name|td_iihash
argument_list|,
operator|&
name|dw
operator|->
name|dw_td
operator|->
name|td_curvgen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|die_fail_reporters
argument_list|,
name|dw
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|"failed to resolve types\n"
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|dw
operator|->
name|dw_nunres
expr_stmt|;
block|}
do|while
condition|(
name|dw
operator|->
name|dw_nunres
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Any object containing a function or object symbol at any scope should also  * contain DWARF data.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|should_have_dwarf
parameter_list|(
name|Elf
modifier|*
name|elf
parameter_list|)
block|{
name|Elf_Scn
modifier|*
name|scn
init|=
name|NULL
decl_stmt|;
name|Elf_Data
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|GElf_Shdr
name|shdr
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|uint32_t
name|symdx
init|=
literal|0
decl_stmt|;
name|size_t
name|nsyms
init|=
literal|0
decl_stmt|;
name|boolean_t
name|found
init|=
name|B_FALSE
decl_stmt|;
while|while
condition|(
operator|(
name|scn
operator|=
name|elf_nextscn
argument_list|(
name|elf
argument_list|,
name|scn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|shdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|shdr
operator|.
name|sh_type
operator|==
name|SHT_SYMTAB
condition|)
block|{
name|found
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|terminate
argument_list|(
literal|"cannot convert stripped objects\n"
argument_list|)
expr_stmt|;
name|data
operator|=
name|elf_getdata
argument_list|(
name|scn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|shdr
operator|.
name|sh_size
operator|/
name|shdr
operator|.
name|sh_entsize
expr_stmt|;
for|for
control|(
name|symdx
operator|=
literal|0
init|;
name|symdx
operator|<
name|nsyms
condition|;
name|symdx
operator|++
control|)
block|{
name|gelf_getsym
argument_list|(
name|data
argument_list|,
name|symdx
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_FUNC
operator|)
operator|||
operator|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_TLS
operator|)
operator|||
operator|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_OBJECT
operator|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|elf_strptr
argument_list|(
name|elf
argument_list|,
name|shdr
operator|.
name|sh_link
argument_list|,
name|sym
operator|.
name|st_name
argument_list|)
expr_stmt|;
comment|/* Studio emits these local symbols regardless */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Bbss.bss"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Ttbss.bss"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Ddata.data"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Ttdata.data"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Drodata.rodata"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|dw_read
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|Elf
modifier|*
name|elf
parameter_list|,
name|char
modifier|*
name|filename
name|__unused
parameter_list|)
block|{
name|Dwarf_Unsigned
name|abboff
decl_stmt|,
name|hdrlen
decl_stmt|,
name|nxthdr
decl_stmt|;
name|Dwarf_Half
name|vers
decl_stmt|,
name|addrsz
decl_stmt|;
name|Dwarf_Die
name|cu
init|=
literal|0
decl_stmt|;
name|Dwarf_Die
name|child
init|=
literal|0
decl_stmt|;
name|dwarf_t
name|dw
decl_stmt|;
name|char
modifier|*
name|prod
init|=
name|NULL
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|dw
argument_list|,
sizeof|sizeof
argument_list|(
name|dwarf_t
argument_list|)
argument_list|)
expr_stmt|;
name|dw
operator|.
name|dw_td
operator|=
name|td
expr_stmt|;
name|dw
operator|.
name|dw_ptrsz
operator|=
name|elf_ptrsz
argument_list|(
name|elf
argument_list|)
expr_stmt|;
name|dw
operator|.
name|dw_mfgtid_last
operator|=
name|TID_MFGTID_BASE
expr_stmt|;
name|dw
operator|.
name|dw_tidhash
operator|=
name|hash_new
argument_list|(
name|TDESC_HASH_BUCKETS
argument_list|,
name|tdesc_idhash
argument_list|,
name|tdesc_idcmp
argument_list|)
expr_stmt|;
name|dw
operator|.
name|dw_fwdhash
operator|=
name|hash_new
argument_list|(
name|TDESC_HASH_BUCKETS
argument_list|,
name|tdesc_namehash
argument_list|,
name|tdesc_namecmp
argument_list|)
expr_stmt|;
name|dw
operator|.
name|dw_enumhash
operator|=
name|hash_new
argument_list|(
name|TDESC_HASH_BUCKETS
argument_list|,
name|tdesc_namehash
argument_list|,
name|tdesc_namecmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|dwarf_elf_init
argument_list|(
name|elf
argument_list|,
name|DW_DLC_READ
argument_list|,
operator|&
name|dw
operator|.
name|dw_dw
argument_list|,
operator|&
name|dw
operator|.
name|dw_err
argument_list|)
operator|)
operator|==
name|DW_DLV_NO_ENTRY
condition|)
block|{
if|if
condition|(
name|should_have_dwarf
argument_list|(
name|elf
argument_list|)
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
name|DW_DLV_OK
condition|)
block|{
if|if
condition|(
name|dwarf_errno
argument_list|(
operator|&
name|dw
operator|.
name|dw_err
argument_list|)
operator|==
name|DW_DLE_DEBUG_INFO_NULL
condition|)
block|{
comment|/* 			 * There's no type data in the DWARF section, but 			 * libdwarf is too clever to handle that properly. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|terminate
argument_list|(
literal|"failed to initialize DWARF: %s\n"
argument_list|,
name|dwarf_errmsg
argument_list|(
operator|&
name|dw
operator|.
name|dw_err
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|dwarf_next_cu_header
argument_list|(
name|dw
operator|.
name|dw_dw
argument_list|,
operator|&
name|hdrlen
argument_list|,
operator|&
name|vers
argument_list|,
operator|&
name|abboff
argument_list|,
operator|&
name|addrsz
argument_list|,
operator|&
name|nxthdr
argument_list|,
operator|&
name|dw
operator|.
name|dw_err
argument_list|)
operator|)
operator|!=
name|DW_DLV_OK
condition|)
name|terminate
argument_list|(
literal|"rc = %d %s\n"
argument_list|,
name|rc
argument_list|,
name|dwarf_errmsg
argument_list|(
operator|&
name|dw
operator|.
name|dw_err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cu
operator|=
name|die_sibling
argument_list|(
operator|&
name|dw
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|(
operator|(
name|child
operator|=
name|die_child
argument_list|(
operator|&
name|dw
argument_list|,
name|cu
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|&&
name|should_have_dwarf
argument_list|(
name|elf
argument_list|)
operator|)
condition|)
block|{
name|terminate
argument_list|(
literal|"file does not contain dwarf type data "
literal|"(try compiling with -g)\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dw
operator|.
name|dw_maxoff
operator|=
name|nxthdr
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dw
operator|.
name|dw_maxoff
operator|>
name|TID_FILEMAX
condition|)
name|terminate
argument_list|(
literal|"file contains too many types\n"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"DWARF version: %d\n"
argument_list|,
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|!=
name|DWARF_VERSION
condition|)
block|{
name|terminate
argument_list|(
literal|"file contains incompatible version %d DWARF code "
literal|"(version 2 required)\n"
argument_list|,
name|vers
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|die_string
argument_list|(
operator|&
name|dw
argument_list|,
name|cu
argument_list|,
name|DW_AT_producer
argument_list|,
operator|&
name|prod
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|1
argument_list|,
literal|"DWARF emitter: %s\n"
argument_list|,
name|prod
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prod
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dw
operator|.
name|dw_cuname
operator|=
name|die_name
argument_list|(
operator|&
name|dw
argument_list|,
name|cu
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|base
init|=
name|xstrdup
argument_list|(
name|basename
argument_list|(
name|dw
operator|.
name|dw_cuname
argument_list|)
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|dw
operator|.
name|dw_cuname
argument_list|)
expr_stmt|;
name|dw
operator|.
name|dw_cuname
operator|=
name|base
expr_stmt|;
name|debug
argument_list|(
literal|1
argument_list|,
literal|"CU name: %s\n"
argument_list|,
name|dw
operator|.
name|dw_cuname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|child
operator|=
name|die_child
argument_list|(
operator|&
name|dw
argument_list|,
name|cu
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|die_create
argument_list|(
operator|&
name|dw
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|dwarf_next_cu_header
argument_list|(
name|dw
operator|.
name|dw_dw
argument_list|,
operator|&
name|hdrlen
argument_list|,
operator|&
name|vers
argument_list|,
operator|&
name|abboff
argument_list|,
operator|&
name|addrsz
argument_list|,
operator|&
name|nxthdr
argument_list|,
operator|&
name|dw
operator|.
name|dw_err
argument_list|)
operator|)
operator|!=
name|DW_DLV_NO_ENTRY
condition|)
name|terminate
argument_list|(
literal|"multiple compilation units not supported\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dwarf_finish
argument_list|(
operator|&
name|dw
operator|.
name|dw_dw
argument_list|,
operator|&
name|dw
operator|.
name|dw_err
argument_list|)
expr_stmt|;
name|die_resolve
argument_list|(
operator|&
name|dw
argument_list|)
expr_stmt|;
name|cvt_fixups
argument_list|(
name|td
argument_list|,
name|dw
operator|.
name|dw_ptrsz
argument_list|)
expr_stmt|;
comment|/* leak the dwarf_t */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

