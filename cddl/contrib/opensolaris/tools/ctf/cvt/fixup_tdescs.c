begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * Workarounds for stabs generation bugs in the compiler and general needed  * fixups.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|"ctf_headers.h"
end_include

begin_include
include|#
directive|include
file|"ctftools.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_comment
comment|/*  * Due to 4432619, the 6.1 compiler will sometimes incorrectly generate pointer  * stabs.  Given a struct foo, and a corresponding typedef struct foo foo_t.  * In some cases, when faced with a pointer to a foo_t, the compiler will  * sometimes generate a stab that describes a pointer to a struct foo.  * Regardless of correctness, this breaks merges, as it occurs inconsistently  * by file.  The following two routines know how to recognize and repair foo_t *  * and foo_t ** bugs in a specific set of cases.  There is no general way to  * solve this problem without a fix to the compiler.  In general, cases should  * only be added to these routines to fix merging problems in genunix.  */
end_comment

begin_function
specifier|static
name|void
name|fix_ptrptr_to_struct
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|strs
index|[
literal|2
index|]
init|=
block|{
literal|"as"
block|,
literal|"fdbuffer"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|mems
index|[
literal|2
index|]
init|=
block|{
literal|"a_objectdir"
block|,
literal|"fd_shadow"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|acts
index|[
literal|2
index|]
init|=
block|{
literal|"vnode"
block|,
literal|"page"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|tgts
index|[
literal|2
index|]
init|=
block|{
literal|"vnode_t"
block|,
literal|"page_t"
block|}
decl_stmt|;
name|tdesc_t
modifier|*
name|str
decl_stmt|;
name|tdesc_t
modifier|*
name|act
decl_stmt|,
modifier|*
name|tgt
decl_stmt|;
name|tdesc_t
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|mlist_t
modifier|*
name|ml
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|strs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|strs
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|str
operator|=
name|lookupname
argument_list|(
name|strs
index|[
name|i
index|]
argument_list|)
operator|)
operator|||
name|str
operator|->
name|t_type
operator|!=
name|STRUCT
condition|)
continue|continue;
for|for
control|(
name|ml
operator|=
name|str
operator|->
name|t_members
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|ml_next
control|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|ml
operator|->
name|ml_name
argument_list|,
name|mems
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|ml
condition|)
continue|continue;
if|if
condition|(
name|ml
operator|->
name|ml_type
operator|->
name|t_type
operator|!=
name|POINTER
operator|||
name|ml
operator|->
name|ml_type
operator|->
name|t_name
operator|||
name|ml
operator|->
name|ml_type
operator|->
name|t_tdesc
operator|->
name|t_type
operator|!=
name|POINTER
operator|||
name|ml
operator|->
name|ml_type
operator|->
name|t_tdesc
operator|->
name|t_name
condition|)
continue|continue;
name|act
operator|=
name|ml
operator|->
name|ml_type
operator|->
name|t_tdesc
operator|->
name|t_tdesc
expr_stmt|;
if|if
condition|(
name|act
operator|->
name|t_type
operator|!=
name|STRUCT
operator|||
operator|!
name|streq
argument_list|(
name|act
operator|->
name|t_name
argument_list|,
name|acts
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|tgt
operator|=
name|lookupname
argument_list|(
name|tgts
index|[
name|i
index|]
argument_list|)
operator|)
operator|||
name|tgt
operator|->
name|t_type
operator|!=
name|TYPEDEF
condition|)
continue|continue;
comment|/* We have an instance of the bug */
name|p2
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|p2
operator|->
name|t_type
operator|=
name|POINTER
expr_stmt|;
name|p2
operator|->
name|t_id
operator|=
name|td
operator|->
name|td_nextid
operator|++
expr_stmt|;
name|p2
operator|->
name|t_tdesc
operator|=
name|tgt
expr_stmt|;
name|p1
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|p1
operator|->
name|t_type
operator|=
name|POINTER
expr_stmt|;
name|p1
operator|->
name|t_id
operator|=
name|td
operator|->
name|td_nextid
operator|++
expr_stmt|;
name|p1
operator|->
name|t_tdesc
operator|=
name|p2
expr_stmt|;
name|ml
operator|->
name|ml_type
operator|=
name|p1
expr_stmt|;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Fixed %s->%s => ptrptr struct %s bug\n"
argument_list|,
name|strs
index|[
name|i
index|]
argument_list|,
name|mems
index|[
name|i
index|]
argument_list|,
name|acts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fix_ptr_to_struct
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|strs
index|[
literal|2
index|]
init|=
block|{
literal|"vmem"
block|,
literal|"id_space"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|mems
index|[
literal|2
index|]
init|=
block|{
name|NULL
block|,
literal|"is_vmem"
block|}
decl_stmt|;
name|tdesc_t
modifier|*
name|ptr
init|=
name|NULL
decl_stmt|;
name|tdesc_t
modifier|*
name|str
decl_stmt|,
modifier|*
name|vmt
decl_stmt|;
name|mlist_t
modifier|*
name|ml
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|vmt
operator|=
name|lookupname
argument_list|(
literal|"vmem_t"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|vmt
operator|->
name|t_type
operator|!=
name|TYPEDEF
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|strs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|strs
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|str
operator|=
name|lookupname
argument_list|(
name|strs
index|[
name|i
index|]
argument_list|)
operator|)
operator|||
name|str
operator|->
name|t_type
operator|!=
name|STRUCT
condition|)
continue|continue;
for|for
control|(
name|ml
operator|=
name|str
operator|->
name|t_members
init|;
name|ml
condition|;
name|ml
operator|=
name|ml
operator|->
name|ml_next
control|)
block|{
if|if
condition|(
name|mems
index|[
name|i
index|]
operator|&&
operator|!
name|streq
argument_list|(
name|ml
operator|->
name|ml_name
argument_list|,
name|mems
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ml
operator|->
name|ml_type
operator|->
name|t_type
operator|!=
name|POINTER
operator|||
name|ml
operator|->
name|ml_type
operator|->
name|t_name
operator|||
operator|(
name|ml
operator|->
name|ml_type
operator|->
name|t_tdesc
operator|->
name|t_type
operator|!=
name|STRUCT
operator|&&
name|ml
operator|->
name|ml_type
operator|->
name|t_tdesc
operator|->
name|t_type
operator|!=
name|FORWARD
operator|)
operator|||
operator|!
name|streq
argument_list|(
name|ml
operator|->
name|ml_type
operator|->
name|t_tdesc
operator|->
name|t_name
argument_list|,
literal|"vmem"
argument_list|)
condition|)
continue|continue;
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Fixed %s->%s => ptr struct vmem bug\n"
argument_list|,
name|strs
index|[
name|i
index|]
argument_list|,
name|ml
operator|->
name|ml_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|ptr
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|t_type
operator|=
name|POINTER
expr_stmt|;
name|ptr
operator|->
name|t_id
operator|=
name|td
operator|->
name|td_nextid
operator|++
expr_stmt|;
name|ptr
operator|->
name|t_tdesc
operator|=
name|vmt
expr_stmt|;
block|}
name|ml
operator|->
name|ml_type
operator|=
name|ptr
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Fix stabs generation bugs.  These routines must be run before the  * post-conversion merge  */
end_comment

begin_function
name|void
name|cvt_fixstabs
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|)
block|{
name|fix_ptrptr_to_struct
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|fix_ptr_to_struct
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|match
block|{
name|tdesc_t
modifier|*
name|m_ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|m_name
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|matching_iidesc
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|iidesc_t
modifier|*
name|iidesc
init|=
name|arg1
decl_stmt|;
name|struct
name|match
modifier|*
name|match
init|=
name|arg2
decl_stmt|;
if|if
condition|(
operator|!
name|streq
argument_list|(
name|iidesc
operator|->
name|ii_name
argument_list|,
name|match
operator|->
name|m_name
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|iidesc
operator|->
name|ii_type
operator|!=
name|II_TYPE
operator|&&
name|iidesc
operator|->
name|ii_type
operator|!=
name|II_SOU
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|match
operator|->
name|m_ret
operator|=
name|iidesc
operator|->
name|ii_dtype
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|tdesc_t
modifier|*
name|lookup_tdesc
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|match
name|match
init|=
block|{
name|NULL
block|,
name|name
block|}
decl_stmt|;
name|iter_iidescs_by_name
argument_list|(
name|td
argument_list|,
name|name
argument_list|,
name|matching_iidesc
argument_list|,
operator|&
name|match
argument_list|)
expr_stmt|;
return|return
operator|(
name|match
operator|.
name|m_ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The cpu structure grows, with the addition of a machcpu member, if  * _MACHDEP is defined.  This means that, for example, the cpu structure  * in unix is different from the cpu structure in genunix.  As one might  * expect, this causes merges to fail.  Since everyone indirectly contains  * a pointer to a CPU structure, the failed merges can cause massive amounts  * of duplication.  In the case of unix uniquifying against genunix, upwards  * of 50% of the structures were unmerged due to this problem.  We fix this  * by adding a cpu_m member.  If machcpu hasn't been defined in our module,  * we make a forward node for it.  */
end_comment

begin_function
specifier|static
name|void
name|fix_small_cpu_struct
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|size_t
name|ptrsize
parameter_list|)
block|{
name|tdesc_t
modifier|*
name|cput
decl_stmt|,
modifier|*
name|cpu
decl_stmt|;
name|tdesc_t
modifier|*
name|machcpu
decl_stmt|;
name|mlist_t
modifier|*
name|ml
decl_stmt|,
modifier|*
name|lml
decl_stmt|;
name|mlist_t
modifier|*
name|cpum
decl_stmt|;
name|int
name|foundcpucyc
init|=
literal|0
decl_stmt|;
comment|/* 	 * We're going to take the circuitous route finding the cpu structure, 	 * because we want to make sure that we find the right one.  It would 	 * be nice if we could verify the header name too.  DWARF might not 	 * have the cpu_t, so we let this pass. 	 */
if|if
condition|(
operator|(
name|cput
operator|=
name|lookup_tdesc
argument_list|(
name|td
argument_list|,
literal|"cpu_t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cput
operator|->
name|t_type
operator|!=
name|TYPEDEF
condition|)
return|return;
name|cpu
operator|=
name|cput
operator|->
name|t_tdesc
expr_stmt|;
block|}
else|else
block|{
name|cpu
operator|=
name|lookup_tdesc
argument_list|(
name|td
argument_list|,
literal|"cpu"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cpu
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|streq
argument_list|(
name|cpu
operator|->
name|t_name
argument_list|,
literal|"cpu"
argument_list|)
operator|||
name|cpu
operator|->
name|t_type
operator|!=
name|STRUCT
condition|)
return|return;
for|for
control|(
name|ml
operator|=
name|cpu
operator|->
name|t_members
operator|,
name|lml
operator|=
name|NULL
init|;
name|ml
condition|;
name|lml
operator|=
name|ml
operator|,
name|ml
operator|=
name|ml
operator|->
name|ml_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ml
operator|->
name|ml_name
argument_list|,
literal|"cpu_cyclic"
argument_list|)
operator|==
literal|0
condition|)
name|foundcpucyc
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|foundcpucyc
operator|==
literal|0
operator|||
name|lml
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|lml
operator|->
name|ml_name
argument_list|,
literal|"cpu_m"
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * We need to derive the right offset for the fake cpu_m member.  To do 	 * that, we require a special unused member to be the last member 	 * before the 'cpu_m', that we encode knowledge of here.  ABI alignment 	 * on all platforms is such that we only need to add a pointer-size 	 * number of bits to get the right offset for cpu_m.  This would most 	 * likely break if gcc's -malign-double were ever used, but that option 	 * breaks the ABI anyway. 	 */
if|if
condition|(
operator|!
name|streq
argument_list|(
name|lml
operator|->
name|ml_name
argument_list|,
literal|"cpu_m_pad"
argument_list|)
operator|&&
name|getenv
argument_list|(
literal|"CTFCONVERT_PERMISSIVE"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|terminate
argument_list|(
literal|"last cpu_t member before cpu_m is %s; "
literal|"it must be cpu_m_pad.\n"
argument_list|,
name|lml
operator|->
name|ml_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|machcpu
operator|=
name|lookup_tdesc
argument_list|(
name|td
argument_list|,
literal|"machcpu"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|machcpu
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|machcpu
argument_list|)
argument_list|)
expr_stmt|;
name|machcpu
operator|->
name|t_name
operator|=
name|xstrdup
argument_list|(
literal|"machcpu"
argument_list|)
expr_stmt|;
name|machcpu
operator|->
name|t_id
operator|=
name|td
operator|->
name|td_nextid
operator|++
expr_stmt|;
name|machcpu
operator|->
name|t_type
operator|=
name|FORWARD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|machcpu
operator|->
name|t_type
operator|!=
name|STRUCT
condition|)
block|{
return|return;
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|"Adding cpu_m machcpu %s to cpu struct\n"
argument_list|,
operator|(
name|machcpu
operator|->
name|t_type
operator|==
name|FORWARD
condition|?
literal|"forward"
else|:
literal|"struct"
operator|)
argument_list|)
expr_stmt|;
name|cpum
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cpum
argument_list|)
argument_list|)
expr_stmt|;
name|cpum
operator|->
name|ml_offset
operator|=
name|lml
operator|->
name|ml_offset
operator|+
operator|(
name|ptrsize
operator|*
name|NBBY
operator|)
expr_stmt|;
name|cpum
operator|->
name|ml_size
operator|=
literal|0
expr_stmt|;
name|cpum
operator|->
name|ml_name
operator|=
name|xstrdup
argument_list|(
literal|"cpu_m"
argument_list|)
expr_stmt|;
name|cpum
operator|->
name|ml_type
operator|=
name|machcpu
expr_stmt|;
name|cpum
operator|->
name|ml_next
operator|=
name|NULL
expr_stmt|;
name|lml
operator|->
name|ml_next
operator|=
name|cpum
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cvt_fixups
parameter_list|(
name|tdata_t
modifier|*
name|td
parameter_list|,
name|size_t
name|ptrsize
parameter_list|)
block|{
name|fix_small_cpu_struct
argument_list|(
name|td
argument_list|,
name|ptrsize
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

