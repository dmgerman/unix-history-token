begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"thread_pool_impl.h"
end_include

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|_Voidfp
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* pointer to extern "C" function */
end_comment

begin_function
specifier|static
name|void
name|delete_pool
parameter_list|(
name|tpool_t
modifier|*
name|tpool
parameter_list|)
block|{
name|tpool_job_t
modifier|*
name|job
decl_stmt|;
comment|/* 	 * There should be no pending jobs, but just in case... 	 */
for|for
control|(
name|job
operator|=
name|tpool
operator|->
name|tp_head
init|;
name|job
operator|!=
name|NULL
condition|;
name|job
operator|=
name|tpool
operator|->
name|tp_head
control|)
block|{
name|tpool
operator|->
name|tp_head
operator|=
name|job
operator|->
name|tpj_next
expr_stmt|;
name|free
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|pthread_attr_destroy
argument_list|(
operator|&
name|tpool
operator|->
name|tp_attr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tpool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Worker thread is terminating.  */
end_comment

begin_function
specifier|static
name|void
name|worker_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tpool_t
modifier|*
name|tpool
init|=
name|arg
decl_stmt|;
if|if
condition|(
operator|--
name|tpool
operator|->
name|tp_current
operator|==
literal|0
operator|&&
operator|(
name|tpool
operator|->
name|tp_flags
operator|&
operator|(
name|TP_DESTROY
operator||
name|TP_ABANDON
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|tpool
operator|->
name|tp_flags
operator|&
name|TP_ABANDON
condition|)
block|{
name|pthread_mutex_unlock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
name|delete_pool
argument_list|(
name|tpool
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tpool
operator|->
name|tp_flags
operator|&
name|TP_DESTROY
condition|)
operator|(
name|void
operator|)
name|pthread_cond_broadcast
argument_list|(
operator|&
name|tpool
operator|->
name|tp_busycv
argument_list|)
expr_stmt|;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_waiters
parameter_list|(
name|tpool_t
modifier|*
name|tpool
parameter_list|)
block|{
if|if
condition|(
name|tpool
operator|->
name|tp_head
operator|==
name|NULL
operator|&&
name|tpool
operator|->
name|tp_active
operator|==
name|NULL
condition|)
block|{
name|tpool
operator|->
name|tp_flags
operator|&=
operator|~
name|TP_WAIT
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_broadcast
argument_list|(
operator|&
name|tpool
operator|->
name|tp_waitcv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Called by a worker thread on return from a tpool_dispatch()d job.  */
end_comment

begin_function
specifier|static
name|void
name|job_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tpool_t
modifier|*
name|tpool
init|=
name|arg
decl_stmt|;
name|pthread_t
name|my_tid
init|=
name|pthread_self
argument_list|()
decl_stmt|;
name|tpool_active_t
modifier|*
name|activep
decl_stmt|;
name|tpool_active_t
modifier|*
modifier|*
name|activepp
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
comment|/* CSTYLED */
for|for
control|(
name|activepp
operator|=
operator|&
name|tpool
operator|->
name|tp_active
init|;
condition|;
name|activepp
operator|=
operator|&
name|activep
operator|->
name|tpa_next
control|)
block|{
name|activep
operator|=
operator|*
name|activepp
expr_stmt|;
if|if
condition|(
name|activep
operator|->
name|tpa_tid
operator|==
name|my_tid
condition|)
block|{
operator|*
name|activepp
operator|=
name|activep
operator|->
name|tpa_next
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tpool
operator|->
name|tp_flags
operator|&
name|TP_WAIT
condition|)
name|notify_waiters
argument_list|(
name|tpool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|tpool_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tpool_t
modifier|*
name|tpool
init|=
operator|(
name|tpool_t
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|elapsed
decl_stmt|;
name|tpool_job_t
modifier|*
name|job
decl_stmt|;
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|tpool_active_t
name|active
decl_stmt|;
name|sigset_t
name|maskset
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
name|pthread_cleanup_push
argument_list|(
name|worker_cleanup
argument_list|,
name|tpool
argument_list|)
expr_stmt|;
comment|/* 	 * This is the worker's main loop. 	 * It will only be left if a timeout or an error has occured. 	 */
name|active
operator|.
name|tpa_tid
operator|=
name|pthread_self
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|elapsed
operator|=
literal|0
expr_stmt|;
name|tpool
operator|->
name|tp_idle
operator|++
expr_stmt|;
if|if
condition|(
name|tpool
operator|->
name|tp_flags
operator|&
name|TP_WAIT
condition|)
name|notify_waiters
argument_list|(
name|tpool
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|tpool
operator|->
name|tp_head
operator|==
name|NULL
operator|||
operator|(
name|tpool
operator|->
name|tp_flags
operator|&
name|TP_SUSPEND
operator|)
operator|)
operator|&&
operator|!
operator|(
name|tpool
operator|->
name|tp_flags
operator|&
operator|(
name|TP_DESTROY
operator||
name|TP_ABANDON
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|tpool
operator|->
name|tp_current
operator|<=
name|tpool
operator|->
name|tp_minimum
operator|||
name|tpool
operator|->
name|tp_linger
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|pthread_cond_wait
argument_list|(
operator|&
name|tpool
operator|->
name|tp_workcv
argument_list|,
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|timespec
name|timeout
decl_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_MONOTONIC
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|+=
name|tpool
operator|->
name|tp_linger
expr_stmt|;
if|if
condition|(
name|pthread_cond_timedwait
argument_list|(
operator|&
name|tpool
operator|->
name|tp_workcv
argument_list|,
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|,
operator|&
name|timeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|elapsed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|tpool
operator|->
name|tp_idle
operator|--
expr_stmt|;
if|if
condition|(
name|tpool
operator|->
name|tp_flags
operator|&
name|TP_DESTROY
condition|)
break|break;
if|if
condition|(
name|tpool
operator|->
name|tp_flags
operator|&
name|TP_ABANDON
condition|)
block|{
comment|/* can't abandon a suspended pool */
if|if
condition|(
name|tpool
operator|->
name|tp_flags
operator|&
name|TP_SUSPEND
condition|)
block|{
name|tpool
operator|->
name|tp_flags
operator|&=
operator|~
name|TP_SUSPEND
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_broadcast
argument_list|(
operator|&
name|tpool
operator|->
name|tp_workcv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tpool
operator|->
name|tp_head
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|job
operator|=
name|tpool
operator|->
name|tp_head
operator|)
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|tpool
operator|->
name|tp_flags
operator|&
name|TP_SUSPEND
operator|)
condition|)
block|{
name|elapsed
operator|=
literal|0
expr_stmt|;
name|func
operator|=
name|job
operator|->
name|tpj_func
expr_stmt|;
name|arg
operator|=
name|job
operator|->
name|tpj_arg
expr_stmt|;
name|tpool
operator|->
name|tp_head
operator|=
name|job
operator|->
name|tpj_next
expr_stmt|;
if|if
condition|(
name|job
operator|==
name|tpool
operator|->
name|tp_tail
condition|)
name|tpool
operator|->
name|tp_tail
operator|=
name|NULL
expr_stmt|;
name|tpool
operator|->
name|tp_njobs
operator|--
expr_stmt|;
name|active
operator|.
name|tpa_next
operator|=
name|tpool
operator|->
name|tp_active
expr_stmt|;
name|tpool
operator|->
name|tp_active
operator|=
operator|&
name|active
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
name|pthread_cleanup_push
argument_list|(
name|job_cleanup
argument_list|,
name|tpool
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|job
argument_list|)
expr_stmt|;
comment|/* 			 * Call the specified function. 			 */
name|func
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* 			 * We don't know what this thread has been doing, 			 * so we reset its signal mask and cancellation 			 * state back to the initial values. 			 */
name|sigfillset
argument_list|(
operator|&
name|maskset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_sigmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|maskset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_setcanceltype
argument_list|(
name|PTHREAD_CANCEL_DEFERRED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_setcancelstate
argument_list|(
name|PTHREAD_CANCEL_ENABLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_cleanup_pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elapsed
operator|&&
name|tpool
operator|->
name|tp_current
operator|>
name|tpool
operator|->
name|tp_minimum
condition|)
block|{
comment|/* 			 * We timed out and there is no work to be done 			 * and the number of workers exceeds the minimum. 			 * Exit now to reduce the size of the pool. 			 */
break|break;
block|}
block|}
name|pthread_cleanup_pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|arg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a worker thread, with all signals blocked.  */
end_comment

begin_function
specifier|static
name|int
name|create_worker
parameter_list|(
name|tpool_t
modifier|*
name|tpool
parameter_list|)
block|{
name|sigset_t
name|maskset
decl_stmt|,
name|oset
decl_stmt|;
name|pthread_t
name|thread
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sigfillset
argument_list|(
operator|&
name|maskset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_sigmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|maskset
argument_list|,
operator|&
name|oset
argument_list|)
expr_stmt|;
name|error
operator|=
name|pthread_create
argument_list|(
operator|&
name|thread
argument_list|,
operator|&
name|tpool
operator|->
name|tp_attr
argument_list|,
name|tpool_worker
argument_list|,
name|tpool
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_sigmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|tpool_t
modifier|*
name|tpool_create
parameter_list|(
name|uint_t
name|min_threads
parameter_list|,
name|uint_t
name|max_threads
parameter_list|,
name|uint_t
name|linger
parameter_list|,
name|pthread_attr_t
modifier|*
name|attr
parameter_list|)
block|{
name|tpool_t
modifier|*
name|tpool
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|min_threads
operator|>
name|max_threads
operator|||
name|max_threads
operator|<
literal|1
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tpool
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpool
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|tpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tpool
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_init
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_init
argument_list|(
operator|&
name|tpool
operator|->
name|tp_busycv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_init
argument_list|(
operator|&
name|tpool
operator|->
name|tp_workcv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_init
argument_list|(
operator|&
name|tpool
operator|->
name|tp_waitcv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tpool
operator|->
name|tp_minimum
operator|=
name|min_threads
expr_stmt|;
name|tpool
operator|->
name|tp_maximum
operator|=
name|max_threads
expr_stmt|;
name|tpool
operator|->
name|tp_linger
operator|=
name|linger
expr_stmt|;
comment|/* make all pool threads be detached daemon threads */
operator|(
name|void
operator|)
name|pthread_attr_init
argument_list|(
operator|&
name|tpool
operator|->
name|tp_attr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_attr_setdetachstate
argument_list|(
operator|&
name|tpool
operator|->
name|tp_attr
argument_list|,
name|PTHREAD_CREATE_DETACHED
argument_list|)
expr_stmt|;
return|return
operator|(
name|tpool
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dispatch a work request to the thread pool.  * If there are idle workers, awaken one.  * Else, if the maximum number of workers has  * not been reached, spawn a new worker thread.  * Else just return with the job added to the queue.  */
end_comment

begin_function
name|int
name|tpool_dispatch
parameter_list|(
name|tpool_t
modifier|*
name|tpool
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tpool_job_t
modifier|*
name|job
decl_stmt|;
if|if
condition|(
operator|(
name|job
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|job
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bzero
argument_list|(
name|job
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|job
argument_list|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|tpj_next
operator|=
name|NULL
expr_stmt|;
name|job
operator|->
name|tpj_func
operator|=
name|func
expr_stmt|;
name|job
operator|->
name|tpj_arg
operator|=
name|arg
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpool
operator|->
name|tp_head
operator|==
name|NULL
condition|)
name|tpool
operator|->
name|tp_head
operator|=
name|job
expr_stmt|;
else|else
name|tpool
operator|->
name|tp_tail
operator|->
name|tpj_next
operator|=
name|job
expr_stmt|;
name|tpool
operator|->
name|tp_tail
operator|=
name|job
expr_stmt|;
name|tpool
operator|->
name|tp_njobs
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tpool
operator|->
name|tp_flags
operator|&
name|TP_SUSPEND
operator|)
condition|)
block|{
if|if
condition|(
name|tpool
operator|->
name|tp_idle
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|pthread_cond_signal
argument_list|(
operator|&
name|tpool
operator|->
name|tp_workcv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tpool
operator|->
name|tp_current
operator|<
name|tpool
operator|->
name|tp_maximum
operator|&&
name|create_worker
argument_list|(
name|tpool
argument_list|)
operator|==
literal|0
condition|)
name|tpool
operator|->
name|tp_current
operator|++
expr_stmt|;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Assumes: by the time tpool_destroy() is called no one will use this  * thread pool in any way and no one will try to dispatch entries to it.  * Calling tpool_destroy() from a job in the pool will cause deadlock.  */
end_comment

begin_function
name|void
name|tpool_destroy
parameter_list|(
name|tpool_t
modifier|*
name|tpool
parameter_list|)
block|{
name|tpool_active_t
modifier|*
name|activep
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
name|pthread_cleanup_push
argument_list|(
operator|(
name|_Voidfp
operator|)
name|pthread_mutex_unlock
argument_list|,
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
comment|/* mark the pool as being destroyed; wakeup idle workers */
name|tpool
operator|->
name|tp_flags
operator||=
name|TP_DESTROY
expr_stmt|;
name|tpool
operator|->
name|tp_flags
operator|&=
operator|~
name|TP_SUSPEND
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_broadcast
argument_list|(
operator|&
name|tpool
operator|->
name|tp_workcv
argument_list|)
expr_stmt|;
comment|/* cancel all active workers */
for|for
control|(
name|activep
operator|=
name|tpool
operator|->
name|tp_active
init|;
name|activep
condition|;
name|activep
operator|=
name|activep
operator|->
name|tpa_next
control|)
operator|(
name|void
operator|)
name|pthread_cancel
argument_list|(
name|activep
operator|->
name|tpa_tid
argument_list|)
expr_stmt|;
comment|/* wait for all active workers to finish */
while|while
condition|(
name|tpool
operator|->
name|tp_active
operator|!=
name|NULL
condition|)
block|{
name|tpool
operator|->
name|tp_flags
operator||=
name|TP_WAIT
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_wait
argument_list|(
operator|&
name|tpool
operator|->
name|tp_waitcv
argument_list|,
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
block|}
comment|/* the last worker to terminate will wake us up */
while|while
condition|(
name|tpool
operator|->
name|tp_current
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|pthread_cond_wait
argument_list|(
operator|&
name|tpool
operator|->
name|tp_busycv
argument_list|,
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
name|pthread_cleanup_pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* pthread_mutex_unlock(&tpool->tp_mutex); */
name|delete_pool
argument_list|(
name|tpool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Like tpool_destroy(), but don't cancel workers or wait for them to finish.  * The last worker to terminate will delete the pool.  */
end_comment

begin_function
name|void
name|tpool_abandon
parameter_list|(
name|tpool_t
modifier|*
name|tpool
parameter_list|)
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpool
operator|->
name|tp_current
operator|==
literal|0
condition|)
block|{
comment|/* no workers, just delete the pool */
name|pthread_mutex_unlock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
name|delete_pool
argument_list|(
name|tpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* wake up all workers, last one will delete the pool */
name|tpool
operator|->
name|tp_flags
operator||=
name|TP_ABANDON
expr_stmt|;
name|tpool
operator|->
name|tp_flags
operator|&=
operator|~
name|TP_SUSPEND
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_broadcast
argument_list|(
operator|&
name|tpool
operator|->
name|tp_workcv
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Wait for all jobs to complete.  * Calling tpool_wait() from a job in the pool will cause deadlock.  */
end_comment

begin_function
name|void
name|tpool_wait
parameter_list|(
name|tpool_t
modifier|*
name|tpool
parameter_list|)
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
name|pthread_cleanup_push
argument_list|(
operator|(
name|_Voidfp
operator|)
name|pthread_mutex_unlock
argument_list|,
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|tpool
operator|->
name|tp_head
operator|!=
name|NULL
operator|||
name|tpool
operator|->
name|tp_active
operator|!=
name|NULL
condition|)
block|{
name|tpool
operator|->
name|tp_flags
operator||=
name|TP_WAIT
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_wait
argument_list|(
operator|&
name|tpool
operator|->
name|tp_waitcv
argument_list|,
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
block|}
name|pthread_cleanup_pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* pthread_mutex_unlock(&tpool->tp_mutex); */
block|}
end_function

begin_function
name|void
name|tpool_suspend
parameter_list|(
name|tpool_t
modifier|*
name|tpool
parameter_list|)
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
name|tpool
operator|->
name|tp_flags
operator||=
name|TP_SUSPEND
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tpool_suspended
parameter_list|(
name|tpool_t
modifier|*
name|tpool
parameter_list|)
block|{
name|int
name|suspended
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
name|suspended
operator|=
operator|(
name|tpool
operator|->
name|tp_flags
operator|&
name|TP_SUSPEND
operator|)
operator|!=
literal|0
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|suspended
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tpool_resume
parameter_list|(
name|tpool_t
modifier|*
name|tpool
parameter_list|)
block|{
name|int
name|excess
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tpool
operator|->
name|tp_flags
operator|&
name|TP_SUSPEND
operator|)
condition|)
block|{
name|pthread_mutex_unlock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
return|return;
block|}
name|tpool
operator|->
name|tp_flags
operator|&=
operator|~
name|TP_SUSPEND
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_broadcast
argument_list|(
operator|&
name|tpool
operator|->
name|tp_workcv
argument_list|)
expr_stmt|;
name|excess
operator|=
name|tpool
operator|->
name|tp_njobs
operator|-
name|tpool
operator|->
name|tp_idle
expr_stmt|;
while|while
condition|(
name|excess
operator|--
operator|>
literal|0
operator|&&
name|tpool
operator|->
name|tp_current
operator|<
name|tpool
operator|->
name|tp_maximum
condition|)
block|{
if|if
condition|(
name|create_worker
argument_list|(
name|tpool
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* pthread_create() failed */
name|tpool
operator|->
name|tp_current
operator|++
expr_stmt|;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tpool_member
parameter_list|(
name|tpool_t
modifier|*
name|tpool
parameter_list|)
block|{
name|pthread_t
name|my_tid
init|=
name|pthread_self
argument_list|()
decl_stmt|;
name|tpool_active_t
modifier|*
name|activep
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|activep
operator|=
name|tpool
operator|->
name|tp_active
init|;
name|activep
condition|;
name|activep
operator|=
name|activep
operator|->
name|tpa_next
control|)
block|{
if|if
condition|(
name|activep
operator|->
name|tpa_tid
operator|==
name|my_tid
condition|)
block|{
name|pthread_mutex_unlock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|tpool
operator|->
name|tp_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

