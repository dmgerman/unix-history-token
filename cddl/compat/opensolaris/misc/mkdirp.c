begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*	Copyright (c) 1988 AT&T	*/
end_comment

begin_comment
comment|/*	  All Rights Reserved  	*/
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"@(#)mkdirp.c	1.15	06/01/04 SMI"
end_pragma

begin_comment
comment|/*  * Creates directory and it's parents if the parents do not  * exist yet.  *  * Returns -1 if fails for reasons other than non-existing  * parents.  * Does NOT simplify pathnames with . or .. in them.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_function_decl
specifier|static
name|char
modifier|*
name|simplify
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|mkdirp
parameter_list|(
specifier|const
name|char
modifier|*
name|d
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|,
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|slash
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|simplify
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* If space couldn't be allocated for the simplified names, return. */
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Try to make the directory */
if|if
condition|(
name|mkdir
argument_list|(
name|str
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|endptr
operator|=
name|strrchr
argument_list|(
name|str
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|slash
operator|=
name|strrchr
argument_list|(
name|str
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Search upward for the non-existing parent */
while|while
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
name|ptr
operator|=
name|slash
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* If reached an existing parent, break */
if|if
condition|(
name|access
argument_list|(
name|str
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* If non-existing parent */
else|else
block|{
name|slash
operator|=
name|strrchr
argument_list|(
name|str
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* If under / or current directory, make it. */
if|if
condition|(
name|slash
operator|==
name|NULL
operator|||
name|slash
operator|==
name|str
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|str
argument_list|,
name|mode
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
block|}
block|}
block|}
comment|/* Create directories starting from upmost non-existing parent */
while|while
condition|(
operator|(
name|ptr
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'\0'
argument_list|)
operator|)
operator|!=
name|endptr
condition|)
block|{
operator|*
name|ptr
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|str
argument_list|,
name|mode
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
block|{
comment|/* 			 *  If the mkdir fails because str already 			 *  exists (EEXIST), then str has the form 			 *  "existing-dir/..", and this is really 			 *  ok. (Remember, this loop is creating the 			 *  portion of the path that didn't exist) 			 */
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	simplify - given a pathname, simplify that path by removing  *		   duplicate contiguous slashes.  *  *		   A simplified copy of the argument is returned to the  *		   caller, or NULL is returned on error.  *  *		   The caller should handle error reporting based upon the  *		   returned vlaue, and should free the returned value,  *		   when appropriate.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|simplify
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|mbPathlen
decl_stmt|;
comment|/* length of multi-byte path */
name|size_t
name|wcPathlen
decl_stmt|;
comment|/* length of wide-character path */
name|wchar_t
modifier|*
name|wptr
decl_stmt|;
comment|/* scratch pointer */
name|wchar_t
modifier|*
name|wcPath
decl_stmt|;
comment|/* wide-character version of the path */
name|char
modifier|*
name|mbPath
decl_stmt|;
comment|/* The copy fo the path to be returned */
comment|/* 	 *  bail out if there is nothing there. 	 */
if|if
condition|(
operator|!
name|str
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 *  Get a copy of the argument. 	 */
if|if
condition|(
operator|(
name|mbPath
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 *  convert the multi-byte version of the path to a 	 *  wide-character rendering, for doing our figuring. 	 */
name|mbPathlen
operator|=
name|strlen
argument_list|(
name|mbPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wcPath
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|,
name|mbPathlen
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|mbPath
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|wcPathlen
operator|=
name|mbstowcs
argument_list|(
name|wcPath
argument_list|,
name|mbPath
argument_list|,
name|mbPathlen
argument_list|)
operator|)
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|mbPath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wcPath
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 *  remove duplicate slashes first ("//../" -> "/") 	 */
for|for
control|(
name|wptr
operator|=
name|wcPath
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wcPathlen
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|wptr
operator|++
operator|=
name|wcPath
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|wcPath
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
block|{
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|wcPath
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|--
expr_stmt|;
block|}
block|}
operator|*
name|wptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 *  now convert back to the multi-byte format. 	 */
if|if
condition|(
name|wcstombs
argument_list|(
name|mbPath
argument_list|,
name|wcPath
argument_list|,
name|mbPathlen
argument_list|)
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|mbPath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wcPath
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|free
argument_list|(
name|wcPath
argument_list|)
expr_stmt|;
return|return
operator|(
name|mbPath
operator|)
return|;
block|}
end_function

end_unit

