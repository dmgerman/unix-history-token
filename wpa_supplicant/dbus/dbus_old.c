begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * WPA Supplicant / dbus-based control interface  * Copyright (c) 2006, Dan Williams<dcbw@redhat.com> and Red Hat, Inc.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<dbus/dbus.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eloop.h"
end_include

begin_include
include|#
directive|include
file|"wps/wps.h"
end_include

begin_include
include|#
directive|include
file|"../config.h"
end_include

begin_include
include|#
directive|include
file|"../wpa_supplicant_i.h"
end_include

begin_include
include|#
directive|include
file|"../bss.h"
end_include

begin_include
include|#
directive|include
file|"dbus_old.h"
end_include

begin_include
include|#
directive|include
file|"dbus_old_handlers.h"
end_include

begin_include
include|#
directive|include
file|"dbus_common.h"
end_include

begin_include
include|#
directive|include
file|"dbus_common_i.h"
end_include

begin_comment
comment|/**  * wpas_dbus_decompose_object_path - Decompose an interface object path into parts  * @path: The dbus object path  * @network: (out) the configured network this object path refers to, if any  * @bssid: (out) the scanned bssid this object path refers to, if any  * Returns: The object path of the network interface this path refers to  *  * For a given object path, decomposes the object path into object id, network,  * and BSSID parts, if those parts exist.  */
end_comment

begin_function
name|char
modifier|*
name|wpas_dbus_decompose_object_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
modifier|*
name|network
parameter_list|,
name|char
modifier|*
modifier|*
name|bssid
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|dev_path_prefix_len
init|=
name|strlen
argument_list|(
name|WPAS_DBUS_PATH_INTERFACES
literal|"/"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|obj_path_only
decl_stmt|;
name|char
modifier|*
name|next_sep
decl_stmt|;
comment|/* Be a bit paranoid about path */
if|if
condition|(
operator|!
name|path
operator|||
name|strncmp
argument_list|(
name|path
argument_list|,
name|WPAS_DBUS_PATH_INTERFACES
literal|"/"
argument_list|,
name|dev_path_prefix_len
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Ensure there's something at the end of the path */
if|if
condition|(
operator|(
name|path
operator|+
name|dev_path_prefix_len
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|obj_path_only
operator|=
name|os_strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_path_only
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|next_sep
operator|=
name|strchr
argument_list|(
name|obj_path_only
operator|+
name|dev_path_prefix_len
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_sep
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|net_part
init|=
name|strstr
argument_list|(
name|next_sep
argument_list|,
name|WPAS_DBUS_NETWORKS_PART
literal|"/"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|bssid_part
init|=
name|strstr
argument_list|(
name|next_sep
argument_list|,
name|WPAS_DBUS_BSSIDS_PART
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|network
operator|&&
name|net_part
condition|)
block|{
comment|/* Deal with a request for a configured network */
specifier|const
name|char
modifier|*
name|net_name
init|=
name|net_part
operator|+
name|strlen
argument_list|(
name|WPAS_DBUS_NETWORKS_PART
literal|"/"
argument_list|)
decl_stmt|;
operator|*
name|network
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|net_name
argument_list|)
condition|)
operator|*
name|network
operator|=
name|os_strdup
argument_list|(
name|net_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bssid
operator|&&
name|bssid_part
condition|)
block|{
comment|/* Deal with a request for a scanned BSSID */
specifier|const
name|char
modifier|*
name|bssid_name
init|=
name|bssid_part
operator|+
name|strlen
argument_list|(
name|WPAS_DBUS_BSSIDS_PART
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|bssid_name
argument_list|)
condition|)
operator|*
name|bssid
operator|=
name|os_strdup
argument_list|(
name|bssid_name
argument_list|)
expr_stmt|;
else|else
operator|*
name|bssid
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Cut off interface object path before "/" */
operator|*
name|next_sep
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|obj_path_only
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dbus_new_invalid_iface_error - Return a new invalid interface error message  * @message: Pointer to incoming dbus message this error refers to  * Returns: A dbus error message  *  * Convenience function to create and return an invalid interface error  */
end_comment

begin_function
name|DBusMessage
modifier|*
name|wpas_dbus_new_invalid_iface_error
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|WPAS_ERROR_INVALID_IFACE
argument_list|,
literal|"wpa_supplicant knows nothing about "
literal|"this interface."
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dbus_new_invalid_network_error - Return a new invalid network error message  * @message: Pointer to incoming dbus message this error refers to  * Returns: a dbus error message  *  * Convenience function to create and return an invalid network error  */
end_comment

begin_function
name|DBusMessage
modifier|*
name|wpas_dbus_new_invalid_network_error
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|WPAS_ERROR_INVALID_NETWORK
argument_list|,
literal|"The requested network does not exist."
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dbus_new_invalid_bssid_error - Return a new invalid bssid error message  * @message: Pointer to incoming dbus message this error refers to  * Returns: a dbus error message  *  * Convenience function to create and return an invalid bssid error  */
end_comment

begin_function
specifier|static
name|DBusMessage
modifier|*
name|wpas_dbus_new_invalid_bssid_error
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|)
block|{
return|return
name|dbus_message_new_error
argument_list|(
name|message
argument_list|,
name|WPAS_ERROR_INVALID_BSSID
argument_list|,
literal|"The BSSID requested was invalid."
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dispatch_network_method - dispatch messages for configured networks  * @message: the incoming dbus message  * @wpa_s: a network interface's data  * @network_id: id of the configured network we're interested in  * Returns: a reply dbus message, or a dbus error message  *  * This function dispatches all incoming dbus messages for configured networks.  */
end_comment

begin_function
specifier|static
name|DBusMessage
modifier|*
name|wpas_dispatch_network_method
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|int
name|network_id
parameter_list|)
block|{
name|DBusMessage
modifier|*
name|reply
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
init|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|struct
name|wpa_ssid
modifier|*
name|ssid
decl_stmt|;
name|ssid
operator|=
name|wpa_config_get_network
argument_list|(
name|wpa_s
operator|->
name|conf
argument_list|,
name|network_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssid
operator|==
name|NULL
condition|)
return|return
name|wpas_dbus_new_invalid_network_error
argument_list|(
name|message
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"set"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_set_network
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"enable"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_enable_network
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"disable"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_disable_network
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dispatch_bssid_method - dispatch messages for scanned networks  * @message: the incoming dbus message  * @wpa_s: a network interface's data  * @bssid: bssid of the scanned network we're interested in  * Returns: a reply dbus message, or a dbus error message  *  * This function dispatches all incoming dbus messages for scanned networks.  */
end_comment

begin_function
specifier|static
name|DBusMessage
modifier|*
name|wpas_dispatch_bssid_method
parameter_list|(
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
specifier|const
name|char
modifier|*
name|bssid_txt
parameter_list|)
block|{
name|u8
name|bssid
index|[
name|ETH_ALEN
index|]
decl_stmt|;
name|struct
name|wpa_bss
modifier|*
name|bss
decl_stmt|;
if|if
condition|(
name|hexstr2bin
argument_list|(
name|bssid_txt
argument_list|,
name|bssid
argument_list|,
name|ETH_ALEN
argument_list|)
operator|<
literal|0
condition|)
return|return
name|wpas_dbus_new_invalid_bssid_error
argument_list|(
name|message
argument_list|)
return|;
name|bss
operator|=
name|wpa_bss_get_bssid
argument_list|(
name|wpa_s
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bss
operator|==
name|NULL
condition|)
return|return
name|wpas_dbus_new_invalid_bssid_error
argument_list|(
name|message
argument_list|)
return|;
comment|/* Dispatch the method call against the scanned bssid */
if|if
condition|(
name|os_strcmp
argument_list|(
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
argument_list|,
literal|"properties"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|wpas_dbus_bssid_properties
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|,
name|bss
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_iface_message_handler - Dispatch messages for interfaces or networks  * @connection: Connection to the system message bus  * @message: An incoming dbus message  * @user_data: A pointer to a dbus control interface data structure  * Returns: Whether or not the message was handled  *  * This function dispatches all incoming dbus messages for network interfaces,  * or objects owned by them, such as scanned BSSIDs and configured networks.  */
end_comment

begin_function
specifier|static
name|DBusHandlerResult
name|wpas_iface_message_handler
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
init|=
name|user_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
init|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|dbus_message_get_path
argument_list|(
name|message
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg_interface
init|=
name|dbus_message_get_interface
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|char
modifier|*
name|iface_obj_path
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|network
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|bssid
init|=
name|NULL
decl_stmt|;
name|DBusMessage
modifier|*
name|reply
init|=
name|NULL
decl_stmt|;
comment|/* Caller must specify a message interface */
if|if
condition|(
operator|!
name|msg_interface
condition|)
goto|goto
name|out
goto|;
name|iface_obj_path
operator|=
name|wpas_dbus_decompose_object_path
argument_list|(
name|path
argument_list|,
operator|&
name|network
argument_list|,
operator|&
name|bssid
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface_obj_path
operator|==
name|NULL
condition|)
block|{
name|reply
operator|=
name|wpas_dbus_new_invalid_iface_error
argument_list|(
name|message
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Make sure the message's object path actually refers to the 	 * wpa_supplicant structure it's supposed to (which is wpa_s) 	 */
if|if
condition|(
name|wpa_supplicant_get_iface_by_dbus_path
argument_list|(
name|wpa_s
operator|->
name|global
argument_list|,
name|iface_obj_path
argument_list|)
operator|!=
name|wpa_s
condition|)
block|{
name|reply
operator|=
name|wpas_dbus_new_invalid_iface_error
argument_list|(
name|message
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|network
operator|&&
operator|!
name|strcmp
argument_list|(
name|msg_interface
argument_list|,
name|WPAS_DBUS_IFACE_NETWORK
argument_list|)
condition|)
block|{
comment|/* A method for one of this interface's configured networks */
name|int
name|nid
init|=
name|strtoul
argument_list|(
name|network
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
name|reply
operator|=
name|wpas_dispatch_network_method
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|,
name|nid
argument_list|)
expr_stmt|;
else|else
name|reply
operator|=
name|wpas_dbus_new_invalid_network_error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bssid
operator|&&
operator|!
name|strcmp
argument_list|(
name|msg_interface
argument_list|,
name|WPAS_DBUS_IFACE_BSSID
argument_list|)
condition|)
block|{
comment|/* A method for one of this interface's scanned BSSIDs */
name|reply
operator|=
name|wpas_dispatch_bssid_method
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|msg_interface
argument_list|,
name|WPAS_DBUS_IFACE_INTERFACE
argument_list|)
condition|)
block|{
comment|/* A method for an interface only. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"scan"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_scan
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"scanResults"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_scan_results
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"addNetwork"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_add_network
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"removeNetwork"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_remove_network
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"selectNetwork"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_select_network
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"capabilities"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_capabilities
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"disconnect"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_disconnect
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"setAPScan"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_set_ap_scan
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"setSmartcardModules"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_set_smartcard_modules
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"state"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_get_state
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"scanning"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_get_scanning
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"setBlobs"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_set_blobs
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"removeBlobs"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_remove_blobs
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_WPS
elseif|else
if|if
condition|(
operator|!
name|os_strcmp
argument_list|(
name|method
argument_list|,
literal|"wpsPbc"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_wps_pbc
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strcmp
argument_list|(
name|method
argument_list|,
literal|"wpsPin"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_wps_pin
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|os_strcmp
argument_list|(
name|method
argument_list|,
literal|"wpsReg"
argument_list|)
condition|)
name|reply
operator|=
name|wpas_dbus_iface_wps_reg
argument_list|(
name|message
argument_list|,
name|wpa_s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_WPS */
block|}
comment|/* If the message was handled, send back the reply */
if|if
condition|(
name|reply
condition|)
block|{
if|if
condition|(
operator|!
name|dbus_message_get_no_reply
argument_list|(
name|message
argument_list|)
condition|)
name|dbus_connection_send
argument_list|(
name|connection
argument_list|,
name|reply
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|os_free
argument_list|(
name|iface_obj_path
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|network
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|bssid
argument_list|)
expr_stmt|;
return|return
name|reply
condition|?
name|DBUS_HANDLER_RESULT_HANDLED
else|:
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_message_handler - dispatch incoming dbus messages  * @connection: connection to the system message bus  * @message: an incoming dbus message  * @user_data: a pointer to a dbus control interface data structure  * Returns: whether or not the message was handled  *  * This function dispatches all incoming dbus messages to the correct  * handlers, depending on what the message's target object path is,  * and what the method call is.  */
end_comment

begin_function
specifier|static
name|DBusHandlerResult
name|wpas_message_handler
parameter_list|(
name|DBusConnection
modifier|*
name|connection
parameter_list|,
name|DBusMessage
modifier|*
name|message
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|struct
name|wpas_dbus_priv
modifier|*
name|ctrl_iface
init|=
name|user_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg_interface
decl_stmt|;
name|DBusMessage
modifier|*
name|reply
init|=
name|NULL
decl_stmt|;
name|method
operator|=
name|dbus_message_get_member
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|path
operator|=
name|dbus_message_get_path
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|msg_interface
operator|=
name|dbus_message_get_interface
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method
operator|||
operator|!
name|path
operator|||
operator|!
name|ctrl_iface
operator|||
operator|!
name|msg_interface
condition|)
return|return
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
comment|/* Validate the method interface */
if|if
condition|(
name|strcmp
argument_list|(
name|msg_interface
argument_list|,
name|WPAS_DBUS_INTERFACE
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|path
argument_list|,
name|WPAS_DBUS_PATH
argument_list|)
condition|)
block|{
comment|/* dispatch methods against our global dbus interface here */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"addInterface"
argument_list|)
condition|)
block|{
name|reply
operator|=
name|wpas_dbus_global_add_interface
argument_list|(
name|message
argument_list|,
name|ctrl_iface
operator|->
name|global
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"removeInterface"
argument_list|)
condition|)
block|{
name|reply
operator|=
name|wpas_dbus_global_remove_interface
argument_list|(
name|message
argument_list|,
name|ctrl_iface
operator|->
name|global
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"getInterface"
argument_list|)
condition|)
block|{
name|reply
operator|=
name|wpas_dbus_global_get_interface
argument_list|(
name|message
argument_list|,
name|ctrl_iface
operator|->
name|global
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"setDebugParams"
argument_list|)
condition|)
block|{
name|reply
operator|=
name|wpas_dbus_global_set_debugparams
argument_list|(
name|message
argument_list|,
name|ctrl_iface
operator|->
name|global
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the message was handled, send back the reply */
if|if
condition|(
name|reply
condition|)
block|{
if|if
condition|(
operator|!
name|dbus_message_get_no_reply
argument_list|(
name|message
argument_list|)
condition|)
name|dbus_connection_send
argument_list|(
name|connection
argument_list|,
name|reply
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dbus_message_unref
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
return|return
name|reply
condition|?
name|DBUS_HANDLER_RESULT_HANDLED
else|:
name|DBUS_HANDLER_RESULT_NOT_YET_HANDLED
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_dbus_notify_scan_results - Send a scan results signal  * @wpa_s: %wpa_supplicant network interface data  * Returns: 0 on success, -1 on failure  *  * Notify listeners that this interface has updated scan results.  */
end_comment

begin_function
name|void
name|wpa_supplicant_dbus_notify_scan_results
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|wpas_dbus_priv
modifier|*
name|iface
init|=
name|wpa_s
operator|->
name|global
operator|->
name|dbus
decl_stmt|;
name|DBusMessage
modifier|*
name|_signal
decl_stmt|;
comment|/* Do nothing if the control interface is not turned on */
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
return|return;
name|_signal
operator|=
name|dbus_message_new_signal
argument_list|(
name|wpa_s
operator|->
name|dbus_path
argument_list|,
name|WPAS_DBUS_IFACE_INTERFACE
argument_list|,
literal|"ScanResultsAvailable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_signal
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Not enough memory to send scan "
literal|"results signal"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dbus_connection_send
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|_signal
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dbus_message_unref
argument_list|(
name|_signal
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_dbus_notify_state_change - Send a state change signal  * @wpa_s: %wpa_supplicant network interface data  * @new_state: new state wpa_supplicant is entering  * @old_state: old state wpa_supplicant is leaving  * Returns: 0 on success, -1 on failure  *  * Notify listeners that wpa_supplicant has changed state  */
end_comment

begin_function
name|void
name|wpa_supplicant_dbus_notify_state_change
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|enum
name|wpa_states
name|new_state
parameter_list|,
name|enum
name|wpa_states
name|old_state
parameter_list|)
block|{
name|struct
name|wpas_dbus_priv
modifier|*
name|iface
decl_stmt|;
name|DBusMessage
modifier|*
name|_signal
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_state_str
decl_stmt|,
modifier|*
name|old_state_str
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|dbus_path
operator|==
name|NULL
condition|)
return|return;
comment|/* Skip signal since D-Bus setup is not yet ready */
comment|/* Do nothing if the control interface is not turned on */
if|if
condition|(
name|wpa_s
operator|->
name|global
operator|==
name|NULL
condition|)
return|return;
name|iface
operator|=
name|wpa_s
operator|->
name|global
operator|->
name|dbus
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
return|return;
comment|/* Only send signal if state really changed */
if|if
condition|(
name|new_state
operator|==
name|old_state
condition|)
return|return;
name|_signal
operator|=
name|dbus_message_new_signal
argument_list|(
name|wpa_s
operator|->
name|dbus_path
argument_list|,
name|WPAS_DBUS_IFACE_INTERFACE
argument_list|,
literal|"StateChange"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_signal
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: wpa_supplicant_dbus_notify_state_change: "
literal|"could not create dbus signal; likely out of "
literal|"memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_state_str
operator|=
name|wpa_supplicant_state_txt
argument_list|(
name|new_state
argument_list|)
expr_stmt|;
name|old_state_str
operator|=
name|wpa_supplicant_state_txt
argument_list|(
name|old_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_state_str
operator|==
name|NULL
operator|||
name|old_state_str
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: wpa_supplicant_dbus_notify_state_change: "
literal|"Could not convert state strings"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|dbus_message_append_args
argument_list|(
name|_signal
argument_list|,
name|DBUS_TYPE_STRING
argument_list|,
operator|&
name|new_state_str
argument_list|,
name|DBUS_TYPE_STRING
argument_list|,
operator|&
name|old_state_str
argument_list|,
name|DBUS_TYPE_INVALID
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: wpa_supplicant_dbus_notify_state_change: "
literal|"Not enough memory to construct state change "
literal|"signal"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dbus_connection_send
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|_signal
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|out
label|:
name|dbus_message_unref
argument_list|(
name|_signal
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_dbus_notify_scanning - send scanning status  * @wpa_s: %wpa_supplicant network interface data  * Returns: 0 on success, -1 on failure  *  * Notify listeners of interface scanning state changes  */
end_comment

begin_function
name|void
name|wpa_supplicant_dbus_notify_scanning
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|wpas_dbus_priv
modifier|*
name|iface
init|=
name|wpa_s
operator|->
name|global
operator|->
name|dbus
decl_stmt|;
name|DBusMessage
modifier|*
name|_signal
decl_stmt|;
name|dbus_bool_t
name|scanning
init|=
name|wpa_s
operator|->
name|scanning
condition|?
name|TRUE
else|:
name|FALSE
decl_stmt|;
comment|/* Do nothing if the control interface is not turned on */
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
return|return;
name|_signal
operator|=
name|dbus_message_new_signal
argument_list|(
name|wpa_s
operator|->
name|dbus_path
argument_list|,
name|WPAS_DBUS_IFACE_INTERFACE
argument_list|,
literal|"Scanning"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_signal
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Not enough memory to send scan "
literal|"results signal"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dbus_message_append_args
argument_list|(
name|_signal
argument_list|,
name|DBUS_TYPE_BOOLEAN
argument_list|,
operator|&
name|scanning
argument_list|,
name|DBUS_TYPE_INVALID
argument_list|)
condition|)
block|{
name|dbus_connection_send
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|_signal
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Not enough memory to construct "
literal|"signal"
argument_list|)
expr_stmt|;
block|}
name|dbus_message_unref
argument_list|(
name|_signal
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_WPS
end_ifdef

begin_function
name|void
name|wpa_supplicant_dbus_notify_wps_cred
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
specifier|const
name|struct
name|wps_credential
modifier|*
name|cred
parameter_list|)
block|{
name|struct
name|wpas_dbus_priv
modifier|*
name|iface
decl_stmt|;
name|DBusMessage
modifier|*
name|_signal
init|=
name|NULL
decl_stmt|;
comment|/* Do nothing if the control interface is not turned on */
if|if
condition|(
name|wpa_s
operator|->
name|global
operator|==
name|NULL
condition|)
return|return;
name|iface
operator|=
name|wpa_s
operator|->
name|global
operator|->
name|dbus
expr_stmt|;
if|if
condition|(
name|iface
operator|==
name|NULL
condition|)
return|return;
name|_signal
operator|=
name|dbus_message_new_signal
argument_list|(
name|wpa_s
operator|->
name|dbus_path
argument_list|,
name|WPAS_DBUS_IFACE_INTERFACE
argument_list|,
literal|"WpsCred"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_signal
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: wpa_supplicant_dbus_notify_wps_cred: "
literal|"Could not create dbus signal; likely out of "
literal|"memory"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|dbus_message_append_args
argument_list|(
name|_signal
argument_list|,
name|DBUS_TYPE_ARRAY
argument_list|,
name|DBUS_TYPE_BYTE
argument_list|,
operator|&
name|cred
operator|->
name|cred_attr
argument_list|,
name|cred
operator|->
name|cred_attr_len
argument_list|,
name|DBUS_TYPE_INVALID
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: wpa_supplicant_dbus_notify_wps_cred: "
literal|"Not enough memory to construct signal"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dbus_connection_send
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|_signal
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|out
label|:
name|dbus_message_unref
argument_list|(
name|_signal
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* CONFIG_WPS */
end_comment

begin_function
name|void
name|wpa_supplicant_dbus_notify_wps_cred
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
specifier|const
name|struct
name|wps_credential
modifier|*
name|cred
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_WPS */
end_comment

begin_comment
comment|/**  * wpa_supplicant_dbus_ctrl_iface_init - Initialize dbus control interface  * @global: Pointer to global data from wpa_supplicant_init()  * Returns: 0 on success, -1 on failure  *  * Initialize the dbus control interface and start receiving commands from  * external programs over the bus.  */
end_comment

begin_function
name|int
name|wpa_supplicant_dbus_ctrl_iface_init
parameter_list|(
name|struct
name|wpas_dbus_priv
modifier|*
name|iface
parameter_list|)
block|{
name|DBusError
name|error
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|DBusObjectPathVTable
name|wpas_vtable
init|=
block|{
name|NULL
block|,
operator|&
name|wpas_message_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
comment|/* Register the message handler for the global dbus interface */
if|if
condition|(
operator|!
name|dbus_connection_register_object_path
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|WPAS_DBUS_PATH
argument_list|,
operator|&
name|wpas_vtable
argument_list|,
name|iface
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Could not set up message "
literal|"handler"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Register our service with the message bus */
name|dbus_error_init
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dbus_bus_request_name
argument_list|(
name|iface
operator|->
name|con
argument_list|,
name|WPAS_DBUS_SERVICE
argument_list|,
literal|0
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
case|case
name|DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER
case|:
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DBUS_REQUEST_NAME_REPLY_EXISTS
case|:
case|case
name|DBUS_REQUEST_NAME_REPLY_IN_QUEUE
case|:
case|case
name|DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER
case|:
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Could not request service name: "
literal|"already registered"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Could not request service name: "
literal|"%s %s"
argument_list|,
name|error
operator|.
name|name
argument_list|,
name|error
operator|.
name|message
argument_list|)
expr_stmt|;
break|break;
block|}
name|dbus_error_free
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Providing DBus service '"
name|WPAS_DBUS_SERVICE
literal|"'."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dbus_register_new_iface - Register a new interface with dbus  * @wpa_s: %wpa_supplicant interface description structure to register  * Returns: 0 on success, -1 on error  *  * Registers a new interface with dbus and assigns it a dbus object path.  */
end_comment

begin_function
name|int
name|wpas_dbus_register_iface
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|wpas_dbus_priv
modifier|*
name|ctrl_iface
init|=
name|wpa_s
operator|->
name|global
operator|->
name|dbus
decl_stmt|;
name|DBusConnection
modifier|*
name|con
decl_stmt|;
name|u32
name|next
decl_stmt|;
name|DBusObjectPathVTable
name|vtable
init|=
block|{
name|NULL
block|,
operator|&
name|wpas_iface_message_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
comment|/* Do nothing if the control interface is not turned on */
if|if
condition|(
name|ctrl_iface
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|con
operator|=
name|ctrl_iface
operator|->
name|con
expr_stmt|;
name|next
operator|=
name|ctrl_iface
operator|->
name|next_objid
operator|++
expr_stmt|;
comment|/* Create and set the interface's object path */
name|wpa_s
operator|->
name|dbus_path
operator|=
name|os_zalloc
argument_list|(
name|WPAS_DBUS_OBJECT_PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|dbus_path
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|os_snprintf
argument_list|(
name|wpa_s
operator|->
name|dbus_path
argument_list|,
name|WPAS_DBUS_OBJECT_PATH_MAX
argument_list|,
name|WPAS_DBUS_PATH_INTERFACES
literal|"/%u"
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* Register the message handler for the interface functions */
if|if
condition|(
operator|!
name|dbus_connection_register_fallback
argument_list|(
name|con
argument_list|,
name|wpa_s
operator|->
name|dbus_path
argument_list|,
operator|&
name|vtable
argument_list|,
name|wpa_s
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"dbus: Could not set up message "
literal|"handler for interface %s"
argument_list|,
name|wpa_s
operator|->
name|ifname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpas_dbus_unregister_iface - Unregister an interface from dbus  * @wpa_s: wpa_supplicant interface structure  * Returns: 0 on success, -1 on failure  *  * Unregisters the interface with dbus  */
end_comment

begin_function
name|int
name|wpas_dbus_unregister_iface
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|wpas_dbus_priv
modifier|*
name|ctrl_iface
decl_stmt|;
name|DBusConnection
modifier|*
name|con
decl_stmt|;
comment|/* Do nothing if the control interface is not turned on */
if|if
condition|(
name|wpa_s
operator|==
name|NULL
operator|||
name|wpa_s
operator|->
name|global
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ctrl_iface
operator|=
name|wpa_s
operator|->
name|global
operator|->
name|dbus
expr_stmt|;
if|if
condition|(
name|ctrl_iface
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|con
operator|=
name|ctrl_iface
operator|->
name|con
expr_stmt|;
if|if
condition|(
operator|!
name|dbus_connection_unregister_object_path
argument_list|(
name|con
argument_list|,
name|wpa_s
operator|->
name|dbus_path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|os_free
argument_list|(
name|wpa_s
operator|->
name|dbus_path
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|dbus_path
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_get_iface_by_dbus_path - Get a new network interface  * @global: Pointer to global data from wpa_supplicant_init()  * @path: Pointer to a dbus object path representing an interface  * Returns: Pointer to the interface or %NULL if not found  */
end_comment

begin_function
name|struct
name|wpa_supplicant
modifier|*
name|wpa_supplicant_get_iface_by_dbus_path
parameter_list|(
name|struct
name|wpa_global
modifier|*
name|global
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
decl_stmt|;
for|for
control|(
name|wpa_s
operator|=
name|global
operator|->
name|ifaces
init|;
name|wpa_s
condition|;
name|wpa_s
operator|=
name|wpa_s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|wpa_s
operator|->
name|dbus_path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
return|return
name|wpa_s
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

