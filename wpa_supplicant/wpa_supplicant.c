begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * WPA Supplicant  * Copyright (c) 2003-2009, Jouni Malinen<j@w1.fi>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  *  * This file implements functions for registering and unregistering  * %wpa_supplicant interfaces. In addition, this file contains number of  * functions for managing network connections.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eapol_supp/eapol_supp_sm.h"
end_include

begin_include
include|#
directive|include
file|"eap_peer/eap.h"
end_include

begin_include
include|#
directive|include
file|"wpa.h"
end_include

begin_include
include|#
directive|include
file|"eloop.h"
end_include

begin_include
include|#
directive|include
file|"drivers/driver.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"l2_packet/l2_packet.h"
end_include

begin_include
include|#
directive|include
file|"wpa_supplicant_i.h"
end_include

begin_include
include|#
directive|include
file|"ctrl_iface.h"
end_include

begin_include
include|#
directive|include
file|"ctrl_iface_dbus.h"
end_include

begin_include
include|#
directive|include
file|"pcsc_funcs.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_include
include|#
directive|include
file|"preauth.h"
end_include

begin_include
include|#
directive|include
file|"pmksa_cache.h"
end_include

begin_include
include|#
directive|include
file|"wpa_ctrl.h"
end_include

begin_include
include|#
directive|include
file|"mlme.h"
end_include

begin_include
include|#
directive|include
file|"ieee802_11_defs.h"
end_include

begin_include
include|#
directive|include
file|"blacklist.h"
end_include

begin_include
include|#
directive|include
file|"wpas_glue.h"
end_include

begin_include
include|#
directive|include
file|"wps_supplicant.h"
end_include

begin_decl_stmt
specifier|const
name|char
modifier|*
name|wpa_supplicant_version
init|=
literal|"wpa_supplicant v"
name|VERSION_STR
literal|"\n"
literal|"Copyright (c) 2003-2009, Jouni Malinen<j@w1.fi> and contributors"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|wpa_supplicant_license
init|=
literal|"This program is free software. You can distribute it and/or modify it\n"
literal|"under the terms of the GNU General Public License version 2.\n"
literal|"\n"
literal|"Alternatively, this software may be distributed under the terms of the\n"
literal|"BSD license. See README and COPYING for more details.\n"
ifdef|#
directive|ifdef
name|EAP_TLS_OPENSSL
literal|"\nThis product includes software developed by the OpenSSL Project\n"
literal|"for use in the OpenSSL Toolkit (http://www.openssl.org/)\n"
endif|#
directive|endif
comment|/* EAP_TLS_OPENSSL */
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CONFIG_NO_STDOUT_DEBUG
end_ifndef

begin_comment
comment|/* Long text divided into parts in order to fit in C89 strings size limits. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|wpa_supplicant_full_license1
init|=
literal|"This program is free software; you can redistribute it and/or modify\n"
literal|"it under the terms of the GNU General Public License version 2 as\n"
literal|"published by the Free Software Foundation.\n"
literal|"\n"
literal|"This program is distributed in the hope that it will be useful,\n"
literal|"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
literal|"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
literal|"GNU General Public License for more details.\n"
literal|"\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|wpa_supplicant_full_license2
init|=
literal|"You should have received a copy of the GNU General Public License\n"
literal|"along with this program; if not, write to the Free Software\n"
literal|"Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n"
literal|"\n"
literal|"Alternatively, this software may be distributed under the terms of the\n"
literal|"BSD license.\n"
literal|"\n"
literal|"Redistribution and use in source and binary forms, with or without\n"
literal|"modification, are permitted provided that the following conditions are\n"
literal|"met:\n"
literal|"\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|wpa_supplicant_full_license3
init|=
literal|"1. Redistributions of source code must retain the above copyright\n"
literal|"   notice, this list of conditions and the following disclaimer.\n"
literal|"\n"
literal|"2. Redistributions in binary form must reproduce the above copyright\n"
literal|"   notice, this list of conditions and the following disclaimer in the\n"
literal|"   documentation and/or other materials provided with the distribution.\n"
literal|"\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|wpa_supplicant_full_license4
init|=
literal|"3. Neither the name(s) of the above-listed copyright holder(s) nor the\n"
literal|"   names of its contributors may be used to endorse or promote products\n"
literal|"   derived from this software without specific prior written permission.\n"
literal|"\n"
literal|"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
literal|"\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
literal|"LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n"
literal|"A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|wpa_supplicant_full_license5
init|=
literal|"OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n"
literal|"SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n"
literal|"LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
literal|"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
literal|"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
literal|"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
literal|"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
literal|"\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_NO_STDOUT_DEBUG */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|wpa_debug_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|wpa_debug_show_keys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|wpa_debug_timestamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Configure default/group WEP keys for static WEP */
end_comment

begin_function
specifier|static
name|int
name|wpa_set_wep_keys
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|ssid
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|set
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WEP_KEYS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ssid
operator|->
name|wep_key_len
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|set
operator|=
literal|1
expr_stmt|;
name|wpa_drv_set_key
argument_list|(
name|wpa_s
argument_list|,
name|WPA_ALG_WEP
argument_list|,
operator|(
name|u8
operator|*
operator|)
literal|"\xff\xff\xff\xff\xff\xff"
argument_list|,
name|i
argument_list|,
name|i
operator|==
name|ssid
operator|->
name|wep_tx_keyidx
argument_list|,
operator|(
name|u8
operator|*
operator|)
literal|""
argument_list|,
literal|0
argument_list|,
name|ssid
operator|->
name|wep_key
index|[
name|i
index|]
argument_list|,
name|ssid
operator|->
name|wep_key_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpa_supplicant_set_wpa_none_key
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|ssid
parameter_list|)
block|{
name|u8
name|key
index|[
literal|32
index|]
decl_stmt|;
name|size_t
name|keylen
decl_stmt|;
name|wpa_alg
name|alg
decl_stmt|;
name|u8
name|seq
index|[
literal|6
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* IBSS/WPA-None uses only one key (Group) for both receiving and 	 * sending unicast and multicast packets. */
if|if
condition|(
name|ssid
operator|->
name|mode
operator|!=
name|IEEE80211_MODE_IBSS
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPA: Invalid mode %d (not IBSS/ad-hoc) "
literal|"for WPA-None"
argument_list|,
name|ssid
operator|->
name|mode
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|ssid
operator|->
name|psk_set
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPA: No PSK configured for WPA-None"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|wpa_s
operator|->
name|group_cipher
condition|)
block|{
case|case
name|WPA_CIPHER_CCMP
case|:
name|os_memcpy
argument_list|(
name|key
argument_list|,
name|ssid
operator|->
name|psk
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|keylen
operator|=
literal|16
expr_stmt|;
name|alg
operator|=
name|WPA_ALG_CCMP
expr_stmt|;
break|break;
case|case
name|WPA_CIPHER_TKIP
case|:
comment|/* WPA-None uses the same Michael MIC key for both TX and RX */
name|os_memcpy
argument_list|(
name|key
argument_list|,
name|ssid
operator|->
name|psk
argument_list|,
literal|16
operator|+
literal|8
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|key
operator|+
literal|16
operator|+
literal|8
argument_list|,
name|ssid
operator|->
name|psk
operator|+
literal|16
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|keylen
operator|=
literal|32
expr_stmt|;
name|alg
operator|=
name|WPA_ALG_TKIP
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPA: Invalid group cipher %d for "
literal|"WPA-None"
argument_list|,
name|wpa_s
operator|->
name|group_cipher
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* TODO: should actually remember the previously used seq#, both for TX 	 * and RX from each STA.. */
return|return
name|wpa_drv_set_key
argument_list|(
name|wpa_s
argument_list|,
name|alg
argument_list|,
operator|(
name|u8
operator|*
operator|)
literal|"\xff\xff\xff\xff\xff\xff"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|seq
argument_list|,
literal|6
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
init|=
name|eloop_ctx
decl_stmt|;
specifier|const
name|u8
modifier|*
name|bssid
init|=
name|wpa_s
operator|->
name|bssid
decl_stmt|;
if|if
condition|(
name|is_zero_ether_addr
argument_list|(
name|bssid
argument_list|)
condition|)
name|bssid
operator|=
name|wpa_s
operator|->
name|pending_bssid
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
literal|"Authentication with "
name|MACSTR
literal|" timed out."
argument_list|,
name|MAC2STR
argument_list|(
name|bssid
argument_list|)
argument_list|)
expr_stmt|;
name|wpa_blacklist_add
argument_list|(
name|wpa_s
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|wpa_sm_notify_disassoc
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|)
expr_stmt|;
name|wpa_supplicant_disassociate
argument_list|(
name|wpa_s
argument_list|,
name|WLAN_REASON_DEAUTH_LEAVING
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|reassociate
operator|=
literal|1
expr_stmt|;
name|wpa_supplicant_req_scan
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_req_auth_timeout - Schedule a timeout for authentication  * @wpa_s: Pointer to wpa_supplicant data  * @sec: Number of seconds after which to time out authentication  * @usec: Number of microseconds after which to time out authentication  *  * This function is used to schedule a timeout for the current authentication  * attempt.  */
end_comment

begin_function
name|void
name|wpa_supplicant_req_auth_timeout
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|int
name|sec
parameter_list|,
name|int
name|usec
parameter_list|)
block|{
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|&&
name|wpa_s
operator|->
name|conf
operator|->
name|ap_scan
operator|==
literal|0
operator|&&
name|wpa_s
operator|->
name|driver
operator|&&
name|IS_WIRED
argument_list|(
name|wpa_s
operator|->
name|driver
argument_list|)
condition|)
return|return;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Setting authentication timeout: %d sec "
literal|"%d usec"
argument_list|,
name|sec
argument_list|,
name|usec
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|wpa_supplicant_timeout
argument_list|,
name|wpa_s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|sec
argument_list|,
name|usec
argument_list|,
name|wpa_supplicant_timeout
argument_list|,
name|wpa_s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_cancel_auth_timeout - Cancel authentication timeout  * @wpa_s: Pointer to wpa_supplicant data  *  * This function is used to cancel authentication timeout scheduled with  * wpa_supplicant_req_auth_timeout() and it is called when authentication has  * been completed.  */
end_comment

begin_function
name|void
name|wpa_supplicant_cancel_auth_timeout
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Cancelling authentication timeout"
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|wpa_supplicant_timeout
argument_list|,
name|wpa_s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wpa_blacklist_del
argument_list|(
name|wpa_s
argument_list|,
name|wpa_s
operator|->
name|bssid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_initiate_eapol - Configure EAPOL state machine  * @wpa_s: Pointer to wpa_supplicant data  *  * This function is used to configure EAPOL state machine based on the selected  * authentication mode.  */
end_comment

begin_function
name|void
name|wpa_supplicant_initiate_eapol
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|IEEE8021X_EAPOL
name|struct
name|eapol_config
name|eapol_conf
decl_stmt|;
name|struct
name|wpa_ssid
modifier|*
name|ssid
init|=
name|wpa_s
operator|->
name|current_ssid
decl_stmt|;
name|eapol_sm_notify_eap_success
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_sm_notify_eap_fail
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|key_mgmt
operator|==
name|WPA_KEY_MGMT_NONE
operator|||
name|wpa_s
operator|->
name|key_mgmt
operator|==
name|WPA_KEY_MGMT_WPA_NONE
condition|)
name|eapol_sm_notify_portControl
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
name|ForceAuthorized
argument_list|)
expr_stmt|;
else|else
name|eapol_sm_notify_portControl
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
name|Auto
argument_list|)
expr_stmt|;
name|os_memset
argument_list|(
operator|&
name|eapol_conf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|eapol_conf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|key_mgmt
operator|==
name|WPA_KEY_MGMT_IEEE8021X_NO_WPA
condition|)
block|{
name|eapol_conf
operator|.
name|accept_802_1x_keys
operator|=
literal|1
expr_stmt|;
name|eapol_conf
operator|.
name|required_keys
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ssid
operator|->
name|eapol_flags
operator|&
name|EAPOL_FLAG_REQUIRE_KEY_UNICAST
condition|)
block|{
name|eapol_conf
operator|.
name|required_keys
operator||=
name|EAPOL_REQUIRE_KEY_UNICAST
expr_stmt|;
block|}
if|if
condition|(
name|ssid
operator|->
name|eapol_flags
operator|&
name|EAPOL_FLAG_REQUIRE_KEY_BROADCAST
condition|)
block|{
name|eapol_conf
operator|.
name|required_keys
operator||=
name|EAPOL_REQUIRE_KEY_BROADCAST
expr_stmt|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|&&
name|wpa_s
operator|->
name|driver
operator|&&
name|IS_WIRED
argument_list|(
name|wpa_s
operator|->
name|driver
argument_list|)
condition|)
block|{
name|eapol_conf
operator|.
name|required_keys
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wpa_s
operator|->
name|conf
condition|)
name|eapol_conf
operator|.
name|fast_reauth
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|fast_reauth
expr_stmt|;
name|eapol_conf
operator|.
name|workaround
operator|=
name|ssid
operator|->
name|eap_workaround
expr_stmt|;
name|eapol_conf
operator|.
name|eap_disabled
operator|=
operator|!
name|wpa_key_mgmt_wpa_ieee8021x
argument_list|(
name|wpa_s
operator|->
name|key_mgmt
argument_list|)
operator|&&
name|wpa_s
operator|->
name|key_mgmt
operator|!=
name|WPA_KEY_MGMT_IEEE8021X_NO_WPA
operator|&&
name|wpa_s
operator|->
name|key_mgmt
operator|!=
name|WPA_KEY_MGMT_WPS
expr_stmt|;
name|eapol_sm_notify_config
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
operator|&
name|ssid
operator|->
name|eap
argument_list|,
operator|&
name|eapol_conf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IEEE8021X_EAPOL */
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_set_non_wpa_policy - Set WPA parameters to non-WPA mode  * @wpa_s: Pointer to wpa_supplicant data  * @ssid: Configuration data for the network  *  * This function is used to configure WPA state machine and related parameters  * to a mode where WPA is not enabled. This is called as part of the  * authentication configuration when the selected network does not use WPA.  */
end_comment

begin_function
name|void
name|wpa_supplicant_set_non_wpa_policy
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|ssid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ssid
operator|->
name|key_mgmt
operator|&
name|WPA_KEY_MGMT_WPS
condition|)
name|wpa_s
operator|->
name|key_mgmt
operator|=
name|WPA_KEY_MGMT_WPS
expr_stmt|;
elseif|else
if|if
condition|(
name|ssid
operator|->
name|key_mgmt
operator|&
name|WPA_KEY_MGMT_IEEE8021X_NO_WPA
condition|)
name|wpa_s
operator|->
name|key_mgmt
operator|=
name|WPA_KEY_MGMT_IEEE8021X_NO_WPA
expr_stmt|;
else|else
name|wpa_s
operator|->
name|key_mgmt
operator|=
name|WPA_KEY_MGMT_NONE
expr_stmt|;
name|wpa_sm_set_ap_wpa_ie
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpa_sm_set_ap_rsn_ie
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpa_sm_set_assoc_wpa_ie
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|pairwise_cipher
operator|=
name|WPA_CIPHER_NONE
expr_stmt|;
name|wpa_s
operator|->
name|group_cipher
operator|=
name|WPA_CIPHER_NONE
expr_stmt|;
name|wpa_s
operator|->
name|mgmt_group_cipher
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WEP_KEYS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ssid
operator|->
name|wep_key_len
index|[
name|i
index|]
operator|>
literal|5
condition|)
block|{
name|wpa_s
operator|->
name|pairwise_cipher
operator|=
name|WPA_CIPHER_WEP104
expr_stmt|;
name|wpa_s
operator|->
name|group_cipher
operator|=
name|WPA_CIPHER_WEP104
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ssid
operator|->
name|wep_key_len
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|wpa_s
operator|->
name|pairwise_cipher
operator|=
name|WPA_CIPHER_WEP40
expr_stmt|;
name|wpa_s
operator|->
name|group_cipher
operator|=
name|WPA_CIPHER_WEP40
expr_stmt|;
break|break;
block|}
block|}
name|wpa_sm_set_param
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|WPA_PARAM_RSN_ENABLED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpa_sm_set_param
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|WPA_PARAM_KEY_MGMT
argument_list|,
name|wpa_s
operator|->
name|key_mgmt
argument_list|)
expr_stmt|;
name|wpa_sm_set_param
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|WPA_PARAM_PAIRWISE
argument_list|,
name|wpa_s
operator|->
name|pairwise_cipher
argument_list|)
expr_stmt|;
name|wpa_sm_set_param
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|WPA_PARAM_GROUP
argument_list|,
name|wpa_s
operator|->
name|group_cipher
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_IEEE80211W
name|wpa_sm_set_param
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|WPA_PARAM_MGMT_GROUP
argument_list|,
name|wpa_s
operator|->
name|mgmt_group_cipher
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_IEEE80211W */
name|pmksa_cache_clear_current
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_cleanup
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|scard_deinit
argument_list|(
name|wpa_s
operator|->
name|scard
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|scard
operator|=
name|NULL
expr_stmt|;
name|wpa_sm_set_scard_ctx
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eapol_sm_register_scard_ctx
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|l2_packet_deinit
argument_list|(
name|wpa_s
operator|->
name|l2
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|l2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|l2_br
condition|)
block|{
name|l2_packet_deinit
argument_list|(
name|wpa_s
operator|->
name|l2_br
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|l2_br
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|ctrl_iface
condition|)
block|{
name|wpa_supplicant_ctrl_iface_deinit
argument_list|(
name|wpa_s
operator|->
name|ctrl_iface
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|ctrl_iface
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|!=
name|NULL
condition|)
block|{
name|wpa_config_free
argument_list|(
name|wpa_s
operator|->
name|conf
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|conf
operator|=
name|NULL
expr_stmt|;
block|}
name|os_free
argument_list|(
name|wpa_s
operator|->
name|confname
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|confname
operator|=
name|NULL
expr_stmt|;
name|wpa_sm_set_eapol
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eapol_sm_deinit
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|eapol
operator|=
name|NULL
expr_stmt|;
name|rsn_preauth_deinit
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|)
expr_stmt|;
name|pmksa_candidate_free
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|)
expr_stmt|;
name|wpa_sm_deinit
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|wpa
operator|=
name|NULL
expr_stmt|;
name|wpa_blacklist_clear
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpa_scan_results_free
argument_list|(
name|wpa_s
operator|->
name|scan_res
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|scan_res
operator|=
name|NULL
expr_stmt|;
name|wpa_supplicant_cancel_scan
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpa_supplicant_cancel_auth_timeout
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|ieee80211_sta_deinit
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpas_wps_deinit
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|wpa_s
operator|->
name|pending_eapol_rx
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|pending_eapol_rx
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_clear_keys - Clear keys configured for the driver  * @wpa_s: Pointer to wpa_supplicant data  * @addr: Previously used BSSID or %NULL if not available  *  * This function clears the encryption keys that has been previously configured  * for the driver.  */
end_comment

begin_function
name|void
name|wpa_clear_keys
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|u8
modifier|*
name|bcast
init|=
operator|(
name|u8
operator|*
operator|)
literal|"\xff\xff\xff\xff\xff\xff"
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|keys_cleared
condition|)
block|{
comment|/* Some drivers (e.g., ndiswrapper& NDIS drivers) seem to have 		 * timing issues with keys being cleared just before new keys 		 * are set or just after association or something similar. This 		 * shows up in group key handshake failing often because of the 		 * client not receiving the first encrypted packets correctly. 		 * Skipping some of the extra key clearing steps seems to help 		 * in completing group key handshake more reliably. */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"No keys have been configured - "
literal|"skip key clearing"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* MLME-DELETEKEYS.request */
name|wpa_drv_set_key
argument_list|(
name|wpa_s
argument_list|,
name|WPA_ALG_NONE
argument_list|,
name|bcast
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpa_drv_set_key
argument_list|(
name|wpa_s
argument_list|,
name|WPA_ALG_NONE
argument_list|,
name|bcast
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpa_drv_set_key
argument_list|(
name|wpa_s
argument_list|,
name|WPA_ALG_NONE
argument_list|,
name|bcast
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpa_drv_set_key
argument_list|(
name|wpa_s
argument_list|,
name|WPA_ALG_NONE
argument_list|,
name|bcast
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_IEEE80211W
name|wpa_drv_set_key
argument_list|(
name|wpa_s
argument_list|,
name|WPA_ALG_NONE
argument_list|,
name|bcast
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpa_drv_set_key
argument_list|(
name|wpa_s
argument_list|,
name|WPA_ALG_NONE
argument_list|,
name|bcast
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_IEEE80211W */
if|if
condition|(
name|addr
condition|)
block|{
name|wpa_drv_set_key
argument_list|(
name|wpa_s
argument_list|,
name|WPA_ALG_NONE
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* MLME-SETPROTECTION.request(None) */
name|wpa_drv_mlme_setprotection
argument_list|(
name|wpa_s
argument_list|,
name|addr
argument_list|,
name|MLME_SETPROTECTION_PROTECT_TYPE_NONE
argument_list|,
name|MLME_SETPROTECTION_KEY_TYPE_PAIRWISE
argument_list|)
expr_stmt|;
block|}
name|wpa_s
operator|->
name|keys_cleared
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_state_txt - Get the connection state name as a text string  * @state: State (wpa_state; WPA_*)  * Returns: The state name as a printable text string  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|wpa_supplicant_state_txt
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|WPA_DISCONNECTED
case|:
return|return
literal|"DISCONNECTED"
return|;
case|case
name|WPA_INACTIVE
case|:
return|return
literal|"INACTIVE"
return|;
case|case
name|WPA_SCANNING
case|:
return|return
literal|"SCANNING"
return|;
case|case
name|WPA_ASSOCIATING
case|:
return|return
literal|"ASSOCIATING"
return|;
case|case
name|WPA_ASSOCIATED
case|:
return|return
literal|"ASSOCIATED"
return|;
case|case
name|WPA_4WAY_HANDSHAKE
case|:
return|return
literal|"4WAY_HANDSHAKE"
return|;
case|case
name|WPA_GROUP_HANDSHAKE
case|:
return|return
literal|"GROUP_HANDSHAKE"
return|;
case|case
name|WPA_COMPLETED
case|:
return|return
literal|"COMPLETED"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_set_state - Set current connection state  * @wpa_s: Pointer to wpa_supplicant data  * @state: The new connection state  *  * This function is called whenever the connection state changes, e.g.,  * association is completed for WPA/WPA2 4-Way Handshake is started.  */
end_comment

begin_function
name|void
name|wpa_supplicant_set_state
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|wpa_states
name|state
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"State: %s -> %s"
argument_list|,
name|wpa_supplicant_state_txt
argument_list|(
name|wpa_s
operator|->
name|wpa_state
argument_list|)
argument_list|,
name|wpa_supplicant_state_txt
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|WPA_SCANNING
condition|)
name|wpa_supplicant_notify_scanning
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpa_supplicant_dbus_notify_state_change
argument_list|(
name|wpa_s
argument_list|,
name|state
argument_list|,
name|wpa_s
operator|->
name|wpa_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|WPA_COMPLETED
operator|&&
name|wpa_s
operator|->
name|new_connection
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CTRL_IFACE
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|CONFIG_NO_STDOUT_DEBUG
argument_list|)
name|struct
name|wpa_ssid
modifier|*
name|ssid
init|=
name|wpa_s
operator|->
name|current_ssid
decl_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_CONNECTED
literal|"- Connection to "
name|MACSTR
literal|" completed %s [id=%d id_str=%s]"
argument_list|,
name|MAC2STR
argument_list|(
name|wpa_s
operator|->
name|bssid
argument_list|)
argument_list|,
name|wpa_s
operator|->
name|reassociated_connection
condition|?
literal|"(reauth)"
else|:
literal|"(auth)"
argument_list|,
name|ssid
condition|?
name|ssid
operator|->
name|id
else|:
operator|-
literal|1
argument_list|,
name|ssid
operator|&&
name|ssid
operator|->
name|id_str
condition|?
name|ssid
operator|->
name|id_str
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
name|wpa_s
operator|->
name|new_connection
operator|=
literal|0
expr_stmt|;
name|wpa_s
operator|->
name|reassociated_connection
operator|=
literal|1
expr_stmt|;
name|wpa_drv_set_operstate
argument_list|(
name|wpa_s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|WPA_DISCONNECTED
operator|||
name|state
operator|==
name|WPA_ASSOCIATING
operator|||
name|state
operator|==
name|WPA_ASSOCIATED
condition|)
block|{
name|wpa_s
operator|->
name|new_connection
operator|=
literal|1
expr_stmt|;
name|wpa_drv_set_operstate
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|wpa_s
operator|->
name|wpa_state
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_terminate
parameter_list|(
name|int
name|sig
parameter_list|,
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|signal_ctx
parameter_list|)
block|{
name|struct
name|wpa_global
modifier|*
name|global
init|=
name|eloop_ctx
decl_stmt|;
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
decl_stmt|;
for|for
control|(
name|wpa_s
operator|=
name|global
operator|->
name|ifaces
init|;
name|wpa_s
condition|;
name|wpa_s
operator|=
name|wpa_s
operator|->
name|next
control|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_TERMINATING
literal|"- signal %d "
literal|"received"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
name|eloop_terminate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_clear_status
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|wpa_s
operator|->
name|pairwise_cipher
operator|=
literal|0
expr_stmt|;
name|wpa_s
operator|->
name|group_cipher
operator|=
literal|0
expr_stmt|;
name|wpa_s
operator|->
name|mgmt_group_cipher
operator|=
literal|0
expr_stmt|;
name|wpa_s
operator|->
name|key_mgmt
operator|=
literal|0
expr_stmt|;
name|wpa_s
operator|->
name|wpa_state
operator|=
name|WPA_DISCONNECTED
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_reload_configuration - Reload configuration data  * @wpa_s: Pointer to wpa_supplicant data  * Returns: 0 on success or -1 if configuration parsing failed  *  * This function can be used to request that the configuration data is reloaded  * (e.g., after configuration file change). This function is reloading  * configuration only for one interface, so this may need to be called multiple  * times if %wpa_supplicant is controlling multiple interfaces and all  * interfaces need reconfiguration.  */
end_comment

begin_function
name|int
name|wpa_supplicant_reload_configuration
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|wpa_config
modifier|*
name|conf
decl_stmt|;
name|int
name|reconf_ctrl
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|confname
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|conf
operator|=
name|wpa_config_read
argument_list|(
name|wpa_s
operator|->
name|confname
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|==
name|NULL
condition|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_ERROR
argument_list|,
literal|"Failed to parse the configuration "
literal|"file '%s' - exiting"
argument_list|,
name|wpa_s
operator|->
name|confname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|reconf_ctrl
operator|=
operator|!
operator|!
name|conf
operator|->
name|ctrl_interface
operator|!=
operator|!
operator|!
name|wpa_s
operator|->
name|conf
operator|->
name|ctrl_interface
operator|||
operator|(
name|conf
operator|->
name|ctrl_interface
operator|&&
name|wpa_s
operator|->
name|conf
operator|->
name|ctrl_interface
operator|&&
name|os_strcmp
argument_list|(
name|conf
operator|->
name|ctrl_interface
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|ctrl_interface
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|reconf_ctrl
operator|&&
name|wpa_s
operator|->
name|ctrl_iface
condition|)
block|{
name|wpa_supplicant_ctrl_iface_deinit
argument_list|(
name|wpa_s
operator|->
name|ctrl_iface
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|ctrl_iface
operator|=
name|NULL
expr_stmt|;
block|}
name|eapol_sm_invalidate_cached_session
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|current_ssid
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * TODO: should notify EAPOL SM about changes in opensc_engine_path, 	 * pkcs11_engine_path, pkcs11_module_path. 	 */
if|if
condition|(
name|wpa_key_mgmt_wpa_psk
argument_list|(
name|wpa_s
operator|->
name|key_mgmt
argument_list|)
condition|)
block|{
comment|/* 		 * Clear forced success to clear EAP state for next 		 * authentication. 		 */
name|eapol_sm_notify_eap_success
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|eapol_sm_notify_config
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wpa_sm_set_config
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wpa_sm_set_fast_reauth
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|fast_reauth
argument_list|)
expr_stmt|;
name|rsn_preauth_deinit
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|)
expr_stmt|;
name|wpa_config_free
argument_list|(
name|wpa_s
operator|->
name|conf
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|conf
operator|=
name|conf
expr_stmt|;
if|if
condition|(
name|reconf_ctrl
condition|)
name|wpa_s
operator|->
name|ctrl_iface
operator|=
name|wpa_supplicant_ctrl_iface_init
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpa_supplicant_clear_status
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|reassociate
operator|=
literal|1
expr_stmt|;
name|wpa_supplicant_req_scan
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"Reconfiguration completed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_reconfig
parameter_list|(
name|int
name|sig
parameter_list|,
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|signal_ctx
parameter_list|)
block|{
name|struct
name|wpa_global
modifier|*
name|global
init|=
name|eloop_ctx
decl_stmt|;
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Signal %d received - reconfiguring"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
for|for
control|(
name|wpa_s
operator|=
name|global
operator|->
name|ifaces
init|;
name|wpa_s
condition|;
name|wpa_s
operator|=
name|wpa_s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|wpa_supplicant_reload_configuration
argument_list|(
name|wpa_s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|eloop_terminate
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|wpa_cipher
name|cipher_suite2driver
parameter_list|(
name|int
name|cipher
parameter_list|)
block|{
switch|switch
condition|(
name|cipher
condition|)
block|{
case|case
name|WPA_CIPHER_NONE
case|:
return|return
name|CIPHER_NONE
return|;
case|case
name|WPA_CIPHER_WEP40
case|:
return|return
name|CIPHER_WEP40
return|;
case|case
name|WPA_CIPHER_WEP104
case|:
return|return
name|CIPHER_WEP104
return|;
case|case
name|WPA_CIPHER_CCMP
case|:
return|return
name|CIPHER_CCMP
return|;
case|case
name|WPA_CIPHER_TKIP
case|:
default|default:
return|return
name|CIPHER_TKIP
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|wpa_key_mgmt
name|key_mgmt2driver
parameter_list|(
name|int
name|key_mgmt
parameter_list|)
block|{
switch|switch
condition|(
name|key_mgmt
condition|)
block|{
case|case
name|WPA_KEY_MGMT_NONE
case|:
return|return
name|KEY_MGMT_NONE
return|;
case|case
name|WPA_KEY_MGMT_IEEE8021X_NO_WPA
case|:
return|return
name|KEY_MGMT_802_1X_NO_WPA
return|;
case|case
name|WPA_KEY_MGMT_IEEE8021X
case|:
return|return
name|KEY_MGMT_802_1X
return|;
case|case
name|WPA_KEY_MGMT_WPA_NONE
case|:
return|return
name|KEY_MGMT_WPA_NONE
return|;
case|case
name|WPA_KEY_MGMT_FT_IEEE8021X
case|:
return|return
name|KEY_MGMT_FT_802_1X
return|;
case|case
name|WPA_KEY_MGMT_FT_PSK
case|:
return|return
name|KEY_MGMT_FT_PSK
return|;
case|case
name|WPA_KEY_MGMT_IEEE8021X_SHA256
case|:
return|return
name|KEY_MGMT_802_1X_SHA256
return|;
case|case
name|WPA_KEY_MGMT_PSK_SHA256
case|:
return|return
name|KEY_MGMT_PSK_SHA256
return|;
case|case
name|WPA_KEY_MGMT_WPS
case|:
return|return
name|KEY_MGMT_WPS
return|;
case|case
name|WPA_KEY_MGMT_PSK
case|:
default|default:
return|return
name|KEY_MGMT_PSK
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wpa_supplicant_suites_from_ai
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|ssid
parameter_list|,
name|struct
name|wpa_ie_data
modifier|*
name|ie
parameter_list|)
block|{
name|int
name|ret
init|=
name|wpa_sm_parse_own_wpa_ie
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|ie
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|ret
operator|==
operator|-
literal|2
condition|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
literal|"WPA: Failed to parse WPA IE "
literal|"from association info"
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPA: Using WPA IE from AssocReq to set cipher "
literal|"suites"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ie
operator|->
name|group_cipher
operator|&
name|ssid
operator|->
name|group_cipher
operator|)
condition|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
literal|"WPA: Driver used disabled group "
literal|"cipher 0x%x (mask 0x%x) - reject"
argument_list|,
name|ie
operator|->
name|group_cipher
argument_list|,
name|ssid
operator|->
name|group_cipher
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|ie
operator|->
name|pairwise_cipher
operator|&
name|ssid
operator|->
name|pairwise_cipher
operator|)
condition|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
literal|"WPA: Driver used disabled pairwise "
literal|"cipher 0x%x (mask 0x%x) - reject"
argument_list|,
name|ie
operator|->
name|pairwise_cipher
argument_list|,
name|ssid
operator|->
name|pairwise_cipher
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|ie
operator|->
name|key_mgmt
operator|&
name|ssid
operator|->
name|key_mgmt
operator|)
condition|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
literal|"WPA: Driver used disabled key "
literal|"management 0x%x (mask 0x%x) - reject"
argument_list|,
name|ie
operator|->
name|key_mgmt
argument_list|,
name|ssid
operator|->
name|key_mgmt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_IEEE80211W
if|if
condition|(
operator|!
operator|(
name|ie
operator|->
name|capabilities
operator|&
name|WPA_CAPABILITY_MFPC
operator|)
operator|&&
name|ssid
operator|->
name|ieee80211w
operator|==
name|IEEE80211W_REQUIRED
condition|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
literal|"WPA: Driver associated with an AP "
literal|"that does not support management frame protection - "
literal|"reject"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* CONFIG_IEEE80211W */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_set_suites - Set authentication and encryption parameters  * @wpa_s: Pointer to wpa_supplicant data  * @bss: Scan results for the selected BSS, or %NULL if not available  * @ssid: Configuration data for the selected network  * @wpa_ie: Buffer for the WPA/RSN IE  * @wpa_ie_len: Maximum wpa_ie buffer size on input. This is changed to be the  * used buffer length in case the functions returns success.  * Returns: 0 on success or -1 on failure  *  * This function is used to configure authentication and encryption parameters  * based on the network configuration and scan result for the selected BSS (if  * available).  */
end_comment

begin_function
name|int
name|wpa_supplicant_set_suites
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_scan_res
modifier|*
name|bss
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|ssid
parameter_list|,
name|u8
modifier|*
name|wpa_ie
parameter_list|,
name|size_t
modifier|*
name|wpa_ie_len
parameter_list|)
block|{
name|struct
name|wpa_ie_data
name|ie
decl_stmt|;
name|int
name|sel
decl_stmt|,
name|proto
decl_stmt|;
specifier|const
name|u8
modifier|*
name|bss_wpa
decl_stmt|,
modifier|*
name|bss_rsn
decl_stmt|;
if|if
condition|(
name|bss
condition|)
block|{
name|bss_wpa
operator|=
name|wpa_scan_get_vendor_ie
argument_list|(
name|bss
argument_list|,
name|WPA_IE_VENDOR_TYPE
argument_list|)
expr_stmt|;
name|bss_rsn
operator|=
name|wpa_scan_get_ie
argument_list|(
name|bss
argument_list|,
name|WLAN_EID_RSN
argument_list|)
expr_stmt|;
block|}
else|else
name|bss_wpa
operator|=
name|bss_rsn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bss_rsn
operator|&&
operator|(
name|ssid
operator|->
name|proto
operator|&
name|WPA_PROTO_RSN
operator|)
operator|&&
name|wpa_parse_wpa_ie
argument_list|(
name|bss_rsn
argument_list|,
literal|2
operator|+
name|bss_rsn
index|[
literal|1
index|]
argument_list|,
operator|&
name|ie
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ie
operator|.
name|group_cipher
operator|&
name|ssid
operator|->
name|group_cipher
operator|)
operator|&&
operator|(
name|ie
operator|.
name|pairwise_cipher
operator|&
name|ssid
operator|->
name|pairwise_cipher
operator|)
operator|&&
operator|(
name|ie
operator|.
name|key_mgmt
operator|&
name|ssid
operator|->
name|key_mgmt
operator|)
condition|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"RSN: using IEEE 802.11i/D9.0"
argument_list|)
expr_stmt|;
name|proto
operator|=
name|WPA_PROTO_RSN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bss_wpa
operator|&&
operator|(
name|ssid
operator|->
name|proto
operator|&
name|WPA_PROTO_WPA
operator|)
operator|&&
name|wpa_parse_wpa_ie
argument_list|(
name|bss_wpa
argument_list|,
literal|2
operator|+
name|bss_wpa
index|[
literal|1
index|]
argument_list|,
operator|&
name|ie
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ie
operator|.
name|group_cipher
operator|&
name|ssid
operator|->
name|group_cipher
operator|)
operator|&&
operator|(
name|ie
operator|.
name|pairwise_cipher
operator|&
name|ssid
operator|->
name|pairwise_cipher
operator|)
operator|&&
operator|(
name|ie
operator|.
name|key_mgmt
operator|&
name|ssid
operator|->
name|key_mgmt
operator|)
condition|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using IEEE 802.11i/D3.0"
argument_list|)
expr_stmt|;
name|proto
operator|=
name|WPA_PROTO_WPA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bss
condition|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_WARNING
argument_list|,
literal|"WPA: Failed to select WPA/RSN"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|ssid
operator|->
name|proto
operator|&
name|WPA_PROTO_RSN
condition|)
name|proto
operator|=
name|WPA_PROTO_RSN
expr_stmt|;
else|else
name|proto
operator|=
name|WPA_PROTO_WPA
expr_stmt|;
if|if
condition|(
name|wpa_supplicant_suites_from_ai
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|,
operator|&
name|ie
argument_list|)
operator|<
literal|0
condition|)
block|{
name|os_memset
argument_list|(
operator|&
name|ie
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ie
argument_list|)
argument_list|)
expr_stmt|;
name|ie
operator|.
name|group_cipher
operator|=
name|ssid
operator|->
name|group_cipher
expr_stmt|;
name|ie
operator|.
name|pairwise_cipher
operator|=
name|ssid
operator|->
name|pairwise_cipher
expr_stmt|;
name|ie
operator|.
name|key_mgmt
operator|=
name|ssid
operator|->
name|key_mgmt
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_IEEE80211W
name|ie
operator|.
name|mgmt_group_cipher
operator|=
name|ssid
operator|->
name|ieee80211w
operator|!=
name|NO_IEEE80211W
condition|?
name|WPA_CIPHER_AES_128_CMAC
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_IEEE80211W */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPA: Set cipher suites based "
literal|"on configuration"
argument_list|)
expr_stmt|;
block|}
else|else
name|proto
operator|=
name|ie
operator|.
name|proto
expr_stmt|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPA: Selected cipher suites: group %d "
literal|"pairwise %d key_mgmt %d proto %d"
argument_list|,
name|ie
operator|.
name|group_cipher
argument_list|,
name|ie
operator|.
name|pairwise_cipher
argument_list|,
name|ie
operator|.
name|key_mgmt
argument_list|,
name|proto
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_IEEE80211W
if|if
condition|(
name|ssid
operator|->
name|ieee80211w
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPA: Selected mgmt group cipher %d"
argument_list|,
name|ie
operator|.
name|mgmt_group_cipher
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CONFIG_IEEE80211W */
name|wpa_sm_set_param
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|WPA_PARAM_PROTO
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|wpa_sm_set_param
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|WPA_PARAM_RSN_ENABLED
argument_list|,
operator|!
operator|!
operator|(
name|ssid
operator|->
name|proto
operator|&
name|WPA_PROTO_RSN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bss
operator|||
operator|!
name|wpa_s
operator|->
name|ap_ies_from_associnfo
condition|)
block|{
if|if
condition|(
name|wpa_sm_set_ap_wpa_ie
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|bss_wpa
argument_list|,
name|bss_wpa
condition|?
literal|2
operator|+
name|bss_wpa
index|[
literal|1
index|]
else|:
literal|0
argument_list|)
operator|||
name|wpa_sm_set_ap_rsn_ie
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|bss_rsn
argument_list|,
name|bss_rsn
condition|?
literal|2
operator|+
name|bss_rsn
index|[
literal|1
index|]
else|:
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|sel
operator|=
name|ie
operator|.
name|group_cipher
operator|&
name|ssid
operator|->
name|group_cipher
expr_stmt|;
if|if
condition|(
name|sel
operator|&
name|WPA_CIPHER_CCMP
condition|)
block|{
name|wpa_s
operator|->
name|group_cipher
operator|=
name|WPA_CIPHER_CCMP
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using GTK CCMP"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sel
operator|&
name|WPA_CIPHER_TKIP
condition|)
block|{
name|wpa_s
operator|->
name|group_cipher
operator|=
name|WPA_CIPHER_TKIP
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using GTK TKIP"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sel
operator|&
name|WPA_CIPHER_WEP104
condition|)
block|{
name|wpa_s
operator|->
name|group_cipher
operator|=
name|WPA_CIPHER_WEP104
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using GTK WEP104"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sel
operator|&
name|WPA_CIPHER_WEP40
condition|)
block|{
name|wpa_s
operator|->
name|group_cipher
operator|=
name|WPA_CIPHER_WEP40
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using GTK WEP40"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"WPA: Failed to select group cipher."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sel
operator|=
name|ie
operator|.
name|pairwise_cipher
operator|&
name|ssid
operator|->
name|pairwise_cipher
expr_stmt|;
if|if
condition|(
name|sel
operator|&
name|WPA_CIPHER_CCMP
condition|)
block|{
name|wpa_s
operator|->
name|pairwise_cipher
operator|=
name|WPA_CIPHER_CCMP
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using PTK CCMP"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sel
operator|&
name|WPA_CIPHER_TKIP
condition|)
block|{
name|wpa_s
operator|->
name|pairwise_cipher
operator|=
name|WPA_CIPHER_TKIP
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using PTK TKIP"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sel
operator|&
name|WPA_CIPHER_NONE
condition|)
block|{
name|wpa_s
operator|->
name|pairwise_cipher
operator|=
name|WPA_CIPHER_NONE
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using PTK NONE"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"WPA: Failed to select pairwise "
literal|"cipher."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sel
operator|=
name|ie
operator|.
name|key_mgmt
operator|&
name|ssid
operator|->
name|key_mgmt
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_IEEE80211R
block|}
elseif|else
if|if
condition|(
name|sel
operator|&
name|WPA_KEY_MGMT_FT_IEEE8021X
condition|)
block|{
name|wpa_s
operator|->
name|key_mgmt
operator|=
name|WPA_KEY_MGMT_FT_IEEE8021X
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using KEY_MGMT FT/802.1X"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sel
operator|&
name|WPA_KEY_MGMT_FT_PSK
condition|)
block|{
name|wpa_s
operator|->
name|key_mgmt
operator|=
name|WPA_KEY_MGMT_FT_PSK
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using KEY_MGMT FT/PSK"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_IEEE80211R */
ifdef|#
directive|ifdef
name|CONFIG_IEEE80211W
block|}
elseif|else
if|if
condition|(
name|sel
operator|&
name|WPA_KEY_MGMT_IEEE8021X_SHA256
condition|)
block|{
name|wpa_s
operator|->
name|key_mgmt
operator|=
name|WPA_KEY_MGMT_IEEE8021X_SHA256
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using KEY_MGMT 802.1X with SHA256"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sel
operator|&
name|WPA_KEY_MGMT_PSK_SHA256
condition|)
block|{
name|wpa_s
operator|->
name|key_mgmt
operator|=
name|WPA_KEY_MGMT_PSK_SHA256
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using KEY_MGMT PSK with SHA256"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_IEEE80211W */
block|}
elseif|else
if|if
condition|(
name|sel
operator|&
name|WPA_KEY_MGMT_IEEE8021X
condition|)
block|{
name|wpa_s
operator|->
name|key_mgmt
operator|=
name|WPA_KEY_MGMT_IEEE8021X
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using KEY_MGMT 802.1X"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sel
operator|&
name|WPA_KEY_MGMT_PSK
condition|)
block|{
name|wpa_s
operator|->
name|key_mgmt
operator|=
name|WPA_KEY_MGMT_PSK
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using KEY_MGMT WPA-PSK"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sel
operator|&
name|WPA_KEY_MGMT_WPA_NONE
condition|)
block|{
name|wpa_s
operator|->
name|key_mgmt
operator|=
name|WPA_KEY_MGMT_WPA_NONE
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using KEY_MGMT WPA-NONE"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"WPA: Failed to select authenticated "
literal|"key management type."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wpa_sm_set_param
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|WPA_PARAM_KEY_MGMT
argument_list|,
name|wpa_s
operator|->
name|key_mgmt
argument_list|)
expr_stmt|;
name|wpa_sm_set_param
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|WPA_PARAM_PAIRWISE
argument_list|,
name|wpa_s
operator|->
name|pairwise_cipher
argument_list|)
expr_stmt|;
name|wpa_sm_set_param
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|WPA_PARAM_GROUP
argument_list|,
name|wpa_s
operator|->
name|group_cipher
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_IEEE80211W
name|sel
operator|=
name|ie
operator|.
name|mgmt_group_cipher
expr_stmt|;
if|if
condition|(
name|ssid
operator|->
name|ieee80211w
operator|==
name|NO_IEEE80211W
operator|||
operator|!
operator|(
name|ie
operator|.
name|capabilities
operator|&
name|WPA_CAPABILITY_MFPC
operator|)
condition|)
name|sel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sel
operator|&
name|WPA_CIPHER_AES_128_CMAC
condition|)
block|{
name|wpa_s
operator|->
name|mgmt_group_cipher
operator|=
name|WPA_CIPHER_AES_128_CMAC
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: using MGMT group cipher "
literal|"AES-128-CMAC"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_s
operator|->
name|mgmt_group_cipher
operator|=
literal|0
expr_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_DEBUG
argument_list|,
literal|"WPA: not using MGMT group cipher"
argument_list|)
expr_stmt|;
block|}
name|wpa_sm_set_param
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|WPA_PARAM_MGMT_GROUP
argument_list|,
name|wpa_s
operator|->
name|mgmt_group_cipher
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_IEEE80211W */
if|if
condition|(
name|wpa_sm_set_assoc_wpa_ie_default
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|wpa_ie
argument_list|,
name|wpa_ie_len
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"WPA: Failed to generate WPA IE."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ssid
operator|->
name|key_mgmt
operator|&
operator|(
name|WPA_KEY_MGMT_PSK
operator||
name|WPA_KEY_MGMT_FT_PSK
operator||
name|WPA_KEY_MGMT_PSK_SHA256
operator|)
condition|)
name|wpa_sm_set_pmk
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|ssid
operator|->
name|psk
argument_list|,
name|PMK_LEN
argument_list|)
expr_stmt|;
else|else
name|wpa_sm_set_pmk_from_pmksa
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_associate - Request association  * @wpa_s: Pointer to wpa_supplicant data  * @bss: Scan results for the selected BSS, or %NULL if not available  * @ssid: Configuration data for the selected network  *  * This function is used to request %wpa_supplicant to associate with a BSS.  */
end_comment

begin_function
name|void
name|wpa_supplicant_associate
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_scan_res
modifier|*
name|bss
parameter_list|,
name|struct
name|wpa_ssid
modifier|*
name|ssid
parameter_list|)
block|{
name|u8
name|wpa_ie
index|[
literal|80
index|]
decl_stmt|;
name|size_t
name|wpa_ie_len
decl_stmt|;
name|int
name|use_crypt
decl_stmt|,
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|int
name|algs
init|=
name|AUTH_ALG_OPEN_SYSTEM
decl_stmt|;
name|wpa_cipher
name|cipher_pairwise
decl_stmt|,
name|cipher_group
decl_stmt|;
name|struct
name|wpa_driver_associate_params
name|params
decl_stmt|;
name|int
name|wep_keys_set
init|=
literal|0
decl_stmt|;
name|struct
name|wpa_driver_capa
name|capa
decl_stmt|;
name|int
name|assoc_failed
init|=
literal|0
decl_stmt|;
name|wpa_s
operator|->
name|reassociate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bss
condition|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_IEEE80211R
specifier|const
name|u8
modifier|*
name|md
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* CONFIG_IEEE80211R */
specifier|const
name|u8
modifier|*
name|ie
init|=
name|wpa_scan_get_ie
argument_list|(
name|bss
argument_list|,
name|WLAN_EID_SSID
argument_list|)
decl_stmt|;
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
literal|"Trying to associate with "
name|MACSTR
literal|" (SSID='%s' freq=%d MHz)"
argument_list|,
name|MAC2STR
argument_list|(
name|bss
operator|->
name|bssid
argument_list|)
argument_list|,
name|ie
condition|?
name|wpa_ssid_txt
argument_list|(
name|ie
operator|+
literal|2
argument_list|,
name|ie
index|[
literal|1
index|]
argument_list|)
else|:
literal|""
argument_list|,
name|bss
operator|->
name|freq
argument_list|)
expr_stmt|;
name|os_memset
argument_list|(
name|wpa_s
operator|->
name|bssid
argument_list|,
literal|0
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|wpa_s
operator|->
name|pending_bssid
argument_list|,
name|bss
operator|->
name|bssid
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_IEEE80211R
name|ie
operator|=
name|wpa_scan_get_ie
argument_list|(
name|bss
argument_list|,
name|WLAN_EID_MOBILITY_DOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|&&
name|ie
index|[
literal|1
index|]
operator|>=
name|MOBILITY_DOMAIN_ID_LEN
condition|)
name|md
operator|=
name|ie
operator|+
literal|2
expr_stmt|;
name|wpa_sm_set_ft_params
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|md
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
condition|)
block|{
comment|/* Prepare for the next transition */
name|wpa_ft_prepare_auth_request
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CONFIG_IEEE80211R */
ifdef|#
directive|ifdef
name|CONFIG_WPS
block|}
elseif|else
if|if
condition|(
operator|(
name|ssid
operator|->
name|ssid
operator|==
name|NULL
operator|||
name|ssid
operator|->
name|ssid_len
operator|==
literal|0
operator|)
operator|&&
name|wpa_s
operator|->
name|conf
operator|->
name|ap_scan
operator|==
literal|2
operator|&&
operator|(
name|ssid
operator|->
name|key_mgmt
operator|&
name|WPA_KEY_MGMT_WPS
operator|)
condition|)
block|{
comment|/* Use ap_scan==1 style network selection to find the network 		 */
name|wpa_s
operator|->
name|scan_req
operator|=
literal|2
expr_stmt|;
name|wpa_s
operator|->
name|reassociate
operator|=
literal|1
expr_stmt|;
name|wpa_supplicant_req_scan
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* CONFIG_WPS */
block|}
else|else
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
literal|"Trying to associate with SSID '%s'"
argument_list|,
name|wpa_ssid_txt
argument_list|(
name|ssid
operator|->
name|ssid
argument_list|,
name|ssid
operator|->
name|ssid_len
argument_list|)
argument_list|)
expr_stmt|;
name|os_memset
argument_list|(
name|wpa_s
operator|->
name|pending_bssid
argument_list|,
literal|0
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
block|}
name|wpa_supplicant_cancel_scan
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
comment|/* Starting new association, so clear the possibly used WPA IE from the 	 * previous association. */
name|wpa_sm_set_assoc_wpa_ie
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_drv_set_mode
argument_list|(
name|wpa_s
argument_list|,
name|ssid
operator|->
name|mode
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Failed to set operating mode"
argument_list|)
expr_stmt|;
name|assoc_failed
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE8021X_EAPOL
if|if
condition|(
name|ssid
operator|->
name|key_mgmt
operator|&
name|WPA_KEY_MGMT_IEEE8021X_NO_WPA
condition|)
block|{
if|if
condition|(
name|ssid
operator|->
name|leap
condition|)
block|{
if|if
condition|(
name|ssid
operator|->
name|non_leap
operator|==
literal|0
condition|)
name|algs
operator|=
name|AUTH_ALG_LEAP
expr_stmt|;
else|else
name|algs
operator||=
name|AUTH_ALG_LEAP
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* IEEE8021X_EAPOL */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Automatic auth_alg selection: 0x%x"
argument_list|,
name|algs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssid
operator|->
name|auth_alg
condition|)
block|{
name|algs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ssid
operator|->
name|auth_alg
operator|&
name|WPA_AUTH_ALG_OPEN
condition|)
name|algs
operator||=
name|AUTH_ALG_OPEN_SYSTEM
expr_stmt|;
if|if
condition|(
name|ssid
operator|->
name|auth_alg
operator|&
name|WPA_AUTH_ALG_SHARED
condition|)
name|algs
operator||=
name|AUTH_ALG_SHARED_KEY
expr_stmt|;
if|if
condition|(
name|ssid
operator|->
name|auth_alg
operator|&
name|WPA_AUTH_ALG_LEAP
condition|)
name|algs
operator||=
name|AUTH_ALG_LEAP
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Overriding auth_alg selection: 0x%x"
argument_list|,
name|algs
argument_list|)
expr_stmt|;
block|}
name|wpa_drv_set_auth_alg
argument_list|(
name|wpa_s
argument_list|,
name|algs
argument_list|)
expr_stmt|;
if|if
condition|(
name|bss
operator|&&
operator|(
name|wpa_scan_get_vendor_ie
argument_list|(
name|bss
argument_list|,
name|WPA_IE_VENDOR_TYPE
argument_list|)
operator|||
name|wpa_scan_get_ie
argument_list|(
name|bss
argument_list|,
name|WLAN_EID_RSN
argument_list|)
operator|)
operator|&&
operator|(
name|ssid
operator|->
name|key_mgmt
operator|&
operator|(
name|WPA_KEY_MGMT_IEEE8021X
operator||
name|WPA_KEY_MGMT_PSK
operator||
name|WPA_KEY_MGMT_FT_IEEE8021X
operator||
name|WPA_KEY_MGMT_FT_PSK
operator||
name|WPA_KEY_MGMT_IEEE8021X_SHA256
operator||
name|WPA_KEY_MGMT_PSK_SHA256
operator|)
operator|)
condition|)
block|{
name|int
name|try_opportunistic
decl_stmt|;
name|try_opportunistic
operator|=
name|ssid
operator|->
name|proactive_key_caching
operator|&&
operator|(
name|ssid
operator|->
name|proto
operator|&
name|WPA_PROTO_RSN
operator|)
expr_stmt|;
if|if
condition|(
name|pmksa_cache_set_current
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|NULL
argument_list|,
name|bss
operator|->
name|bssid
argument_list|,
name|wpa_s
operator|->
name|current_ssid
argument_list|,
name|try_opportunistic
argument_list|)
operator|==
literal|0
condition|)
name|eapol_sm_notify_pmkid_attempt
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wpa_ie_len
operator|=
sizeof|sizeof
argument_list|(
name|wpa_ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_supplicant_set_suites
argument_list|(
name|wpa_s
argument_list|,
name|bss
argument_list|,
name|ssid
argument_list|,
name|wpa_ie
argument_list|,
operator|&
name|wpa_ie_len
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"WPA: Failed to set WPA key "
literal|"management and encryption suites"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ssid
operator|->
name|key_mgmt
operator|&
operator|(
name|WPA_KEY_MGMT_PSK
operator||
name|WPA_KEY_MGMT_IEEE8021X
operator||
name|WPA_KEY_MGMT_WPA_NONE
operator||
name|WPA_KEY_MGMT_FT_PSK
operator||
name|WPA_KEY_MGMT_FT_IEEE8021X
operator||
name|WPA_KEY_MGMT_PSK_SHA256
operator||
name|WPA_KEY_MGMT_IEEE8021X_SHA256
operator|)
condition|)
block|{
name|wpa_ie_len
operator|=
sizeof|sizeof
argument_list|(
name|wpa_ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_supplicant_set_suites
argument_list|(
name|wpa_s
argument_list|,
name|NULL
argument_list|,
name|ssid
argument_list|,
name|wpa_ie
argument_list|,
operator|&
name|wpa_ie_len
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"WPA: Failed to set WPA key "
literal|"management and encryption suites (no scan "
literal|"results)"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|CONFIG_WPS
block|}
elseif|else
if|if
condition|(
name|ssid
operator|->
name|key_mgmt
operator|&
name|WPA_KEY_MGMT_WPS
condition|)
block|{
name|struct
name|wpabuf
modifier|*
name|wps_ie
decl_stmt|;
name|wps_ie
operator|=
name|wps_build_assoc_req_ie
argument_list|(
name|wpas_wps_get_req_type
argument_list|(
name|ssid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wps_ie
operator|&&
name|wpabuf_len
argument_list|(
name|wps_ie
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|wpa_ie
argument_list|)
condition|)
block|{
name|wpa_ie_len
operator|=
name|wpabuf_len
argument_list|(
name|wps_ie
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|wpa_ie
argument_list|,
name|wpabuf_head
argument_list|(
name|wps_ie
argument_list|)
argument_list|,
name|wpa_ie_len
argument_list|)
expr_stmt|;
block|}
else|else
name|wpa_ie_len
operator|=
literal|0
expr_stmt|;
name|wpabuf_free
argument_list|(
name|wps_ie
argument_list|)
expr_stmt|;
name|wpa_supplicant_set_non_wpa_policy
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_WPS */
block|}
else|else
block|{
name|wpa_supplicant_set_non_wpa_policy
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
name|wpa_ie_len
operator|=
literal|0
expr_stmt|;
block|}
name|wpa_clear_keys
argument_list|(
name|wpa_s
argument_list|,
name|bss
condition|?
name|bss
operator|->
name|bssid
else|:
name|NULL
argument_list|)
expr_stmt|;
name|use_crypt
operator|=
literal|1
expr_stmt|;
name|cipher_pairwise
operator|=
name|cipher_suite2driver
argument_list|(
name|wpa_s
operator|->
name|pairwise_cipher
argument_list|)
expr_stmt|;
name|cipher_group
operator|=
name|cipher_suite2driver
argument_list|(
name|wpa_s
operator|->
name|group_cipher
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|key_mgmt
operator|==
name|WPA_KEY_MGMT_NONE
operator|||
name|wpa_s
operator|->
name|key_mgmt
operator|==
name|WPA_KEY_MGMT_IEEE8021X_NO_WPA
condition|)
block|{
if|if
condition|(
name|wpa_s
operator|->
name|key_mgmt
operator|==
name|WPA_KEY_MGMT_NONE
condition|)
name|use_crypt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wpa_set_wep_keys
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
condition|)
block|{
name|use_crypt
operator|=
literal|1
expr_stmt|;
name|wep_keys_set
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wpa_s
operator|->
name|key_mgmt
operator|==
name|WPA_KEY_MGMT_WPS
condition|)
name|use_crypt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE8021X_EAPOL
if|if
condition|(
name|wpa_s
operator|->
name|key_mgmt
operator|==
name|WPA_KEY_MGMT_IEEE8021X_NO_WPA
condition|)
block|{
if|if
condition|(
operator|(
name|ssid
operator|->
name|eapol_flags
operator|&
operator|(
name|EAPOL_FLAG_REQUIRE_KEY_UNICAST
operator||
name|EAPOL_FLAG_REQUIRE_KEY_BROADCAST
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|!
name|wep_keys_set
condition|)
block|{
name|use_crypt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Assume that dynamic WEP-104 keys will be used and 			 * set cipher suites in order for drivers to expect 			 * encryption. */
name|cipher_pairwise
operator|=
name|cipher_group
operator|=
name|CIPHER_WEP104
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* IEEE8021X_EAPOL */
if|if
condition|(
name|wpa_s
operator|->
name|key_mgmt
operator|==
name|WPA_KEY_MGMT_WPA_NONE
condition|)
block|{
comment|/* Set the key before (and later after) association */
name|wpa_supplicant_set_wpa_none_key
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
block|}
name|wpa_drv_set_drop_unencrypted
argument_list|(
name|wpa_s
argument_list|,
name|use_crypt
argument_list|)
expr_stmt|;
name|wpa_supplicant_set_state
argument_list|(
name|wpa_s
argument_list|,
name|WPA_ASSOCIATING
argument_list|)
expr_stmt|;
name|os_memset
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bss
condition|)
block|{
specifier|const
name|u8
modifier|*
name|ie
init|=
name|wpa_scan_get_ie
argument_list|(
name|bss
argument_list|,
name|WLAN_EID_SSID
argument_list|)
decl_stmt|;
name|params
operator|.
name|bssid
operator|=
name|bss
operator|->
name|bssid
expr_stmt|;
name|params
operator|.
name|ssid
operator|=
name|ie
condition|?
name|ie
operator|+
literal|2
else|:
operator|(
name|u8
operator|*
operator|)
literal|""
expr_stmt|;
name|params
operator|.
name|ssid_len
operator|=
name|ie
condition|?
name|ie
index|[
literal|1
index|]
else|:
literal|0
expr_stmt|;
name|params
operator|.
name|freq
operator|=
name|bss
operator|->
name|freq
expr_stmt|;
block|}
else|else
block|{
name|params
operator|.
name|ssid
operator|=
name|ssid
operator|->
name|ssid
expr_stmt|;
name|params
operator|.
name|ssid_len
operator|=
name|ssid
operator|->
name|ssid_len
expr_stmt|;
block|}
if|if
condition|(
name|ssid
operator|->
name|mode
operator|==
literal|1
operator|&&
name|ssid
operator|->
name|frequency
operator|>
literal|0
operator|&&
name|params
operator|.
name|freq
operator|==
literal|0
condition|)
name|params
operator|.
name|freq
operator|=
name|ssid
operator|->
name|frequency
expr_stmt|;
comment|/* Initial channel for IBSS */
name|params
operator|.
name|wpa_ie
operator|=
name|wpa_ie
expr_stmt|;
name|params
operator|.
name|wpa_ie_len
operator|=
name|wpa_ie_len
expr_stmt|;
name|params
operator|.
name|pairwise_suite
operator|=
name|cipher_pairwise
expr_stmt|;
name|params
operator|.
name|group_suite
operator|=
name|cipher_group
expr_stmt|;
name|params
operator|.
name|key_mgmt_suite
operator|=
name|key_mgmt2driver
argument_list|(
name|wpa_s
operator|->
name|key_mgmt
argument_list|)
expr_stmt|;
name|params
operator|.
name|auth_alg
operator|=
name|algs
expr_stmt|;
name|params
operator|.
name|mode
operator|=
name|ssid
operator|->
name|mode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WEP_KEYS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ssid
operator|->
name|wep_key_len
index|[
name|i
index|]
condition|)
name|params
operator|.
name|wep_key
index|[
name|i
index|]
operator|=
name|ssid
operator|->
name|wep_key
index|[
name|i
index|]
expr_stmt|;
name|params
operator|.
name|wep_key_len
index|[
name|i
index|]
operator|=
name|ssid
operator|->
name|wep_key_len
index|[
name|i
index|]
expr_stmt|;
block|}
name|params
operator|.
name|wep_tx_keyidx
operator|=
name|ssid
operator|->
name|wep_tx_keyidx
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|driver_4way_handshake
operator|&&
operator|(
name|params
operator|.
name|key_mgmt_suite
operator|==
name|KEY_MGMT_PSK
operator|||
name|params
operator|.
name|key_mgmt_suite
operator|==
name|KEY_MGMT_FT_PSK
operator|)
condition|)
block|{
name|params
operator|.
name|passphrase
operator|=
name|ssid
operator|->
name|passphrase
expr_stmt|;
if|if
condition|(
name|ssid
operator|->
name|psk_set
condition|)
name|params
operator|.
name|psk
operator|=
name|ssid
operator|->
name|psk
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_IEEE80211W
switch|switch
condition|(
name|ssid
operator|->
name|ieee80211w
condition|)
block|{
case|case
name|NO_IEEE80211W
case|:
name|params
operator|.
name|mgmt_frame_protection
operator|=
name|NO_MGMT_FRAME_PROTECTION
expr_stmt|;
break|break;
case|case
name|IEEE80211W_OPTIONAL
case|:
name|params
operator|.
name|mgmt_frame_protection
operator|=
name|MGMT_FRAME_PROTECTION_OPTIONAL
expr_stmt|;
break|break;
case|case
name|IEEE80211W_REQUIRED
case|:
name|params
operator|.
name|mgmt_frame_protection
operator|=
name|MGMT_FRAME_PROTECTION_REQUIRED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ssid
operator|->
name|ieee80211w
operator|!=
name|NO_IEEE80211W
operator|&&
name|bss
condition|)
block|{
specifier|const
name|u8
modifier|*
name|rsn
init|=
name|wpa_scan_get_ie
argument_list|(
name|bss
argument_list|,
name|WLAN_EID_RSN
argument_list|)
decl_stmt|;
name|struct
name|wpa_ie_data
name|ie
decl_stmt|;
if|if
condition|(
name|rsn
operator|&&
name|wpa_parse_wpa_ie
argument_list|(
name|rsn
argument_list|,
literal|2
operator|+
name|rsn
index|[
literal|1
index|]
argument_list|,
operator|&
name|ie
argument_list|)
operator|==
literal|0
operator|&&
name|ie
operator|.
name|capabilities
operator|&
operator|(
name|WPA_CAPABILITY_MFPC
operator||
name|WPA_CAPABILITY_MFPR
operator|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPA: Selected AP supports MFP: "
literal|"require MFP"
argument_list|)
expr_stmt|;
name|params
operator|.
name|mgmt_frame_protection
operator|=
name|MGMT_FRAME_PROTECTION_REQUIRED
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* CONFIG_IEEE80211W */
if|if
condition|(
name|wpa_s
operator|->
name|use_client_mlme
condition|)
name|ret
operator|=
name|ieee80211_sta_associate
argument_list|(
name|wpa_s
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|wpa_drv_associate
argument_list|(
name|wpa_s
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|wpa_msg
argument_list|(
name|wpa_s
argument_list|,
name|MSG_INFO
argument_list|,
literal|"Association request to the driver "
literal|"failed"
argument_list|)
expr_stmt|;
comment|/* try to continue anyway; new association will be tried again 		 * after timeout */
name|assoc_failed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|key_mgmt
operator|==
name|WPA_KEY_MGMT_WPA_NONE
condition|)
block|{
comment|/* Set the key after the association just in case association 		 * cleared the previously configured key. */
name|wpa_supplicant_set_wpa_none_key
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
comment|/* No need to timeout authentication since there is no key 		 * management. */
name|wpa_supplicant_cancel_auth_timeout
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpa_supplicant_set_state
argument_list|(
name|wpa_s
argument_list|,
name|WPA_COMPLETED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Timeout for IEEE 802.11 authentication and association */
name|int
name|timeout
init|=
literal|60
decl_stmt|;
if|if
condition|(
name|assoc_failed
condition|)
block|{
comment|/* give IBSS a bit more time */
name|timeout
operator|=
name|ssid
operator|->
name|mode
condition|?
literal|10
else|:
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|ap_scan
operator|==
literal|1
condition|)
block|{
comment|/* give IBSS a bit more time */
name|timeout
operator|=
name|ssid
operator|->
name|mode
condition|?
literal|20
else|:
literal|10
expr_stmt|;
block|}
name|wpa_supplicant_req_auth_timeout
argument_list|(
name|wpa_s
argument_list|,
name|timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wep_keys_set
operator|&&
name|wpa_drv_get_capa
argument_list|(
name|wpa_s
argument_list|,
operator|&
name|capa
argument_list|)
operator|==
literal|0
operator|&&
name|capa
operator|.
name|flags
operator|&
name|WPA_DRIVER_FLAGS_SET_KEYS_AFTER_ASSOC
condition|)
block|{
comment|/* Set static WEP keys again */
name|wpa_set_wep_keys
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|current_ssid
operator|&&
name|wpa_s
operator|->
name|current_ssid
operator|!=
name|ssid
condition|)
block|{
comment|/* 		 * Do not allow EAP session resumption between different 		 * network configurations. 		 */
name|eapol_sm_invalidate_cached_session
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|)
expr_stmt|;
block|}
name|wpa_s
operator|->
name|current_ssid
operator|=
name|ssid
expr_stmt|;
name|wpa_supplicant_rsn_supp_set_config
argument_list|(
name|wpa_s
argument_list|,
name|wpa_s
operator|->
name|current_ssid
argument_list|)
expr_stmt|;
name|wpa_supplicant_initiate_eapol
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_disassociate - Disassociate the current connection  * @wpa_s: Pointer to wpa_supplicant data  * @reason_code: IEEE 802.11 reason code for the disassociate frame  *  * This function is used to request %wpa_supplicant to disassociate with the  * current AP.  */
end_comment

begin_function
name|void
name|wpa_supplicant_disassociate
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|int
name|reason_code
parameter_list|)
block|{
name|u8
modifier|*
name|addr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|is_zero_ether_addr
argument_list|(
name|wpa_s
operator|->
name|bssid
argument_list|)
condition|)
block|{
if|if
condition|(
name|wpa_s
operator|->
name|use_client_mlme
condition|)
name|ieee80211_sta_disassociate
argument_list|(
name|wpa_s
argument_list|,
name|reason_code
argument_list|)
expr_stmt|;
else|else
name|wpa_drv_disassociate
argument_list|(
name|wpa_s
argument_list|,
name|wpa_s
operator|->
name|bssid
argument_list|,
name|reason_code
argument_list|)
expr_stmt|;
name|addr
operator|=
name|wpa_s
operator|->
name|bssid
expr_stmt|;
block|}
name|wpa_clear_keys
argument_list|(
name|wpa_s
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|wpa_supplicant_mark_disassoc
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|current_ssid
operator|=
name|NULL
expr_stmt|;
name|wpa_sm_set_config
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eapol_sm_notify_config
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_deauthenticate - Deauthenticate the current connection  * @wpa_s: Pointer to wpa_supplicant data  * @reason_code: IEEE 802.11 reason code for the deauthenticate frame  *  * This function is used to request %wpa_supplicant to deauthenticate from the  * current AP.  */
end_comment

begin_function
name|void
name|wpa_supplicant_deauthenticate
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|int
name|reason_code
parameter_list|)
block|{
name|u8
modifier|*
name|addr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|is_zero_ether_addr
argument_list|(
name|wpa_s
operator|->
name|bssid
argument_list|)
condition|)
block|{
if|if
condition|(
name|wpa_s
operator|->
name|use_client_mlme
condition|)
name|ieee80211_sta_deauthenticate
argument_list|(
name|wpa_s
argument_list|,
name|reason_code
argument_list|)
expr_stmt|;
else|else
name|wpa_drv_deauthenticate
argument_list|(
name|wpa_s
argument_list|,
name|wpa_s
operator|->
name|bssid
argument_list|,
name|reason_code
argument_list|)
expr_stmt|;
name|addr
operator|=
name|wpa_s
operator|->
name|bssid
expr_stmt|;
block|}
name|wpa_clear_keys
argument_list|(
name|wpa_s
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|wpa_supplicant_mark_disassoc
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|current_ssid
operator|=
name|NULL
expr_stmt|;
name|wpa_sm_set_config
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eapol_sm_notify_config
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpa_supplicant_get_scan_results_old
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
define|#
directive|define
name|SCAN_AP_LIMIT
value|128
name|struct
name|wpa_scan_result
modifier|*
name|results
decl_stmt|;
name|int
name|num
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|wpa_scan_results
modifier|*
name|res
decl_stmt|;
name|results
operator|=
name|os_malloc
argument_list|(
name|SCAN_AP_LIMIT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|wpa_scan_result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Failed to allocate memory for scan "
literal|"results"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|num
operator|=
name|wpa_drv_get_scan_results
argument_list|(
name|wpa_s
argument_list|,
name|results
argument_list|,
name|SCAN_AP_LIMIT
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Scan results: %d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Failed to get scan results"
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|results
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|num
operator|>
name|SCAN_AP_LIMIT
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"Not enough room for all APs (%d< %d)"
argument_list|,
name|num
argument_list|,
name|SCAN_AP_LIMIT
argument_list|)
expr_stmt|;
name|num
operator|=
name|SCAN_AP_LIMIT
expr_stmt|;
block|}
name|wpa_scan_results_free
argument_list|(
name|wpa_s
operator|->
name|scan_res
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|scan_res
operator|=
name|NULL
expr_stmt|;
comment|/* Convert old scan result data structure to the new one */
name|res
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|os_free
argument_list|(
name|results
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|res
operator|->
name|res
operator|=
name|os_zalloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|wpa_scan_res
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|os_free
argument_list|(
name|results
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|wpa_scan_result
modifier|*
name|bss
init|=
operator|&
name|results
index|[
name|i
index|]
decl_stmt|;
name|struct
name|wpa_scan_res
modifier|*
name|r
decl_stmt|;
name|size_t
name|ie_len
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
name|ie_len
operator|=
literal|2
operator|+
name|bss
operator|->
name|ssid_len
operator|+
name|bss
operator|->
name|rsn_ie_len
operator|+
name|bss
operator|->
name|wpa_ie_len
expr_stmt|;
if|if
condition|(
name|bss
operator|->
name|maxrate
condition|)
name|ie_len
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|bss
operator|->
name|mdie_present
condition|)
name|ie_len
operator|+=
literal|5
expr_stmt|;
name|r
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
operator|+
name|ie_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
break|break;
name|os_memcpy
argument_list|(
name|r
operator|->
name|bssid
argument_list|,
name|bss
operator|->
name|bssid
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|r
operator|->
name|freq
operator|=
name|bss
operator|->
name|freq
expr_stmt|;
name|r
operator|->
name|caps
operator|=
name|bss
operator|->
name|caps
expr_stmt|;
name|r
operator|->
name|qual
operator|=
name|bss
operator|->
name|qual
expr_stmt|;
name|r
operator|->
name|noise
operator|=
name|bss
operator|->
name|noise
expr_stmt|;
name|r
operator|->
name|level
operator|=
name|bss
operator|->
name|level
expr_stmt|;
name|r
operator|->
name|tsf
operator|=
name|bss
operator|->
name|tsf
expr_stmt|;
name|r
operator|->
name|ie_len
operator|=
name|ie_len
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|r
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* SSID IE */
operator|*
name|pos
operator|++
operator|=
name|WLAN_EID_SSID
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|bss
operator|->
name|ssid_len
expr_stmt|;
name|os_memcpy
argument_list|(
name|pos
argument_list|,
name|bss
operator|->
name|ssid
argument_list|,
name|bss
operator|->
name|ssid_len
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|bss
operator|->
name|ssid_len
expr_stmt|;
if|if
condition|(
name|bss
operator|->
name|maxrate
condition|)
block|{
comment|/* Fake Supported Rate IE to include max rate */
operator|*
name|pos
operator|++
operator|=
name|WLAN_EID_SUPP_RATES
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|bss
operator|->
name|maxrate
expr_stmt|;
block|}
if|if
condition|(
name|bss
operator|->
name|rsn_ie_len
condition|)
block|{
name|os_memcpy
argument_list|(
name|pos
argument_list|,
name|bss
operator|->
name|rsn_ie
argument_list|,
name|bss
operator|->
name|rsn_ie_len
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|bss
operator|->
name|rsn_ie_len
expr_stmt|;
block|}
if|if
condition|(
name|bss
operator|->
name|mdie_present
condition|)
block|{
name|os_memcpy
argument_list|(
name|pos
argument_list|,
name|bss
operator|->
name|mdie
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|5
expr_stmt|;
block|}
if|if
condition|(
name|bss
operator|->
name|wpa_ie_len
condition|)
block|{
name|os_memcpy
argument_list|(
name|pos
argument_list|,
name|bss
operator|->
name|wpa_ie
argument_list|,
name|bss
operator|->
name|wpa_ie_len
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|bss
operator|->
name|wpa_ie_len
expr_stmt|;
block|}
name|res
operator|->
name|res
index|[
name|res
operator|->
name|num
operator|++
index|]
operator|=
name|r
expr_stmt|;
block|}
name|os_free
argument_list|(
name|results
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|scan_res
operator|=
name|res
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_get_scan_results - Get scan results  * @wpa_s: Pointer to wpa_supplicant data  * Returns: 0 on success, -1 on failure  *  * This function is request the current scan results from the driver and stores  * a local copy of the results in wpa_s->scan_res.  */
end_comment

begin_function
name|int
name|wpa_supplicant_get_scan_results
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|use_client_mlme
condition|)
block|{
name|wpa_scan_results_free
argument_list|(
name|wpa_s
operator|->
name|scan_res
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|scan_res
operator|=
name|ieee80211_sta_get_scan_results
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|scan_res
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Failed to get scan results"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|ret
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wpa_s
operator|->
name|driver
operator|->
name|get_scan_results2
operator|==
name|NULL
condition|)
name|ret
operator|=
name|wpa_supplicant_get_scan_results_old
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
else|else
block|{
name|wpa_scan_results_free
argument_list|(
name|wpa_s
operator|->
name|scan_res
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|scan_res
operator|=
name|wpa_drv_get_scan_results2
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|scan_res
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Failed to get scan results"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|scan_res
condition|)
name|wpa_scan_sort_results
argument_list|(
name|wpa_s
operator|->
name|scan_res
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_get_ssid - Get a pointer to the current network structure  * @wpa_s: Pointer to wpa_supplicant data  * Returns: A pointer to the current network structure or %NULL on failure  */
end_comment

begin_function
name|struct
name|wpa_ssid
modifier|*
name|wpa_supplicant_get_ssid
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|wpa_ssid
modifier|*
name|entry
decl_stmt|;
name|u8
name|ssid
index|[
name|MAX_SSID_LEN
index|]
decl_stmt|;
name|int
name|res
decl_stmt|;
name|size_t
name|ssid_len
decl_stmt|;
name|u8
name|bssid
index|[
name|ETH_ALEN
index|]
decl_stmt|;
name|int
name|wired
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|use_client_mlme
condition|)
block|{
if|if
condition|(
name|ieee80211_sta_get_ssid
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|,
operator|&
name|ssid_len
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Could not read SSID from "
literal|"MLME."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|res
operator|=
name|wpa_drv_get_ssid
argument_list|(
name|wpa_s
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Could not read SSID from "
literal|"driver."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ssid_len
operator|=
name|res
expr_stmt|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|use_client_mlme
condition|)
name|os_memcpy
argument_list|(
name|bssid
argument_list|,
name|wpa_s
operator|->
name|bssid
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wpa_drv_get_bssid
argument_list|(
name|wpa_s
argument_list|,
name|bssid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Could not read BSSID from driver."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|wired
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|ap_scan
operator|==
literal|0
operator|&&
name|wpa_s
operator|->
name|driver
operator|&&
name|IS_WIRED
argument_list|(
name|wpa_s
operator|->
name|driver
argument_list|)
expr_stmt|;
name|entry
operator|=
name|wpa_s
operator|->
name|conf
operator|->
name|ssid
expr_stmt|;
while|while
condition|(
name|entry
condition|)
block|{
if|if
condition|(
operator|!
name|entry
operator|->
name|disabled
operator|&&
operator|(
operator|(
name|ssid_len
operator|==
name|entry
operator|->
name|ssid_len
operator|&&
name|os_memcmp
argument_list|(
name|ssid
argument_list|,
name|entry
operator|->
name|ssid
argument_list|,
name|ssid_len
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|wired
operator|)
operator|&&
operator|(
operator|!
name|entry
operator|->
name|bssid_set
operator|||
name|os_memcmp
argument_list|(
name|bssid
argument_list|,
name|entry
operator|->
name|bssid
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|entry
return|;
ifdef|#
directive|ifdef
name|CONFIG_WPS
if|if
condition|(
operator|!
name|entry
operator|->
name|disabled
operator|&&
operator|(
name|entry
operator|->
name|key_mgmt
operator|&
name|WPA_KEY_MGMT_WPS
operator|)
operator|&&
operator|(
name|entry
operator|->
name|ssid
operator|==
name|NULL
operator|||
name|entry
operator|->
name|ssid_len
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|entry
operator|->
name|bssid_set
operator|||
name|os_memcmp
argument_list|(
name|bssid
argument_list|,
name|entry
operator|->
name|bssid
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|entry
return|;
endif|#
directive|endif
comment|/* CONFIG_WPS */
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpa_supplicant_set_driver
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|wpa_supplicant_drivers
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"No driver interfaces build into "
literal|"wpa_supplicant."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* default to first driver in the list */
name|wpa_s
operator|->
name|driver
operator|=
name|wpa_supplicant_drivers
index|[
literal|0
index|]
expr_stmt|;
name|wpa_s
operator|->
name|global_drv_priv
operator|=
name|wpa_s
operator|->
name|global
operator|->
name|drv_priv
index|[
literal|0
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|wpa_supplicant_drivers
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|os_strcmp
argument_list|(
name|name
argument_list|,
name|wpa_supplicant_drivers
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wpa_s
operator|->
name|driver
operator|=
name|wpa_supplicant_drivers
index|[
name|i
index|]
expr_stmt|;
name|wpa_s
operator|->
name|global_drv_priv
operator|=
name|wpa_s
operator|->
name|global
operator|->
name|drv_priv
index|[
name|i
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Unsupported driver '%s'.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|wpa_supplicant_rx_eapol
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u8
modifier|*
name|src_addr
parameter_list|,
specifier|const
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
init|=
name|ctx
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RX EAPOL from "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|src_addr
argument_list|)
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"RX EAPOL"
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|wpa_state
operator|<
name|WPA_ASSOCIATED
condition|)
block|{
comment|/* 		 * There is possible race condition between receiving the 		 * association event and the EAPOL frame since they are coming 		 * through different paths from the driver. In order to avoid 		 * issues in trying to process the EAPOL frame before receiving 		 * association information, lets queue it for processing until 		 * the association event is received. 		 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Not associated - Delay processing of "
literal|"received EAPOL frame"
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|wpa_s
operator|->
name|pending_eapol_rx
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|pending_eapol_rx
operator|=
name|wpabuf_alloc_copy
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|pending_eapol_rx
condition|)
block|{
name|os_get_time
argument_list|(
operator|&
name|wpa_s
operator|->
name|pending_eapol_rx_time
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|wpa_s
operator|->
name|pending_eapol_rx_src
argument_list|,
name|src_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|key_mgmt
operator|==
name|WPA_KEY_MGMT_NONE
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Ignored received EAPOL frame since "
literal|"no key management is configured"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|eapol_received
operator|==
literal|0
operator|&&
operator|(
operator|!
name|wpa_s
operator|->
name|driver_4way_handshake
operator|||
operator|!
name|wpa_key_mgmt_wpa_psk
argument_list|(
name|wpa_s
operator|->
name|key_mgmt
argument_list|)
operator|||
name|wpa_s
operator|->
name|wpa_state
operator|!=
name|WPA_COMPLETED
operator|)
condition|)
block|{
comment|/* Timeout for completing IEEE 802.1X and WPA authentication */
name|wpa_supplicant_req_auth_timeout
argument_list|(
name|wpa_s
argument_list|,
operator|(
name|wpa_key_mgmt_wpa_ieee8021x
argument_list|(
name|wpa_s
operator|->
name|key_mgmt
argument_list|)
operator|||
name|wpa_s
operator|->
name|key_mgmt
operator|==
name|WPA_KEY_MGMT_IEEE8021X_NO_WPA
operator|||
name|wpa_s
operator|->
name|key_mgmt
operator|==
name|WPA_KEY_MGMT_WPS
operator|)
condition|?
literal|70
else|:
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|wpa_s
operator|->
name|eapol_received
operator|++
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|countermeasures
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPA: Countermeasures - dropped EAPOL "
literal|"packet"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Source address of the incoming EAPOL frame could be compared to the 	 * current BSSID. However, it is possible that a centralized 	 * Authenticator could be using another MAC address than the BSSID of 	 * an AP, so just allow any address to be used for now. The replies are 	 * still sent to the current BSSID (if available), though. */
name|os_memcpy
argument_list|(
name|wpa_s
operator|->
name|last_eapol_src
argument_list|,
name|src_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wpa_key_mgmt_wpa_psk
argument_list|(
name|wpa_s
operator|->
name|key_mgmt
argument_list|)
operator|&&
name|eapol_sm_rx_eapol
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
name|src_addr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|>
literal|0
condition|)
return|return;
name|wpa_drv_poll
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wpa_s
operator|->
name|driver_4way_handshake
condition|)
name|wpa_sm_rx_eapol
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|src_addr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wpa_key_mgmt_wpa_ieee8021x
argument_list|(
name|wpa_s
operator|->
name|key_mgmt
argument_list|)
condition|)
block|{
comment|/* 		 * Set portValid = TRUE here since we are going to skip 4-way 		 * handshake processing which would normally set portValid. We 		 * need this to allow the EAPOL state machines to be completed 		 * without going through EAPOL-Key handshake. 		 */
name|eapol_sm_notify_portValid
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|wpa_supplicant_sta_free_hw_features
parameter_list|(
name|struct
name|wpa_hw_modes
modifier|*
name|hw_features
parameter_list|,
name|size_t
name|num_hw_features
parameter_list|)
block|{
name|ieee80211_sta_free_hw_features
argument_list|(
name|hw_features
argument_list|,
name|num_hw_features
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wpa_supplicant_sta_rx
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|ieee80211_rx_status
modifier|*
name|rx_status
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
init|=
name|ctx
decl_stmt|;
name|ieee80211_sta_rx
argument_list|(
name|wpa_s
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|rx_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_driver_init - Initialize driver interface parameters  * @wpa_s: Pointer to wpa_supplicant data  * Returns: 0 on success, -1 on failure  *  * This function is called to initialize driver interface parameters.  * wpa_drv_init() must have been called before this function to initialize the  * driver interface.  */
end_comment

begin_function
name|int
name|wpa_supplicant_driver_init
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
specifier|static
name|int
name|interface_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|driver
operator|->
name|send_eapol
condition|)
block|{
specifier|const
name|u8
modifier|*
name|addr
init|=
name|wpa_drv_get_mac_addr
argument_list|(
name|wpa_s
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
condition|)
name|os_memcpy
argument_list|(
name|wpa_s
operator|->
name|own_addr
argument_list|,
name|addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_s
operator|->
name|l2
operator|=
name|l2_packet_init
argument_list|(
name|wpa_s
operator|->
name|ifname
argument_list|,
name|wpa_drv_get_mac_addr
argument_list|(
name|wpa_s
argument_list|)
argument_list|,
name|ETH_P_EAPOL
argument_list|,
name|wpa_supplicant_rx_eapol
argument_list|,
name|wpa_s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|l2
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|l2
operator|&&
name|l2_packet_get_own_addr
argument_list|(
name|wpa_s
operator|->
name|l2
argument_list|,
name|wpa_s
operator|->
name|own_addr
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Failed to get own L2 address"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Own MAC address: "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|wpa_s
operator|->
name|own_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|bridge_ifname
index|[
literal|0
index|]
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Receiving packets from bridge interface"
literal|" '%s'"
argument_list|,
name|wpa_s
operator|->
name|bridge_ifname
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|l2_br
operator|=
name|l2_packet_init
argument_list|(
name|wpa_s
operator|->
name|bridge_ifname
argument_list|,
name|wpa_s
operator|->
name|own_addr
argument_list|,
name|ETH_P_EAPOL
argument_list|,
name|wpa_supplicant_rx_eapol
argument_list|,
name|wpa_s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|l2_br
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Failed to open l2_packet "
literal|"connection for the bridge interface '%s'"
argument_list|,
name|wpa_s
operator|->
name|bridge_ifname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Backwards compatibility call to set_wpa() handler. This is called 	 * only just after init and just before deinit, so these handler can be 	 * used to implement same functionality. */
if|if
condition|(
name|wpa_drv_set_wpa
argument_list|(
name|wpa_s
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|struct
name|wpa_driver_capa
name|capa
decl_stmt|;
if|if
condition|(
name|wpa_drv_get_capa
argument_list|(
name|wpa_s
argument_list|,
operator|&
name|capa
argument_list|)
operator|<
literal|0
operator|||
operator|!
operator|(
name|capa
operator|.
name|flags
operator|&
operator|(
name|WPA_DRIVER_CAPA_KEY_MGMT_WPA
operator||
name|WPA_DRIVER_CAPA_KEY_MGMT_WPA2
operator|)
operator|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Driver does not support WPA."
argument_list|)
expr_stmt|;
comment|/* Continue to allow non-WPA modes to be used. */
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Failed to enable WPA in the "
literal|"driver."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|wpa_clear_keys
argument_list|(
name|wpa_s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make sure that TKIP countermeasures are not left enabled (could 	 * happen if wpa_supplicant is killed during countermeasures. */
name|wpa_drv_set_countermeasures
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpa_drv_set_drop_unencrypted
argument_list|(
name|wpa_s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"RSN: flushing PMKID list in the driver"
argument_list|)
expr_stmt|;
name|wpa_drv_flush_pmkid
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|prev_scan_ssid
operator|=
name|BROADCAST_SSID_SCAN
expr_stmt|;
name|wpa_supplicant_req_scan
argument_list|(
name|wpa_s
argument_list|,
name|interface_count
argument_list|,
literal|100000
argument_list|)
expr_stmt|;
name|interface_count
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpa_supplicant_daemon
parameter_list|(
specifier|const
name|char
modifier|*
name|pid_file
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Daemonize.."
argument_list|)
expr_stmt|;
return|return
name|os_daemonize
argument_list|(
name|pid_file
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpa_supplicant
modifier|*
name|wpa_supplicant_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
decl_stmt|;
name|wpa_s
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|wpa_s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|wpa_s
operator|->
name|scan_req
operator|=
literal|1
expr_stmt|;
return|return
name|wpa_s
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpa_supplicant_init_iface
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|,
name|struct
name|wpa_interface
modifier|*
name|iface
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Initializing interface '%s' conf '%s' driver "
literal|"'%s' ctrl_interface '%s' bridge '%s'"
argument_list|,
name|iface
operator|->
name|ifname
argument_list|,
name|iface
operator|->
name|confname
condition|?
name|iface
operator|->
name|confname
else|:
literal|"N/A"
argument_list|,
name|iface
operator|->
name|driver
condition|?
name|iface
operator|->
name|driver
else|:
literal|"default"
argument_list|,
name|iface
operator|->
name|ctrl_interface
condition|?
name|iface
operator|->
name|ctrl_interface
else|:
literal|"N/A"
argument_list|,
name|iface
operator|->
name|bridge_ifname
condition|?
name|iface
operator|->
name|bridge_ifname
else|:
literal|"N/A"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_supplicant_set_driver
argument_list|(
name|wpa_s
argument_list|,
name|iface
operator|->
name|driver
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|iface
operator|->
name|confname
condition|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_BACKEND_FILE
name|wpa_s
operator|->
name|confname
operator|=
name|os_rel2abs_path
argument_list|(
name|iface
operator|->
name|confname
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|confname
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Failed to get absolute path "
literal|"for configuration file '%s'."
argument_list|,
name|iface
operator|->
name|confname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Configuration file '%s' -> '%s'"
argument_list|,
name|iface
operator|->
name|confname
argument_list|,
name|wpa_s
operator|->
name|confname
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* CONFIG_BACKEND_FILE */
name|wpa_s
operator|->
name|confname
operator|=
name|os_strdup
argument_list|(
name|iface
operator|->
name|confname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_BACKEND_FILE */
name|wpa_s
operator|->
name|conf
operator|=
name|wpa_config_read
argument_list|(
name|wpa_s
operator|->
name|confname
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Failed to read or parse "
literal|"configuration '%s'."
argument_list|,
name|wpa_s
operator|->
name|confname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 		 * Override ctrl_interface and driver_param if set on command 		 * line. 		 */
if|if
condition|(
name|iface
operator|->
name|ctrl_interface
condition|)
block|{
name|os_free
argument_list|(
name|wpa_s
operator|->
name|conf
operator|->
name|ctrl_interface
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|conf
operator|->
name|ctrl_interface
operator|=
name|os_strdup
argument_list|(
name|iface
operator|->
name|ctrl_interface
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iface
operator|->
name|driver_param
condition|)
block|{
name|os_free
argument_list|(
name|wpa_s
operator|->
name|conf
operator|->
name|driver_param
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|conf
operator|->
name|driver_param
operator|=
name|os_strdup
argument_list|(
name|iface
operator|->
name|driver_param
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|wpa_s
operator|->
name|conf
operator|=
name|wpa_config_alloc_empty
argument_list|(
name|iface
operator|->
name|ctrl_interface
argument_list|,
name|iface
operator|->
name|driver_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"\nNo configuration found."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|iface
operator|->
name|ifname
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"\nInterface name is required."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|os_strlen
argument_list|(
name|iface
operator|->
name|ifname
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|wpa_s
operator|->
name|ifname
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"\nToo long interface name '%s'."
argument_list|,
name|iface
operator|->
name|ifname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|os_strlcpy
argument_list|(
name|wpa_s
operator|->
name|ifname
argument_list|,
name|iface
operator|->
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|wpa_s
operator|->
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|->
name|bridge_ifname
condition|)
block|{
if|if
condition|(
name|os_strlen
argument_list|(
name|iface
operator|->
name|bridge_ifname
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|wpa_s
operator|->
name|bridge_ifname
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"\nToo long bridge interface "
literal|"name '%s'."
argument_list|,
name|iface
operator|->
name|bridge_ifname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|os_strlcpy
argument_list|(
name|wpa_s
operator|->
name|bridge_ifname
argument_list|,
name|iface
operator|->
name|bridge_ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|wpa_s
operator|->
name|bridge_ifname
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpa_supplicant_init_iface2
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ifname
decl_stmt|;
name|struct
name|wpa_driver_capa
name|capa
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Initializing interface (2) '%s'"
argument_list|,
name|wpa_s
operator|->
name|ifname
argument_list|)
expr_stmt|;
comment|/* RSNA Supplicant Key Management - INITIALIZE */
name|eapol_sm_notify_portEnabled
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_sm_notify_portValid
argument_list|(
name|wpa_s
operator|->
name|eapol
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Initialize driver interface and register driver event handler before 	 * L2 receive handler so that association events are processed before 	 * EAPOL-Key packets if both become available for the same select() 	 * call. */
name|wpa_s
operator|->
name|drv_priv
operator|=
name|wpa_drv_init
argument_list|(
name|wpa_s
argument_list|,
name|wpa_s
operator|->
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|drv_priv
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Failed to initialize driver interface"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|wpa_drv_set_param
argument_list|(
name|wpa_s
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|driver_param
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Driver interface rejected "
literal|"driver_param '%s'"
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|driver_param
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ifname
operator|=
name|wpa_drv_get_ifname
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifname
operator|&&
name|os_strcmp
argument_list|(
name|ifname
argument_list|,
name|wpa_s
operator|->
name|ifname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Driver interface replaced interface "
literal|"name with '%s'"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|os_strlcpy
argument_list|(
name|wpa_s
operator|->
name|ifname
argument_list|,
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|wpa_s
operator|->
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wpa_supplicant_init_wpa
argument_list|(
name|wpa_s
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_sm_set_ifname
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|wpa_s
operator|->
name|ifname
argument_list|,
name|wpa_s
operator|->
name|bridge_ifname
index|[
literal|0
index|]
condition|?
name|wpa_s
operator|->
name|bridge_ifname
else|:
name|NULL
argument_list|)
expr_stmt|;
name|wpa_sm_set_fast_reauth
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|fast_reauth
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|dot11RSNAConfigPMKLifetime
operator|&&
name|wpa_sm_set_param
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|RSNA_PMK_LIFETIME
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|dot11RSNAConfigPMKLifetime
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Invalid WPA parameter value for "
literal|"dot11RSNAConfigPMKLifetime"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|dot11RSNAConfigPMKReauthThreshold
operator|&&
name|wpa_sm_set_param
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|RSNA_PMK_REAUTH_THRESHOLD
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|dot11RSNAConfigPMKReauthThreshold
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Invalid WPA parameter value for "
literal|"dot11RSNAConfigPMKReauthThreshold"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|dot11RSNAConfigSATimeout
operator|&&
name|wpa_sm_set_param
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|RSNA_SA_TIMEOUT
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|dot11RSNAConfigSATimeout
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Invalid WPA parameter value for "
literal|"dot11RSNAConfigSATimeout"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|wpa_supplicant_driver_init
argument_list|(
name|wpa_s
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|wpa_s
operator|->
name|conf
operator|->
name|country
index|[
literal|0
index|]
operator|&&
name|wpa_s
operator|->
name|conf
operator|->
name|country
index|[
literal|1
index|]
operator|&&
name|wpa_drv_set_country
argument_list|(
name|wpa_s
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|country
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Failed to set country"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wpa_sm_set_own_addr
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|wpa_s
operator|->
name|own_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpas_wps_init
argument_list|(
name|wpa_s
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|wpa_supplicant_init_eapol
argument_list|(
name|wpa_s
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|wpa_sm_set_eapol
argument_list|(
name|wpa_s
operator|->
name|wpa
argument_list|,
name|wpa_s
operator|->
name|eapol
argument_list|)
expr_stmt|;
name|wpa_s
operator|->
name|ctrl_iface
operator|=
name|wpa_supplicant_ctrl_iface_init
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|ctrl_iface
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Failed to initialize control interface '%s'.\n"
literal|"You may have another wpa_supplicant process "
literal|"already running or the file was\n"
literal|"left by an unclean termination of wpa_supplicant "
literal|"in which case you will need\n"
literal|"to manually remove this file before starting "
literal|"wpa_supplicant again.\n"
argument_list|,
name|wpa_s
operator|->
name|conf
operator|->
name|ctrl_interface
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|wpa_drv_get_capa
argument_list|(
name|wpa_s
argument_list|,
operator|&
name|capa
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|capa
operator|.
name|flags
operator|&
name|WPA_DRIVER_FLAGS_USER_SPACE_MLME
condition|)
block|{
name|wpa_s
operator|->
name|use_client_mlme
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ieee80211_sta_init
argument_list|(
name|wpa_s
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|capa
operator|.
name|flags
operator|&
name|WPA_DRIVER_FLAGS_4WAY_HANDSHAKE
condition|)
name|wpa_s
operator|->
name|driver_4way_handshake
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpa_supplicant_deinit_iface
parameter_list|(
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
if|if
condition|(
name|wpa_s
operator|->
name|drv_priv
condition|)
block|{
name|wpa_supplicant_deauthenticate
argument_list|(
name|wpa_s
argument_list|,
name|WLAN_REASON_DEAUTH_LEAVING
argument_list|)
expr_stmt|;
comment|/* Backwards compatibility call to set_wpa() handler. This is 		 * called only just after init and just before deinit, so these 		 * handler can be used to implement same functionality. */
if|if
condition|(
name|wpa_drv_set_wpa
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Failed to disable WPA in the "
literal|"driver."
argument_list|)
expr_stmt|;
block|}
name|wpa_drv_set_drop_unencrypted
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpa_drv_set_countermeasures
argument_list|(
name|wpa_s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wpa_clear_keys
argument_list|(
name|wpa_s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|wpas_dbus_unregister_iface
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|wpa_supplicant_cleanup
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|->
name|drv_priv
condition|)
name|wpa_drv_deinit
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_add_iface - Add a new network interface  * @global: Pointer to global data from wpa_supplicant_init()  * @iface: Interface configuration options  * Returns: Pointer to the created interface or %NULL on failure  *  * This function is used to add new network interfaces for %wpa_supplicant.  * This can be called before wpa_supplicant_run() to add interfaces before the  * main event loop has been started. In addition, new interfaces can be added  * dynamically while %wpa_supplicant is already running. This could happen,  * e.g., when a hotplug network adapter is inserted.  */
end_comment

begin_function
name|struct
name|wpa_supplicant
modifier|*
name|wpa_supplicant_add_iface
parameter_list|(
name|struct
name|wpa_global
modifier|*
name|global
parameter_list|,
name|struct
name|wpa_interface
modifier|*
name|iface
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
decl_stmt|;
if|if
condition|(
name|global
operator|==
name|NULL
operator|||
name|iface
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|wpa_s
operator|=
name|wpa_supplicant_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|wpa_s
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|wpa_s
operator|->
name|global
operator|=
name|global
expr_stmt|;
if|if
condition|(
name|wpa_supplicant_init_iface
argument_list|(
name|wpa_s
argument_list|,
name|iface
argument_list|)
operator|||
name|wpa_supplicant_init_iface2
argument_list|(
name|wpa_s
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Failed to add interface %s"
argument_list|,
name|iface
operator|->
name|ifname
argument_list|)
expr_stmt|;
name|wpa_supplicant_deinit_iface
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Register the interface with the dbus control interface */
if|if
condition|(
name|wpas_dbus_register_iface
argument_list|(
name|wpa_s
argument_list|)
condition|)
block|{
name|wpa_supplicant_deinit_iface
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|wpa_s
operator|->
name|next
operator|=
name|global
operator|->
name|ifaces
expr_stmt|;
name|global
operator|->
name|ifaces
operator|=
name|wpa_s
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Added interface %s"
argument_list|,
name|wpa_s
operator|->
name|ifname
argument_list|)
expr_stmt|;
return|return
name|wpa_s
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_remove_iface - Remove a network interface  * @global: Pointer to global data from wpa_supplicant_init()  * @wpa_s: Pointer to the network interface to be removed  * Returns: 0 if interface was removed, -1 if interface was not found  *  * This function can be used to dynamically remove network interfaces from  * %wpa_supplicant, e.g., when a hotplug network adapter is ejected. In  * addition, this function is used to remove all remaining interfaces when  * %wpa_supplicant is terminated.  */
end_comment

begin_function
name|int
name|wpa_supplicant_remove_iface
parameter_list|(
name|struct
name|wpa_global
modifier|*
name|global
parameter_list|,
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|prev
decl_stmt|;
comment|/* Remove interface from the global list of interfaces */
name|prev
operator|=
name|global
operator|->
name|ifaces
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|wpa_s
condition|)
block|{
name|global
operator|->
name|ifaces
operator|=
name|wpa_s
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|prev
operator|&&
name|prev
operator|->
name|next
operator|!=
name|wpa_s
condition|)
name|prev
operator|=
name|prev
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|prev
operator|->
name|next
operator|=
name|wpa_s
operator|->
name|next
expr_stmt|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"Removing interface %s"
argument_list|,
name|wpa_s
operator|->
name|ifname
argument_list|)
expr_stmt|;
name|wpa_supplicant_deinit_iface
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|wpa_s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_get_iface - Get a new network interface  * @global: Pointer to global data from wpa_supplicant_init()  * @ifname: Interface name  * Returns: Pointer to the interface or %NULL if not found  */
end_comment

begin_function
name|struct
name|wpa_supplicant
modifier|*
name|wpa_supplicant_get_iface
parameter_list|(
name|struct
name|wpa_global
modifier|*
name|global
parameter_list|,
specifier|const
name|char
modifier|*
name|ifname
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
decl_stmt|;
for|for
control|(
name|wpa_s
operator|=
name|global
operator|->
name|ifaces
init|;
name|wpa_s
condition|;
name|wpa_s
operator|=
name|wpa_s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|os_strcmp
argument_list|(
name|wpa_s
operator|->
name|ifname
argument_list|,
name|ifname
argument_list|)
operator|==
literal|0
condition|)
return|return
name|wpa_s
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_init - Initialize %wpa_supplicant  * @params: Parameters for %wpa_supplicant  * Returns: Pointer to global %wpa_supplicant data, or %NULL on failure  *  * This function is used to initialize %wpa_supplicant. After successful  * initialization, the returned data pointer can be used to add and remove  * network interfaces, and eventually, to deinitialize %wpa_supplicant.  */
end_comment

begin_function
name|struct
name|wpa_global
modifier|*
name|wpa_supplicant_init
parameter_list|(
name|struct
name|wpa_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|wpa_global
modifier|*
name|global
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|wpa_debug_open_file
argument_list|(
name|params
operator|->
name|wpa_debug_file_path
argument_list|)
expr_stmt|;
name|ret
operator|=
name|eap_peer_register_methods
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Failed to register EAP methods"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|2
condition|)
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Two or more EAP methods used "
literal|"the same EAP type."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|global
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|global
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|global
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|global
operator|->
name|params
operator|.
name|daemonize
operator|=
name|params
operator|->
name|daemonize
expr_stmt|;
name|global
operator|->
name|params
operator|.
name|wait_for_monitor
operator|=
name|params
operator|->
name|wait_for_monitor
expr_stmt|;
name|global
operator|->
name|params
operator|.
name|dbus_ctrl_interface
operator|=
name|params
operator|->
name|dbus_ctrl_interface
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|pid_file
condition|)
name|global
operator|->
name|params
operator|.
name|pid_file
operator|=
name|os_strdup
argument_list|(
name|params
operator|->
name|pid_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ctrl_interface
condition|)
name|global
operator|->
name|params
operator|.
name|ctrl_interface
operator|=
name|os_strdup
argument_list|(
name|params
operator|->
name|ctrl_interface
argument_list|)
expr_stmt|;
name|wpa_debug_level
operator|=
name|global
operator|->
name|params
operator|.
name|wpa_debug_level
operator|=
name|params
operator|->
name|wpa_debug_level
expr_stmt|;
name|wpa_debug_show_keys
operator|=
name|global
operator|->
name|params
operator|.
name|wpa_debug_show_keys
operator|=
name|params
operator|->
name|wpa_debug_show_keys
expr_stmt|;
name|wpa_debug_timestamp
operator|=
name|global
operator|->
name|params
operator|.
name|wpa_debug_timestamp
operator|=
name|params
operator|->
name|wpa_debug_timestamp
expr_stmt|;
if|if
condition|(
name|eloop_init
argument_list|(
name|global
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Failed to initialize event loop"
argument_list|)
expr_stmt|;
name|wpa_supplicant_deinit
argument_list|(
name|global
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|global
operator|->
name|ctrl_iface
operator|=
name|wpa_supplicant_global_ctrl_iface_init
argument_list|(
name|global
argument_list|)
expr_stmt|;
if|if
condition|(
name|global
operator|->
name|ctrl_iface
operator|==
name|NULL
condition|)
block|{
name|wpa_supplicant_deinit
argument_list|(
name|global
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|global
operator|->
name|params
operator|.
name|dbus_ctrl_interface
condition|)
block|{
name|global
operator|->
name|dbus_ctrl_iface
operator|=
name|wpa_supplicant_dbus_ctrl_iface_init
argument_list|(
name|global
argument_list|)
expr_stmt|;
if|if
condition|(
name|global
operator|->
name|dbus_ctrl_iface
operator|==
name|NULL
condition|)
block|{
name|wpa_supplicant_deinit
argument_list|(
name|global
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|wpa_supplicant_drivers
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|global
operator|->
name|drv_count
operator|++
expr_stmt|;
if|if
condition|(
name|global
operator|->
name|drv_count
operator|==
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"No drivers enabled"
argument_list|)
expr_stmt|;
name|wpa_supplicant_deinit
argument_list|(
name|global
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|global
operator|->
name|drv_priv
operator|=
name|os_zalloc
argument_list|(
name|global
operator|->
name|drv_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|global
operator|->
name|drv_priv
operator|==
name|NULL
condition|)
block|{
name|wpa_supplicant_deinit
argument_list|(
name|global
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|wpa_supplicant_drivers
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|wpa_supplicant_drivers
index|[
name|i
index|]
operator|->
name|global_init
condition|)
continue|continue;
name|global
operator|->
name|drv_priv
index|[
name|i
index|]
operator|=
name|wpa_supplicant_drivers
index|[
name|i
index|]
operator|->
name|global_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|global
operator|->
name|drv_priv
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"Failed to initialize driver "
literal|"'%s'"
argument_list|,
name|wpa_supplicant_drivers
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|wpa_supplicant_deinit
argument_list|(
name|global
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|global
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_run - Run the %wpa_supplicant main event loop  * @global: Pointer to global data from wpa_supplicant_init()  * Returns: 0 after successful event loop run, -1 on failure  *  * This function starts the main event loop and continues running as long as  * there are any remaining events. In most cases, this function is running as  * long as the %wpa_supplicant process in still in use.  */
end_comment

begin_function
name|int
name|wpa_supplicant_run
parameter_list|(
name|struct
name|wpa_global
modifier|*
name|global
parameter_list|)
block|{
name|struct
name|wpa_supplicant
modifier|*
name|wpa_s
decl_stmt|;
if|if
condition|(
name|global
operator|->
name|params
operator|.
name|daemonize
operator|&&
name|wpa_supplicant_daemon
argument_list|(
name|global
operator|->
name|params
operator|.
name|pid_file
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|global
operator|->
name|params
operator|.
name|wait_for_monitor
condition|)
block|{
for|for
control|(
name|wpa_s
operator|=
name|global
operator|->
name|ifaces
init|;
name|wpa_s
condition|;
name|wpa_s
operator|=
name|wpa_s
operator|->
name|next
control|)
if|if
condition|(
name|wpa_s
operator|->
name|ctrl_iface
condition|)
name|wpa_supplicant_ctrl_iface_wait
argument_list|(
name|wpa_s
operator|->
name|ctrl_iface
argument_list|)
expr_stmt|;
block|}
name|eloop_register_signal_terminate
argument_list|(
name|wpa_supplicant_terminate
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_register_signal_reconfig
argument_list|(
name|wpa_supplicant_reconfig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_run
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * wpa_supplicant_deinit - Deinitialize %wpa_supplicant  * @global: Pointer to global data from wpa_supplicant_init()  *  * This function is called to deinitialize %wpa_supplicant and to free all  * allocated resources. Remaining network interfaces will also be removed.  */
end_comment

begin_function
name|void
name|wpa_supplicant_deinit
parameter_list|(
name|struct
name|wpa_global
modifier|*
name|global
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|global
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|global
operator|->
name|ifaces
condition|)
name|wpa_supplicant_remove_iface
argument_list|(
name|global
argument_list|,
name|global
operator|->
name|ifaces
argument_list|)
expr_stmt|;
if|if
condition|(
name|global
operator|->
name|ctrl_iface
condition|)
name|wpa_supplicant_global_ctrl_iface_deinit
argument_list|(
name|global
operator|->
name|ctrl_iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|global
operator|->
name|dbus_ctrl_iface
condition|)
name|wpa_supplicant_dbus_ctrl_iface_deinit
argument_list|(
name|global
operator|->
name|dbus_ctrl_iface
argument_list|)
expr_stmt|;
name|eap_peer_unregister_methods
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|wpa_supplicant_drivers
index|[
name|i
index|]
operator|&&
name|global
operator|->
name|drv_priv
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|global
operator|->
name|drv_priv
index|[
name|i
index|]
condition|)
continue|continue;
name|wpa_supplicant_drivers
index|[
name|i
index|]
operator|->
name|global_deinit
argument_list|(
name|global
operator|->
name|drv_priv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|os_free
argument_list|(
name|global
operator|->
name|drv_priv
argument_list|)
expr_stmt|;
name|eloop_destroy
argument_list|()
expr_stmt|;
if|if
condition|(
name|global
operator|->
name|params
operator|.
name|pid_file
condition|)
block|{
name|os_daemonize_terminate
argument_list|(
name|global
operator|->
name|params
operator|.
name|pid_file
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|global
operator|->
name|params
operator|.
name|pid_file
argument_list|)
expr_stmt|;
block|}
name|os_free
argument_list|(
name|global
operator|->
name|params
operator|.
name|ctrl_interface
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|global
argument_list|)
expr_stmt|;
name|wpa_debug_close_file
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

