begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2013 Qualcomm Atheros, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AH_SUPPORT_AR9300
end_ifdef

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AH_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|"ah_desc.h"
end_include

begin_comment
comment|/* NB: for HAL_PHYERR* */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ar9300/ar9300.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300reg.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300phy.h"
end_include

begin_define
define|#
directive|define
name|AR_GPIO_BIT
parameter_list|(
name|_gpio
parameter_list|)
value|(1<< (_gpio))
end_define

begin_comment
comment|/*  * Configure GPIO Output Mux control  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UMAC_SUPPORT_SMARTANTENNA
end_ifdef

begin_function
specifier|static
name|void
name|ar9340_soc_gpio_cfg_output_mux
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|gpio
parameter_list|,
name|u_int32_t
name|ah_signal_type
parameter_list|)
block|{
define|#
directive|define
name|ADDR_READ
parameter_list|(
name|addr
parameter_list|)
value|(*((volatile u_int32_t *)(addr)))
define|#
directive|define
name|ADDR_WRITE
parameter_list|(
name|addr
parameter_list|,
name|b
parameter_list|)
value|(void)((*(volatile u_int32_t *) (addr)) = (b))
define|#
directive|define
name|AR9340_SOC_GPIO_FUN0
value|0xB804002c
define|#
directive|define
name|AR9340_SOC_GPIO_OE
value|0xB8040000
if|#
directive|if
name|ATH_SMARTANTENNA_DISABLE_JTAG
define|#
directive|define
name|AR9340_SOC_GPIO_FUNCTION
value|(volatile u_int32_t*) 0xB804006c
define|#
directive|define
name|WASP_DISABLE_JTAG
value|0x2
define|#
directive|define
name|MAX_JTAG_GPIO_PIN
value|1
endif|#
directive|endif
name|u_int8_t
name|out_func
decl_stmt|,
name|shift
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
specifier|volatile
name|u_int32_t
modifier|*
name|address
decl_stmt|;
if|if
condition|(
operator|!
name|ah_signal_type
condition|)
block|{
return|return;
block|}
if|#
directive|if
name|ATH_SMARTANTENNA_DISABLE_JTAG
comment|/*   * To use GPIO pins 0 and 1 for controling antennas, JTAG needs to disabled.  */
if|if
condition|(
name|gpio
operator|<=
name|MAX_JTAG_GPIO_PIN
condition|)
block|{
name|flags
operator|=
name|ADDR_READ
argument_list|(
name|AR9340_SOC_GPIO_FUNCTION
argument_list|)
expr_stmt|;
name|flags
operator||=
name|WASP_DISABLE_JTAG
expr_stmt|;
name|ADDR_WRITE
argument_list|(
name|AR9340_SOC_GPIO_FUNCTION
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|out_func
operator|=
name|gpio
operator|/
literal|4
expr_stmt|;
name|shift
operator|=
operator|(
name|gpio
operator|%
literal|4
operator|)
expr_stmt|;
name|address
operator|=
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
operator|(
name|AR9340_SOC_GPIO_FUN0
operator|+
operator|(
name|out_func
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|flags
operator|=
name|ADDR_READ
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|flags
operator||=
name|ah_signal_type
operator|<<
operator|(
literal|8
operator|*
name|shift
operator|)
expr_stmt|;
name|ADDR_WRITE
argument_list|(
name|address
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|flags
operator|=
name|ADDR_READ
argument_list|(
name|AR9340_SOC_GPIO_OE
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|gpio
operator|)
expr_stmt|;
name|ADDR_WRITE
argument_list|(
name|AR9340_SOC_GPIO_OE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ar9300_gpio_cfg_output_mux
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|gpio
parameter_list|,
name|u_int32_t
name|type
parameter_list|)
block|{
name|int
name|addr
decl_stmt|;
name|u_int32_t
name|gpio_shift
decl_stmt|;
comment|/* each MUX controls 6 GPIO pins */
if|if
condition|(
name|gpio
operator|>
literal|11
condition|)
block|{
name|addr
operator|=
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OUTPUT_MUX3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gpio
operator|>
literal|5
condition|)
block|{
name|addr
operator|=
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OUTPUT_MUX2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OUTPUT_MUX1
argument_list|)
expr_stmt|;
block|}
comment|/*      * 5 bits per GPIO pin.      * Bits 0..4 for 1st pin in that mux,      * bits 5..9 for 2nd pin, etc.      */
name|gpio_shift
operator|=
operator|(
name|gpio
operator|%
literal|6
operator|)
operator|*
literal|5
expr_stmt|;
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
operator|(
name|type
operator|<<
name|gpio_shift
operator|)
argument_list|,
operator|(
literal|0x1f
operator|<<
name|gpio_shift
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Configure GPIO Output lines  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_gpio_cfg_output
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|gpio
parameter_list|,
name|HAL_GPIO_OUTPUT_MUX_TYPE
name|hal_signal_type
parameter_list|)
block|{
name|u_int32_t
name|ah_signal_type
decl_stmt|;
name|u_int32_t
name|gpio_shift
decl_stmt|;
name|u_int8_t
name|smart_ant
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|u_int32_t
name|mux_signal_conversion_table
index|[]
init|=
block|{
comment|/* HAL_GPIO_OUTPUT_MUX_AS_OUTPUT             */
name|AR_GPIO_OUTPUT_MUX_AS_OUTPUT
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_PCIE_ATTENTION_LED */
name|AR_GPIO_OUTPUT_MUX_AS_PCIE_ATTENTION_LED
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_PCIE_POWER_LED     */
name|AR_GPIO_OUTPUT_MUX_AS_PCIE_POWER_LED
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_MAC_NETWORK_LED    */
name|AR_GPIO_OUTPUT_MUX_AS_MAC_NETWORK_LED
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_MAC_POWER_LED      */
name|AR_GPIO_OUTPUT_MUX_AS_MAC_POWER_LED
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_WLAN_ACTIVE        */
name|AR_GPIO_OUTPUT_MUX_AS_RX_CLEAR_EXTERNAL
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_TX_FRAME           */
name|AR_GPIO_OUTPUT_MUX_AS_TX_FRAME
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_MCI_WLAN_DATA      */
name|AR_GPIO_OUTPUT_MUX_AS_MCI_WLAN_DATA
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_MCI_WLAN_CLK       */
name|AR_GPIO_OUTPUT_MUX_AS_MCI_WLAN_CLK
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA        */
name|AR_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK         */
name|AR_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_WL_IN_TX           */
name|AR_GPIO_OUTPUT_MUX_AS_WL_IN_TX
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_WL_IN_RX           */
name|AR_GPIO_OUTPUT_MUX_AS_WL_IN_RX
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_BT_IN_TX           */
name|AR_GPIO_OUTPUT_MUX_AS_BT_IN_TX
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_BT_IN_RX           */
name|AR_GPIO_OUTPUT_MUX_AS_BT_IN_RX
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_RUCKUS_STROBE      */
name|AR_GPIO_OUTPUT_MUX_AS_RUCKUS_STROBE
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_RUCKUS_DATA        */
name|AR_GPIO_OUTPUT_MUX_AS_RUCKUS_DATA
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL0     */
name|AR_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL0
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL1     */
name|AR_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL1
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL2     */
name|AR_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL2
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_SMARTANT_SWCOM3    */
name|AR_GPIO_OUTPUT_MUX_AS_SWCOM3
block|,     }
decl_stmt|;
name|HALASSERT
argument_list|(
name|gpio
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_num_gpio_pins
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gpio
operator|==
name|AR9382_GPIO_PIN_8_RESERVED
operator|)
operator|||
operator|(
name|gpio
operator|==
name|AR9382_GPIO_PIN_11_RESERVED
operator|)
operator|||
operator|(
name|gpio
operator|==
name|AR9382_GPIO_9_INPUT_ONLY
operator|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
comment|/* Convert HAL signal type definitions to hardware-specific values. */
if|if
condition|(
name|hal_signal_type
operator|<
name|ARRAY_LENGTH
argument_list|(
name|mux_signal_conversion_table
argument_list|)
condition|)
block|{
name|ah_signal_type
operator|=
name|mux_signal_conversion_table
index|[
name|hal_signal_type
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
name|gpio
operator|<=
name|AR9382_MAX_JTAG_GPIO_PIN_NUM
condition|)
block|{
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_INPUT_EN_VAL
argument_list|)
argument_list|,
name|AR_GPIO_JTAG_DISABLE
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|UMAC_SUPPORT_SMARTANTENNA
comment|/* Get the pin and func values for smart antenna */
switch|switch
condition|(
name|ah_signal_type
condition|)
block|{
case|case
name|AR_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL0
case|:
name|gpio
operator|=
name|ATH_GPIOPIN_ANTCHAIN0
expr_stmt|;
name|ah_signal_type
operator|=
name|ATH_GPIOFUNC_ANTCHAIN0
expr_stmt|;
name|smart_ant
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AR_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL1
case|:
name|gpio
operator|=
name|ATH_GPIOPIN_ANTCHAIN1
expr_stmt|;
name|ah_signal_type
operator|=
name|ATH_GPIOFUNC_ANTCHAIN1
expr_stmt|;
name|smart_ant
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AR_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL2
case|:
name|gpio
operator|=
name|ATH_GPIOPIN_ANTCHAIN2
expr_stmt|;
name|ah_signal_type
operator|=
name|ATH_GPIOFUNC_ANTCHAIN2
expr_stmt|;
name|smart_ant
operator|=
literal|1
expr_stmt|;
break|break;
if|#
directive|if
name|ATH_SMARTANTENNA_ROUTE_SWCOM_TO_GPIO
case|case
name|AR_GPIO_OUTPUT_MUX_AS_SWCOM3
case|:
name|gpio
operator|=
name|ATH_GPIOPIN_ROUTE_SWCOM3
expr_stmt|;
name|ah_signal_type
operator|=
name|ATH_GPIOFUNC_ROUTE_SWCOM3
expr_stmt|;
name|smart_ant
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|smart_ant
operator|&&
operator|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|UMAC_SUPPORT_SMARTANTENNA
name|ar9340_soc_gpio_cfg_output_mux
argument_list|(
name|ah
argument_list|,
name|gpio
argument_list|,
name|ah_signal_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|AH_TRUE
return|;
block|}
else|else
block|{
comment|/* Configure the MUX */
name|ar9300_gpio_cfg_output_mux
argument_list|(
name|ah
argument_list|,
name|gpio
argument_list|,
name|ah_signal_type
argument_list|)
expr_stmt|;
block|}
comment|/* 2 bits per output mode */
name|gpio_shift
operator|=
literal|2
operator|*
name|gpio
expr_stmt|;
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OE_OUT
argument_list|)
argument_list|,
operator|(
name|AR_GPIO_OE_OUT_DRV_ALL
operator|<<
name|gpio_shift
operator|)
argument_list|,
operator|(
name|AR_GPIO_OE_OUT_DRV
operator|<<
name|gpio_shift
operator|)
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Configure GPIO Output lines -LED off  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_gpio_cfg_output_led_off
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|gpio
parameter_list|,
name|HAL_GPIO_OUTPUT_MUX_TYPE
name|halSignalType
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a) / sizeof(a[0]))
name|u_int32_t
name|ah_signal_type
decl_stmt|;
name|u_int32_t
name|gpio_shift
decl_stmt|;
name|u_int8_t
name|smart_ant
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|u_int32_t
name|mux_signal_conversion_table
index|[]
init|=
block|{
comment|/* HAL_GPIO_OUTPUT_MUX_AS_OUTPUT             */
name|AR_GPIO_OUTPUT_MUX_AS_OUTPUT
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_PCIE_ATTENTION_LED */
name|AR_GPIO_OUTPUT_MUX_AS_PCIE_ATTENTION_LED
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_PCIE_POWER_LED     */
name|AR_GPIO_OUTPUT_MUX_AS_PCIE_POWER_LED
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_MAC_NETWORK_LED    */
name|AR_GPIO_OUTPUT_MUX_AS_MAC_NETWORK_LED
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_MAC_POWER_LED      */
name|AR_GPIO_OUTPUT_MUX_AS_MAC_POWER_LED
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_WLAN_ACTIVE        */
name|AR_GPIO_OUTPUT_MUX_AS_RX_CLEAR_EXTERNAL
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_TX_FRAME           */
name|AR_GPIO_OUTPUT_MUX_AS_TX_FRAME
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_MCI_WLAN_DATA      */
name|AR_GPIO_OUTPUT_MUX_AS_MCI_WLAN_DATA
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_MCI_WLAN_CLK       */
name|AR_GPIO_OUTPUT_MUX_AS_MCI_WLAN_CLK
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA        */
name|AR_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK         */
name|AR_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_WL_IN_TX           */
name|AR_GPIO_OUTPUT_MUX_AS_WL_IN_TX
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_WL_IN_RX           */
name|AR_GPIO_OUTPUT_MUX_AS_WL_IN_RX
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_BT_IN_TX           */
name|AR_GPIO_OUTPUT_MUX_AS_BT_IN_TX
block|,
comment|/* HAL_GPIO_OUTPUT_MUX_AS_BT_IN_RX           */
name|AR_GPIO_OUTPUT_MUX_AS_BT_IN_RX
block|,
name|AR_GPIO_OUTPUT_MUX_AS_RUCKUS_STROBE
block|,
name|AR_GPIO_OUTPUT_MUX_AS_RUCKUS_DATA
block|,
name|AR_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL0
block|,
name|AR_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL1
block|,
name|AR_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL2
block|}
decl_stmt|;
name|HALASSERT
argument_list|(
name|gpio
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_num_gpio_pins
argument_list|)
expr_stmt|;
comment|/* Convert HAL signal type definitions to hardware-specific values. */
if|if
condition|(
name|halSignalType
operator|<
name|ARRAY_LENGTH
argument_list|(
name|mux_signal_conversion_table
argument_list|)
condition|)
block|{
name|ah_signal_type
operator|=
name|mux_signal_conversion_table
index|[
name|halSignalType
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
name|AH_FALSE
return|;
block|}
if|#
directive|if
name|UMAC_SUPPORT_SMARTANTENNA
comment|/* Get the pin and func values for smart antenna */
switch|switch
condition|(
name|halSignalType
condition|)
block|{
case|case
name|AR_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL0
case|:
name|gpio
operator|=
name|ATH_GPIOPIN_ANTCHAIN0
expr_stmt|;
name|ah_signal_type
operator|=
name|ATH_GPIOFUNC_ANTCHAIN0
expr_stmt|;
name|smart_ant
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AR_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL1
case|:
name|gpio
operator|=
name|ATH_GPIOPIN_ANTCHAIN1
expr_stmt|;
name|ah_signal_type
operator|=
name|ATH_GPIOFUNC_ANTCHAIN1
expr_stmt|;
name|smart_ant
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AR_GPIO_OUTPUT_MUX_AS_SMARTANT_CTRL2
case|:
name|gpio
operator|=
name|ATH_GPIOPIN_ANTCHAIN2
expr_stmt|;
name|ah_signal_type
operator|=
name|ATH_GPIOFUNC_ANTCHAIN2
expr_stmt|;
name|smart_ant
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|smart_ant
operator|&&
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
comment|// Configure the MUX
name|ar9300_gpio_cfg_output_mux
argument_list|(
name|ah
argument_list|,
name|gpio
argument_list|,
name|ah_signal_type
argument_list|)
expr_stmt|;
comment|// 2 bits per output mode
name|gpio_shift
operator|=
literal|2
operator|*
name|gpio
expr_stmt|;
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OE_OUT
argument_list|)
argument_list|,
operator|(
name|AR_GPIO_OE_OUT_DRV_NO
operator|<<
name|gpio_shift
operator|)
argument_list|,
operator|(
name|AR_GPIO_OE_OUT_DRV
operator|<<
name|gpio_shift
operator|)
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Configure GPIO Input lines  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_gpio_cfg_input
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|gpio
parameter_list|)
block|{
name|u_int32_t
name|gpio_shift
decl_stmt|;
name|HALASSERT
argument_list|(
name|gpio
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_num_gpio_pins
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gpio
operator|==
name|AR9382_GPIO_PIN_8_RESERVED
operator|)
operator|||
operator|(
name|gpio
operator|==
name|AR9382_GPIO_PIN_11_RESERVED
operator|)
operator|||
operator|(
name|gpio
operator|>
name|AR9382_MAX_GPIO_INPUT_PIN_NUM
operator|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
name|gpio
operator|<=
name|AR9382_MAX_JTAG_GPIO_PIN_NUM
condition|)
block|{
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_INPUT_EN_VAL
argument_list|)
argument_list|,
name|AR_GPIO_JTAG_DISABLE
argument_list|)
expr_stmt|;
block|}
comment|/* TODO: configure input mux for AR9300 */
comment|/* If configured as input, set output to tristate */
name|gpio_shift
operator|=
literal|2
operator|*
name|gpio
expr_stmt|;
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OE_OUT
argument_list|)
argument_list|,
operator|(
name|AR_GPIO_OE_OUT_DRV_NO
operator|<<
name|gpio_shift
operator|)
argument_list|,
operator|(
name|AR_GPIO_OE_OUT_DRV
operator|<<
name|gpio_shift
operator|)
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Once configured for I/O - set output lines  * output the level of GPio PIN without care work mode   */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_gpio_set
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|gpio
parameter_list|,
name|u_int32_t
name|val
parameter_list|)
block|{
name|HALASSERT
argument_list|(
name|gpio
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_num_gpio_pins
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gpio
operator|==
name|AR9382_GPIO_PIN_8_RESERVED
operator|)
operator|||
operator|(
name|gpio
operator|==
name|AR9382_GPIO_PIN_11_RESERVED
operator|)
operator|||
operator|(
name|gpio
operator|==
name|AR9382_GPIO_9_INPUT_ONLY
operator|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OUT
argument_list|)
argument_list|,
operator|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|<<
name|gpio
operator|)
argument_list|,
name|AR_GPIO_BIT
argument_list|(
name|gpio
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Once configured for I/O - get input lines  */
end_comment

begin_function
name|u_int32_t
name|ar9300_gpio_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|gpio
parameter_list|)
block|{
name|u_int32_t
name|gpio_in
decl_stmt|;
name|HALASSERT
argument_list|(
name|gpio
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_num_gpio_pins
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gpio
operator|==
name|AR9382_GPIO_PIN_8_RESERVED
operator|)
operator|||
operator|(
name|gpio
operator|==
name|AR9382_GPIO_PIN_11_RESERVED
operator|)
condition|)
block|{
return|return
literal|0xffffffff
return|;
block|}
name|gpio_in
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_IN
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_IN
argument_list|)
argument_list|,
operator|(
literal|1
operator|<<
name|gpio
operator|)
argument_list|,
name|AR_GPIO_BIT
argument_list|(
name|gpio
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|MS
argument_list|(
name|gpio_in
argument_list|,
name|AR_GPIO_IN_VAL
argument_list|)
operator|&
name|AR_GPIO_BIT
argument_list|(
name|gpio
argument_list|)
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|u_int32_t
name|ar9300_gpio_get_intr
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|unsigned
name|int
name|mask
init|=
literal|0
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|mask
operator|=
name|ahp
operator|->
name|ah_gpio_cause
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function

begin_comment
comment|/*  * Set the GPIO Interrupt  * Sync and Async interrupts are both set/cleared.  * Async GPIO interrupts may not be raised when the chip is put to sleep.  */
end_comment

begin_function
name|void
name|ar9300_gpio_set_intr
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|gpio
parameter_list|,
name|u_int32_t
name|ilevel
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|reg_bit
decl_stmt|;
name|u_int32_t
name|reg_val
decl_stmt|;
name|u_int32_t
name|regs
index|[
literal|2
index|]
decl_stmt|,
name|shifts
index|[
literal|2
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|AH_ASSERT
name|u_int32_t
name|gpio_mask
decl_stmt|;
name|u_int32_t
name|old_field_val
init|=
literal|0
decl_stmt|,
name|field_val
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ATH_GPIO_USE_ASYNC_CAUSE
name|regs
index|[
literal|0
index|]
operator|=
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_ENABLE
argument_list|)
expr_stmt|;
name|regs
index|[
literal|1
index|]
operator|=
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_MASK
argument_list|)
expr_stmt|;
name|shifts
index|[
literal|0
index|]
operator|=
name|AR_INTR_ASYNC_ENABLE_GPIO_S
expr_stmt|;
name|shifts
index|[
literal|1
index|]
operator|=
name|AR_INTR_ASYNC_MASK_GPIO_S
expr_stmt|;
else|#
directive|else
name|regs
index|[
literal|0
index|]
operator|=
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_ENABLE
argument_list|)
expr_stmt|;
name|regs
index|[
literal|1
index|]
operator|=
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_MASK
argument_list|)
expr_stmt|;
name|shifts
index|[
literal|0
index|]
operator|=
name|AR_INTR_SYNC_ENABLE_GPIO_S
expr_stmt|;
name|shifts
index|[
literal|1
index|]
operator|=
name|AR_INTR_SYNC_MASK_GPIO_S
expr_stmt|;
endif|#
directive|endif
name|HALASSERT
argument_list|(
name|gpio
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_num_gpio_pins
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gpio
operator|==
name|AR9382_GPIO_PIN_8_RESERVED
operator|)
operator|||
operator|(
name|gpio
operator|==
name|AR9382_GPIO_PIN_11_RESERVED
operator|)
operator|||
operator|(
name|gpio
operator|>
name|AR9382_MAX_GPIO_INPUT_PIN_NUM
operator|)
condition|)
block|{
return|return;
block|}
ifdef|#
directive|ifdef
name|AH_ASSERT
name|gpio_mask
operator|=
operator|(
literal|1
operator|<<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_num_gpio_pins
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ilevel
operator|==
name|HAL_GPIO_INTR_DISABLE
condition|)
block|{
comment|/* clear this GPIO's bit in the interrupt registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_LENGTH
argument_list|(
name|regs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|reg_val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|reg_bit
operator|=
name|shifts
index|[
name|i
index|]
operator|+
name|gpio
expr_stmt|;
name|reg_val
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|reg_bit
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|regs
index|[
name|i
index|]
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* check that each register has same GPIOs enabled */
ifdef|#
directive|ifdef
name|AH_ASSERT
name|field_val
operator|=
operator|(
name|reg_val
operator|>>
name|shifts
index|[
name|i
index|]
operator|)
operator|&
name|gpio_mask
expr_stmt|;
name|HALASSERT
argument_list|(
name|i
operator|==
literal|0
operator|||
name|old_field_val
operator|==
name|field_val
argument_list|)
expr_stmt|;
name|old_field_val
operator|=
name|field_val
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|reg_val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_INTR_POL
argument_list|)
argument_list|)
expr_stmt|;
name|reg_bit
operator|=
name|gpio
expr_stmt|;
if|if
condition|(
name|ilevel
operator|==
name|HAL_GPIO_INTR_HIGH
condition|)
block|{
comment|/* 0 == interrupt on pin high */
name|reg_val
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|reg_bit
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ilevel
operator|==
name|HAL_GPIO_INTR_LOW
condition|)
block|{
comment|/* 1 == interrupt on pin low */
name|reg_val
operator||=
operator|(
literal|1
operator|<<
name|reg_bit
operator|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_INTR_POL
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* set this GPIO's bit in the interrupt registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_LENGTH
argument_list|(
name|regs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|reg_val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|reg_bit
operator|=
name|shifts
index|[
name|i
index|]
operator|+
name|gpio
expr_stmt|;
name|reg_val
operator||=
operator|(
literal|1
operator|<<
name|reg_bit
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|regs
index|[
name|i
index|]
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* check that each register has same GPIOs enabled */
ifdef|#
directive|ifdef
name|AH_ASSERT
name|field_val
operator|=
operator|(
name|reg_val
operator|>>
name|shifts
index|[
name|i
index|]
operator|)
operator|&
name|gpio_mask
expr_stmt|;
name|HALASSERT
argument_list|(
name|i
operator|==
literal|0
operator|||
name|old_field_val
operator|==
name|field_val
argument_list|)
expr_stmt|;
name|old_field_val
operator|=
name|field_val
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_function
name|u_int32_t
name|ar9300_gpio_get_polarity
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_INTR_POL
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ar9300_gpio_set_polarity
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|pol_map
parameter_list|,
name|u_int32_t
name|changed_mask
parameter_list|)
block|{
name|u_int32_t
name|gpio_mask
decl_stmt|;
name|gpio_mask
operator|=
operator|(
literal|1
operator|<<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_num_gpio_pins
operator|)
operator|-
literal|1
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_INTR_POL
argument_list|)
argument_list|,
name|gpio_mask
operator|&
name|pol_map
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ATH_GPIO_USE_ASYNC_CAUSE
comment|/*      * For SYNC_CAUSE type interrupts, we need to clear the cause register      * explicitly. Otherwise an interrupt with the original polarity setting      * will come up immediately (if there is already an interrupt source),      * which is not what we want usually.      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE_CLR
argument_list|)
argument_list|,
name|changed_mask
operator|<<
name|AR_INTR_SYNC_ENABLE_GPIO_S
argument_list|)
expr_stmt|;
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE_CLR
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * get the GPIO input pin mask  * gpio0 - gpio13  * gpio8, gpio11, regard as reserved by the chip ar9382  */
end_comment

begin_function
name|u_int32_t
name|ar9300_gpio_get_mask
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int32_t
name|mask
init|=
operator|(
literal|1
operator|<<
operator|(
name|AR9382_MAX_GPIO_INPUT_PIN_NUM
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_devid
operator|==
name|AR9300_DEVID_AR9380_PCIE
condition|)
block|{
name|mask
operator|=
operator|(
literal|1
operator|<<
name|AR9382_MAX_GPIO_PIN_NUM
operator|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|AR9382_GPIO_PIN_8_RESERVED
operator||
literal|1
operator|<<
name|AR9382_GPIO_PIN_11_RESERVED
operator|)
expr_stmt|;
block|}
return|return
name|mask
return|;
block|}
end_function

begin_function
name|int
name|ar9300_gpio_set_mask
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|mask
parameter_list|,
name|u_int32_t
name|pol_map
parameter_list|)
block|{
name|u_int32_t
name|invalid
init|=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|AR9382_MAX_GPIO_INPUT_PIN_NUM
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_devid
operator|==
name|AR9300_DEVID_AR9380_PCIE
condition|)
block|{
name|invalid
operator|=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|AR9382_MAX_GPIO_PIN_NUM
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|invalid
operator||=
literal|1
operator|<<
name|AR9382_GPIO_PIN_8_RESERVED
operator||
literal|1
operator|<<
name|AR9382_GPIO_PIN_11_RESERVED
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|invalid
condition|)
block|{
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"%s: invalid GPIO mask 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_gpio_mask
operator|=
name|mask
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_INTR_POL
argument_list|)
argument_list|,
name|mask
operator|&
name|pol_map
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AH_DEBUG
end_ifdef

begin_function_decl
name|void
name|ar9300_gpio_show
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ar9300_gpio_show
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"--- 9382 GPIOs ---(ah=%p)\n"
argument_list|,
name|ah
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"AH9300(_ah)->ah_hostifregs:%p\r\n"
argument_list|,
operator|&
operator|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_hostifregs
operator|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"GPIO_OUT:         0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OUT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"GPIO_IN:          0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_IN
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"GPIO_OE:          0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OE_OUT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"GPIO_OE1_OUT:     0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OE1_OUT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"GPIO_INTR_POLAR:  0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_INTR_POL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"GPIO_INPUT_VALUE: 0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_INPUT_EN_VAL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"GPIO_INPUT_MUX1:  0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_INPUT_MUX1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"GPIO_INPUT_MUX2:  0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_INPUT_MUX2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"GPIO_OUTPUT_MUX1: 0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OUTPUT_MUX1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"GPIO_OUTPUT_MUX2: 0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OUTPUT_MUX2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"GPIO_OUTPUT_MUX3: 0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OUTPUT_MUX3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"GPIO_INPUT_STATE: 0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INPUT_STATE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"GPIO_PDPU:        0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_PDPU
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"GPIO_DS:          0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_DS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"AR_INTR_ASYNC_ENABLE: 0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_ENABLE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"AR_INTR_ASYNC_MASK:   0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_MASK
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"AR_INTR_SYNC_ENABLE:  0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_ENABLE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"AR_INTR_SYNC_MASK:    0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_MASK
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"AR_INTR_ASYNC_CAUSE:  0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_CAUSE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"AR_INTR_SYNC_CAUSE:   0x%08X\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*AH_DEBUG*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AH_SUPPORT_AR9300 */
end_comment

end_unit

