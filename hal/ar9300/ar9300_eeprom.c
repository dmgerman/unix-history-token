begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2013 Qualcomm Atheros, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AH_SUPPORT_AR9300
end_ifdef

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AH_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|"ah_desc.h"
end_include

begin_comment
comment|/* NB: for HAL_PHYERR* */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ar9300/ar9300.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300eep.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300template_generic.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300template_xb112.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300template_hb116.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300template_xb113.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300template_hb112.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300template_ap121.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300template_osprey_k31.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300template_wasp_2.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300template_wasp_k31.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300template_aphrodite.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300reg.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300phy.h"
end_include

begin_if
if|#
directive|if
name|AH_BYTE_ORDER
operator|==
name|AH_BIG_ENDIAN
end_if

begin_function_decl
name|void
name|ar9300_swap_eeprom
parameter_list|(
name|ar9300_eeprom_t
modifier|*
name|eep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ar9300_eeprom_template_swap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|u_int16_t
name|ar9300_eeprom_get_spur_chan
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|spur_chan
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_function_decl
specifier|static
specifier|inline
name|HAL_BOOL
name|ar9300_fill_eeprom
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|HAL_STATUS
name|ar9300_check_eeprom
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|ar9300_eeprom_t
modifier|*
name|default9300
index|[]
init|=
block|{
operator|&
name|ar9300_template_generic
block|,
operator|&
name|ar9300_template_xb112
block|,
operator|&
name|ar9300_template_hb116
block|,
operator|&
name|ar9300_template_hb112
block|,
operator|&
name|ar9300_template_xb113
block|,
operator|&
name|ar9300_template_ap121
block|,
operator|&
name|ar9300_template_wasp_2
block|,
operator|&
name|ar9300_template_wasp_k31
block|,
operator|&
name|ar9300_template_osprey_k31
block|,
operator|&
name|ar9300_template_aphrodite
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Different types of memory where the calibration data might be stored.  * All types are searched in ar9300_eeprom_restore()  * in the order flash, eeprom, otp.  * To disable searching a type, set its parameter to 0.  */
end_comment

begin_comment
comment|/*  * This is where we look for the calibration data.  * must be set before ath_attach() is called  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|calibration_data_try
init|=
name|calibration_data_none
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|calibration_data_try_address
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set the type of memory used to store calibration data.  * Used by nart to force reading/writing of a specific type.  * The driver can normally allow autodetection  * by setting source to calibration_data_none=0.  */
end_comment

begin_function
name|void
name|ar9300_calibration_data_set
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int32_t
name|source
parameter_list|)
block|{
if|if
condition|(
name|ah
operator|!=
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|=
name|source
expr_stmt|;
block|}
else|else
block|{
name|calibration_data_try
operator|=
name|source
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int32_t
name|ar9300_calibration_data_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
name|ah
operator|!=
literal|0
condition|)
block|{
return|return
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
return|;
block|}
else|else
block|{
return|return
name|calibration_data_try
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the address of first byte used to store calibration data.  * Used by nart to force reading/writing at a specific address.  * The driver can normally allow autodetection by setting size=0.  */
end_comment

begin_function
name|void
name|ar9300_calibration_data_address_set
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int32_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|ah
operator|!=
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|calibration_data_try_address
operator|=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int32_t
name|ar9300_calibration_data_address_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
name|ah
operator|!=
literal|0
condition|)
block|{
return|return
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
return|;
block|}
else|else
block|{
return|return
name|calibration_data_try_address
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is the template that is loaded if ar9300_eeprom_restore()  * can't find valid data in the memory.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Ar9300_eeprom_template_preference
init|=
name|ar9300_eeprom_template_generic
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ar9300_eeprom_template_preference
parameter_list|(
name|int32_t
name|value
parameter_list|)
block|{
name|Ar9300_eeprom_template_preference
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Install the specified default template.  * Overwrites any existing calibration and configuration information in memory.  */
end_comment

begin_function
name|int32_t
name|ar9300_eeprom_template_install
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int32_t
name|value
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|mptr
decl_stmt|,
modifier|*
name|dptr
decl_stmt|;
name|int
name|mdata_size
decl_stmt|;
name|mptr
operator|=
operator|&
name|ahp
operator|->
name|ah_eeprom
expr_stmt|;
name|mdata_size
operator|=
name|ar9300_eeprom_struct_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|mptr
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|calibration_data_source = calibration_data_none;         calibration_data_source_address = 0;
endif|#
directive|endif
name|dptr
operator|=
name|ar9300_eeprom_struct_default_find_by_id
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|dptr
operator|!=
literal|0
condition|)
block|{
name|OS_MEMCPY
argument_list|(
name|mptr
argument_list|,
name|dptr
argument_list|,
name|mdata_size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar9300_eeprom_restore_something
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|ar9300_eeprom_t
modifier|*
name|mptr
parameter_list|,
name|int
name|mdata_size
parameter_list|)
block|{
name|int
name|it
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|dptr
decl_stmt|;
name|int
name|nptr
decl_stmt|;
name|nptr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*      * if we didn't find any blocks in the memory,      * put the prefered template in place      */
if|if
condition|(
name|nptr
operator|<
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|=
name|calibration_data_none
expr_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
literal|0
expr_stmt|;
name|dptr
operator|=
name|ar9300_eeprom_struct_default_find_by_id
argument_list|(
name|Ar9300_eeprom_template_preference
argument_list|)
expr_stmt|;
if|if
condition|(
name|dptr
operator|!=
literal|0
condition|)
block|{
name|OS_MEMCPY
argument_list|(
name|mptr
argument_list|,
name|dptr
argument_list|,
name|mdata_size
argument_list|)
expr_stmt|;
name|nptr
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*      * if we didn't find the prefered one,      * put the normal default template in place      */
if|if
condition|(
name|nptr
operator|<
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|=
name|calibration_data_none
expr_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
literal|0
expr_stmt|;
name|dptr
operator|=
name|ar9300_eeprom_struct_default_find_by_id
argument_list|(
name|ar9300_eeprom_template_default
argument_list|)
expr_stmt|;
if|if
condition|(
name|dptr
operator|!=
literal|0
condition|)
block|{
name|OS_MEMCPY
argument_list|(
name|mptr
argument_list|,
name|dptr
argument_list|,
name|mdata_size
argument_list|)
expr_stmt|;
name|nptr
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*      * if we can't find the best template, put any old template in place      * presume that newer ones are better, so search backwards      */
if|if
condition|(
name|nptr
operator|<
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|=
name|calibration_data_none
expr_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|it
operator|=
name|ar9300_eeprom_struct_default_many
argument_list|()
operator|-
literal|1
init|;
name|it
operator|>=
literal|0
condition|;
name|it
operator|--
control|)
block|{
name|dptr
operator|=
name|ar9300_eeprom_struct_default
argument_list|(
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|dptr
operator|!=
literal|0
condition|)
block|{
name|OS_MEMCPY
argument_list|(
name|mptr
argument_list|,
name|dptr
argument_list|,
name|mdata_size
argument_list|)
expr_stmt|;
name|nptr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|nptr
return|;
block|}
end_function

begin_comment
comment|/*  * Read 16 bits of data from offset into *data  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_eeprom_read_word
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int16_t
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|AR_SREV_OSPREY
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR9300_EEPROM_OFFSET
operator|+
operator|(
name|off
operator|<<
name|AR9300_EEPROM_S
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_EEPROM_STATUS_DATA
argument_list|)
argument_list|,
name|AR_EEPROM_STATUS_DATA_BUSY
operator||
name|AR_EEPROM_STATUS_DATA_PROT_ACCESS
argument_list|,
literal|0
argument_list|,
name|AH_WAIT_TIMEOUT
argument_list|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
operator|*
name|data
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_EEPROM_STATUS_DATA
argument_list|)
argument_list|)
argument_list|,
name|AR_EEPROM_STATUS_DATA_VAL
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
else|else
block|{
operator|*
name|data
operator|=
literal|0
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_otp_read
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int32_t
modifier|*
name|data
parameter_list|,
name|HAL_BOOL
name|is_wifi
parameter_list|)
block|{
name|int
name|time_out
init|=
literal|1000
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|;
name|addr
operator|=
operator|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
operator|)
condition|?
name|OTP_MEM_START_ADDRESS_WASP
else|:
name|OTP_MEM_START_ADDRESS
expr_stmt|;
if|if
condition|(
operator|!
name|is_wifi
condition|)
block|{
name|addr
operator|=
name|BTOTP_MEM_START_ADDRESS
expr_stmt|;
block|}
name|addr
operator|+=
name|off
operator|*
literal|4
expr_stmt|;
comment|/* OTP is 32 bit addressable */
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
operator|)
condition|?
name|OTP_STATUS0_OTP_SM_BUSY_WASP
else|:
name|OTP_STATUS0_OTP_SM_BUSY
expr_stmt|;
if|if
condition|(
operator|!
name|is_wifi
condition|)
block|{
name|addr
operator|=
name|BTOTP_STATUS0_OTP_SM_BUSY
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|time_out
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|!
name|status
operator|)
condition|)
block|{
comment|/* wait for access complete */
comment|/* Read data valid, access not busy, sm not busy */
name|status
operator|=
operator|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|)
operator|&
literal|0x7
operator|)
operator|==
literal|0x4
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|time_out
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|time_out
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: Timed out during OTP Status0 validation\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|addr
operator|=
operator|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
operator|)
condition|?
name|OTP_STATUS1_EFUSE_READ_DATA_WASP
else|:
name|OTP_STATUS1_EFUSE_READ_DATA
expr_stmt|;
if|if
condition|(
operator|!
name|is_wifi
condition|)
block|{
name|addr
operator|=
name|BTOTP_STATUS1_EFUSE_READ_DATA
expr_stmt|;
block|}
operator|*
name|data
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|HAL_STATUS
name|ar9300_flash_map
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AR9100
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|ahp
operator|->
name|ah_cal_mem
operator|=
name|OS_REMAP
argument_list|(
name|ah
argument_list|,
name|AR9300_EEPROM_START_ADDR
argument_list|,
name|AR9300_EEPROM_MAX
argument_list|)
expr_stmt|;
else|#
directive|else
name|ahp
operator|->
name|ah_cal_mem
operator|=
name|OS_REMAP
argument_list|(
call|(
name|uintptr_t
call|)
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_st
argument_list|)
argument_list|,
operator|(
name|AR9300_EEPROM_MAX
operator|+
name|AR9300_FLASH_CAL_START_OFFSET
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ahp
operator|->
name|ah_cal_mem
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: cannot remap eeprom region \n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|HAL_EIO
return|;
block|}
return|return
name|HAL_OK
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_flash_read
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int16_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
operator|*
name|data
operator|=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|ahp
operator|->
name|ah_cal_mem
operator|)
index|[
name|off
index|]
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_flash_write
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|ahp
operator|->
name|ah_cal_mem
operator|)
index|[
name|off
index|]
operator|=
name|data
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|HAL_STATUS
name|ar9300_eeprom_attach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|ahp
operator|->
name|try_dram
operator|=
literal|1
expr_stmt|;
name|ahp
operator|->
name|try_eeprom
operator|=
literal|1
expr_stmt|;
name|ahp
operator|->
name|try_otp
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_CAL_NAND_FLASH
name|ahp
operator|->
name|try_nand
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|ahp
operator|->
name|try_flash
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|ahp
operator|->
name|calibration_data_source
operator|=
name|calibration_data_none
expr_stmt|;
name|ahp
operator|->
name|calibration_data_source_address
operator|=
literal|0
expr_stmt|;
name|ahp
operator|->
name|calibration_data_try
operator|=
name|calibration_data_try
expr_stmt|;
name|ahp
operator|->
name|calibration_data_try_address
operator|=
literal|0
expr_stmt|;
comment|/*      * In case flash will be used for EEPROM. Otherwise ahp->ah_cal_mem      * must be set to NULL or the real EEPROM address.      */
name|ar9300_flash_map
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/*      * ###### This function always return NO SPUR.      * This is not AH_TRUE for many board designs.      * Does anyone use this?      */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom_get_spur_chan
operator|=
name|ar9300_eeprom_get_spur_chan
expr_stmt|;
ifdef|#
directive|ifdef
name|OLDCODE
comment|/* XXX Needs to be moved for dynamic selection */
name|ahp
operator|->
name|ah_eeprom
operator|=
operator|*
operator|(
name|default9300
index|[
name|ar9300_eeprom_template_default
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Set default values for Hornet. */
name|ahp
operator|->
name|ah_eeprom
operator|.
name|base_eep_header
operator|.
name|op_cap_flags
operator|.
name|op_flags
operator|=
name|AR9300_OPFLAGS_11G
expr_stmt|;
name|ahp
operator|->
name|ah_eeprom
operator|.
name|base_eep_header
operator|.
name|txrx_mask
operator|=
literal|0x11
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Set default values for Poseidon. */
name|ahp
operator|->
name|ah_eeprom
operator|.
name|base_eep_header
operator|.
name|op_cap_flags
operator|.
name|op_flags
operator|=
name|AR9300_OPFLAGS_11G
expr_stmt|;
name|ahp
operator|->
name|ah_eeprom
operator|.
name|base_eep_header
operator|.
name|txrx_mask
operator|=
literal|0x11
expr_stmt|;
block|}
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_skip_eeprom_read
condition|)
block|{
name|ahp
operator|->
name|ah_emu_eeprom
operator|=
literal|1
expr_stmt|;
return|return
name|HAL_OK
return|;
block|}
name|ahp
operator|->
name|ah_emu_eeprom
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|UNUSED
endif|#
directive|endif
if|if
condition|(
operator|!
name|ar9300_fill_eeprom
argument_list|(
name|ah
argument_list|)
condition|)
block|{
return|return
name|HAL_EIO
return|;
block|}
return|return
name|HAL_OK
return|;
comment|/* return ar9300_check_eeprom(ah); */
else|#
directive|else
name|ahp
operator|->
name|ah_emu_eeprom
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/*#ifdef MDK_AP*/
comment|/* MDK_AP is defined only in NART AP build */
block|u_int8_t buffer[10];     int caldata_check = 0;      ar9300_calibration_data_read_flash(         ah, FLASH_BASE_CALDATA_OFFSET, buffer, 4);     printf("flash caldata:: %x\n", buffer[0]);     if (buffer[0] != 0xff) {         caldata_check = 1;     }     if (!caldata_check) {         ar9300_eeprom_t *mptr;         int mdata_size;         if (AR_SREV_HORNET(ah)) {
comment|/* XXX: For initial testing */
block|mptr =&ahp->ah_eeprom;             mdata_size = ar9300_eeprom_struct_size();             ahp->ah_eeprom = ar9300_template_ap121;             ahp->ah_emu_eeprom = 1;
comment|/* need it to let art save in to flash ????? */
block|calibration_data_source = calibration_data_flash;         } else if (AR_SREV_WASP(ah)) {
comment|/* XXX: For initial testing */
block|ath_hal_printf(ah, " wasp eep attach\n");             mptr =&ahp->ah_eeprom;             mdata_size = ar9300_eeprom_struct_size();             ahp->ah_eeprom = ar9300_template_generic;             ahp->ah_eeprom.mac_addr[0] = 0x00;             ahp->ah_eeprom.mac_addr[1] = 0x03;             ahp->ah_eeprom.mac_addr[2] = 0x7F;             ahp->ah_eeprom.mac_addr[3] = 0xBA;             ahp->ah_eeprom.mac_addr[4] = 0xD0;             ahp->ah_eeprom.mac_addr[5] = 0x00;             ahp->ah_emu_eeprom = 1;             ahp->ah_eeprom.base_eep_header.txrx_mask = 0x33;             ahp->ah_eeprom.base_eep_header.txrxgain = 0x10;
comment|/* need it to let art save in to flash ????? */
block|calibration_data_source = calibration_data_flash;         }         return HAL_OK;     }
endif|#
directive|endif
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|ahp
operator|->
name|try_eeprom
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ar9300_eeprom_restore
argument_list|(
name|ah
argument_list|)
condition|)
block|{
return|return
name|HAL_EIO
return|;
block|}
return|return
name|HAL_OK
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|u_int32_t
name|ar9300_eeprom_get
parameter_list|(
name|struct
name|ath_hal_9300
modifier|*
name|ahp
parameter_list|,
name|EEPROM_PARAM
name|param
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|ahp
operator|->
name|ah_eeprom
decl_stmt|;
name|OSPREY_BASE_EEP_HEADER
modifier|*
name|p_base
init|=
operator|&
name|eep
operator|->
name|base_eep_header
decl_stmt|;
name|OSPREY_BASE_EXTENSION_1
modifier|*
name|base_ext1
init|=
operator|&
name|eep
operator|->
name|base_ext1
decl_stmt|;
switch|switch
condition|(
name|param
condition|)
block|{
if|#
directive|if
name|NOTYET
case|case
name|EEP_NFTHRESH_5
case|:
return|return
name|p_modal
index|[
literal|0
index|]
operator|.
name|noise_floor_thresh_ch
index|[
literal|0
index|]
return|;
case|case
name|EEP_NFTHRESH_2
case|:
return|return
name|p_modal
index|[
literal|1
index|]
operator|.
name|noise_floor_thresh_ch
index|[
literal|0
index|]
return|;
endif|#
directive|endif
case|case
name|EEP_MAC_LSW
case|:
return|return
name|eep
operator|->
name|mac_addr
index|[
literal|0
index|]
operator|<<
literal|8
operator||
name|eep
operator|->
name|mac_addr
index|[
literal|1
index|]
return|;
case|case
name|EEP_MAC_MID
case|:
return|return
name|eep
operator|->
name|mac_addr
index|[
literal|2
index|]
operator|<<
literal|8
operator||
name|eep
operator|->
name|mac_addr
index|[
literal|3
index|]
return|;
case|case
name|EEP_MAC_MSW
case|:
return|return
name|eep
operator|->
name|mac_addr
index|[
literal|4
index|]
operator|<<
literal|8
operator||
name|eep
operator|->
name|mac_addr
index|[
literal|5
index|]
return|;
case|case
name|EEP_REG_0
case|:
return|return
name|p_base
operator|->
name|reg_dmn
index|[
literal|0
index|]
return|;
case|case
name|EEP_REG_1
case|:
return|return
name|p_base
operator|->
name|reg_dmn
index|[
literal|1
index|]
return|;
case|case
name|EEP_OP_CAP
case|:
return|return
name|p_base
operator|->
name|device_cap
return|;
case|case
name|EEP_OP_MODE
case|:
return|return
name|p_base
operator|->
name|op_cap_flags
operator|.
name|op_flags
return|;
case|case
name|EEP_RF_SILENT
case|:
return|return
name|p_base
operator|->
name|rf_silent
return|;
if|#
directive|if
name|NOTYET
case|case
name|EEP_OB_5
case|:
return|return
name|p_modal
index|[
literal|0
index|]
operator|.
name|ob
return|;
case|case
name|EEP_DB_5
case|:
return|return
name|p_modal
index|[
literal|0
index|]
operator|.
name|db
return|;
case|case
name|EEP_OB_2
case|:
return|return
name|p_modal
index|[
literal|1
index|]
operator|.
name|ob
return|;
case|case
name|EEP_DB_2
case|:
return|return
name|p_modal
index|[
literal|1
index|]
operator|.
name|db
return|;
case|case
name|EEP_MINOR_REV
case|:
return|return
name|p_base
operator|->
name|eeprom_version
operator|&
name|AR9300_EEP_VER_MINOR_MASK
return|;
endif|#
directive|endif
case|case
name|EEP_TX_MASK
case|:
return|return
operator|(
name|p_base
operator|->
name|txrx_mask
operator|>>
literal|4
operator|)
operator|&
literal|0xf
return|;
case|case
name|EEP_RX_MASK
case|:
return|return
name|p_base
operator|->
name|txrx_mask
operator|&
literal|0xf
return|;
if|#
directive|if
name|NOTYET
case|case
name|EEP_FSTCLK_5G
case|:
return|return
name|p_base
operator|->
name|fast_clk5g
return|;
case|case
name|EEP_RXGAIN_TYPE
case|:
return|return
name|p_base
operator|->
name|rx_gain_type
return|;
endif|#
directive|endif
case|case
name|EEP_DRIVE_STRENGTH
case|:
define|#
directive|define
name|AR9300_EEP_BASE_DRIVE_STRENGTH
value|0x1
return|return
name|p_base
operator|->
name|misc_configuration
operator|&
name|AR9300_EEP_BASE_DRIVE_STRENGTH
return|;
case|case
name|EEP_INTERNAL_REGULATOR
case|:
comment|/* Bit 4 is internal regulator flag */
return|return
operator|(
operator|(
name|p_base
operator|->
name|feature_enable
operator|&
literal|0x10
operator|)
operator|>>
literal|4
operator|)
return|;
case|case
name|EEP_SWREG
case|:
return|return
operator|(
name|p_base
operator|->
name|swreg
operator|)
return|;
case|case
name|EEP_PAPRD_ENABLED
case|:
comment|/* Bit 5 is paprd flag */
return|return
operator|(
operator|(
name|p_base
operator|->
name|feature_enable
operator|&
literal|0x20
operator|)
operator|>>
literal|5
operator|)
return|;
case|case
name|EEP_ANTDIV_control
case|:
return|return
call|(
name|u_int32_t
call|)
argument_list|(
name|base_ext1
operator|->
name|ant_div_control
argument_list|)
return|;
case|case
name|EEP_CHAIN_MASK_REDUCE
case|:
return|return
operator|(
operator|(
name|p_base
operator|->
name|misc_configuration
operator|>>
literal|3
operator|)
operator|&
literal|0x1
operator|)
return|;
case|case
name|EEP_OL_PWRCTRL
case|:
return|return
literal|0
return|;
case|case
name|EEP_DEV_TYPE
case|:
return|return
name|p_base
operator|->
name|device_type
return|;
default|default:
name|HALASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! **  \brief EEPROM fixup code for INI values ** ** This routine provides a place to insert "fixup" code for specific devices ** that need to modify INI values based on EEPROM values, BEFORE the INI values ** are written. ** Certain registers in the INI file can only be written once without ** undesired side effects, and this provides a place for EEPROM overrides ** in these cases. ** ** This is called at attach time once.  It should not affect run time ** performance at all ** **  \param ah       Pointer to HAL object (this) **  \param p_eep_data Pointer to (filled in) eeprom data structure **  \param reg      register being inspected on this call **  \param value    value in INI file ** **  \return Updated value for INI file. */
end_comment

begin_function
name|u_int32_t
name|ar9300_ini_fixup
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|ar9300_eeprom_t
modifier|*
name|p_eep_data
parameter_list|,
name|u_int32_t
name|reg
parameter_list|,
name|u_int32_t
name|value
parameter_list|)
block|{
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"ar9300_eeprom_def_ini_fixup: FIXME\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|BASE_EEPDEF_HEADER  *p_base  =&(p_eep_data->base_eep_header);      switch (AH_PRIVATE(ah)->ah_devid)     {     case AR9300_DEVID_AR9300_PCI:
comment|/*         ** Need to set the external/internal regulator bit to the proper value.         ** Can only write this ONCE.         */
block|if ( reg == 0x7894 )         {
comment|/*             ** Check for an EEPROM data structure of "0x0b" or better             */
block|HALDEBUG(ah, HAL_DEBUG_EEPROM, "ini VAL: %x  EEPROM: %x\n",                      value, (p_base->version& 0xff));              if ( (p_base->version& 0xff)> 0x0a) {                 HALDEBUG(ah, HAL_DEBUG_EEPROM,                     "PWDCLKIND: %d\n", p_base->pwdclkind);                 value&= ~AR_AN_TOP2_PWDCLKIND;                 value |=                     AR_AN_TOP2_PWDCLKIND&                     (p_base->pwdclkind<<  AR_AN_TOP2_PWDCLKIND_S);             } else {                 HALDEBUG(ah, HAL_DEBUG_EEPROM, "PWDCLKIND Earlier Rev\n");             }              HALDEBUG(ah, HAL_DEBUG_EEPROM, "final ini VAL: %x\n", value);         }         break;      }      return (value);
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Returns the interpolated y value corresponding to the specified x value  * from the np ordered pairs of data (px,py).  * The pairs do not have to be in any order.  * If the specified x value is less than any of the px,  * the returned y value is equal to the py for the lowest px.  * If the specified x value is greater than any of the px,  * the returned y value is equal to the py for the highest px.  */
end_comment

begin_function
specifier|static
name|int
name|interpolate
parameter_list|(
name|int32_t
name|x
parameter_list|,
name|int32_t
modifier|*
name|px
parameter_list|,
name|int32_t
modifier|*
name|py
parameter_list|,
name|u_int16_t
name|np
parameter_list|)
block|{
name|int
name|ip
init|=
literal|0
decl_stmt|;
name|int
name|lx
init|=
literal|0
decl_stmt|,
name|ly
init|=
literal|0
decl_stmt|,
name|lhave
init|=
literal|0
decl_stmt|;
name|int
name|hx
init|=
literal|0
decl_stmt|,
name|hy
init|=
literal|0
decl_stmt|,
name|hhave
init|=
literal|0
decl_stmt|;
name|int
name|dx
init|=
literal|0
decl_stmt|;
name|int
name|y
init|=
literal|0
decl_stmt|;
name|int
name|bf
decl_stmt|,
name|factor
decl_stmt|,
name|plus
decl_stmt|;
name|lhave
operator|=
literal|0
expr_stmt|;
name|hhave
operator|=
literal|0
expr_stmt|;
comment|/*      * identify best lower and higher x calibration measurement      */
for|for
control|(
name|ip
operator|=
literal|0
init|;
name|ip
operator|<
name|np
condition|;
name|ip
operator|++
control|)
block|{
name|dx
operator|=
name|x
operator|-
name|px
index|[
name|ip
index|]
expr_stmt|;
comment|/* this measurement is higher than our desired x */
if|if
condition|(
name|dx
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|hhave
operator|||
name|dx
operator|>
operator|(
name|x
operator|-
name|hx
operator|)
condition|)
block|{
comment|/* new best higher x measurement */
name|hx
operator|=
name|px
index|[
name|ip
index|]
expr_stmt|;
name|hy
operator|=
name|py
index|[
name|ip
index|]
expr_stmt|;
name|hhave
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* this measurement is lower than our desired x */
if|if
condition|(
name|dx
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|lhave
operator|||
name|dx
operator|<
operator|(
name|x
operator|-
name|lx
operator|)
condition|)
block|{
comment|/* new best lower x measurement */
name|lx
operator|=
name|px
index|[
name|ip
index|]
expr_stmt|;
name|ly
operator|=
name|py
index|[
name|ip
index|]
expr_stmt|;
name|lhave
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* the low x is good */
if|if
condition|(
name|lhave
condition|)
block|{
comment|/* so is the high x */
if|if
condition|(
name|hhave
condition|)
block|{
comment|/* they're the same, so just pick one */
if|if
condition|(
name|hx
operator|==
name|lx
condition|)
block|{
name|y
operator|=
name|ly
expr_stmt|;
block|}
else|else
block|{
comment|/* interpolate with round off */
name|bf
operator|=
operator|(
literal|2
operator|*
operator|(
name|hy
operator|-
name|ly
operator|)
operator|*
operator|(
name|x
operator|-
name|lx
operator|)
operator|)
operator|/
operator|(
name|hx
operator|-
name|lx
operator|)
expr_stmt|;
name|plus
operator|=
operator|(
name|bf
operator|%
literal|2
operator|)
expr_stmt|;
name|factor
operator|=
name|bf
operator|/
literal|2
expr_stmt|;
name|y
operator|=
name|ly
operator|+
name|factor
operator|+
name|plus
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* only low is good, use it */
name|y
operator|=
name|ly
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hhave
condition|)
block|{
comment|/* only high is good, use it */
name|y
operator|=
name|hy
expr_stmt|;
block|}
else|else
block|{
comment|/* nothing is good,this should never happen unless np=0, ????  */
name|y
operator|=
operator|-
operator|(
literal|1
operator|<<
literal|30
operator|)
expr_stmt|;
block|}
return|return
name|y
return|;
block|}
end_function

begin_function
name|u_int8_t
name|ar9300_eeprom_get_legacy_trgt_pwr
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|rate_index
parameter_list|,
name|u_int16_t
name|freq
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
name|u_int16_t
name|num_piers
decl_stmt|,
name|i
decl_stmt|;
name|int32_t
name|target_power_array
index|[
name|OSPREY_NUM_5G_20_TARGET_POWERS
index|]
decl_stmt|;
name|int32_t
name|freq_array
index|[
name|OSPREY_NUM_5G_20_TARGET_POWERS
index|]
decl_stmt|;
name|u_int8_t
modifier|*
name|p_freq_bin
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|CAL_TARGET_POWER_LEG
modifier|*
name|p_eeprom_target_pwr
decl_stmt|;
if|if
condition|(
name|is_2ghz
condition|)
block|{
name|num_piers
operator|=
name|OSPREY_NUM_2G_20_TARGET_POWERS
expr_stmt|;
name|p_eeprom_target_pwr
operator|=
name|eep
operator|->
name|cal_target_power_2g
expr_stmt|;
name|p_freq_bin
operator|=
name|eep
operator|->
name|cal_target_freqbin_2g
expr_stmt|;
block|}
else|else
block|{
name|num_piers
operator|=
name|OSPREY_NUM_5G_20_TARGET_POWERS
expr_stmt|;
name|p_eeprom_target_pwr
operator|=
name|eep
operator|->
name|cal_target_power_5g
expr_stmt|;
name|p_freq_bin
operator|=
name|eep
operator|->
name|cal_target_freqbin_5g
expr_stmt|;
block|}
comment|/*      * create array of channels and targetpower from      * targetpower piers stored on eeprom      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_piers
condition|;
name|i
operator|++
control|)
block|{
name|freq_array
index|[
name|i
index|]
operator|=
name|FBIN2FREQ
argument_list|(
name|p_freq_bin
index|[
name|i
index|]
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_array
index|[
name|i
index|]
operator|=
name|p_eeprom_target_pwr
index|[
name|i
index|]
operator|.
name|t_pow2x
index|[
name|rate_index
index|]
expr_stmt|;
block|}
comment|/* interpolate to get target power for given frequency */
return|return
operator|(
operator|(
name|u_int8_t
operator|)
name|interpolate
argument_list|(
operator|(
name|int32_t
operator|)
name|freq
argument_list|,
name|freq_array
argument_list|,
name|target_power_array
argument_list|,
name|num_piers
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|u_int8_t
name|ar9300_eeprom_get_ht20_trgt_pwr
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|rate_index
parameter_list|,
name|u_int16_t
name|freq
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
name|u_int16_t
name|num_piers
decl_stmt|,
name|i
decl_stmt|;
name|int32_t
name|target_power_array
index|[
name|OSPREY_NUM_5G_20_TARGET_POWERS
index|]
decl_stmt|;
name|int32_t
name|freq_array
index|[
name|OSPREY_NUM_5G_20_TARGET_POWERS
index|]
decl_stmt|;
name|u_int8_t
modifier|*
name|p_freq_bin
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|OSP_CAL_TARGET_POWER_HT
modifier|*
name|p_eeprom_target_pwr
decl_stmt|;
if|if
condition|(
name|is_2ghz
condition|)
block|{
name|num_piers
operator|=
name|OSPREY_NUM_2G_20_TARGET_POWERS
expr_stmt|;
name|p_eeprom_target_pwr
operator|=
name|eep
operator|->
name|cal_target_power_2g_ht20
expr_stmt|;
name|p_freq_bin
operator|=
name|eep
operator|->
name|cal_target_freqbin_2g_ht20
expr_stmt|;
block|}
else|else
block|{
name|num_piers
operator|=
name|OSPREY_NUM_5G_20_TARGET_POWERS
expr_stmt|;
name|p_eeprom_target_pwr
operator|=
name|eep
operator|->
name|cal_target_power_5g_ht20
expr_stmt|;
name|p_freq_bin
operator|=
name|eep
operator|->
name|cal_target_freqbin_5g_ht20
expr_stmt|;
block|}
comment|/*      * create array of channels and targetpower from      * targetpower piers stored on eeprom      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_piers
condition|;
name|i
operator|++
control|)
block|{
name|freq_array
index|[
name|i
index|]
operator|=
name|FBIN2FREQ
argument_list|(
name|p_freq_bin
index|[
name|i
index|]
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_array
index|[
name|i
index|]
operator|=
name|p_eeprom_target_pwr
index|[
name|i
index|]
operator|.
name|t_pow2x
index|[
name|rate_index
index|]
expr_stmt|;
block|}
comment|/* interpolate to get target power for given frequency */
return|return
operator|(
operator|(
name|u_int8_t
operator|)
name|interpolate
argument_list|(
operator|(
name|int32_t
operator|)
name|freq
argument_list|,
name|freq_array
argument_list|,
name|target_power_array
argument_list|,
name|num_piers
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|u_int8_t
name|ar9300_eeprom_get_ht40_trgt_pwr
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|rate_index
parameter_list|,
name|u_int16_t
name|freq
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
name|u_int16_t
name|num_piers
decl_stmt|,
name|i
decl_stmt|;
name|int32_t
name|target_power_array
index|[
name|OSPREY_NUM_5G_40_TARGET_POWERS
index|]
decl_stmt|;
name|int32_t
name|freq_array
index|[
name|OSPREY_NUM_5G_40_TARGET_POWERS
index|]
decl_stmt|;
name|u_int8_t
modifier|*
name|p_freq_bin
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|OSP_CAL_TARGET_POWER_HT
modifier|*
name|p_eeprom_target_pwr
decl_stmt|;
if|if
condition|(
name|is_2ghz
condition|)
block|{
name|num_piers
operator|=
name|OSPREY_NUM_2G_40_TARGET_POWERS
expr_stmt|;
name|p_eeprom_target_pwr
operator|=
name|eep
operator|->
name|cal_target_power_2g_ht40
expr_stmt|;
name|p_freq_bin
operator|=
name|eep
operator|->
name|cal_target_freqbin_2g_ht40
expr_stmt|;
block|}
else|else
block|{
name|num_piers
operator|=
name|OSPREY_NUM_5G_40_TARGET_POWERS
expr_stmt|;
name|p_eeprom_target_pwr
operator|=
name|eep
operator|->
name|cal_target_power_5g_ht40
expr_stmt|;
name|p_freq_bin
operator|=
name|eep
operator|->
name|cal_target_freqbin_5g_ht40
expr_stmt|;
block|}
comment|/*      * create array of channels and targetpower from      * targetpower piers stored on eeprom      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_piers
condition|;
name|i
operator|++
control|)
block|{
name|freq_array
index|[
name|i
index|]
operator|=
name|FBIN2FREQ
argument_list|(
name|p_freq_bin
index|[
name|i
index|]
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_array
index|[
name|i
index|]
operator|=
name|p_eeprom_target_pwr
index|[
name|i
index|]
operator|.
name|t_pow2x
index|[
name|rate_index
index|]
expr_stmt|;
block|}
comment|/* interpolate to get target power for given frequency */
return|return
operator|(
operator|(
name|u_int8_t
operator|)
name|interpolate
argument_list|(
operator|(
name|int32_t
operator|)
name|freq
argument_list|,
name|freq_array
argument_list|,
name|target_power_array
argument_list|,
name|num_piers
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|u_int8_t
name|ar9300_eeprom_get_cck_trgt_pwr
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|rate_index
parameter_list|,
name|u_int16_t
name|freq
parameter_list|)
block|{
name|u_int16_t
name|num_piers
init|=
name|OSPREY_NUM_2G_CCK_TARGET_POWERS
decl_stmt|,
name|i
decl_stmt|;
name|int32_t
name|target_power_array
index|[
name|OSPREY_NUM_2G_CCK_TARGET_POWERS
index|]
decl_stmt|;
name|int32_t
name|freq_array
index|[
name|OSPREY_NUM_2G_CCK_TARGET_POWERS
index|]
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|u_int8_t
modifier|*
name|p_freq_bin
init|=
name|eep
operator|->
name|cal_target_freqbin_cck
decl_stmt|;
name|CAL_TARGET_POWER_LEG
modifier|*
name|p_eeprom_target_pwr
init|=
name|eep
operator|->
name|cal_target_power_cck
decl_stmt|;
comment|/*      * create array of channels and targetpower from      * targetpower piers stored on eeprom      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_piers
condition|;
name|i
operator|++
control|)
block|{
name|freq_array
index|[
name|i
index|]
operator|=
name|FBIN2FREQ
argument_list|(
name|p_freq_bin
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|target_power_array
index|[
name|i
index|]
operator|=
name|p_eeprom_target_pwr
index|[
name|i
index|]
operator|.
name|t_pow2x
index|[
name|rate_index
index|]
expr_stmt|;
block|}
comment|/* interpolate to get target power for given frequency */
return|return
operator|(
operator|(
name|u_int8_t
operator|)
name|interpolate
argument_list|(
operator|(
name|int32_t
operator|)
name|freq
argument_list|,
name|freq_array
argument_list|,
name|target_power_array
argument_list|,
name|num_piers
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set tx power registers to array of values passed in  */
end_comment

begin_function
name|int
name|ar9300_transmit_power_reg_write
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int8_t
modifier|*
name|p_pwr_array
parameter_list|)
block|{
define|#
directive|define
name|POW_SM
parameter_list|(
name|_r
parameter_list|,
name|_s
parameter_list|)
value|(((_r)& 0x3f)<< (_s))
comment|/* make sure forced gain is not set */
if|#
directive|if
literal|0
block|field_write("force_dac_gain", 0);     OS_REG_WRITE(ah, 0xa3f8, 0);     field_write("force_tx_gain", 0);
endif|#
directive|endif
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0xa458
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Write the OFDM power per rate set */
comment|/* 6 (LSB), 9, 12, 18 (MSB) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0xa3c0
argument_list|,
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_6_24
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_6_24
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_6_24
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_6_24
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 24 (LSB), 36, 48, 54 (MSB) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0xa3c4
argument_list|,
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_54
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_48
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_36
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_6_24
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the CCK power per rate set */
comment|/* 1L (LSB), reserved, 2L, 2S (MSB) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0xa3c8
argument_list|,
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_1L_5L
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_1L_5L
index|]
argument_list|,
literal|16
argument_list|)
comment|/*          | POW_SM(tx_power_times2,  8)*/
comment|/* this is reserved for Osprey */
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_1L_5L
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 5.5L (LSB), 5.5S, 11L, 11S (MSB) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0xa3cc
argument_list|,
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_11S
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_11L
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_5S
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_1L_5L
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write the power for duplicated frames - HT40 */
comment|/* dup40_cck (LSB), dup40_ofdm, ext20_cck, ext20_ofdm  (MSB) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0xa3e0
argument_list|,
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_6_24
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_1L_5L
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_6_24
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_1L_5L
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the HT20 power per rate set */
comment|/* 0/8/16 (LSB), 1-3/9-11/17-19, 4, 5 (MSB) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0xa3d0
argument_list|,
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT20_5
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT20_4
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT20_1_3_9_11_17_19
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT20_0_8_16
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 6 (LSB), 7, 12, 13 (MSB) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0xa3d4
argument_list|,
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT20_13
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT20_12
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT20_7
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT20_6
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 14 (LSB), 15, 20, 21 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0xa3e4
argument_list|,
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT20_21
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT20_20
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT20_15
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT20_14
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mixed HT20 and HT40 rates */
comment|/* HT20 22 (LSB), HT20 23, HT40 22, HT40 23 (MSB) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0xa3e8
argument_list|,
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT40_23
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT40_22
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT20_23
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT20_22
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the HT40 power per rate set */
comment|/* correct PAR difference between HT40 and HT20/LEGACY */
comment|/* 0/8/16 (LSB), 1-3/9-11/17-19, 4, 5 (MSB) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0xa3d8
argument_list|,
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT40_5
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT40_4
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT40_1_3_9_11_17_19
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT40_0_8_16
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 6 (LSB), 7, 12, 13 (MSB) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0xa3dc
argument_list|,
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT40_13
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT40_12
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT40_7
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT40_6
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 14 (LSB), 15, 20, 21 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0xa3ec
argument_list|,
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT40_21
index|]
argument_list|,
literal|24
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT40_20
index|]
argument_list|,
literal|16
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT40_15
index|]
argument_list|,
literal|8
argument_list|)
operator||
name|POW_SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_HT40_14
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|POW_SM
block|}
end_function

begin_function
specifier|static
name|void
name|ar9300_selfgen_tpc_reg_write
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|,
name|u_int8_t
modifier|*
name|p_pwr_array
parameter_list|)
block|{
name|u_int32_t
name|tpc_reg_val
decl_stmt|;
comment|/* Set the target power values for self generated frames (ACK,RTS/CTS) to      * be within limits. This is just a safety measure.With per packet TPC mode      * enabled the target power value used with self generated frames will be      * MIN( TPC reg, BB_powertx_rate register)      */
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|tpc_reg_val
operator|=
operator|(
name|SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_1L_5L
index|]
argument_list|,
name|AR_TPC_ACK
argument_list|)
operator||
name|SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_1L_5L
index|]
argument_list|,
name|AR_TPC_CTS
argument_list|)
operator||
name|SM
argument_list|(
literal|0x3f
argument_list|,
name|AR_TPC_CHIRP
argument_list|)
operator||
name|SM
argument_list|(
literal|0x3f
argument_list|,
name|AR_TPC_RPT
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tpc_reg_val
operator|=
operator|(
name|SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_6_24
index|]
argument_list|,
name|AR_TPC_ACK
argument_list|)
operator||
name|SM
argument_list|(
name|p_pwr_array
index|[
name|ALL_TARGET_LEGACY_6_24
index|]
argument_list|,
name|AR_TPC_CTS
argument_list|)
operator||
name|SM
argument_list|(
literal|0x3f
argument_list|,
name|AR_TPC_CHIRP
argument_list|)
operator||
name|SM
argument_list|(
literal|0x3f
argument_list|,
name|AR_TPC_RPT
argument_list|)
operator|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TPC
argument_list|,
name|tpc_reg_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar9300_set_target_power_from_eeprom
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|freq
parameter_list|,
name|u_int8_t
modifier|*
name|target_power_val_t2
parameter_list|)
block|{
comment|/* hard code for now, need to get from eeprom struct */
name|u_int8_t
name|ht40_power_inc_for_pdadc
init|=
literal|0
decl_stmt|;
name|HAL_BOOL
name|is_2ghz
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|freq
operator|<
literal|4000
condition|)
block|{
name|is_2ghz
operator|=
literal|1
expr_stmt|;
block|}
name|target_power_val_t2
index|[
name|ALL_TARGET_LEGACY_6_24
index|]
operator|=
name|ar9300_eeprom_get_legacy_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|LEGACY_TARGET_RATE_6_24
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_LEGACY_36
index|]
operator|=
name|ar9300_eeprom_get_legacy_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|LEGACY_TARGET_RATE_36
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_LEGACY_48
index|]
operator|=
name|ar9300_eeprom_get_legacy_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|LEGACY_TARGET_RATE_48
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_LEGACY_54
index|]
operator|=
name|ar9300_eeprom_get_legacy_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|LEGACY_TARGET_RATE_54
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_LEGACY_1L_5L
index|]
operator|=
name|ar9300_eeprom_get_cck_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|LEGACY_TARGET_RATE_1L_5L
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_LEGACY_5S
index|]
operator|=
name|ar9300_eeprom_get_cck_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|LEGACY_TARGET_RATE_5S
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_LEGACY_11L
index|]
operator|=
name|ar9300_eeprom_get_cck_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|LEGACY_TARGET_RATE_11L
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_LEGACY_11S
index|]
operator|=
name|ar9300_eeprom_get_cck_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|LEGACY_TARGET_RATE_11S
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT20_0_8_16
index|]
operator|=
name|ar9300_eeprom_get_ht20_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_0_8_16
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT20_1_3_9_11_17_19
index|]
operator|=
name|ar9300_eeprom_get_ht20_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_1_3_9_11_17_19
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT20_4
index|]
operator|=
name|ar9300_eeprom_get_ht20_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_4
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT20_5
index|]
operator|=
name|ar9300_eeprom_get_ht20_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_5
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT20_6
index|]
operator|=
name|ar9300_eeprom_get_ht20_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_6
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT20_7
index|]
operator|=
name|ar9300_eeprom_get_ht20_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_7
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT20_12
index|]
operator|=
name|ar9300_eeprom_get_ht20_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_12
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT20_13
index|]
operator|=
name|ar9300_eeprom_get_ht20_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_13
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT20_14
index|]
operator|=
name|ar9300_eeprom_get_ht20_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_14
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT20_15
index|]
operator|=
name|ar9300_eeprom_get_ht20_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_15
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT20_20
index|]
operator|=
name|ar9300_eeprom_get_ht20_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_20
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT20_21
index|]
operator|=
name|ar9300_eeprom_get_ht20_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_21
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT20_22
index|]
operator|=
name|ar9300_eeprom_get_ht20_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_22
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT20_23
index|]
operator|=
name|ar9300_eeprom_get_ht20_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_23
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT40_0_8_16
index|]
operator|=
name|ar9300_eeprom_get_ht40_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_0_8_16
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
operator|+
name|ht40_power_inc_for_pdadc
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT40_1_3_9_11_17_19
index|]
operator|=
name|ar9300_eeprom_get_ht40_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_1_3_9_11_17_19
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
operator|+
name|ht40_power_inc_for_pdadc
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT40_4
index|]
operator|=
name|ar9300_eeprom_get_ht40_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_4
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
operator|+
name|ht40_power_inc_for_pdadc
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT40_5
index|]
operator|=
name|ar9300_eeprom_get_ht40_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_5
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
operator|+
name|ht40_power_inc_for_pdadc
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT40_6
index|]
operator|=
name|ar9300_eeprom_get_ht40_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_6
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
operator|+
name|ht40_power_inc_for_pdadc
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT40_7
index|]
operator|=
name|ar9300_eeprom_get_ht40_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_7
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
operator|+
name|ht40_power_inc_for_pdadc
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT40_12
index|]
operator|=
name|ar9300_eeprom_get_ht40_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_12
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
operator|+
name|ht40_power_inc_for_pdadc
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT40_13
index|]
operator|=
name|ar9300_eeprom_get_ht40_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_13
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
operator|+
name|ht40_power_inc_for_pdadc
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT40_14
index|]
operator|=
name|ar9300_eeprom_get_ht40_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_14
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
operator|+
name|ht40_power_inc_for_pdadc
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT40_15
index|]
operator|=
name|ar9300_eeprom_get_ht40_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_15
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
operator|+
name|ht40_power_inc_for_pdadc
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT40_20
index|]
operator|=
name|ar9300_eeprom_get_ht40_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_20
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
operator|+
name|ht40_power_inc_for_pdadc
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT40_21
index|]
operator|=
name|ar9300_eeprom_get_ht40_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_21
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
operator|+
name|ht40_power_inc_for_pdadc
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT40_22
index|]
operator|=
name|ar9300_eeprom_get_ht40_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_22
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
operator|+
name|ht40_power_inc_for_pdadc
expr_stmt|;
name|target_power_val_t2
index|[
name|ALL_TARGET_HT40_23
index|]
operator|=
name|ar9300_eeprom_get_ht40_trgt_pwr
argument_list|(
name|ah
argument_list|,
name|HT_TARGET_RATE_23
argument_list|,
name|freq
argument_list|,
name|is_2ghz
argument_list|)
operator|+
name|ht40_power_inc_for_pdadc
expr_stmt|;
ifdef|#
directive|ifdef
name|AH_DEBUG
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: APPLYING TARGET POWERS\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|ar9300_rate_size
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: TPC[%02d] 0x%08x "
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|target_power_val_t2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ar9300_rate_size
condition|)
block|{
break|break;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: TPC[%02d] 0x%08x "
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|target_power_val_t2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ar9300_rate_size
condition|)
block|{
break|break;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: TPC[%02d] 0x%08x "
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|target_power_val_t2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ar9300_rate_size
condition|)
block|{
break|break;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: TPC[%02d] 0x%08x \n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|target_power_val_t2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|u_int16_t
modifier|*
name|ar9300_regulatory_domain_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
return|return
name|eep
operator|->
name|base_eep_header
operator|.
name|reg_dmn
return|;
block|}
end_function

begin_function
name|int32_t
name|ar9300_eeprom_write_enable_gpio_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
return|return
name|eep
operator|->
name|base_eep_header
operator|.
name|eeprom_write_enable_gpio
return|;
block|}
end_function

begin_function
name|int32_t
name|ar9300_wlan_disable_gpio_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
return|return
name|eep
operator|->
name|base_eep_header
operator|.
name|wlan_disable_gpio
return|;
block|}
end_function

begin_function
name|int32_t
name|ar9300_wlan_led_gpio_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
return|return
name|eep
operator|->
name|base_eep_header
operator|.
name|wlan_led_gpio
return|;
block|}
end_function

begin_function
name|int32_t
name|ar9300_rx_band_select_gpio_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
return|return
name|eep
operator|->
name|base_eep_header
operator|.
name|rx_band_select_gpio
return|;
block|}
end_function

begin_comment
comment|/*  * since valid noise floor values are negative, returns 1 on error  */
end_comment

begin_function
name|int32_t
name|ar9300_noise_floor_cal_or_power_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int32_t
name|frequency
parameter_list|,
name|int32_t
name|ichain
parameter_list|,
name|HAL_BOOL
name|use_cal
parameter_list|)
block|{
name|int
name|nf_use
init|=
literal|1
decl_stmt|;
comment|/* start with an error return value */
name|int32_t
name|fx
index|[
name|OSPREY_NUM_5G_CAL_PIERS
operator|+
name|OSPREY_NUM_2G_CAL_PIERS
index|]
decl_stmt|;
name|int32_t
name|nf
index|[
name|OSPREY_NUM_5G_CAL_PIERS
operator|+
name|OSPREY_NUM_2G_CAL_PIERS
index|]
decl_stmt|;
name|int
name|nnf
decl_stmt|;
name|int
name|is_2ghz
decl_stmt|;
name|int
name|ipier
decl_stmt|,
name|npier
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|u_int8_t
modifier|*
name|p_cal_pier
decl_stmt|;
name|OSP_CAL_DATA_PER_FREQ_OP_LOOP
modifier|*
name|p_cal_pier_struct
decl_stmt|;
comment|/*      * check chain value      */
if|if
condition|(
name|ichain
operator|<
literal|0
operator|||
name|ichain
operator|>=
name|OSPREY_MAX_CHAINS
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* figure out which band we're using */
name|is_2ghz
operator|=
operator|(
name|frequency
operator|<
literal|4000
operator|)
expr_stmt|;
if|if
condition|(
name|is_2ghz
condition|)
block|{
name|npier
operator|=
name|OSPREY_NUM_2G_CAL_PIERS
expr_stmt|;
name|p_cal_pier
operator|=
name|eep
operator|->
name|cal_freq_pier_2g
expr_stmt|;
name|p_cal_pier_struct
operator|=
name|eep
operator|->
name|cal_pier_data_2g
index|[
name|ichain
index|]
expr_stmt|;
block|}
else|else
block|{
name|npier
operator|=
name|OSPREY_NUM_5G_CAL_PIERS
expr_stmt|;
name|p_cal_pier
operator|=
name|eep
operator|->
name|cal_freq_pier_5g
expr_stmt|;
name|p_cal_pier_struct
operator|=
name|eep
operator|->
name|cal_pier_data_5g
index|[
name|ichain
index|]
expr_stmt|;
block|}
comment|/* look for valid noise floor values */
name|nnf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ipier
operator|=
literal|0
init|;
name|ipier
operator|<
name|npier
condition|;
name|ipier
operator|++
control|)
block|{
name|fx
index|[
name|nnf
index|]
operator|=
name|FBIN2FREQ
argument_list|(
name|p_cal_pier
index|[
name|ipier
index|]
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|nf
index|[
name|nnf
index|]
operator|=
name|use_cal
condition|?
name|p_cal_pier_struct
index|[
name|ipier
index|]
operator|.
name|rx_noisefloor_cal
else|:
name|p_cal_pier_struct
index|[
name|ipier
index|]
operator|.
name|rx_noisefloor_power
expr_stmt|;
if|if
condition|(
name|nf
index|[
name|nnf
index|]
operator|<
literal|0
condition|)
block|{
name|nnf
operator|++
expr_stmt|;
block|}
block|}
comment|/*      * If we have some valid values, interpolate to find the value      * at the desired frequency.      */
if|if
condition|(
name|nnf
operator|>
literal|0
condition|)
block|{
name|nf_use
operator|=
name|interpolate
argument_list|(
name|frequency
argument_list|,
name|fx
argument_list|,
name|nf
argument_list|,
name|nnf
argument_list|)
expr_stmt|;
block|}
return|return
name|nf_use
return|;
block|}
end_function

begin_function
name|int32_t
name|ar9300_rx_gain_index_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
return|return
operator|(
name|eep
operator|->
name|base_eep_header
operator|.
name|txrxgain
operator|)
operator|&
literal|0xf
return|;
comment|/* bits 3:0 */
block|}
end_function

begin_function
name|int32_t
name|ar9300_tx_gain_index_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
return|return
operator|(
name|eep
operator|->
name|base_eep_header
operator|.
name|txrxgain
operator|>>
literal|4
operator|)
operator|&
literal|0xf
return|;
comment|/* bits 7:4 */
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_internal_regulator_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|internal_regulator
init|=
name|ar9300_eeprom_get
argument_list|(
name|ahp
argument_list|,
name|EEP_INTERNAL_REGULATOR
argument_list|)
decl_stmt|;
name|int
name|reg_pmu1
decl_stmt|,
name|reg_pmu2
decl_stmt|,
name|reg_pmu1_set
decl_stmt|,
name|reg_pmu2_set
decl_stmt|;
name|u_int32_t
name|reg_PMU1
decl_stmt|,
name|reg_PMU2
decl_stmt|;
name|unsigned
name|long
name|eep_addr
decl_stmt|;
name|u_int32_t
name|reg_val
decl_stmt|,
name|reg_usb
init|=
literal|0
decl_stmt|,
name|reg_pmu
init|=
literal|0
decl_stmt|;
name|int
name|usb_valid
init|=
literal|0
decl_stmt|,
name|pmu_valid
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|pmu_refv
decl_stmt|;
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|reg_PMU1
operator|=
name|AR_PHY_PMU1_JUPITER
expr_stmt|;
name|reg_PMU2
operator|=
name|AR_PHY_PMU2_JUPITER
expr_stmt|;
block|}
else|else
block|{
name|reg_PMU1
operator|=
name|AR_PHY_PMU1
expr_stmt|;
name|reg_PMU2
operator|=
name|AR_PHY_PMU2
expr_stmt|;
block|}
if|if
condition|(
name|internal_regulator
condition|)
block|{
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Read OTP first */
for|for
control|(
name|eep_addr
operator|=
literal|0x14
init|;
condition|;
name|eep_addr
operator|-=
literal|0x10
control|)
block|{
name|ar9300_otp_read
argument_list|(
name|ah
argument_list|,
name|eep_addr
operator|/
literal|4
argument_list|,
operator|&
name|reg_val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg_val
operator|&
literal|0x80
operator|)
operator|==
literal|0x80
condition|)
block|{
name|usb_valid
operator|=
literal|1
expr_stmt|;
name|reg_usb
operator|=
name|reg_val
operator|&
literal|0x000000ff
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reg_val
operator|&
literal|0x80000000
operator|)
operator|==
literal|0x80000000
condition|)
block|{
name|pmu_valid
operator|=
literal|1
expr_stmt|;
name|reg_pmu
operator|=
operator|(
name|reg_val
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
expr_stmt|;
block|}
if|if
condition|(
name|eep_addr
operator|==
literal|0x4
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|pmu_valid
condition|)
block|{
name|pmu_refv
operator|=
name|reg_pmu
operator|&
literal|0xf
expr_stmt|;
block|}
else|else
block|{
name|pmu_refv
operator|=
literal|0x8
expr_stmt|;
block|}
comment|/*                  * If (valid) {                  *   Usb_phy_ctrl2_tx_cal_en -> 0                  *   Usb_phy_ctrl2_tx_cal_sel -> 0                  *   Usb_phy_ctrl2_tx_man_cal -> 0, 1, 3, 7 or 15 from OTP                  * }                  */
if|if
condition|(
name|usb_valid
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
literal|0x16c88
argument_list|,
name|AR_PHY_CTRL2_TX_CAL_EN
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
literal|0x16c88
argument_list|,
name|AR_PHY_CTRL2_TX_CAL_SEL
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
literal|0x16c88
argument_list|,
name|AR_PHY_CTRL2_TX_MAN_CAL
argument_list|,
operator|(
name|reg_usb
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pmu_refv
operator|=
literal|0x8
expr_stmt|;
block|}
comment|/*#ifndef USE_HIF*/
comment|/* Follow the MDK settings for Hornet PMU.              * my $pwd               = 0x0;              * my $Nfdiv             = 0x3;  # xtal_freq = 25MHz              * my $Nfdiv             = 0x4;  # xtal_freq = 40MHz              * my $Refv              = 0x7;  # 0x5:1.22V; 0x8:1.29V              * my $Gm1               = 0x3;  #Poseidon $Gm1=1              * my $classb            = 0x0;              * my $Cc                = 0x1;  #Poseidon $Cc=7              * my $Rc                = 0x6;              * my $ramp_slope        = 0x1;              * my $Segm              = 0x3;              * my $use_local_osc     = 0x0;              * my $force_xosc_stable = 0x0;              * my $Selfb             = 0x0;  #Poseidon $Selfb=1              * my $Filterfb          = 0x3;  #Poseidon $Filterfb=0              * my $Filtervc          = 0x0;              * my $disc              = 0x0;              * my $discdel           = 0x4;              * my $spare             = 0x0;              * $reg_PMU1 =              *     $pwd | ($Nfdiv<<1) | ($Refv<<4) | ($Gm1<<8) |              *     ($classb<<11) | ($Cc<<14) | ($Rc<<17) | ($ramp_slope<<20) |              *     ($Segm<<24) | ($use_local_osc<<26) |              *     ($force_xosc_stable<<27) | ($Selfb<<28) | ($Filterfb<<29);              * $reg_PMU2 = $handle->reg_rd("ch0_PMU2");              * $reg_PMU2 = ($reg_PMU2& 0xfe3fffff) | ($Filtervc<<22);              * $reg_PMU2 = ($reg_PMU2& 0xe3ffffff) | ($discdel<<26);              * $reg_PMU2 = ($reg_PMU2& 0x1fffffff) | ($spare<<29);               */
if|if
condition|(
name|ahp
operator|->
name|clk_25mhz
condition|)
block|{
name|reg_pmu1_set
operator|=
literal|0
operator||
operator|(
literal|3
operator|<<
literal|1
operator|)
operator||
operator|(
name|pmu_refv
operator|<<
literal|4
operator|)
operator||
operator|(
literal|3
operator|<<
literal|8
operator|)
operator||
operator|(
literal|0
operator|<<
literal|11
operator|)
operator||
operator|(
literal|1
operator|<<
literal|14
operator|)
operator||
operator|(
literal|6
operator|<<
literal|17
operator|)
operator||
operator|(
literal|1
operator|<<
literal|20
operator|)
operator||
operator|(
literal|3
operator|<<
literal|24
operator|)
operator||
operator|(
literal|0
operator|<<
literal|26
operator|)
operator||
operator|(
literal|0
operator|<<
literal|27
operator|)
operator||
operator|(
literal|0
operator|<<
literal|28
operator|)
operator||
operator|(
literal|0
operator|<<
literal|29
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|reg_pmu1_set
operator|=
literal|0
operator||
operator|(
literal|5
operator|<<
literal|1
operator|)
operator||
operator|(
literal|7
operator|<<
literal|4
operator|)
operator||
operator|(
literal|2
operator|<<
literal|8
operator|)
operator||
operator|(
literal|0
operator|<<
literal|11
operator|)
operator||
operator|(
literal|2
operator|<<
literal|14
operator|)
operator||
operator|(
literal|6
operator|<<
literal|17
operator|)
operator||
operator|(
literal|1
operator|<<
literal|20
operator|)
operator||
operator|(
literal|3
operator|<<
literal|24
operator|)
operator||
operator|(
literal|0
operator|<<
literal|26
operator|)
operator||
operator|(
literal|0
operator|<<
literal|27
operator|)
operator||
operator|(
literal|1
operator|<<
literal|28
operator|)
operator||
operator|(
literal|0
operator|<<
literal|29
operator|)
expr_stmt|;
block|}
else|else
block|{
name|reg_pmu1_set
operator|=
literal|0
operator||
operator|(
literal|4
operator|<<
literal|1
operator|)
operator||
operator|(
literal|7
operator|<<
literal|4
operator|)
operator||
operator|(
literal|3
operator|<<
literal|8
operator|)
operator||
operator|(
literal|0
operator|<<
literal|11
operator|)
operator||
operator|(
literal|1
operator|<<
literal|14
operator|)
operator||
operator|(
literal|6
operator|<<
literal|17
operator|)
operator||
operator|(
literal|1
operator|<<
literal|20
operator|)
operator||
operator|(
literal|3
operator|<<
literal|24
operator|)
operator||
operator|(
literal|0
operator|<<
literal|26
operator|)
operator||
operator|(
literal|0
operator|<<
literal|27
operator|)
operator||
operator|(
literal|0
operator|<<
literal|28
operator|)
operator||
operator|(
literal|0
operator|<<
literal|29
operator|)
expr_stmt|;
block|}
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|,
name|AR_PHY_PMU2_PGM
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg_PMU1
argument_list|,
name|reg_pmu1_set
argument_list|)
expr_stmt|;
comment|/* 0x638c8376 */
name|reg_pmu1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg_PMU1
argument_list|)
expr_stmt|;
while|while
condition|(
name|reg_pmu1
operator|!=
name|reg_pmu1_set
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg_PMU1
argument_list|,
name|reg_pmu1_set
argument_list|)
expr_stmt|;
comment|/* 0x638c8376 */
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|reg_pmu1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg_PMU1
argument_list|)
expr_stmt|;
block|}
name|reg_pmu2_set
operator|=
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|)
operator|&
operator|(
operator|~
literal|0xFFC00000
operator|)
operator|)
operator||
operator|(
literal|4
operator|<<
literal|26
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|,
name|reg_pmu2_set
argument_list|)
expr_stmt|;
name|reg_pmu2
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|)
expr_stmt|;
while|while
condition|(
name|reg_pmu2
operator|!=
name|reg_pmu2_set
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|,
name|reg_pmu2_set
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|reg_pmu2
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|)
expr_stmt|;
block|}
name|reg_pmu2_set
operator|=
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|)
operator|&
operator|(
operator|~
literal|0x00200000
operator|)
operator|)
operator||
operator|(
literal|1
operator|<<
literal|21
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|,
name|reg_pmu2_set
argument_list|)
expr_stmt|;
name|reg_pmu2
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|)
expr_stmt|;
while|while
condition|(
name|reg_pmu2
operator|!=
name|reg_pmu2_set
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|,
name|reg_pmu2_set
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|reg_pmu2
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|)
expr_stmt|;
block|}
comment|/*#endif*/
block|}
elseif|else
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Internal regulator is ON. Write swreg register. */
name|int
name|swreg
init|=
name|ar9300_eeprom_get
argument_list|(
name|ahp
argument_list|,
name|EEP_SWREG
argument_list|)
decl_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg_PMU1
argument_list|,
name|swreg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Internal regulator is ON. Write swreg register. */
name|int
name|swreg
init|=
name|ar9300_eeprom_get
argument_list|(
name|ahp
argument_list|,
name|EEP_SWREG
argument_list|)
decl_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_REG_CONTROL1
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RTC_REG_CONTROL1
argument_list|)
operator|&
operator|(
operator|~
name|AR_RTC_REG_CONTROL1_SWREG_PROGRAM
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_REG_CONTROL0
argument_list|,
name|swreg
argument_list|)
expr_stmt|;
comment|/* Set REG_CONTROL1.SWREG_PROGRAM */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_REG_CONTROL1
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RTC_REG_CONTROL1
argument_list|)
operator||
name|AR_RTC_REG_CONTROL1_SWREG_PROGRAM
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|,
name|AR_PHY_PMU2_PGM
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|reg_pmu2
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|,
name|AR_PHY_PMU2_PGM
argument_list|)
expr_stmt|;
while|while
condition|(
name|reg_pmu2
condition|)
block|{
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|reg_pmu2
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|,
name|AR_PHY_PMU2_PGM
argument_list|)
expr_stmt|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|reg_PMU1
argument_list|,
name|AR_PHY_PMU1_PWD
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|reg_pmu1
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|reg_PMU1
argument_list|,
name|AR_PHY_PMU1_PWD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|reg_pmu1
condition|)
block|{
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|reg_pmu1
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|reg_PMU1
argument_list|,
name|AR_PHY_PMU1_PWD
argument_list|)
expr_stmt|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|,
name|AR_PHY_PMU2_PGM
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|reg_pmu2
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|,
name|AR_PHY_PMU2_PGM
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|reg_pmu2
condition|)
block|{
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|reg_pmu2
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|reg_PMU2
argument_list|,
name|AR_PHY_PMU2_PGM
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|reg_PMU1
argument_list|,
name|AR_PHY_PMU1_PWD
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_SLEEP_CLK
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RTC_SLEEP_CLK
argument_list|)
operator||
name|AR_RTC_FORCE_SWREG_PRD
operator||
name|AR_RTC_PCIE_RST_PWDN_EN
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_drive_strength_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|drive_strength
decl_stmt|;
name|unsigned
name|long
name|reg
decl_stmt|;
name|drive_strength
operator|=
name|ar9300_eeprom_get
argument_list|(
name|ahp
argument_list|,
name|EEP_DRIVE_STRENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive_strength
condition|)
block|{
name|reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_BIAS1
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
literal|0x00ffffc0
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|21
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|18
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|15
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|12
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|9
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|6
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_BIAS1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_BIAS2
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
literal|0xffffffe0
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|29
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|26
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|23
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|20
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|17
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|14
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|11
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|8
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|5
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_BIAS2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_BIAS4
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
literal|0xff800000
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|29
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|26
expr_stmt|;
name|reg
operator||=
literal|0x5
operator|<<
literal|23
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_BIAS4
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int32_t
name|ar9300_xpa_bias_level_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
if|if
condition|(
name|is_2ghz
condition|)
block|{
return|return
name|eep
operator|->
name|modal_header_2g
operator|.
name|xpa_bias_lvl
return|;
block|}
else|else
block|{
return|return
name|eep
operator|->
name|modal_header_5g
operator|.
name|xpa_bias_lvl
return|;
block|}
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_xpa_bias_level_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
comment|/*      * In ar9330 emu, we can't access radio registers,       * merlin is used for radio part.      */
name|int
name|bias
decl_stmt|;
name|bias
operator|=
name|ar9300_xpa_bias_level_get
argument_list|(
name|ah
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_HORNET_CH0_TOP2
argument_list|,
name|AR_HORNET_CH0_TOP2_XPABIASLVL
argument_list|,
name|bias
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_SCORPION_CH0_TOP
argument_list|,
name|AR_SCORPION_CH0_TOP_XPABIASLVL
argument_list|,
name|bias
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_TOP_JUPITER
argument_list|,
name|AR_PHY_65NM_CH0_TOP_XPABIASLVL
argument_list|,
name|bias
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_TOP
argument_list|,
name|AR_PHY_65NM_CH0_TOP_XPABIASLVL
argument_list|,
name|bias
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_THERM
argument_list|,
name|AR_PHY_65NM_CH0_THERM_XPABIASLVL_MSB
argument_list|,
name|bias
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_THERM
argument_list|,
name|AR_PHY_65NM_CH0_THERM_XPASHORT2GND
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|u_int32_t
name|ar9300_ant_ctrl_common_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
if|if
condition|(
name|is_2ghz
condition|)
block|{
return|return
name|eep
operator|->
name|modal_header_2g
operator|.
name|ant_ctrl_common
return|;
block|}
else|else
block|{
return|return
name|eep
operator|->
name|modal_header_5g
operator|.
name|ant_ctrl_common
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|ar9300_switch_com_spdt_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
if|if
condition|(
name|is_2ghz
condition|)
block|{
return|return
name|eep
operator|->
name|modal_header_2g
operator|.
name|switchcomspdt
return|;
block|}
else|else
block|{
return|return
name|eep
operator|->
name|modal_header_5g
operator|.
name|switchcomspdt
return|;
block|}
block|}
end_function

begin_function
name|u_int32_t
name|ar9300_ant_ctrl_common2_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
if|if
condition|(
name|is_2ghz
condition|)
block|{
return|return
name|eep
operator|->
name|modal_header_2g
operator|.
name|ant_ctrl_common2
return|;
block|}
else|else
block|{
return|return
name|eep
operator|->
name|modal_header_5g
operator|.
name|ant_ctrl_common2
return|;
block|}
block|}
end_function

begin_function
name|u_int16_t
name|ar9300_ant_ctrl_chain_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|chain
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
if|if
condition|(
name|chain
operator|>=
literal|0
operator|&&
name|chain
operator|<
name|OSPREY_MAX_CHAINS
condition|)
block|{
if|if
condition|(
name|is_2ghz
condition|)
block|{
return|return
name|eep
operator|->
name|modal_header_2g
operator|.
name|ant_ctrl_chain
index|[
name|chain
index|]
return|;
block|}
else|else
block|{
return|return
name|eep
operator|->
name|modal_header_5g
operator|.
name|ant_ctrl_chain
index|[
name|chain
index|]
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_ant_ctrl_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
name|u_int32_t
name|value
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|u_int32_t
name|regval
decl_stmt|;
name|struct
name|ath_hal_private
modifier|*
name|ahpriv
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|#
directive|if
name|ATH_ANT_DIV_COMB
name|HAL_CAPABILITIES
modifier|*
name|pcap
init|=
operator|&
name|ahpriv
operator|->
name|ah_caps
decl_stmt|;
endif|#
directive|endif
comment|/* ATH_ANT_DIV_COMB */
name|u_int32_t
name|xlan_gpio_cfg
decl_stmt|;
name|u_int8_t
name|i
decl_stmt|;
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|xlan_gpio_cfg
operator|=
name|ahpriv
operator|->
name|ah_config
operator|.
name|ath_hal_ext_lna_ctl_gpio
expr_stmt|;
if|if
condition|(
name|xlan_gpio_cfg
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xlan_gpio_cfg
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|ath_hal_gpio_cfg_output
argument_list|(
name|ah
argument_list|,
name|i
argument_list|,
name|HAL_GPIO_OUTPUT_MUX_AS_PCIE_ATTENTION_LED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
define|#
directive|define
name|AR_SWITCH_TABLE_COM_ALL
value|(0xffff)
define|#
directive|define
name|AR_SWITCH_TABLE_COM_ALL_S
value|(0)
define|#
directive|define
name|AR_SWITCH_TABLE_COM_JUPITER_ALL
value|(0xffffff)
define|#
directive|define
name|AR_SWITCH_TABLE_COM_JUPITER_ALL_S
value|(0)
define|#
directive|define
name|AR_SWITCH_TABLE_COM_SCORPION_ALL
value|(0xffffff)
define|#
directive|define
name|AR_SWITCH_TABLE_COM_SCORPION_ALL_S
value|(0)
define|#
directive|define
name|AR_SWITCH_TABLE_COM_SPDT
value|(0x00f00000)
name|value
operator|=
name|ar9300_ant_ctrl_common_get
argument_list|(
name|ah
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|AR_SREV_JUPITER_10
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Force SPDT setting for Jupiter 1.0 chips. */
name|value
operator|&=
operator|~
name|AR_SWITCH_TABLE_COM_SPDT
expr_stmt|;
name|value
operator||=
literal|0x00100000
expr_stmt|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SWITCH_COM
argument_list|,
name|AR_SWITCH_TABLE_COM_JUPITER_ALL
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SWITCH_COM
argument_list|,
name|AR_SWITCH_TABLE_COM_SCORPION_ALL
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SWITCH_COM
argument_list|,
name|AR_SWITCH_TABLE_COM_ALL
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* *   Jupiter2.0 defines new switch table for BT/WLAN,  *	here's new field name in WB222.ref for both 2G and 5G. *   Register: [GLB_CONTROL] GLB_CONTROL (@0x20044) *   15:12	R/W	SWITCH_TABLE_COM_SPDT_WLAN_RX	SWITCH_TABLE_COM_SPDT_WLAN_RX  *   11:8	R/W	SWITCH_TABLE_COM_SPDT_WLAN_TX	SWITCH_TABLE_COM_SPDT_WLAN_TX *   7:4	R/W	SWITCH_TABLE_COM_SPDT_WLAN_IDLE	SWITCH_TABLE_COM_SPDT_WLAN_IDLE	 */
define|#
directive|define
name|AR_SWITCH_TABLE_COM_SPDT_ALL
value|(0x0000fff0)
define|#
directive|define
name|AR_SWITCH_TABLE_COM_SPDT_ALL_S
value|(4)
if|if
condition|(
name|AR_SREV_JUPITER_20_OR_LATER
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|value
operator|=
name|ar9300_switch_com_spdt_get
argument_list|(
name|ah
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_GLB_CONTROL
argument_list|,
name|AR_SWITCH_TABLE_COM_SPDT_ALL
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_GLB_CONTROL
argument_list|,
name|AR_BTCOEX_CTRL_SPDT_ENABLE
argument_list|)
expr_stmt|;
comment|//OS_REG_SET_BIT(ah, AR_GLB_CONTROL,
comment|//    AR_BTCOEX_CTRL_BT_OWN_SPDT_CTRL);
block|}
define|#
directive|define
name|AR_SWITCH_TABLE_COM2_ALL
value|(0xffffff)
define|#
directive|define
name|AR_SWITCH_TABLE_COM2_ALL_S
value|(0)
name|value
operator|=
name|ar9300_ant_ctrl_common2_get
argument_list|(
name|ah
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
if|#
directive|if
name|ATH_ANT_DIV_COMB
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_lna_div_use_bt_ant_enable
operator|==
name|TRUE
operator|)
condition|)
block|{
name|value
operator|&=
operator|~
name|AR_SWITCH_TABLE_COM2_ALL
expr_stmt|;
name|value
operator||=
name|ahpriv
operator|->
name|ah_config
operator|.
name|ath_hal_ant_ctrl_comm2g_switch_enable
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ATH_ANT_DIV_COMB */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SWITCH_COM_2
argument_list|,
name|AR_SWITCH_TABLE_COM2_ALL
argument_list|,
name|value
argument_list|)
expr_stmt|;
define|#
directive|define
name|AR_SWITCH_TABLE_ALL
value|(0xfff)
define|#
directive|define
name|AR_SWITCH_TABLE_ALL_S
value|(0)
name|value
operator|=
name|ar9300_ant_ctrl_chain_get
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SWITCH_CHAIN_0
argument_list|,
name|AR_SWITCH_TABLE_ALL
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|value
operator|=
name|ar9300_ant_ctrl_chain_get
argument_list|(
name|ah
argument_list|,
literal|1
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SWITCH_CHAIN_1
argument_list|,
name|AR_SWITCH_TABLE_ALL
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|value
operator|=
name|ar9300_ant_ctrl_chain_get
argument_list|(
name|ah
argument_list|,
literal|2
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SWITCH_CHAIN_2
argument_list|,
name|AR_SWITCH_TABLE_ALL
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|value
operator|=
name|ar9300_eeprom_get
argument_list|(
name|ahp
argument_list|,
name|EEP_ANTDIV_control
argument_list|)
expr_stmt|;
comment|/* main_lnaconf, alt_lnaconf, main_tb, alt_tb */
name|regval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MC_GAIN_CTRL
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|(
operator|~
name|ANT_DIV_CONTROL_ALL
operator|)
expr_stmt|;
comment|/* clear bit 25~30 */
name|regval
operator||=
operator|(
name|value
operator|&
literal|0x3f
operator|)
operator|<<
name|ANT_DIV_CONTROL_ALL_S
expr_stmt|;
comment|/* enable_lnadiv */
name|regval
operator|&=
operator|(
operator|~
name|MULTICHAIN_GAIN_CTRL__ENABLE_ANT_DIV_LNADIV__MASK
operator|)
expr_stmt|;
name|regval
operator||=
operator|(
operator|(
name|value
operator|>>
literal|6
operator|)
operator|&
literal|0x1
operator|)
operator|<<
name|MULTICHAIN_GAIN_CTRL__ENABLE_ANT_DIV_LNADIV__SHIFT
expr_stmt|;
if|#
directive|if
name|ATH_ANT_DIV_COMB
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_lna_div_use_bt_ant_enable
operator|==
name|TRUE
operator|)
condition|)
block|{
name|regval
operator||=
name|ANT_DIV_ENABLE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ATH_ANT_DIV_COMB */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MC_GAIN_CTRL
argument_list|,
name|regval
argument_list|)
expr_stmt|;
comment|/* enable fast_div */
name|regval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_DETECT
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|(
operator|~
name|BBB_SIG_DETECT__ENABLE_ANT_FAST_DIV__MASK
operator|)
expr_stmt|;
name|regval
operator||=
operator|(
operator|(
name|value
operator|>>
literal|7
operator|)
operator|&
literal|0x1
operator|)
operator|<<
name|BBB_SIG_DETECT__ENABLE_ANT_FAST_DIV__SHIFT
expr_stmt|;
if|#
directive|if
name|ATH_ANT_DIV_COMB
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_lna_div_use_bt_ant_enable
operator|==
name|TRUE
operator|)
condition|)
block|{
name|regval
operator||=
name|FAST_DIV_ENABLE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ATH_ANT_DIV_COMB */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_DETECT
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ATH_ANT_DIV_COMB
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_POSEIDON_11_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|pcap
operator|->
name|hal_ant_div_comb_support
condition|)
block|{
comment|/* If support DivComb, set MAIN to LNA1, ALT to LNA2 at beginning */
name|regval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MC_GAIN_CTRL
argument_list|)
expr_stmt|;
comment|/* clear bit 25~30 main_lnaconf, alt_lnaconf, main_tb, alt_tb */
name|regval
operator|&=
operator|(
operator|~
operator|(
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__MASK
operator||
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__MASK
operator||
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_GAINTB__MASK
operator||
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_GAINTB__MASK
operator|)
operator|)
expr_stmt|;
name|regval
operator||=
operator|(
name|HAL_ANT_DIV_COMB_LNA1
operator|<<
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__SHIFT
operator|)
expr_stmt|;
name|regval
operator||=
operator|(
name|HAL_ANT_DIV_COMB_LNA2
operator|<<
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__SHIFT
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MC_GAIN_CTRL
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ATH_ANT_DIV_COMB */
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_diversity_control
operator|==
name|HAL_ANT_FIXED_A
operator|||
name|ahp
operator|->
name|ah_diversity_control
operator|==
name|HAL_ANT_FIXED_B
operator|)
condition|)
block|{
name|u_int32_t
name|reg_val
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MC_GAIN_CTRL
argument_list|)
decl_stmt|;
name|reg_val
operator|&=
operator|~
operator|(
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__MASK
operator||
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__MASK
operator||
name|MULTICHAIN_GAIN_CTRL__ANT_FAST_DIV_BIAS__MASK
operator||
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_GAINTB__MASK
operator||
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_GAINTB__MASK
operator|)
expr_stmt|;
switch|switch
condition|(
name|ahp
operator|->
name|ah_diversity_control
condition|)
block|{
case|case
name|HAL_ANT_FIXED_A
case|:
comment|/* Enable first antenna only */
name|reg_val
operator||=
operator|(
name|HAL_ANT_DIV_COMB_LNA1
operator|<<
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__SHIFT
operator|)
expr_stmt|;
name|reg_val
operator||=
operator|(
name|HAL_ANT_DIV_COMB_LNA2
operator|<<
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__SHIFT
operator|)
expr_stmt|;
comment|/* main/alt gain table and Fast Div Bias all set to 0 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MC_GAIN_CTRL
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|regval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_DETECT
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|(
operator|~
name|BBB_SIG_DETECT__ENABLE_ANT_FAST_DIV__MASK
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_DETECT
argument_list|,
name|regval
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_ANT_FIXED_B
case|:
comment|/* Enable second antenna only, after checking capability */
name|reg_val
operator||=
operator|(
name|HAL_ANT_DIV_COMB_LNA2
operator|<<
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__SHIFT
operator|)
expr_stmt|;
name|reg_val
operator||=
operator|(
name|HAL_ANT_DIV_COMB_LNA1
operator|<<
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__SHIFT
operator|)
expr_stmt|;
comment|/* main/alt gain table and Fast Div all set to 0 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MC_GAIN_CTRL
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|regval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_DETECT
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|(
operator|~
name|BBB_SIG_DETECT__ENABLE_ANT_FAST_DIV__MASK
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_DETECT
argument_list|,
name|regval
argument_list|)
expr_stmt|;
comment|/* For WB225, need to swith ANT2 from BT to Wifi              * This will not affect HB125 LNA diversity feature.              */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SWITCH_COM_2
argument_list|,
name|AR_SWITCH_TABLE_COM2_ALL
argument_list|,
name|ahpriv
operator|->
name|ah_config
operator|.
name|ath_hal_ant_ctrl_comm2g_switch_enable
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|ar9300_attenuation_chain_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|chain
parameter_list|,
name|u_int16_t
name|channel
parameter_list|)
block|{
name|int32_t
name|f
index|[
literal|3
index|]
decl_stmt|,
name|t
index|[
literal|3
index|]
decl_stmt|;
name|u_int16_t
name|value
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
if|if
condition|(
name|chain
operator|>=
literal|0
operator|&&
name|chain
operator|<
name|OSPREY_MAX_CHAINS
condition|)
block|{
if|if
condition|(
name|channel
operator|<
literal|4000
condition|)
block|{
return|return
name|eep
operator|->
name|modal_header_2g
operator|.
name|xatten1_db
index|[
name|chain
index|]
return|;
block|}
else|else
block|{
if|if
condition|(
name|eep
operator|->
name|base_ext2
operator|.
name|xatten1_db_low
index|[
name|chain
index|]
operator|!=
literal|0
condition|)
block|{
name|t
index|[
literal|0
index|]
operator|=
name|eep
operator|->
name|base_ext2
operator|.
name|xatten1_db_low
index|[
name|chain
index|]
expr_stmt|;
name|f
index|[
literal|0
index|]
operator|=
literal|5180
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
name|eep
operator|->
name|modal_header_5g
operator|.
name|xatten1_db
index|[
name|chain
index|]
expr_stmt|;
name|f
index|[
literal|1
index|]
operator|=
literal|5500
expr_stmt|;
name|t
index|[
literal|2
index|]
operator|=
name|eep
operator|->
name|base_ext2
operator|.
name|xatten1_db_high
index|[
name|chain
index|]
expr_stmt|;
name|f
index|[
literal|2
index|]
operator|=
literal|5785
expr_stmt|;
name|value
operator|=
name|interpolate
argument_list|(
name|channel
argument_list|,
name|f
argument_list|,
name|t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
else|else
block|{
return|return
name|eep
operator|->
name|modal_header_5g
operator|.
name|xatten1_db
index|[
name|chain
index|]
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|ar9300_attenuation_margin_chain_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|chain
parameter_list|,
name|u_int16_t
name|channel
parameter_list|)
block|{
name|int32_t
name|f
index|[
literal|3
index|]
decl_stmt|,
name|t
index|[
literal|3
index|]
decl_stmt|;
name|u_int16_t
name|value
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
if|if
condition|(
name|chain
operator|>=
literal|0
operator|&&
name|chain
operator|<
name|OSPREY_MAX_CHAINS
condition|)
block|{
if|if
condition|(
name|channel
operator|<
literal|4000
condition|)
block|{
return|return
name|eep
operator|->
name|modal_header_2g
operator|.
name|xatten1_margin
index|[
name|chain
index|]
return|;
block|}
else|else
block|{
if|if
condition|(
name|eep
operator|->
name|base_ext2
operator|.
name|xatten1_margin_low
index|[
name|chain
index|]
operator|!=
literal|0
condition|)
block|{
name|t
index|[
literal|0
index|]
operator|=
name|eep
operator|->
name|base_ext2
operator|.
name|xatten1_margin_low
index|[
name|chain
index|]
expr_stmt|;
name|f
index|[
literal|0
index|]
operator|=
literal|5180
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
name|eep
operator|->
name|modal_header_5g
operator|.
name|xatten1_margin
index|[
name|chain
index|]
expr_stmt|;
name|f
index|[
literal|1
index|]
operator|=
literal|5500
expr_stmt|;
name|t
index|[
literal|2
index|]
operator|=
name|eep
operator|->
name|base_ext2
operator|.
name|xatten1_margin_high
index|[
name|chain
index|]
expr_stmt|;
name|f
index|[
literal|2
index|]
operator|=
literal|5785
expr_stmt|;
name|value
operator|=
name|interpolate
argument_list|(
name|channel
argument_list|,
name|f
argument_list|,
name|t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
else|else
block|{
return|return
name|eep
operator|->
name|modal_header_5g
operator|.
name|xatten1_margin
index|[
name|chain
index|]
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_attenuation_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|channel
parameter_list|)
block|{
name|u_int32_t
name|value
decl_stmt|;
name|struct
name|ath_hal_private
modifier|*
name|ahpriv
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* Test value. if 0 then attenuation is unused. Don't load anything. */
name|value
operator|=
name|ar9300_attenuation_chain_get
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_EXT_ATTEN_CTL_0
argument_list|,
name|AR_PHY_EXT_ATTEN_CTL_XATTEN1_DB
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|ar9300_attenuation_margin_chain_get
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar9300_rx_gain_index_get
argument_list|(
name|ah
argument_list|)
operator|==
literal|0
operator|&&
name|ahpriv
operator|->
name|ah_config
operator|.
name|ath_hal_ext_atten_margin_cfg
condition|)
block|{
name|value
operator|=
literal|5
expr_stmt|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_EXT_ATTEN_CTL_0
argument_list|,
name|AR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|value
operator|=
name|ar9300_attenuation_chain_get
argument_list|(
name|ah
argument_list|,
literal|1
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_EXT_ATTEN_CTL_1
argument_list|,
name|AR_PHY_EXT_ATTEN_CTL_XATTEN1_DB
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|ar9300_attenuation_margin_chain_get
argument_list|(
name|ah
argument_list|,
literal|1
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_EXT_ATTEN_CTL_1
argument_list|,
name|AR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|value
operator|=
name|ar9300_attenuation_chain_get
argument_list|(
name|ah
argument_list|,
literal|2
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_EXT_ATTEN_CTL_2
argument_list|,
name|AR_PHY_EXT_ATTEN_CTL_XATTEN1_DB
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|ar9300_attenuation_margin_chain_get
argument_list|(
name|ah
argument_list|,
literal|2
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_EXT_ATTEN_CTL_2
argument_list|,
name|AR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|ar9300_quick_drop_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|chain
parameter_list|,
name|u_int16_t
name|channel
parameter_list|)
block|{
name|int32_t
name|f
index|[
literal|3
index|]
decl_stmt|,
name|t
index|[
literal|3
index|]
decl_stmt|;
name|u_int16_t
name|value
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
if|if
condition|(
name|channel
operator|<
literal|4000
condition|)
block|{
return|return
name|eep
operator|->
name|modal_header_2g
operator|.
name|quick_drop
return|;
block|}
else|else
block|{
name|t
index|[
literal|0
index|]
operator|=
name|eep
operator|->
name|base_ext1
operator|.
name|quick_drop_low
expr_stmt|;
name|f
index|[
literal|0
index|]
operator|=
literal|5180
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
name|eep
operator|->
name|modal_header_5g
operator|.
name|quick_drop
expr_stmt|;
name|f
index|[
literal|1
index|]
operator|=
literal|5500
expr_stmt|;
name|t
index|[
literal|2
index|]
operator|=
name|eep
operator|->
name|base_ext1
operator|.
name|quick_drop_high
expr_stmt|;
name|f
index|[
literal|2
index|]
operator|=
literal|5785
expr_stmt|;
name|value
operator|=
name|interpolate
argument_list|(
name|channel
argument_list|,
name|f
argument_list|,
name|t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar9300_quick_drop_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|channel
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|u_int32_t
name|value
decl_stmt|;
comment|//
comment|// Test value. if 0 then quickDrop is unused. Don't load anything.
comment|//
if|if
condition|(
name|eep
operator|->
name|base_eep_header
operator|.
name|misc_configuration
operator|&
literal|0x10
condition|)
block|{
if|if
condition|(
name|AR_SREV_OSPREY
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_AR9580
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|value
operator|=
name|ar9300_quick_drop_get
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC
argument_list|,
name|AR_PHY_AGC_QUICK_DROP
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|ar9300_tx_end_to_xpa_off_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|channel
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
if|if
condition|(
name|channel
operator|<
literal|4000
condition|)
block|{
return|return
name|eep
operator|->
name|modal_header_2g
operator|.
name|tx_end_to_xpa_off
return|;
block|}
else|else
block|{
return|return
name|eep
operator|->
name|modal_header_5g
operator|.
name|tx_end_to_xpa_off
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar9300_tx_end_to_xpab_off_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|channel
parameter_list|)
block|{
name|u_int32_t
name|value
decl_stmt|;
name|value
operator|=
name|ar9300_tx_end_to_xpa_off_get
argument_list|(
name|ah
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* Apply to both xpaa and xpab */
if|if
condition|(
name|AR_SREV_OSPREY
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_AR9580
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_XPA_TIMING_CTL
argument_list|,
name|AR_PHY_XPA_TIMING_CTL_TX_END_XPAB_OFF
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_XPA_TIMING_CTL
argument_list|,
name|AR_PHY_XPA_TIMING_CTL_TX_END_XPAA_OFF
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar9300_eeprom_cal_pier_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|ipier
parameter_list|,
name|int
name|ichain
parameter_list|,
name|int
modifier|*
name|pfrequency
parameter_list|,
name|int
modifier|*
name|pcorrection
parameter_list|,
name|int
modifier|*
name|ptemperature
parameter_list|,
name|int
modifier|*
name|pvoltage
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|p_cal_pier
decl_stmt|;
name|OSP_CAL_DATA_PER_FREQ_OP_LOOP
modifier|*
name|p_cal_pier_struct
decl_stmt|;
name|int
name|is_2ghz
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
if|if
condition|(
name|ichain
operator|>=
name|OSPREY_MAX_CHAINS
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: Invalid chain index, must be less than %d\n"
argument_list|,
name|__func__
argument_list|,
name|OSPREY_MAX_CHAINS
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mode
condition|)
block|{
comment|/* 5GHz */
if|if
condition|(
name|ipier
operator|>=
name|OSPREY_NUM_5G_CAL_PIERS
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: Invalid 5GHz cal pier index, must be less than %d\n"
argument_list|,
name|__func__
argument_list|,
name|OSPREY_NUM_5G_CAL_PIERS
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_cal_pier
operator|=
operator|&
operator|(
name|eep
operator|->
name|cal_freq_pier_5g
index|[
name|ipier
index|]
operator|)
expr_stmt|;
name|p_cal_pier_struct
operator|=
operator|&
operator|(
name|eep
operator|->
name|cal_pier_data_5g
index|[
name|ichain
index|]
index|[
name|ipier
index|]
operator|)
expr_stmt|;
name|is_2ghz
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ipier
operator|>=
name|OSPREY_NUM_2G_CAL_PIERS
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: Invalid 2GHz cal pier index, must be less than %d\n"
argument_list|,
name|__func__
argument_list|,
name|OSPREY_NUM_2G_CAL_PIERS
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_cal_pier
operator|=
operator|&
operator|(
name|eep
operator|->
name|cal_freq_pier_2g
index|[
name|ipier
index|]
operator|)
expr_stmt|;
name|p_cal_pier_struct
operator|=
operator|&
operator|(
name|eep
operator|->
name|cal_pier_data_2g
index|[
name|ichain
index|]
index|[
name|ipier
index|]
operator|)
expr_stmt|;
name|is_2ghz
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|pfrequency
operator|=
name|FBIN2FREQ
argument_list|(
operator|*
name|p_cal_pier
argument_list|,
name|is_2ghz
argument_list|)
expr_stmt|;
operator|*
name|pcorrection
operator|=
name|p_cal_pier_struct
operator|->
name|ref_power
expr_stmt|;
operator|*
name|ptemperature
operator|=
name|p_cal_pier_struct
operator|->
name|temp_meas
expr_stmt|;
operator|*
name|pvoltage
operator|=
name|p_cal_pier_struct
operator|->
name|volt_meas
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Apply the recorded correction values.  */
end_comment

begin_function
specifier|static
name|int
name|ar9300_calibration_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|frequency
parameter_list|)
block|{
name|int
name|ichain
decl_stmt|,
name|ipier
decl_stmt|,
name|npier
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|fdiff
decl_stmt|;
name|int
name|pfrequency
decl_stmt|,
name|pcorrection
decl_stmt|,
name|ptemperature
decl_stmt|,
name|pvoltage
decl_stmt|;
name|int
name|bf
decl_stmt|,
name|factor
decl_stmt|,
name|plus
decl_stmt|;
name|int
name|lfrequency
index|[
name|AR9300_MAX_CHAINS
index|]
decl_stmt|;
name|int
name|hfrequency
index|[
name|AR9300_MAX_CHAINS
index|]
decl_stmt|;
name|int
name|lcorrection
index|[
name|AR9300_MAX_CHAINS
index|]
decl_stmt|;
name|int
name|hcorrection
index|[
name|AR9300_MAX_CHAINS
index|]
decl_stmt|;
name|int
name|correction
index|[
name|AR9300_MAX_CHAINS
index|]
decl_stmt|;
name|int
name|ltemperature
index|[
name|AR9300_MAX_CHAINS
index|]
decl_stmt|;
name|int
name|htemperature
index|[
name|AR9300_MAX_CHAINS
index|]
decl_stmt|;
name|int
name|temperature
index|[
name|AR9300_MAX_CHAINS
index|]
decl_stmt|;
name|int
name|lvoltage
index|[
name|AR9300_MAX_CHAINS
index|]
decl_stmt|;
name|int
name|hvoltage
index|[
name|AR9300_MAX_CHAINS
index|]
decl_stmt|;
name|int
name|voltage
index|[
name|AR9300_MAX_CHAINS
index|]
decl_stmt|;
name|mode
operator|=
operator|(
name|frequency
operator|>=
literal|4000
operator|)
expr_stmt|;
name|npier
operator|=
operator|(
name|mode
operator|)
condition|?
name|OSPREY_NUM_5G_CAL_PIERS
else|:
name|OSPREY_NUM_2G_CAL_PIERS
expr_stmt|;
for|for
control|(
name|ichain
operator|=
literal|0
init|;
name|ichain
operator|<
name|AR9300_MAX_CHAINS
condition|;
name|ichain
operator|++
control|)
block|{
name|lfrequency
index|[
name|ichain
index|]
operator|=
literal|0
expr_stmt|;
name|hfrequency
index|[
name|ichain
index|]
operator|=
literal|100000
expr_stmt|;
block|}
comment|/*      * identify best lower and higher frequency calibration measurement      */
for|for
control|(
name|ichain
operator|=
literal|0
init|;
name|ichain
operator|<
name|AR9300_MAX_CHAINS
condition|;
name|ichain
operator|++
control|)
block|{
for|for
control|(
name|ipier
operator|=
literal|0
init|;
name|ipier
operator|<
name|npier
condition|;
name|ipier
operator|++
control|)
block|{
if|if
condition|(
name|ar9300_eeprom_cal_pier_get
argument_list|(
name|ah
argument_list|,
name|mode
argument_list|,
name|ipier
argument_list|,
name|ichain
argument_list|,
operator|&
name|pfrequency
argument_list|,
operator|&
name|pcorrection
argument_list|,
operator|&
name|ptemperature
argument_list|,
operator|&
name|pvoltage
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fdiff
operator|=
name|frequency
operator|-
name|pfrequency
expr_stmt|;
comment|/*                  * this measurement is higher than our desired frequency                  */
if|if
condition|(
name|fdiff
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|hfrequency
index|[
name|ichain
index|]
operator|<=
literal|0
operator|||
name|hfrequency
index|[
name|ichain
index|]
operator|>=
literal|100000
operator|||
name|fdiff
operator|>
operator|(
name|frequency
operator|-
name|hfrequency
index|[
name|ichain
index|]
operator|)
condition|)
block|{
comment|/*                          * new best higher frequency measurement                          */
name|hfrequency
index|[
name|ichain
index|]
operator|=
name|pfrequency
expr_stmt|;
name|hcorrection
index|[
name|ichain
index|]
operator|=
name|pcorrection
expr_stmt|;
name|htemperature
index|[
name|ichain
index|]
operator|=
name|ptemperature
expr_stmt|;
name|hvoltage
index|[
name|ichain
index|]
operator|=
name|pvoltage
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fdiff
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|lfrequency
index|[
name|ichain
index|]
operator|<=
literal|0
operator|||
name|fdiff
operator|<
operator|(
name|frequency
operator|-
name|lfrequency
index|[
name|ichain
index|]
operator|)
condition|)
block|{
comment|/*                          * new best lower frequency measurement                          */
name|lfrequency
index|[
name|ichain
index|]
operator|=
name|pfrequency
expr_stmt|;
name|lcorrection
index|[
name|ichain
index|]
operator|=
name|pcorrection
expr_stmt|;
name|ltemperature
index|[
name|ichain
index|]
operator|=
name|ptemperature
expr_stmt|;
name|lvoltage
index|[
name|ichain
index|]
operator|=
name|pvoltage
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* interpolate */
for|for
control|(
name|ichain
operator|=
literal|0
init|;
name|ichain
operator|<
name|AR9300_MAX_CHAINS
condition|;
name|ichain
operator|++
control|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: ch=%d f=%d low=%d %d h=%d %d\n"
argument_list|,
name|__func__
argument_list|,
name|ichain
argument_list|,
name|frequency
argument_list|,
name|lfrequency
index|[
name|ichain
index|]
argument_list|,
name|lcorrection
index|[
name|ichain
index|]
argument_list|,
name|hfrequency
index|[
name|ichain
index|]
argument_list|,
name|hcorrection
index|[
name|ichain
index|]
argument_list|)
expr_stmt|;
comment|/*          * they're the same, so just pick one          */
if|if
condition|(
name|hfrequency
index|[
name|ichain
index|]
operator|==
name|lfrequency
index|[
name|ichain
index|]
condition|)
block|{
name|correction
index|[
name|ichain
index|]
operator|=
name|lcorrection
index|[
name|ichain
index|]
expr_stmt|;
name|voltage
index|[
name|ichain
index|]
operator|=
name|lvoltage
index|[
name|ichain
index|]
expr_stmt|;
name|temperature
index|[
name|ichain
index|]
operator|=
name|ltemperature
index|[
name|ichain
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frequency
operator|-
name|lfrequency
index|[
name|ichain
index|]
operator|<
literal|1000
condition|)
block|{
comment|/* the low frequency is good */
if|if
condition|(
name|hfrequency
index|[
name|ichain
index|]
operator|-
name|frequency
operator|<
literal|1000
condition|)
block|{
comment|/*                  * The high frequency is good too -                  * interpolate with round off.                  */
name|int
name|mult
decl_stmt|,
name|div
decl_stmt|,
name|diff
decl_stmt|;
name|mult
operator|=
name|frequency
operator|-
name|lfrequency
index|[
name|ichain
index|]
expr_stmt|;
name|div
operator|=
name|hfrequency
index|[
name|ichain
index|]
operator|-
name|lfrequency
index|[
name|ichain
index|]
expr_stmt|;
name|diff
operator|=
name|hcorrection
index|[
name|ichain
index|]
operator|-
name|lcorrection
index|[
name|ichain
index|]
expr_stmt|;
name|bf
operator|=
literal|2
operator|*
name|diff
operator|*
name|mult
operator|/
name|div
expr_stmt|;
name|plus
operator|=
operator|(
name|bf
operator|%
literal|2
operator|)
expr_stmt|;
name|factor
operator|=
name|bf
operator|/
literal|2
expr_stmt|;
name|correction
index|[
name|ichain
index|]
operator|=
name|lcorrection
index|[
name|ichain
index|]
operator|+
name|factor
operator|+
name|plus
expr_stmt|;
name|diff
operator|=
name|htemperature
index|[
name|ichain
index|]
operator|-
name|ltemperature
index|[
name|ichain
index|]
expr_stmt|;
name|bf
operator|=
literal|2
operator|*
name|diff
operator|*
name|mult
operator|/
name|div
expr_stmt|;
name|plus
operator|=
operator|(
name|bf
operator|%
literal|2
operator|)
expr_stmt|;
name|factor
operator|=
name|bf
operator|/
literal|2
expr_stmt|;
name|temperature
index|[
name|ichain
index|]
operator|=
name|ltemperature
index|[
name|ichain
index|]
operator|+
name|factor
operator|+
name|plus
expr_stmt|;
name|diff
operator|=
name|hvoltage
index|[
name|ichain
index|]
operator|-
name|lvoltage
index|[
name|ichain
index|]
expr_stmt|;
name|bf
operator|=
literal|2
operator|*
name|diff
operator|*
name|mult
operator|/
name|div
expr_stmt|;
name|plus
operator|=
operator|(
name|bf
operator|%
literal|2
operator|)
expr_stmt|;
name|factor
operator|=
name|bf
operator|/
literal|2
expr_stmt|;
name|voltage
index|[
name|ichain
index|]
operator|=
name|lvoltage
index|[
name|ichain
index|]
operator|+
name|factor
operator|+
name|plus
expr_stmt|;
block|}
else|else
block|{
comment|/* only low is good, use it */
name|correction
index|[
name|ichain
index|]
operator|=
name|lcorrection
index|[
name|ichain
index|]
expr_stmt|;
name|temperature
index|[
name|ichain
index|]
operator|=
name|ltemperature
index|[
name|ichain
index|]
expr_stmt|;
name|voltage
index|[
name|ichain
index|]
operator|=
name|lvoltage
index|[
name|ichain
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hfrequency
index|[
name|ichain
index|]
operator|-
name|frequency
operator|<
literal|1000
condition|)
block|{
comment|/* only high is good, use it */
name|correction
index|[
name|ichain
index|]
operator|=
name|hcorrection
index|[
name|ichain
index|]
expr_stmt|;
name|temperature
index|[
name|ichain
index|]
operator|=
name|htemperature
index|[
name|ichain
index|]
expr_stmt|;
name|voltage
index|[
name|ichain
index|]
operator|=
name|hvoltage
index|[
name|ichain
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* nothing is good, presume 0???? */
name|correction
index|[
name|ichain
index|]
operator|=
literal|0
expr_stmt|;
name|temperature
index|[
name|ichain
index|]
operator|=
literal|0
expr_stmt|;
name|voltage
index|[
name|ichain
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* GreenTx */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_sta_update_tx_pwr_enable
condition|)
block|{
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Get calibrated OLPC gain delta value for GreenTx */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_db2
index|[
name|POSEIDON_STORED_REG_G2_OLPC_OFFSET
index|]
operator|=
operator|(
name|u_int32_t
operator|)
name|correction
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
name|ar9300_power_control_override
argument_list|(
name|ah
argument_list|,
name|frequency
argument_list|,
name|correction
argument_list|,
name|voltage
argument_list|,
name|temperature
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: for frequency=%d, calibration correction = %d %d %d\n"
argument_list|,
name|__func__
argument_list|,
name|frequency
argument_list|,
name|correction
index|[
literal|0
index|]
argument_list|,
name|correction
index|[
literal|1
index|]
argument_list|,
name|correction
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ar9300_power_control_override
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|frequency
parameter_list|,
name|int
modifier|*
name|correction
parameter_list|,
name|int
modifier|*
name|voltage
parameter_list|,
name|int
modifier|*
name|temperature
parameter_list|)
block|{
name|int
name|temp_slope
init|=
literal|0
decl_stmt|;
name|int
name|temp_slope_1
init|=
literal|0
decl_stmt|;
name|int
name|temp_slope_2
init|=
literal|0
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|int32_t
name|f
index|[
literal|8
index|]
decl_stmt|,
name|t
index|[
literal|8
index|]
decl_stmt|,
name|t1
index|[
literal|3
index|]
decl_stmt|,
name|t2
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPC_11_B0
argument_list|,
operator|(
name|correction
index|[
literal|0
index|]
operator|<<
name|AR_PHY_TPC_OLPC_GAIN_DELTA_S
operator|)
argument_list|,
name|AR_PHY_TPC_OLPC_GAIN_DELTA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPC_11_B1
argument_list|,
operator|(
name|correction
index|[
literal|1
index|]
operator|<<
name|AR_PHY_TPC_OLPC_GAIN_DELTA_S
operator|)
argument_list|,
name|AR_PHY_TPC_OLPC_GAIN_DELTA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPC_11_B2
argument_list|,
operator|(
name|correction
index|[
literal|2
index|]
operator|<<
name|AR_PHY_TPC_OLPC_GAIN_DELTA_S
operator|)
argument_list|,
name|AR_PHY_TPC_OLPC_GAIN_DELTA
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * enable open loop power control on chip      */
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPC_6_B0
argument_list|,
operator|(
literal|3
operator|<<
name|AR_PHY_TPC_6_ERROR_EST_MODE_S
operator|)
argument_list|,
name|AR_PHY_TPC_6_ERROR_EST_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPC_6_B1
argument_list|,
operator|(
literal|3
operator|<<
name|AR_PHY_TPC_6_ERROR_EST_MODE_S
operator|)
argument_list|,
name|AR_PHY_TPC_6_ERROR_EST_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPC_6_B2
argument_list|,
operator|(
literal|3
operator|<<
name|AR_PHY_TPC_6_ERROR_EST_MODE_S
operator|)
argument_list|,
name|AR_PHY_TPC_6_ERROR_EST_MODE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Enable temperature compensation      * Need to use register names      */
if|if
condition|(
name|frequency
operator|<
literal|4000
condition|)
block|{
name|temp_slope
operator|=
name|eep
operator|->
name|modal_header_2g
operator|.
name|temp_slope
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|eep
operator|->
name|base_eep_header
operator|.
name|misc_configuration
operator|&
literal|0x20
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|t
index|[
name|i
index|]
operator|=
name|eep
operator|->
name|base_ext1
operator|.
name|tempslopextension
index|[
name|i
index|]
expr_stmt|;
name|f
index|[
name|i
index|]
operator|=
name|FBIN2FREQ
argument_list|(
name|eep
operator|->
name|cal_freq_pier_5g
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|temp_slope
operator|=
name|interpolate
argument_list|(
name|frequency
argument_list|,
name|f
argument_list|,
name|t
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|eep
operator|->
name|base_ext2
operator|.
name|temp_slope_low
operator|!=
literal|0
condition|)
block|{
name|t
index|[
literal|0
index|]
operator|=
name|eep
operator|->
name|base_ext2
operator|.
name|temp_slope_low
expr_stmt|;
name|f
index|[
literal|0
index|]
operator|=
literal|5180
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
name|eep
operator|->
name|modal_header_5g
operator|.
name|temp_slope
expr_stmt|;
name|f
index|[
literal|1
index|]
operator|=
literal|5500
expr_stmt|;
name|t
index|[
literal|2
index|]
operator|=
name|eep
operator|->
name|base_ext2
operator|.
name|temp_slope_high
expr_stmt|;
name|f
index|[
literal|2
index|]
operator|=
literal|5785
expr_stmt|;
name|temp_slope
operator|=
name|interpolate
argument_list|(
name|frequency
argument_list|,
name|f
argument_list|,
name|t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp_slope
operator|=
name|eep
operator|->
name|modal_header_5g
operator|.
name|temp_slope
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*              * Scorpion has individual chain tempslope values              */
name|t
index|[
literal|0
index|]
operator|=
name|eep
operator|->
name|base_ext1
operator|.
name|tempslopextension
index|[
literal|2
index|]
expr_stmt|;
name|t1
index|[
literal|0
index|]
operator|=
name|eep
operator|->
name|base_ext1
operator|.
name|tempslopextension
index|[
literal|3
index|]
expr_stmt|;
name|t2
index|[
literal|0
index|]
operator|=
name|eep
operator|->
name|base_ext1
operator|.
name|tempslopextension
index|[
literal|4
index|]
expr_stmt|;
name|f
index|[
literal|0
index|]
operator|=
literal|5180
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
name|eep
operator|->
name|modal_header_5g
operator|.
name|temp_slope
expr_stmt|;
name|t1
index|[
literal|1
index|]
operator|=
name|eep
operator|->
name|base_ext1
operator|.
name|tempslopextension
index|[
literal|0
index|]
expr_stmt|;
name|t2
index|[
literal|1
index|]
operator|=
name|eep
operator|->
name|base_ext1
operator|.
name|tempslopextension
index|[
literal|1
index|]
expr_stmt|;
name|f
index|[
literal|1
index|]
operator|=
literal|5500
expr_stmt|;
name|t
index|[
literal|2
index|]
operator|=
name|eep
operator|->
name|base_ext1
operator|.
name|tempslopextension
index|[
literal|5
index|]
expr_stmt|;
name|t1
index|[
literal|2
index|]
operator|=
name|eep
operator|->
name|base_ext1
operator|.
name|tempslopextension
index|[
literal|6
index|]
expr_stmt|;
name|t2
index|[
literal|2
index|]
operator|=
name|eep
operator|->
name|base_ext1
operator|.
name|tempslopextension
index|[
literal|7
index|]
expr_stmt|;
name|f
index|[
literal|2
index|]
operator|=
literal|5785
expr_stmt|;
name|temp_slope
operator|=
name|interpolate
argument_list|(
name|frequency
argument_list|,
name|f
argument_list|,
name|t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|temp_slope_1
operator|=
name|interpolate
argument_list|(
name|frequency
argument_list|,
name|f
argument_list|,
name|t1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|temp_slope_2
operator|=
name|interpolate
argument_list|(
name|frequency
argument_list|,
name|f
argument_list|,
name|t2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPC_19
argument_list|,
name|AR_PHY_TPC_19_ALPHA_THERM
argument_list|,
name|temp_slope
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*Scorpion has tempSlope register for each chain*/
comment|/*Check whether temp_compensation feature is enabled or not*/
if|if
condition|(
name|eep
operator|->
name|base_eep_header
operator|.
name|feature_enable
operator|&
literal|0x1
condition|)
block|{
if|if
condition|(
name|frequency
operator|<
literal|4000
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPC_19
argument_list|,
name|AR_PHY_TPC_19_ALPHA_THERM
argument_list|,
name|eep
operator|->
name|base_ext2
operator|.
name|temp_slope_low
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_SCORPION_PHY_TPC_19_B1
argument_list|,
name|AR_PHY_TPC_19_ALPHA_THERM
argument_list|,
name|temp_slope
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_SCORPION_PHY_TPC_19_B2
argument_list|,
name|AR_PHY_TPC_19_ALPHA_THERM
argument_list|,
name|eep
operator|->
name|base_ext2
operator|.
name|temp_slope_high
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPC_19
argument_list|,
name|AR_PHY_TPC_19_ALPHA_THERM
argument_list|,
name|temp_slope
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_SCORPION_PHY_TPC_19_B1
argument_list|,
name|AR_PHY_TPC_19_ALPHA_THERM
argument_list|,
name|temp_slope_1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_SCORPION_PHY_TPC_19_B2
argument_list|,
name|AR_PHY_TPC_19_ALPHA_THERM
argument_list|,
name|temp_slope_2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If temp compensation is not enabled, set all registers to 0*/
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPC_19
argument_list|,
name|AR_PHY_TPC_19_ALPHA_THERM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_SCORPION_PHY_TPC_19_B1
argument_list|,
name|AR_PHY_TPC_19_ALPHA_THERM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_SCORPION_PHY_TPC_19_B2
argument_list|,
name|AR_PHY_TPC_19_ALPHA_THERM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPC_18
argument_list|,
name|AR_PHY_TPC_18_THERM_CAL_VALUE
argument_list|,
name|temperature
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  * ar9300_eep_def_get_max_edge_power  *  * Find the maximum conformance test limit for the given channel and CTL info  */
end_comment

begin_function
specifier|static
specifier|inline
name|u_int16_t
name|ar9300_eep_def_get_max_edge_power
parameter_list|(
name|ar9300_eeprom_t
modifier|*
name|p_eep_data
parameter_list|,
name|u_int16_t
name|freq
parameter_list|,
name|int
name|idx
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
name|u_int16_t
name|twice_max_edge_power
init|=
name|AR9300_MAX_RATE_POWER
decl_stmt|;
name|u_int8_t
modifier|*
name|ctl_freqbin
init|=
name|is_2ghz
condition|?
operator|&
name|p_eep_data
operator|->
name|ctl_freqbin_2G
index|[
name|idx
index|]
index|[
literal|0
index|]
else|:
operator|&
name|p_eep_data
operator|->
name|ctl_freqbin_5G
index|[
name|idx
index|]
index|[
literal|0
index|]
decl_stmt|;
name|u_int16_t
name|num_edges
init|=
name|is_2ghz
condition|?
name|OSPREY_NUM_BAND_EDGES_2G
else|:
name|OSPREY_NUM_BAND_EDGES_5G
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get the edge power */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|num_edges
operator|)
operator|&&
operator|(
name|ctl_freqbin
index|[
name|i
index|]
operator|!=
name|AR9300_BCHAN_UNUSED
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/*          * If there's an exact channel match or an inband flag set          * on the lower channel use the given rd_edge_power          */
if|if
condition|(
name|freq
operator|==
name|fbin2freq
argument_list|(
name|ctl_freqbin
index|[
name|i
index|]
argument_list|,
name|is_2ghz
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_2ghz
condition|)
block|{
name|twice_max_edge_power
operator|=
name|p_eep_data
operator|->
name|ctl_power_data_2g
index|[
name|idx
index|]
operator|.
name|ctl_edges
index|[
name|i
index|]
operator|.
name|t_power
expr_stmt|;
block|}
else|else
block|{
name|twice_max_edge_power
operator|=
name|p_eep_data
operator|->
name|ctl_power_data_5g
index|[
name|idx
index|]
operator|.
name|ctl_edges
index|[
name|i
index|]
operator|.
name|t_power
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|freq
operator|<
name|fbin2freq
argument_list|(
name|ctl_freqbin
index|[
name|i
index|]
argument_list|,
name|is_2ghz
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|is_2ghz
condition|)
block|{
if|if
condition|(
name|fbin2freq
argument_list|(
name|ctl_freqbin
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|1
argument_list|)
operator|<
name|freq
operator|&&
name|p_eep_data
operator|->
name|ctl_power_data_2g
index|[
name|idx
index|]
operator|.
name|ctl_edges
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|flag
condition|)
block|{
name|twice_max_edge_power
operator|=
name|p_eep_data
operator|->
name|ctl_power_data_2g
index|[
name|idx
index|]
operator|.
name|ctl_edges
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|t_power
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fbin2freq
argument_list|(
name|ctl_freqbin
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
name|freq
operator|&&
name|p_eep_data
operator|->
name|ctl_power_data_5g
index|[
name|idx
index|]
operator|.
name|ctl_edges
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|flag
condition|)
block|{
name|twice_max_edge_power
operator|=
name|p_eep_data
operator|->
name|ctl_power_data_5g
index|[
name|idx
index|]
operator|.
name|ctl_edges
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|t_power
expr_stmt|;
block|}
block|}
comment|/*              * Leave loop - no more affecting edges possible              * in this monotonic increasing list              */
break|break;
block|}
block|}
comment|/*      * EV89475: EEPROM might contain 0 txpower in CTL table for certain      * 2.4GHz channels. We workaround it by overwriting 60 (30 dBm) here.      */
if|if
condition|(
name|is_2ghz
operator|&&
operator|(
name|twice_max_edge_power
operator|==
literal|0
operator|)
condition|)
block|{
name|twice_max_edge_power
operator|=
literal|60
expr_stmt|;
block|}
name|HALASSERT
argument_list|(
name|twice_max_edge_power
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
name|twice_max_edge_power
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_eeprom_set_power_per_rate_table
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|ar9300_eeprom_t
modifier|*
name|p_eep_data
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|,
name|u_int8_t
modifier|*
name|p_pwr_array
parameter_list|,
name|u_int16_t
name|cfg_ctl
parameter_list|,
name|u_int16_t
name|antenna_reduction
parameter_list|,
name|u_int16_t
name|twice_max_regulatory_power
parameter_list|,
name|u_int16_t
name|power_limit
parameter_list|,
name|u_int8_t
name|chainmask
parameter_list|)
block|{
comment|/* Local defines to distinguish between extension and control CTL's */
define|#
directive|define
name|EXT_ADDITIVE
value|(0x8000)
define|#
directive|define
name|CTL_11A_EXT
value|(CTL_11A | EXT_ADDITIVE)
define|#
directive|define
name|CTL_11G_EXT
value|(CTL_11G | EXT_ADDITIVE)
define|#
directive|define
name|CTL_11B_EXT
value|(CTL_11B | EXT_ADDITIVE)
define|#
directive|define
name|REDUCE_SCALED_POWER_BY_TWO_CHAIN
value|6
comment|/* 10*log10(2)*2 */
define|#
directive|define
name|REDUCE_SCALED_POWER_BY_THREE_CHAIN
value|10
comment|/* 10*log10(3)*2 */
define|#
directive|define
name|PWRINCR_3_TO_1_CHAIN
value|9
comment|/* 10*log(3)*2 */
define|#
directive|define
name|PWRINCR_3_TO_2_CHAIN
value|3
comment|/* floor(10*log(3/2)*2) */
define|#
directive|define
name|PWRINCR_2_TO_1_CHAIN
value|6
comment|/* 10*log(2)*2 */
specifier|static
specifier|const
name|u_int16_t
name|tp_scale_reduction_table
index|[
literal|5
index|]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|6
block|,
literal|9
block|,
name|AR9300_MAX_RATE_POWER
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int16_t
name|twice_largest_antenna
decl_stmt|;
name|u_int16_t
name|twice_antenna_reduction
init|=
literal|2
operator|*
name|antenna_reduction
decl_stmt|;
name|int16_t
name|scaled_power
init|=
literal|0
decl_stmt|,
name|min_ctl_power
decl_stmt|,
name|max_reg_allowed_power
decl_stmt|;
define|#
directive|define
name|SUB_NUM_CTL_MODES_AT_5G_40
value|2
comment|/* excluding HT40, EXT-OFDM */
define|#
directive|define
name|SUB_NUM_CTL_MODES_AT_2G_40
value|3
comment|/* excluding HT40, EXT-OFDM, EXT-CCK */
name|u_int16_t
name|ctl_modes_for11a
index|[]
init|=
block|{
name|CTL_11A
block|,
name|CTL_5GHT20
block|,
name|CTL_11A_EXT
block|,
name|CTL_5GHT40
block|}
decl_stmt|;
name|u_int16_t
name|ctl_modes_for11g
index|[]
init|=
block|{
name|CTL_11B
block|,
name|CTL_11G
block|,
name|CTL_2GHT20
block|,
name|CTL_11B_EXT
block|,
name|CTL_11G_EXT
block|,
name|CTL_2GHT40
block|}
decl_stmt|;
name|u_int16_t
name|num_ctl_modes
decl_stmt|,
modifier|*
name|p_ctl_mode
decl_stmt|,
name|ctl_mode
decl_stmt|,
name|freq
decl_stmt|;
name|CHAN_CENTERS
name|centers
decl_stmt|;
name|int
name|tx_chainmask
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|u_int8_t
modifier|*
name|ctl_index
decl_stmt|;
name|u_int8_t
name|ctl_num
decl_stmt|;
name|u_int16_t
name|twice_min_edge_power
decl_stmt|;
name|u_int16_t
name|twice_max_edge_power
init|=
name|AR9300_MAX_RATE_POWER
decl_stmt|;
name|tx_chainmask
operator|=
name|chainmask
condition|?
name|chainmask
else|:
name|ahp
operator|->
name|ah_tx_chainmask
expr_stmt|;
name|ar9300_get_channel_centers
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|centers
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ahp
operator|->
name|twice_antenna_gain
operator|=
name|p_eep_data
operator|->
name|modal_header_2g
operator|.
name|antenna_gain
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|twice_antenna_gain
operator|=
name|p_eep_data
operator|->
name|modal_header_5g
operator|.
name|antenna_gain
expr_stmt|;
block|}
comment|/* Save max allowed antenna gain to ease future lookups */
name|ahp
operator|->
name|twice_antenna_reduction
operator|=
name|twice_antenna_reduction
expr_stmt|;
comment|/*  Deduct antenna gain from  EIRP to get the upper limit */
name|twice_largest_antenna
operator|=
operator|(
name|int16_t
operator|)
name|AH_MIN
argument_list|(
operator|(
name|twice_antenna_reduction
operator|-
name|ahp
operator|->
name|twice_antenna_gain
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|max_reg_allowed_power
operator|=
name|twice_max_regulatory_power
operator|+
name|twice_largest_antenna
expr_stmt|;
comment|/* Use ah_tp_scale - see bug 30070. */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tp_scale
operator|!=
name|HAL_TP_SCALE_MAX
condition|)
block|{
name|max_reg_allowed_power
operator|-=
operator|(
name|tp_scale_reduction_table
index|[
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tp_scale
operator|)
index|]
operator|*
literal|2
operator|)
expr_stmt|;
block|}
name|scaled_power
operator|=
name|AH_MIN
argument_list|(
name|power_limit
argument_list|,
name|max_reg_allowed_power
argument_list|)
expr_stmt|;
comment|/*      * Reduce scaled Power by number of chains active to get to      * per chain tx power level      */
comment|/* TODO: better value than these? */
switch|switch
condition|(
name|ar9300_get_ntxchains
argument_list|(
name|tx_chainmask
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|ahp
operator|->
name|upper_limit
index|[
literal|0
index|]
operator|=
name|AH_MAX
argument_list|(
literal|0
argument_list|,
name|scaled_power
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|scaled_power
operator|-=
name|REDUCE_SCALED_POWER_BY_TWO_CHAIN
expr_stmt|;
name|ahp
operator|->
name|upper_limit
index|[
literal|1
index|]
operator|=
name|AH_MAX
argument_list|(
literal|0
argument_list|,
name|scaled_power
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|scaled_power
operator|-=
name|REDUCE_SCALED_POWER_BY_THREE_CHAIN
expr_stmt|;
name|ahp
operator|->
name|upper_limit
index|[
literal|2
index|]
operator|=
name|AH_MAX
argument_list|(
literal|0
argument_list|,
name|scaled_power
argument_list|)
expr_stmt|;
break|break;
default|default:
name|HALASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Unsupported number of chains */
block|}
name|scaled_power
operator|=
name|AH_MAX
argument_list|(
literal|0
argument_list|,
name|scaled_power
argument_list|)
expr_stmt|;
comment|/* Get target powers from EEPROM - our baseline for TX Power */
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* Setup for CTL modes */
comment|/* CTL_11B, CTL_11G, CTL_2GHT20 */
name|num_ctl_modes
operator|=
name|ARRAY_LENGTH
argument_list|(
name|ctl_modes_for11g
argument_list|)
operator|-
name|SUB_NUM_CTL_MODES_AT_2G_40
expr_stmt|;
name|p_ctl_mode
operator|=
name|ctl_modes_for11g
expr_stmt|;
if|if
condition|(
name|IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|num_ctl_modes
operator|=
name|ARRAY_LENGTH
argument_list|(
name|ctl_modes_for11g
argument_list|)
expr_stmt|;
comment|/* All 2G CTL's */
block|}
block|}
else|else
block|{
comment|/* Setup for CTL modes */
comment|/* CTL_11A, CTL_5GHT20 */
name|num_ctl_modes
operator|=
name|ARRAY_LENGTH
argument_list|(
name|ctl_modes_for11a
argument_list|)
operator|-
name|SUB_NUM_CTL_MODES_AT_5G_40
expr_stmt|;
name|p_ctl_mode
operator|=
name|ctl_modes_for11a
expr_stmt|;
if|if
condition|(
name|IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|num_ctl_modes
operator|=
name|ARRAY_LENGTH
argument_list|(
name|ctl_modes_for11a
argument_list|)
expr_stmt|;
comment|/* All 5G CTL's */
block|}
block|}
comment|/*      * For MIMO, need to apply regulatory caps individually across dynamically      * running modes: CCK, OFDM, HT20, HT40      *      * The outer loop walks through each possible applicable runtime mode.      * The inner loop walks through each ctl_index entry in EEPROM.      * The ctl value is encoded as [7:4] == test group, [3:0] == test mode.      *      */
for|for
control|(
name|ctl_mode
operator|=
literal|0
init|;
name|ctl_mode
operator|<
name|num_ctl_modes
condition|;
name|ctl_mode
operator|++
control|)
block|{
name|HAL_BOOL
name|is_ht40_ctl_mode
init|=
operator|(
name|p_ctl_mode
index|[
name|ctl_mode
index|]
operator|==
name|CTL_5GHT40
operator|)
operator|||
operator|(
name|p_ctl_mode
index|[
name|ctl_mode
index|]
operator|==
name|CTL_2GHT40
operator|)
decl_stmt|;
if|if
condition|(
name|is_ht40_ctl_mode
condition|)
block|{
name|freq
operator|=
name|centers
operator|.
name|synth_center
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_ctl_mode
index|[
name|ctl_mode
index|]
operator|&
name|EXT_ADDITIVE
condition|)
block|{
name|freq
operator|=
name|centers
operator|.
name|ext_center
expr_stmt|;
block|}
else|else
block|{
name|freq
operator|=
name|centers
operator|.
name|ctl_center
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_POWER_MGMT
argument_list|,
literal|"LOOP-Mode ctl_mode %d< %d, "
literal|"is_ht40_ctl_mode %d, EXT_ADDITIVE %d\n"
argument_list|,
name|ctl_mode
argument_list|,
name|num_ctl_modes
argument_list|,
name|is_ht40_ctl_mode
argument_list|,
operator|(
name|p_ctl_mode
index|[
name|ctl_mode
index|]
operator|&
name|EXT_ADDITIVE
operator|)
argument_list|)
expr_stmt|;
comment|/* walk through each CTL index stored in EEPROM */
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ctl_index
operator|=
name|p_eep_data
operator|->
name|ctl_index_2g
expr_stmt|;
name|ctl_num
operator|=
name|OSPREY_NUM_CTLS_2G
expr_stmt|;
block|}
else|else
block|{
name|ctl_index
operator|=
name|p_eep_data
operator|->
name|ctl_index_5g
expr_stmt|;
name|ctl_num
operator|=
name|OSPREY_NUM_CTLS_5G
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|ctl_num
operator|)
operator|&&
name|ctl_index
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_POWER_MGMT
argument_list|,
literal|"  LOOP-Ctlidx %d: cfg_ctl 0x%2.2x p_ctl_mode 0x%2.2x "
literal|"ctl_index 0x%2.2x chan %d chanctl 0x%x\n"
argument_list|,
name|i
argument_list|,
name|cfg_ctl
argument_list|,
name|p_ctl_mode
index|[
name|ctl_mode
index|]
argument_list|,
name|ctl_index
index|[
name|i
index|]
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|chan
operator|->
name|conformance_test_limit
argument_list|)
expr_stmt|;
comment|/*               * compare test group from regulatory channel list              * with test mode from p_ctl_mode list              */
if|if
condition|(
operator|(
operator|(
operator|(
name|cfg_ctl
operator|&
operator|~
name|CTL_MODE_M
operator|)
operator||
operator|(
name|p_ctl_mode
index|[
name|ctl_mode
index|]
operator|&
name|CTL_MODE_M
operator|)
operator|)
operator|==
name|ctl_index
index|[
name|i
index|]
operator|)
operator|||
operator|(
operator|(
operator|(
name|cfg_ctl
operator|&
operator|~
name|CTL_MODE_M
operator|)
operator||
operator|(
name|p_ctl_mode
index|[
name|ctl_mode
index|]
operator|&
name|CTL_MODE_M
operator|)
operator|)
operator|==
operator|(
operator|(
name|ctl_index
index|[
name|i
index|]
operator|&
name|CTL_MODE_M
operator|)
operator||
name|SD_NO_CTL
operator|)
operator|)
condition|)
block|{
name|twice_min_edge_power
operator|=
name|ar9300_eep_def_get_max_edge_power
argument_list|(
name|p_eep_data
argument_list|,
name|freq
argument_list|,
name|i
argument_list|,
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_POWER_MGMT
argument_list|,
literal|"    MATCH-EE_IDX %d: ch %d is2 %d "
literal|"2xMinEdge %d chainmask %d chains %d\n"
argument_list|,
name|i
argument_list|,
name|freq
argument_list|,
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|,
name|twice_min_edge_power
argument_list|,
name|tx_chainmask
argument_list|,
name|ar9300_get_ntxchains
argument_list|(
name|tx_chainmask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cfg_ctl
operator|&
operator|~
name|CTL_MODE_M
operator|)
operator|==
name|SD_NO_CTL
condition|)
block|{
comment|/*                      * Find the minimum of all CTL edge powers                      * that apply to this channel                      */
name|twice_max_edge_power
operator|=
name|AH_MIN
argument_list|(
name|twice_max_edge_power
argument_list|,
name|twice_min_edge_power
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* specific */
name|twice_max_edge_power
operator|=
name|twice_min_edge_power
expr_stmt|;
break|break;
block|}
block|}
block|}
name|min_ctl_power
operator|=
operator|(
name|u_int8_t
operator|)
name|AH_MIN
argument_list|(
name|twice_max_edge_power
argument_list|,
name|scaled_power
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_POWER_MGMT
argument_list|,
literal|"    SEL-Min ctl_mode %d p_ctl_mode %d "
literal|"2xMaxEdge %d sP %d min_ctl_pwr %d\n"
argument_list|,
name|ctl_mode
argument_list|,
name|p_ctl_mode
index|[
name|ctl_mode
index|]
argument_list|,
name|twice_max_edge_power
argument_list|,
name|scaled_power
argument_list|,
name|min_ctl_power
argument_list|)
expr_stmt|;
comment|/* Apply ctl mode to correct target power set */
switch|switch
condition|(
name|p_ctl_mode
index|[
name|ctl_mode
index|]
condition|)
block|{
case|case
name|CTL_11B
case|:
for|for
control|(
name|i
operator|=
name|ALL_TARGET_LEGACY_1L_5L
init|;
name|i
operator|<=
name|ALL_TARGET_LEGACY_11S
condition|;
name|i
operator|++
control|)
block|{
name|p_pwr_array
index|[
name|i
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|AH_MIN
argument_list|(
name|p_pwr_array
index|[
name|i
index|]
argument_list|,
name|min_ctl_power
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTL_11A
case|:
case|case
name|CTL_11G
case|:
for|for
control|(
name|i
operator|=
name|ALL_TARGET_LEGACY_6_24
init|;
name|i
operator|<=
name|ALL_TARGET_LEGACY_54
condition|;
name|i
operator|++
control|)
block|{
name|p_pwr_array
index|[
name|i
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|AH_MIN
argument_list|(
name|p_pwr_array
index|[
name|i
index|]
argument_list|,
name|min_ctl_power
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_BT_COEX
if|if
condition|(
operator|(
name|ahp
operator|->
name|ah_bt_coex_config_type
operator|==
name|HAL_BT_COEX_CFG_3WIRE
operator|)
operator|||
operator|(
name|ahp
operator|->
name|ah_bt_coex_config_type
operator|==
name|HAL_BT_COEX_CFG_MCI
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ahp
operator|->
name|ah_bt_coex_flag
operator|&
name|HAL_BT_COEX_FLAG_LOWER_TX_PWR
operator|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_bt_wlan_isolation
operator|<
name|HAL_BT_COEX_ISOLATION_FOR_NO_COEX
operator|)
condition|)
block|{
name|u_int8_t
name|reduce_pow
decl_stmt|;
name|reduce_pow
operator|=
operator|(
name|HAL_BT_COEX_ISOLATION_FOR_NO_COEX
operator|-
name|ahp
operator|->
name|ah_bt_wlan_isolation
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|reduce_pow
operator|<=
name|p_pwr_array
index|[
name|i
index|]
condition|)
block|{
name|p_pwr_array
index|[
name|i
index|]
operator|-=
name|reduce_pow
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|ahp
operator|->
name|ah_bt_coex_flag
operator|&
name|HAL_BT_COEX_FLAG_LOW_ACK_PWR
operator|)
operator|&&
operator|(
name|i
operator|!=
name|ALL_TARGET_LEGACY_36
operator|)
operator|&&
operator|(
name|i
operator|!=
name|ALL_TARGET_LEGACY_48
operator|)
operator|&&
operator|(
name|i
operator|!=
name|ALL_TARGET_LEGACY_54
operator|)
operator|&&
operator|(
name|p_ctl_mode
index|[
name|ctl_mode
index|]
operator|==
name|CTL_11G
operator|)
condition|)
block|{
name|p_pwr_array
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
break|break;
case|case
name|CTL_5GHT20
case|:
case|case
name|CTL_2GHT20
case|:
for|for
control|(
name|i
operator|=
name|ALL_TARGET_HT20_0_8_16
init|;
name|i
operator|<=
name|ALL_TARGET_HT20_23
condition|;
name|i
operator|++
control|)
block|{
name|p_pwr_array
index|[
name|i
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|AH_MIN
argument_list|(
name|p_pwr_array
index|[
name|i
index|]
argument_list|,
name|min_ctl_power
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_BT_COEX
if|if
condition|(
operator|(
operator|(
name|ahp
operator|->
name|ah_bt_coex_config_type
operator|==
name|HAL_BT_COEX_CFG_3WIRE
operator|)
operator|||
operator|(
name|ahp
operator|->
name|ah_bt_coex_config_type
operator|==
name|HAL_BT_COEX_CFG_MCI
operator|)
operator|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_bt_coex_flag
operator|&
name|HAL_BT_COEX_FLAG_LOWER_TX_PWR
operator|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_bt_wlan_isolation
operator|<
name|HAL_BT_COEX_ISOLATION_FOR_NO_COEX
operator|)
condition|)
block|{
name|u_int8_t
name|reduce_pow
init|=
operator|(
name|HAL_BT_COEX_ISOLATION_FOR_NO_COEX
operator|-
name|ahp
operator|->
name|ah_bt_wlan_isolation
operator|)
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|reduce_pow
operator|<=
name|p_pwr_array
index|[
name|i
index|]
condition|)
block|{
name|p_pwr_array
index|[
name|i
index|]
operator|-=
name|reduce_pow
expr_stmt|;
block|}
block|}
if|#
directive|if
name|ATH_SUPPORT_MCI
elseif|else
if|if
condition|(
operator|(
name|ahp
operator|->
name|ah_bt_coex_flag
operator|&
name|HAL_BT_COEX_FLAG_MCI_MAX_TX_PWR
operator|)
operator|&&
operator|(
name|p_ctl_mode
index|[
name|ctl_mode
index|]
operator|==
name|CTL_2GHT20
operator|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_bt_coex_config_type
operator|==
name|HAL_BT_COEX_CFG_MCI
operator|)
condition|)
block|{
name|u_int8_t
name|max_pwr
decl_stmt|;
name|max_pwr
operator|=
name|MS
argument_list|(
name|mci_concur_tx_max_pwr
index|[
literal|2
index|]
index|[
literal|1
index|]
argument_list|,
name|ATH_MCI_CONCUR_TX_LOWEST_PWR_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pwr_array
index|[
name|i
index|]
operator|>
name|max_pwr
condition|)
block|{
name|p_pwr_array
index|[
name|i
index|]
operator|=
name|max_pwr
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
block|}
break|break;
case|case
name|CTL_11B_EXT
case|:
ifdef|#
directive|ifdef
name|NOT_YET
name|target_power_cck_ext
operator|.
name|t_pow2x
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|AH_MIN
argument_list|(
name|target_power_cck_ext
operator|.
name|t_pow2x
index|[
literal|0
index|]
argument_list|,
name|min_ctl_power
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOT_YET */
break|break;
case|case
name|CTL_11A_EXT
case|:
case|case
name|CTL_11G_EXT
case|:
ifdef|#
directive|ifdef
name|NOT_YET
name|target_power_ofdm_ext
operator|.
name|t_pow2x
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|AH_MIN
argument_list|(
name|target_power_ofdm_ext
operator|.
name|t_pow2x
index|[
literal|0
index|]
argument_list|,
name|min_ctl_power
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOT_YET */
break|break;
case|case
name|CTL_5GHT40
case|:
case|case
name|CTL_2GHT40
case|:
for|for
control|(
name|i
operator|=
name|ALL_TARGET_HT40_0_8_16
init|;
name|i
operator|<=
name|ALL_TARGET_HT40_23
condition|;
name|i
operator|++
control|)
block|{
name|p_pwr_array
index|[
name|i
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|AH_MIN
argument_list|(
name|p_pwr_array
index|[
name|i
index|]
argument_list|,
name|min_ctl_power
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_BT_COEX
if|if
condition|(
operator|(
operator|(
name|ahp
operator|->
name|ah_bt_coex_config_type
operator|==
name|HAL_BT_COEX_CFG_3WIRE
operator|)
operator|||
operator|(
name|ahp
operator|->
name|ah_bt_coex_config_type
operator|==
name|HAL_BT_COEX_CFG_MCI
operator|)
operator|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_bt_coex_flag
operator|&
name|HAL_BT_COEX_FLAG_LOWER_TX_PWR
operator|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_bt_wlan_isolation
operator|<
name|HAL_BT_COEX_ISOLATION_FOR_NO_COEX
operator|)
condition|)
block|{
name|u_int8_t
name|reduce_pow
init|=
operator|(
name|HAL_BT_COEX_ISOLATION_FOR_NO_COEX
operator|-
name|ahp
operator|->
name|ah_bt_wlan_isolation
operator|)
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|reduce_pow
operator|<=
name|p_pwr_array
index|[
name|i
index|]
condition|)
block|{
name|p_pwr_array
index|[
name|i
index|]
operator|-=
name|reduce_pow
expr_stmt|;
block|}
block|}
if|#
directive|if
name|ATH_SUPPORT_MCI
elseif|else
if|if
condition|(
operator|(
name|ahp
operator|->
name|ah_bt_coex_flag
operator|&
name|HAL_BT_COEX_FLAG_MCI_MAX_TX_PWR
operator|)
operator|&&
operator|(
name|p_ctl_mode
index|[
name|ctl_mode
index|]
operator|==
name|CTL_2GHT40
operator|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_bt_coex_config_type
operator|==
name|HAL_BT_COEX_CFG_MCI
operator|)
condition|)
block|{
name|u_int8_t
name|max_pwr
decl_stmt|;
name|max_pwr
operator|=
name|MS
argument_list|(
name|mci_concur_tx_max_pwr
index|[
literal|3
index|]
index|[
literal|1
index|]
argument_list|,
name|ATH_MCI_CONCUR_TX_LOWEST_PWR_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pwr_array
index|[
name|i
index|]
operator|>
name|max_pwr
condition|)
block|{
name|p_pwr_array
index|[
name|i
index|]
operator|=
name|max_pwr
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
block|}
break|break;
default|default:
name|HALASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* end ctl mode checking */
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|EXT_ADDITIVE
undef|#
directive|undef
name|CTL_11A_EXT
undef|#
directive|undef
name|CTL_11G_EXT
undef|#
directive|undef
name|CTL_11B_EXT
undef|#
directive|undef
name|REDUCE_SCALED_POWER_BY_TWO_CHAIN
undef|#
directive|undef
name|REDUCE_SCALED_POWER_BY_THREE_CHAIN
block|}
end_function

begin_comment
comment|/**************************************************************  * ar9300_eeprom_set_transmit_power  *  * Set the transmit power in the baseband for the given  * operating channel and mode.  */
end_comment

begin_function
name|HAL_STATUS
name|ar9300_eeprom_set_transmit_power
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|ar9300_eeprom_t
modifier|*
name|p_eep_data
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|,
name|u_int16_t
name|cfg_ctl
parameter_list|,
name|u_int16_t
name|antenna_reduction
parameter_list|,
name|u_int16_t
name|twice_max_regulatory_power
parameter_list|,
name|u_int16_t
name|power_limit
parameter_list|)
block|{
define|#
directive|define
name|ABS
parameter_list|(
name|_x
parameter_list|,
name|_y
parameter_list|)
value|((int)_x> (int)_y ? (int)_x - (int)_y : (int)_y - (int)_x)
define|#
directive|define
name|INCREASE_MAXPOW_BY_TWO_CHAIN
value|6
comment|/* 10*log10(2)*2 */
define|#
directive|define
name|INCREASE_MAXPOW_BY_THREE_CHAIN
value|10
comment|/* 10*log10(3)*2 */
name|u_int8_t
name|target_power_val_t2
index|[
name|ar9300_rate_size
index|]
decl_stmt|;
name|u_int8_t
name|target_power_val_t2_eep
index|[
name|ar9300_rate_size
index|]
decl_stmt|;
name|int16_t
name|twice_array_gain
init|=
literal|0
decl_stmt|,
name|max_power_level
init|=
literal|0
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|tmp_paprd_rate_mask
init|=
literal|0
decl_stmt|,
modifier|*
name|tmp_ptr
init|=
name|NULL
decl_stmt|;
name|int
name|paprd_scale_factor
init|=
literal|5
decl_stmt|;
name|u_int8_t
modifier|*
name|ptr_mcs_rate2power_table_index
decl_stmt|;
name|u_int8_t
name|mcs_rate2power_table_index_ht20
index|[
literal|24
index|]
init|=
block|{
name|ALL_TARGET_HT20_0_8_16
block|,
name|ALL_TARGET_HT20_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT20_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT20_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT20_4
block|,
name|ALL_TARGET_HT20_5
block|,
name|ALL_TARGET_HT20_6
block|,
name|ALL_TARGET_HT20_7
block|,
name|ALL_TARGET_HT20_0_8_16
block|,
name|ALL_TARGET_HT20_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT20_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT20_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT20_12
block|,
name|ALL_TARGET_HT20_13
block|,
name|ALL_TARGET_HT20_14
block|,
name|ALL_TARGET_HT20_15
block|,
name|ALL_TARGET_HT20_0_8_16
block|,
name|ALL_TARGET_HT20_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT20_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT20_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT20_20
block|,
name|ALL_TARGET_HT20_21
block|,
name|ALL_TARGET_HT20_22
block|,
name|ALL_TARGET_HT20_23
block|}
decl_stmt|;
name|u_int8_t
name|mcs_rate2power_table_index_ht40
index|[
literal|24
index|]
init|=
block|{
name|ALL_TARGET_HT40_0_8_16
block|,
name|ALL_TARGET_HT40_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT40_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT40_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT40_4
block|,
name|ALL_TARGET_HT40_5
block|,
name|ALL_TARGET_HT40_6
block|,
name|ALL_TARGET_HT40_7
block|,
name|ALL_TARGET_HT40_0_8_16
block|,
name|ALL_TARGET_HT40_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT40_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT40_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT40_12
block|,
name|ALL_TARGET_HT40_13
block|,
name|ALL_TARGET_HT40_14
block|,
name|ALL_TARGET_HT40_15
block|,
name|ALL_TARGET_HT40_0_8_16
block|,
name|ALL_TARGET_HT40_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT40_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT40_1_3_9_11_17_19
block|,
name|ALL_TARGET_HT40_20
block|,
name|ALL_TARGET_HT40_21
block|,
name|ALL_TARGET_HT40_22
block|,
name|ALL_TARGET_HT40_23
block|,     }
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s[%d] +++chan %d,cfgctl 0x%04x  "
literal|"antenna_reduction 0x%04x, twice_max_regulatory_power 0x%04x "
literal|"power_limit 0x%04x\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|cfg_ctl
argument_list|,
name|antenna_reduction
argument_list|,
name|twice_max_regulatory_power
argument_list|,
name|power_limit
argument_list|)
expr_stmt|;
name|ar9300_set_target_power_from_eeprom
argument_list|(
name|ah
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|target_power_val_t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar9300_eeprom_get
argument_list|(
name|ahp
argument_list|,
name|EEP_PAPRD_ENABLED
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|tmp_paprd_rate_mask
operator|=
name|p_eep_data
operator|->
name|modal_header_2g
operator|.
name|paprd_rate_mask_ht40
expr_stmt|;
name|tmp_ptr
operator|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_2g_paprd_rate_mask_ht40
expr_stmt|;
block|}
else|else
block|{
name|tmp_paprd_rate_mask
operator|=
name|p_eep_data
operator|->
name|modal_header_2g
operator|.
name|paprd_rate_mask_ht20
expr_stmt|;
name|tmp_ptr
operator|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_2g_paprd_rate_mask_ht20
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|tmp_paprd_rate_mask
operator|=
name|p_eep_data
operator|->
name|modal_header_5g
operator|.
name|paprd_rate_mask_ht40
expr_stmt|;
name|tmp_ptr
operator|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_5g_paprd_rate_mask_ht40
expr_stmt|;
block|}
else|else
block|{
name|tmp_paprd_rate_mask
operator|=
name|p_eep_data
operator|->
name|modal_header_5g
operator|.
name|paprd_rate_mask_ht20
expr_stmt|;
name|tmp_ptr
operator|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_5g_paprd_rate_mask_ht20
expr_stmt|;
block|}
block|}
name|AH_PAPRD_GET_SCALE_FACTOR
argument_list|(
name|paprd_scale_factor
argument_list|,
name|p_eep_data
argument_list|,
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|,
name|chan
operator|->
name|channel
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s[%d] paprd_scale_factor %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|paprd_scale_factor
argument_list|)
expr_stmt|;
comment|/* PAPRD is not done yet, Scale down the EEP power */
if|if
condition|(
name|IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ptr_mcs_rate2power_table_index
operator|=
operator|&
name|mcs_rate2power_table_index_ht40
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|ptr_mcs_rate2power_table_index
operator|=
operator|&
name|mcs_rate2power_table_index_ht20
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|chan
operator|->
name|paprd_table_write_done
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
block|{
comment|/* PAPRD is done yet, so Scale down Power for PAPRD Rates*/
if|if
condition|(
name|tmp_paprd_rate_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|target_power_val_t2
index|[
name|ptr_mcs_rate2power_table_index
index|[
name|i
index|]
index|]
operator|-=
name|paprd_scale_factor
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s[%d]: Chan %d "
literal|"Scale down target_power_val_t2[%d] = 0x%04x\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|i
argument_list|,
name|target_power_val_t2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s[%d]: PAPRD Done No TGT PWR Scaling\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Save the Target power for future use */
name|OS_MEMCPY
argument_list|(
name|target_power_val_t2_eep
argument_list|,
name|target_power_val_t2
argument_list|,
sizeof|sizeof
argument_list|(
name|target_power_val_t2
argument_list|)
argument_list|)
expr_stmt|;
name|ar9300_eeprom_set_power_per_rate_table
argument_list|(
name|ah
argument_list|,
name|p_eep_data
argument_list|,
name|chan
argument_list|,
name|target_power_val_t2
argument_list|,
name|cfg_ctl
argument_list|,
name|antenna_reduction
argument_list|,
name|twice_max_regulatory_power
argument_list|,
name|power_limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Save this for quick lookup */
name|ahp
operator|->
name|reg_dmn
operator|=
name|chan
operator|->
name|conformance_test_limit
expr_stmt|;
comment|/*      * Always use CDD/direct per rate power table for register based approach.      * For FCC, CDD calculations should factor in the array gain, hence       * this adjust call. ETSI and MKK does not have this requirement.      */
if|if
condition|(
name|is_reg_dmn_fcc
argument_list|(
name|ahp
operator|->
name|reg_dmn
argument_list|)
condition|)
block|{
name|ar9300_adjust_reg_txpower_cdd
argument_list|(
name|ah
argument_list|,
name|target_power_val_t2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ar9300_eeprom_get
argument_list|(
name|ahp
argument_list|,
name|EEP_PAPRD_ENABLED
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ar9300_rate_size
condition|;
name|i
operator|++
control|)
block|{
comment|/*              * EEPROM TGT PWR is not same as current TGT PWR,              * so Disable PAPRD for this rate.              * Some of APs might ask to reduce Target Power,              * if target power drops significantly,              * disable PAPRD for that rate.              */
if|if
condition|(
name|tmp_paprd_rate_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|ABS
argument_list|(
name|target_power_val_t2_eep
index|[
name|i
index|]
argument_list|,
name|target_power_val_t2
index|[
name|i
index|]
argument_list|)
operator|>
name|paprd_scale_factor
condition|)
block|{
name|tmp_paprd_rate_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: EEP TPC[%02d] 0x%08x "
literal|"Curr TPC[%02d] 0x%08x mask = 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|target_power_val_t2_eep
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|target_power_val_t2
index|[
name|i
index|]
argument_list|,
name|tmp_paprd_rate_mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Chan %d After tmp_paprd_rate_mask = 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|tmp_paprd_rate_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_ptr
condition|)
block|{
operator|*
name|tmp_ptr
operator|=
name|tmp_paprd_rate_mask
expr_stmt|;
block|}
block|}
comment|/* Write target power array to registers */
name|ar9300_transmit_power_reg_write
argument_list|(
name|ah
argument_list|,
name|target_power_val_t2
argument_list|)
expr_stmt|;
comment|/* Write target power for self generated frames to the TPC register */
name|ar9300_selfgen_tpc_reg_write
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|target_power_val_t2
argument_list|)
expr_stmt|;
comment|/* GreenTx or Paprd */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_sta_update_tx_pwr_enable
operator|||
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_paprd_enabled
condition|)
block|{
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/*For HAL_RSSI_TX_POWER_NONE array*/
name|OS_MEMCPY
argument_list|(
name|ahp
operator|->
name|ah_default_tx_power
argument_list|,
name|target_power_val_t2
argument_list|,
sizeof|sizeof
argument_list|(
name|target_power_val_t2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get defautl tx related register setting for GreenTx */
comment|/* Record OB/DB */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ob_db1
index|[
name|POSEIDON_STORED_REG_OBDB
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_TXRF2
argument_list|)
expr_stmt|;
comment|/* Record TPC settting */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ob_db1
index|[
name|POSEIDON_STORED_REG_TPC
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TPC
argument_list|)
expr_stmt|;
comment|/* Record BB_powertx_rate9 setting */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_ob_db1
index|[
name|POSEIDON_STORED_REG_BB_PWRTX_RATE9
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_POWERTX_RATE9
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Return tx power used to iwconfig.      * Since power is rate dependent, use one of the indices from the      * AR9300_Rates enum to select an entry from target_power_val_t2[]      * to report.      * Currently returns the power for HT40 MCS 0, HT20 MCS 0, or OFDM 6 Mbps      * as CCK power is less interesting (?).      */
name|i
operator|=
name|ALL_TARGET_LEGACY_6_24
expr_stmt|;
comment|/* legacy */
if|if
condition|(
name|IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|i
operator|=
name|ALL_TARGET_HT40_0_8_16
expr_stmt|;
comment|/* ht40 */
block|}
elseif|else
if|if
condition|(
name|IS_CHAN_HT20
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|i
operator|=
name|ALL_TARGET_HT20_0_8_16
expr_stmt|;
comment|/* ht20 */
block|}
name|max_power_level
operator|=
name|target_power_val_t2
index|[
name|i
index|]
expr_stmt|;
comment|/* Adjusting the ah_max_power_level based on chains and antennaGain*/
switch|switch
condition|(
name|ar9300_get_ntxchains
argument_list|(
name|ahp
operator|->
name|ah_tx_chainmask
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|twice_array_gain
operator|=
operator|(
name|ahp
operator|->
name|twice_antenna_gain
operator|>=
name|ahp
operator|->
name|twice_antenna_reduction
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|int16_t
operator|)
name|AH_MIN
argument_list|(
operator|(
name|ahp
operator|->
name|twice_antenna_reduction
operator|-
operator|(
name|ahp
operator|->
name|twice_antenna_gain
operator|+
name|INCREASE_MAXPOW_BY_TWO_CHAIN
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
comment|/* Adjusting maxpower with antennaGain */
name|max_power_level
operator|-=
name|twice_array_gain
expr_stmt|;
comment|/* Adjusting maxpower based on chain */
name|max_power_level
operator|+=
name|INCREASE_MAXPOW_BY_TWO_CHAIN
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|twice_array_gain
operator|=
operator|(
name|ahp
operator|->
name|twice_antenna_gain
operator|>=
name|ahp
operator|->
name|twice_antenna_reduction
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|int16_t
operator|)
name|AH_MIN
argument_list|(
operator|(
name|ahp
operator|->
name|twice_antenna_reduction
operator|-
operator|(
name|ahp
operator|->
name|twice_antenna_gain
operator|+
name|INCREASE_MAXPOW_BY_THREE_CHAIN
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
comment|/* Adjusting maxpower with antennaGain */
name|max_power_level
operator|-=
name|twice_array_gain
expr_stmt|;
comment|/* Adjusting maxpower based on chain */
name|max_power_level
operator|+=
name|INCREASE_MAXPOW_BY_THREE_CHAIN
expr_stmt|;
break|break;
default|default:
name|HALASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Unsupported number of chains */
block|}
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_max_power_level
operator|=
operator|(
name|int8_t
operator|)
name|max_power_level
expr_stmt|;
name|ar9300_calibration_apply
argument_list|(
name|ah
argument_list|,
name|chan
operator|->
name|channel
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ABS
comment|/* Handle per packet TPC initializations */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_desc_tpc
condition|)
block|{
comment|/* Transmit Power per-rate per-chain  are  computed here. A separate          * power table is maintained for different MIMO modes (i.e. TXBF ON,          * STBC) to enable easy lookup during packet transmit.           * The reason for maintaing each of these tables per chain is that          * the transmit power used for different number of chains is different          * depending on whether the power has been limited by the target power,          * the regulatory domain  or the CTL limits.          */
name|u_int
name|mode
init|=
name|ath_hal_get_curmode
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|u_int32_t
name|val
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|chainmasks
index|[
name|AR9300_MAX_CHAINS
index|]
init|=
block|{
name|OSPREY_1_CHAINMASK
block|,
name|OSPREY_2LOHI_CHAINMASK
block|,
name|OSPREY_3_CHAINMASK
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR9300_MAX_CHAINS
condition|;
name|i
operator|++
control|)
block|{
name|OS_MEMCPY
argument_list|(
name|target_power_val_t2
argument_list|,
name|target_power_val_t2_eep
argument_list|,
sizeof|sizeof
argument_list|(
name|target_power_val_t2_eep
argument_list|)
argument_list|)
expr_stmt|;
name|ar9300_eeprom_set_power_per_rate_table
argument_list|(
name|ah
argument_list|,
name|p_eep_data
argument_list|,
name|chan
argument_list|,
name|target_power_val_t2
argument_list|,
name|cfg_ctl
argument_list|,
name|antenna_reduction
argument_list|,
name|twice_max_regulatory_power
argument_list|,
name|power_limit
argument_list|,
name|chainmasks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_POWER_MGMT
argument_list|,
literal|" Channel = %d Chainmask = %d, Upper Limit = [%2d.%1d dBm]\n"
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|i
argument_list|,
name|ahp
operator|->
name|upper_limit
index|[
name|i
index|]
operator|/
literal|2
argument_list|,
name|ahp
operator|->
name|upper_limit
index|[
name|i
index|]
operator|%
literal|2
operator|*
literal|5
argument_list|)
expr_stmt|;
name|ar9300_init_rate_txpower
argument_list|(
name|ah
argument_list|,
name|mode
argument_list|,
name|chan
argument_list|,
name|target_power_val_t2
argument_list|,
name|chainmasks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Enable TPC */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PWRTX_MAX
argument_list|,
name|AR_PHY_PWRTX_MAX_TPC_ENABLE
argument_list|)
expr_stmt|;
comment|/*          * Disable per chain power reduction since we are already           * accounting for this in our calculations           */
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_SUB
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_SUB
argument_list|,
name|val
operator|&
name|AR_PHY_POWER_TX_SUB_2_DISABLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_POWER_TX_SUB
argument_list|,
name|val
operator|&
name|AR_PHY_POWER_TX_SUB_3_DISABLE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  * ar9300_eeprom_set_addac  *  * Set the ADDAC from eeprom.  */
end_comment

begin_function
name|void
name|ar9300_eeprom_set_addac
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|)
block|{
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"FIXME: ar9300_eeprom_def_set_addac called\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|MODAL_EEPDEF_HEADER *p_modal;     struct ath_hal_9300 *ahp = AH9300(ah);     ar9300_eeprom_t *eep =&ahp->ah_eeprom.def;     u_int8_t biaslevel;      if (AH_PRIVATE(ah)->ah_macVersion != AR_SREV_VERSION_SOWL) {         return;     }      HALASSERT(owl_get_eepdef_ver(ahp) == AR9300_EEP_VER);
comment|/* Xpa bias levels in eeprom are valid from rev 14.7 */
block|if (owl_get_eepdef_rev(ahp)< AR9300_EEP_MINOR_VER_7) {         return;     }      if (ahp->ah_emu_eeprom) {         return;     }      p_modal =&(eep->modal_header[IS_CHAN_2GHZ(chan)]);      if (p_modal->xpa_bias_lvl != 0xff) {         biaslevel = p_modal->xpa_bias_lvl;     } else {
comment|/* Use freqeuncy specific xpa bias level */
block|u_int16_t reset_freq_bin, freq_bin, freq_count = 0;         CHAN_CENTERS centers;          ar9300_get_channel_centers(ah, chan,&centers);          reset_freq_bin = FREQ2FBIN(centers.synth_center, IS_CHAN_2GHZ(chan));         freq_bin = p_modal->xpa_bias_lvl_freq[0]& 0xff;         biaslevel = (u_int8_t)(p_modal->xpa_bias_lvl_freq[0]>> 14);          freq_count++;          while (freq_count< 3) {             if (p_modal->xpa_bias_lvl_freq[freq_count] == 0x0) {                 break;             }              freq_bin = p_modal->xpa_bias_lvl_freq[freq_count]& 0xff;             if (reset_freq_bin>= freq_bin) {                 biaslevel =                     (u_int8_t)(p_modal->xpa_bias_lvl_freq[freq_count]>> 14);             } else {                 break;             }             freq_count++;         }     }
comment|/* Apply bias level to the ADDAC values in the INI array */
block|if (IS_CHAN_2GHZ(chan)) {         INI_RA(&ahp->ah_ini_addac, 7, 1) =             (INI_RA(&ahp->ah_ini_addac, 7, 1)& (~0x18)) | biaslevel<< 3;     } else {         INI_RA(&ahp->ah_ini_addac, 6, 1) =             (INI_RA(&ahp->ah_ini_addac, 6, 1)& (~0xc0)) | biaslevel<< 6;     }
endif|#
directive|endif
block|}
end_function

begin_function
name|u_int
name|ar9300_eeprom_dump_support
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|void
modifier|*
modifier|*
name|pp_e
parameter_list|)
block|{
operator|*
name|pp_e
operator|=
operator|&
operator|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
operator|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
name|ar9300_eeprom_t
argument_list|)
return|;
block|}
end_function

begin_function
name|u_int8_t
name|ar9300_eeprom_get_num_ant_config
parameter_list|(
name|struct
name|ath_hal_9300
modifier|*
name|ahp
parameter_list|,
name|HAL_FREQ_BAND
name|freq_band
parameter_list|)
block|{
if|#
directive|if
literal|0
block|ar9300_eeprom_t  *eep =&ahp->ah_eeprom.def;     MODAL_EEPDEF_HEADER *p_modal =&(eep->modal_header[HAL_FREQ_BAND_2GHZ == freq_band]);     BASE_EEPDEF_HEADER  *p_base  =&eep->base_eep_header;     u_int8_t         num_ant_config;      num_ant_config = 1;
comment|/* default antenna configuration */
block|if (p_base->version>= 0x0E0D) {         if (p_modal->use_ant1) {             num_ant_config += 1;         }     }      return num_ant_config;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|HAL_STATUS
name|ar9300_eeprom_get_ant_cfg
parameter_list|(
name|struct
name|ath_hal_9300
modifier|*
name|ahp
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|,
name|u_int8_t
name|index
parameter_list|,
name|u_int16_t
modifier|*
name|config
parameter_list|)
block|{
if|#
directive|if
literal|0
block|ar9300_eeprom_t  *eep =&ahp->ah_eeprom.def;     MODAL_EEPDEF_HEADER *p_modal =&(eep->modal_header[IS_CHAN_2GHZ(chan)]);     BASE_EEPDEF_HEADER  *p_base  =&eep->base_eep_header;      switch (index) {     case 0:         *config = p_modal->ant_ctrl_common& 0xFFFF;         return HAL_OK;     case 1:         if (p_base->version>= 0x0E0D) {             if (p_modal->use_ant1) {                 *config = ((p_modal->ant_ctrl_common& 0xFFFF0000)>> 16);                 return HAL_OK;             }         }         break;     default:         break;     }
endif|#
directive|endif
return|return
name|HAL_EINVAL
return|;
block|}
end_function

begin_function
name|u_int8_t
modifier|*
name|ar9300_eeprom_get_cust_data
parameter_list|(
name|struct
name|ath_hal_9300
modifier|*
name|ahp
parameter_list|)
block|{
return|return
operator|(
name|u_int8_t
operator|*
operator|)
name|ahp
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_function
specifier|static
specifier|inline
name|HAL_STATUS
name|ar9300_check_eeprom
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
if|#
directive|if
literal|0
block|u_int32_t sum = 0, el;     u_int16_t *eepdata;     int i;     struct ath_hal_9300 *ahp = AH9300(ah);     HAL_BOOL need_swap = AH_FALSE;     ar9300_eeprom_t *eep = (ar9300_eeprom_t *)&ahp->ah_eeprom.def;     u_int16_t magic, magic2;     int addr;     u_int16_t temp;
comment|/*     ** We need to check the EEPROM data regardless of if it's in flash or     ** in EEPROM.     */
block|if (!ahp->ah_priv.priv.ah_eeprom_read(             ah, AR9300_EEPROM_MAGIC_OFFSET,&magic))     {         HALDEBUG(ah, HAL_DEBUG_EEPROM, "%s: Reading Magic # failed\n", __func__);         return AH_FALSE;     }      HALDEBUG(ah, HAL_DEBUG_EEPROM, "%s: Read Magic = 0x%04X\n", __func__, magic);      if (!ar9300_eep_data_in_flash(ah)) {          if (magic != AR9300_EEPROM_MAGIC) {             magic2 = SWAP16(magic);              if (magic2 == AR9300_EEPROM_MAGIC) {                 need_swap = AH_TRUE;                 eepdata = (u_int16_t *)(&ahp->ah_eeprom);                  for (addr = 0;                      addr< sizeof(ar9300_eeprom_t) / sizeof(u_int16_t);                      addr++)                 {                     temp = SWAP16(*eepdata);                     *eepdata = temp;                     eepdata++;                      HALDEBUG(ah, HAL_DEBUG_EEPROM_DUMP, "0x%04X  ", *eepdata);                     if (((addr + 1) % 6) == 0) {                         HALDEBUG(ah, HAL_DEBUG_EEPROM_DUMP, "\n");                     }                 }             } else {                 HALDEBUG(ah, HAL_DEBUG_EEPROM,                     "Invalid EEPROM Magic. endianness missmatch.\n");                 return HAL_EEBADSUM;             }         }     } else {         HALDEBUG(ah, HAL_DEBUG_EEPROM,                  "EEPROM being read from flash @0x%p\n", AH_PRIVATE(ah)->ah_st);     }      HALDEBUG(ah, HAL_DEBUG_EEPROM, "need_swap = %s.\n", need_swap?"True":"False");      if (need_swap) {         el = SWAP16(ahp->ah_eeprom.def.base_eep_header.length);     } else {         el = ahp->ah_eeprom.def.base_eep_header.length;     }      eepdata = (u_int16_t *)(&ahp->ah_eeprom.def);     for (i = 0;          i< AH_MIN(el, sizeof(ar9300_eeprom_t)) / sizeof(u_int16_t);          i++) {         sum ^= *eepdata++;     }      if (need_swap) {
comment|/*         *  preddy: EEPROM endianness does not match. So change it         *  8bit values in eeprom data structure does not need to be swapped         *  Only>8bits (16& 32) values need to be swapped         *  If a new 16 or 32 bit field is added to the EEPROM contents,         *  please make sure to swap the field here         */
block|u_int32_t integer, j;         u_int16_t word;          HALDEBUG(ah, HAL_DEBUG_EEPROM,             "EEPROM Endianness is not native.. Changing \n");
comment|/* convert Base Eep header */
block|word = SWAP16(eep->base_eep_header.length);         eep->base_eep_header.length = word;          word = SWAP16(eep->base_eep_header.checksum);         eep->base_eep_header.checksum = word;          word = SWAP16(eep->base_eep_header.version);         eep->base_eep_header.version = word;          word = SWAP16(eep->base_eep_header.reg_dmn[0]);         eep->base_eep_header.reg_dmn[0] = word;          word = SWAP16(eep->base_eep_header.reg_dmn[1]);         eep->base_eep_header.reg_dmn[1] = word;          word = SWAP16(eep->base_eep_header.rf_silent);         eep->base_eep_header.rf_silent = word;          word = SWAP16(eep->base_eep_header.blue_tooth_options);         eep->base_eep_header.blue_tooth_options = word;          word = SWAP16(eep->base_eep_header.device_cap);         eep->base_eep_header.device_cap = word;
comment|/* convert Modal Eep header */
block|for (j = 0; j< ARRAY_LENGTH(eep->modal_header); j++) {             MODAL_EEPDEF_HEADER *p_modal =&eep->modal_header[j];             integer = SWAP32(p_modal->ant_ctrl_common);             p_modal->ant_ctrl_common = integer;              for (i = 0; i< AR9300_MAX_CHAINS; i++) {                 integer = SWAP32(p_modal->ant_ctrl_chain[i]);                 p_modal->ant_ctrl_chain[i] = integer;             }              for (i = 0; i< AR9300_EEPROM_MODAL_SPURS; i++) {                 word = SWAP16(p_modal->spur_chans[i].spur_chan);                 p_modal->spur_chans[i].spur_chan = word;             }         }     }
comment|/* Check CRC - Attach should fail on a bad checksum */
block|if (sum != 0xffff || owl_get_eepdef_ver(ahp) != AR9300_EEP_VER ||         owl_get_eepdef_rev(ahp)< AR9300_EEP_NO_BACK_VER) {         HALDEBUG(ah, HAL_DEBUG_EEPROM,             "Bad EEPROM checksum 0x%x or revision 0x%04x\n",             sum, owl_get_eepdef_ver(ahp));         return HAL_EEBADSUM;     }
ifdef|#
directive|ifdef
name|EEPROM_DUMP
block|ar9300_eeprom_def_dump(ah, eep);
endif|#
directive|endif
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|AH_AR9300_OVRD_TGT_PWR
comment|/*      * 14.4 EEPROM contains low target powers.      * Hardcode until EEPROM> 14.4      */
block|if (owl_get_eepdef_ver(ahp) == 14&& owl_get_eepdef_rev(ahp)<= 4) {         MODAL_EEPDEF_HEADER *p_modal;
ifdef|#
directive|ifdef
name|EEPROM_DUMP
block|HALDEBUG(ah,  HAL_DEBUG_POWER_OVERRIDE, "Original Target Powers\n");         ar9300_eep_def_dump_tgt_power(ah, eep);
endif|#
directive|endif
block|HALDEBUG(ah,  HAL_DEBUG_POWER_OVERRIDE,                  "Override Target Powers. EEPROM Version is %d.%d, "                 "Device Type %d\n",                 owl_get_eepdef_ver(ahp),                 owl_get_eepdef_rev(ahp),                 eep->base_eep_header.device_type);           ar9300_eep_def_override_tgt_power(ah, eep);          if (eep->base_eep_header.device_type == 5) {
comment|/* for xb72 only: improve transmit EVM for interop */
block|p_modal =&eep->modal_header[1];             p_modal->tx_frame_to_data_start = 0x23;             p_modal->tx_frame_to_xpa_on = 0x23;             p_modal->tx_frame_to_pa_on = 0x23;     }
ifdef|#
directive|ifdef
name|EEPROM_DUMP
block|HALDEBUG(ah, HAL_DEBUG_POWER_OVERRIDE, "Modified Target Powers\n");         ar9300_eep_def_dump_tgt_power(ah, eep);
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* AH_AR9300_OVRD_TGT_PWR */
endif|#
directive|endif
endif|#
directive|endif
return|return
name|HAL_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|u_int16_t
name|ar9300_eeprom_get_spur_chan
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|i
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
name|u_int16_t
name|spur_val
init|=
name|AR_NO_SPUR
decl_stmt|;
if|#
directive|if
literal|0
block|struct ath_hal_9300 *ahp = AH9300(ah);     ar9300_eeprom_t *eep = (ar9300_eeprom_t *)&ahp->ah_eeprom;      HALASSERT(i<  AR_EEPROM_MODAL_SPURS );      HALDEBUG(ah, HAL_DEBUG_ANI,              "Getting spur idx %d is2Ghz. %d val %x\n",              i, is_2ghz,              AH_PRIVATE(ah)->ah_config.ath_hal_spur_chans[i][is_2ghz]);      switch (AH_PRIVATE(ah)->ah_config.ath_hal_spur_mode) {     case SPUR_DISABLE:
comment|/* returns AR_NO_SPUR */
block|break;     case SPUR_ENABLE_IOCTL:         spur_val = AH_PRIVATE(ah)->ah_config.ath_hal_spur_chans[i][is_2ghz];         HALDEBUG(ah, HAL_DEBUG_ANI,             "Getting spur val from new loc. %d\n", spur_val);         break;     case SPUR_ENABLE_EEPROM:         spur_val = eep->modal_header[is_2ghz].spur_chans[i].spur_chan;         break;      }
endif|#
directive|endif
return|return
name|spur_val
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_function
specifier|static
specifier|inline
name|HAL_BOOL
name|ar9300_fill_eeprom
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|ar9300_eeprom_restore
argument_list|(
name|ah
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|u_int16_t
name|ar9300_eeprom_struct_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|ar9300_eeprom_t
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ar9300_eeprom_struct_default_many
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ARRAY_LENGTH
argument_list|(
name|default9300
argument_list|)
return|;
block|}
end_function

begin_function
name|ar9300_eeprom_t
modifier|*
name|ar9300_eeprom_struct_default
parameter_list|(
name|int
name|default_index
parameter_list|)
block|{
if|if
condition|(
name|default_index
operator|>=
literal|0
operator|&&
name|default_index
operator|<
name|ARRAY_LENGTH
argument_list|(
name|default9300
argument_list|)
condition|)
block|{
return|return
name|default9300
index|[
name|default_index
index|]
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|ar9300_eeprom_t
modifier|*
name|ar9300_eeprom_struct_default_find_by_id
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|int
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
literal|0
init|;
name|it
operator|<
name|ARRAY_LENGTH
argument_list|(
name|default9300
argument_list|)
condition|;
name|it
operator|++
control|)
block|{
if|if
condition|(
name|default9300
index|[
name|it
index|]
operator|!=
literal|0
operator|&&
name|default9300
index|[
name|it
index|]
operator|->
name|template_version
operator|==
name|id
condition|)
block|{
return|return
name|default9300
index|[
name|it
index|]
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_calibration_data_read_flash
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|long
name|address
parameter_list|,
name|u_int8_t
modifier|*
name|buffer
parameter_list|,
name|int
name|many
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|address
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|address
operator|+
name|many
operator|)
operator|>
name|AR9300_EEPROM_SIZE
operator|-
literal|1
operator|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_calibration_data_read_eeprom
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|long
name|address
parameter_list|,
name|u_int8_t
modifier|*
name|buffer
parameter_list|,
name|int
name|many
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int8_t
name|value
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|long
name|eep_addr
decl_stmt|;
name|unsigned
name|long
name|byte_addr
decl_stmt|;
name|u_int16_t
modifier|*
name|svalue
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|address
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|address
operator|+
name|many
operator|)
operator|>
name|AR9300_EEPROM_SIZE
operator|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|many
condition|;
name|i
operator|++
control|)
block|{
name|eep_addr
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|address
operator|+
name|i
argument_list|)
operator|/
literal|2
expr_stmt|;
name|byte_addr
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|address
operator|+
name|i
argument_list|)
operator|%
literal|2
expr_stmt|;
name|svalue
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|ahp
operator|->
name|ah_priv
operator|.
name|priv
operator|.
name|ah_eeprom_read
argument_list|(
name|ah
argument_list|,
name|eep_addr
argument_list|,
name|svalue
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: Unable to read eeprom region \n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|buffer
index|[
name|i
index|]
operator|=
operator|(
operator|*
name|svalue
operator|>>
operator|(
literal|8
operator|*
name|byte_addr
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_calibration_data_read_otp
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|long
name|address
parameter_list|,
name|u_int8_t
modifier|*
name|buffer
parameter_list|,
name|int
name|many
parameter_list|,
name|HAL_BOOL
name|is_wifi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|eep_addr
decl_stmt|;
name|unsigned
name|long
name|byte_addr
decl_stmt|;
name|u_int32_t
name|svalue
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|address
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|address
operator|+
name|many
operator|)
operator|>
literal|0x400
operator|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|many
condition|;
name|i
operator|++
control|)
block|{
name|eep_addr
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|address
operator|+
name|i
argument_list|)
operator|/
literal|4
expr_stmt|;
comment|/* otp is 4 bytes long???? */
name|byte_addr
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|address
operator|+
name|i
argument_list|)
operator|%
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|ar9300_otp_read
argument_list|(
name|ah
argument_list|,
name|eep_addr
argument_list|,
operator|&
name|svalue
argument_list|,
name|is_wifi
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: Unable to read otp region \n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|svalue
operator|>>
operator|(
literal|8
operator|*
name|byte_addr
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_CAL_NAND_FLASH
end_ifdef

begin_function
name|HAL_BOOL
name|ar9300_calibration_data_read_nand
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|long
name|address
parameter_list|,
name|u_int8_t
modifier|*
name|buffer
parameter_list|,
name|int
name|many
parameter_list|)
block|{
name|int
name|ret_len
decl_stmt|;
name|int
name|ret_val
init|=
literal|1
decl_stmt|;
comment|/* Calling OS based API to read NAND */
name|ret_val
operator|=
name|OS_NAND_FLASH_READ
argument_list|(
name|ATH_CAL_NAND_PARTITION
argument_list|,
name|address
argument_list|,
name|many
argument_list|,
operator|&
name|ret_len
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret_val
condition|?
name|AH_FALSE
else|:
name|AH_TRUE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|HAL_BOOL
name|ar9300_calibration_data_read
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|long
name|address
parameter_list|,
name|u_int8_t
modifier|*
name|buffer
parameter_list|,
name|int
name|many
parameter_list|)
block|{
switch|switch
condition|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
condition|)
block|{
case|case
name|calibration_data_flash
case|:
return|return
name|ar9300_calibration_data_read_flash
argument_list|(
name|ah
argument_list|,
name|address
argument_list|,
name|buffer
argument_list|,
name|many
argument_list|)
return|;
case|case
name|calibration_data_eeprom
case|:
return|return
name|ar9300_calibration_data_read_eeprom
argument_list|(
name|ah
argument_list|,
name|address
argument_list|,
name|buffer
argument_list|,
name|many
argument_list|)
return|;
case|case
name|calibration_data_otp
case|:
return|return
name|ar9300_calibration_data_read_otp
argument_list|(
name|ah
argument_list|,
name|address
argument_list|,
name|buffer
argument_list|,
name|many
argument_list|,
literal|1
argument_list|)
return|;
ifdef|#
directive|ifdef
name|ATH_CAL_NAND_FLASH
case|case
name|calibration_data_nand
case|:
return|return
name|ar9300_calibration_data_read_nand
argument_list|(
name|ah
argument_list|,
name|address
argument_list|,
name|buffer
argument_list|,
name|many
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_calibration_data_read_array
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|address
parameter_list|,
name|u_int8_t
modifier|*
name|buffer
parameter_list|,
name|int
name|many
parameter_list|)
block|{
name|int
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
literal|0
init|;
name|it
operator|<
name|many
condition|;
name|it
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|ar9300_calibration_data_read
argument_list|(
name|ah
argument_list|,
name|address
operator|-
name|it
argument_list|,
name|buffer
operator|+
name|it
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * the address where the first configuration block is written  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|base_address
init|=
literal|0x3ff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1KB */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|base_address_512
init|=
literal|0x1ff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 512Bytes */
end_comment

begin_comment
comment|/*  * the address where the NAND first configuration block is written  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_CAL_NAND_FLASH
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|int
name|base_address_nand
init|=
name|AR9300_FLASH_CAL_START_OFFSET
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * the lower limit on configuration data  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|low_limit
init|=
literal|0x040
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * returns size of the physical eeprom in bytes.  * 1024 and 2048 are normal sizes.   * 0 means there is no eeprom.   */
end_comment

begin_function
name|int32_t
name|ar9300_eeprom_size
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int16_t
name|data
decl_stmt|;
comment|/*      * first we'll try for 4096 bytes eeprom      */
if|if
condition|(
name|ar9300_eeprom_read_word
argument_list|(
name|ah
argument_list|,
literal|2047
argument_list|,
operator|&
name|data
argument_list|)
condition|)
block|{
if|if
condition|(
name|data
operator|!=
literal|0
condition|)
block|{
return|return
literal|4096
return|;
block|}
block|}
comment|/*      * then we'll try for 2048 bytes eeprom      */
if|if
condition|(
name|ar9300_eeprom_read_word
argument_list|(
name|ah
argument_list|,
literal|1023
argument_list|,
operator|&
name|data
argument_list|)
condition|)
block|{
if|if
condition|(
name|data
operator|!=
literal|0
condition|)
block|{
return|return
literal|2048
return|;
block|}
block|}
comment|/*      * then we'll try for 1024 bytes eeprom      */
if|if
condition|(
name|ar9300_eeprom_read_word
argument_list|(
name|ah
argument_list|,
literal|511
argument_list|,
operator|&
name|data
argument_list|)
condition|)
block|{
if|if
condition|(
name|data
operator|!=
literal|0
condition|)
block|{
return|return
literal|1024
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * returns size of the physical otp in bytes.  * 1024 and 2048 are normal sizes.   * 0 means there is no eeprom.   */
end_comment

begin_function_decl
name|int32_t
name|ar9300_otp_size
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int32_t
name|ar9300_otp_size
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
condition|)
block|{
return|return
name|base_address_512
operator|+
literal|1
return|;
block|}
else|else
block|{
return|return
name|base_address
operator|+
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * find top of memory  */
end_comment

begin_function
name|int
name|ar9300_eeprom_base_address
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|==
name|calibration_data_otp
condition|)
block|{
return|return
name|ar9300_otp_size
argument_list|(
name|ah
argument_list|)
operator|-
literal|1
return|;
block|}
else|else
block|{
name|size
operator|=
name|ar9300_eeprom_size
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
return|return
name|size
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|ar9300_otp_size
argument_list|(
name|ah
argument_list|)
operator|-
literal|1
return|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|ar9300_eeprom_volatile
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|==
name|calibration_data_otp
condition|)
block|{
return|return
literal|0
return|;
comment|/* no eeprom, use otp */
block|}
else|else
block|{
return|return
literal|1
return|;
comment|/* board has eeprom or flash */
block|}
block|}
end_function

begin_comment
comment|/*  * need to change this to look for the pcie data in the low parts of memory  * cal data needs to stop a few locations above   */
end_comment

begin_function
name|int
name|ar9300_eeprom_low_limit
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|low_limit
return|;
block|}
end_function

begin_function
name|u_int16_t
name|ar9300_compression_checksum
parameter_list|(
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|dsize
parameter_list|)
block|{
name|int
name|it
decl_stmt|;
name|int
name|checksum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|it
operator|=
literal|0
init|;
name|it
operator|<
name|dsize
condition|;
name|it
operator|++
control|)
block|{
name|checksum
operator|+=
name|data
index|[
name|it
index|]
expr_stmt|;
name|checksum
operator|&=
literal|0xffff
expr_stmt|;
block|}
return|return
name|checksum
return|;
block|}
end_function

begin_function
name|int
name|ar9300_compression_header_unpack
parameter_list|(
name|u_int8_t
modifier|*
name|best
parameter_list|,
name|int
modifier|*
name|code
parameter_list|,
name|int
modifier|*
name|reference
parameter_list|,
name|int
modifier|*
name|length
parameter_list|,
name|int
modifier|*
name|major
parameter_list|,
name|int
modifier|*
name|minor
parameter_list|)
block|{
name|unsigned
name|long
name|value
index|[
literal|4
index|]
decl_stmt|;
name|value
index|[
literal|0
index|]
operator|=
name|best
index|[
literal|0
index|]
expr_stmt|;
name|value
index|[
literal|1
index|]
operator|=
name|best
index|[
literal|1
index|]
expr_stmt|;
name|value
index|[
literal|2
index|]
operator|=
name|best
index|[
literal|2
index|]
expr_stmt|;
name|value
index|[
literal|3
index|]
operator|=
name|best
index|[
literal|3
index|]
expr_stmt|;
operator|*
name|code
operator|=
operator|(
operator|(
name|value
index|[
literal|0
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x0007
operator|)
expr_stmt|;
operator|*
name|reference
operator|=
operator|(
name|value
index|[
literal|0
index|]
operator|&
literal|0x001f
operator|)
operator||
operator|(
operator|(
name|value
index|[
literal|1
index|]
operator|>>
literal|2
operator|)
operator|&
literal|0x0020
operator|)
expr_stmt|;
operator|*
name|length
operator|=
operator|(
operator|(
name|value
index|[
literal|1
index|]
operator|<<
literal|4
operator|)
operator|&
literal|0x07f0
operator|)
operator||
operator|(
operator|(
name|value
index|[
literal|2
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0x000f
operator|)
expr_stmt|;
operator|*
name|major
operator|=
operator|(
name|value
index|[
literal|2
index|]
operator|&
literal|0x000f
operator|)
expr_stmt|;
operator|*
name|minor
operator|=
operator|(
name|value
index|[
literal|3
index|]
operator|&
literal|0x00ff
operator|)
expr_stmt|;
return|return
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|HAL_BOOL
name|ar9300_uncompress_block
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int8_t
modifier|*
name|mptr
parameter_list|,
name|int
name|mdata_size
parameter_list|,
name|u_int8_t
modifier|*
name|block
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|it
decl_stmt|;
name|int
name|spot
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|length
decl_stmt|;
name|spot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|it
operator|=
literal|0
init|;
name|it
operator|<
name|size
condition|;
name|it
operator|+=
operator|(
name|length
operator|+
literal|2
operator|)
control|)
block|{
name|offset
operator|=
name|block
index|[
name|it
index|]
expr_stmt|;
name|offset
operator|&=
literal|0xff
expr_stmt|;
name|spot
operator|+=
name|offset
expr_stmt|;
name|length
operator|=
name|block
index|[
name|it
operator|+
literal|1
index|]
expr_stmt|;
name|length
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
operator|&&
name|spot
operator|>=
literal|0
operator|&&
name|spot
operator|+
name|length
operator|<=
name|mdata_size
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: Restore at %d: spot=%d offset=%d length=%d\n"
argument_list|,
name|__func__
argument_list|,
name|it
argument_list|,
name|spot
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|OS_MEMCPY
argument_list|(
operator|&
name|mptr
index|[
name|spot
index|]
argument_list|,
operator|&
name|block
index|[
name|it
operator|+
literal|2
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|spot
operator|+=
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: Bad restore at %d: spot=%d offset=%d length=%d\n"
argument_list|,
name|__func__
argument_list|,
name|it
argument_list|,
name|spot
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar9300_eeprom_restore_internal_address
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|ar9300_eeprom_t
modifier|*
name|mptr
parameter_list|,
name|int
name|mdata_size
parameter_list|,
name|int
name|cptr
parameter_list|,
name|u_int8_t
name|blank
parameter_list|)
block|{
name|u_int8_t
name|word
index|[
name|MOUTPUT
index|]
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|dptr
decl_stmt|;
comment|/* was uint8 */
name|int
name|code
decl_stmt|;
name|int
name|reference
decl_stmt|,
name|length
decl_stmt|,
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|int
name|osize
decl_stmt|;
name|int
name|it
decl_stmt|;
name|int
name|restored
decl_stmt|;
name|u_int16_t
name|checksum
decl_stmt|,
name|mchecksum
decl_stmt|;
name|restored
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|it
operator|=
literal|0
init|;
name|it
operator|<
name|MSTATE
condition|;
name|it
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|ar9300_calibration_data_read_array
argument_list|(
name|ah
argument_list|,
name|cptr
argument_list|,
name|word
argument_list|,
name|compression_header_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
index|[
literal|0
index|]
operator|==
name|blank
operator|&&
name|word
index|[
literal|1
index|]
operator|==
name|blank
operator|&&
name|word
index|[
literal|2
index|]
operator|==
name|blank
operator|&&
name|word
index|[
literal|3
index|]
operator|==
name|blank
condition|)
block|{
break|break;
block|}
name|ar9300_compression_header_unpack
argument_list|(
name|word
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|reference
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: Found block at %x: "
literal|"code=%d ref=%d length=%d major=%d minor=%d\n"
argument_list|,
name|__func__
argument_list|,
name|cptr
argument_list|,
name|code
argument_list|,
name|reference
argument_list|,
name|length
argument_list|,
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DONTUSE
if|if
condition|(
name|length
operator|>=
literal|1024
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: Skipping bad header\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cptr
operator|-=
name|compression_header_length
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|osize
operator|=
name|length
expr_stmt|;
operator|(
name|void
operator|)
name|ar9300_calibration_data_read_array
argument_list|(
name|ah
argument_list|,
name|cptr
argument_list|,
name|word
argument_list|,
name|compression_header_length
operator|+
name|osize
operator|+
name|compression_checksum_length
argument_list|)
expr_stmt|;
name|checksum
operator|=
name|ar9300_compression_checksum
argument_list|(
operator|&
name|word
index|[
name|compression_header_length
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|mchecksum
operator|=
name|word
index|[
name|compression_header_length
operator|+
name|osize
index|]
operator||
operator|(
name|word
index|[
name|compression_header_length
operator|+
name|osize
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: checksum %x %x\n"
argument_list|,
name|__func__
argument_list|,
name|checksum
argument_list|,
name|mchecksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|==
name|mchecksum
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|_compress_none
case|:
if|if
condition|(
name|length
operator|!=
name|mdata_size
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: EEPROM structure size mismatch "
literal|"memory=%d eeprom=%d\n"
argument_list|,
name|__func__
argument_list|,
name|mdata_size
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|OS_MEMCPY
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|mptr
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|word
operator|+
name|compression_header_length
operator|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: restored eeprom %d: uncompressed, length %d\n"
argument_list|,
name|__func__
argument_list|,
name|it
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|restored
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|UNUSED
case|case
name|_compress_lzma
case|:
if|if
condition|(
name|reference
operator|==
name|reference_current
condition|)
block|{
name|dptr
operator|=
name|mptr
expr_stmt|;
block|}
else|else
block|{
name|dptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|ar9300_eeprom_struct_default_find_by_id
argument_list|(
name|reference
argument_list|)
expr_stmt|;
if|if
condition|(
name|dptr
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: Can't find reference eeprom struct %d\n"
argument_list|,
name|__func__
argument_list|,
name|reference
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|usize
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|usize
operator|!=
name|mdata_size
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: uncompressed data is wrong size %d %d\n"
argument_list|,
name|__func__
argument_list|,
name|usize
argument_list|,
name|mdata_size
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|ib
operator|=
literal|0
init|;
name|ib
operator|<
name|mdata_size
condition|;
name|ib
operator|++
control|)
block|{
name|mptr
index|[
name|ib
index|]
operator|=
name|dptr
index|[
name|ib
index|]
operator|^
name|word
index|[
name|ib
operator|+
name|overhead
index|]
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: restored eeprom %d: compressed, "
literal|"reference %d, length %d\n"
argument_list|,
name|__func__
argument_list|,
name|it
argument_list|,
name|reference
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|_compress_pairs
case|:
if|if
condition|(
name|reference
operator|==
name|reference_current
condition|)
block|{
name|dptr
operator|=
name|mptr
expr_stmt|;
block|}
else|else
block|{
name|dptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|ar9300_eeprom_struct_default_find_by_id
argument_list|(
name|reference
argument_list|)
expr_stmt|;
if|if
condition|(
name|dptr
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: Can't find the reference "
literal|"eeprom structure %d\n"
argument_list|,
name|__func__
argument_list|,
name|reference
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: restored eeprom %d: "
literal|"pairs, reference %d, length %d,\n"
argument_list|,
name|__func__
argument_list|,
name|it
argument_list|,
name|reference
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|_compress_block
case|:
if|if
condition|(
name|reference
operator|==
name|reference_current
condition|)
block|{
name|dptr
operator|=
name|mptr
expr_stmt|;
block|}
else|else
block|{
name|dptr
operator|=
name|ar9300_eeprom_struct_default_find_by_id
argument_list|(
name|reference
argument_list|)
expr_stmt|;
if|if
condition|(
name|dptr
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: cant find reference eeprom struct %d\n"
argument_list|,
name|__func__
argument_list|,
name|reference
argument_list|)
expr_stmt|;
break|break;
block|}
name|OS_MEMCPY
argument_list|(
name|mptr
argument_list|,
name|dptr
argument_list|,
name|mdata_size
argument_list|)
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: restore eeprom %d: block, reference %d, length %d\n"
argument_list|,
name|__func__
argument_list|,
name|it
argument_list|,
name|reference
argument_list|,
name|length
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ar9300_uncompress_block
argument_list|(
name|ah
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|mptr
argument_list|,
name|mdata_size
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|word
operator|+
name|compression_header_length
operator|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|restored
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: unknown compression code %d\n"
argument_list|,
name|__func__
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: skipping block with bad checksum\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|cptr
operator|-=
name|compression_header_length
operator|+
name|osize
operator|+
name|compression_checksum_length
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|restored
condition|)
block|{
name|cptr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|cptr
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar9300_eeprom_restore_from_dram
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|ar9300_eeprom_t
modifier|*
name|mptr
parameter_list|,
name|int
name|mdata_size
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_PLATFORM_FRAMEWORK
argument_list|)
name|char
modifier|*
name|cal_ptr
decl_stmt|;
endif|#
directive|endif
name|HALASSERT
argument_list|(
name|mdata_size
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* if cal_in_flash is AH_TRUE, the address sent by LMAC to HAL        (i.e. ah->ah_st) is corresponding to Flash. so return from         here if ar9300_eep_data_in_flash(ah) returns AH_TRUE */
if|if
condition|(
name|ar9300_eep_data_in_flash
argument_list|(
name|ah
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* check if LMAC sent DRAM address is valid */
if|if
condition|(
operator|!
call|(
name|uintptr_t
call|)
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_st
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/* When calibration data is from host, Host will copy the         compressed data to the predefined DRAM location saved at ah->ah_st */
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"Restoring Cal data from DRAM\n"
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_cal_mem
operator|=
name|OS_REMAP
argument_list|(
call|(
name|uintptr_t
call|)
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_st
argument_list|)
argument_list|,
name|HOST_CALDATA_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ahp
operator|->
name|ah_cal_mem
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: can't remap dram region\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_PLATFORM_FRAMEWORK
argument_list|)
name|cal_ptr
operator|=
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|ahp
operator|->
name|ah_cal_mem
operator|)
operator|)
index|[
name|AR9300_FLASH_CAL_START_OFFSET
index|]
expr_stmt|;
name|OS_MEMCPY
argument_list|(
name|mptr
argument_list|,
name|cal_ptr
argument_list|,
name|mdata_size
argument_list|)
expr_stmt|;
else|#
directive|else
name|OS_MEMCPY
argument_list|(
name|mptr
argument_list|,
name|ahp
operator|->
name|ah_cal_mem
argument_list|,
name|mdata_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mptr
operator|->
name|eeprom_version
operator|==
literal|0xff
operator|||
name|mptr
operator|->
name|template_version
operator|==
literal|0xff
operator|||
name|mptr
operator|->
name|eeprom_version
operator|==
literal|0
operator|||
name|mptr
operator|->
name|template_version
operator|==
literal|0
condition|)
block|{
comment|/* The board is uncalibrated */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mptr
operator|->
name|eeprom_version
operator|!=
literal|0x2
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|mdata_size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar9300_eeprom_restore_from_flash
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|ar9300_eeprom_t
modifier|*
name|mptr
parameter_list|,
name|int
name|mdata_size
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cal_ptr
decl_stmt|;
name|HALASSERT
argument_list|(
name|mdata_size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ahp
operator|->
name|ah_cal_mem
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"Restoring Cal data from Flash\n"
argument_list|)
expr_stmt|;
comment|/*      * When calibration data is saved in flash, read      * uncompressed eeprom structure from flash and return      */
name|cal_ptr
operator|=
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|ahp
operator|->
name|ah_cal_mem
operator|)
operator|)
index|[
name|AR9300_FLASH_CAL_START_OFFSET
index|]
expr_stmt|;
name|OS_MEMCPY
argument_list|(
name|mptr
argument_list|,
name|cal_ptr
argument_list|,
name|mdata_size
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|ar9300_swap_eeprom((ar9300_eeprom_t *)mptr); DONE IN ar9300_restore()
endif|#
directive|endif
if|if
condition|(
name|mptr
operator|->
name|eeprom_version
operator|==
literal|0xff
operator|||
name|mptr
operator|->
name|template_version
operator|==
literal|0xff
operator|||
name|mptr
operator|->
name|eeprom_version
operator|==
literal|0
operator|||
name|mptr
operator|->
name|template_version
operator|==
literal|0
condition|)
block|{
comment|/* The board is uncalibrated */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mptr
operator|->
name|eeprom_version
operator|!=
literal|0x2
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|mdata_size
return|;
block|}
end_function

begin_comment
comment|/*  * Read the configuration data from the storage. We try the order with:  * EEPROM, Flash, OTP. If all of above failed, use the default template.  * The data can be put in any specified memory buffer.  *  * Returns -1 on error.   * Returns address of next memory location on success.  */
end_comment

begin_function
name|int
name|ar9300_eeprom_restore_internal
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|ar9300_eeprom_t
modifier|*
name|mptr
parameter_list|,
name|int
name|mdata_size
parameter_list|)
block|{
name|int
name|nptr
decl_stmt|;
name|nptr
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_try
operator|==
name|calibration_data_none
operator|||
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_try
operator|==
name|calibration_data_dram
operator|)
operator|&&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|try_dram
operator|&&
name|nptr
operator|<
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|=
name|calibration_data_dram
expr_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
literal|0
expr_stmt|;
name|nptr
operator|=
name|ar9300_eeprom_restore_from_dram
argument_list|(
name|ah
argument_list|,
name|mptr
argument_list|,
name|mdata_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|nptr
operator|<
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|=
name|calibration_data_none
expr_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_try
operator|==
name|calibration_data_none
operator|||
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_try
operator|==
name|calibration_data_eeprom
operator|)
operator|&&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|try_eeprom
operator|&&
name|nptr
operator|<
literal|0
condition|)
block|{
comment|/*          * need to look at highest eeprom address as well as at          * base_address=0x3ff where we used to write the data          */
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|=
name|calibration_data_eeprom
expr_stmt|;
if|if
condition|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_try_address
operator|!=
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_try_address
expr_stmt|;
name|nptr
operator|=
name|ar9300_eeprom_restore_internal_address
argument_list|(
name|ah
argument_list|,
name|mptr
argument_list|,
name|mdata_size
argument_list|,
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
name|ar9300_eeprom_base_address
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|nptr
operator|=
name|ar9300_eeprom_restore_internal_address
argument_list|(
name|ah
argument_list|,
name|mptr
argument_list|,
name|mdata_size
argument_list|,
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nptr
operator|<
literal|0
operator|&&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|!=
name|base_address
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
name|base_address
expr_stmt|;
name|nptr
operator|=
name|ar9300_eeprom_restore_internal_address
argument_list|(
name|ah
argument_list|,
name|mptr
argument_list|,
name|mdata_size
argument_list|,
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nptr
operator|<
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|=
name|calibration_data_none
expr_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*      * ##### should be an ifdef test for any AP usage,      * either in driver or in nart      */
if|if
condition|(
operator|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_try
operator|==
name|calibration_data_none
operator|||
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_try
operator|==
name|calibration_data_flash
operator|)
operator|&&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|try_flash
operator|&&
name|nptr
operator|<
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|=
name|calibration_data_flash
expr_stmt|;
comment|/* how are we supposed to set this for flash? */
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
literal|0
expr_stmt|;
name|nptr
operator|=
name|ar9300_eeprom_restore_from_flash
argument_list|(
name|ah
argument_list|,
name|mptr
argument_list|,
name|mdata_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|nptr
operator|<
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|=
name|calibration_data_none
expr_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_try
operator|==
name|calibration_data_none
operator|||
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_try
operator|==
name|calibration_data_otp
operator|)
operator|&&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|try_otp
operator|&&
name|nptr
operator|<
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|=
name|calibration_data_otp
expr_stmt|;
if|if
condition|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_try_address
operator|!=
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_try_address
expr_stmt|;
block|}
else|else
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
name|ar9300_eeprom_base_address
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
name|nptr
operator|=
name|ar9300_eeprom_restore_internal_address
argument_list|(
name|ah
argument_list|,
name|mptr
argument_list|,
name|mdata_size
argument_list|,
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nptr
operator|<
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|=
name|calibration_data_none
expr_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ATH_CAL_NAND_FLASH
if|if
condition|(
operator|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_try
operator|==
name|calibration_data_none
operator|||
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_try
operator|==
name|calibration_data_nand
operator|)
operator|&&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|try_nand
operator|&&
name|nptr
operator|<
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|=
name|calibration_data_nand
expr_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_st
argument_list|)
operator|)
operator|+
name|base_address_nand
expr_stmt|;
if|if
condition|(
name|ar9300_calibration_data_read
argument_list|(
name|ah
argument_list|,
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|mptr
argument_list|,
name|mdata_size
argument_list|)
operator|==
name|AH_TRUE
condition|)
block|{
name|nptr
operator|=
name|mdata_size
expr_stmt|;
block|}
comment|/*nptr=ar9300EepromRestoreInternalAddress(ah, mptr, mdataSize, CalibrationDataSourceAddress);*/
if|if
condition|(
name|nptr
operator|<
literal|0
condition|)
block|{
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source
operator|=
name|calibration_data_none
expr_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|calibration_data_source_address
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|nptr
operator|<
literal|0
condition|)
block|{
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"%s[%d] No vaid CAL, calling default template\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|nptr
operator|=
name|ar9300_eeprom_restore_something
argument_list|(
name|ah
argument_list|,
name|mptr
argument_list|,
name|mdata_size
argument_list|)
expr_stmt|;
block|}
return|return
name|nptr
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*! **  \brief Eeprom Swapping Function ** **  This function will swap the contents of the "longer" EEPROM data items **  to ensure they are consistent with the endian requirements for the platform **  they are being compiled for ** **  \param eh    Pointer to the EEPROM data structure **  \return N/A */
end_comment

begin_if
if|#
directive|if
name|AH_BYTE_ORDER
operator|==
name|AH_BIG_ENDIAN
end_if

begin_function
name|void
name|ar9300_swap_eeprom
parameter_list|(
name|ar9300_eeprom_t
modifier|*
name|eep
parameter_list|)
block|{
name|u_int32_t
name|dword
decl_stmt|;
name|u_int16_t
name|word
decl_stmt|;
name|int
name|i
decl_stmt|;
name|word
operator|=
name|__bswap16
argument_list|(
name|eep
operator|->
name|base_eep_header
operator|.
name|reg_dmn
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|eep
operator|->
name|base_eep_header
operator|.
name|reg_dmn
index|[
literal|0
index|]
operator|=
name|word
expr_stmt|;
name|word
operator|=
name|__bswap16
argument_list|(
name|eep
operator|->
name|base_eep_header
operator|.
name|reg_dmn
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|eep
operator|->
name|base_eep_header
operator|.
name|reg_dmn
index|[
literal|1
index|]
operator|=
name|word
expr_stmt|;
name|dword
operator|=
name|__bswap32
argument_list|(
name|eep
operator|->
name|base_eep_header
operator|.
name|swreg
argument_list|)
expr_stmt|;
name|eep
operator|->
name|base_eep_header
operator|.
name|swreg
operator|=
name|dword
expr_stmt|;
name|dword
operator|=
name|__bswap32
argument_list|(
name|eep
operator|->
name|modal_header_2g
operator|.
name|ant_ctrl_common
argument_list|)
expr_stmt|;
name|eep
operator|->
name|modal_header_2g
operator|.
name|ant_ctrl_common
operator|=
name|dword
expr_stmt|;
name|dword
operator|=
name|__bswap32
argument_list|(
name|eep
operator|->
name|modal_header_2g
operator|.
name|ant_ctrl_common2
argument_list|)
expr_stmt|;
name|eep
operator|->
name|modal_header_2g
operator|.
name|ant_ctrl_common2
operator|=
name|dword
expr_stmt|;
name|dword
operator|=
name|__bswap32
argument_list|(
name|eep
operator|->
name|modal_header_2g
operator|.
name|paprd_rate_mask_ht20
argument_list|)
expr_stmt|;
name|eep
operator|->
name|modal_header_2g
operator|.
name|paprd_rate_mask_ht20
operator|=
name|dword
expr_stmt|;
name|dword
operator|=
name|__bswap32
argument_list|(
name|eep
operator|->
name|modal_header_2g
operator|.
name|paprd_rate_mask_ht40
argument_list|)
expr_stmt|;
name|eep
operator|->
name|modal_header_2g
operator|.
name|paprd_rate_mask_ht40
operator|=
name|dword
expr_stmt|;
name|dword
operator|=
name|__bswap32
argument_list|(
name|eep
operator|->
name|modal_header_5g
operator|.
name|ant_ctrl_common
argument_list|)
expr_stmt|;
name|eep
operator|->
name|modal_header_5g
operator|.
name|ant_ctrl_common
operator|=
name|dword
expr_stmt|;
name|dword
operator|=
name|__bswap32
argument_list|(
name|eep
operator|->
name|modal_header_5g
operator|.
name|ant_ctrl_common2
argument_list|)
expr_stmt|;
name|eep
operator|->
name|modal_header_5g
operator|.
name|ant_ctrl_common2
operator|=
name|dword
expr_stmt|;
name|dword
operator|=
name|__bswap32
argument_list|(
name|eep
operator|->
name|modal_header_5g
operator|.
name|paprd_rate_mask_ht20
argument_list|)
expr_stmt|;
name|eep
operator|->
name|modal_header_5g
operator|.
name|paprd_rate_mask_ht20
operator|=
name|dword
expr_stmt|;
name|dword
operator|=
name|__bswap32
argument_list|(
name|eep
operator|->
name|modal_header_5g
operator|.
name|paprd_rate_mask_ht40
argument_list|)
expr_stmt|;
name|eep
operator|->
name|modal_header_5g
operator|.
name|paprd_rate_mask_ht40
operator|=
name|dword
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OSPREY_MAX_CHAINS
condition|;
name|i
operator|++
control|)
block|{
name|word
operator|=
name|__bswap16
argument_list|(
name|eep
operator|->
name|modal_header_2g
operator|.
name|ant_ctrl_chain
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|eep
operator|->
name|modal_header_2g
operator|.
name|ant_ctrl_chain
index|[
name|i
index|]
operator|=
name|word
expr_stmt|;
name|word
operator|=
name|__bswap16
argument_list|(
name|eep
operator|->
name|modal_header_5g
operator|.
name|ant_ctrl_chain
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|eep
operator|->
name|modal_header_5g
operator|.
name|ant_ctrl_chain
index|[
name|i
index|]
operator|=
name|word
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ar9300_eeprom_template_swap
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|it
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|dptr
decl_stmt|;
for|for
control|(
name|it
operator|=
literal|0
init|;
name|it
operator|<
name|ARRAY_LENGTH
argument_list|(
name|default9300
argument_list|)
condition|;
name|it
operator|++
control|)
block|{
name|dptr
operator|=
name|ar9300_eeprom_struct_default
argument_list|(
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|dptr
operator|!=
literal|0
condition|)
block|{
name|ar9300_swap_eeprom
argument_list|(
name|dptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Restore the configuration structure by reading the eeprom.  * This function destroys any existing in-memory structure content.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_eeprom_restore
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|mptr
decl_stmt|;
name|int
name|mdata_size
decl_stmt|;
name|HAL_BOOL
name|status
init|=
name|AH_FALSE
decl_stmt|;
name|mptr
operator|=
operator|&
name|ahp
operator|->
name|ah_eeprom
expr_stmt|;
name|mdata_size
operator|=
name|ar9300_eeprom_struct_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|mptr
operator|!=
literal|0
operator|&&
name|mdata_size
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|AH_BYTE_ORDER
operator|==
name|AH_BIG_ENDIAN
name|ar9300_eeprom_template_swap
argument_list|()
expr_stmt|;
name|ar9300_swap_eeprom
argument_list|(
name|mptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*          * At this point, mptr points to the eeprom data structure          * in it's "default" state.  If this is big endian, swap the          * data structures back to "little endian" form.          */
if|if
condition|(
name|ar9300_eeprom_restore_internal
argument_list|(
name|ah
argument_list|,
name|mptr
argument_list|,
name|mdata_size
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|status
operator|=
name|AH_TRUE
expr_stmt|;
block|}
if|#
directive|if
name|AH_BYTE_ORDER
operator|==
name|AH_BIG_ENDIAN
comment|/* Second Swap, back to Big Endian */
name|ar9300_eeprom_template_swap
argument_list|()
expr_stmt|;
name|ar9300_swap_eeprom
argument_list|(
name|mptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ahp
operator|->
name|ah_2g_paprd_rate_mask_ht40
operator|=
name|mptr
operator|->
name|modal_header_2g
operator|.
name|paprd_rate_mask_ht40
expr_stmt|;
name|ahp
operator|->
name|ah_2g_paprd_rate_mask_ht20
operator|=
name|mptr
operator|->
name|modal_header_2g
operator|.
name|paprd_rate_mask_ht20
expr_stmt|;
name|ahp
operator|->
name|ah_5g_paprd_rate_mask_ht40
operator|=
name|mptr
operator|->
name|modal_header_5g
operator|.
name|paprd_rate_mask_ht40
expr_stmt|;
name|ahp
operator|->
name|ah_5g_paprd_rate_mask_ht20
operator|=
name|mptr
operator|->
name|modal_header_5g
operator|.
name|paprd_rate_mask_ht20
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|int32_t
name|ar9300_thermometer_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|thermometer
decl_stmt|;
name|thermometer
operator|=
operator|(
name|ahp
operator|->
name|ah_eeprom
operator|.
name|base_eep_header
operator|.
name|misc_configuration
operator|>>
literal|1
operator|)
operator|&
literal|0x3
expr_stmt|;
name|thermometer
operator|--
expr_stmt|;
return|return
name|thermometer
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_thermometer_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|int
name|thermometer
init|=
name|ar9300_thermometer_get
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* ch0_RXTX4 */
comment|/*#define AR_PHY_65NM_CH0_RXTX4       AR_PHY_65NM(ch0_RXTX4)*/
define|#
directive|define
name|AR_PHY_65NM_CH1_RXTX4
value|AR_PHY_65NM(ch1_RXTX4)
define|#
directive|define
name|AR_PHY_65NM_CH2_RXTX4
value|AR_PHY_65NM(ch2_RXTX4)
comment|/*#define AR_PHY_65NM_CH0_RXTX4_THERM_ON          0x10000000*/
comment|/*#define AR_PHY_65NM_CH0_RXTX4_THERM_ON_S        28*/
define|#
directive|define
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR_S
value|29
define|#
directive|define
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR
define|\
value|(0x1<<AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR_S)
if|if
condition|(
name|thermometer
operator|<
literal|0
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH1_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH2_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH1_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH2_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH1_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH2_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|thermometer
operator|==
literal|0
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH1_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH2_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|thermometer
operator|==
literal|1
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH1_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH2_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|thermometer
operator|==
literal|2
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH1_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH2_RXTX4
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4_THERM_ON
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|ar9300_tuning_caps_params_get
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|int
name|tuning_caps_params
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|tuning_caps_params
operator|=
name|eep
operator|->
name|base_eep_header
operator|.
name|params_for_tuning_caps
index|[
literal|0
index|]
expr_stmt|;
return|return
name|tuning_caps_params
return|;
block|}
end_function

begin_comment
comment|/*  * Read the tuning caps params from eeprom and set to correct register.  * To regulation the frequency accuracy.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_tuning_caps_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|int
name|tuning_caps_params
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
name|tuning_caps_params
operator|=
name|ar9300_tuning_caps_params_get
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eep
operator|->
name|base_eep_header
operator|.
name|feature_enable
operator|&
literal|0x40
operator|)
operator|>>
literal|6
condition|)
block|{
name|tuning_caps_params
operator|&=
literal|0x7f
expr_stmt|;
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
return|return
name|AH_TRUE
return|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_SCORPION_CH0_XTAL
argument_list|,
name|AR_OSPREY_CHO_XTAL_CAPINDAC
argument_list|,
name|tuning_caps_params
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_SCORPION_CH0_XTAL
argument_list|,
name|AR_OSPREY_CHO_XTAL_CAPOUTDAC
argument_list|,
name|tuning_caps_params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_OSPREY_CH0_XTAL
argument_list|,
name|AR_OSPREY_CHO_XTAL_CAPINDAC
argument_list|,
name|tuning_caps_params
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_OSPREY_CH0_XTAL
argument_list|,
name|AR_OSPREY_CHO_XTAL_CAPOUTDAC
argument_list|,
name|tuning_caps_params
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Read the tx_frame_to_xpa_on param from eeprom and apply the value to   * correct register.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_xpa_timing_control_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
name|u_int8_t
name|xpa_timing_control
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
if|if
condition|(
operator|(
name|eep
operator|->
name|base_eep_header
operator|.
name|feature_enable
operator|&
literal|0x80
operator|)
operator|>>
literal|7
condition|)
block|{
if|if
condition|(
name|AR_SREV_OSPREY
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_AR9580
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_2ghz
condition|)
block|{
name|xpa_timing_control
operator|=
name|eep
operator|->
name|modal_header_2g
operator|.
name|tx_frame_to_xpa_on
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_XPA_TIMING_CTL
argument_list|,
name|AR_PHY_XPA_TIMING_CTL_FRAME_XPAB_ON
argument_list|,
name|xpa_timing_control
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xpa_timing_control
operator|=
name|eep
operator|->
name|modal_header_5g
operator|.
name|tx_frame_to_xpa_on
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_XPA_TIMING_CTL
argument_list|,
name|AR_PHY_XPA_TIMING_CTL_FRAME_XPAA_ON
argument_list|,
name|xpa_timing_control
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Read the xLNA_bias_strength param from eeprom and apply the value to   * correct register.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_x_lNA_bias_strength_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
name|u_int8_t
name|x_lNABias
decl_stmt|;
name|u_int32_t
name|value
init|=
literal|0
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
if|if
condition|(
operator|(
name|eep
operator|->
name|base_eep_header
operator|.
name|misc_configuration
operator|&
literal|0x40
operator|)
operator|>>
literal|6
condition|)
block|{
if|if
condition|(
name|AR_SREV_OSPREY
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_2ghz
condition|)
block|{
name|x_lNABias
operator|=
name|eep
operator|->
name|modal_header_2g
operator|.
name|xLNA_bias_strength
expr_stmt|;
block|}
else|else
block|{
name|x_lNABias
operator|=
name|eep
operator|->
name|modal_header_5g
operator|.
name|xLNA_bias_strength
expr_stmt|;
block|}
name|value
operator|=
name|x_lNABias
operator|&
operator|(
literal|0x03
operator|)
expr_stmt|;
comment|// bit0,1 for chain0
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_RXTX4
argument_list|,
name|AR_PHY_65NM_RXTX4_XLNA_BIAS
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|x_lNABias
operator|>>
literal|2
operator|)
operator|&
operator|(
literal|0x03
operator|)
expr_stmt|;
comment|// bit2,3 for chain1
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH1_RXTX4
argument_list|,
name|AR_PHY_65NM_RXTX4_XLNA_BIAS
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|x_lNABias
operator|>>
literal|4
operator|)
operator|&
operator|(
literal|0x03
operator|)
expr_stmt|;
comment|// bit4,5 for chain2
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH2_RXTX4
argument_list|,
name|AR_PHY_65NM_RXTX4_XLNA_BIAS
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Read EEPROM header info and program the device for correct operation  * given the channel value.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_eeprom_set_board_values
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|)
block|{
name|ar9300_xpa_bias_level_apply
argument_list|(
name|ah
argument_list|,
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|ar9300_xpa_timing_control_apply
argument_list|(
name|ah
argument_list|,
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|ar9300_ant_ctrl_apply
argument_list|(
name|ah
argument_list|,
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|ar9300_drive_strength_apply
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar9300_x_lNA_bias_strength_apply
argument_list|(
name|ah
argument_list|,
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
comment|/* wait for Poseidon internal regular turnning */
comment|/* for Hornet we move it before initPLL to avoid an access issue */
comment|/* Function not used when EMULATION. */
if|if
condition|(
operator|!
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|ar9300_internal_regulator_apply
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
name|ar9300_attenuation_apply
argument_list|(
name|ah
argument_list|,
name|chan
operator|->
name|channel
argument_list|)
expr_stmt|;
name|ar9300_quick_drop_apply
argument_list|(
name|ah
argument_list|,
name|chan
operator|->
name|channel
argument_list|)
expr_stmt|;
name|ar9300_thermometer_apply
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|ar9300_tuning_caps_apply
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
name|ar9300_tx_end_to_xpab_off_apply
argument_list|(
name|ah
argument_list|,
name|chan
operator|->
name|channel
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|u_int8_t
modifier|*
name|ar9300_eeprom_get_spur_chans_ptr
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|is_2ghz
parameter_list|)
block|{
name|ar9300_eeprom_t
modifier|*
name|eep
init|=
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_eeprom
decl_stmt|;
if|if
condition|(
name|is_2ghz
condition|)
block|{
return|return
operator|&
operator|(
name|eep
operator|->
name|modal_header_2g
operator|.
name|spur_chans
index|[
literal|0
index|]
operator|)
return|;
block|}
else|else
block|{
return|return
operator|&
operator|(
name|eep
operator|->
name|modal_header_5g
operator|.
name|spur_chans
index|[
literal|0
index|]
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|ar9300_eeprom_get_tx_gain_table_number_max
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|unsigned
name|long
name|tx_gain_table_max
decl_stmt|;
name|tx_gain_table_max
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPC_7
argument_list|,
name|AR_PHY_TPC_7_TX_GAIN_TABLE_MAX
argument_list|)
expr_stmt|;
return|return
name|tx_gain_table_max
return|;
block|}
end_function

begin_function
name|u_int8_t
name|ar9300_eeprom_tx_gain_table_index_max_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|channel
parameter_list|)
block|{
name|unsigned
name|int
name|index
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|ahp_Eeprom
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|ahp_Eeprom
operator|=
operator|&
name|ahp
operator|->
name|ah_eeprom
expr_stmt|;
if|if
condition|(
name|ahp_Eeprom
operator|->
name|base_ext1
operator|.
name|misc_enable
operator|==
literal|0
condition|)
return|return
name|AH_FALSE
return|;
if|if
condition|(
name|channel
operator|<
literal|4000
condition|)
block|{
name|index
operator|=
name|ahp_Eeprom
operator|->
name|modal_header_2g
operator|.
name|tx_gain_cap
expr_stmt|;
block|}
else|else
block|{
name|index
operator|=
name|ahp_Eeprom
operator|->
name|modal_header_5g
operator|.
name|tx_gain_cap
expr_stmt|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TPC_7
argument_list|,
name|AR_PHY_TPC_7_TX_GAIN_TABLE_MAX
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|ar9300_eeprom_get_pcdac_tx_gain_table_i
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|i
parameter_list|,
name|u_int8_t
modifier|*
name|pcdac
parameter_list|)
block|{
name|unsigned
name|long
name|tx_gain
decl_stmt|;
name|u_int8_t
name|tx_gain_table_max
decl_stmt|;
name|tx_gain_table_max
operator|=
name|ar9300_eeprom_get_tx_gain_table_number_max
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
name|tx_gain_table_max
condition|)
block|{
operator|*
name|pcdac
operator|=
literal|0
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|tx_gain
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TXGAIN_TAB
argument_list|(
literal|1
argument_list|)
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
operator|*
name|pcdac
operator|=
operator|(
operator|(
name|tx_gain
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|u_int8_t
name|ar9300_eeprom_set_tx_gain_cap
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
modifier|*
name|tx_gain_max
parameter_list|)
comment|// pcdac read back from reg, read back value depends on reset 2GHz/5GHz ini
comment|// tx_gain_table, this function will be called twice after each
comment|// band's calibration.
comment|// after 2GHz cal, tx_gain_max[0] has 2GHz, calibration max txgain,
comment|// tx_gain_max[1]=-100
comment|// after 5GHz cal, tx_gain_max[0],tx_gain_max[1] have calibration
comment|// value for both band
comment|// reset is on 5GHz, reg reading from tx_gain_table is for 5GHz,
comment|// so program can't recalculate 2g.tx_gain_cap at this point.
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|ig
decl_stmt|,
name|im
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|pcdac
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|tx_gain_table_max
decl_stmt|;
name|ar9300_eeprom_t
modifier|*
name|ahp_Eeprom
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|ahp_Eeprom
operator|=
operator|&
name|ahp
operator|->
name|ah_eeprom
expr_stmt|;
if|if
condition|(
name|ahp_Eeprom
operator|->
name|base_ext1
operator|.
name|misc_enable
operator|==
literal|0
condition|)
return|return
name|AH_FALSE
return|;
name|tx_gain_table_max
operator|=
name|ar9300_eeprom_get_tx_gain_table_number_max
argument_list|(
name|ah
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tx_gain_max
index|[
name|i
index|]
operator|>
operator|-
literal|100
condition|)
block|{
comment|// -100 didn't cal that band.
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tx_gain_max
index|[
literal|1
index|]
operator|>
operator|-
literal|100
condition|)
block|{
continue|continue;
comment|// both band are calibrated, skip 2GHz 2g.tx_gain_cap reset
block|}
block|}
for|for
control|(
name|ig
operator|=
literal|1
init|;
name|ig
operator|<=
name|tx_gain_table_max
condition|;
name|ig
operator|++
control|)
block|{
if|if
condition|(
name|ah
operator|!=
literal|0
operator|&&
name|ah
operator|->
name|ah_reset
operator|!=
literal|0
condition|)
block|{
name|ar9300_eeprom_get_pcdac_tx_gain_table_i
argument_list|(
name|ah
argument_list|,
name|ig
argument_list|,
operator|&
name|pcdac
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcdac
operator|>=
name|tx_gain_max
index|[
name|i
index|]
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|ig
operator|+
literal|1
operator|<=
name|tx_gain_table_max
condition|)
block|{
if|if
condition|(
name|pcdac
operator|==
name|tx_gain_max
index|[
name|i
index|]
condition|)
name|im
operator|=
name|ig
expr_stmt|;
else|else
name|im
operator|=
name|ig
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|ahp_Eeprom
operator|->
name|modal_header_2g
operator|.
name|tx_gain_cap
operator|=
name|im
expr_stmt|;
block|}
else|else
block|{
name|ahp_Eeprom
operator|->
name|modal_header_5g
operator|.
name|tx_gain_cap
operator|=
name|im
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|ahp_Eeprom
operator|->
name|modal_header_2g
operator|.
name|tx_gain_cap
operator|=
name|ig
expr_stmt|;
block|}
else|else
block|{
name|ahp_Eeprom
operator|->
name|modal_header_5g
operator|.
name|tx_gain_cap
operator|=
name|ig
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AH_SUPPORT_AR9300 */
end_comment

end_unit

