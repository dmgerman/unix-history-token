begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012,2013 Joseph Koshy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<libelftc.h>
end_include

begin_include
include|#
directive|include
file|"_elftc.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: isa.c 2934 2013-03-30 01:40:49Z jkoshy $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Option handling.  */
end_comment

begin_enum
enum|enum
name|isa_mode
block|{
name|ISA_MODE_DECODE
block|,
name|ISA_MODE_ENCODE
block|,
name|ISA_MODE_QUERY
block|}
enum|;
end_enum

begin_enum
enum|enum
name|isa_submode
block|{
name|ISA_SUBMODE_GENERATE_TESTS
block|,
name|ISA_SUBMODE_LIST_INSTRUCTIONS
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|ISA_OPT_DRY_RUN
value|0x0001
end_define

begin_define
define|#
directive|define
name|ISA_OPT_NO_WARNINGS
value|0x0002
end_define

begin_define
define|#
directive|define
name|ISA_OPT_VERBOSE
value|0x0004
end_define

begin_comment
comment|/* Record a option. */
end_comment

begin_struct
struct|struct
name|isa_option
block|{
specifier|const
name|char
modifier|*
name|isa_option
decl_stmt|;
name|SLIST_ENTRY
argument_list|(
argument|isa_option
argument_list|)
name|isa_next
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|isa_config
block|{
name|unsigned
name|int
name|isa_flags
decl_stmt|;
name|enum
name|isa_mode
name|isa_mode
decl_stmt|;
name|enum
name|isa_submode
name|isa_submode
decl_stmt|;
name|int
name|isa_ntests
decl_stmt|;
name|int
name|isa_seed
decl_stmt|;
specifier|const
name|char
modifier|*
name|isa_arch
decl_stmt|;
specifier|const
name|char
modifier|*
name|isa_input
decl_stmt|;
specifier|const
name|char
modifier|*
name|isa_output
decl_stmt|;
specifier|const
name|char
modifier|*
name|isa_prefix
decl_stmt|;
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|isa_option
argument_list|)
name|isa_cpus
expr_stmt|;
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|isa_option
argument_list|)
name|isa_specs
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ISA_MAX_LONG_OPTION_LENGTH
value|64
end_define

begin_decl_stmt
specifier|static
name|struct
name|option
name|isa_long_options
index|[]
init|=
block|{
block|{
literal|"arch"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"cpu"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"decode"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"dry-run"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"encode"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'E'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"input"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"list-instructions"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'L'
block|}
block|,
block|{
literal|"ntests"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'N'
block|}
block|,
block|{
literal|"output"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
block|{
literal|"prefix"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"query"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'Q'
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"random-seed"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'R'
block|}
block|,
block|{
literal|"spec"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"test"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'T'
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|isa_usage_message
init|=
literal|"\ usage: %s [options] [command] [specfiles]...\n\     Process an instruction set specification.\n\ \n\ Supported values for 'command' are:\n\     decode	Build an instruction stream decoder.\n\     encode	Build an instruction stream encoder.\n\     query	(default) Retrieve information about an instruction set.\n\ \n\ Supported global options are:\n\     -a ARCH | --arch ARCH    Process instruction specifications for ARCH.\n\     -c CPU  | --cpu CPU      Process instruction specifications for CPU.\n\     -n      | --dry-run      Exit after checking inputs for errors.\n\     -s FILE | --spec FILE    Read instruction specifications from FILE.\n\     -q      | --quiet        Suppress warning messages.\n\     -v      | --verbose      Be verbose.\n\     -V      | --version      Display a version identifier and exit.\n\ \n\ Supported options for command 'decode' are:\n\     -i FILE | --input FILE   Read source to be expanded from FILE.\n\     -o FILE | --output FILE  Write generated output to FILE.\n\ \n\ Supported options for command 'encode' are:\n\     -o FILE | --output FILE  Write generated output to FILE.\n\     -p STR | --prefix STR    Use STR as a prefix for generated symbols.\n\ \n\ Supported options for command 'query' are:\n\     -L | --list-instructions Generate a list of all known instructions.\n\     -N NUM | --ntests NUM    Specify the number of test sequences generated.\n\     -R N   | --random-seed N Use N as the random number generator seed.\n\     -T     | --test          Generate test sequences.\n\ "
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|isa_usage
parameter_list|(
name|int
name|iserror
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
modifier|...
parameter_list|)
block|{
name|FILE
modifier|*
name|channel
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|channel
operator|=
name|iserror
condition|?
name|stderr
else|:
name|stdout
expr_stmt|;
if|if
condition|(
name|message
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|message
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|channel
argument_list|,
name|message
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|channel
argument_list|,
name|isa_usage_message
argument_list|,
name|ELFTC_GETPROGNAME
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|iserror
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isa_unimplemented
parameter_list|(
name|int
name|option
parameter_list|,
name|int
name|option_index
parameter_list|,
name|struct
name|option
modifier|*
name|options_table
parameter_list|)
block|{
name|char
name|msgbuf
index|[
name|ISA_MAX_LONG_OPTION_LENGTH
index|]
decl_stmt|;
if|if
condition|(
name|option_index
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|"\"--%s\""
argument_list|,
name|options_table
index|[
name|option_index
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
literal|"'-%c'"
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"ERROR: option %s is unimplemented."
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|isa_option
modifier|*
name|isa_make_option
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|isa_option
modifier|*
name|isa_opt
decl_stmt|;
if|if
condition|(
operator|(
name|isa_opt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|isa_opt
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|isa_opt
operator|->
name|isa_option
operator|=
name|optarg
expr_stmt|;
return|return
operator|(
name|isa_opt
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|option
decl_stmt|,
name|option_index
decl_stmt|;
name|struct
name|isa_option
modifier|*
name|isa_opt
decl_stmt|;
name|struct
name|isa_config
name|config
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|config
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|config
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|.
name|isa_mode
operator|=
name|ISA_MODE_QUERY
expr_stmt|;
name|config
operator|.
name|isa_arch
operator|=
name|config
operator|.
name|isa_input
operator|=
name|config
operator|.
name|isa_output
operator|=
name|config
operator|.
name|isa_prefix
operator|=
name|NULL
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|config
operator|.
name|isa_cpus
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|config
operator|.
name|isa_specs
argument_list|)
expr_stmt|;
for|for
control|(
name|option_index
operator|=
operator|-
literal|1
init|;
operator|(
name|option
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:c:hi:no:p:qs:vDELN:QR:TV"
argument_list|,
name|isa_long_options
argument_list|,
operator|&
name|option_index
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|;
name|option_index
operator|=
operator|-
literal|1
control|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
literal|'h'
case|:
name|isa_usage
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s (%s)\n"
argument_list|,
name|ELFTC_GETPROGNAME
argument_list|()
argument_list|,
name|elftc_version
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|config
operator|.
name|isa_arch
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
operator|(
name|isa_opt
operator|=
name|isa_make_option
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|config
operator|.
name|isa_cpus
argument_list|,
name|isa_opt
argument_list|,
name|isa_next
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|config
operator|.
name|isa_input
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|config
operator|.
name|isa_flags
operator||=
name|ISA_OPT_DRY_RUN
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|config
operator|.
name|isa_output
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|config
operator|.
name|isa_prefix
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|config
operator|.
name|isa_flags
operator||=
name|ISA_OPT_NO_WARNINGS
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|(
name|isa_opt
operator|=
name|isa_make_option
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|config
operator|.
name|isa_specs
argument_list|,
name|isa_opt
argument_list|,
name|isa_next
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|config
operator|.
name|isa_flags
operator||=
name|ISA_OPT_VERBOSE
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|config
operator|.
name|isa_mode
operator|=
name|ISA_MODE_DECODE
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|config
operator|.
name|isa_mode
operator|=
name|ISA_MODE_ENCODE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|config
operator|.
name|isa_submode
operator|=
name|ISA_SUBMODE_LIST_INSTRUCTIONS
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|config
operator|.
name|isa_ntests
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|config
operator|.
name|isa_mode
operator|=
name|ISA_MODE_QUERY
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|config
operator|.
name|isa_seed
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|config
operator|.
name|isa_submode
operator|=
name|ISA_SUBMODE_GENERATE_TESTS
expr_stmt|;
break|break;
default|default:
name|isa_usage
argument_list|(
literal|1
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Create the canonical list of specification files to 	 * be processed. 	 */
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|isa_opt
operator|=
name|isa_make_option
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|config
operator|.
name|isa_specs
argument_list|,
name|isa_opt
argument_list|,
name|isa_next
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
label|:
name|err
argument_list|(
literal|1
argument_list|,
literal|"ERROR: Invocation failed"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

