begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: mdoc_man.c,v 1.57 2013/12/25 22:00:45 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2011, 2012, 2013 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"out.h"
end_include

begin_include
include|#
directive|include
file|"man.h"
end_include

begin_include
include|#
directive|include
file|"mdoc.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_define
define|#
directive|define
name|DECL_ARGS
value|const struct mdoc_meta *meta, \ 		  const struct mdoc_node *n
end_define

begin_struct
struct|struct
name|manact
block|{
name|int
function_decl|(
modifier|*
name|cond
function_decl|)
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
comment|/* DON'T run actions */
name|int
function_decl|(
modifier|*
name|pre
function_decl|)
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
comment|/* pre-node action */
name|void
function_decl|(
modifier|*
name|post
function_decl|)
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
comment|/* post-node action */
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* pre-node string constant */
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
comment|/* post-node string constant */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|cond_body
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cond_head
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|font_push
parameter_list|(
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|font_pop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mid_it
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post__t
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_bd
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_bf
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_bk
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_bl
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_dl
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_enc
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_eo
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_fa
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_fd
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_fl
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_fn
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_fo
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_font
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_in
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_it
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_lb
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_nm
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_percent
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_pf
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_sect
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_sp
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_vt
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre__t
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_an
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_ap
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_bd
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_bf
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_bk
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_bl
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_br
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_bx
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_dl
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_enc
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_em
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_fa
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_fd
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_fl
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_fn
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_fo
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_ft
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_in
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_it
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_lk
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_li
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_nm
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_no
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_ns
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_pp
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_rs
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_sm
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_sp
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_sect
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_sy
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pre_syn
parameter_list|(
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_vt
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_ux
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_xr
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_word
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_line
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_block
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_offs
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_width
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_count
parameter_list|(
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_node
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|manact
name|manacts
index|[
name|MDOC_MAX
operator|+
literal|1
index|]
init|=
block|{
block|{
name|NULL
block|,
name|pre_ap
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ap */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dd */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dt */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Os */
block|{
name|NULL
block|,
name|pre_sect
block|,
name|post_sect
block|,
literal|".SH"
block|,
name|NULL
block|}
block|,
comment|/* Sh */
block|{
name|NULL
block|,
name|pre_sect
block|,
name|post_sect
block|,
literal|".SS"
block|,
name|NULL
block|}
block|,
comment|/* Ss */
block|{
name|NULL
block|,
name|pre_pp
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Pp */
block|{
name|cond_body
block|,
name|pre_dl
block|,
name|post_dl
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* D1 */
block|{
name|cond_body
block|,
name|pre_dl
block|,
name|post_dl
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dl */
block|{
name|cond_body
block|,
name|pre_bd
block|,
name|post_bd
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bd */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ed */
block|{
name|cond_body
block|,
name|pre_bl
block|,
name|post_bl
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bl */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* El */
block|{
name|NULL
block|,
name|pre_it
block|,
name|post_it
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* It */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ad */
block|{
name|NULL
block|,
name|pre_an
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* An */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ar */
block|{
name|NULL
block|,
name|pre_sy
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Cd */
block|{
name|NULL
block|,
name|pre_sy
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Cm */
block|{
name|NULL
block|,
name|pre_li
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dv */
block|{
name|NULL
block|,
name|pre_li
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Er */
block|{
name|NULL
block|,
name|pre_li
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ev */
block|{
name|NULL
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"The \\fB"
block|,
literal|"\\fP\nutility exits 0 on success, and>0 if an error occurs."
block|}
block|,
comment|/* Ex */
block|{
name|NULL
block|,
name|pre_fa
block|,
name|post_fa
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fa */
block|{
name|NULL
block|,
name|pre_fd
block|,
name|post_fd
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fd */
block|{
name|NULL
block|,
name|pre_fl
block|,
name|post_fl
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fl */
block|{
name|NULL
block|,
name|pre_fn
block|,
name|post_fn
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fn */
block|{
name|NULL
block|,
name|pre_ft
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ft */
block|{
name|NULL
block|,
name|pre_sy
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ic */
block|{
name|NULL
block|,
name|pre_in
block|,
name|post_in
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* In */
block|{
name|NULL
block|,
name|pre_li
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Li */
block|{
name|cond_head
block|,
name|pre_enc
block|,
name|NULL
block|,
literal|"\\- "
block|,
name|NULL
block|}
block|,
comment|/* Nd */
block|{
name|NULL
block|,
name|pre_nm
block|,
name|post_nm
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Nm */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"["
block|,
literal|"]"
block|}
block|,
comment|/* Op */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ot */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Pa */
block|{
name|NULL
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"The \\fB"
block|,
literal|"\\fP\nfunction returns the value 0 if successful;\n"
literal|"otherwise the value -1 is returned and the global\n"
literal|"variable \\fIerrno\\fP is set to indicate the error."
block|}
block|,
comment|/* Rv */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* St */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Va */
block|{
name|NULL
block|,
name|pre_vt
block|,
name|post_vt
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Vt */
block|{
name|NULL
block|,
name|pre_xr
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Xr */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %A */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %B */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %D */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %I */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %J */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %N */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %O */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %P */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %R */
block|{
name|NULL
block|,
name|pre__t
block|,
name|post__t
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %T */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %V */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ac */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"<"
block|,
literal|">"
block|}
block|,
comment|/* Ao */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"<"
block|,
literal|">"
block|}
block|,
comment|/* Aq */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* At */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bc */
block|{
name|NULL
block|,
name|pre_bf
block|,
name|post_bf
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bf */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"["
block|,
literal|"]"
block|}
block|,
comment|/* Bo */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"["
block|,
literal|"]"
block|}
block|,
comment|/* Bq */
block|{
name|NULL
block|,
name|pre_ux
block|,
name|NULL
block|,
literal|"BSD/OS"
block|,
name|NULL
block|}
block|,
comment|/* Bsx */
block|{
name|NULL
block|,
name|pre_bx
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bx */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Db */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dc */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"\\(lq"
block|,
literal|"\\(rq"
block|}
block|,
comment|/* Do */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"\\(lq"
block|,
literal|"\\(rq"
block|}
block|,
comment|/* Dq */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ec */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ef */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Em */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_eo
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Eo */
block|{
name|NULL
block|,
name|pre_ux
block|,
name|NULL
block|,
literal|"FreeBSD"
block|,
name|NULL
block|}
block|,
comment|/* Fx */
block|{
name|NULL
block|,
name|pre_sy
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ms */
block|{
name|NULL
block|,
name|pre_no
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* No */
block|{
name|NULL
block|,
name|pre_ns
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ns */
block|{
name|NULL
block|,
name|pre_ux
block|,
name|NULL
block|,
literal|"NetBSD"
block|,
name|NULL
block|}
block|,
comment|/* Nx */
block|{
name|NULL
block|,
name|pre_ux
block|,
name|NULL
block|,
literal|"OpenBSD"
block|,
name|NULL
block|}
block|,
comment|/* Ox */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Pc */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_pf
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Pf */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"("
block|,
literal|")"
block|}
block|,
comment|/* Po */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"("
block|,
literal|")"
block|}
block|,
comment|/* Pq */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Qc */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"\\(oq"
block|,
literal|"\\(cq"
block|}
block|,
comment|/* Ql */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"\""
block|,
literal|"\""
block|}
block|,
comment|/* Qo */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"\""
block|,
literal|"\""
block|}
block|,
comment|/* Qq */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Re */
block|{
name|cond_body
block|,
name|pre_rs
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Rs */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Sc */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"\\(oq"
block|,
literal|"\\(cq"
block|}
block|,
comment|/* So */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"\\(oq"
block|,
literal|"\\(cq"
block|}
block|,
comment|/* Sq */
block|{
name|NULL
block|,
name|pre_sm
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Sm */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Sx */
block|{
name|NULL
block|,
name|pre_sy
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Sy */
block|{
name|NULL
block|,
name|pre_li
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Tn */
block|{
name|NULL
block|,
name|pre_ux
block|,
name|NULL
block|,
literal|"UNIX"
block|,
name|NULL
block|}
block|,
comment|/* Ux */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Xc */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Xo */
block|{
name|NULL
block|,
name|pre_fo
block|,
name|post_fo
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fo */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fc */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"["
block|,
literal|"]"
block|}
block|,
comment|/* Oo */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Oc */
block|{
name|NULL
block|,
name|pre_bk
block|,
name|post_bk
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bk */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ek */
block|{
name|NULL
block|,
name|pre_ux
block|,
name|NULL
block|,
literal|"is currently in beta test."
block|,
name|NULL
block|}
block|,
comment|/* Bt */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Hf */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fr */
block|{
name|NULL
block|,
name|pre_ux
block|,
name|NULL
block|,
literal|"currently under development."
block|,
name|NULL
block|}
block|,
comment|/* Ud */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_lb
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Lb */
block|{
name|NULL
block|,
name|pre_pp
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Lp */
block|{
name|NULL
block|,
name|pre_lk
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Lk */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Mt */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"{"
block|,
literal|"}"
block|}
block|,
comment|/* Brq */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"{"
block|,
literal|"}"
block|}
block|,
comment|/* Bro */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Brc */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %C */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Es */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* En */
block|{
name|NULL
block|,
name|pre_ux
block|,
name|NULL
block|,
literal|"DragonFly"
block|,
name|NULL
block|}
block|,
comment|/* Dx */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %Q */
block|{
name|NULL
block|,
name|pre_br
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* br */
block|{
name|NULL
block|,
name|pre_sp
block|,
name|post_sp
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* sp */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %U */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ta */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* ROOT */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|outflags
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MMAN_spc
value|(1<< 0)
end_define

begin_comment
comment|/* blank character before next word */
end_comment

begin_define
define|#
directive|define
name|MMAN_spc_force
value|(1<< 1)
end_define

begin_comment
comment|/* even before trailing punctuation */
end_comment

begin_define
define|#
directive|define
name|MMAN_nl
value|(1<< 2)
end_define

begin_comment
comment|/* break man(7) code line */
end_comment

begin_define
define|#
directive|define
name|MMAN_br
value|(1<< 3)
end_define

begin_comment
comment|/* break output line */
end_comment

begin_define
define|#
directive|define
name|MMAN_sp
value|(1<< 4)
end_define

begin_comment
comment|/* insert a blank output line */
end_comment

begin_define
define|#
directive|define
name|MMAN_PP
value|(1<< 5)
end_define

begin_comment
comment|/* reset indentation etc. */
end_comment

begin_define
define|#
directive|define
name|MMAN_Sm
value|(1<< 6)
end_define

begin_comment
comment|/* horizontal spacing mode */
end_comment

begin_define
define|#
directive|define
name|MMAN_Bk
value|(1<< 7)
end_define

begin_comment
comment|/* word keep mode */
end_comment

begin_define
define|#
directive|define
name|MMAN_Bk_susp
value|(1<< 8)
end_define

begin_comment
comment|/* suspend this (after a macro) */
end_comment

begin_define
define|#
directive|define
name|MMAN_An_split
value|(1<< 9)
end_define

begin_comment
comment|/* author mode is "split" */
end_comment

begin_define
define|#
directive|define
name|MMAN_An_nosplit
value|(1<< 10)
end_define

begin_comment
comment|/* author mode is "nosplit" */
end_comment

begin_define
define|#
directive|define
name|MMAN_PD
value|(1<< 11)
end_define

begin_comment
comment|/* inter-paragraph spacing disabled */
end_comment

begin_define
define|#
directive|define
name|MMAN_nbrword
value|(1<< 12)
end_define

begin_comment
comment|/* do not break the next word */
end_comment

begin_define
define|#
directive|define
name|BL_STACK_MAX
value|32
end_define

begin_decl_stmt
specifier|static
name|size_t
name|Bl_stack
index|[
name|BL_STACK_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offsets [chars] */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Bl_stack_post
index|[
name|BL_STACK_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* add final .RE */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Bl_stack_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of nested Bl blocks */
end_comment

begin_decl_stmt
specifier|static
name|int
name|TPremain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* characters before tag is full */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|head
decl_stmt|;
name|char
modifier|*
name|tail
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|}
name|fontqueue
struct|;
end_struct

begin_function
specifier|static
name|void
name|font_push
parameter_list|(
name|char
name|newfont
parameter_list|)
block|{
if|if
condition|(
name|fontqueue
operator|.
name|head
operator|+
name|fontqueue
operator|.
name|size
operator|<=
operator|++
name|fontqueue
operator|.
name|tail
condition|)
block|{
name|fontqueue
operator|.
name|size
operator|+=
literal|8
expr_stmt|;
name|fontqueue
operator|.
name|head
operator|=
name|mandoc_realloc
argument_list|(
name|fontqueue
operator|.
name|head
argument_list|,
name|fontqueue
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
operator|*
name|fontqueue
operator|.
name|tail
operator|=
name|newfont
expr_stmt|;
name|print_word
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\\f"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|newfont
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|font_pop
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|fontqueue
operator|.
name|tail
operator|>
name|fontqueue
operator|.
name|head
condition|)
name|fontqueue
operator|.
name|tail
operator|--
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\\f"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|fontqueue
operator|.
name|tail
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_word
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|(
name|MMAN_PP
operator||
name|MMAN_sp
operator||
name|MMAN_br
operator||
name|MMAN_nl
operator|)
operator|&
name|outflags
condition|)
block|{
comment|/*  		 * If we need a newline, print it now and start afresh. 		 */
if|if
condition|(
name|MMAN_PP
operator|&
name|outflags
condition|)
block|{
if|if
condition|(
name|MMAN_sp
operator|&
name|outflags
condition|)
block|{
if|if
condition|(
name|MMAN_PD
operator|&
name|outflags
condition|)
block|{
name|printf
argument_list|(
literal|"\n.PD"
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_PD
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|MMAN_PD
operator|&
name|outflags
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n.PD 0"
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_PD
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n.PP\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MMAN_sp
operator|&
name|outflags
condition|)
name|printf
argument_list|(
literal|"\n.sp\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MMAN_br
operator|&
name|outflags
condition|)
name|printf
argument_list|(
literal|"\n.br\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MMAN_nl
operator|&
name|outflags
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_PP
operator||
name|MMAN_sp
operator||
name|MMAN_br
operator||
name|MMAN_nl
operator||
name|MMAN_spc
operator|)
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|TPremain
condition|)
name|printf
argument_list|(
literal|".br\n"
argument_list|)
expr_stmt|;
name|TPremain
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MMAN_spc
operator|&
name|outflags
condition|)
block|{
comment|/* 		 * If we need a space, only print it if 		 * (1) it is forced by `No' or 		 * (2) what follows is not terminating punctuation or 		 * (3) what follows is longer than one character. 		 */
if|if
condition|(
name|MMAN_spc_force
operator|&
name|outflags
operator|||
literal|'\0'
operator|==
name|s
index|[
literal|0
index|]
operator|||
name|NULL
operator|==
name|strchr
argument_list|(
literal|".,:;)]?!"
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|)
operator|||
literal|'\0'
operator|!=
name|s
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|MMAN_Bk
operator|&
name|outflags
operator|&&
operator|!
operator|(
name|MMAN_Bk_susp
operator|&
name|outflags
operator|)
condition|)
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|TPremain
condition|)
name|TPremain
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * Reassign needing space if we're not following opening 	 * punctuation. 	 */
if|if
condition|(
name|MMAN_Sm
operator|&
name|outflags
operator|&&
operator|(
literal|'\0'
operator|==
name|s
index|[
literal|0
index|]
operator|||
operator|(
operator|(
literal|'('
operator|!=
name|s
index|[
literal|0
index|]
operator|&&
literal|'['
operator|!=
name|s
index|[
literal|0
index|]
operator|)
operator|||
literal|'\0'
operator|!=
name|s
index|[
literal|1
index|]
operator|)
operator|)
condition|)
name|outflags
operator||=
name|MMAN_spc
expr_stmt|;
else|else
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_spc_force
operator||
name|MMAN_Bk_susp
operator|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
operator|(
name|ASCII_NBRSP
operator|)
case|:
name|printf
argument_list|(
literal|"\\ "
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|ASCII_HYPH
operator|)
case|:
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|' '
operator|)
case|:
if|if
condition|(
name|MMAN_nbrword
operator|&
name|outflags
condition|)
block|{
name|printf
argument_list|(
literal|"\\ "
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
name|putchar
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TPremain
condition|)
name|TPremain
operator|--
expr_stmt|;
block|}
name|outflags
operator|&=
operator|~
name|MMAN_nbrword
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_line
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|newflags
parameter_list|)
block|{
name|outflags
operator|&=
operator|~
name|MMAN_br
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
name|print_word
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|newflags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_block
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|newflags
parameter_list|)
block|{
name|outflags
operator|&=
operator|~
name|MMAN_PP
expr_stmt|;
if|if
condition|(
name|MMAN_sp
operator|&
name|outflags
condition|)
block|{
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_sp
operator||
name|MMAN_br
operator|)
expr_stmt|;
if|if
condition|(
name|MMAN_PD
operator|&
name|outflags
condition|)
block|{
name|print_line
argument_list|(
literal|".PD"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_PD
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|MMAN_PD
operator|&
name|outflags
operator|)
condition|)
name|print_line
argument_list|(
literal|".PD 0"
argument_list|,
name|MMAN_PD
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
name|print_word
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_Bk_susp
operator||
name|newflags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_offs
parameter_list|(
specifier|const
name|char
modifier|*
name|v
parameter_list|)
block|{
name|char
name|buf
index|[
literal|24
index|]
decl_stmt|;
name|struct
name|roffsu
name|su
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|print_line
argument_list|(
literal|".RS"
argument_list|,
name|MMAN_Bk_susp
argument_list|)
expr_stmt|;
comment|/* Convert v into a number (of characters). */
if|if
condition|(
name|NULL
operator|==
name|v
operator|||
literal|'\0'
operator|==
operator|*
name|v
operator|||
literal|0
operator|==
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"left"
argument_list|)
condition|)
name|sz
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"indent"
argument_list|)
condition|)
name|sz
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"indent-two"
argument_list|)
condition|)
name|sz
operator|=
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
name|a2roffsu
argument_list|(
name|v
argument_list|,
operator|&
name|su
argument_list|,
name|SCALE_MAX
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCALE_EN
operator|==
name|su
operator|.
name|unit
condition|)
name|sz
operator|=
name|su
operator|.
name|scale
expr_stmt|;
else|else
block|{
comment|/* 			 * XXX 			 * If we are inside an enclosing list, 			 * there is no easy way to add the two 			 * indentations because they are provided 			 * in terms of different units. 			 */
name|print_word
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
return|return;
block|}
block|}
else|else
name|sz
operator|=
name|strlen
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* 	 * We are inside an enclosing list. 	 * Add the two indentations. 	 */
if|if
condition|(
name|Bl_stack_len
condition|)
name|sz
operator|+=
name|Bl_stack
index|[
name|Bl_stack_len
operator|-
literal|1
index|]
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%zun"
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up the indentation for a list item; used from pre_it().  */
end_comment

begin_function
name|void
name|print_width
parameter_list|(
specifier|const
name|char
modifier|*
name|v
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|child
parameter_list|,
name|size_t
name|defsz
parameter_list|)
block|{
name|char
name|buf
index|[
literal|24
index|]
decl_stmt|;
name|struct
name|roffsu
name|su
decl_stmt|;
name|size_t
name|sz
decl_stmt|,
name|chsz
decl_stmt|;
name|int
name|numeric
decl_stmt|,
name|remain
decl_stmt|;
name|numeric
operator|=
literal|1
expr_stmt|;
name|remain
operator|=
literal|0
expr_stmt|;
comment|/* Convert v into a number (of characters). */
if|if
condition|(
name|NULL
operator|==
name|v
condition|)
name|sz
operator|=
name|defsz
expr_stmt|;
elseif|else
if|if
condition|(
name|a2roffsu
argument_list|(
name|v
argument_list|,
operator|&
name|su
argument_list|,
name|SCALE_MAX
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCALE_EN
operator|==
name|su
operator|.
name|unit
condition|)
name|sz
operator|=
name|su
operator|.
name|scale
expr_stmt|;
else|else
block|{
name|sz
operator|=
literal|0
expr_stmt|;
name|numeric
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|sz
operator|=
name|strlen
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* XXX Rough estimation, might have multiple parts. */
name|chsz
operator|=
operator|(
name|NULL
operator|!=
name|child
operator|&&
name|MDOC_TEXT
operator|==
name|child
operator|->
name|type
operator|)
condition|?
name|strlen
argument_list|(
name|child
operator|->
name|string
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* Maybe we are inside an enclosing list? */
name|mid_it
argument_list|()
expr_stmt|;
comment|/* 	 * Save our own indentation, 	 * such that child lists can use it. 	 */
name|Bl_stack
index|[
name|Bl_stack_len
operator|++
index|]
operator|=
name|sz
operator|+
literal|2
expr_stmt|;
comment|/* Set up the current list. */
if|if
condition|(
name|defsz
operator|&&
name|chsz
operator|>
name|sz
condition|)
name|print_block
argument_list|(
literal|".HP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|print_block
argument_list|(
literal|".TP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|remain
operator|=
name|sz
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|numeric
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%zun"
argument_list|,
name|sz
operator|+
literal|2
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|print_word
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|TPremain
operator|=
name|remain
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_count
parameter_list|(
name|int
modifier|*
name|count
parameter_list|)
block|{
name|char
name|buf
index|[
literal|12
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d."
argument_list|,
operator|++
operator|*
name|count
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|man_man
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|struct
name|man
modifier|*
name|man
parameter_list|)
block|{
comment|/* 	 * Dump the keep buffer. 	 * We're guaranteed by now that this exists (is non-NULL). 	 * Flush stdout afterward, just in case. 	 */
name|fputs
argument_list|(
name|mparse_getkeep
argument_list|(
name|man_mparse
argument_list|(
name|man
argument_list|)
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|man_mdoc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|struct
name|mdoc
modifier|*
name|mdoc
parameter_list|)
block|{
specifier|const
name|struct
name|mdoc_meta
modifier|*
name|meta
decl_stmt|;
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
decl_stmt|;
name|meta
operator|=
name|mdoc_meta
argument_list|(
name|mdoc
argument_list|)
expr_stmt|;
name|n
operator|=
name|mdoc_node
argument_list|(
name|mdoc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".TH \"%s\" \"%s\" \"%s\" \"%s\" \"%s\"\n"
argument_list|,
name|meta
operator|->
name|title
argument_list|,
name|meta
operator|->
name|msec
argument_list|,
name|meta
operator|->
name|date
argument_list|,
name|meta
operator|->
name|os
argument_list|,
name|meta
operator|->
name|vol
argument_list|)
expr_stmt|;
comment|/* Disable hyphenation and if nroff, disable justification. */
name|printf
argument_list|(
literal|".nh\n.if n .ad l"
argument_list|)
expr_stmt|;
name|outflags
operator|=
name|MMAN_nl
operator||
name|MMAN_Sm
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|fontqueue
operator|.
name|size
condition|)
block|{
name|fontqueue
operator|.
name|size
operator|=
literal|8
expr_stmt|;
name|fontqueue
operator|.
name|head
operator|=
name|fontqueue
operator|.
name|tail
operator|=
name|mandoc_malloc
argument_list|(
literal|8
argument_list|)
expr_stmt|;
operator|*
name|fontqueue
operator|.
name|tail
operator|=
literal|'R'
expr_stmt|;
block|}
name|print_node
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_node
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|struct
name|mdoc_node
modifier|*
name|sub
decl_stmt|;
specifier|const
name|struct
name|manact
modifier|*
name|act
decl_stmt|;
name|int
name|cond
decl_stmt|,
name|do_sub
decl_stmt|;
comment|/* 	 * Break the line if we were parsed subsequent the current node. 	 * This makes the page structure be more consistent. 	 */
if|if
condition|(
name|MMAN_spc
operator|&
name|outflags
operator|&&
name|MDOC_LINE
operator|&
name|n
operator|->
name|flags
condition|)
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
name|act
operator|=
name|NULL
expr_stmt|;
name|cond
operator|=
literal|0
expr_stmt|;
name|do_sub
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MDOC_TEXT
operator|==
name|n
operator|->
name|type
condition|)
block|{
comment|/* 		 * Make sure that we don't happen to start with a 		 * control character at the start of a line. 		 */
if|if
condition|(
name|MMAN_nl
operator|&
name|outflags
operator|&&
operator|(
literal|'.'
operator|==
operator|*
name|n
operator|->
name|string
operator|||
literal|'\''
operator|==
operator|*
name|n
operator|->
name|string
operator|)
condition|)
block|{
name|print_word
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\\&"
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
name|print_word
argument_list|(
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Conditionally run the pre-node action handler for a 		 * node. 		 */
name|act
operator|=
name|manacts
operator|+
name|n
operator|->
name|tok
expr_stmt|;
name|cond
operator|=
name|NULL
operator|==
name|act
operator|->
name|cond
operator|||
call|(
modifier|*
name|act
operator|->
name|cond
call|)
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|&&
name|act
operator|->
name|pre
condition|)
name|do_sub
operator|=
call|(
modifier|*
name|act
operator|->
name|pre
call|)
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * Conditionally run all child nodes. 	 * Note that this iterates over children instead of using 	 * recursion.  This prevents unnecessary depth in the stack. 	 */
if|if
condition|(
name|do_sub
condition|)
for|for
control|(
name|sub
operator|=
name|n
operator|->
name|child
init|;
name|sub
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
control|)
name|print_node
argument_list|(
name|meta
argument_list|,
name|sub
argument_list|)
expr_stmt|;
comment|/* 	 * Lastly, conditionally run the post-node handler. 	 */
if|if
condition|(
name|cond
operator|&&
name|act
operator|->
name|post
condition|)
call|(
modifier|*
name|act
operator|->
name|post
call|)
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cond_head
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
return|return
operator|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cond_body
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
return|return
operator|(
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_enc
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|prefix
operator|=
name|manacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|prefix
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|prefix
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|print_word
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_enc
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
name|suffix
operator|=
name|manacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|suffix
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|suffix
condition|)
return|return;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_font
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|font_pop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_percent
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|pre_em
operator|==
name|manacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|pre
condition|)
name|font_pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|next
condition|)
block|{
name|print_word
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|prev
operator|&&
name|n
operator|->
name|prev
operator|->
name|tok
operator|==
name|n
operator|->
name|tok
operator|&&
name|n
operator|->
name|next
operator|->
name|tok
operator|==
name|n
operator|->
name|tok
condition|)
name|print_word
argument_list|(
literal|"and"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_word
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre__t
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|parent
operator|&&
name|MDOC_Rs
operator|==
name|n
operator|->
name|parent
operator|->
name|tok
operator|&&
name|n
operator|->
name|parent
operator|->
name|norm
operator|->
name|Rs
operator|.
name|quote_T
condition|)
block|{
name|print_word
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
else|else
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post__t
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|parent
operator|&&
name|MDOC_Rs
operator|==
name|n
operator|->
name|parent
operator|->
name|tok
operator|&&
name|n
operator|->
name|parent
operator|->
name|norm
operator|->
name|Rs
operator|.
name|quote_T
condition|)
block|{
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
block|}
else|else
name|font_pop
argument_list|()
expr_stmt|;
name|post_percent
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print before a section header.  */
end_comment

begin_function
specifier|static
name|int
name|pre_sect
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
block|{
name|outflags
operator||=
name|MMAN_sp
expr_stmt|;
name|print_block
argument_list|(
name|manacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|prefix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print subsequent a section header.  */
end_comment

begin_function
specifier|static
name|void
name|post_sect
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_HEAD
operator|!=
name|n
operator|->
name|type
condition|)
return|return;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
if|if
condition|(
name|MDOC_Sh
operator|==
name|n
operator|->
name|tok
operator|&&
name|SEC_AUTHORS
operator|==
name|n
operator|->
name|sec
condition|)
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_An_split
operator||
name|MMAN_An_nosplit
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See mdoc_term.c, synopsis_pre() for comments. */
end_comment

begin_function
specifier|static
name|void
name|pre_syn
parameter_list|(
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|prev
operator|||
operator|!
operator|(
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
operator|)
condition|)
return|return;
if|if
condition|(
name|n
operator|->
name|prev
operator|->
name|tok
operator|==
name|n
operator|->
name|tok
operator|&&
name|MDOC_Ft
operator|!=
name|n
operator|->
name|tok
operator|&&
name|MDOC_Fo
operator|!=
name|n
operator|->
name|tok
operator|&&
name|MDOC_Fn
operator|!=
name|n
operator|->
name|tok
condition|)
block|{
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|n
operator|->
name|prev
operator|->
name|tok
condition|)
block|{
case|case
operator|(
name|MDOC_Fd
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|MDOC_Fn
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|MDOC_Fo
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|MDOC_In
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|MDOC_Vt
operator|)
case|:
name|outflags
operator||=
name|MMAN_sp
expr_stmt|;
break|break;
case|case
operator|(
name|MDOC_Ft
operator|)
case|:
if|if
condition|(
name|MDOC_Fn
operator|!=
name|n
operator|->
name|tok
operator|&&
name|MDOC_Fo
operator|!=
name|n
operator|->
name|tok
condition|)
block|{
name|outflags
operator||=
name|MMAN_sp
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre_an
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|norm
operator|->
name|An
operator|.
name|auth
condition|)
block|{
case|case
operator|(
name|AUTH_split
operator|)
case|:
name|outflags
operator|&=
operator|~
name|MMAN_An_nosplit
expr_stmt|;
name|outflags
operator||=
name|MMAN_An_split
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
operator|(
name|AUTH_nosplit
operator|)
case|:
name|outflags
operator|&=
operator|~
name|MMAN_An_split
expr_stmt|;
name|outflags
operator||=
name|MMAN_An_nosplit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
if|if
condition|(
name|MMAN_An_split
operator|&
name|outflags
condition|)
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
elseif|else
if|if
condition|(
name|SEC_AUTHORS
operator|==
name|n
operator|->
name|sec
operator|&&
operator|!
operator|(
name|MMAN_An_nosplit
operator|&
name|outflags
operator|)
condition|)
name|outflags
operator||=
name|MMAN_An_split
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre_ap
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_bd
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_PP
operator||
name|MMAN_sp
operator||
name|MMAN_br
operator|)
expr_stmt|;
if|if
condition|(
name|DISP_unfilled
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
operator|||
name|DISP_literal
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
condition|)
name|print_line
argument_list|(
literal|".nf"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|comp
operator|&&
name|NULL
operator|!=
name|n
operator|->
name|parent
operator|->
name|prev
condition|)
name|outflags
operator||=
name|MMAN_sp
expr_stmt|;
name|print_offs
argument_list|(
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|offs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_bd
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
comment|/* Close out this display. */
name|print_line
argument_list|(
literal|".RE"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DISP_unfilled
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
operator|||
name|DISP_literal
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
condition|)
name|print_line
argument_list|(
literal|".fi"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
comment|/* Maybe we are inside an enclosing list? */
if|if
condition|(
name|NULL
operator|!=
name|n
operator|->
name|parent
operator|->
name|next
condition|)
name|mid_it
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_bf
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|MDOC_BLOCK
operator|)
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
operator|(
name|MDOC_BODY
operator|)
case|:
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|n
operator|->
name|norm
operator|->
name|Bf
operator|.
name|font
condition|)
block|{
case|case
operator|(
name|FONT_Em
operator|)
case|:
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|FONT_Sy
operator|)
case|:
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|font_push
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_bf
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
condition|)
name|font_pop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_bk
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|MDOC_BLOCK
operator|)
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
operator|(
name|MDOC_BODY
operator|)
case|:
name|outflags
operator||=
name|MMAN_Bk
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|post_bk
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
condition|)
name|outflags
operator|&=
operator|~
name|MMAN_Bk
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_bl
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|size_t
name|icol
decl_stmt|;
comment|/* 	 * print_offs() will increase the -offset to account for 	 * a possible enclosing .It, but any enclosed .It blocks 	 * just nest and do not add up their indentation. 	 */
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|offs
condition|)
block|{
name|print_offs
argument_list|(
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|offs
argument_list|)
expr_stmt|;
name|Bl_stack
index|[
name|Bl_stack_len
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|LIST_enum
operator|)
case|:
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|count
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
operator|(
name|LIST_column
operator|)
case|:
break|break;
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|print_line
argument_list|(
literal|".TS"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|ncols
condition|;
name|icol
operator|++
control|)
name|print_word
argument_list|(
literal|"l"
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_bl
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|LIST_column
operator|)
case|:
name|print_line
argument_list|(
literal|".TE"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|LIST_enum
operator|)
case|:
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|count
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|offs
condition|)
block|{
name|print_line
argument_list|(
literal|".RE"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Bl_stack_len
argument_list|)
expr_stmt|;
name|Bl_stack_len
operator|--
expr_stmt|;
name|assert
argument_list|(
literal|0
operator|==
name|Bl_stack
index|[
name|Bl_stack_len
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outflags
operator||=
name|MMAN_PP
operator||
name|MMAN_nl
expr_stmt|;
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_sp
operator||
name|MMAN_br
operator|)
expr_stmt|;
block|}
comment|/* Maybe we are inside an enclosing list? */
if|if
condition|(
name|NULL
operator|!=
name|n
operator|->
name|parent
operator|->
name|next
condition|)
name|mid_it
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_br
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_bx
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|n
operator|=
name|n
operator|->
name|child
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|print_word
argument_list|(
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
name|print_word
argument_list|(
literal|"BSD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_dl
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|print_offs
argument_list|(
literal|"6n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_dl
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|print_line
argument_list|(
literal|".RE"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
comment|/* Maybe we are inside an enclosing list? */
if|if
condition|(
name|NULL
operator|!=
name|n
operator|->
name|parent
operator|->
name|next
condition|)
name|mid_it
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_em
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_eo
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
operator|||
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
condition|)
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_fa
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|int
name|am_Fa
decl_stmt|;
name|am_Fa
operator|=
name|MDOC_Fa
operator|==
name|n
operator|->
name|tok
expr_stmt|;
if|if
condition|(
name|am_Fa
condition|)
name|n
operator|=
name|n
operator|->
name|child
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|n
condition|)
block|{
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
if|if
condition|(
name|am_Fa
operator|||
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
name|outflags
operator||=
name|MMAN_nbrword
expr_stmt|;
name|print_node
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|font_pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|n
operator|=
name|n
operator|->
name|next
operator|)
condition|)
name|print_word
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_fa
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|!=
name|n
operator|->
name|next
operator|&&
name|MDOC_Fa
operator|==
name|n
operator|->
name|next
operator|->
name|tok
condition|)
name|print_word
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_fd
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|pre_syn
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_fd
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|font_pop
argument_list|()
expr_stmt|;
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_fl
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
literal|"\\-"
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_fl
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|font_pop
argument_list|()
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|n
operator|->
name|nchild
operator|&&
name|NULL
operator|!=
name|n
operator|->
name|next
operator|&&
name|n
operator|->
name|next
operator|->
name|line
operator|==
name|n
operator|->
name|line
condition|)
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_fn
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|pre_syn
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|child
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
name|print_block
argument_list|(
literal|".HP 4n"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|font_pop
argument_list|()
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|n
condition|)
name|pre_fa
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_fn
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|print_word
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
block|{
name|print_word
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_PP
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre_fo
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|MDOC_BLOCK
operator|)
case|:
name|pre_syn
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|MDOC_HEAD
operator|)
case|:
if|if
condition|(
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
name|print_block
argument_list|(
literal|".HP 4n"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|MDOC_BODY
operator|)
case|:
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_fo
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|MDOC_HEAD
operator|)
case|:
name|font_pop
argument_list|()
expr_stmt|;
break|break;
case|case
operator|(
name|MDOC_BODY
operator|)
case|:
name|post_fn
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre_ft
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|pre_syn
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_in
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
block|{
name|pre_syn
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
literal|"#include<"
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
else|else
block|{
name|print_word
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_in
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
block|{
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
name|font_pop
argument_list|()
expr_stmt|;
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
block|}
else|else
block|{
name|font_pop
argument_list|()
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre_it
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|struct
name|mdoc_node
modifier|*
name|bln
decl_stmt|;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|MDOC_HEAD
operator|)
case|:
name|outflags
operator||=
name|MMAN_PP
operator||
name|MMAN_nl
expr_stmt|;
name|bln
operator|=
name|n
operator|->
name|parent
operator|->
name|parent
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|comp
operator|||
operator|(
name|NULL
operator|==
name|n
operator|->
name|parent
operator|->
name|prev
operator|&&
name|NULL
operator|==
name|bln
operator|->
name|parent
operator|->
name|prev
operator|)
condition|)
name|outflags
operator||=
name|MMAN_sp
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_br
expr_stmt|;
switch|switch
condition|(
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|LIST_item
operator|)
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
operator|(
name|LIST_inset
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|LIST_diag
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|LIST_ohang
operator|)
case|:
if|if
condition|(
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
operator|==
name|LIST_diag
condition|)
name|print_line
argument_list|(
literal|".B \""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|print_line
argument_list|(
literal|".R \""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
operator|(
name|LIST_bullet
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|LIST_dash
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|LIST_hyphen
operator|)
case|:
name|print_width
argument_list|(
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|width
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TPremain
operator|=
literal|0
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_bullet
operator|==
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
name|print_word
argument_list|(
literal|"o"
argument_list|)
expr_stmt|;
else|else
name|print_word
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|font_pop
argument_list|()
expr_stmt|;
break|break;
case|case
operator|(
name|LIST_enum
operator|)
case|:
name|print_width
argument_list|(
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|width
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TPremain
operator|=
literal|0
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
name|print_count
argument_list|(
operator|&
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|LIST_hang
operator|)
case|:
name|print_width
argument_list|(
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|width
argument_list|,
name|n
operator|->
name|child
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|TPremain
operator|=
literal|0
expr_stmt|;
break|break;
case|case
operator|(
name|LIST_tag
operator|)
case|:
name|print_width
argument_list|(
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|width
argument_list|,
name|n
operator|->
name|child
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
default|default:
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called after closing out an indented block.  * If we are inside an enclosing list, restore its indentation.  */
end_comment

begin_function
specifier|static
name|void
name|mid_it
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
literal|24
index|]
decl_stmt|;
comment|/* Nothing to do outside a list. */
if|if
condition|(
literal|0
operator|==
name|Bl_stack_len
operator|||
literal|0
operator|==
name|Bl_stack
index|[
name|Bl_stack_len
operator|-
literal|1
index|]
condition|)
return|return;
comment|/* The indentation has already been set up. */
if|if
condition|(
name|Bl_stack_post
index|[
name|Bl_stack_len
operator|-
literal|1
index|]
condition|)
return|return;
comment|/* Restore the indentation of the enclosing list. */
name|print_line
argument_list|(
literal|".RS"
argument_list|,
name|MMAN_Bk_susp
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%zun"
argument_list|,
name|Bl_stack
index|[
name|Bl_stack_len
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Remeber to close out this .RS block later. */
name|Bl_stack_post
index|[
name|Bl_stack_len
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_it
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|struct
name|mdoc_node
modifier|*
name|bln
decl_stmt|;
name|bln
operator|=
name|n
operator|->
name|parent
operator|->
name|parent
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|MDOC_HEAD
operator|)
case|:
switch|switch
condition|(
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|LIST_diag
operator|)
case|:
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|"\\ "
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|LIST_ohang
operator|)
case|:
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
operator|(
name|MDOC_BODY
operator|)
case|:
switch|switch
condition|(
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|LIST_bullet
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|LIST_dash
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|LIST_hyphen
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|LIST_enum
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|LIST_hang
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|LIST_tag
operator|)
case|:
name|assert
argument_list|(
name|Bl_stack_len
argument_list|)
expr_stmt|;
name|Bl_stack
index|[
operator|--
name|Bl_stack_len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Our indentation had to be restored 			 * after a child display or child list. 			 * Close out that indentation block now. 			 */
if|if
condition|(
name|Bl_stack_post
index|[
name|Bl_stack_len
index|]
condition|)
block|{
name|print_line
argument_list|(
literal|".RE"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
name|Bl_stack_post
index|[
name|Bl_stack_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|LIST_column
operator|)
case|:
if|if
condition|(
name|NULL
operator|!=
name|n
operator|->
name|next
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|post_lb
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|SEC_LIBRARY
operator|==
name|n
operator|->
name|sec
condition|)
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_lk
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|struct
name|mdoc_node
modifier|*
name|link
decl_stmt|,
modifier|*
name|descr
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|link
operator|=
name|n
operator|->
name|child
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|descr
operator|=
name|link
operator|->
name|next
operator|)
condition|)
block|{
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|descr
condition|)
block|{
name|print_word
argument_list|(
name|descr
operator|->
name|string
argument_list|)
expr_stmt|;
name|descr
operator|=
name|descr
operator|->
name|next
expr_stmt|;
block|}
name|print_word
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|font_pop
argument_list|()
expr_stmt|;
block|}
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
name|link
operator|->
name|string
argument_list|)
expr_stmt|;
name|font_pop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_li
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|font_push
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_nm
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|MDOC_BLOCK
operator|==
name|n
operator|->
name|type
condition|)
block|{
name|outflags
operator||=
name|MMAN_Bk
expr_stmt|;
name|pre_syn
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MDOC_ELEM
operator|!=
name|n
operator|->
name|type
operator|&&
name|MDOC_HEAD
operator|!=
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|name
operator|=
name|n
operator|->
name|child
condition|?
name|n
operator|->
name|child
operator|->
name|string
else|:
name|meta
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|name
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|parent
operator|->
name|prev
condition|)
name|outflags
operator||=
name|MMAN_sp
expr_stmt|;
name|print_block
argument_list|(
literal|".HP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %zun"
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
block|}
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|child
condition|)
name|print_word
argument_list|(
name|meta
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_nm
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|MDOC_BLOCK
operator|)
case|:
name|outflags
operator|&=
operator|~
name|MMAN_Bk
expr_stmt|;
break|break;
case|case
operator|(
name|MDOC_HEAD
operator|)
case|:
comment|/* FALLTHROUGH */
case|case
operator|(
name|MDOC_ELEM
operator|)
case|:
name|font_pop
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre_no
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator||=
name|MMAN_spc_force
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_ns
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_pf
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_pp
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_It
operator|!=
name|n
operator|->
name|parent
operator|->
name|tok
condition|)
name|outflags
operator||=
name|MMAN_PP
expr_stmt|;
name|outflags
operator||=
name|MMAN_sp
operator||
name|MMAN_nl
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_br
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_rs
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|SEC_SEE_ALSO
operator|==
name|n
operator|->
name|sec
condition|)
block|{
name|outflags
operator||=
name|MMAN_PP
operator||
name|MMAN_sp
operator||
name|MMAN_nl
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_br
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_sm
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|assert
argument_list|(
name|n
operator|->
name|child
operator|&&
name|MDOC_TEXT
operator|==
name|n
operator|->
name|child
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
literal|"on"
argument_list|,
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
condition|)
name|outflags
operator||=
name|MMAN_Sm
operator||
name|MMAN_spc
expr_stmt|;
else|else
name|outflags
operator|&=
operator|~
name|MMAN_Sm
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_sp
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MMAN_PP
operator|&
name|outflags
condition|)
block|{
name|outflags
operator|&=
operator|~
name|MMAN_PP
expr_stmt|;
name|print_line
argument_list|(
literal|".PP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|print_line
argument_list|(
literal|".sp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_sp
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_sy
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_vt
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|MDOC_BLOCK
operator|)
case|:
name|pre_syn
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
operator|(
name|MDOC_BODY
operator|)
case|:
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_vt
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
operator|&&
name|MDOC_BODY
operator|!=
name|n
operator|->
name|type
condition|)
return|return;
name|font_pop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_xr
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|n
operator|=
name|n
operator|->
name|child
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|print_node
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_ux
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|print_word
argument_list|(
name|manacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|child
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|"\\ "
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

