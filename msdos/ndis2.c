begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) 1993,1994  *      Texas A&M University.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Texas A&M University  *      and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Developers:  *             David K. Hess, Douglas Lee Schales, David R. Safford  *  * Heavily modified for Metaware HighC + GNU C 2.8+  *             Gisle Vanem 1998  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"pcap-dos.h"
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_include
include|#
directive|include
file|"msdos/ndis2.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_NDIS2
argument_list|)
end_if

begin_comment
comment|/*  *  Packet buffer handling  */
end_comment

begin_function_decl
specifier|extern
name|int
name|FreePktBuf
parameter_list|(
name|PktBuf
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|EnquePktBuf
parameter_list|(
name|PktBuf
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|PktBuf
modifier|*
name|AllocPktBuf
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  Various defines  */
end_comment

begin_define
define|#
directive|define
name|MAX_NUM_DEBUG_STRINGS
value|90
end_define

begin_define
define|#
directive|define
name|DEBUG_STRING_LENGTH
value|80
end_define

begin_define
define|#
directive|define
name|STACK_POOL_SIZE
value|6
end_define

begin_define
define|#
directive|define
name|STACK_SIZE
value|256
end_define

begin_define
define|#
directive|define
name|MEDIA_FDDI
value|1
end_define

begin_define
define|#
directive|define
name|MEDIA_ETHERNET
value|2
end_define

begin_define
define|#
directive|define
name|MEDIA_TOKEN
value|3
end_define

begin_decl_stmt
specifier|static
name|int
name|startDebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stopDebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DWORD
name|droppedPackets
init|=
literal|0L
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|WORD
name|frameSize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|WORD
name|headerSize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mediaType
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lastErr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BYTE
name|debugStrings
index|[
name|MAX_NUM_DEBUG_STRINGS
index|]
index|[
name|DEBUG_STRING_LENGTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BYTE
modifier|*
name|freeStacks
index|[
name|STACK_POOL_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|freeStackPtr
init|=
name|STACK_POOL_SIZE
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ProtMan
name|protManEntry
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|WORD
name|protManDS
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|xmitPending
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|_PktBuf
modifier|*
name|txBufPending
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|_CardHandle
modifier|*
name|handle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|_CommonChars
name|common
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|_ProtocolChars
name|protChars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|_ProtDispatch
name|lowerTable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|_FailingModules
name|failingModules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|_BindingsList
name|bindings
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|WORD
name|err_num
decl_stmt|;
name|char
modifier|*
name|err_text
decl_stmt|;
block|}
name|ndis_errlist
index|[]
init|=
block|{
block|{
name|ERR_SUCCESS
block|,
literal|"The function completed successfully.\n"
block|}
block|,
block|{
name|ERR_WAIT_FOR_RELEASE
block|,
literal|"The ReceiveChain completed successfully but the protocol has\n"
literal|"retained control of the buffer.\n"
block|}
block|,
block|{
name|ERR_REQUEST_QUEUED
block|,
literal|"The current request has been queued.\n"
block|}
block|,
block|{
name|ERR_FRAME_NOT_RECOGNIZED
block|,
literal|"Frame not recognized.\n"
block|}
block|,
block|{
name|ERR_FRAME_REJECTED
block|,
literal|"Frame was discarded.\n"
block|}
block|,
block|{
name|ERR_FORWARD_FRAME
block|,
literal|"Protocol wishes to forward frame to another protocol.\n"
block|}
block|,
block|{
name|ERR_OUT_OF_RESOURCE
block|,
literal|"Out of resource.\n"
block|}
block|,
block|{
name|ERR_INVALID_PARAMETER
block|,
literal|"Invalid parameter.\n"
block|}
block|,
block|{
name|ERR_INVALID_FUNCTION
block|,
literal|"Invalid function.\n"
block|}
block|,
block|{
name|ERR_NOT_SUPPORTED
block|,
literal|"Not supported.\n"
block|}
block|,
block|{
name|ERR_HARDWARE_ERROR
block|,
literal|"Hardware error.\n"
block|}
block|,
block|{
name|ERR_TRANSMIT_ERROR
block|,
literal|"The packet was not transmitted due to an error.\n"
block|}
block|,
block|{
name|ERR_NO_SUCH_DESTINATION
block|,
literal|"Token ring packet was not recognized when transmitted.\n"
block|}
block|,
block|{
name|ERR_BUFFER_TOO_SMALL
block|,
literal|"Provided buffer was too small.\n"
block|}
block|,
block|{
name|ERR_ALREADY_STARTED
block|,
literal|"Network drivers already started.\n"
block|}
block|,
block|{
name|ERR_INCOMPLETE_BINDING
block|,
literal|"Protocol driver could not complete its bindings.\n"
block|}
block|,
block|{
name|ERR_DRIVER_NOT_INITIALIZED
block|,
literal|"MAC did not initialize properly.\n"
block|}
block|,
block|{
name|ERR_HARDWARE_NOT_FOUND
block|,
literal|"Hardware not found.\n"
block|}
block|,
block|{
name|ERR_HARDWARE_FAILURE
block|,
literal|"Hardware failure.\n"
block|}
block|,
block|{
name|ERR_CONFIGURATION_FAILURE
block|,
literal|"Configuration failure.\n"
block|}
block|,
block|{
name|ERR_INTERRUPT_CONFLICT
block|,
literal|"Interrupt conflict.\n"
block|}
block|,
block|{
name|ERR_INCOMPATIBLE_MAC
block|,
literal|"The MAC is not compatible with the protocol.\n"
block|}
block|,
block|{
name|ERR_INITIALIZATION_FAILED
block|,
literal|"Initialization failed.\n"
block|}
block|,
block|{
name|ERR_NO_BINDING
block|,
literal|"Binding did not occur.\n"
block|}
block|,
block|{
name|ERR_NETWORK_MAY_NOT_BE_CONNECTED
block|,
literal|"The network may not be connected to the adapter.\n"
block|}
block|,
block|{
name|ERR_INCOMPATIBLE_OS_VERSION
block|,
literal|"The version of the operating system is incompatible with the protocol.\n"
block|}
block|,
block|{
name|ERR_ALREADY_REGISTERED
block|,
literal|"The protocol is already registered.\n"
block|}
block|,
block|{
name|ERR_PATH_NOT_FOUND
block|,
literal|"PROTMAN.EXE could not be found.\n"
block|}
block|,
block|{
name|ERR_INSUFFICIENT_MEMORY
block|,
literal|"Insufficient memory.\n"
block|}
block|,
block|{
name|ERR_INFO_NOT_FOUND
block|,
literal|"Protocol Mananger info structure is lost or corrupted.\n"
block|}
block|,
block|{
name|ERR_GENERAL_FAILURE
block|,
literal|"General failure.\n"
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Some handy macros  */
end_comment

begin_define
define|#
directive|define
name|PERROR
parameter_list|(
name|str
parameter_list|)
value|printf("%s (%d): %s\n", __FILE__,__LINE__,str)
end_define

begin_define
define|#
directive|define
name|DEBUG_RING
parameter_list|()
value|(debugStrings[stopDebug+1 == MAX_NUM_DEBUG_STRINGS ? \                         stopDebug = 0 : ++stopDebug])
end_define

begin_comment
comment|/*  * needs rewrite for DOSX  */
end_comment

begin_define
define|#
directive|define
name|MAC_DISPATCH
parameter_list|(
name|hnd
parameter_list|)
value|((struct _MacUpperDispatch*)(hnd)->common->upperDispatchTable)
end_define

begin_define
define|#
directive|define
name|MAC_STATUS
parameter_list|(
name|hnd
parameter_list|)
value|((struct _MacStatusTable*)  (hnd)->common->serviceStatus)
end_define

begin_define
define|#
directive|define
name|MAC_CHAR
parameter_list|(
name|hnd
parameter_list|)
value|((struct _MacChars*)        (hnd)->common->serviceChars)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|NDIS_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DEBUG0
parameter_list|(
name|str
parameter_list|)
value|printf (str)
end_define

begin_define
define|#
directive|define
name|DEBUG1
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|)
value|printf (fmt,a)
end_define

begin_define
define|#
directive|define
name|DEBUG2
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|printf (fmt,a,b)
end_define

begin_define
define|#
directive|define
name|TRACE0
parameter_list|(
name|str
parameter_list|)
value|sprintf (DEBUG_RING(),str)
end_define

begin_define
define|#
directive|define
name|TRACE1
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|)
value|sprintf (DEBUG_RING(),fmt,a)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEBUG0
parameter_list|(
name|str
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|DEBUG1
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|DEBUG2
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|TRACE0
parameter_list|(
name|str
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|TRACE1
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This routine is called from both threads  */
end_comment

begin_function
name|void
name|NdisFreeStack
parameter_list|(
name|BYTE
modifier|*
name|aStack
parameter_list|)
block|{
name|GUARD
argument_list|()
expr_stmt|;
if|if
condition|(
name|freeStackPtr
operator|==
name|STACK_POOL_SIZE
operator|-
literal|1
condition|)
name|PERROR
argument_list|(
literal|"tried to free too many stacks"
argument_list|)
expr_stmt|;
name|freeStacks
index|[
operator|++
name|freeStackPtr
index|]
operator|=
name|aStack
expr_stmt|;
if|if
condition|(
name|freeStackPtr
operator|==
literal|0
condition|)
name|TRACE0
argument_list|(
literal|"freeStackPtr went positive\n"
argument_list|)
expr_stmt|;
name|UNGUARD
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is called from callbacks to allocate local data  */
end_comment

begin_function
name|BYTE
modifier|*
name|NdisAllocStack
parameter_list|(
name|void
parameter_list|)
block|{
name|BYTE
modifier|*
name|stack
decl_stmt|;
name|GUARD
argument_list|()
expr_stmt|;
if|if
condition|(
name|freeStackPtr
operator|<
literal|0
condition|)
block|{
comment|/* Ran out of stack buffers. Return NULL which will start      * dropping packets      */
name|TRACE0
argument_list|(
literal|"freeStackPtr went negative\n"
argument_list|)
expr_stmt|;
name|stack
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|stack
operator|=
name|freeStacks
index|[
name|freeStackPtr
operator|--
index|]
expr_stmt|;
name|UNGUARD
argument_list|()
expr_stmt|;
return|return
operator|(
name|stack
operator|)
return|;
block|}
end_function

begin_macro
name|CALLBACK
argument_list|(
argument|NdisSystemRequest (DWORD param1, DWORD param2, WORD param3,                              WORD opcode, WORD targetDS)
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|int
name|bindEntry
init|=
literal|0
decl_stmt|;
name|struct
name|_CommonChars
modifier|*
name|macCommon
decl_stmt|;
specifier|volatile
name|WORD
name|result
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|REQ_INITIATE_BIND
case|:
name|macCommon
operator|=
operator|(
expr|struct
name|_CommonChars
operator|*
operator|)
name|param2
expr_stmt|;
if|if
condition|(
name|macCommon
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"There is an NDIS misconfiguration.\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ERR_GENERAL_FAILURE
expr_stmt|;
break|break;
block|}
name|DEBUG2
argument_list|(
literal|"module name %s\n"
literal|"module type %s\n"
argument_list|,
name|macCommon
operator|->
name|moduleName
argument_list|,
operator|(
operator|(
name|MacChars
operator|*
operator|)
name|macCommon
operator|->
name|serviceChars
operator|)
operator|->
name|macName
argument_list|)
expr_stmt|;
comment|/* Binding to the MAC */
name|result
operator|=
name|macCommon
operator|->
name|systemRequest
argument_list|(
operator|(
name|DWORD
operator|)
operator|&
name|common
argument_list|,
operator|(
name|DWORD
operator|)
operator|&
name|macCommon
argument_list|,
literal|0
argument_list|,
name|REQ_BIND
argument_list|,
name|macCommon
operator|->
name|moduleDS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|bindings
operator|.
name|moduleName
index|[
name|bindEntry
index|]
argument_list|,
name|handle
operator|->
name|moduleName
argument_list|)
condition|)
name|handle
operator|->
name|common
operator|=
name|macCommon
expr_stmt|;
else|else
name|PERROR
argument_list|(
literal|"unknown module"
argument_list|)
expr_stmt|;
operator|++
name|bindEntry
expr_stmt|;
break|break;
case|case
name|REQ_INITIATE_UNBIND
case|:
name|macCommon
operator|=
operator|(
expr|struct
name|_CommonChars
operator|*
operator|)
name|param2
expr_stmt|;
name|result
operator|=
name|macCommon
operator|->
name|systemRequest
argument_list|(
operator|(
name|DWORD
operator|)
operator|&
name|common
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|REQ_UNBIND
argument_list|,
name|macCommon
operator|->
name|moduleDS
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|ERR_GENERAL_FAILURE
expr_stmt|;
break|break;
block|}
name|ARGSUSED
argument_list|(
name|param1
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|param3
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|targetDS
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_macro
name|CALLBACK
argument_list|(
argument|NdisRequestConfirm (WORD protId, WORD macId,   WORD reqHandle,                               WORD status, WORD request, WORD protDS)
argument_list|)
end_macro

begin_block
block|{
name|ARGSUSED
argument_list|(
name|protId
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|macId
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|reqHandle
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|protDS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERR_SUCCESS
operator|)
return|;
block|}
end_block

begin_macro
name|CALLBACK
argument_list|(
argument|NdisTransmitConfirm (WORD protId, WORD macId, WORD reqHandle,                                WORD status, WORD protDS)
argument_list|)
end_macro

begin_block
block|{
name|xmitPending
operator|--
expr_stmt|;
name|FreePktBuf
argument_list|(
name|txBufPending
argument_list|)
expr_stmt|;
comment|/* Add passed ECB back to the free list */
name|ARGSUSED
argument_list|(
name|reqHandle
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|protDS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERR_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * The primary function for receiving packets  */
end_comment

begin_macro
name|CALLBACK
argument_list|(
argument|NdisReceiveLookahead (WORD  macId,      WORD  frameSize,                                 WORD  bytesAvail, BYTE *buffer,                                 BYTE *indicate,   WORD  protDS)
argument_list|)
end_macro

begin_block
block|{
name|int
name|result
decl_stmt|;
name|PktBuf
modifier|*
name|pktBuf
decl_stmt|;
name|WORD
name|bytesCopied
decl_stmt|;
name|struct
name|_TDBufDescr
name|tDBufDescr
decl_stmt|;
if|#
directive|if
literal|0
block|TRACE1 ("lookahead length = %d, ", bytesAvail);   TRACE1 ("ecb = %08lX, ",          *ecb);   TRACE1 ("count = %08lX\n",         count);   TRACE1 ("offset = %08lX, ",        offset);   TRACE1 ("timesAllowed = %d, ",     timesAllowed);   TRACE1 ("packet size = %d\n",      look->dataLookAheadLen);
endif|#
directive|endif
comment|/* Allocate a buffer for the packet    */
if|if
condition|(
operator|(
name|pktBuf
operator|=
name|AllocPktBuf
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|droppedPackets
operator|++
expr_stmt|;
return|return
operator|(
name|ERR_FRAME_REJECTED
operator|)
return|;
block|}
comment|/*    * Now kludge things. Note we will have to undo this later. This will    * make the packet contiguous after the MLID has done the requested copy.    */
name|tDBufDescr
operator|.
name|tDDataCount
operator|=
literal|1
expr_stmt|;
name|tDBufDescr
operator|.
name|tDBufDescrRec
index|[
literal|0
index|]
operator|.
name|tDPtrType
operator|=
name|NDIS_PTR_PHYSICAL
expr_stmt|;
name|tDBufDescr
operator|.
name|tDBufDescrRec
index|[
literal|0
index|]
operator|.
name|tDDataPtr
operator|=
name|pktBuf
operator|->
name|buffer
expr_stmt|;
name|tDBufDescr
operator|.
name|tDBufDescrRec
index|[
literal|0
index|]
operator|.
name|tDDataLen
operator|=
name|pktBuf
operator|->
name|length
expr_stmt|;
name|tDBufDescr
operator|.
name|tDBufDescrRec
index|[
literal|0
index|]
operator|.
name|dummy
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|MAC_DISPATCH
argument_list|(
name|handle
argument_list|)
operator|->
name|transferData
argument_list|(
operator|&
name|bytesCopied
argument_list|,
literal|0
argument_list|,
operator|&
name|tDBufDescr
argument_list|,
name|handle
operator|->
name|common
operator|->
name|moduleDS
argument_list|)
expr_stmt|;
name|pktBuf
operator|->
name|packetLength
operator|=
name|bytesCopied
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ERR_SUCCESS
condition|)
name|EnquePktBuf
argument_list|(
name|pktBuf
argument_list|)
expr_stmt|;
else|else
name|FreePktBuf
argument_list|(
name|pktBuf
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|frameSize
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|bytesAvail
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|indicate
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|protDS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERR_SUCCESS
operator|)
return|;
block|}
end_block

begin_macro
name|CALLBACK
argument_list|(
argument|NdisIndicationComplete (WORD macId, WORD protDS)
argument_list|)
end_macro

begin_block
block|{
name|ARGSUSED
argument_list|(
name|macId
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|protDS
argument_list|)
expr_stmt|;
comment|/* We don't give a hoot about these. Just return    */
return|return
operator|(
name|ERR_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * This is the OTHER way we may receive packets  */
end_comment

begin_macro
name|CALLBACK
argument_list|(
argument|NdisReceiveChain (WORD macId, WORD frameSize, WORD reqHandle,                             struct _RxBufDescr *rxBufDescr,                             BYTE *indicate, WORD protDS)
argument_list|)
end_macro

begin_block
block|{
name|struct
name|_PktBuf
modifier|*
name|pktBuf
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*    * For now we copy the entire packet over to a PktBuf structure. This may be    * a performance hit but this routine probably isn't called very much, and    * it is a lot of work to do it otherwise. Also if it is a filter protocol    * packet we could end up sucking up MAC buffes.    */
if|if
condition|(
operator|(
name|pktBuf
operator|=
name|AllocPktBuf
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|droppedPackets
operator|++
expr_stmt|;
return|return
operator|(
name|ERR_FRAME_REJECTED
operator|)
return|;
block|}
name|pktBuf
operator|->
name|packetLength
operator|=
literal|0
expr_stmt|;
comment|/* Copy the packet to the buffer    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rxBufDescr
operator|->
name|rxDataCount
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|_RxBufDescrRec
modifier|*
name|rxDescr
init|=
operator|&
name|rxBufDescr
operator|->
name|rxBufDescrRec
index|[
name|i
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|pktBuf
operator|->
name|buffer
operator|+
name|pktBuf
operator|->
name|packetLength
argument_list|,
name|rxDescr
operator|->
name|rxDataPtr
argument_list|,
name|rxDescr
operator|->
name|rxDataLen
argument_list|)
expr_stmt|;
name|pktBuf
operator|->
name|packetLength
operator|+=
name|rxDescr
operator|->
name|rxDataLen
expr_stmt|;
block|}
name|EnquePktBuf
argument_list|(
name|pktBuf
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|frameSize
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|reqHandle
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|indicate
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|protDS
argument_list|)
expr_stmt|;
comment|/* This frees up the buffer for the MAC to use    */
return|return
operator|(
name|ERR_SUCCESS
operator|)
return|;
block|}
end_block

begin_macro
name|CALLBACK
argument_list|(
argument|NdisStatusProc (WORD macId,  WORD param1, BYTE *indicate,                           WORD opcode, WORD protDS)
argument_list|)
end_macro

begin_block
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|STATUS_RING_STATUS
case|:
break|break;
case|case
name|STATUS_ADAPTER_CHECK
case|:
break|break;
case|case
name|STATUS_START_RESET
case|:
break|break;
case|case
name|STATUS_INTERRUPT
case|:
break|break;
case|case
name|STATUS_END_RESET
case|:
break|break;
default|default:
break|break;
block|}
name|ARGSUSED
argument_list|(
name|macId
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|param1
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|indicate
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|ARGSUSED
argument_list|(
name|protDS
argument_list|)
expr_stmt|;
comment|/* We don't need to do anything about this stuff yet    */
return|return
operator|(
name|ERR_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Tell the NDIS driver to start the delivery of the packet  */
end_comment

begin_function
name|int
name|NdisSendPacket
parameter_list|(
name|struct
name|_PktBuf
modifier|*
name|pktBuf
parameter_list|,
name|int
name|macId
parameter_list|)
block|{
name|struct
name|_TxBufDescr
name|txBufDescr
decl_stmt|;
name|int
name|result
decl_stmt|;
name|xmitPending
operator|++
expr_stmt|;
name|txBufPending
operator|=
name|pktBuf
expr_stmt|;
comment|/* we only have 1 pending Tx at a time */
name|txBufDescr
operator|.
name|txImmedLen
operator|=
literal|0
expr_stmt|;
name|txBufDescr
operator|.
name|txImmedPtr
operator|=
name|NULL
expr_stmt|;
name|txBufDescr
operator|.
name|txDataCount
operator|=
literal|1
expr_stmt|;
name|txBufDescr
operator|.
name|txBufDescrRec
index|[
literal|0
index|]
operator|.
name|txPtrType
operator|=
name|NDIS_PTR_PHYSICAL
expr_stmt|;
name|txBufDescr
operator|.
name|txBufDescrRec
index|[
literal|0
index|]
operator|.
name|dummy
operator|=
literal|0
expr_stmt|;
name|txBufDescr
operator|.
name|txBufDescrRec
index|[
literal|0
index|]
operator|.
name|txDataLen
operator|=
name|pktBuf
operator|->
name|packetLength
expr_stmt|;
name|txBufDescr
operator|.
name|txBufDescrRec
index|[
literal|0
index|]
operator|.
name|txDataPtr
operator|=
name|pktBuf
operator|->
name|buffer
expr_stmt|;
name|result
operator|=
name|MAC_DISPATCH
argument_list|(
name|handle
argument_list|)
operator|->
name|transmitChain
argument_list|(
name|common
operator|.
name|moduleId
argument_list|,
name|pktBuf
operator|->
name|handle
argument_list|,
operator|&
name|txBufDescr
argument_list|,
name|handle
operator|->
name|common
operator|->
name|moduleDS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|ERR_OUT_OF_RESOURCE
case|:
comment|/* Note that this should not happen but if it does there is not           * much we can do about it           */
name|printf
argument_list|(
literal|"ERROR: transmit queue overflowed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ERR_SUCCESS
case|:
comment|/* Everything was hunky dory and synchronous. Free up the            * packet buffer           */
name|xmitPending
operator|--
expr_stmt|;
name|FreePktBuf
argument_list|(
name|pktBuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|ERR_REQUEST_QUEUED
case|:
comment|/* Everything was hunky dory and asynchronous. Do nothing           */
return|return
operator|(
literal|1
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"Tx fail, code = %04X\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|ndis_nerr
init|=
sizeof|sizeof
argument_list|(
name|ndis_errlist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ndis_errlist
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|Ndis_strerror
parameter_list|(
name|WORD
name|errorCode
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndis_nerr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|errorCode
operator|==
name|ndis_errlist
index|[
name|i
index|]
operator|.
name|err_num
condition|)
return|return
operator|(
name|ndis_errlist
index|[
name|i
index|]
operator|.
name|err_text
operator|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"unknown error %d"
argument_list|,
name|errorCode
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|NdisLastError
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|errStr
init|=
name|lastErr
decl_stmt|;
name|lastErr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|errStr
operator|)
return|;
block|}
end_function

begin_function
name|int
name|NdisOpen
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|_ReqBlock
name|reqBlock
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|ndisFd
init|=
name|open
argument_list|(
name|NDIS_PATH
argument_list|,
name|O_RDONLY
argument_list|)
decl_stmt|;
if|if
condition|(
name|ndisFd
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Could not open NDIS Protocol Manager device.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|reqBlock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ReqBlock
argument_list|)
argument_list|)
expr_stmt|;
name|reqBlock
operator|.
name|opcode
operator|=
name|PM_GET_PROTOCOL_MANAGER_LINKAGE
expr_stmt|;
name|result
operator|=
name|NdisGetLinkage
argument_list|(
name|ndisFd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reqBlock
argument_list|,
sizeof|sizeof
argument_list|(
name|ReqBlock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Could not get Protocol Manager linkage.\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ndisFd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|close
argument_list|(
name|ndisFd
argument_list|)
expr_stmt|;
name|protManEntry
operator|=
operator|(
name|ProtMan
operator|)
name|reqBlock
operator|.
name|pointer1
expr_stmt|;
name|protManDS
operator|=
name|reqBlock
operator|.
name|word1
expr_stmt|;
name|DEBUG2
argument_list|(
literal|"Entry Point = %04X:%04X\n"
argument_list|,
name|FP_SEG
argument_list|(
name|protManEntry
argument_list|)
argument_list|,
name|FP_OFF
argument_list|(
name|protManEntry
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG1
argument_list|(
literal|"ProtMan DS  = %04X\n"
argument_list|,
name|protManDS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|NdisRegisterAndBind
parameter_list|(
name|int
name|promis
parameter_list|)
block|{
name|struct
name|_ReqBlock
name|reqBlock
decl_stmt|;
name|WORD
name|result
decl_stmt|;
name|memset
argument_list|(
operator|&
name|common
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|common
argument_list|)
argument_list|)
expr_stmt|;
name|common
operator|.
name|tableSize
operator|=
sizeof|sizeof
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|common
operator|.
name|majorNdisVersion
operator|=
literal|2
expr_stmt|;
name|common
operator|.
name|minorNdisVersion
operator|=
literal|0
expr_stmt|;
name|common
operator|.
name|majorModuleVersion
operator|=
literal|2
expr_stmt|;
name|common
operator|.
name|minorModuleVersion
operator|=
literal|0
expr_stmt|;
comment|/* Indicates binding from below and dynamically loaded    */
name|common
operator|.
name|moduleFlags
operator|=
literal|0x00000006L
expr_stmt|;
name|strcpy
argument_list|(
name|common
operator|.
name|moduleName
argument_list|,
literal|"PCAP"
argument_list|)
expr_stmt|;
name|common
operator|.
name|protocolLevelUpper
operator|=
literal|0xFF
expr_stmt|;
name|common
operator|.
name|protocolLevelLower
operator|=
literal|1
expr_stmt|;
name|common
operator|.
name|interfaceLower
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|__DJGPP__
name|common
operator|.
name|moduleDS
operator|=
name|_dos_ds
expr_stmt|;
comment|/* the callback data segment */
else|#
directive|else
name|common
operator|.
name|moduleDS
operator|=
name|_DS
expr_stmt|;
endif|#
directive|endif
name|common
operator|.
name|systemRequest
operator|=
operator|(
name|SystemRequest
operator|)
name|systemRequestGlue
expr_stmt|;
name|common
operator|.
name|serviceChars
operator|=
operator|(
name|BYTE
operator|*
operator|)
operator|&
name|protChars
expr_stmt|;
name|common
operator|.
name|serviceStatus
operator|=
name|NULL
expr_stmt|;
name|common
operator|.
name|upperDispatchTable
operator|=
name|NULL
expr_stmt|;
name|common
operator|.
name|lowerDispatchTable
operator|=
operator|(
name|BYTE
operator|*
operator|)
operator|&
name|lowerTable
expr_stmt|;
name|protChars
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|protChars
argument_list|)
expr_stmt|;
name|protChars
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|protChars
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|lowerTable
operator|.
name|backPointer
operator|=
operator|&
name|common
expr_stmt|;
name|lowerTable
operator|.
name|requestConfirm
operator|=
name|requestConfirmGlue
expr_stmt|;
name|lowerTable
operator|.
name|transmitConfirm
operator|=
name|transmitConfirmGlue
expr_stmt|;
name|lowerTable
operator|.
name|receiveLookahead
operator|=
name|receiveLookaheadGlue
expr_stmt|;
name|lowerTable
operator|.
name|indicationComplete
operator|=
name|indicationCompleteGlue
expr_stmt|;
name|lowerTable
operator|.
name|receiveChain
operator|=
name|receiveChainGlue
expr_stmt|;
name|lowerTable
operator|.
name|status
operator|=
name|statusGlue
expr_stmt|;
name|lowerTable
operator|.
name|flags
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|promis
condition|)
name|lowerTable
operator|.
name|flags
operator||=
literal|4
expr_stmt|;
comment|/* promiscous mode (receive everything) */
name|bindings
operator|.
name|numBindings
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|bindings
operator|.
name|moduleName
index|[
literal|0
index|]
argument_list|,
name|handle
operator|->
name|moduleName
argument_list|)
expr_stmt|;
comment|/* Register ourselves with NDIS    */
name|reqBlock
operator|.
name|opcode
operator|=
name|PM_REGISTER_MODULE
expr_stmt|;
name|reqBlock
operator|.
name|pointer1
operator|=
operator|(
name|BYTE
name|FAR
operator|*
operator|)
operator|&
name|common
expr_stmt|;
name|reqBlock
operator|.
name|pointer2
operator|=
operator|(
name|BYTE
name|FAR
operator|*
operator|)
operator|&
name|bindings
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|protManEntry
call|)
argument_list|(
operator|&
name|reqBlock
argument_list|,
name|protManDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|printf
argument_list|(
literal|"Protman registering failed: %s\n"
argument_list|,
name|Ndis_strerror
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Start the binding process    */
name|reqBlock
operator|.
name|opcode
operator|=
name|PM_BIND_AND_START
expr_stmt|;
name|reqBlock
operator|.
name|pointer1
operator|=
operator|(
name|BYTE
name|FAR
operator|*
operator|)
operator|&
name|failingModules
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|protManEntry
call|)
argument_list|(
operator|&
name|reqBlock
argument_list|,
name|protManDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|printf
argument_list|(
literal|"Start binding failed: %s\n"
argument_list|,
name|Ndis_strerror
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|CheckMacFeatures
parameter_list|(
name|CardHandle
modifier|*
name|card
parameter_list|)
block|{
name|DWORD
name|serviceFlags
decl_stmt|;
name|BYTE
name|_far
modifier|*
name|mediaString
decl_stmt|;
name|BYTE
name|_far
modifier|*
name|mac_addr
decl_stmt|;
name|DEBUG2
argument_list|(
literal|"checking card features\n"
literal|"common table address = %08lX, macId = %d\n"
argument_list|,
name|card
operator|->
name|common
argument_list|,
name|card
operator|->
name|common
operator|->
name|moduleId
argument_list|)
expr_stmt|;
name|serviceFlags
operator|=
name|MAC_CHAR
argument_list|(
name|handle
argument_list|)
operator|->
name|serviceFlags
expr_stmt|;
if|if
condition|(
operator|(
name|serviceFlags
operator|&
name|SF_PROMISCUOUS
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"The MAC %s does not support promiscuous mode.\n"
argument_list|,
name|card
operator|->
name|moduleName
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mediaString
operator|=
name|MAC_CHAR
argument_list|(
name|handle
argument_list|)
operator|->
name|macName
expr_stmt|;
name|DEBUG1
argument_list|(
literal|"media type = %s\n"
argument_list|,
name|mediaString
argument_list|)
expr_stmt|;
comment|/* Get the media type. And set the header size    */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|mediaString
argument_list|,
literal|"802.3"
argument_list|,
literal|5
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|mediaString
argument_list|,
literal|"DIX"
argument_list|,
literal|3
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|mediaString
argument_list|,
literal|"DIX+802.3"
argument_list|,
literal|9
argument_list|)
condition|)
name|headerSize
operator|=
sizeof|sizeof
argument_list|(
name|EthernetIIHeader
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|mediaString
argument_list|,
literal|"FDDI"
argument_list|,
literal|4
argument_list|)
condition|)
name|headerSize
operator|=
sizeof|sizeof
argument_list|(
name|FddiHeader
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Ieee802Dot2SnapHeader
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"Unsupported MAC type: `%s'\n"
argument_list|,
name|mediaString
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|frameSize
operator|=
name|MAC_CHAR
argument_list|(
name|handle
argument_list|)
operator|->
name|maxFrameSize
expr_stmt|;
name|mac_addr
operator|=
name|MAC_CHAR
argument_list|(
name|handle
argument_list|)
operator|->
name|currentAddress
expr_stmt|;
name|printf
argument_list|(
literal|"Hardware address: %02X:%02X:%02X:%02X:%02X:%02X\n"
argument_list|,
name|mac_addr
index|[
literal|0
index|]
argument_list|,
name|mac_addr
index|[
literal|1
index|]
argument_list|,
name|mac_addr
index|[
literal|2
index|]
argument_list|,
name|mac_addr
index|[
literal|3
index|]
argument_list|,
name|mac_addr
index|[
literal|4
index|]
argument_list|,
name|mac_addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|NdisStartMac
parameter_list|(
name|CardHandle
modifier|*
name|card
parameter_list|)
block|{
name|WORD
name|result
decl_stmt|;
comment|/* Set the lookahead length    */
name|result
operator|=
name|MAC_DISPATCH
argument_list|(
name|handle
argument_list|)
operator|->
name|request
argument_list|(
name|common
operator|.
name|moduleId
argument_list|,
literal|0
argument_list|,
name|headerSize
argument_list|,
literal|0
argument_list|,
name|REQ_SET_LOOKAHEAD
argument_list|,
name|card
operator|->
name|common
operator|->
name|moduleDS
argument_list|)
expr_stmt|;
comment|/* We assume that if we got INVALID PARAMETER then either this    * is not supported or will work anyway. NE2000 does this.    */
if|if
condition|(
name|result
operator|!=
name|ERR_SUCCESS
operator|&&
name|result
operator|!=
name|ERR_INVALID_PARAMETER
condition|)
block|{
name|DEBUG1
argument_list|(
literal|"Set lookahead failed: %s\n"
argument_list|,
name|Ndis_strerror
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Set the packet filter. Note that for some medias and drivers we    * must specify all three flags or the card(s) will not operate correctly.    */
name|result
operator|=
name|MAC_DISPATCH
argument_list|(
name|handle
argument_list|)
operator|->
name|request
argument_list|(
name|common
operator|.
name|moduleId
argument_list|,
literal|0
argument_list|,
comment|/* all packets */
name|FILTER_PROMISCUOUS
operator||
comment|/* packets to us */
name|FILTER_DIRECTED
operator||
comment|/* broadcasts */
name|FILTER_BROADCAST
argument_list|,
literal|0
argument_list|,
name|REQ_SET_PACKET_FILTER
argument_list|,
name|card
operator|->
name|common
operator|->
name|moduleDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ERR_SUCCESS
condition|)
block|{
name|DEBUG1
argument_list|(
literal|"Set packet filter failed: %s\n"
argument_list|,
name|Ndis_strerror
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* If OPEN/CLOSE supported then open the adapter    */
if|if
condition|(
name|MAC_CHAR
argument_list|(
name|handle
argument_list|)
operator|->
name|serviceFlags
operator|&
name|SF_OPEN_CLOSE
condition|)
block|{
name|result
operator|=
name|MAC_DISPATCH
argument_list|(
name|handle
argument_list|)
operator|->
name|request
argument_list|(
name|common
operator|.
name|moduleId
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|REQ_OPEN_ADAPTER
argument_list|,
name|card
operator|->
name|common
operator|->
name|moduleDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ERR_SUCCESS
condition|)
block|{
name|DEBUG1
argument_list|(
literal|"Opening the MAC failed: %s\n"
argument_list|,
name|Ndis_strerror
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|NdisShutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|_ReqBlock
name|reqBlock
decl_stmt|;
name|int
name|result
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|handle
condition|)
return|return;
comment|/* If the adapters support open and are open then close them    */
if|if
condition|(
operator|(
name|MAC_CHAR
argument_list|(
name|handle
argument_list|)
operator|->
name|serviceFlags
operator|&
name|SF_OPEN_CLOSE
operator|)
operator|&&
operator|(
name|MAC_STATUS
argument_list|(
name|handle
argument_list|)
operator|->
name|macStatus
operator|&
name|MAC_OPEN
operator|)
condition|)
block|{
name|result
operator|=
name|MAC_DISPATCH
argument_list|(
name|handle
argument_list|)
operator|->
name|request
argument_list|(
name|common
operator|.
name|moduleId
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|REQ_CLOSE_ADAPTER
argument_list|,
name|handle
operator|->
name|common
operator|->
name|moduleDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ERR_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"Closing the MAC failed: %s\n"
argument_list|,
name|Ndis_strerror
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Tell the Protocol Manager to unbind and stop    */
name|reqBlock
operator|.
name|opcode
operator|=
name|PM_UNBIND_AND_STOP
expr_stmt|;
name|reqBlock
operator|.
name|pointer1
operator|=
operator|(
name|BYTE
name|FAR
operator|*
operator|)
operator|&
name|failingModules
expr_stmt|;
name|reqBlock
operator|.
name|pointer2
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|protManEntry
call|)
argument_list|(
operator|&
name|reqBlock
argument_list|,
name|protManDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|printf
argument_list|(
literal|"Unbind failed: %s\n"
argument_list|,
name|Ndis_strerror
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STACK_POOL_SIZE
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|freeStacks
index|[
name|i
index|]
operator|-
name|STACK_SIZE
argument_list|)
expr_stmt|;
name|handle
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|NdisInit
parameter_list|(
name|int
name|promis
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
comment|/* Allocate the real mode stacks used for NDIS callbacks    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STACK_POOL_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|freeStacks
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|STACK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|freeStacks
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|freeStacks
index|[
name|i
index|]
operator|+=
name|STACK_SIZE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NdisOpen
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|NdisRegisterAndBind
argument_list|(
name|promis
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DEBUG1
argument_list|(
literal|"My module id: %d\n"
argument_list|,
name|common
operator|.
name|moduleId
argument_list|)
expr_stmt|;
name|DEBUG1
argument_list|(
literal|"Handle id;    %d\n"
argument_list|,
name|handle
operator|->
name|common
operator|->
name|moduleId
argument_list|)
expr_stmt|;
name|DEBUG1
argument_list|(
literal|"MAC card:     %-16s - "
argument_list|,
name|handle
operator|->
name|moduleName
argument_list|)
expr_stmt|;
name|atexit
argument_list|(
name|NdisShutdown
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CheckMacFeatures
argument_list|(
operator|&
name|handle
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|mediaType
condition|)
block|{
case|case
name|MEDIA_FDDI
case|:
name|DEBUG0
argument_list|(
literal|"Media type: FDDI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEDIA_ETHERNET
case|:
name|DEBUG0
argument_list|(
literal|"Media type: ETHERNET"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DEBUG0
argument_list|(
literal|"Unsupported media.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DEBUG1
argument_list|(
literal|" - Frame size: %d\n"
argument_list|,
name|frameSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NdisStartMac
argument_list|(
operator|&
name|handle
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_NDIS2 */
end_comment

end_unit

