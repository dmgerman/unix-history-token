begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: umac.c,v 1.2 2007/09/12 19:39:19 stevesk Exp $ */
end_comment

begin_comment
comment|/* -----------------------------------------------------------------------  *   * umac.c -- C Implementation UMAC Message Authentication  *  * Version 0.93b of rfc4418.txt -- 2006 July 18  *  * For a full description of UMAC message authentication see the UMAC  * world-wide-web page at http://www.cs.ucdavis.edu/~rogaway/umac  * Please report bugs and suggestions to the UMAC webpage.  *  * Copyright (c) 1999-2006 Ted Krovetz  *                                                                   * Permission to use, copy, modify, and distribute this software and  * its documentation for any purpose and with or without fee, is hereby  * granted provided that the above copyright notice appears in all copies  * and in supporting documentation, and that the name of the copyright  * holder not be used in advertising or publicity pertaining to  * distribution of the software without specific, written prior permission.  *  * Comments should be directed to Ted Krovetz (tdk@acm.org)                                          *                                                                     * ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ////////////////////// IMPORTANT NOTES /////////////////////////////////   *   * 1) This version does not work properly on messages larger than 16MB   *   * 2) If you set the switch to use SSE2, then all data must be 16-byte   *    aligned   *   * 3) When calling the function umac(), it is assumed that msg is in   * a writable buffer of length divisible by 32 bytes. The message itself   * does not have to fill the entire buffer, but bytes beyond msg may be   * zeroed.   *   * 4) Three free AES implementations are supported by this implementation of   * UMAC. Paulo Barreto's version is in the public domain and can be found   * at http://www.esat.kuleuven.ac.be/~rijmen/rijndael/ (search for   * "Barreto"). The only two files needed are rijndael-alg-fst.c and   * rijndael-alg-fst.h. Brian Gladman's version is distributed with the GNU   * Public lisence at http://fp.gladman.plus.com/AES/index.htm. It   * includes a fast IA-32 assembly version. The OpenSSL crypo library is   * the third.   *   * 5) With FORCE_C_ONLY flags set to 0, incorrect results are sometimes   * produced under gcc with optimizations set -O3 or higher. Dunno why.   *   /////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* --- User Switches ---------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_define
define|#
directive|define
name|UMAC_OUTPUT_LEN
value|8
end_define

begin_comment
comment|/* Alowable: 4, 8, 12, 16                  */
end_comment

begin_comment
comment|/* #define FORCE_C_ONLY        1  ANSI C and 64-bit integers req'd        */
end_comment

begin_comment
comment|/* #define AES_IMPLEMENTAION   1  1 = OpenSSL, 2 = Barreto, 3 = Gladman   */
end_comment

begin_comment
comment|/* #define SSE2                0  Is SSE2 is available?                   */
end_comment

begin_comment
comment|/* #define RUN_TESTS           0  Run basic correctness/speed tests       */
end_comment

begin_comment
comment|/* #define UMAC_AE_SUPPORT     0  Enable auhthenticated encrytion         */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* -- Global Includes --------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"umac.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* --- Primitive Data Types ---                                           */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* The following assumptions may need change on your system */
end_comment

begin_typedef
typedef|typedef
name|u_int8_t
name|UINT8
typedef|;
end_typedef

begin_comment
comment|/* 1 byte   */
end_comment

begin_typedef
typedef|typedef
name|u_int16_t
name|UINT16
typedef|;
end_typedef

begin_comment
comment|/* 2 byte   */
end_comment

begin_typedef
typedef|typedef
name|u_int32_t
name|UINT32
typedef|;
end_typedef

begin_comment
comment|/* 4 byte   */
end_comment

begin_typedef
typedef|typedef
name|u_int64_t
name|UINT64
typedef|;
end_typedef

begin_comment
comment|/* 8 bytes  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|int
name|UWORD
typedef|;
end_typedef

begin_comment
comment|/* Register */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* --- Constants -------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_define
define|#
directive|define
name|UMAC_KEY_LEN
value|16
end_define

begin_comment
comment|/* UMAC takes 16 bytes of external key */
end_comment

begin_comment
comment|/* Message "words" are read from memory in an endian-specific manner.     */
end_comment

begin_comment
comment|/* For this implementation to behave correctly, __LITTLE_ENDIAN__ must    */
end_comment

begin_comment
comment|/* be set true if the host computer is little-endian.                     */
end_comment

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
end_if

begin_define
define|#
directive|define
name|__LITTLE_ENDIAN__
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__LITTLE_ENDIAN__
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ----- Architecture Specific ------------------------------------------ */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ----- Primitive Routines --------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* --- 32-bit by 32-bit to 64-bit Multiplication ------------------------ */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_define
define|#
directive|define
name|MUL64
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((UINT64)((UINT64)(UINT32)(a) * (UINT64)(UINT32)(b)))
end_define

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* --- Endian Conversion --- Forcing assembly on some platforms           */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_if
if|#
directive|if
name|HAVE_SWAP32
end_if

begin_define
define|#
directive|define
name|LOAD_UINT32_REVERSED
parameter_list|(
name|p
parameter_list|)
value|(swap32(*(UINT32 *)(p)))
end_define

begin_define
define|#
directive|define
name|STORE_UINT32_REVERSED
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|(*(UINT32 *)(p) = swap32(v))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_SWAP32 */
end_comment

begin_function
specifier|static
name|UINT32
name|LOAD_UINT32_REVERSED
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|UINT32
name|temp
init|=
operator|*
operator|(
name|UINT32
operator|*
operator|)
name|ptr
decl_stmt|;
name|temp
operator|=
operator|(
name|temp
operator|>>
literal|24
operator|)
operator||
operator|(
operator|(
name|temp
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|temp
operator|&
literal|0x0000FF00
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|temp
operator|<<
literal|24
operator|)
expr_stmt|;
return|return
operator|(
name|UINT32
operator|)
name|temp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|STORE_UINT32_REVERSED
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|UINT32
name|x
parameter_list|)
block|{
name|UINT32
name|i
init|=
operator|(
name|UINT32
operator|)
name|x
decl_stmt|;
operator|*
operator|(
name|UINT32
operator|*
operator|)
name|ptr
operator|=
operator|(
name|i
operator|>>
literal|24
operator|)
operator||
operator|(
operator|(
name|i
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|i
operator|&
literal|0x0000FF00
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|i
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SWAP32 */
end_comment

begin_comment
comment|/* The following definitions use the above reversal-primitives to do the right  * thing on endian specific load and stores.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|__LITTLE_ENDIAN__
operator|)
end_if

begin_define
define|#
directive|define
name|LOAD_UINT32_LITTLE
parameter_list|(
name|ptr
parameter_list|)
value|(*(UINT32 *)(ptr))
end_define

begin_define
define|#
directive|define
name|STORE_UINT32_BIG
parameter_list|(
name|ptr
parameter_list|,
name|x
parameter_list|)
value|STORE_UINT32_REVERSED(ptr,x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LOAD_UINT32_LITTLE
parameter_list|(
name|ptr
parameter_list|)
value|LOAD_UINT32_REVERSED(ptr)
end_define

begin_define
define|#
directive|define
name|STORE_UINT32_BIG
parameter_list|(
name|ptr
parameter_list|,
name|x
parameter_list|)
value|(*(UINT32 *)(ptr) = (UINT32)(x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ----- Begin KDF& PDF Section ---------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* UMAC uses AES with 16 byte block and key lengths */
end_comment

begin_define
define|#
directive|define
name|AES_BLOCK_LEN
value|16
end_define

begin_comment
comment|/* OpenSSL's AES */
end_comment

begin_include
include|#
directive|include
file|"openbsd-compat/openssl-compat.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USE_BUILTIN_RIJNDAEL
end_ifndef

begin_include
include|#
directive|include
file|<openssl/aes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|AES_KEY
name|aes_int_key
index|[
literal|1
index|]
typedef|;
end_typedef

begin_define
define|#
directive|define
name|aes_encryption
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|,
name|int_key
parameter_list|)
define|\
value|AES_encrypt((u_char *)(in),(u_char *)(out),(AES_KEY *)int_key)
end_define

begin_define
define|#
directive|define
name|aes_key_setup
parameter_list|(
name|key
parameter_list|,
name|int_key
parameter_list|)
define|\
value|AES_set_encrypt_key((u_char *)(key),UMAC_KEY_LEN*8,int_key)
end_define

begin_comment
comment|/* The user-supplied UMAC key is stretched using AES in a counter  * mode to supply all random bits needed by UMAC. The kdf function takes  * an AES internal key representation 'key' and writes a stream of  * 'nbytes' bytes to the memory pointed at by 'buffer_ptr'. Each distinct  * 'ndx' causes a distinct byte stream.  */
end_comment

begin_function
specifier|static
name|void
name|kdf
parameter_list|(
name|void
modifier|*
name|buffer_ptr
parameter_list|,
name|aes_int_key
name|key
parameter_list|,
name|UINT8
name|ndx
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
name|UINT8
name|in_buf
index|[
name|AES_BLOCK_LEN
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|UINT8
name|out_buf
index|[
name|AES_BLOCK_LEN
index|]
decl_stmt|;
name|UINT8
modifier|*
name|dst_buf
init|=
operator|(
name|UINT8
operator|*
operator|)
name|buffer_ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Setup the initial value */
name|in_buf
index|[
name|AES_BLOCK_LEN
operator|-
literal|9
index|]
operator|=
name|ndx
expr_stmt|;
name|in_buf
index|[
name|AES_BLOCK_LEN
operator|-
literal|1
index|]
operator|=
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|nbytes
operator|>=
name|AES_BLOCK_LEN
condition|)
block|{
name|aes_encryption
argument_list|(
name|in_buf
argument_list|,
name|out_buf
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst_buf
argument_list|,
name|out_buf
argument_list|,
name|AES_BLOCK_LEN
argument_list|)
expr_stmt|;
name|in_buf
index|[
name|AES_BLOCK_LEN
operator|-
literal|1
index|]
operator|=
operator|++
name|i
expr_stmt|;
name|nbytes
operator|-=
name|AES_BLOCK_LEN
expr_stmt|;
name|dst_buf
operator|+=
name|AES_BLOCK_LEN
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
condition|)
block|{
name|aes_encryption
argument_list|(
name|in_buf
argument_list|,
name|out_buf
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst_buf
argument_list|,
name|out_buf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The final UHASH result is XOR'd with the output of a pseudorandom  * function. Here, we use AES to generate random output and   * xor the appropriate bytes depending on the last bits of nonce.  * This scheme is optimized for sequential, increasing big-endian nonces.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|UINT8
name|cache
index|[
name|AES_BLOCK_LEN
index|]
decl_stmt|;
comment|/* Previous AES output is saved      */
name|UINT8
name|nonce
index|[
name|AES_BLOCK_LEN
index|]
decl_stmt|;
comment|/* The AES input making above cache  */
name|aes_int_key
name|prf_key
decl_stmt|;
comment|/* Expanded AES key for PDF          */
block|}
name|pdf_ctx
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|pdf_init
parameter_list|(
name|pdf_ctx
modifier|*
name|pc
parameter_list|,
name|aes_int_key
name|prf_key
parameter_list|)
block|{
name|UINT8
name|buf
index|[
name|UMAC_KEY_LEN
index|]
decl_stmt|;
name|kdf
argument_list|(
name|buf
argument_list|,
name|prf_key
argument_list|,
literal|0
argument_list|,
name|UMAC_KEY_LEN
argument_list|)
expr_stmt|;
name|aes_key_setup
argument_list|(
name|buf
argument_list|,
name|pc
operator|->
name|prf_key
argument_list|)
expr_stmt|;
comment|/* Initialize pdf and cache */
name|memset
argument_list|(
name|pc
operator|->
name|nonce
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
operator|->
name|nonce
argument_list|)
argument_list|)
expr_stmt|;
name|aes_encryption
argument_list|(
name|pc
operator|->
name|nonce
argument_list|,
name|pc
operator|->
name|cache
argument_list|,
name|pc
operator|->
name|prf_key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pdf_gen_xor
parameter_list|(
name|pdf_ctx
modifier|*
name|pc
parameter_list|,
name|UINT8
name|nonce
index|[
literal|8
index|]
parameter_list|,
name|UINT8
name|buf
index|[
literal|8
index|]
parameter_list|)
block|{
comment|/* 'ndx' indicates that we'll be using the 0th or 1st eight bytes      * of the AES output. If last time around we returned the ndx-1st      * element, then we may have the result in the cache already.      */
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|4
operator|)
define|#
directive|define
name|LOW_BIT_MASK
value|3
elif|#
directive|elif
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|8
operator|)
define|#
directive|define
name|LOW_BIT_MASK
value|1
elif|#
directive|elif
operator|(
name|UMAC_OUTPUT_LEN
operator|>
literal|8
operator|)
define|#
directive|define
name|LOW_BIT_MASK
value|0
endif|#
directive|endif
name|UINT8
name|tmp_nonce_lo
index|[
literal|4
index|]
decl_stmt|;
if|#
directive|if
name|LOW_BIT_MASK
operator|!=
literal|0
name|int
name|ndx
init|=
name|nonce
index|[
literal|7
index|]
operator|&
name|LOW_BIT_MASK
decl_stmt|;
endif|#
directive|endif
operator|*
operator|(
name|UINT32
operator|*
operator|)
name|tmp_nonce_lo
operator|=
operator|(
operator|(
name|UINT32
operator|*
operator|)
name|nonce
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|tmp_nonce_lo
index|[
literal|3
index|]
operator|&=
operator|~
name|LOW_BIT_MASK
expr_stmt|;
comment|/* zero last bit */
if|if
condition|(
operator|(
operator|(
operator|(
name|UINT32
operator|*
operator|)
name|tmp_nonce_lo
operator|)
index|[
literal|0
index|]
operator|!=
operator|(
operator|(
name|UINT32
operator|*
operator|)
name|pc
operator|->
name|nonce
operator|)
index|[
literal|1
index|]
operator|)
operator|||
operator|(
operator|(
operator|(
name|UINT32
operator|*
operator|)
name|nonce
operator|)
index|[
literal|0
index|]
operator|!=
operator|(
operator|(
name|UINT32
operator|*
operator|)
name|pc
operator|->
name|nonce
operator|)
index|[
literal|0
index|]
operator|)
condition|)
block|{
operator|(
operator|(
name|UINT32
operator|*
operator|)
name|pc
operator|->
name|nonce
operator|)
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|UINT32
operator|*
operator|)
name|nonce
operator|)
index|[
literal|0
index|]
expr_stmt|;
operator|(
operator|(
name|UINT32
operator|*
operator|)
name|pc
operator|->
name|nonce
operator|)
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|UINT32
operator|*
operator|)
name|tmp_nonce_lo
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|aes_encryption
argument_list|(
name|pc
operator|->
name|nonce
argument_list|,
name|pc
operator|->
name|cache
argument_list|,
name|pc
operator|->
name|prf_key
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|4
operator|)
operator|*
operator|(
operator|(
name|UINT32
operator|*
operator|)
name|buf
operator|)
operator|^=
operator|(
operator|(
name|UINT32
operator|*
operator|)
name|pc
operator|->
name|cache
operator|)
index|[
name|ndx
index|]
expr_stmt|;
elif|#
directive|elif
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|8
operator|)
operator|*
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|buf
operator|)
operator|^=
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|pc
operator|->
name|cache
operator|)
index|[
name|ndx
index|]
expr_stmt|;
elif|#
directive|elif
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|12
operator|)
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|buf
operator|)
index|[
literal|0
index|]
operator|^=
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|pc
operator|->
name|cache
operator|)
index|[
literal|0
index|]
expr_stmt|;
operator|(
operator|(
name|UINT32
operator|*
operator|)
name|buf
operator|)
index|[
literal|2
index|]
operator|^=
operator|(
operator|(
name|UINT32
operator|*
operator|)
name|pc
operator|->
name|cache
operator|)
index|[
literal|2
index|]
expr_stmt|;
elif|#
directive|elif
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|16
operator|)
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|buf
operator|)
index|[
literal|0
index|]
operator|^=
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|pc
operator|->
name|cache
operator|)
index|[
literal|0
index|]
expr_stmt|;
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|buf
operator|)
index|[
literal|1
index|]
operator|^=
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|pc
operator|->
name|cache
operator|)
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ----- Begin NH Hash Section ------------------------------------------ */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* The NH-based hash functions used in UMAC are described in the UMAC paper  * and specification, both of which can be found at the UMAC website.       * The interface to this implementation has two           * versions, one expects the entire message being hashed to be passed  * in a single buffer and returns the hash result immediately. The second  * allows the message to be passed in a sequence of buffers. In the            * muliple-buffer interface, the client calls the routine nh_update() as       * many times as necessary. When there is no more data to be fed to the     * hash, the client calls nh_final() which calculates the hash output.      * Before beginning another hash calculation the nh_reset() routine         * must be called. The single-buffer routine, nh(), is equivalent to    * the sequence of calls nh_update() and nh_final(); however it is          * optimized and should be prefered whenever the multiple-buffer interface  * is not necessary. When using either interface, it is the client's           * responsability to pass no more than L1_KEY_LEN bytes per hash result.              *                                                                          * The routine nh_init() initializes the nh_ctx data structure and          * must be called once, before any other PDF routine.                       */
end_comment

begin_comment
comment|/* The "nh_aux" routines do the actual NH hashing work. They   * expect buffers to be multiples of L1_PAD_BOUNDARY. These routines   * produce output for all STREAMS NH iterations in one call,    * allowing the parallel implementation of the streams.   */
end_comment

begin_define
define|#
directive|define
name|STREAMS
value|(UMAC_OUTPUT_LEN / 4)
end_define

begin_comment
comment|/* Number of times hash is applied  */
end_comment

begin_define
define|#
directive|define
name|L1_KEY_LEN
value|1024
end_define

begin_comment
comment|/* Internal key bytes                 */
end_comment

begin_define
define|#
directive|define
name|L1_KEY_SHIFT
value|16
end_define

begin_comment
comment|/* Toeplitz key shift between streams */
end_comment

begin_define
define|#
directive|define
name|L1_PAD_BOUNDARY
value|32
end_define

begin_comment
comment|/* pad message to boundary multiple   */
end_comment

begin_define
define|#
directive|define
name|ALLOC_BOUNDARY
value|16
end_define

begin_comment
comment|/* Keep buffers aligned to this       */
end_comment

begin_define
define|#
directive|define
name|HASH_BUF_BYTES
value|64
end_define

begin_comment
comment|/* nh_aux_hb buffer multiple          */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|UINT8
name|nh_key
index|[
name|L1_KEY_LEN
operator|+
name|L1_KEY_SHIFT
operator|*
operator|(
name|STREAMS
operator|-
literal|1
operator|)
index|]
decl_stmt|;
comment|/* NH Key */
name|UINT8
name|data
index|[
name|HASH_BUF_BYTES
index|]
decl_stmt|;
comment|/* Incomming data buffer           */
name|int
name|next_data_empty
decl_stmt|;
comment|/* Bookeeping variable for data buffer.       */
name|int
name|bytes_hashed
decl_stmt|;
comment|/* Bytes (out of L1_KEY_LEN) incorperated.   */
name|UINT64
name|state
index|[
name|STREAMS
index|]
decl_stmt|;
comment|/* on-line state     */
block|}
name|nh_ctx
typedef|;
end_typedef

begin_if
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|4
operator|)
end_if

begin_function
specifier|static
name|void
name|nh_aux
parameter_list|(
name|void
modifier|*
name|kp
parameter_list|,
name|void
modifier|*
name|dp
parameter_list|,
name|void
modifier|*
name|hp
parameter_list|,
name|UINT32
name|dlen
parameter_list|)
comment|/* NH hashing primitive. Previous (partial) hash result is loaded and      * then stored via hp pointer. The length of the data pointed at by "dp", * "dlen", is guaranteed to be divisible by L1_PAD_BOUNDARY (32).  Key * is expected to be endian compensated in memory at key setup.     */
block|{
name|UINT64
name|h
decl_stmt|;
name|UWORD
name|c
init|=
name|dlen
operator|/
literal|32
decl_stmt|;
name|UINT32
modifier|*
name|k
init|=
operator|(
name|UINT32
operator|*
operator|)
name|kp
decl_stmt|;
name|UINT32
modifier|*
name|d
init|=
operator|(
name|UINT32
operator|*
operator|)
name|dp
decl_stmt|;
name|UINT32
name|d0
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|,
name|d4
decl_stmt|,
name|d5
decl_stmt|,
name|d6
decl_stmt|,
name|d7
decl_stmt|;
name|UINT32
name|k0
decl_stmt|,
name|k1
decl_stmt|,
name|k2
decl_stmt|,
name|k3
decl_stmt|,
name|k4
decl_stmt|,
name|k5
decl_stmt|,
name|k6
decl_stmt|,
name|k7
decl_stmt|;
name|h
operator|=
operator|*
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|)
expr_stmt|;
do|do
block|{
name|d0
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|0
argument_list|)
expr_stmt|;
name|d1
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|2
argument_list|)
expr_stmt|;
name|d3
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|3
argument_list|)
expr_stmt|;
name|d4
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|4
argument_list|)
expr_stmt|;
name|d5
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|5
argument_list|)
expr_stmt|;
name|d6
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|6
argument_list|)
expr_stmt|;
name|d7
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|7
argument_list|)
expr_stmt|;
name|k0
operator|=
operator|*
operator|(
name|k
operator|+
literal|0
operator|)
expr_stmt|;
name|k1
operator|=
operator|*
operator|(
name|k
operator|+
literal|1
operator|)
expr_stmt|;
name|k2
operator|=
operator|*
operator|(
name|k
operator|+
literal|2
operator|)
expr_stmt|;
name|k3
operator|=
operator|*
operator|(
name|k
operator|+
literal|3
operator|)
expr_stmt|;
name|k4
operator|=
operator|*
operator|(
name|k
operator|+
literal|4
operator|)
expr_stmt|;
name|k5
operator|=
operator|*
operator|(
name|k
operator|+
literal|5
operator|)
expr_stmt|;
name|k6
operator|=
operator|*
operator|(
name|k
operator|+
literal|6
operator|)
expr_stmt|;
name|k7
operator|=
operator|*
operator|(
name|k
operator|+
literal|7
operator|)
expr_stmt|;
name|h
operator|+=
name|MUL64
argument_list|(
operator|(
name|k0
operator|+
name|d0
operator|)
argument_list|,
operator|(
name|k4
operator|+
name|d4
operator|)
argument_list|)
expr_stmt|;
name|h
operator|+=
name|MUL64
argument_list|(
operator|(
name|k1
operator|+
name|d1
operator|)
argument_list|,
operator|(
name|k5
operator|+
name|d5
operator|)
argument_list|)
expr_stmt|;
name|h
operator|+=
name|MUL64
argument_list|(
operator|(
name|k2
operator|+
name|d2
operator|)
argument_list|,
operator|(
name|k6
operator|+
name|d6
operator|)
argument_list|)
expr_stmt|;
name|h
operator|+=
name|MUL64
argument_list|(
operator|(
name|k3
operator|+
name|d3
operator|)
argument_list|,
operator|(
name|k7
operator|+
name|d7
operator|)
argument_list|)
expr_stmt|;
name|d
operator|+=
literal|8
expr_stmt|;
name|k
operator|+=
literal|8
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|c
condition|)
do|;
operator|*
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|)
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_elif
elif|#
directive|elif
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|8
operator|)
end_elif

begin_function
specifier|static
name|void
name|nh_aux
parameter_list|(
name|void
modifier|*
name|kp
parameter_list|,
name|void
modifier|*
name|dp
parameter_list|,
name|void
modifier|*
name|hp
parameter_list|,
name|UINT32
name|dlen
parameter_list|)
comment|/* Same as previous nh_aux, but two streams are handled in one pass,  * reading and writing 16 bytes of hash-state per call.  */
block|{
name|UINT64
name|h1
decl_stmt|,
name|h2
decl_stmt|;
name|UWORD
name|c
init|=
name|dlen
operator|/
literal|32
decl_stmt|;
name|UINT32
modifier|*
name|k
init|=
operator|(
name|UINT32
operator|*
operator|)
name|kp
decl_stmt|;
name|UINT32
modifier|*
name|d
init|=
operator|(
name|UINT32
operator|*
operator|)
name|dp
decl_stmt|;
name|UINT32
name|d0
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|,
name|d4
decl_stmt|,
name|d5
decl_stmt|,
name|d6
decl_stmt|,
name|d7
decl_stmt|;
name|UINT32
name|k0
decl_stmt|,
name|k1
decl_stmt|,
name|k2
decl_stmt|,
name|k3
decl_stmt|,
name|k4
decl_stmt|,
name|k5
decl_stmt|,
name|k6
decl_stmt|,
name|k7
decl_stmt|,
name|k8
decl_stmt|,
name|k9
decl_stmt|,
name|k10
decl_stmt|,
name|k11
decl_stmt|;
name|h1
operator|=
operator|*
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|)
expr_stmt|;
name|h2
operator|=
operator|*
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|+
literal|1
operator|)
expr_stmt|;
name|k0
operator|=
operator|*
operator|(
name|k
operator|+
literal|0
operator|)
expr_stmt|;
name|k1
operator|=
operator|*
operator|(
name|k
operator|+
literal|1
operator|)
expr_stmt|;
name|k2
operator|=
operator|*
operator|(
name|k
operator|+
literal|2
operator|)
expr_stmt|;
name|k3
operator|=
operator|*
operator|(
name|k
operator|+
literal|3
operator|)
expr_stmt|;
do|do
block|{
name|d0
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|0
argument_list|)
expr_stmt|;
name|d1
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|2
argument_list|)
expr_stmt|;
name|d3
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|3
argument_list|)
expr_stmt|;
name|d4
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|4
argument_list|)
expr_stmt|;
name|d5
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|5
argument_list|)
expr_stmt|;
name|d6
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|6
argument_list|)
expr_stmt|;
name|d7
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|7
argument_list|)
expr_stmt|;
name|k4
operator|=
operator|*
operator|(
name|k
operator|+
literal|4
operator|)
expr_stmt|;
name|k5
operator|=
operator|*
operator|(
name|k
operator|+
literal|5
operator|)
expr_stmt|;
name|k6
operator|=
operator|*
operator|(
name|k
operator|+
literal|6
operator|)
expr_stmt|;
name|k7
operator|=
operator|*
operator|(
name|k
operator|+
literal|7
operator|)
expr_stmt|;
name|k8
operator|=
operator|*
operator|(
name|k
operator|+
literal|8
operator|)
expr_stmt|;
name|k9
operator|=
operator|*
operator|(
name|k
operator|+
literal|9
operator|)
expr_stmt|;
name|k10
operator|=
operator|*
operator|(
name|k
operator|+
literal|10
operator|)
expr_stmt|;
name|k11
operator|=
operator|*
operator|(
name|k
operator|+
literal|11
operator|)
expr_stmt|;
name|h1
operator|+=
name|MUL64
argument_list|(
operator|(
name|k0
operator|+
name|d0
operator|)
argument_list|,
operator|(
name|k4
operator|+
name|d4
operator|)
argument_list|)
expr_stmt|;
name|h2
operator|+=
name|MUL64
argument_list|(
operator|(
name|k4
operator|+
name|d0
operator|)
argument_list|,
operator|(
name|k8
operator|+
name|d4
operator|)
argument_list|)
expr_stmt|;
name|h1
operator|+=
name|MUL64
argument_list|(
operator|(
name|k1
operator|+
name|d1
operator|)
argument_list|,
operator|(
name|k5
operator|+
name|d5
operator|)
argument_list|)
expr_stmt|;
name|h2
operator|+=
name|MUL64
argument_list|(
operator|(
name|k5
operator|+
name|d1
operator|)
argument_list|,
operator|(
name|k9
operator|+
name|d5
operator|)
argument_list|)
expr_stmt|;
name|h1
operator|+=
name|MUL64
argument_list|(
operator|(
name|k2
operator|+
name|d2
operator|)
argument_list|,
operator|(
name|k6
operator|+
name|d6
operator|)
argument_list|)
expr_stmt|;
name|h2
operator|+=
name|MUL64
argument_list|(
operator|(
name|k6
operator|+
name|d2
operator|)
argument_list|,
operator|(
name|k10
operator|+
name|d6
operator|)
argument_list|)
expr_stmt|;
name|h1
operator|+=
name|MUL64
argument_list|(
operator|(
name|k3
operator|+
name|d3
operator|)
argument_list|,
operator|(
name|k7
operator|+
name|d7
operator|)
argument_list|)
expr_stmt|;
name|h2
operator|+=
name|MUL64
argument_list|(
operator|(
name|k7
operator|+
name|d3
operator|)
argument_list|,
operator|(
name|k11
operator|+
name|d7
operator|)
argument_list|)
expr_stmt|;
name|k0
operator|=
name|k8
expr_stmt|;
name|k1
operator|=
name|k9
expr_stmt|;
name|k2
operator|=
name|k10
expr_stmt|;
name|k3
operator|=
name|k11
expr_stmt|;
name|d
operator|+=
literal|8
expr_stmt|;
name|k
operator|+=
literal|8
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|c
condition|)
do|;
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|)
index|[
literal|0
index|]
operator|=
name|h1
expr_stmt|;
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|)
index|[
literal|1
index|]
operator|=
name|h2
expr_stmt|;
block|}
end_function

begin_elif
elif|#
directive|elif
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|12
operator|)
end_elif

begin_function
specifier|static
name|void
name|nh_aux
parameter_list|(
name|void
modifier|*
name|kp
parameter_list|,
name|void
modifier|*
name|dp
parameter_list|,
name|void
modifier|*
name|hp
parameter_list|,
name|UINT32
name|dlen
parameter_list|)
comment|/* Same as previous nh_aux, but two streams are handled in one pass,  * reading and writing 24 bytes of hash-state per call. */
block|{
name|UINT64
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|h3
decl_stmt|;
name|UWORD
name|c
init|=
name|dlen
operator|/
literal|32
decl_stmt|;
name|UINT32
modifier|*
name|k
init|=
operator|(
name|UINT32
operator|*
operator|)
name|kp
decl_stmt|;
name|UINT32
modifier|*
name|d
init|=
operator|(
name|UINT32
operator|*
operator|)
name|dp
decl_stmt|;
name|UINT32
name|d0
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|,
name|d4
decl_stmt|,
name|d5
decl_stmt|,
name|d6
decl_stmt|,
name|d7
decl_stmt|;
name|UINT32
name|k0
decl_stmt|,
name|k1
decl_stmt|,
name|k2
decl_stmt|,
name|k3
decl_stmt|,
name|k4
decl_stmt|,
name|k5
decl_stmt|,
name|k6
decl_stmt|,
name|k7
decl_stmt|,
name|k8
decl_stmt|,
name|k9
decl_stmt|,
name|k10
decl_stmt|,
name|k11
decl_stmt|,
name|k12
decl_stmt|,
name|k13
decl_stmt|,
name|k14
decl_stmt|,
name|k15
decl_stmt|;
name|h1
operator|=
operator|*
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|)
expr_stmt|;
name|h2
operator|=
operator|*
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|+
literal|1
operator|)
expr_stmt|;
name|h3
operator|=
operator|*
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|+
literal|2
operator|)
expr_stmt|;
name|k0
operator|=
operator|*
operator|(
name|k
operator|+
literal|0
operator|)
expr_stmt|;
name|k1
operator|=
operator|*
operator|(
name|k
operator|+
literal|1
operator|)
expr_stmt|;
name|k2
operator|=
operator|*
operator|(
name|k
operator|+
literal|2
operator|)
expr_stmt|;
name|k3
operator|=
operator|*
operator|(
name|k
operator|+
literal|3
operator|)
expr_stmt|;
name|k4
operator|=
operator|*
operator|(
name|k
operator|+
literal|4
operator|)
expr_stmt|;
name|k5
operator|=
operator|*
operator|(
name|k
operator|+
literal|5
operator|)
expr_stmt|;
name|k6
operator|=
operator|*
operator|(
name|k
operator|+
literal|6
operator|)
expr_stmt|;
name|k7
operator|=
operator|*
operator|(
name|k
operator|+
literal|7
operator|)
expr_stmt|;
do|do
block|{
name|d0
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|0
argument_list|)
expr_stmt|;
name|d1
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|2
argument_list|)
expr_stmt|;
name|d3
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|3
argument_list|)
expr_stmt|;
name|d4
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|4
argument_list|)
expr_stmt|;
name|d5
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|5
argument_list|)
expr_stmt|;
name|d6
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|6
argument_list|)
expr_stmt|;
name|d7
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|7
argument_list|)
expr_stmt|;
name|k8
operator|=
operator|*
operator|(
name|k
operator|+
literal|8
operator|)
expr_stmt|;
name|k9
operator|=
operator|*
operator|(
name|k
operator|+
literal|9
operator|)
expr_stmt|;
name|k10
operator|=
operator|*
operator|(
name|k
operator|+
literal|10
operator|)
expr_stmt|;
name|k11
operator|=
operator|*
operator|(
name|k
operator|+
literal|11
operator|)
expr_stmt|;
name|k12
operator|=
operator|*
operator|(
name|k
operator|+
literal|12
operator|)
expr_stmt|;
name|k13
operator|=
operator|*
operator|(
name|k
operator|+
literal|13
operator|)
expr_stmt|;
name|k14
operator|=
operator|*
operator|(
name|k
operator|+
literal|14
operator|)
expr_stmt|;
name|k15
operator|=
operator|*
operator|(
name|k
operator|+
literal|15
operator|)
expr_stmt|;
name|h1
operator|+=
name|MUL64
argument_list|(
operator|(
name|k0
operator|+
name|d0
operator|)
argument_list|,
operator|(
name|k4
operator|+
name|d4
operator|)
argument_list|)
expr_stmt|;
name|h2
operator|+=
name|MUL64
argument_list|(
operator|(
name|k4
operator|+
name|d0
operator|)
argument_list|,
operator|(
name|k8
operator|+
name|d4
operator|)
argument_list|)
expr_stmt|;
name|h3
operator|+=
name|MUL64
argument_list|(
operator|(
name|k8
operator|+
name|d0
operator|)
argument_list|,
operator|(
name|k12
operator|+
name|d4
operator|)
argument_list|)
expr_stmt|;
name|h1
operator|+=
name|MUL64
argument_list|(
operator|(
name|k1
operator|+
name|d1
operator|)
argument_list|,
operator|(
name|k5
operator|+
name|d5
operator|)
argument_list|)
expr_stmt|;
name|h2
operator|+=
name|MUL64
argument_list|(
operator|(
name|k5
operator|+
name|d1
operator|)
argument_list|,
operator|(
name|k9
operator|+
name|d5
operator|)
argument_list|)
expr_stmt|;
name|h3
operator|+=
name|MUL64
argument_list|(
operator|(
name|k9
operator|+
name|d1
operator|)
argument_list|,
operator|(
name|k13
operator|+
name|d5
operator|)
argument_list|)
expr_stmt|;
name|h1
operator|+=
name|MUL64
argument_list|(
operator|(
name|k2
operator|+
name|d2
operator|)
argument_list|,
operator|(
name|k6
operator|+
name|d6
operator|)
argument_list|)
expr_stmt|;
name|h2
operator|+=
name|MUL64
argument_list|(
operator|(
name|k6
operator|+
name|d2
operator|)
argument_list|,
operator|(
name|k10
operator|+
name|d6
operator|)
argument_list|)
expr_stmt|;
name|h3
operator|+=
name|MUL64
argument_list|(
operator|(
name|k10
operator|+
name|d2
operator|)
argument_list|,
operator|(
name|k14
operator|+
name|d6
operator|)
argument_list|)
expr_stmt|;
name|h1
operator|+=
name|MUL64
argument_list|(
operator|(
name|k3
operator|+
name|d3
operator|)
argument_list|,
operator|(
name|k7
operator|+
name|d7
operator|)
argument_list|)
expr_stmt|;
name|h2
operator|+=
name|MUL64
argument_list|(
operator|(
name|k7
operator|+
name|d3
operator|)
argument_list|,
operator|(
name|k11
operator|+
name|d7
operator|)
argument_list|)
expr_stmt|;
name|h3
operator|+=
name|MUL64
argument_list|(
operator|(
name|k11
operator|+
name|d3
operator|)
argument_list|,
operator|(
name|k15
operator|+
name|d7
operator|)
argument_list|)
expr_stmt|;
name|k0
operator|=
name|k8
expr_stmt|;
name|k1
operator|=
name|k9
expr_stmt|;
name|k2
operator|=
name|k10
expr_stmt|;
name|k3
operator|=
name|k11
expr_stmt|;
name|k4
operator|=
name|k12
expr_stmt|;
name|k5
operator|=
name|k13
expr_stmt|;
name|k6
operator|=
name|k14
expr_stmt|;
name|k7
operator|=
name|k15
expr_stmt|;
name|d
operator|+=
literal|8
expr_stmt|;
name|k
operator|+=
literal|8
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|c
condition|)
do|;
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|)
index|[
literal|0
index|]
operator|=
name|h1
expr_stmt|;
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|)
index|[
literal|1
index|]
operator|=
name|h2
expr_stmt|;
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|)
index|[
literal|2
index|]
operator|=
name|h3
expr_stmt|;
block|}
end_function

begin_elif
elif|#
directive|elif
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|16
operator|)
end_elif

begin_function
specifier|static
name|void
name|nh_aux
parameter_list|(
name|void
modifier|*
name|kp
parameter_list|,
name|void
modifier|*
name|dp
parameter_list|,
name|void
modifier|*
name|hp
parameter_list|,
name|UINT32
name|dlen
parameter_list|)
comment|/* Same as previous nh_aux, but two streams are handled in one pass,  * reading and writing 24 bytes of hash-state per call. */
block|{
name|UINT64
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|h3
decl_stmt|,
name|h4
decl_stmt|;
name|UWORD
name|c
init|=
name|dlen
operator|/
literal|32
decl_stmt|;
name|UINT32
modifier|*
name|k
init|=
operator|(
name|UINT32
operator|*
operator|)
name|kp
decl_stmt|;
name|UINT32
modifier|*
name|d
init|=
operator|(
name|UINT32
operator|*
operator|)
name|dp
decl_stmt|;
name|UINT32
name|d0
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|,
name|d4
decl_stmt|,
name|d5
decl_stmt|,
name|d6
decl_stmt|,
name|d7
decl_stmt|;
name|UINT32
name|k0
decl_stmt|,
name|k1
decl_stmt|,
name|k2
decl_stmt|,
name|k3
decl_stmt|,
name|k4
decl_stmt|,
name|k5
decl_stmt|,
name|k6
decl_stmt|,
name|k7
decl_stmt|,
name|k8
decl_stmt|,
name|k9
decl_stmt|,
name|k10
decl_stmt|,
name|k11
decl_stmt|,
name|k12
decl_stmt|,
name|k13
decl_stmt|,
name|k14
decl_stmt|,
name|k15
decl_stmt|,
name|k16
decl_stmt|,
name|k17
decl_stmt|,
name|k18
decl_stmt|,
name|k19
decl_stmt|;
name|h1
operator|=
operator|*
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|)
expr_stmt|;
name|h2
operator|=
operator|*
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|+
literal|1
operator|)
expr_stmt|;
name|h3
operator|=
operator|*
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|+
literal|2
operator|)
expr_stmt|;
name|h4
operator|=
operator|*
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|+
literal|3
operator|)
expr_stmt|;
name|k0
operator|=
operator|*
operator|(
name|k
operator|+
literal|0
operator|)
expr_stmt|;
name|k1
operator|=
operator|*
operator|(
name|k
operator|+
literal|1
operator|)
expr_stmt|;
name|k2
operator|=
operator|*
operator|(
name|k
operator|+
literal|2
operator|)
expr_stmt|;
name|k3
operator|=
operator|*
operator|(
name|k
operator|+
literal|3
operator|)
expr_stmt|;
name|k4
operator|=
operator|*
operator|(
name|k
operator|+
literal|4
operator|)
expr_stmt|;
name|k5
operator|=
operator|*
operator|(
name|k
operator|+
literal|5
operator|)
expr_stmt|;
name|k6
operator|=
operator|*
operator|(
name|k
operator|+
literal|6
operator|)
expr_stmt|;
name|k7
operator|=
operator|*
operator|(
name|k
operator|+
literal|7
operator|)
expr_stmt|;
do|do
block|{
name|d0
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|0
argument_list|)
expr_stmt|;
name|d1
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|2
argument_list|)
expr_stmt|;
name|d3
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|3
argument_list|)
expr_stmt|;
name|d4
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|4
argument_list|)
expr_stmt|;
name|d5
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|5
argument_list|)
expr_stmt|;
name|d6
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|6
argument_list|)
expr_stmt|;
name|d7
operator|=
name|LOAD_UINT32_LITTLE
argument_list|(
name|d
operator|+
literal|7
argument_list|)
expr_stmt|;
name|k8
operator|=
operator|*
operator|(
name|k
operator|+
literal|8
operator|)
expr_stmt|;
name|k9
operator|=
operator|*
operator|(
name|k
operator|+
literal|9
operator|)
expr_stmt|;
name|k10
operator|=
operator|*
operator|(
name|k
operator|+
literal|10
operator|)
expr_stmt|;
name|k11
operator|=
operator|*
operator|(
name|k
operator|+
literal|11
operator|)
expr_stmt|;
name|k12
operator|=
operator|*
operator|(
name|k
operator|+
literal|12
operator|)
expr_stmt|;
name|k13
operator|=
operator|*
operator|(
name|k
operator|+
literal|13
operator|)
expr_stmt|;
name|k14
operator|=
operator|*
operator|(
name|k
operator|+
literal|14
operator|)
expr_stmt|;
name|k15
operator|=
operator|*
operator|(
name|k
operator|+
literal|15
operator|)
expr_stmt|;
name|k16
operator|=
operator|*
operator|(
name|k
operator|+
literal|16
operator|)
expr_stmt|;
name|k17
operator|=
operator|*
operator|(
name|k
operator|+
literal|17
operator|)
expr_stmt|;
name|k18
operator|=
operator|*
operator|(
name|k
operator|+
literal|18
operator|)
expr_stmt|;
name|k19
operator|=
operator|*
operator|(
name|k
operator|+
literal|19
operator|)
expr_stmt|;
name|h1
operator|+=
name|MUL64
argument_list|(
operator|(
name|k0
operator|+
name|d0
operator|)
argument_list|,
operator|(
name|k4
operator|+
name|d4
operator|)
argument_list|)
expr_stmt|;
name|h2
operator|+=
name|MUL64
argument_list|(
operator|(
name|k4
operator|+
name|d0
operator|)
argument_list|,
operator|(
name|k8
operator|+
name|d4
operator|)
argument_list|)
expr_stmt|;
name|h3
operator|+=
name|MUL64
argument_list|(
operator|(
name|k8
operator|+
name|d0
operator|)
argument_list|,
operator|(
name|k12
operator|+
name|d4
operator|)
argument_list|)
expr_stmt|;
name|h4
operator|+=
name|MUL64
argument_list|(
operator|(
name|k12
operator|+
name|d0
operator|)
argument_list|,
operator|(
name|k16
operator|+
name|d4
operator|)
argument_list|)
expr_stmt|;
name|h1
operator|+=
name|MUL64
argument_list|(
operator|(
name|k1
operator|+
name|d1
operator|)
argument_list|,
operator|(
name|k5
operator|+
name|d5
operator|)
argument_list|)
expr_stmt|;
name|h2
operator|+=
name|MUL64
argument_list|(
operator|(
name|k5
operator|+
name|d1
operator|)
argument_list|,
operator|(
name|k9
operator|+
name|d5
operator|)
argument_list|)
expr_stmt|;
name|h3
operator|+=
name|MUL64
argument_list|(
operator|(
name|k9
operator|+
name|d1
operator|)
argument_list|,
operator|(
name|k13
operator|+
name|d5
operator|)
argument_list|)
expr_stmt|;
name|h4
operator|+=
name|MUL64
argument_list|(
operator|(
name|k13
operator|+
name|d1
operator|)
argument_list|,
operator|(
name|k17
operator|+
name|d5
operator|)
argument_list|)
expr_stmt|;
name|h1
operator|+=
name|MUL64
argument_list|(
operator|(
name|k2
operator|+
name|d2
operator|)
argument_list|,
operator|(
name|k6
operator|+
name|d6
operator|)
argument_list|)
expr_stmt|;
name|h2
operator|+=
name|MUL64
argument_list|(
operator|(
name|k6
operator|+
name|d2
operator|)
argument_list|,
operator|(
name|k10
operator|+
name|d6
operator|)
argument_list|)
expr_stmt|;
name|h3
operator|+=
name|MUL64
argument_list|(
operator|(
name|k10
operator|+
name|d2
operator|)
argument_list|,
operator|(
name|k14
operator|+
name|d6
operator|)
argument_list|)
expr_stmt|;
name|h4
operator|+=
name|MUL64
argument_list|(
operator|(
name|k14
operator|+
name|d2
operator|)
argument_list|,
operator|(
name|k18
operator|+
name|d6
operator|)
argument_list|)
expr_stmt|;
name|h1
operator|+=
name|MUL64
argument_list|(
operator|(
name|k3
operator|+
name|d3
operator|)
argument_list|,
operator|(
name|k7
operator|+
name|d7
operator|)
argument_list|)
expr_stmt|;
name|h2
operator|+=
name|MUL64
argument_list|(
operator|(
name|k7
operator|+
name|d3
operator|)
argument_list|,
operator|(
name|k11
operator|+
name|d7
operator|)
argument_list|)
expr_stmt|;
name|h3
operator|+=
name|MUL64
argument_list|(
operator|(
name|k11
operator|+
name|d3
operator|)
argument_list|,
operator|(
name|k15
operator|+
name|d7
operator|)
argument_list|)
expr_stmt|;
name|h4
operator|+=
name|MUL64
argument_list|(
operator|(
name|k15
operator|+
name|d3
operator|)
argument_list|,
operator|(
name|k19
operator|+
name|d7
operator|)
argument_list|)
expr_stmt|;
name|k0
operator|=
name|k8
expr_stmt|;
name|k1
operator|=
name|k9
expr_stmt|;
name|k2
operator|=
name|k10
expr_stmt|;
name|k3
operator|=
name|k11
expr_stmt|;
name|k4
operator|=
name|k12
expr_stmt|;
name|k5
operator|=
name|k13
expr_stmt|;
name|k6
operator|=
name|k14
expr_stmt|;
name|k7
operator|=
name|k15
expr_stmt|;
name|k8
operator|=
name|k16
expr_stmt|;
name|k9
operator|=
name|k17
expr_stmt|;
name|k10
operator|=
name|k18
expr_stmt|;
name|k11
operator|=
name|k19
expr_stmt|;
name|d
operator|+=
literal|8
expr_stmt|;
name|k
operator|+=
literal|8
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|c
condition|)
do|;
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|)
index|[
literal|0
index|]
operator|=
name|h1
expr_stmt|;
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|)
index|[
literal|1
index|]
operator|=
name|h2
expr_stmt|;
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|)
index|[
literal|2
index|]
operator|=
name|h3
expr_stmt|;
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hp
operator|)
index|[
literal|3
index|]
operator|=
name|h4
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UMAC_OUTPUT_LENGTH */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|nh_transform
parameter_list|(
name|nh_ctx
modifier|*
name|hc
parameter_list|,
name|UINT8
modifier|*
name|buf
parameter_list|,
name|UINT32
name|nbytes
parameter_list|)
comment|/* This function is a wrapper for the primitive NH hash functions. It takes  * as argument "hc" the current hash context and a buffer which must be a  * multiple of L1_PAD_BOUNDARY. The key passed to nh_aux is offset  * appropriately according to how much message has been hashed already.  */
block|{
name|UINT8
modifier|*
name|key
decl_stmt|;
name|key
operator|=
name|hc
operator|->
name|nh_key
operator|+
name|hc
operator|->
name|bytes_hashed
expr_stmt|;
name|nh_aux
argument_list|(
name|key
argument_list|,
name|buf
argument_list|,
name|hc
operator|->
name|state
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|endian_convert
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|UWORD
name|bpw
parameter_list|,
name|UINT32
name|num_bytes
parameter_list|)
comment|/* We endian convert the keys on little-endian computers to               */
comment|/* compensate for the lack of big-endian memory reads during hashing.     */
block|{
name|UWORD
name|iters
init|=
name|num_bytes
operator|/
name|bpw
decl_stmt|;
if|if
condition|(
name|bpw
operator|==
literal|4
condition|)
block|{
name|UINT32
modifier|*
name|p
init|=
operator|(
name|UINT32
operator|*
operator|)
name|buf
decl_stmt|;
do|do
block|{
operator|*
name|p
operator|=
name|LOAD_UINT32_REVERSED
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|iters
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|bpw
operator|==
literal|8
condition|)
block|{
name|UINT32
modifier|*
name|p
init|=
operator|(
name|UINT32
operator|*
operator|)
name|buf
decl_stmt|;
name|UINT32
name|t
decl_stmt|;
do|do
block|{
name|t
operator|=
name|LOAD_UINT32_REVERSED
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|LOAD_UINT32_REVERSED
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|iters
condition|)
do|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|__LITTLE_ENDIAN__
operator|)
end_if

begin_define
define|#
directive|define
name|endian_convert_if_le
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|endian_convert((x),(y),(z))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|endian_convert_if_le
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|do{}while(0)
end_define

begin_comment
comment|/* Do nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|nh_reset
parameter_list|(
name|nh_ctx
modifier|*
name|hc
parameter_list|)
comment|/* Reset nh_ctx to ready for hashing of new data */
block|{
name|hc
operator|->
name|bytes_hashed
operator|=
literal|0
expr_stmt|;
name|hc
operator|->
name|next_data_empty
operator|=
literal|0
expr_stmt|;
name|hc
operator|->
name|state
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|>=
literal|8
operator|)
name|hc
operator|->
name|state
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|>=
literal|12
operator|)
name|hc
operator|->
name|state
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|16
operator|)
name|hc
operator|->
name|state
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|nh_init
parameter_list|(
name|nh_ctx
modifier|*
name|hc
parameter_list|,
name|aes_int_key
name|prf_key
parameter_list|)
comment|/* Generate nh_key, endian convert and reset to be ready for hashing.   */
block|{
name|kdf
argument_list|(
name|hc
operator|->
name|nh_key
argument_list|,
name|prf_key
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|hc
operator|->
name|nh_key
argument_list|)
argument_list|)
expr_stmt|;
name|endian_convert_if_le
argument_list|(
name|hc
operator|->
name|nh_key
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|hc
operator|->
name|nh_key
argument_list|)
argument_list|)
expr_stmt|;
name|nh_reset
argument_list|(
name|hc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|nh_update
parameter_list|(
name|nh_ctx
modifier|*
name|hc
parameter_list|,
name|UINT8
modifier|*
name|buf
parameter_list|,
name|UINT32
name|nbytes
parameter_list|)
comment|/* Incorporate nbytes of data into a nh_ctx, buffer whatever is not an    */
comment|/* even multiple of HASH_BUF_BYTES.                                       */
block|{
name|UINT32
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
name|hc
operator|->
name|next_data_empty
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|+
name|nbytes
operator|)
operator|>=
name|HASH_BUF_BYTES
condition|)
block|{
if|if
condition|(
name|j
condition|)
block|{
name|i
operator|=
name|HASH_BUF_BYTES
operator|-
name|j
expr_stmt|;
name|memcpy
argument_list|(
name|hc
operator|->
name|data
operator|+
name|j
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|nh_transform
argument_list|(
name|hc
argument_list|,
name|hc
operator|->
name|data
argument_list|,
name|HASH_BUF_BYTES
argument_list|)
expr_stmt|;
name|nbytes
operator|-=
name|i
expr_stmt|;
name|buf
operator|+=
name|i
expr_stmt|;
name|hc
operator|->
name|bytes_hashed
operator|+=
name|HASH_BUF_BYTES
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
operator|>=
name|HASH_BUF_BYTES
condition|)
block|{
name|i
operator|=
name|nbytes
operator|&
operator|~
operator|(
name|HASH_BUF_BYTES
operator|-
literal|1
operator|)
expr_stmt|;
name|nh_transform
argument_list|(
name|hc
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|nbytes
operator|-=
name|i
expr_stmt|;
name|buf
operator|+=
name|i
expr_stmt|;
name|hc
operator|->
name|bytes_hashed
operator|+=
name|i
expr_stmt|;
block|}
name|j
operator|=
literal|0
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|hc
operator|->
name|data
operator|+
name|j
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|hc
operator|->
name|next_data_empty
operator|=
name|j
operator|+
name|nbytes
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|zero_pad
parameter_list|(
name|UINT8
modifier|*
name|p
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
comment|/* Write "nbytes" of zeroes, beginning at "p" */
if|if
condition|(
name|nbytes
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|UWORD
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|ptrdiff_t
operator|)
name|p
operator|%
sizeof|sizeof
argument_list|(
name|UWORD
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|--
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|nbytes
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|UWORD
argument_list|)
condition|)
block|{
operator|*
operator|(
name|UWORD
operator|*
operator|)
name|p
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|-=
sizeof|sizeof
argument_list|(
name|UWORD
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|UWORD
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|nbytes
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|--
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|nh_final
parameter_list|(
name|nh_ctx
modifier|*
name|hc
parameter_list|,
name|UINT8
modifier|*
name|result
parameter_list|)
comment|/* After passing some number of data buffers to nh_update() for integration  * into an NH context, nh_final is called to produce a hash result. If any  * bytes are in the buffer hc->data, incorporate them into the  * NH context. Finally, add into the NH accumulation "state" the total number  * of bits hashed. The resulting numbers are written to the buffer "result".  * If nh_update was never called, L1_PAD_BOUNDARY zeroes are incorporated.  */
block|{
name|int
name|nh_len
decl_stmt|,
name|nbits
decl_stmt|;
if|if
condition|(
name|hc
operator|->
name|next_data_empty
operator|!=
literal|0
condition|)
block|{
name|nh_len
operator|=
operator|(
operator|(
name|hc
operator|->
name|next_data_empty
operator|+
operator|(
name|L1_PAD_BOUNDARY
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|L1_PAD_BOUNDARY
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|zero_pad
argument_list|(
name|hc
operator|->
name|data
operator|+
name|hc
operator|->
name|next_data_empty
argument_list|,
name|nh_len
operator|-
name|hc
operator|->
name|next_data_empty
argument_list|)
expr_stmt|;
name|nh_transform
argument_list|(
name|hc
argument_list|,
name|hc
operator|->
name|data
argument_list|,
name|nh_len
argument_list|)
expr_stmt|;
name|hc
operator|->
name|bytes_hashed
operator|+=
name|hc
operator|->
name|next_data_empty
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hc
operator|->
name|bytes_hashed
operator|==
literal|0
condition|)
block|{
name|nh_len
operator|=
name|L1_PAD_BOUNDARY
expr_stmt|;
name|zero_pad
argument_list|(
name|hc
operator|->
name|data
argument_list|,
name|L1_PAD_BOUNDARY
argument_list|)
expr_stmt|;
name|nh_transform
argument_list|(
name|hc
argument_list|,
name|hc
operator|->
name|data
argument_list|,
name|nh_len
argument_list|)
expr_stmt|;
block|}
name|nbits
operator|=
operator|(
name|hc
operator|->
name|bytes_hashed
operator|<<
literal|3
operator|)
expr_stmt|;
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|result
operator|)
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hc
operator|->
name|state
operator|)
index|[
literal|0
index|]
operator|+
name|nbits
expr_stmt|;
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|>=
literal|8
operator|)
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|result
operator|)
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hc
operator|->
name|state
operator|)
index|[
literal|1
index|]
operator|+
name|nbits
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|>=
literal|12
operator|)
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|result
operator|)
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hc
operator|->
name|state
operator|)
index|[
literal|2
index|]
operator|+
name|nbits
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|16
operator|)
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|result
operator|)
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|hc
operator|->
name|state
operator|)
index|[
literal|3
index|]
operator|+
name|nbits
expr_stmt|;
endif|#
directive|endif
name|nh_reset
argument_list|(
name|hc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|nh
parameter_list|(
name|nh_ctx
modifier|*
name|hc
parameter_list|,
name|UINT8
modifier|*
name|buf
parameter_list|,
name|UINT32
name|padded_len
parameter_list|,
name|UINT32
name|unpadded_len
parameter_list|,
name|UINT8
modifier|*
name|result
parameter_list|)
comment|/* All-in-one nh_update() and nh_final() equivalent.  * Assumes that padded_len is divisible by L1_PAD_BOUNDARY and result is  * well aligned  */
block|{
name|UINT32
name|nbits
decl_stmt|;
comment|/* Initialize the hash state */
name|nbits
operator|=
operator|(
name|unpadded_len
operator|<<
literal|3
operator|)
expr_stmt|;
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|result
operator|)
index|[
literal|0
index|]
operator|=
name|nbits
expr_stmt|;
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|>=
literal|8
operator|)
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|result
operator|)
index|[
literal|1
index|]
operator|=
name|nbits
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|>=
literal|12
operator|)
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|result
operator|)
index|[
literal|2
index|]
operator|=
name|nbits
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|16
operator|)
operator|(
operator|(
name|UINT64
operator|*
operator|)
name|result
operator|)
index|[
literal|3
index|]
operator|=
name|nbits
expr_stmt|;
endif|#
directive|endif
name|nh_aux
argument_list|(
name|hc
operator|->
name|nh_key
argument_list|,
name|buf
argument_list|,
name|result
argument_list|,
name|padded_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ----- Begin UHASH Section -------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* UHASH is a multi-layered algorithm. Data presented to UHASH is first  * hashed by NH. The NH output is then hashed by a polynomial-hash layer  * unless the initial data to be hashed is short. After the polynomial-  * layer, an inner-product hash is used to produce the final UHASH output.  *  * UHASH provides two interfaces, one all-at-once and another where data  * buffers are presented sequentially. In the sequential interface, the  * UHASH client calls the routine uhash_update() as many times as necessary.  * When there is no more data to be fed to UHASH, the client calls  * uhash_final() which            * calculates the UHASH output. Before beginning another UHASH calculation      * the uhash_reset() routine must be called. The all-at-once UHASH routine,     * uhash(), is equivalent to the sequence of calls uhash_update() and           * uhash_final(); however it is optimized and should be                       * used whenever the sequential interface is not necessary.                *                                                                          * The routine uhash_init() initializes the uhash_ctx data structure and      * must be called once, before any other UHASH routine.  */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ----- Constants and uhash_ctx ---------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ----- Poly hash and Inner-Product hash Constants --------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Primes and masks */
end_comment

begin_define
define|#
directive|define
name|p36
value|((UINT64)0x0000000FFFFFFFFBull)
end_define

begin_comment
comment|/* 2^36 -  5 */
end_comment

begin_define
define|#
directive|define
name|p64
value|((UINT64)0xFFFFFFFFFFFFFFC5ull)
end_define

begin_comment
comment|/* 2^64 - 59 */
end_comment

begin_define
define|#
directive|define
name|m36
value|((UINT64)0x0000000FFFFFFFFFull)
end_define

begin_comment
comment|/* The low 36 of 64 bits */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|uhash_ctx
block|{
name|nh_ctx
name|hash
decl_stmt|;
comment|/* Hash context for L1 NH hash  */
name|UINT64
name|poly_key_8
index|[
name|STREAMS
index|]
decl_stmt|;
comment|/* p64 poly keys                */
name|UINT64
name|poly_accum
index|[
name|STREAMS
index|]
decl_stmt|;
comment|/* poly hash result             */
name|UINT64
name|ip_keys
index|[
name|STREAMS
operator|*
literal|4
index|]
decl_stmt|;
comment|/* Inner-product keys           */
name|UINT32
name|ip_trans
index|[
name|STREAMS
index|]
decl_stmt|;
comment|/* Inner-product translation    */
name|UINT32
name|msg_len
decl_stmt|;
comment|/* Total length of data passed  */
comment|/* to uhash */
block|}
name|uhash_ctx
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|uhash_ctx
modifier|*
name|uhash_ctx_t
typedef|;
end_typedef

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* The polynomial hashes use Horner's rule to evaluate a polynomial one  * word at a time. As described in the specification, poly32 and poly64  * require keys from special domains. The following implementations exploit  * the special domains to avoid overflow. The results are not guaranteed to  * be within Z_p32 and Z_p64, but the Inner-Product hash implementation  * patches any errant values.  */
end_comment

begin_function
specifier|static
name|UINT64
name|poly64
parameter_list|(
name|UINT64
name|cur
parameter_list|,
name|UINT64
name|key
parameter_list|,
name|UINT64
name|data
parameter_list|)
block|{
name|UINT32
name|key_hi
init|=
call|(
name|UINT32
call|)
argument_list|(
name|key
operator|>>
literal|32
argument_list|)
decl_stmt|,
name|key_lo
init|=
operator|(
name|UINT32
operator|)
name|key
decl_stmt|,
name|cur_hi
init|=
call|(
name|UINT32
call|)
argument_list|(
name|cur
operator|>>
literal|32
argument_list|)
decl_stmt|,
name|cur_lo
init|=
operator|(
name|UINT32
operator|)
name|cur
decl_stmt|,
name|x_lo
decl_stmt|,
name|x_hi
decl_stmt|;
name|UINT64
name|X
decl_stmt|,
name|T
decl_stmt|,
name|res
decl_stmt|;
name|X
operator|=
name|MUL64
argument_list|(
name|key_hi
argument_list|,
name|cur_lo
argument_list|)
operator|+
name|MUL64
argument_list|(
name|cur_hi
argument_list|,
name|key_lo
argument_list|)
expr_stmt|;
name|x_lo
operator|=
operator|(
name|UINT32
operator|)
name|X
expr_stmt|;
name|x_hi
operator|=
call|(
name|UINT32
call|)
argument_list|(
name|X
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
name|MUL64
argument_list|(
name|key_hi
argument_list|,
name|cur_hi
argument_list|)
operator|+
name|x_hi
operator|)
operator|*
literal|59
operator|+
name|MUL64
argument_list|(
name|key_lo
argument_list|,
name|cur_lo
argument_list|)
expr_stmt|;
name|T
operator|=
operator|(
operator|(
name|UINT64
operator|)
name|x_lo
operator|<<
literal|32
operator|)
expr_stmt|;
name|res
operator|+=
name|T
expr_stmt|;
if|if
condition|(
name|res
operator|<
name|T
condition|)
name|res
operator|+=
literal|59
expr_stmt|;
name|res
operator|+=
name|data
expr_stmt|;
if|if
condition|(
name|res
operator|<
name|data
condition|)
name|res
operator|+=
literal|59
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Although UMAC is specified to use a ramped polynomial hash scheme, this  * implementation does not handle all ramp levels. Because we don't handle  * the ramp up to p128 modulus in this implementation, we are limited to  * 2^14 poly_hash() invocations per stream (for a total capacity of 2^24  * bytes input to UMAC per tag, ie. 16MB).  */
end_comment

begin_function
specifier|static
name|void
name|poly_hash
parameter_list|(
name|uhash_ctx_t
name|hc
parameter_list|,
name|UINT32
name|data_in
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|UINT64
modifier|*
name|data
init|=
operator|(
name|UINT64
operator|*
operator|)
name|data_in
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STREAMS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
call|(
name|UINT32
call|)
argument_list|(
name|data
index|[
name|i
index|]
operator|>>
literal|32
argument_list|)
operator|==
literal|0xfffffffful
condition|)
block|{
name|hc
operator|->
name|poly_accum
index|[
name|i
index|]
operator|=
name|poly64
argument_list|(
name|hc
operator|->
name|poly_accum
index|[
name|i
index|]
argument_list|,
name|hc
operator|->
name|poly_key_8
index|[
name|i
index|]
argument_list|,
name|p64
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hc
operator|->
name|poly_accum
index|[
name|i
index|]
operator|=
name|poly64
argument_list|(
name|hc
operator|->
name|poly_accum
index|[
name|i
index|]
argument_list|,
name|hc
operator|->
name|poly_key_8
index|[
name|i
index|]
argument_list|,
operator|(
name|data
index|[
name|i
index|]
operator|-
literal|59
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hc
operator|->
name|poly_accum
index|[
name|i
index|]
operator|=
name|poly64
argument_list|(
name|hc
operator|->
name|poly_accum
index|[
name|i
index|]
argument_list|,
name|hc
operator|->
name|poly_key_8
index|[
name|i
index|]
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* The final step in UHASH is an inner-product hash. The poly hash  * produces a result not neccesarily WORD_LEN bytes long. The inner-  * product hash breaks the polyhash output into 16-bit chunks and  * multiplies each with a 36 bit key.  */
end_comment

begin_function
specifier|static
name|UINT64
name|ip_aux
parameter_list|(
name|UINT64
name|t
parameter_list|,
name|UINT64
modifier|*
name|ipkp
parameter_list|,
name|UINT64
name|data
parameter_list|)
block|{
name|t
operator|=
name|t
operator|+
name|ipkp
index|[
literal|0
index|]
operator|*
call|(
name|UINT64
call|)
argument_list|(
name|UINT16
argument_list|)
argument_list|(
name|data
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|+
name|ipkp
index|[
literal|1
index|]
operator|*
call|(
name|UINT64
call|)
argument_list|(
name|UINT16
argument_list|)
argument_list|(
name|data
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|+
name|ipkp
index|[
literal|2
index|]
operator|*
call|(
name|UINT64
call|)
argument_list|(
name|UINT16
argument_list|)
argument_list|(
name|data
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|+
name|ipkp
index|[
literal|3
index|]
operator|*
call|(
name|UINT64
call|)
argument_list|(
name|UINT16
argument_list|)
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|UINT32
name|ip_reduce_p36
parameter_list|(
name|UINT64
name|t
parameter_list|)
block|{
comment|/* Divisionless modular reduction */
name|UINT64
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
name|t
operator|&
name|m36
operator|)
operator|+
literal|5
operator|*
operator|(
name|t
operator|>>
literal|36
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
name|p36
condition|)
name|ret
operator|-=
name|p36
expr_stmt|;
comment|/* return least significant 32 bits */
return|return
call|(
name|UINT32
call|)
argument_list|(
name|ret
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If the data being hashed by UHASH is no longer than L1_KEY_LEN, then  * the polyhash stage is skipped and ip_short is applied directly to the  * NH output.  */
end_comment

begin_function
specifier|static
name|void
name|ip_short
parameter_list|(
name|uhash_ctx_t
name|ahc
parameter_list|,
name|UINT8
modifier|*
name|nh_res
parameter_list|,
name|u_char
modifier|*
name|res
parameter_list|)
block|{
name|UINT64
name|t
decl_stmt|;
name|UINT64
modifier|*
name|nhp
init|=
operator|(
name|UINT64
operator|*
operator|)
name|nh_res
decl_stmt|;
name|t
operator|=
name|ip_aux
argument_list|(
literal|0
argument_list|,
name|ahc
operator|->
name|ip_keys
argument_list|,
name|nhp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|STORE_UINT32_BIG
argument_list|(
operator|(
name|UINT32
operator|*
operator|)
name|res
operator|+
literal|0
argument_list|,
name|ip_reduce_p36
argument_list|(
name|t
argument_list|)
operator|^
name|ahc
operator|->
name|ip_trans
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|>=
literal|8
operator|)
name|t
operator|=
name|ip_aux
argument_list|(
literal|0
argument_list|,
name|ahc
operator|->
name|ip_keys
operator|+
literal|4
argument_list|,
name|nhp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|STORE_UINT32_BIG
argument_list|(
operator|(
name|UINT32
operator|*
operator|)
name|res
operator|+
literal|1
argument_list|,
name|ip_reduce_p36
argument_list|(
name|t
argument_list|)
operator|^
name|ahc
operator|->
name|ip_trans
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|>=
literal|12
operator|)
name|t
operator|=
name|ip_aux
argument_list|(
literal|0
argument_list|,
name|ahc
operator|->
name|ip_keys
operator|+
literal|8
argument_list|,
name|nhp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|STORE_UINT32_BIG
argument_list|(
operator|(
name|UINT32
operator|*
operator|)
name|res
operator|+
literal|2
argument_list|,
name|ip_reduce_p36
argument_list|(
name|t
argument_list|)
operator|^
name|ahc
operator|->
name|ip_trans
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|16
operator|)
name|t
operator|=
name|ip_aux
argument_list|(
literal|0
argument_list|,
name|ahc
operator|->
name|ip_keys
operator|+
literal|12
argument_list|,
name|nhp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|STORE_UINT32_BIG
argument_list|(
operator|(
name|UINT32
operator|*
operator|)
name|res
operator|+
literal|3
argument_list|,
name|ip_reduce_p36
argument_list|(
name|t
argument_list|)
operator|^
name|ahc
operator|->
name|ip_trans
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* If the data being hashed by UHASH is longer than L1_KEY_LEN, then  * the polyhash stage is not skipped and ip_long is applied to the  * polyhash output.  */
end_comment

begin_function
specifier|static
name|void
name|ip_long
parameter_list|(
name|uhash_ctx_t
name|ahc
parameter_list|,
name|u_char
modifier|*
name|res
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|UINT64
name|t
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STREAMS
condition|;
name|i
operator|++
control|)
block|{
comment|/* fix polyhash output not in Z_p64 */
if|if
condition|(
name|ahc
operator|->
name|poly_accum
index|[
name|i
index|]
operator|>=
name|p64
condition|)
name|ahc
operator|->
name|poly_accum
index|[
name|i
index|]
operator|-=
name|p64
expr_stmt|;
name|t
operator|=
name|ip_aux
argument_list|(
literal|0
argument_list|,
name|ahc
operator|->
name|ip_keys
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
name|ahc
operator|->
name|poly_accum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|STORE_UINT32_BIG
argument_list|(
operator|(
name|UINT32
operator|*
operator|)
name|res
operator|+
name|i
argument_list|,
name|ip_reduce_p36
argument_list|(
name|t
argument_list|)
operator|^
name|ahc
operator|->
name|ip_trans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Reset uhash context for next hash session */
end_comment

begin_function
specifier|static
name|int
name|uhash_reset
parameter_list|(
name|uhash_ctx_t
name|pc
parameter_list|)
block|{
name|nh_reset
argument_list|(
operator|&
name|pc
operator|->
name|hash
argument_list|)
expr_stmt|;
name|pc
operator|->
name|msg_len
operator|=
literal|0
expr_stmt|;
name|pc
operator|->
name|poly_accum
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|>=
literal|8
operator|)
name|pc
operator|->
name|poly_accum
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|>=
literal|12
operator|)
name|pc
operator|->
name|poly_accum
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|UMAC_OUTPUT_LEN
operator|==
literal|16
operator|)
name|pc
operator|->
name|poly_accum
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Given a pointer to the internal key needed by kdf() and a uhash context,  * initialize the NH context and generate keys needed for poly and inner-  * product hashing. All keys are endian adjusted in memory so that native  * loads cause correct keys to be in registers during calculation.  */
end_comment

begin_function
specifier|static
name|void
name|uhash_init
parameter_list|(
name|uhash_ctx_t
name|ahc
parameter_list|,
name|aes_int_key
name|prf_key
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|UINT8
name|buf
index|[
operator|(
literal|8
operator|*
name|STREAMS
operator|+
literal|4
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|UINT64
argument_list|)
index|]
decl_stmt|;
comment|/* Zero the entire uhash context */
name|memset
argument_list|(
name|ahc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uhash_ctx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the L1 hash */
name|nh_init
argument_list|(
operator|&
name|ahc
operator|->
name|hash
argument_list|,
name|prf_key
argument_list|)
expr_stmt|;
comment|/* Setup L2 hash variables */
name|kdf
argument_list|(
name|buf
argument_list|,
name|prf_key
argument_list|,
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill buffer with index 1 key */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STREAMS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Fill keys from the buffer, skipping bytes in the buffer not          * used by this implementation. Endian reverse the keys if on a          * little-endian computer.          */
name|memcpy
argument_list|(
name|ahc
operator|->
name|poly_key_8
operator|+
name|i
argument_list|,
name|buf
operator|+
literal|24
operator|*
name|i
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|endian_convert_if_le
argument_list|(
name|ahc
operator|->
name|poly_key_8
operator|+
name|i
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Mask the 64-bit keys to their special domain */
name|ahc
operator|->
name|poly_key_8
index|[
name|i
index|]
operator|&=
operator|(
operator|(
name|UINT64
operator|)
literal|0x01ffffffu
operator|<<
literal|32
operator|)
operator|+
literal|0x01ffffffu
expr_stmt|;
name|ahc
operator|->
name|poly_accum
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Our polyhash prepends a non-zero word */
block|}
comment|/* Setup L3-1 hash variables */
name|kdf
argument_list|(
name|buf
argument_list|,
name|prf_key
argument_list|,
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill buffer with index 2 key */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STREAMS
condition|;
name|i
operator|++
control|)
name|memcpy
argument_list|(
name|ahc
operator|->
name|ip_keys
operator|+
literal|4
operator|*
name|i
argument_list|,
name|buf
operator|+
operator|(
literal|8
operator|*
name|i
operator|+
literal|4
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|UINT64
argument_list|)
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|UINT64
argument_list|)
argument_list|)
expr_stmt|;
name|endian_convert_if_le
argument_list|(
name|ahc
operator|->
name|ip_keys
argument_list|,
sizeof|sizeof
argument_list|(
name|UINT64
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ahc
operator|->
name|ip_keys
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STREAMS
operator|*
literal|4
condition|;
name|i
operator|++
control|)
name|ahc
operator|->
name|ip_keys
index|[
name|i
index|]
operator|%=
name|p36
expr_stmt|;
comment|/* Bring into Z_p36 */
comment|/* Setup L3-2 hash variables    */
comment|/* Fill buffer with index 4 key */
name|kdf
argument_list|(
name|ahc
operator|->
name|ip_trans
argument_list|,
name|prf_key
argument_list|,
literal|4
argument_list|,
name|STREAMS
operator|*
sizeof|sizeof
argument_list|(
name|UINT32
argument_list|)
argument_list|)
expr_stmt|;
name|endian_convert_if_le
argument_list|(
name|ahc
operator|->
name|ip_trans
argument_list|,
sizeof|sizeof
argument_list|(
name|UINT32
argument_list|)
argument_list|,
name|STREAMS
operator|*
sizeof|sizeof
argument_list|(
name|UINT32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static uhash_ctx_t uhash_alloc(u_char key[]) {
comment|/* Allocate memory and force to a 16-byte boundary. */
end_comment

begin_endif
unit|uhash_ctx_t ctx;     u_char bytes_to_add;     aes_int_key prf_key;          ctx = (uhash_ctx_t)malloc(sizeof(uhash_ctx)+ALLOC_BOUNDARY);     if (ctx) {         if (ALLOC_BOUNDARY) {             bytes_to_add = ALLOC_BOUNDARY -                               ((ptrdiff_t)ctx& (ALLOC_BOUNDARY -1));             ctx = (uhash_ctx_t)((u_char *)ctx + bytes_to_add);             *((u_char *)ctx - 1) = bytes_to_add;         }         aes_key_setup(key,prf_key);         uhash_init(ctx, prf_key);     }     return (ctx); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int uhash_free(uhash_ctx_t ctx) {
comment|/* Free memory allocated by uhash_alloc */
end_comment

begin_endif
unit|u_char bytes_to_sub;          if (ctx) {         if (ALLOC_BOUNDARY) {             bytes_to_sub = *((u_char *)ctx - 1);             ctx = (uhash_ctx_t)((u_char *)ctx - bytes_to_sub);         }         free(ctx);     }     return (1); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int
name|uhash_update
parameter_list|(
name|uhash_ctx_t
name|ctx
parameter_list|,
name|u_char
modifier|*
name|input
parameter_list|,
name|long
name|len
parameter_list|)
comment|/* Given len bytes of data, we parse it into L1_KEY_LEN chunks and  * hash each one with NH, calling the polyhash on each NH output.  */
block|{
name|UWORD
name|bytes_hashed
decl_stmt|,
name|bytes_remaining
decl_stmt|;
name|UINT8
name|nh_result
index|[
name|STREAMS
operator|*
sizeof|sizeof
argument_list|(
name|UINT64
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|msg_len
operator|+
name|len
operator|<=
name|L1_KEY_LEN
condition|)
block|{
name|nh_update
argument_list|(
operator|&
name|ctx
operator|->
name|hash
argument_list|,
operator|(
name|UINT8
operator|*
operator|)
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|msg_len
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|bytes_hashed
operator|=
name|ctx
operator|->
name|msg_len
operator|%
name|L1_KEY_LEN
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|msg_len
operator|==
name|L1_KEY_LEN
condition|)
name|bytes_hashed
operator|=
name|L1_KEY_LEN
expr_stmt|;
if|if
condition|(
name|bytes_hashed
operator|+
name|len
operator|>=
name|L1_KEY_LEN
condition|)
block|{
comment|/* If some bytes have been passed to the hash function      */
comment|/* then we want to pass at most (L1_KEY_LEN - bytes_hashed) */
comment|/* bytes to complete the current nh_block.                  */
if|if
condition|(
name|bytes_hashed
condition|)
block|{
name|bytes_remaining
operator|=
operator|(
name|L1_KEY_LEN
operator|-
name|bytes_hashed
operator|)
expr_stmt|;
name|nh_update
argument_list|(
operator|&
name|ctx
operator|->
name|hash
argument_list|,
operator|(
name|UINT8
operator|*
operator|)
name|input
argument_list|,
name|bytes_remaining
argument_list|)
expr_stmt|;
name|nh_final
argument_list|(
operator|&
name|ctx
operator|->
name|hash
argument_list|,
name|nh_result
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|msg_len
operator|+=
name|bytes_remaining
expr_stmt|;
name|poly_hash
argument_list|(
name|ctx
argument_list|,
operator|(
name|UINT32
operator|*
operator|)
name|nh_result
argument_list|)
expr_stmt|;
name|len
operator|-=
name|bytes_remaining
expr_stmt|;
name|input
operator|+=
name|bytes_remaining
expr_stmt|;
block|}
comment|/* Hash directly from input stream if enough bytes */
while|while
condition|(
name|len
operator|>=
name|L1_KEY_LEN
condition|)
block|{
name|nh
argument_list|(
operator|&
name|ctx
operator|->
name|hash
argument_list|,
operator|(
name|UINT8
operator|*
operator|)
name|input
argument_list|,
name|L1_KEY_LEN
argument_list|,
name|L1_KEY_LEN
argument_list|,
name|nh_result
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|msg_len
operator|+=
name|L1_KEY_LEN
expr_stmt|;
name|len
operator|-=
name|L1_KEY_LEN
expr_stmt|;
name|input
operator|+=
name|L1_KEY_LEN
expr_stmt|;
name|poly_hash
argument_list|(
name|ctx
argument_list|,
operator|(
name|UINT32
operator|*
operator|)
name|nh_result
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* pass remaining< L1_KEY_LEN bytes of input data to NH */
if|if
condition|(
name|len
condition|)
block|{
name|nh_update
argument_list|(
operator|&
name|ctx
operator|->
name|hash
argument_list|,
operator|(
name|UINT8
operator|*
operator|)
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|msg_len
operator|+=
name|len
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int
name|uhash_final
parameter_list|(
name|uhash_ctx_t
name|ctx
parameter_list|,
name|u_char
modifier|*
name|res
parameter_list|)
comment|/* Incorporate any pending data, pad, and generate tag */
block|{
name|UINT8
name|nh_result
index|[
name|STREAMS
operator|*
sizeof|sizeof
argument_list|(
name|UINT64
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|msg_len
operator|>
name|L1_KEY_LEN
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|msg_len
operator|%
name|L1_KEY_LEN
condition|)
block|{
name|nh_final
argument_list|(
operator|&
name|ctx
operator|->
name|hash
argument_list|,
name|nh_result
argument_list|)
expr_stmt|;
name|poly_hash
argument_list|(
name|ctx
argument_list|,
operator|(
name|UINT32
operator|*
operator|)
name|nh_result
argument_list|)
expr_stmt|;
block|}
name|ip_long
argument_list|(
name|ctx
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nh_final
argument_list|(
operator|&
name|ctx
operator|->
name|hash
argument_list|,
name|nh_result
argument_list|)
expr_stmt|;
name|ip_short
argument_list|(
name|ctx
argument_list|,
name|nh_result
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
name|uhash_reset
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int uhash(uhash_ctx_t ahc, u_char *msg, long len, u_char *res)
comment|/* assumes that msg is in a writable buffer of length divisible by */
end_comment

begin_comment
comment|/* L1_PAD_BOUNDARY. Bytes beyond msg[len] may be zeroed.           */
end_comment

begin_comment
unit|{     UINT8 nh_result[STREAMS*sizeof(UINT64)];     UINT32 nh_len;     int extra_zeroes_needed;
comment|/* If the message to be hashed is no longer than L1_HASH_LEN, we skip      * the polyhash.      */
end_comment

begin_comment
unit|if (len<= L1_KEY_LEN) {     	if (len == 0)
comment|/* If zero length messages will not */
end_comment

begin_comment
unit|nh_len = L1_PAD_BOUNDARY;
comment|/* be seen, comment out this case   */
end_comment

begin_comment
unit|else         	nh_len = ((len + (L1_PAD_BOUNDARY - 1))& ~(L1_PAD_BOUNDARY - 1));         extra_zeroes_needed = nh_len - len;         zero_pad((UINT8 *)msg + len, extra_zeroes_needed);         nh(&ahc->hash, (UINT8 *)msg, nh_len, len, nh_result);         ip_short(ahc,nh_result, res);     } else {
comment|/* Otherwise, we hash each L1_KEY_LEN chunk with NH, passing the NH          * output to poly_hash().          */
end_comment

begin_endif
unit|do {             nh(&ahc->hash, (UINT8 *)msg, L1_KEY_LEN, L1_KEY_LEN, nh_result);             poly_hash(ahc,(UINT32 *)nh_result);             len -= L1_KEY_LEN;             msg += L1_KEY_LEN;         } while (len>= L1_KEY_LEN);         if (len) {             nh_len = ((len + (L1_PAD_BOUNDARY - 1))& ~(L1_PAD_BOUNDARY - 1));             extra_zeroes_needed = nh_len - len;             zero_pad((UINT8 *)msg + len, extra_zeroes_needed);             nh(&ahc->hash, (UINT8 *)msg, nh_len, len, nh_result);             poly_hash(ahc,(UINT32 *)nh_result);         }          ip_long(ahc, res);     }          uhash_reset(ahc);     return 1; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ----- Begin UMAC Section --------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* The UMAC interface has two interfaces, an all-at-once interface where  * the entire message to be authenticated is passed to UMAC in one buffer,  * and a sequential interface where the message is presented a little at a     * time. The all-at-once is more optimaized than the sequential version and  * should be preferred when the sequential interface is not required.   */
end_comment

begin_struct
struct|struct
name|umac_ctx
block|{
name|uhash_ctx
name|hash
decl_stmt|;
comment|/* Hash function for message compression    */
name|pdf_ctx
name|pdf
decl_stmt|;
comment|/* PDF for hashed output                    */
name|void
modifier|*
name|free_ptr
decl_stmt|;
comment|/* Address to free this struct via          */
block|}
name|umac_ctx
struct|;
end_struct

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|int umac_reset(struct umac_ctx *ctx)
comment|/* Reset the hash function to begin a new authentication.        */
end_comment

begin_endif
unit|{     uhash_reset(&ctx->hash);     return (1); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|umac_delete
parameter_list|(
name|struct
name|umac_ctx
modifier|*
name|ctx
parameter_list|)
comment|/* Deallocate the ctx structure */
block|{
if|if
condition|(
name|ctx
condition|)
block|{
if|if
condition|(
name|ALLOC_BOUNDARY
condition|)
name|ctx
operator|=
operator|(
expr|struct
name|umac_ctx
operator|*
operator|)
name|ctx
operator|->
name|free_ptr
expr_stmt|;
name|xfree
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
name|struct
name|umac_ctx
modifier|*
name|umac_new
parameter_list|(
name|u_char
name|key
index|[]
parameter_list|)
comment|/* Dynamically allocate a umac_ctx struct, initialize variables,   * generate subkeys from key. Align to 16-byte boundary.  */
block|{
name|struct
name|umac_ctx
modifier|*
name|ctx
decl_stmt|,
modifier|*
name|octx
decl_stmt|;
name|size_t
name|bytes_to_add
decl_stmt|;
name|aes_int_key
name|prf_key
decl_stmt|;
name|octx
operator|=
name|ctx
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
operator|+
name|ALLOC_BOUNDARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
if|if
condition|(
name|ALLOC_BOUNDARY
condition|)
block|{
name|bytes_to_add
operator|=
name|ALLOC_BOUNDARY
operator|-
operator|(
operator|(
name|ptrdiff_t
operator|)
name|ctx
operator|&
operator|(
name|ALLOC_BOUNDARY
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|ctx
operator|=
operator|(
expr|struct
name|umac_ctx
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ctx
operator|+
name|bytes_to_add
operator|)
expr_stmt|;
block|}
name|ctx
operator|->
name|free_ptr
operator|=
name|octx
expr_stmt|;
name|aes_key_setup
argument_list|(
name|key
argument_list|,
name|prf_key
argument_list|)
expr_stmt|;
name|pdf_init
argument_list|(
operator|&
name|ctx
operator|->
name|pdf
argument_list|,
name|prf_key
argument_list|)
expr_stmt|;
name|uhash_init
argument_list|(
operator|&
name|ctx
operator|->
name|hash
argument_list|,
name|prf_key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ctx
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|umac_final
parameter_list|(
name|struct
name|umac_ctx
modifier|*
name|ctx
parameter_list|,
name|u_char
name|tag
index|[]
parameter_list|,
name|u_char
name|nonce
index|[
literal|8
index|]
parameter_list|)
comment|/* Incorporate any pending data, pad, and generate tag */
block|{
name|uhash_final
argument_list|(
operator|&
name|ctx
operator|->
name|hash
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|tag
argument_list|)
expr_stmt|;
name|pdf_gen_xor
argument_list|(
operator|&
name|ctx
operator|->
name|pdf
argument_list|,
operator|(
name|UINT8
operator|*
operator|)
name|nonce
argument_list|,
operator|(
name|UINT8
operator|*
operator|)
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|umac_update
parameter_list|(
name|struct
name|umac_ctx
modifier|*
name|ctx
parameter_list|,
name|u_char
modifier|*
name|input
parameter_list|,
name|long
name|len
parameter_list|)
comment|/* Given len bytes of data, we parse it into L1_KEY_LEN chunks and   */
comment|/* hash each one, calling the PDF on the hashed output whenever the hash- */
comment|/* output buffer is full.                                                 */
block|{
name|uhash_update
argument_list|(
operator|&
name|ctx
operator|->
name|hash
argument_list|,
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|int umac(struct umac_ctx *ctx, u_char *input,           long len, u_char tag[],          u_char nonce[8])
comment|/* All-in-one version simply calls umac_update() and umac_final().        */
end_comment

begin_endif
unit|{     uhash(&ctx->hash, input, len, (u_char *)tag);     pdf_gen_xor(&ctx->pdf, (UINT8 *)nonce, (UINT8 *)tag);          return (1); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ----- End UMAC Section ----------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

end_unit

