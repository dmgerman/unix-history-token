begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	alloc.c	4.8	81/03/08	*/
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/mount.h"
end_include

begin_include
include|#
directive|include
file|"../h/filsys.h"
end_include

begin_include
include|#
directive|include
file|"../h/fblk.h"
end_include

begin_include
include|#
directive|include
file|"../h/conf.h"
end_include

begin_include
include|#
directive|include
file|"../h/buf.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/ino.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_typedef
typedef|typedef
name|struct
name|fblk
modifier|*
name|FBLKP
typedef|;
end_typedef

begin_comment
comment|/*  * alloc will obtain the next available  * free disk block from the free list of  * the specified device.  * The super block has up to NICFREE remembered  * free blocks; the last of these is read to  * obtain NICFREE more . . .  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|alloc
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
name|daddr_t
name|bno
decl_stmt|;
specifier|register
name|struct
name|filsys
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|fp
operator|=
name|getfs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
while|while
condition|(
name|fp
operator|->
name|s_flock
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fp
operator|->
name|s_flock
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|<=
literal|0
condition|)
goto|goto
name|nospace
goto|;
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|>
name|NICFREE
condition|)
block|{
name|fserr
argument_list|(
name|fp
argument_list|,
literal|"bad free count"
argument_list|)
expr_stmt|;
goto|goto
name|nospace
goto|;
block|}
name|bno
operator|=
name|fp
operator|->
name|s_free
index|[
operator|--
name|fp
operator|->
name|s_nfree
index|]
expr_stmt|;
if|if
condition|(
name|bno
operator|==
literal|0
condition|)
goto|goto
name|nospace
goto|;
block|}
do|while
condition|(
name|badblock
argument_list|(
name|fp
argument_list|,
name|bno
argument_list|)
condition|)
do|;
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|<=
literal|0
condition|)
block|{
name|fp
operator|->
name|s_flock
operator|++
expr_stmt|;
name|bp
operator|=
name|bread
argument_list|(
name|dev
argument_list|,
name|bno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|s_nfree
operator|=
operator|(
call|(
name|FBLKP
call|)
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
operator|)
operator|->
name|df_nfree
expr_stmt|;
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
call|(
name|FBLKP
call|)
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
argument_list|)
operator|->
name|df_free
argument_list|,
operator|(
name|caddr_t
operator|)
name|fp
operator|->
name|s_free
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|s_free
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_flock
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fp
operator|->
name|s_flock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|<=
literal|0
condition|)
goto|goto
name|nospace
goto|;
block|}
name|bp
operator|=
name|getblk
argument_list|(
name|dev
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|s_tfree
operator|--
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
name|nospace
label|:
name|fp
operator|->
name|s_nfree
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|s_tfree
operator|=
literal|0
expr_stmt|;
name|fserr
argument_list|(
name|fp
argument_list|,
literal|"file system full"
argument_list|)
expr_stmt|;
comment|/* THIS IS A KLUDGE... */
comment|/* SHOULD RATHER SEND A SIGNAL AND SUSPEND THE PROCESS IN A */
comment|/* STATE FROM WHICH THE SYSTEM CALL WILL RESTART */
name|uprintf
argument_list|(
literal|"\n%s: write failed, file system is full\n"
argument_list|,
name|fp
operator|->
name|s_fsmnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
comment|/* END KLUDGE */
name|u
operator|.
name|u_error
operator|=
name|ENOSPC
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * place the specified disk block  * back on the free list of the  * specified device.  */
end_comment

begin_macro
name|free
argument_list|(
argument|dev
argument_list|,
argument|bno
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|bno
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|filsys
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|fp
operator|=
name|getfs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|fp
operator|->
name|s_flock
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fp
operator|->
name|s_flock
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|badblock
argument_list|(
name|fp
argument_list|,
name|bno
argument_list|)
condition|)
return|return;
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|<=
literal|0
condition|)
block|{
name|fp
operator|->
name|s_nfree
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|s_free
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|>=
name|NICFREE
condition|)
block|{
name|fp
operator|->
name|s_flock
operator|++
expr_stmt|;
name|bp
operator|=
name|getblk
argument_list|(
name|dev
argument_list|,
name|bno
argument_list|)
expr_stmt|;
operator|(
call|(
name|FBLKP
call|)
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
operator|)
operator|->
name|df_nfree
operator|=
name|fp
operator|->
name|s_nfree
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|fp
operator|->
name|s_free
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
call|(
name|FBLKP
call|)
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
argument_list|)
operator|->
name|df_free
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|s_free
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_nfree
operator|=
literal|0
expr_stmt|;
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_flock
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fp
operator|->
name|s_flock
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|s_free
index|[
name|fp
operator|->
name|s_nfree
operator|++
index|]
operator|=
name|bno
expr_stmt|;
name|fp
operator|->
name|s_tfree
operator|++
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Check that a block number is in the  * range between the I list and the size  * of the device.  * This is used mainly to check that a  * garbage file system has not been mounted.  */
end_comment

begin_expr_stmt
name|badblock
argument_list|(
name|fp
argument_list|,
name|bn
argument_list|)
specifier|register
expr|struct
name|filsys
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|daddr_t
name|bn
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|bn
operator|<
name|fp
operator|->
name|s_isize
operator|||
name|bn
operator|>=
name|fp
operator|->
name|s_fsize
condition|)
block|{
name|fserr
argument_list|(
name|fp
argument_list|,
literal|"bad block"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Allocate an unused inode on the specified device.  * Used with file creation.  The algorithm keeps up to  * NICINOD spare inodes in the super block.  When this runs out,  * the inodes are searched to pick up more.  We keep searching  * foreward on the device, remembering the number of inodes  * which are freed behind our search point for which there is no  * room in the in-core table.  When this number passes a threshold  * (or if we search to the end of the ilist without finding any inodes)  * we restart the search from the beginning.  */
end_comment

begin_function
name|struct
name|inode
modifier|*
name|ialloc
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
specifier|register
name|struct
name|filsys
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|dinode
modifier|*
name|dp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|,
name|inobas
decl_stmt|;
name|int
name|first
decl_stmt|;
name|daddr_t
name|adr
decl_stmt|;
name|fp
operator|=
name|getfs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
while|while
condition|(
name|fp
operator|->
name|s_ilock
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fp
operator|->
name|s_ilock
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>
literal|0
condition|)
block|{
name|ino
operator|=
name|fp
operator|->
name|s_inode
index|[
operator|--
name|fp
operator|->
name|s_ninode
index|]
expr_stmt|;
name|ip
operator|=
name|iget
argument_list|(
name|dev
argument_list|,
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ip
operator|->
name|i_mode
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NADDR
condition|;
name|i
operator|++
control|)
name|ip
operator|->
name|i_un
operator|.
name|i_addr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|s_tinode
operator|--
expr_stmt|;
return|return
operator|(
name|ip
operator|)
return|;
block|}
comment|/* 		 * Inode was allocated after all. 		 * Look some more. 		 */
name|iput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|fp
operator|->
name|s_ilock
operator|++
expr_stmt|;
comment|/* 	 * If less than 4*NICINOD inodes are known 	 * to be free behind the current search point, 	 * then search forward; else search from beginning. 	 */
if|if
condition|(
name|fp
operator|->
name|s_nbehind
operator|<
literal|4
operator|*
name|NICINOD
condition|)
block|{
name|first
operator|=
literal|1
expr_stmt|;
name|ino
operator|=
name|fp
operator|->
name|s_lasti
expr_stmt|;
if|if
condition|(
name|itoo
argument_list|(
name|ino
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ialloc"
argument_list|)
expr_stmt|;
name|adr
operator|=
name|itod
argument_list|(
name|ino
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fromtop
label|:
name|first
operator|=
literal|0
expr_stmt|;
name|ino
operator|=
literal|1
expr_stmt|;
name|adr
operator|=
name|SUPERB
operator|+
literal|1
expr_stmt|;
name|fp
operator|->
name|s_nbehind
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * This is the search for free inodes. 	 */
for|for
control|(
init|;
name|adr
operator|<
name|fp
operator|->
name|s_isize
condition|;
name|adr
operator|++
control|)
block|{
name|inobas
operator|=
name|ino
expr_stmt|;
name|bp
operator|=
name|bread
argument_list|(
name|dev
argument_list|,
name|adr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
name|u
operator|.
name|u_vm
operator|.
name|vm_inblk
operator|--
expr_stmt|;
comment|/* no charge! */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ino
operator|+=
name|INOPB
expr_stmt|;
continue|continue;
block|}
name|dp
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_dino
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INOPB
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|di_mode
operator|!=
literal|0
operator|||
name|ifind
argument_list|(
name|dev
argument_list|,
name|ino
argument_list|)
condition|)
goto|goto
name|cont
goto|;
name|fp
operator|->
name|s_inode
index|[
name|fp
operator|->
name|s_ninode
operator|++
index|]
operator|=
name|ino
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>=
name|NICINOD
condition|)
break|break;
name|cont
label|:
name|ino
operator|++
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>=
name|NICINOD
condition|)
break|break;
block|}
comment|/* 	 * If the search didn't net a full superblock of inodes, 	 * then try it again from the beginning of the ilist. 	 */
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|<
name|NICINOD
operator|&&
name|first
condition|)
goto|goto
name|fromtop
goto|;
name|fp
operator|->
name|s_lasti
operator|=
name|inobas
expr_stmt|;
name|fp
operator|->
name|s_ilock
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fp
operator|->
name|s_ilock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
name|fserr
argument_list|(
name|fp
argument_list|,
literal|"out of inodes"
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"\n%s: create failed, no inodes free\n"
argument_list|,
name|fp
operator|->
name|s_fsmnt
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|ENOSPC
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the specified inode on the specified device.  * The algorithm stores up to NICINOD inodes in the super  * block and throws away any more.  It keeps track of the  * number of inodes thrown away which preceded the current  * search point in the file system.  This lets us rescan  * for more inodes from the beginning only when there  * are a reasonable number of inodes back there to reallocate.  */
end_comment

begin_macro
name|ifree
argument_list|(
argument|dev
argument_list|,
argument|ino
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|ino
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|filsys
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|getfs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_tinode
operator|++
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_ilock
condition|)
return|return;
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>=
name|NICINOD
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|s_lasti
operator|>
name|ino
condition|)
name|fp
operator|->
name|s_nbehind
operator|++
expr_stmt|;
return|return;
block|}
name|fp
operator|->
name|s_inode
index|[
name|fp
operator|->
name|s_ninode
operator|++
index|]
operator|=
name|ino
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * getfs maps a device number into  * a pointer to the incore super  * block.  The algorithm is a linear  * search through the mount table.  * A consistency check of the  * in core free-block and i-node  * counts is performed.  *  * panic: no fs -- the device is not mounted.  *	this "cannot happen"  */
end_comment

begin_function
name|struct
name|filsys
modifier|*
name|getfs
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
specifier|register
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|filsys
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|mount
index|[
literal|0
index|]
init|;
name|mp
operator|<
operator|&
name|mount
index|[
name|NMOUNT
index|]
condition|;
name|mp
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|m_bufp
operator|!=
name|NULL
operator|&&
name|mp
operator|->
name|m_dev
operator|==
name|dev
condition|)
block|{
name|fp
operator|=
name|mp
operator|->
name|m_bufp
operator|->
name|b_un
operator|.
name|b_filsys
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|>
name|NICFREE
operator|||
name|fp
operator|->
name|s_ninode
operator|>
name|NICINOD
condition|)
block|{
name|fserr
argument_list|(
name|fp
argument_list|,
literal|"bad count"
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_nfree
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|s_ninode
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|fp
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"no fs"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fserr prints the name of a file system  * with an error diagnostic, in the form  *	filsys: error message  */
end_comment

begin_macro
name|fserr
argument_list|(
argument|fp
argument_list|,
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|filsys
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|fp
operator|->
name|s_fsmnt
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Getfsx returns the index in the file system  * table of the specified device.  The swap device  * is also assigned a pseudo-index.  The index may  * be used as a compressed indication of the location  * of a block, recording  *<getfsx(dev),blkno>  * rather than  *<dev, blkno>  * provided the information need remain valid only  * as long as the file system is mounted.  */
end_comment

begin_macro
name|getfsx
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|swapdev
condition|)
return|return
operator|(
name|MSWAPX
operator|)
return|;
for|for
control|(
name|mp
operator|=
operator|&
name|mount
index|[
literal|0
index|]
init|;
name|mp
operator|<
operator|&
name|mount
index|[
name|NMOUNT
index|]
condition|;
name|mp
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|m_dev
operator|==
name|dev
condition|)
return|return
operator|(
name|mp
operator|-
operator|&
name|mount
index|[
literal|0
index|]
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Update is the internal name of 'sync'.  It goes through the disk  * queues to initiate sandbagged IO; goes through the inodes to write  * modified nodes; and it goes through the mount table to initiate modified  * super blocks.  */
end_comment

begin_macro
name|update
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|filsys
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|updlock
condition|)
return|return;
name|updlock
operator|++
expr_stmt|;
comment|/* 	 * Write back modified superblocks. 	 * Consistency check that the superblock 	 * of each file system is still in the buffer cache. 	 */
for|for
control|(
name|mp
operator|=
operator|&
name|mount
index|[
literal|0
index|]
init|;
name|mp
operator|<
operator|&
name|mount
index|[
name|NMOUNT
index|]
condition|;
name|mp
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|m_bufp
operator|!=
name|NULL
condition|)
block|{
name|fp
operator|=
name|mp
operator|->
name|m_bufp
operator|->
name|b_un
operator|.
name|b_filsys
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_fmod
operator|==
literal|0
operator|||
name|fp
operator|->
name|s_ilock
operator|!=
literal|0
operator|||
name|fp
operator|->
name|s_flock
operator|!=
literal|0
operator|||
name|fp
operator|->
name|s_ronly
operator|!=
literal|0
condition|)
continue|continue;
name|bp
operator|=
name|getblk
argument_list|(
name|mp
operator|->
name|m_dev
argument_list|,
name|SUPERB
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|s_time
operator|=
name|time
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_un
operator|.
name|b_filsys
operator|!=
name|fp
condition|)
name|panic
argument_list|(
literal|"update"
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Write back each (modified) inode. 	 */
for|for
control|(
name|ip
operator|=
name|inode
init|;
name|ip
operator|<
name|inodeNINODE
condition|;
name|ip
operator|++
control|)
if|if
condition|(
operator|(
name|ip
operator|->
name|i_flag
operator|&
name|ILOCK
operator|)
operator|==
literal|0
operator|&&
name|ip
operator|->
name|i_count
condition|)
block|{
name|ip
operator|->
name|i_flag
operator||=
name|ILOCK
expr_stmt|;
name|ip
operator|->
name|i_count
operator|++
expr_stmt|;
name|iupdat
argument_list|(
name|ip
argument_list|,
operator|&
name|time
argument_list|,
operator|&
name|time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
name|updlock
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Force stale buffer cache information to be flushed, 	 * for all devices. 	 */
name|bflush
argument_list|(
name|NODEV
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

