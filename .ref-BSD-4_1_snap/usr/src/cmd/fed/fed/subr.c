begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"fed.h"
end_include

begin_comment
comment|/*  * subr.c: general subroutines for fed.  */
end_comment

begin_comment
comment|/*  * initialize: various one time initializations.  */
end_comment

begin_macro
name|initialize
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Initialize random variables */
name|curwind
operator|=
operator|-
literal|1
expr_stmt|;
name|pencolor
operator|=
literal|1
expr_stmt|;
name|penweight
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize value of sqrtmat.  This is a constant table 	 * so we don't have to redo all these square roots when the pen 	 * changes every time. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|sqrtmat
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|sqrt
argument_list|(
operator|(
name|float
operator|)
name|i
operator|*
name|i
operator|+
name|j
operator|*
name|j
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize base locations on screen. These remain fixed. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NROW
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NCOL
condition|;
name|j
operator|++
control|)
block|{
name|base
index|[
name|NCOL
operator|*
name|i
operator|+
name|j
index|]
operator|.
name|c
operator|=
operator|(
name|GLCOL
operator|+
name|GLPAD
operator|)
operator|*
name|j
operator|+
literal|1
expr_stmt|;
name|base
index|[
name|NCOL
operator|*
name|i
operator|+
name|j
index|]
operator|.
name|r
operator|=
name|SCRHI
operator|-
operator|(
name|GLROW
operator|+
name|GLPAD
operator|+
literal|10
operator|)
operator|*
name|i
operator|-
name|GLROW
operator|-
literal|3
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|stoutbuf
argument_list|)
expr_stmt|;
name|curzoom
operator|=
literal|1
expr_stmt|;
comment|/* default is zoomed completely out */
name|ttyinit
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * showfont: Wipe clean the screen, display the font  * in a properly spaced fashion, wait for a char to be typed, if it's  * p print the font, then clear the screen and ungetc the char.  */
end_comment

begin_macro
name|showfont
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|cr
decl_stmt|,
name|cc
decl_stmt|,
name|nc
decl_stmt|;
name|int
name|roff
decl_stmt|,
name|coff
decl_stmt|;
name|char
name|maxc
decl_stmt|,
name|minc
decl_stmt|;
name|char
name|nextcmd
decl_stmt|;
name|char
name|tmpbuf
index|[
name|WINDSIZE
index|]
decl_stmt|;
name|zoomout
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"Show font from<char>"
argument_list|)
expr_stmt|;
name|minc
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"Show font from %s to<char>"
argument_list|,
name|rdchar
argument_list|(
name|minc
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|maxc
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|clearg
argument_list|()
expr_stmt|;
name|zermat
argument_list|(
name|tmpbuf
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
name|cr
operator|=
name|SCRHI
operator|-
name|GLROW
expr_stmt|;
name|cc
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
name|minc
init|;
name|i
operator|<=
name|maxc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|disptable
index|[
name|i
index|]
operator|.
name|nbytes
condition|)
block|{
comment|/* 			 * We really should try to find out how far to the 			 * left the glyph goes so we don't run off the left 			 * end of the screen, but this is hard, so we fake it. 			 * Usually glyphs don't run past the left so it's OK. 			 */
if|if
condition|(
name|cc
operator|-
name|disptable
index|[
name|i
index|]
operator|.
name|left
operator|<
literal|0
condition|)
name|cc
operator|=
name|disptable
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
name|nc
operator|=
name|cc
operator|+
name|disptable
index|[
name|i
index|]
operator|.
name|width
expr_stmt|;
if|if
condition|(
name|nc
operator|>=
name|SCRWID
condition|)
block|{
name|cc
operator|=
literal|0
expr_stmt|;
name|nc
operator|=
name|disptable
index|[
name|i
index|]
operator|.
name|width
expr_stmt|;
name|cr
operator|-=
literal|85
expr_stmt|;
comment|/* Should be GLROW but 4*100>360 */
if|if
condition|(
name|cr
operator|<
literal|0
condition|)
break|break;
comment|/* Screen full.  Just stop. */
block|}
name|dispmsg
argument_list|(
name|rdchar
argument_list|(
name|i
argument_list|)
argument_list|,
name|cc
argument_list|,
name|cr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|placechar
argument_list|(
name|i
argument_list|,
name|cr
operator|+
name|BASELINE
argument_list|,
name|cc
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|cc
operator|=
name|nc
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|nextcmd
operator|=
name|inchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextcmd
operator|!=
literal|'p'
condition|)
break|break;
name|printg
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|nextcmd
operator|!=
literal|'Q'
operator|&&
name|nextcmd
operator|!=
literal|'E'
operator|&&
name|nextcmd
operator|!=
literal|'N'
condition|)
name|redraw
argument_list|()
expr_stmt|;
else|else
name|clearg
argument_list|()
expr_stmt|;
name|ungetc
argument_list|(
name|nextcmd
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * typein: Like showfont but takes a line of text from the user  * and "typesets" it on the screen.  */
end_comment

begin_macro
name|typein
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|cr
decl_stmt|,
name|cc
decl_stmt|,
name|nc
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|roff
decl_stmt|,
name|coff
decl_stmt|;
name|char
name|maxc
decl_stmt|,
name|minc
decl_stmt|;
name|char
name|nextcmd
decl_stmt|;
name|char
name|tmpbuf
index|[
name|WINDSIZE
index|]
decl_stmt|;
name|char
name|msgtype
index|[
literal|100
index|]
decl_stmt|;
name|zoomout
argument_list|()
expr_stmt|;
name|readline
argument_list|(
literal|"Input line to be typeset: "
argument_list|,
name|msgtype
argument_list|,
sizeof|sizeof
name|msgtype
argument_list|)
expr_stmt|;
name|clearg
argument_list|()
expr_stmt|;
name|zermat
argument_list|(
name|tmpbuf
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
name|cr
operator|=
name|SCRHI
operator|-
name|GLROW
expr_stmt|;
name|cc
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|p
operator|=
name|msgtype
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|i
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|disptable
index|[
name|i
index|]
operator|.
name|nbytes
condition|)
block|{
if|if
condition|(
name|cc
operator|-
name|disptable
index|[
name|i
index|]
operator|.
name|left
operator|<
literal|0
condition|)
name|cc
operator|=
name|disptable
index|[
name|i
index|]
operator|.
name|left
expr_stmt|;
name|nc
operator|=
name|cc
operator|+
name|disptable
index|[
name|i
index|]
operator|.
name|width
expr_stmt|;
if|if
condition|(
name|nc
operator|>=
name|SCRWID
condition|)
block|{
name|cc
operator|=
literal|0
expr_stmt|;
name|nc
operator|=
name|disptable
index|[
name|i
index|]
operator|.
name|width
expr_stmt|;
name|cr
operator|-=
literal|85
expr_stmt|;
comment|/* Should be GLROW but 4*100>360 */
if|if
condition|(
name|cr
operator|<
literal|0
condition|)
break|break;
comment|/* Screen full.  Just stop. */
block|}
name|dispmsg
argument_list|(
name|rdchar
argument_list|(
name|i
argument_list|)
argument_list|,
name|cc
argument_list|,
name|cr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|placechar
argument_list|(
name|i
argument_list|,
name|cr
operator|+
name|BASELINE
argument_list|,
name|cc
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|cc
operator|=
name|nc
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|nextcmd
operator|=
name|inchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextcmd
operator|!=
literal|'p'
condition|)
break|break;
name|printg
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|nextcmd
operator|!=
literal|'Q'
operator|&&
name|nextcmd
operator|!=
literal|'E'
operator|&&
name|nextcmd
operator|!=
literal|'N'
condition|)
name|redraw
argument_list|()
expr_stmt|;
else|else
name|clearg
argument_list|()
expr_stmt|;
name|ungetc
argument_list|(
name|nextcmd
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * placechar: draw the character ch at position (llr, llc) on the screen.  * Position means the logical center of the character.  zero is a GLROW x GLCOL  * matrix of zeros which is needed for comparison, that is, we assume that  * the spot on the screen where this is going is blank, so the chars better  * not overlap.  */
end_comment

begin_macro
name|placechar
argument_list|(
argument|ch
argument_list|,
argument|llr
argument_list|,
argument|llc
argument_list|,
argument|zero
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|llr
decl_stmt|,
name|llc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bitmat
name|zero
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bitmat
name|glbuf
decl_stmt|;
name|int
name|roff
decl_stmt|,
name|coff
decl_stmt|;
name|glbuf
operator|=
name|findbits
argument_list|(
name|ch
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|roff
argument_list|,
operator|&
name|coff
argument_list|)
expr_stmt|;
if|if
condition|(
name|glbuf
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"placechar('%s'), roff=%d, coff=%d, llr=%d, llc=%d, down=%d, left=%d, r=%d, c=%d\n"
argument_list|,
name|rdchar
argument_list|(
name|ch
argument_list|)
argument_list|,
name|roff
argument_list|,
name|coff
argument_list|,
name|llr
argument_list|,
name|llc
argument_list|,
name|disptable
index|[
name|ch
index|]
operator|.
name|down
argument_list|,
name|disptable
index|[
name|ch
index|]
operator|.
name|left
argument_list|,
name|llr
operator|-
name|disptable
index|[
name|ch
index|]
operator|.
name|down
argument_list|,
name|llc
operator|-
name|disptable
index|[
name|ch
index|]
operator|.
name|left
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|zero
argument_list|,
name|glbuf
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|llr
operator|-
name|GLROW
operator|+
name|roff
argument_list|,
name|llc
operator|-
name|coff
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"placechar, free %x\n"
argument_list|,
name|glbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|glbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * redraw: The screen has gotten screwed up somehow.  * Assume nothing but make it look right.  */
end_comment

begin_macro
name|redraw
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|zoomout
argument_list|()
expr_stmt|;
name|clearg
argument_list|()
expr_stmt|;
name|turnofrb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NWIND
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wind
index|[
name|i
index|]
operator|.
name|onscreen
operator|!=
name|NULL
condition|)
block|{
name|zermat
argument_list|(
name|wind
index|[
name|i
index|]
operator|.
name|onscreen
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
name|syncwind
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Print the char at the lower left of the window */
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"%s"
argument_list|,
name|rdchar
argument_list|(
name|wind
index|[
name|i
index|]
operator|.
name|used
argument_list|)
argument_list|)
expr_stmt|;
name|dispmsg
argument_list|(
name|msgbuf
argument_list|,
name|base
index|[
name|i
index|]
operator|.
name|c
argument_list|,
name|base
index|[
name|i
index|]
operator|.
name|r
operator|-
literal|11
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curwind
operator|>=
literal|0
condition|)
name|drawbox
argument_list|(
name|base
index|[
name|curwind
index|]
operator|.
name|r
operator|-
literal|1
argument_list|,
name|base
index|[
name|curwind
index|]
operator|.
name|c
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|GLROW
operator|+
literal|2
argument_list|,
name|GLCOL
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * findbits: find the data bits of glyph c, wherever they are, and make  * nr x nc bitmat and put them in it, shifted by horoff and vertoff.  */
end_comment

begin_function
name|bitmat
name|findbits
parameter_list|(
name|c
parameter_list|,
name|nr
parameter_list|,
name|nc
parameter_list|,
name|horoff
parameter_list|,
name|vertoff
parameter_list|,
name|rcenter
parameter_list|,
name|ccenter
parameter_list|)
name|int
name|c
decl_stmt|;
name|int
name|nr
decl_stmt|,
name|nc
decl_stmt|;
comment|/* the size of the dest */
name|int
name|horoff
decl_stmt|,
name|vertoff
decl_stmt|;
name|int
modifier|*
name|rcenter
decl_stmt|,
decl|*
name|ccenter
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|bitmat
name|retval
decl_stmt|,
name|source
decl_stmt|;
name|int
name|tr
decl_stmt|,
name|tc
decl_stmt|;
comment|/* the size of source */
name|char
name|tmp
index|[
name|WINDSIZE
index|]
decl_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"findbits(c=%s, nr=%d, nc=%d, horoff=%d, vertoff=%d\n"
argument_list|,
name|rdchar
argument_list|(
name|c
argument_list|)
argument_list|,
name|nr
argument_list|,
name|nc
argument_list|,
name|horoff
argument_list|,
name|vertoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|disptable
index|[
name|c
index|]
operator|.
name|nbytes
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
switch|switch
condition|(
name|cht
index|[
name|c
index|]
operator|.
name|wherewind
condition|)
block|{
case|case
operator|-
literal|2
case|:
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"case -2, saved from prev place\n"
argument_list|)
expr_stmt|;
comment|/* Saved from previous place */
name|source
operator|=
name|cht
index|[
name|c
index|]
operator|.
name|whereat
expr_stmt|;
comment|/* Ignore horoff/vertoff assuming they are already right */
operator|*
name|rcenter
operator|=
name|cht
index|[
name|c
index|]
operator|.
name|rcent
expr_stmt|;
operator|*
name|ccenter
operator|=
name|cht
index|[
name|c
index|]
operator|.
name|ccent
expr_stmt|;
comment|/* 		 * Small but important optimization: if the desired result is 		 * a whole window and the source happens to be in a whole 		 * window, just return the source pointer.  This saves 		 * lots of memory copies and happens quite often. 		 */
if|if
condition|(
name|nr
operator|==
name|GLROW
operator|&&
name|nc
operator|==
name|GLCOL
condition|)
return|return
operator|(
name|source
operator|)
return|;
name|tr
operator|=
name|GLROW
expr_stmt|;
name|tc
operator|=
name|GLCOL
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"case -1: first time\n"
argument_list|)
expr_stmt|;
comment|/* First time for this glyph: get it from font file */
name|fseek
argument_list|(
name|fontdes
argument_list|,
operator|(
name|long
operator|)
name|fbase
operator|+
name|disptable
index|[
name|c
index|]
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tr
operator|=
name|cht
index|[
name|c
index|]
operator|.
name|nrow
expr_stmt|;
name|tc
operator|=
name|cht
index|[
name|c
index|]
operator|.
name|ncol
expr_stmt|;
if|if
condition|(
name|tr
operator|>
name|GLROW
operator|||
name|tc
operator|>
name|GLCOL
operator|||
name|disptable
index|[
name|c
index|]
operator|.
name|nbytes
operator|>
name|WINDSIZE
condition|)
name|error
argument_list|(
literal|"glyph too large for window"
argument_list|)
expr_stmt|;
operator|*
name|rcenter
operator|=
name|vertoff
operator|+
name|disptable
index|[
name|c
index|]
operator|.
name|up
expr_stmt|;
operator|*
name|ccenter
operator|=
name|horoff
operator|+
name|disptable
index|[
name|c
index|]
operator|.
name|left
expr_stmt|;
name|source
operator|=
name|tmp
expr_stmt|;
name|fread
argument_list|(
name|source
argument_list|,
name|disptable
index|[
name|c
index|]
operator|.
name|nbytes
argument_list|,
literal|1
argument_list|,
name|fontdes
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"case default, in window %d"
argument_list|,
name|cht
index|[
name|c
index|]
operator|.
name|wherewind
argument_list|)
expr_stmt|;
name|source
operator|=
name|wind
index|[
name|cht
index|[
name|c
index|]
operator|.
name|wherewind
index|]
operator|.
name|val
expr_stmt|;
name|tr
operator|=
name|GLROW
expr_stmt|;
name|tc
operator|=
name|GLCOL
expr_stmt|;
operator|*
name|rcenter
operator|=
name|vertoff
operator|+
name|cht
index|[
name|c
index|]
operator|.
name|rcent
expr_stmt|;
operator|*
name|ccenter
operator|=
name|horoff
operator|+
name|cht
index|[
name|c
index|]
operator|.
name|ccent
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"curchar=%c=%d, tr=%d, tc=%d\n"
argument_list|,
name|curchar
argument_list|,
name|curchar
argument_list|,
name|tr
argument_list|,
name|tc
argument_list|)
expr_stmt|;
name|dumpmat
argument_list|(
literal|"before copy, source"
argument_list|,
name|source
argument_list|,
name|tr
argument_list|,
name|tc
argument_list|)
expr_stmt|;
comment|/* Copy in the bits into a bitmat of the right size */
name|retval
operator|=
name|newmat
argument_list|(
name|nr
argument_list|,
name|nc
argument_list|)
expr_stmt|;
name|r1
operator|=
name|max
argument_list|(
literal|0
argument_list|,
operator|-
name|vertoff
argument_list|)
expr_stmt|;
name|r2
operator|=
name|min
argument_list|(
name|GLROW
operator|-
name|vertoff
operator|-
literal|1
argument_list|,
name|GLROW
operator|-
literal|1
argument_list|)
expr_stmt|;
name|r2
operator|=
name|min
argument_list|(
name|r2
argument_list|,
name|tr
operator|-
literal|1
argument_list|)
expr_stmt|;
name|c1
operator|=
name|max
argument_list|(
literal|0
argument_list|,
operator|-
name|horoff
argument_list|)
expr_stmt|;
name|c2
operator|=
name|min
argument_list|(
name|GLCOL
operator|-
name|horoff
operator|-
literal|1
argument_list|,
name|GLCOL
operator|-
literal|1
argument_list|)
expr_stmt|;
name|c2
operator|=
name|min
argument_list|(
name|c2
argument_list|,
name|tc
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"findbits copy: r1=%d, r2=%d, c1=%d, c2=%d, horoff=%d, vertoff=%d\n"
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|,
name|horoff
argument_list|,
name|vertoff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|r1
init|;
name|i
operator|<=
name|r2
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|c1
init|;
name|j
operator|<=
name|c2
condition|;
name|j
operator|++
control|)
name|setmat
argument_list|(
name|retval
argument_list|,
name|nr
argument_list|,
name|nc
argument_list|,
name|i
operator|+
name|vertoff
argument_list|,
name|j
operator|+
name|horoff
argument_list|,
name|mat
argument_list|(
name|source
argument_list|,
name|tr
argument_list|,
name|tc
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dumpmat
argument_list|(
literal|"result of copy"
argument_list|,
name|retval
argument_list|,
name|nr
argument_list|,
name|nc
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * bufmod: called just before a buffer modifying command.  * Makes a backup copy of the glyph so we can undo later.  */
end_comment

begin_macro
name|bufmod
argument_list|()
end_macro

begin_block
block|{
name|changes
operator|++
expr_stmt|;
if|if
condition|(
name|curwind
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|wind
index|[
name|curwind
index|]
operator|.
name|undval
operator|==
name|NULL
condition|)
name|wind
index|[
name|curwind
index|]
operator|.
name|undval
operator|=
name|newmat
argument_list|(
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
name|bitcopy
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|undval
argument_list|,
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
name|und_p_r
operator|=
name|pen_r
expr_stmt|;
name|und_p_c
operator|=
name|pen_c
expr_stmt|;
name|und_c_r
operator|=
name|curs_r
expr_stmt|;
name|und_c_c
operator|=
name|curs_c
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * undo: restore the backup copy.  We just swap pointers, which is  * the same as interchanging the two matrices.  This way, undo is  * its own inverse.  */
end_comment

begin_macro
name|undo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|bitmat
name|tmp
decl_stmt|;
if|if
condition|(
name|wind
index|[
name|curwind
index|]
operator|.
name|undval
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Nothing to undo"
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|wind
index|[
name|curwind
index|]
operator|.
name|val
expr_stmt|;
name|wind
index|[
name|curwind
index|]
operator|.
name|val
operator|=
name|wind
index|[
name|curwind
index|]
operator|.
name|undval
expr_stmt|;
name|wind
index|[
name|curwind
index|]
operator|.
name|undval
operator|=
name|tmp
expr_stmt|;
name|pen_r
operator|=
name|und_p_r
expr_stmt|;
name|pen_c
operator|=
name|und_p_c
expr_stmt|;
name|move
argument_list|(
name|base
index|[
name|curwind
index|]
operator|.
name|c
operator|+
name|pen_c
argument_list|,
name|base
index|[
name|curwind
index|]
operator|.
name|r
operator|+
name|GLROW
operator|-
name|pen_r
argument_list|)
expr_stmt|;
name|curs_r
operator|=
name|und_c_r
expr_stmt|;
name|curs_c
operator|=
name|und_c_c
expr_stmt|;
name|syncwind
argument_list|(
name|curwind
argument_list|)
expr_stmt|;
name|changes
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * drawline: draw a line of current flavor between the named two points.  * All points are relative to current window.  *  * The algorithm is that of a simple DDA.  This is similar to what the  * hardware of the HP 2648 does but the placing of the points will be  * different (because of thick pens and erasers).  */
end_comment

begin_macro
name|drawline
argument_list|(
argument|from_r
argument_list|,
argument|from_c
argument_list|,
argument|to_r
argument_list|,
argument|to_c
argument_list|)
end_macro

begin_block
block|{
name|int
name|length
decl_stmt|,
name|i
decl_stmt|;
name|float
name|x
decl_stmt|,
name|y
decl_stmt|,
name|xinc
decl_stmt|,
name|yinc
decl_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"drawline from (%d, %d) to (%d, %d)\n"
argument_list|,
name|from_r
argument_list|,
name|from_c
argument_list|,
name|to_r
argument_list|,
name|to_c
argument_list|)
expr_stmt|;
name|length
operator|=
name|max
argument_list|(
name|abs
argument_list|(
name|to_r
operator|-
name|from_r
argument_list|)
argument_list|,
name|abs
argument_list|(
name|to_c
operator|-
name|from_c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
block|{
comment|/* 		 * The actual value doesn't matter, we're just avoiding 		 * division by zero here. 		 */
name|xinc
operator|=
name|yinc
operator|=
literal|1.0
expr_stmt|;
block|}
else|else
block|{
name|xinc
operator|=
operator|(
call|(
name|float
call|)
argument_list|(
name|to_r
operator|-
name|from_r
argument_list|)
operator|)
operator|/
name|length
expr_stmt|;
name|yinc
operator|=
operator|(
call|(
name|float
call|)
argument_list|(
name|to_c
operator|-
name|from_c
argument_list|)
operator|)
operator|/
name|length
expr_stmt|;
block|}
name|drawpoint
argument_list|(
name|from_r
argument_list|,
name|from_c
argument_list|)
expr_stmt|;
name|x
operator|=
name|from_r
operator|+
literal|0.5
expr_stmt|;
name|y
operator|=
name|from_c
operator|+
literal|0.5
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|+=
name|xinc
expr_stmt|;
name|y
operator|+=
name|yinc
expr_stmt|;
name|drawpoint
argument_list|(
operator|(
name|int
operator|)
name|x
argument_list|,
operator|(
name|int
operator|)
name|y
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * drawpoint: make a point of the current flavor at (r, c).  */
end_comment

begin_expr_stmt
name|drawpoint
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
specifier|register
name|int
name|r
operator|,
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|penweight
operator|==
literal|0
condition|)
name|setmat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
argument_list|,
name|pencolor
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|penmat
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
name|setmat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
operator|+
name|i
operator|-
literal|4
argument_list|,
name|c
operator|+
name|j
operator|-
literal|4
argument_list|,
name|pencolor
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * setcmd: handle the s command.  Format: s<what><where>.  */
end_comment

begin_macro
name|setcmd
argument_list|()
end_macro

begin_block
block|{
name|char
name|what
decl_stmt|,
name|where
decl_stmt|;
name|message
argument_list|(
literal|"set<what>"
argument_list|)
expr_stmt|;
name|what
operator|=
name|inchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
literal|'p'
case|:
comment|/* set pen */
name|message
argument_list|(
literal|"set pen<weight>"
argument_list|)
expr_stmt|;
name|where
operator|=
name|inchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|where
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* set pen fine */
case|case
literal|'l'
case|:
comment|/* set pen light */
name|message
argument_list|(
literal|"set pen fine"
argument_list|)
expr_stmt|;
name|penweight
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* set pen heavy */
case|case
literal|'b'
case|:
comment|/* set pen bold */
name|message
argument_list|(
literal|"set pen heavy"
argument_list|)
expr_stmt|;
name|penweight
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Illegal kind of pen weight"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* set size of heavy pen */
name|message
argument_list|(
literal|"set pen size to<size>"
argument_list|)
expr_stmt|;
name|where
operator|=
name|inchar
argument_list|()
operator|-
literal|'0'
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"set pen size to %d"
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
operator|>
literal|0
operator|&&
name|where
operator|<
literal|10
condition|)
block|{
name|setpen
argument_list|(
name|where
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Illegal size"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|message
argument_list|(
literal|"set draw"
argument_list|)
expr_stmt|;
name|pencolor
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|message
argument_list|(
literal|"set erase"
argument_list|)
expr_stmt|;
name|pencolor
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Illegal set"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * setpen: set the heavy pen size to s.  * Main work here is defining template of pen.  */
end_comment

begin_macro
name|setpen
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|float
name|radius
decl_stmt|;
if|if
condition|(
name|s
operator|<
literal|1
condition|)
name|s
operator|=
literal|1
expr_stmt|;
name|hpensize
operator|=
name|s
expr_stmt|;
name|radius
operator|=
name|hpensize
expr_stmt|;
name|radius
operator|/=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|penmat
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|radius
operator|>=
name|sqrtmat
index|[
name|abs
argument_list|(
name|i
operator|-
literal|4
argument_list|)
index|]
index|[
name|abs
argument_list|(
name|j
operator|-
literal|4
argument_list|)
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Kludge to make a 2-wide pen possible by specifying 1. 	 */
if|if
condition|(
name|hpensize
operator|==
literal|1
condition|)
name|penmat
index|[
literal|4
index|]
index|[
literal|5
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|trace
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"%c"
argument_list|,
name|penmat
index|[
name|i
index|]
index|[
name|j
index|]
condition|?
literal|'P'
else|:
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * error: print the given error message and return for another command.  */
end_comment

begin_macro
name|error
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * copymove: do a move or copy command.  * cmd is C or M, the command.  */
end_comment

begin_macro
name|copymove
argument_list|(
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|char
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|action
decl_stmt|;
name|char
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|bitmat
name|cpy
decl_stmt|;
name|char
name|lochr
index|[
literal|5
index|]
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|'C'
condition|)
name|action
operator|=
literal|"copy"
expr_stmt|;
else|else
name|action
operator|=
literal|"move"
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"%s<from>"
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|src
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"%s %s to<to>"
argument_list|,
name|action
argument_list|,
name|rdchar
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|dest
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|lochr
argument_list|,
name|rdchar
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"%s %s to %s"
argument_list|,
name|action
argument_list|,
name|lochr
argument_list|,
name|rdchar
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
comment|/* Do the copy */
name|disptable
index|[
name|dest
index|]
operator|=
name|disptable
index|[
name|src
index|]
expr_stmt|;
name|cht
index|[
name|dest
index|]
operator|=
name|cht
index|[
name|src
index|]
expr_stmt|;
if|if
condition|(
name|cht
index|[
name|dest
index|]
operator|.
name|wherewind
operator|>=
literal|0
condition|)
name|wind
index|[
name|cht
index|[
name|dest
index|]
operator|.
name|wherewind
index|]
operator|.
name|used
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|'C'
condition|)
block|{
if|if
condition|(
name|cht
index|[
name|dest
index|]
operator|.
name|wherewind
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Make copies of the window so changing 			 * one won't change the other. 			 * The old copy gets the window on the screen, if any, 			 * relegating the new copy to the background. 			 */
name|cpy
operator|=
name|newmat
argument_list|(
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cht
index|[
name|dest
index|]
operator|.
name|wherewind
operator|>=
literal|0
condition|)
name|bitcopy
argument_list|(
name|cpy
argument_list|,
name|wind
index|[
name|cht
index|[
name|src
index|]
operator|.
name|wherewind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
else|else
name|bitcopy
argument_list|(
name|cpy
argument_list|,
name|cht
index|[
name|src
index|]
operator|.
name|whereat
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cht
index|[
name|dest
index|]
operator|.
name|wherewind
operator|==
name|curwind
condition|)
name|curwind
operator|=
operator|-
literal|1
expr_stmt|;
name|cht
index|[
name|dest
index|]
operator|.
name|wherewind
operator|=
operator|-
literal|2
expr_stmt|;
name|cht
index|[
name|dest
index|]
operator|.
name|whereat
operator|=
name|cpy
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Move. Delete the old entries. 		 */
name|disptable
index|[
name|src
index|]
operator|.
name|addr
operator|=
name|disptable
index|[
name|src
index|]
operator|.
name|nbytes
operator|=
literal|0
expr_stmt|;
name|cht
index|[
name|src
index|]
operator|.
name|wherewind
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|changes
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * cch: make sure there is a current character.  */
end_comment

begin_macro
name|cch
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|curwind
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"No current glyph"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * confirm: if there have been changes, ask user if he is sure.  */
end_comment

begin_macro
name|confirm
argument_list|()
end_macro

begin_block
block|{
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|changes
operator|==
literal|0
condition|)
return|return;
name|message
argument_list|(
literal|"Changes since last write -- Are you sure?"
argument_list|)
expr_stmt|;
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|tolower
argument_list|(
name|ch
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'y'
case|:
case|case
literal|'q'
case|:
case|case
literal|'e'
case|:
return|return;
case|case
literal|'n'
case|:
default|default:
name|error
argument_list|(
literal|"Not sure - aborted"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * delchar: the D command.  Delete a character from the buffer.  */
end_comment

begin_macro
name|delchar
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
specifier|register
name|int
name|w
decl_stmt|;
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
name|message
argument_list|(
literal|"delete<char>"
argument_list|)
expr_stmt|;
name|c1
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"delete %s through<char>"
argument_list|,
name|rdchar
argument_list|(
name|c1
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|c2
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|rdchar
argument_list|(
name|c1
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"delete %s through %s"
argument_list|,
name|buf
argument_list|,
name|rdchar
argument_list|(
name|c2
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|changes
operator|++
expr_stmt|;
for|for
control|(
name|c
operator|=
name|c1
init|;
name|c
operator|<=
name|c2
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|cht
index|[
name|c
index|]
operator|.
name|wherewind
operator|)
operator|>=
literal|0
condition|)
block|{
name|zermat
argument_list|(
name|wind
index|[
name|w
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
name|syncwind
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|cht
index|[
name|c
index|]
operator|.
name|wherewind
operator|=
operator|-
literal|1
expr_stmt|;
name|disptable
index|[
name|c
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
name|disptable
index|[
name|c
index|]
operator|.
name|nbytes
operator|=
literal|0
expr_stmt|;
name|disptable
index|[
name|c
index|]
operator|.
name|up
operator|=
literal|0
expr_stmt|;
name|disptable
index|[
name|c
index|]
operator|.
name|down
operator|=
literal|0
expr_stmt|;
name|disptable
index|[
name|c
index|]
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|disptable
index|[
name|c
index|]
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|disptable
index|[
name|c
index|]
operator|.
name|width
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * zoom out to full screen so the screen doean't go nuts when we  * print off the current zoom window.  Save old value of zoom in  * oldzoom so space can put us back.  */
end_comment

begin_macro
name|zoomout
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|curzoom
operator|!=
literal|1
condition|)
name|zoomn
argument_list|(
name|curzoom
operator|=
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * newglyph: the n command.  */
end_comment

begin_macro
name|newglyph
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|windno
decl_stmt|;
name|int
name|vertoff
decl_stmt|,
name|horoff
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|message
argument_list|(
literal|"new glyph<char>"
argument_list|)
expr_stmt|;
name|curchar
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"new glyph %s"
argument_list|,
name|rdchar
argument_list|(
name|curchar
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"\n\nnewglyph(%s)\n"
argument_list|,
name|rdchar
argument_list|(
name|curchar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disptable
index|[
name|curchar
index|]
operator|.
name|nbytes
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"char exists: %s\n"
argument_list|,
name|rdchar
argument_list|(
name|curchar
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"char exists: %s"
argument_list|,
name|rdchar
argument_list|(
name|curchar
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
block|}
name|turnofcurs
argument_list|()
expr_stmt|;
comment|/* 	 * Not on screen.  First find a suitable window, 	 * using round robin. 	 */
name|windno
operator|=
name|nextwind
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"chose window %d\n"
argument_list|,
name|windno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|nextwind
operator|>=
name|NWIND
condition|)
name|nextwind
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|nextwind
operator|>=
literal|3
condition|)
name|nextwind
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|wind
index|[
name|windno
index|]
operator|.
name|used
operator|=
name|curchar
expr_stmt|;
comment|/* Put a box around the current window */
if|if
condition|(
name|windno
operator|!=
name|curwind
condition|)
block|{
name|drawbox
argument_list|(
name|base
index|[
name|curwind
index|]
operator|.
name|r
operator|-
literal|1
argument_list|,
name|base
index|[
name|curwind
index|]
operator|.
name|c
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|GLROW
operator|+
literal|2
argument_list|,
name|GLCOL
operator|+
literal|2
argument_list|)
expr_stmt|;
name|drawbox
argument_list|(
name|base
index|[
name|windno
index|]
operator|.
name|r
operator|-
literal|1
argument_list|,
name|base
index|[
name|windno
index|]
operator|.
name|c
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|GLROW
operator|+
literal|2
argument_list|,
name|GLCOL
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Print the char at the lower left of the window */
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"%s"
argument_list|,
name|rdchar
argument_list|(
name|curchar
argument_list|)
argument_list|)
expr_stmt|;
name|dispmsg
argument_list|(
name|msgbuf
argument_list|,
name|base
index|[
name|windno
index|]
operator|.
name|c
argument_list|,
name|base
index|[
name|windno
index|]
operator|.
name|r
operator|-
literal|11
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Now make room in the window */
if|if
condition|(
name|wind
index|[
name|windno
index|]
operator|.
name|onscreen
operator|==
name|NULL
condition|)
block|{
comment|/* Brand new window, have to allocate space */
name|wind
index|[
name|windno
index|]
operator|.
name|onscreen
operator|=
name|newmat
argument_list|(
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Save prev glyph for later */
name|cht
index|[
name|wind
index|[
name|curchar
index|]
operator|.
name|used
index|]
operator|.
name|whereat
operator|=
name|wind
index|[
name|windno
index|]
operator|.
name|val
expr_stmt|;
name|cht
index|[
name|wind
index|[
name|curchar
index|]
operator|.
name|used
index|]
operator|.
name|wherewind
operator|=
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|wind
index|[
name|windno
index|]
operator|.
name|undval
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"newglyph frees undo: %x\n"
argument_list|,
name|wind
index|[
name|windno
index|]
operator|.
name|undval
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wind
index|[
name|windno
index|]
operator|.
name|undval
argument_list|)
expr_stmt|;
block|}
name|wind
index|[
name|windno
index|]
operator|.
name|undval
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Vertical& horizontal offsets.  Line up the baseline 	 * of the char at BASELINE from bottom, but center 	 * horizontally. 	 */
name|wind
index|[
name|windno
index|]
operator|.
name|val
operator|=
name|newmat
argument_list|(
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
name|curwind
operator|=
name|windno
expr_stmt|;
name|cht
index|[
name|curchar
index|]
operator|.
name|wherewind
operator|=
name|windno
expr_stmt|;
name|cht
index|[
name|curchar
index|]
operator|.
name|rcent
operator|=
name|curs_r
operator|=
name|GLROW
operator|-
name|BASELINE
expr_stmt|;
name|cht
index|[
name|curchar
index|]
operator|.
name|ccent
operator|=
name|curs_c
operator|=
name|GLCOL
operator|/
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|dumpmat
argument_list|(
literal|"wind[windno].onscreen"
argument_list|,
name|wind
index|[
name|windno
index|]
operator|.
name|onscreen
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|syncwind
argument_list|(
name|windno
argument_list|)
expr_stmt|;
comment|/* 	 * Mung the zoom out to 1 and back.  This is needed to 	 * re-center the glyph on the screen if zoomed in, otherwise 	 * if you move by one window it puts the cursor way over at 	 * the right with only half the window visible. 	 */
if|if
condition|(
operator|(
name|i
operator|=
name|curzoom
operator|)
operator|>
literal|1
condition|)
block|{
name|zoomn
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|zoomn
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * numedit: change one of the numerical parameters.  */
end_comment

begin_macro
name|numedit
argument_list|()
end_macro

begin_block
block|{
name|short
modifier|*
name|sp
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|,
name|f
decl_stmt|;
name|char
modifier|*
name|fld
decl_stmt|;
name|short
name|ovalue
decl_stmt|,
name|nvalue
decl_stmt|;
name|char
name|numb
index|[
literal|20
index|]
decl_stmt|;
name|message
argument_list|(
literal|"number of<char>"
argument_list|)
expr_stmt|;
name|c
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"number of %s<field>"
argument_list|,
name|rdchar
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|f
operator|=
name|inchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|f
condition|)
block|{
case|case
literal|'a'
case|:
name|sp
operator|=
operator|(
name|short
operator|*
operator|)
operator|&
name|disptable
index|[
name|c
index|]
operator|.
name|addr
expr_stmt|;
name|fld
operator|=
literal|"addr"
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|sp
operator|=
operator|&
name|disptable
index|[
name|c
index|]
operator|.
name|nbytes
expr_stmt|;
name|fld
operator|=
literal|"nbytes"
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|cp
operator|=
operator|&
name|disptable
index|[
name|c
index|]
operator|.
name|up
expr_stmt|;
name|fld
operator|=
literal|"up"
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|cp
operator|=
operator|&
name|disptable
index|[
name|c
index|]
operator|.
name|down
expr_stmt|;
name|fld
operator|=
literal|"down"
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|cp
operator|=
operator|&
name|disptable
index|[
name|c
index|]
operator|.
name|left
expr_stmt|;
name|fld
operator|=
literal|"left"
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|cp
operator|=
operator|&
name|disptable
index|[
name|c
index|]
operator|.
name|right
expr_stmt|;
name|fld
operator|=
literal|"right"
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|sp
operator|=
operator|&
name|disptable
index|[
name|c
index|]
operator|.
name|width
expr_stmt|;
name|fld
operator|=
literal|"width"
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sp
operator|=
operator|(
name|short
operator|*
operator|)
operator|&
name|disptable
index|[
name|c
index|]
operator|.
name|nbytes
expr_stmt|;
name|fld
operator|=
literal|"size"
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"No such field"
argument_list|)
expr_stmt|;
block|}
name|ovalue
operator|=
name|sp
condition|?
operator|*
name|sp
else|:
operator|*
name|cp
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"number of %s %s (old value %d) is "
argument_list|,
name|rdchar
argument_list|(
name|c
argument_list|)
argument_list|,
name|fld
argument_list|,
name|ovalue
argument_list|)
expr_stmt|;
name|readline
argument_list|(
name|msgbuf
argument_list|,
name|numb
argument_list|,
sizeof|sizeof
name|numb
argument_list|)
expr_stmt|;
name|nvalue
operator|=
name|atoi
argument_list|(
name|numb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
name|nvalue
expr_stmt|;
else|else
operator|*
name|sp
operator|=
name|nvalue
expr_stmt|;
name|changes
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * These routines turn the cursor and rubber band line on and off,  * remembering its state for the o and r commands.  */
end_comment

begin_macro
name|turnoncurs
argument_list|()
end_macro

begin_block
block|{
name|curon
argument_list|()
expr_stmt|;
name|curcurs
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|turnofcurs
argument_list|()
end_macro

begin_block
block|{
name|curoff
argument_list|()
expr_stmt|;
name|curcurs
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|turnonrb
argument_list|()
end_macro

begin_block
block|{
name|rbon
argument_list|()
expr_stmt|;
name|currb
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|turnofrb
argument_list|()
end_macro

begin_block
block|{
name|rboff
argument_list|()
expr_stmt|;
name|currb
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|synccurs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|=
name|base
index|[
name|curwind
index|]
operator|.
name|c
operator|+
name|curs_c
expr_stmt|;
name|y
operator|=
name|base
index|[
name|curwind
index|]
operator|.
name|r
operator|+
name|GLROW
operator|-
name|curs_r
operator|-
literal|1
expr_stmt|;
name|movecurs
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|inchar
argument_list|()
end_macro

begin_block
block|{
name|sync
argument_list|()
expr_stmt|;
name|synccurs
argument_list|()
expr_stmt|;
return|return
operator|(
name|rawchar
argument_list|()
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * fillin - fill in with 1's all the spots that are in the enclosed  * area that (x, y) is in.  */
end_comment

begin_macro
name|fillin
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>=
name|GLROW
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|GLCOL
operator|||
name|mat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return;
name|setmat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fillin
argument_list|(
name|x
operator|-
literal|1
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|fillin
argument_list|(
name|x
operator|+
literal|1
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|fillin
argument_list|(
name|x
argument_list|,
name|y
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fillin
argument_list|(
name|x
argument_list|,
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * syncwind: make sure that window #n shows on the screen what it's  * supposed to after an arbitrary change.  */
end_comment

begin_macro
name|syncwind
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"syncwind(%d)\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|wind
index|[
name|n
index|]
operator|.
name|onscreen
argument_list|,
name|wind
index|[
name|n
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|base
index|[
name|n
index|]
operator|.
name|r
argument_list|,
name|base
index|[
name|n
index|]
operator|.
name|c
argument_list|)
expr_stmt|;
name|bitcopy
argument_list|(
name|wind
index|[
name|n
index|]
operator|.
name|onscreen
argument_list|,
name|wind
index|[
name|n
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Embolden artificially emboldens the glyphs in the font by smearing  * them to the right by the current heavy pen size.  Or else italicize it.  */
end_comment

begin_macro
name|artificial
argument_list|()
end_macro

begin_block
block|{
name|int
name|low
decl_stmt|,
name|high
decl_stmt|,
name|cur
decl_stmt|;
name|int
name|oldps
decl_stmt|,
name|newps
decl_stmt|;
name|char
name|lowch
index|[
literal|10
index|]
decl_stmt|;
define|#
directive|define
name|ITAL
value|0
define|#
directive|define
name|BOLD
value|1
define|#
directive|define
name|RESIZE
value|2
define|#
directive|define
name|SMOOTH
value|3
name|int
name|kind
decl_stmt|;
name|char
modifier|*
name|strbold
decl_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"Artificially<embolden/italicize/resize/smooth>"
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|cur
operator|=
name|inchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cur
condition|)
block|{
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
name|kind
operator|=
name|ITAL
expr_stmt|;
name|strbold
operator|=
literal|"italicize"
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
name|kind
operator|=
name|BOLD
expr_stmt|;
name|strbold
operator|=
literal|"embolden"
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|kind
operator|=
name|RESIZE
expr_stmt|;
name|strbold
operator|=
literal|"resize"
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|kind
operator|=
name|SMOOTH
expr_stmt|;
name|strbold
operator|=
literal|"smooth"
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"No such artificial operation"
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"Artificially %s glyphs from<char>"
argument_list|,
name|strbold
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|low
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|lowch
argument_list|,
name|rdchar
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"Artificially %s glyphs from %s to<char>"
argument_list|,
name|strbold
argument_list|,
name|lowch
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|high
operator|=
name|inchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|RESIZE
condition|)
block|{
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"Artificially %s glyphs from %s to %s from<point size>"
argument_list|,
name|strbold
argument_list|,
name|lowch
argument_list|,
name|rdchar
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|oldps
operator|=
name|readnum
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"Artificially %s glyphs from %s to %s from %dP to<point size>P"
argument_list|,
name|strbold
argument_list|,
name|lowch
argument_list|,
name|rdchar
argument_list|(
name|high
argument_list|)
argument_list|,
name|oldps
argument_list|)
expr_stmt|;
name|newps
operator|=
name|readnum
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"Artificially %s glyphs from %s to %s from %dP to %dP"
argument_list|,
name|strbold
argument_list|,
name|lowch
argument_list|,
name|rdchar
argument_list|(
name|high
argument_list|)
argument_list|,
name|oldps
argument_list|,
name|newps
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldps
operator|<=
literal|0
operator|||
name|oldps
operator|>
literal|36
operator|||
name|newps
operator|<=
literal|0
operator|||
name|newps
operator|>
literal|36
operator|||
name|oldps
operator|==
name|newps
condition|)
name|error
argument_list|(
literal|"Bad point sizes"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"Artificially %s glyphs from %s to %s"
argument_list|,
name|strbold
argument_list|,
name|lowch
argument_list|,
name|rdchar
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|cur
operator|=
name|low
init|;
name|cur
operator|<=
name|high
condition|;
name|cur
operator|++
control|)
block|{
name|getglyph
argument_list|(
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
operator|==
name|cur
condition|)
block|{
comment|/* e.g. if the getglyph succeeded */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|BOLD
case|:
name|boldglyph
argument_list|()
expr_stmt|;
break|break;
case|case
name|ITAL
case|:
name|italglyph
argument_list|()
expr_stmt|;
break|break;
case|case
name|RESIZE
case|:
if|if
condition|(
name|oldps
operator|>
name|newps
condition|)
name|shrinkglyph
argument_list|(
name|oldps
argument_list|,
name|newps
argument_list|)
expr_stmt|;
else|else
name|blowupglyph
argument_list|(
name|oldps
argument_list|,
name|newps
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMOOTH
case|:
name|smoothglyph
argument_list|()
expr_stmt|;
break|break;
block|}
name|syncwind
argument_list|(
name|curwind
argument_list|)
expr_stmt|;
block|}
block|}
name|message
argument_list|(
literal|"Done"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Artificially embolden the current glyph.  */
end_comment

begin_macro
name|boldglyph
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|r
decl_stmt|,
name|c
decl_stmt|,
name|i
decl_stmt|;
name|int
name|smear
init|=
name|hpensize
operator|<
literal|2
condition|?
literal|2
else|:
name|hpensize
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|GLROW
condition|;
name|r
operator|++
control|)
for|for
control|(
name|c
operator|=
name|GLCOL
operator|-
literal|1
init|;
name|c
operator|>=
name|smear
condition|;
name|c
operator|--
control|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|smear
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
operator|-
name|i
argument_list|)
condition|)
name|setmat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Artificially italicize the current glyph.  */
end_comment

begin_macro
name|italglyph
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|r
decl_stmt|,
name|c
decl_stmt|,
name|i
decl_stmt|,
name|off
decl_stmt|;
name|int
name|baser
init|=
name|cht
index|[
name|curchar
index|]
operator|.
name|rcent
decl_stmt|;
comment|/* GLROW - BASELINE; */
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|baser
condition|;
name|r
operator|++
control|)
block|{
name|off
operator|=
operator|(
name|baser
operator|-
name|r
operator|)
operator|/
name|SLOPE
operator|+
literal|0.5
expr_stmt|;
for|for
control|(
name|c
operator|=
name|GLCOL
operator|-
literal|1
init|;
name|c
operator|>=
name|off
condition|;
name|c
operator|--
control|)
block|{
name|setmat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
argument_list|,
name|mat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
operator|-
name|off
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
name|off
operator|-
literal|1
init|;
name|c
operator|>=
literal|0
condition|;
name|c
operator|--
control|)
name|setmat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|r
operator|=
name|baser
init|;
name|r
operator|<
name|GLROW
condition|;
name|r
operator|++
control|)
block|{
name|off
operator|=
operator|(
name|r
operator|-
name|baser
operator|)
operator|*
operator|(
literal|2.0
operator|/
literal|7.0
operator|)
operator|+
literal|0.5
expr_stmt|;
for|for
control|(
name|c
operator|=
name|off
init|;
name|c
operator|<
name|GLCOL
condition|;
name|c
operator|++
control|)
name|setmat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
operator|-
name|off
argument_list|,
name|mat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|off
operator|-
literal|1
init|;
name|c
operator|>=
literal|0
condition|;
name|c
operator|--
control|)
name|setmat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Blow up or shrink a glyph from oldps points to newps points.  * The basic idea is that for each on point in the old glyph we  * find the corresponding point in the new glyph and copy the value.  */
end_comment

begin_macro
name|shrinkglyph
argument_list|(
argument|oldps
argument_list|,
argument|newps
argument_list|)
end_macro

begin_decl_stmt
name|int
name|oldps
decl_stmt|,
name|newps
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|float
name|ratio
decl_stmt|;
specifier|register
name|int
name|or
decl_stmt|,
name|oc
decl_stmt|,
name|nr
decl_stmt|,
name|nc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|bitmat
name|tmp
decl_stmt|,
name|curw
decl_stmt|;
name|int
name|baser
init|=
name|cht
index|[
name|curchar
index|]
operator|.
name|rcent
decl_stmt|;
name|int
name|basec
init|=
name|cht
index|[
name|curchar
index|]
operator|.
name|ccent
decl_stmt|;
name|ratio
operator|=
operator|(
name|float
operator|)
name|newps
operator|/
operator|(
name|float
operator|)
name|oldps
expr_stmt|;
name|tmp
operator|=
name|newmat
argument_list|(
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
name|curw
operator|=
name|wind
index|[
name|curwind
index|]
operator|.
name|val
expr_stmt|;
name|bitcopy
argument_list|(
name|tmp
argument_list|,
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
name|zermat
argument_list|(
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
for|for
control|(
name|or
operator|=
literal|0
init|;
name|or
operator|<
name|GLROW
condition|;
name|or
operator|++
control|)
block|{
name|nr
operator|=
name|baser
operator|+
operator|(
name|or
operator|-
name|baser
operator|)
operator|*
name|ratio
operator|+
literal|0.5
expr_stmt|;
for|for
control|(
name|oc
operator|=
literal|0
init|;
name|oc
operator|<
name|GLCOL
condition|;
name|oc
operator|++
control|)
block|{
name|nc
operator|=
name|basec
operator|+
operator|(
name|oc
operator|-
name|basec
operator|)
operator|*
name|ratio
operator|+
literal|0.5
expr_stmt|;
if|if
condition|(
name|nr
operator|<
literal|0
operator|||
name|nr
operator|>=
name|GLROW
operator|||
name|nc
operator|<
literal|0
operator|||
name|nc
operator|>=
name|GLCOL
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|or
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|setmat
argument_list|(
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|nr
argument_list|,
name|nc
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|disptable
index|[
name|curchar
index|]
operator|.
name|width
operator|=
name|disptable
index|[
name|curchar
index|]
operator|.
name|width
operator|*
name|ratio
operator|+
literal|0.5
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * blow up a glyph.  Otherwise like shrinkglyph.  */
end_comment

begin_macro
name|blowupglyph
argument_list|(
argument|oldps
argument_list|,
argument|newps
argument_list|)
end_macro

begin_decl_stmt
name|int
name|oldps
decl_stmt|,
name|newps
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|float
name|ratio
decl_stmt|;
specifier|register
name|int
name|or
decl_stmt|,
name|oc
decl_stmt|,
name|nr
decl_stmt|,
name|nc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|bitmat
name|tmp
decl_stmt|,
name|curw
decl_stmt|;
name|int
name|baser
init|=
name|cht
index|[
name|curchar
index|]
operator|.
name|rcent
decl_stmt|;
name|int
name|basec
init|=
name|cht
index|[
name|curchar
index|]
operator|.
name|ccent
decl_stmt|;
name|ratio
operator|=
operator|(
name|float
operator|)
name|oldps
operator|/
operator|(
name|float
operator|)
name|newps
expr_stmt|;
name|tmp
operator|=
name|newmat
argument_list|(
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
name|curw
operator|=
name|wind
index|[
name|curwind
index|]
operator|.
name|val
expr_stmt|;
name|bitcopy
argument_list|(
name|tmp
argument_list|,
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
name|zermat
argument_list|(
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|GLROW
condition|;
name|nr
operator|++
control|)
block|{
name|or
operator|=
name|baser
operator|+
operator|(
name|nr
operator|-
name|baser
operator|)
operator|*
name|ratio
operator|+
literal|0.5
expr_stmt|;
for|for
control|(
name|nc
operator|=
literal|0
init|;
name|nc
operator|<
name|GLCOL
condition|;
name|nc
operator|++
control|)
block|{
name|oc
operator|=
name|basec
operator|+
operator|(
name|nc
operator|-
name|basec
operator|)
operator|*
name|ratio
operator|+
literal|0.5
expr_stmt|;
if|if
condition|(
name|or
operator|<
literal|0
operator|||
name|or
operator|>=
name|GLROW
operator|||
name|oc
operator|<
literal|0
operator|||
name|oc
operator|>=
name|GLCOL
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|or
argument_list|,
name|oc
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|setmat
argument_list|(
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|nr
argument_list|,
name|nc
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|disptable
index|[
name|curchar
index|]
operator|.
name|width
operator|=
name|disptable
index|[
name|curchar
index|]
operator|.
name|width
operator|/
name|ratio
operator|+
literal|0.5
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Smooth a glyph.  We look for corners and trim the point.  Corners of  * both blanks and dots in all 4 orientations are looked for.  */
end_comment

begin_macro
name|smoothglyph
argument_list|()
end_macro

begin_block
block|{
name|bitmat
name|tmp
decl_stmt|,
name|curw
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|int
name|c3
decl_stmt|;
name|int
name|a3
decl_stmt|,
name|b2
decl_stmt|,
name|b3
decl_stmt|,
name|b4
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|c4
decl_stmt|,
name|c5
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|,
name|d4
decl_stmt|,
name|e3
decl_stmt|;
name|tmp
operator|=
name|newmat
argument_list|(
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
name|curw
operator|=
name|wind
index|[
name|curwind
index|]
operator|.
name|val
expr_stmt|;
name|bitcopy
argument_list|(
name|tmp
argument_list|,
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|2
init|;
name|r
operator|<
name|GLROW
operator|-
literal|2
condition|;
name|r
operator|++
control|)
for|for
control|(
name|c
operator|=
literal|2
init|;
name|c
operator|<
name|GLCOL
operator|-
literal|2
condition|;
name|c
operator|++
control|)
block|{
comment|/* 			 *		a3 			 *	     b2 b3 b4 			 *	  c1 c2 c3 c4 c5 			 *	     d2 d3 d4 			 *	        d4 			 * where c3 is the square we are interested in 			 */
name|b3
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
operator|-
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c2
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
operator|-
literal|1
argument_list|)
expr_stmt|;
name|c4
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d3
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
operator|+
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* exactly 2 of the 4 neighbors must be dots */
if|if
condition|(
name|b3
operator|+
name|c2
operator|+
name|c4
operator|+
name|d3
operator|!=
literal|2
condition|)
continue|continue;
name|c3
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|b2
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
operator|-
literal|1
argument_list|,
name|c
operator|-
literal|1
argument_list|)
expr_stmt|;
name|b4
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
operator|-
literal|1
argument_list|,
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
operator|+
literal|1
argument_list|,
name|c
operator|-
literal|1
argument_list|)
expr_stmt|;
name|d4
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
operator|+
literal|1
argument_list|,
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* exactly one of the 4 diags must match the center */
if|if
condition|(
name|b2
operator|+
name|b4
operator|+
name|d2
operator|+
name|d4
operator|!=
literal|3
operator|-
literal|2
operator|*
name|c3
condition|)
continue|continue;
name|a3
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
operator|-
literal|2
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c1
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
operator|-
literal|2
argument_list|)
expr_stmt|;
name|c5
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
operator|+
literal|2
argument_list|)
expr_stmt|;
name|e3
operator|=
name|mat
argument_list|(
name|tmp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
operator|+
literal|2
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Figure out which of the 4 directions */
if|if
condition|(
name|b2
operator|==
name|c3
condition|)
block|{
if|if
condition|(
name|b3
operator|+
name|c2
operator|+
name|c1
operator|+
name|a3
operator|!=
literal|4
operator|*
name|c3
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|b4
operator|==
name|c3
condition|)
block|{
if|if
condition|(
name|b3
operator|+
name|c4
operator|+
name|c5
operator|+
name|a3
operator|!=
literal|4
operator|*
name|c3
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|d2
operator|==
name|c3
condition|)
block|{
if|if
condition|(
name|d3
operator|+
name|c2
operator|+
name|c1
operator|+
name|e3
operator|!=
literal|4
operator|*
name|c3
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|d4
operator|==
name|c3
condition|)
block|{
if|if
condition|(
name|d3
operator|+
name|c4
operator|+
name|c5
operator|+
name|e3
operator|!=
literal|4
operator|*
name|c3
condition|)
continue|continue;
block|}
comment|/* It must be a corner.  Toggle it. */
name|setmat
argument_list|(
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
argument_list|,
operator|!
name|c3
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Read a number from bottom line ala readline.  * This should probably go in lib2648.  */
end_comment

begin_function
name|int
name|readnum
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|readline
argument_list|(
name|prompt
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|retval
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"readline returns '%s', retval=%d\n"
argument_list|,
name|buf
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_macro
name|invert
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
name|int
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|kind
decl_stmt|;
name|bitmat
name|curw
init|=
name|wind
index|[
name|curwind
index|]
operator|.
name|val
decl_stmt|;
name|message
argument_list|(
literal|"Invert<horizontally/vertically>"
argument_list|)
expr_stmt|;
name|kind
operator|=
name|inchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|message
argument_list|(
literal|"Invert horizontally"
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|GLROW
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"row %d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<=
operator|(
name|GLCOL
operator|-
literal|1
operator|)
operator|/
literal|2
condition|;
name|c
operator|++
control|)
block|{
name|tmp1
operator|=
name|mat
argument_list|(
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|mat
argument_list|(
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|GLCOL
operator|-
literal|1
operator|-
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"cols %d (%d)<=> %d (%d)\n"
argument_list|,
name|c
argument_list|,
name|tmp1
argument_list|,
name|GLCOL
operator|-
literal|1
operator|-
name|c
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|setmat
argument_list|(
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|setmat
argument_list|(
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|GLCOL
operator|-
literal|1
operator|-
name|c
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|message
argument_list|(
literal|"Invert vertically"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|GLCOL
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<=
operator|(
name|GLROW
operator|-
literal|1
operator|)
operator|/
literal|2
condition|;
name|r
operator|++
control|)
block|{
name|tmp1
operator|=
name|mat
argument_list|(
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|mat
argument_list|(
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|GLROW
operator|-
literal|1
operator|-
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|setmat
argument_list|(
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|r
argument_list|,
name|c
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|setmat
argument_list|(
name|curw
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|GLROW
operator|-
literal|1
operator|-
name|r
argument_list|,
name|c
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"Bad choice"
argument_list|)
expr_stmt|;
block|}
name|syncwind
argument_list|(
name|curwind
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

