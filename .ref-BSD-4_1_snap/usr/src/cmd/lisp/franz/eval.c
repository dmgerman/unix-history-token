begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)eval.c	35.3 7/9/81"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*   file: eval.c							*/
end_comment

begin_comment
comment|/*   contents: evaluator and namestack maintenance routines		*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* eval *****************************************************************/
end_comment

begin_comment
comment|/* returns the value of the pointer passed as the argument.		*/
end_comment

begin_function
name|lispval
name|eval
parameter_list|(
name|actarg
parameter_list|)
name|lispval
name|actarg
decl_stmt|;
block|{
define|#
directive|define
name|argptr
value|handy
specifier|register
name|lispval
name|a
init|=
name|actarg
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|struct
name|nament
modifier|*
name|namptr
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|workp
decl_stmt|;
name|struct
name|nament
modifier|*
name|oldbnp
init|=
name|bnp
decl_stmt|;
name|int
name|dopopframe
init|=
name|FALSE
decl_stmt|;
name|lispval
name|Ifcall
argument_list|()
decl_stmt|,
name|Iarray
argument_list|()
decl_stmt|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/*debugging      if (rsetsw&& rsetatom->a.clb != nil) { 	printf("Eval:"); 	printr(a,stdout); 	printf("\nrsetsw: %d evalhsw: %d\n", rsetsw, evalhsw); 	printf("*rset: "); 	printr(rsetatom->a.clb,stdout); 	printf(" evalhook: "); 	printr(evalhatom->a.clb,stdout); 	printf(" evalhook call flag^G: %d\n", evalhcallsw); 	fflush(stdout);      };       */
comment|/* check if an interrupt is pending	 and handle if so */
if|if
condition|(
name|sigintcnt
operator|>
literal|0
condition|)
name|sigcall
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsetsw
operator|&&
name|rsetatom
operator|->
name|a
operator|.
name|clb
operator|!=
name|nil
condition|)
comment|/* if (*rset t) has been done */
block|{
if|if
condition|(
name|evalhsw
operator|!=
name|nil
operator|&&
name|evalhatom
operator|->
name|a
operator|.
name|clb
operator|!=
name|nil
condition|)
block|{
comment|/*if (sstatus evalhook t) 						    and evalhook non-nil */
if|if
condition|(
name|evalhcallsw
condition|)
comment|/*if this is a call to evalhook, don't call evalhook 			  function, but clear evalhcallsw , so recursive  			  calls to eval cause evalhook function to fire. */
name|evalhcallsw
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
comment|/* setup equivalent of (funcall evalhook<arg to eval>) */
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|a
expr_stmt|;
comment|/* push form on namestack */
name|lbot
operator|=
name|np
expr_stmt|;
comment|/* set up args to funcall */
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|evalhatom
operator|->
name|a
operator|.
name|clb
expr_stmt|;
comment|/* push evalhook's clb */
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|a
expr_stmt|;
comment|/* eval's arg becomes 						           2nd arg to funcall */
name|PUSHDOWN
argument_list|(
name|evalhatom
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* lambda-bind evalhook to nil*/
name|PUSHDOWN
argument_list|(
name|funhatom
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* lambda-bind evalhook to nil*/
name|funhcallsw
operator|=
name|TRUE
expr_stmt|;
comment|/* skip any funcall hook */
name|handy
operator|=
name|Lfuncal
argument_list|()
expr_stmt|;
comment|/* now call funcall */
name|funhcallsw
operator|=
name|FALSE
expr_stmt|;
name|POP
expr_stmt|;
name|POP
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
empty_stmt|;
block|}
name|errp
operator|=
name|Pushframe
argument_list|(
name|F_EVAL
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|dopopframe
operator|=
name|TRUE
expr_stmt|;
comment|/* remember to pop later */
if|if
condition|(
name|retval
operator|==
name|C_FRETURN
condition|)
block|{
name|Restorestack
argument_list|()
expr_stmt|;
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
return|return
operator|(
name|lispretval
operator|)
return|;
block|}
block|}
empty_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
if|if
condition|(
name|rsetsw
operator|&&
name|rsetatom
operator|->
name|a
operator|.
name|clb
operator|!=
name|nil
operator|&&
name|bptr_atom
operator|->
name|a
operator|.
name|clb
operator|!=
name|nil
condition|)
block|{
name|struct
name|nament
modifier|*
name|bpntr
decl_stmt|,
modifier|*
name|eval1bptr
decl_stmt|;
comment|/* Both rsetsw and rsetatom for efficiency*/
comment|/* bptr_atom set by second arg to eval1 */
name|eval1bptr
operator|=
operator|(
expr|struct
name|nament
operator|*
operator|)
name|bptr_atom
operator|->
name|a
operator|.
name|clb
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
comment|/* eval1bptr is bnp when eval1 was called; 				       if an atom was bound after this, 				       then its clb is valid */
for|for
control|(
name|bpntr
operator|=
name|eval1bptr
init|;
name|bpntr
operator|<
name|bnp
condition|;
name|bpntr
operator|++
control|)
if|if
condition|(
name|bpntr
operator|->
name|atm
operator|==
name|a
condition|)
block|{
name|handy
operator|=
name|a
operator|->
name|a
operator|.
name|clb
expr_stmt|;
goto|goto
name|gotatom
goto|;
block|}
empty_stmt|;
comment|/* Value saved in first binding of a, 				       if any, after pointer to eval1, 				       is the valid value, else use its clb */
for|for
control|(
name|bpntr
operator|=
operator|(
expr|struct
name|nament
operator|*
operator|)
name|bptr_atom
operator|->
name|a
operator|.
name|clb
operator|->
name|d
operator|.
name|car
init|;
name|bpntr
operator|<
name|eval1bptr
condition|;
name|bpntr
operator|++
control|)
if|if
condition|(
name|bpntr
operator|->
name|atm
operator|==
name|a
condition|)
block|{
name|handy
operator|=
name|bpntr
operator|->
name|val
expr_stmt|;
goto|goto
name|gotatom
goto|;
comment|/* Simply no way around goto here */
block|}
empty_stmt|;
block|}
empty_stmt|;
name|handy
operator|=
name|a
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|gotatom
label|:
if|if
condition|(
name|handy
operator|==
name|CNIL
condition|)
block|{
name|handy
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Unbound Variable:"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dopopframe
condition|)
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
case|case
name|VALUE
case|:
if|if
condition|(
name|dopopframe
condition|)
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|a
operator|->
name|l
operator|)
return|;
case|case
name|DTPR
case|:
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|a
expr_stmt|;
comment|/* push form on namestack */
name|lbot
operator|=
name|np
expr_stmt|;
comment|/* define beginning of argstack */
comment|/* oldbnp = bnp;		   redundant - Mitch Marcus */
name|a
operator|=
name|a
operator|->
name|d
operator|.
name|car
expr_stmt|;
comment|/* function name or lambda-expr */
for|for
control|(
name|EVER
control|)
block|{
switch|switch
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
comment|/*  get function binding  */
if|if
condition|(
name|a
operator|->
name|a
operator|.
name|fnbnd
operator|==
name|nil
operator|&&
name|a
operator|->
name|a
operator|.
name|clb
operator|!=
name|nil
condition|)
block|{
name|a
operator|=
name|a
operator|->
name|a
operator|.
name|clb
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
operator|==
name|ATOM
condition|)
name|a
operator|=
name|a
operator|->
name|a
operator|.
name|fnbnd
expr_stmt|;
block|}
else|else
name|a
operator|=
name|a
operator|->
name|a
operator|.
name|fnbnd
expr_stmt|;
break|break;
case|case
name|VALUE
case|:
name|a
operator|=
name|a
operator|->
name|l
expr_stmt|;
comment|/*  get value  */
break|break;
block|}
name|vtemp
operator|=
operator|(
name|CNIL
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* sentinel value for error test */
name|funcal
label|:
switch|switch
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|BCD
case|:
comment|/* function */
name|argptr
operator|=
name|actarg
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
comment|/* decide whether lambda, nlambda or 				       macro and push args onto argstack 				       accordingly.                */
if|if
condition|(
name|a
operator|->
name|bcd
operator|.
name|discipline
operator|==
name|nlambda
condition|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|argptr
expr_stmt|;
name|TNP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|bcd
operator|.
name|discipline
operator|==
name|macro
condition|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|actarg
expr_stmt|;
name|TNP
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
name|argptr
operator|!=
name|nil
condition|;
name|argptr
operator|=
name|argptr
operator|->
name|d
operator|.
name|cdr
control|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|eval
argument_list|(
name|argptr
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
name|TNP
expr_stmt|;
block|}
comment|/* go for it */
if|if
condition|(
name|TYPE
argument_list|(
name|a
operator|->
name|bcd
operator|.
name|discipline
argument_list|)
operator|==
name|STRNG
condition|)
name|vtemp
operator|=
name|Ifcall
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
name|vtemp
operator|=
operator|(
operator|*
operator|(
name|lispval
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|a
operator|->
name|bcd
operator|.
name|entry
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
break|break;
case|case
name|ARRAY
case|:
name|vtemp
operator|=
name|Iarray
argument_list|(
name|a
argument_list|,
name|actarg
operator|->
name|d
operator|.
name|cdr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTPR
case|:
comment|/* push args on argstack according to 				       type                */
name|argptr
operator|=
name|a
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
name|argptr
operator|==
name|lambda
condition|)
block|{
for|for
control|(
name|argptr
operator|=
name|actarg
operator|->
name|d
operator|.
name|cdr
init|;
name|argptr
operator|!=
name|nil
condition|;
name|argptr
operator|=
name|argptr
operator|->
name|d
operator|.
name|cdr
control|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|eval
argument_list|(
name|argptr
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
name|TNP
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argptr
operator|==
name|nlambda
condition|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|actarg
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|TNP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argptr
operator|==
name|macro
condition|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|actarg
expr_stmt|;
name|TNP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argptr
operator|==
name|lexpr
condition|)
block|{
for|for
control|(
name|argptr
operator|=
name|actarg
operator|->
name|d
operator|.
name|cdr
init|;
name|argptr
operator|!=
name|nil
condition|;
name|argptr
operator|=
name|argptr
operator|->
name|d
operator|.
name|cdr
control|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|eval
argument_list|(
name|argptr
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
name|TNP
expr_stmt|;
block|}
name|handy
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
operator|(
name|lispval
operator|)
name|lbot
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
operator|(
name|lispval
operator|)
name|np
expr_stmt|;
name|PUSHDOWN
argument_list|(
name|lexpr_atom
argument_list|,
name|handy
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|inewint
argument_list|(
operator|(
operator|(
name|lispval
operator|*
operator|)
name|handy
operator|->
name|d
operator|.
name|cdr
operator|)
operator|-
operator|(
name|lispval
operator|*
operator|)
name|handy
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
comment|/* something is wrong - this isn't a proper function */
name|argptr
operator|=
operator|(
name|a
operator|->
name|d
operator|.
name|cdr
operator|)
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|namptr
operator|=
name|bnp
expr_stmt|;
name|workp
operator|=
name|lbot
expr_stmt|;
if|if
condition|(
name|bnp
operator|+
operator|(
name|np
operator|-
name|lbot
operator|)
operator|>
name|bnplim
condition|)
name|binderr
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|argptr
operator|!=
operator|(
name|lispval
operator|)
name|nil
condition|;
name|workp
operator|++
operator|,
name|argptr
operator|=
name|argptr
operator|->
name|d
operator|.
name|cdr
control|)
comment|/* rebind formal names (shallow) */
block|{
if|if
condition|(
name|argptr
operator|->
name|d
operator|.
name|car
operator|==
name|nil
condition|)
continue|continue;
comment|/*if(((namptr)->atm = argptr->d.car)==nil)                         error("Attempt to lambda bind nil",FALSE);*/
name|namptr
operator|->
name|atm
operator|=
name|argptr
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
name|workp
operator|<
name|np
condition|)
block|{
name|namptr
operator|->
name|val
operator|=
name|namptr
operator|->
name|atm
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|namptr
operator|->
name|atm
operator|->
name|a
operator|.
name|clb
operator|=
name|workp
operator|->
name|val
expr_stmt|;
block|}
else|else
name|bnp
operator|=
name|namptr
operator|,
name|error
argument_list|(
literal|"Too few actual parameters"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|namptr
operator|++
expr_stmt|;
block|}
name|bnp
operator|=
name|namptr
expr_stmt|;
if|if
condition|(
name|workp
operator|<
name|np
condition|)
name|error
argument_list|(
literal|"Too many actual parameters"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* execute body, implied prog allowed */
for|for
control|(
name|handy
operator|=
name|a
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
control|)
block|{
name|vtemp
operator|=
name|eval
argument_list|(
name|handy
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vtemp
operator|!=
operator|(
name|CNIL
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* if we get here with a believable value, */
comment|/* we must have executed a function. */
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
comment|/* in case some clown trashed t */
name|tatom
operator|->
name|a
operator|.
name|clb
operator|=
operator|(
name|lispval
operator|)
name|tatom
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|d
operator|.
name|car
operator|==
name|macro
condition|)
name|vtemp
operator|=
name|eval
argument_list|(
name|vtemp
argument_list|)
expr_stmt|;
comment|/* It is of the most wonderful                         coincidence that the offset                        for car is the same as for                        discipline so we get bcd macros                        for free here ! */
if|if
condition|(
name|dopopframe
condition|)
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|vtemp
operator|)
return|;
block|}
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
name|lispval
operator|)
name|errorh
argument_list|(
name|Verundef
argument_list|,
literal|"eval: Undefined function "
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|actarg
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dopopframe
condition|)
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
comment|/* other data types are considered constants */
block|}
end_function

begin_comment
comment|/* popnames *************************************************************/
end_comment

begin_comment
comment|/* removes from the name stack all entries above the first argument.    */
end_comment

begin_comment
comment|/* routine should usually be used to clean up the name stack as it    */
end_comment

begin_comment
comment|/* knows about the special cases.  np is returned pointing to the    */
end_comment

begin_comment
comment|/* same place as the argument passed.                    */
end_comment

begin_function
name|lispval
name|popnames
parameter_list|(
name|llimit
parameter_list|)
specifier|register
name|struct
name|nament
modifier|*
name|llimit
decl_stmt|;
block|{
specifier|register
name|struct
name|nament
modifier|*
name|rnp
decl_stmt|;
for|for
control|(
name|rnp
operator|=
name|bnp
init|;
operator|--
name|rnp
operator|>=
name|llimit
condition|;
control|)
name|rnp
operator|->
name|atm
operator|->
name|a
operator|.
name|clb
operator|=
name|rnp
operator|->
name|val
expr_stmt|;
name|bnp
operator|=
name|llimit
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*   file: apply.c							*/
end_comment

begin_comment
comment|/*    Caveat -- Work in Progress -- not guaranteed! not tested!		*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/* apply  ***************************************************************/
end_comment

begin_function
name|lispval
name|Lapply
parameter_list|()
block|{
specifier|register
name|lispval
name|a
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|workp
decl_stmt|;
specifier|register
name|struct
name|nament
modifier|*
name|namptr
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|np
decl_stmt|;
name|lispval
name|vtemp
decl_stmt|;
name|struct
name|nament
modifier|*
name|oldbnp
init|=
name|bnp
decl_stmt|;
name|struct
name|argent
modifier|*
name|oldlbot
init|=
name|lbot
decl_stmt|;
comment|/* Bottom of my frame! */
name|a
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|argptr
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
if|if
condition|(
name|np
operator|-
name|lbot
operator|!=
literal|2
condition|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Apply: Wrong number of args."
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|999
argument_list|,
name|a
argument_list|,
name|argptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|argptr
argument_list|)
operator|!=
name|DTPR
operator|&&
name|argptr
operator|!=
name|nil
condition|)
name|argptr
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Apply: non-list of args"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|998
argument_list|,
name|argptr
argument_list|)
expr_stmt|;
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|a
expr_stmt|;
comment|/* push form on namestack */
name|TNP
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
comment|/* bottom of current frame */
for|for
control|(
name|EVER
control|)
block|{
if|if
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
operator|==
name|ATOM
condition|)
name|a
operator|=
name|a
operator|->
name|a
operator|.
name|fnbnd
expr_stmt|;
comment|/* get function definition (unless 					   calling form is itself a lambda- 					   expression) */
name|vtemp
operator|=
name|CNIL
expr_stmt|;
comment|/* sentinel value for error test */
switch|switch
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|BCD
case|:
comment|/* push arguments - value of a */
if|if
condition|(
name|a
operator|->
name|bcd
operator|.
name|discipline
operator|==
name|nlambda
operator|||
name|a
operator|->
name|bcd
operator|.
name|discipline
operator|==
name|macro
condition|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|argptr
expr_stmt|;
name|TNP
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
name|argptr
operator|!=
name|nil
condition|;
name|argptr
operator|=
name|argptr
operator|->
name|d
operator|.
name|cdr
control|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|argptr
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|TNP
expr_stmt|;
block|}
if|if
condition|(
name|TYPE
argument_list|(
name|a
operator|->
name|bcd
operator|.
name|discipline
argument_list|)
operator|==
name|STRNG
condition|)
name|vtemp
operator|=
name|Ifcall
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* foreign function */
else|else
name|vtemp
operator|=
operator|(
operator|*
operator|(
name|lispval
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|a
operator|->
name|bcd
operator|.
name|entry
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
comment|/* go for it */
break|break;
case|case
name|ARRAY
case|:
name|vtemp
operator|=
name|Iarray
argument_list|(
name|a
argument_list|,
name|argptr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTPR
case|:
if|if
condition|(
name|a
operator|->
name|d
operator|.
name|car
operator|==
name|nlambda
operator|||
name|a
operator|->
name|d
operator|.
name|car
operator|==
name|macro
condition|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|argptr
expr_stmt|;
name|TNP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|d
operator|.
name|car
operator|==
name|lambda
condition|)
for|for
control|(
init|;
name|argptr
operator|!=
name|nil
condition|;
name|argptr
operator|=
name|argptr
operator|->
name|d
operator|.
name|cdr
control|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|argptr
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|TNP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|d
operator|.
name|car
operator|==
name|lexpr
condition|)
block|{
for|for
control|(
init|;
name|argptr
operator|!=
name|nil
condition|;
name|argptr
operator|=
name|argptr
operator|->
name|d
operator|.
name|cdr
control|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|argptr
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|TNP
expr_stmt|;
block|}
name|handy
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
operator|(
name|lispval
operator|)
name|lbot
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
operator|(
name|lispval
operator|)
name|np
expr_stmt|;
name|PUSHDOWN
argument_list|(
name|lexpr_atom
argument_list|,
name|handy
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|inewint
argument_list|(
operator|(
operator|(
name|lispval
operator|*
operator|)
name|handy
operator|->
name|d
operator|.
name|cdr
operator|)
operator|-
operator|(
name|lispval
operator|*
operator|)
name|handy
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
comment|/* something is wrong - this isn't a proper function */
name|rebind
argument_list|(
name|a
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
argument_list|,
name|lbot
argument_list|)
expr_stmt|;
name|np
operator|=
name|lbot
expr_stmt|;
for|for
control|(
name|handy
operator|=
name|a
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
control|)
block|{
name|vtemp
operator|=
name|eval
argument_list|(
name|handy
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
comment|/* go for it */
block|}
block|}
if|if
condition|(
name|vtemp
operator|!=
name|CNIL
condition|)
comment|/* if we get here with a believable value, */
comment|/* we must have executed a function. */
block|{
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
comment|/* in case some clown trashed t */
name|tatom
operator|->
name|a
operator|.
name|clb
operator|=
operator|(
name|lispval
operator|)
name|tatom
expr_stmt|;
return|return
operator|(
name|vtemp
operator|)
return|;
block|}
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
name|lispval
operator|)
name|errorh
argument_list|(
name|Verundef
argument_list|,
literal|"apply: Undefined Function "
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|oldlbot
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
comment|/*NOT REACHED*/
block|}
end_function

begin_comment
comment|/*  * Rebind -- rebind formal names  */
end_comment

begin_expr_stmt
name|rebind
argument_list|(
name|argptr
argument_list|,
name|workp
argument_list|)
specifier|register
name|lispval
name|argptr
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* argptr points to list of atoms */
end_comment

begin_decl_stmt
specifier|register
name|struct
name|argent
modifier|*
name|workp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* workp points to position on stack                        where evaluated args begin */
end_comment

begin_block
block|{
specifier|register
name|lispval
name|vtemp
decl_stmt|;
specifier|register
name|struct
name|nament
modifier|*
name|namptr
init|=
name|bnp
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|np
decl_stmt|;
for|for
control|(
init|;
name|argptr
operator|!=
operator|(
name|lispval
operator|)
name|nil
condition|;
name|workp
operator|++
operator|,
name|argptr
operator|=
name|argptr
operator|->
name|d
operator|.
name|cdr
control|)
comment|/* rebind formal names (shallow) */
block|{
if|if
condition|(
name|argptr
operator|->
name|d
operator|.
name|car
operator|==
name|nil
condition|)
continue|continue;
name|namptr
operator|->
name|atm
operator|=
name|argptr
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
name|workp
operator|<
name|np
condition|)
block|{
name|namptr
operator|->
name|val
operator|=
name|namptr
operator|->
name|atm
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|namptr
operator|->
name|atm
operator|->
name|a
operator|.
name|clb
operator|=
name|workp
operator|->
name|val
expr_stmt|;
block|}
else|else
name|bnp
operator|=
name|namptr
operator|,
name|error
argument_list|(
literal|"Too few actual parameters"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|namptr
operator|++
expr_stmt|;
if|if
condition|(
name|namptr
operator|>
name|bnplim
condition|)
name|binderr
argument_list|()
expr_stmt|;
block|}
name|bnp
operator|=
name|namptr
expr_stmt|;
if|if
condition|(
name|workp
operator|<
name|np
condition|)
name|error
argument_list|(
literal|"Too many actual parameters"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* the argument to Lfuncal is optional, if it is given  then it is   * the name of the function to call and lbot points to the first arg.  * if it is not given, then lbot points to the function to call  */
end_comment

begin_function
name|lispval
name|Lfuncal
parameter_list|(
name|fcn
parameter_list|)
name|lispval
name|fcn
decl_stmt|;
block|{
specifier|register
name|lispval
name|a
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|struct
name|nament
modifier|*
modifier|*
name|namptr
decl_stmt|;
name|struct
name|nament
modifier|*
name|oldbnp
init|=
name|bnp
decl_stmt|;
comment|/* MUST be first local for evalframe */
name|lispval
name|fcncalled
decl_stmt|;
name|lispval
name|Ifcall
argument_list|()
decl_stmt|,
name|Llist
argument_list|()
decl_stmt|,
name|Iarray
argument_list|()
decl_stmt|;
name|lispval
name|vtemp
decl_stmt|;
name|int
name|typ
decl_stmt|,
name|dopopframe
init|=
name|FALSE
decl_stmt|;
specifier|extern
name|lispval
name|end
index|[]
decl_stmt|;
name|Savestack
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
argument_list|()
operator|==
literal|1
condition|)
comment|/* function I am evaling.    */
name|a
operator|=
name|fcncalled
operator|=
name|fcn
expr_stmt|;
else|else
block|{
name|a
operator|=
name|fcncalled
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|lbot
operator|++
expr_stmt|;
block|}
comment|/*debugging      if (rsetsw&& rsetatom->a.clb != nil) { 	printf("funcall:"); 	printr(a,stdout); 	printf("\nrsetsw: %d evalhsw: %d\n", rsetsw, evalhsw); 	printf("*rset: "); 	printr(rsetatom->a.clb,stdout); 	printf(" funhook: "); 	printr(funhatom->a.clb,stdout); 	printf(" funhook call flag^G: %d\n",funhcallsw); 	fflush(stdout);      };       */
comment|/* check if exception pending */
if|if
condition|(
name|sigintcnt
operator|>
literal|0
condition|)
name|sigcall
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsetsw
operator|&&
name|rsetatom
operator|->
name|a
operator|.
name|clb
operator|!=
name|nil
condition|)
comment|/* if (*rset t) has been done */
block|{
if|if
condition|(
name|evalhsw
operator|!=
name|nil
operator|&&
name|funhatom
operator|->
name|a
operator|.
name|clb
operator|!=
name|nil
condition|)
block|{
comment|/*if (sstatus evalhook t) 						    and evalhook non-nil */
if|if
condition|(
name|funhcallsw
condition|)
comment|/*if this is a call to evalhook, don't call evalhook 			  function, but clear evalhcallsw , so recursive  			  calls to eval cause evalhook function to fire. */
name|funhcallsw
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
comment|/* setup equivalent of (funcall funcallhook<args to eval>) */
name|protect
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|=
name|fcncalled
operator|=
name|funhatom
operator|->
name|a
operator|.
name|clb
expr_stmt|;
comment|/* new function to funcall */
name|PUSHDOWN
argument_list|(
name|funhatom
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* lambda-bind  						 * funcallhook to nil 						 */
name|PUSHDOWN
argument_list|(
name|evalhatom
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* printf(" now will funcall "); 		printr(a,stdout); 		putchar('\n'); 		fflush(stdout); */
block|}
empty_stmt|;
block|}
name|errp
operator|=
name|Pushframe
argument_list|(
name|F_FUNCALL
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|dopopframe
operator|=
name|TRUE
expr_stmt|;
comment|/* remember to pop later */
if|if
condition|(
name|retval
operator|==
name|C_FRETURN
condition|)
block|{
name|Restorestack
argument_list|()
expr_stmt|;
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
return|return
operator|(
name|lispretval
operator|)
return|;
block|}
block|}
empty_stmt|;
for|for
control|(
name|EVER
control|)
block|{
name|top
label|:
name|typ
operator|=
name|TYPE
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|typ
operator|==
name|ATOM
condition|)
name|a
operator|=
name|a
operator|->
name|a
operator|.
name|fnbnd
operator|,
name|typ
operator|=
name|TYPE
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* get function defn (unless calling form */
comment|/* is itself a lambda-expr) */
name|vtemp
operator|=
name|CNIL
operator|-
literal|1
expr_stmt|;
comment|/* sentinel value for error test */
switch|switch
condition|(
name|typ
condition|)
block|{
case|case
name|ARRAY
case|:
name|protect
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* stack array descriptor on top */
name|a
operator|=
name|a
operator|->
name|ar
operator|.
name|accfun
expr_stmt|;
comment|/* now funcall access function */
goto|goto
name|top
goto|;
case|case
name|BCD
case|:
if|if
condition|(
name|a
operator|->
name|bcd
operator|.
name|discipline
operator|==
name|nlambda
condition|)
block|{
if|if
condition|(
name|np
operator|==
name|lbot
condition|)
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
comment|/* default is nil */
while|while
condition|(
name|np
operator|-
name|lbot
operator|!=
literal|1
operator|||
operator|(
name|lbot
operator|->
name|val
operator|!=
name|nil
operator|&&
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|DTPR
operator|)
condition|)
block|{
name|lbot
operator|->
name|val
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Bad funcall arg(s) to fexpr."
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
name|np
operator|=
name|lbot
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* go for it */
if|if
condition|(
name|TYPE
argument_list|(
name|a
operator|->
name|bcd
operator|.
name|discipline
argument_list|)
operator|==
name|STRNG
condition|)
name|vtemp
operator|=
name|Ifcall
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
name|vtemp
operator|=
operator|(
operator|*
operator|(
name|lispval
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|a
operator|->
name|bcd
operator|.
name|entry
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|bcd
operator|.
name|discipline
operator|==
name|macro
condition|)
name|vtemp
operator|=
name|eval
argument_list|(
name|vtemp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTPR
case|:
if|if
condition|(
name|a
operator|->
name|d
operator|.
name|car
operator|==
name|lambda
condition|)
block|{
empty_stmt|;
comment|/* VOID */
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|d
operator|.
name|car
operator|==
name|nlambda
operator|||
name|a
operator|->
name|d
operator|.
name|car
operator|==
name|macro
condition|)
block|{
if|if
condition|(
name|np
operator|==
name|lbot
condition|)
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
comment|/* default */
while|while
condition|(
name|np
operator|-
name|lbot
operator|!=
literal|1
operator|||
operator|(
name|lbot
operator|->
name|val
operator|!=
name|nil
operator|&&
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|DTPR
operator|)
condition|)
block|{
name|lbot
operator|->
name|val
operator|=
name|error
argument_list|(
literal|"Bad funcall arg(s) to fexpr."
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|np
operator|=
name|lbot
operator|+
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|d
operator|.
name|car
operator|==
name|lexpr
condition|)
block|{
name|handy
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
operator|(
name|lispval
operator|)
name|lbot
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
operator|(
name|lispval
operator|)
name|np
expr_stmt|;
name|PUSHDOWN
argument_list|(
name|lexpr_atom
argument_list|,
name|handy
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|inewint
argument_list|(
operator|(
operator|(
name|lispval
operator|*
operator|)
name|handy
operator|->
name|d
operator|.
name|cdr
operator|)
operator|-
operator|(
name|lispval
operator|*
operator|)
name|handy
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
comment|/* something is wrong - this isn't a proper function */
name|rebind
argument_list|(
name|a
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
argument_list|,
name|lbot
argument_list|)
expr_stmt|;
name|np
operator|=
name|lbot
expr_stmt|;
for|for
control|(
name|handy
operator|=
name|a
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
control|)
block|{
name|vtemp
operator|=
name|eval
argument_list|(
name|handy
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
comment|/* go for it */
block|}
if|if
condition|(
name|a
operator|->
name|d
operator|.
name|car
operator|==
name|macro
condition|)
name|vtemp
operator|=
name|eval
argument_list|(
name|vtemp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vtemp
operator|!=
name|CNIL
operator|-
literal|1
condition|)
comment|/* if we get here with a believable value, */
comment|/* we must have executed a function. */
block|{
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
comment|/* in case some clown trashed t */
name|tatom
operator|->
name|a
operator|.
name|clb
operator|=
operator|(
name|lispval
operator|)
name|tatom
expr_stmt|;
if|if
condition|(
name|dopopframe
condition|)
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
return|return
operator|(
name|vtemp
operator|)
return|;
block|}
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
name|a
operator|=
name|fcncalled
operator|=
operator|(
name|lispval
operator|)
name|errorh
argument_list|(
name|Verundef
argument_list|,
literal|"funcall: Bad function"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|fcncalled
argument_list|)
expr_stmt|;
block|}
comment|/*NOT REACHED*/
block|}
end_function

begin_comment
comment|/* The following must be the next "function" after Lfuncal, for the sake of Levalf.  */
end_comment

begin_macro
name|fchack
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_undef
undef|#
directive|undef
name|protect
end_undef

begin_comment
comment|/* protect **************************************************************/
end_comment

begin_comment
comment|/* pushes the first argument onto namestack, thereby protecting from gc */
end_comment

begin_function
name|lispval
name|protect
parameter_list|(
name|a
parameter_list|)
name|lispval
name|a
decl_stmt|;
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|np
operator|>=
name|nplim
condition|)
name|namerr
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* unprot ****************************************************************/
end_comment

begin_comment
comment|/* returns the top thing on the name stack.  Underflow had better not    */
end_comment

begin_comment
comment|/* occur.                                */
end_comment

begin_function
name|lispval
name|unprot
parameter_list|()
block|{
return|return
operator|(
operator|(
operator|--
name|np
operator|)
operator|->
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|linterp
parameter_list|()
block|{
name|error
argument_list|(
literal|"BYTE INTERPRETER CALLED ERRONEOUSLY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undeff - called from qfuncl when it detects a call to a undefined     function from compiled code, we print out a message and     dont allow continuation */
end_comment

begin_function
name|lispval
name|Undeff
parameter_list|(
name|atmn
parameter_list|)
name|lispval
name|atmn
decl_stmt|;
block|{
return|return
operator|(
name|errorh
argument_list|(
name|Verundef
argument_list|,
literal|"Undefined function called from compiled code "
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|atmn
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|bindfix
argument_list|(
argument|firstarg
argument_list|)
end_macro

begin_decl_stmt
name|lispval
name|firstarg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|lispval
modifier|*
name|argp
init|=
operator|&
name|firstarg
decl_stmt|;
specifier|register
name|struct
name|nament
modifier|*
name|mybnp
init|=
name|bnp
decl_stmt|;
while|while
condition|(
operator|*
name|argp
operator|!=
name|nil
condition|)
block|{
name|mybnp
operator|->
name|atm
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
name|mybnp
operator|->
name|val
operator|=
name|mybnp
operator|->
name|atm
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|mybnp
operator|->
name|atm
operator|->
name|a
operator|.
name|clb
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
name|bnp
operator|=
name|mybnp
operator|++
expr_stmt|;
block|}
block|}
end_block

end_unit

