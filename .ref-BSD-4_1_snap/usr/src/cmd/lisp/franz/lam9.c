begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_comment
comment|/* /*			Program name	:  Init.c /*			Anthor		:  Morris Djavaheri /*			Date		:  April 8,82 /*			Version		:  1.2c /* /* These routines writen in C will allow use of the termcap file /* by any lisp program. They are very basic routines which initialize /* termcap and allow the lisp to execute any of the termcap functions. /* 									*/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*add definations for I/O and bandrate */
end_comment

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_undef
undef|#
directive|undef
name|putchar
end_undef

begin_function_decl
name|int
name|putchar
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* functions used from the termlib */
end_comment

begin_function_decl
name|int
name|tgetflag
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|tgoto
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|bpbuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|tstrbuf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|BC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* /*	This routine will initialize the termcap for the lisp programs. /*	If the termcap file is not found, or terminal type is undefined, /*	it will print out an error mesg.				*/
end_comment

begin_function
name|lispval
name|Ltci
parameter_list|()
block|{
name|char
modifier|*
name|bp
init|=
name|bpbuf
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pc
decl_stmt|;
name|int
name|found
decl_stmt|;
name|struct
name|sgttyb
name|tty
decl_stmt|;
name|found
operator|=
name|tgetent
argument_list|(
name|bpbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* open ther termcap file */
switch|switch
condition|(
name|found
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|printf
argument_list|(
literal|"\nError Termcap File not found \n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"\nError No Termcap Entry for this terminal \n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
block|{
comment|/* everything was ok	*/
name|gtty
argument_list|(
literal|1
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
name|ospeed
operator|=
name|tty
operator|.
name|sg_ospeed
expr_stmt|;
block|}
break|break;
block|}
name|cp
operator|=
name|tstrbuf
expr_stmt|;
name|BC
operator|=
name|tgetstr
argument_list|(
literal|"bc"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|UP
operator|=
name|tgetstr
argument_list|(
literal|"up"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|pc
operator|=
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
condition|)
name|PC
operator|=
operator|*
name|pc
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This routine will execute any of the termcap functions used by the lisp /* program. If the feature is not include in the terminal defined it will /* ignore the call. /*		option	: feature to execute /*		line	: line if is nessery /*		colum	: colum if is nessaery /*									*/
end_comment

begin_function
name|lispval
name|Ltcx
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
name|char
modifier|*
name|option
decl_stmt|;
name|int
name|line
decl_stmt|,
name|column
decl_stmt|;
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|1
case|:
name|line
operator|=
name|column
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|error
argument_list|(
literal|"Wrong number of Arguments to Termcapexecute"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|line
operator|=
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|column
operator|=
name|mylbot
index|[
literal|2
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
block|}
return|return
operator|(
name|inewint
argument_list|(
name|show
argument_list|(
name|mylbot
operator|->
name|val
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|column
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|show
argument_list|(
argument|option
argument_list|,
argument|line
argument_list|,
argument|colum
argument_list|)
name|char
operator|*
name|option
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
modifier|*
name|line
decl_stmt|,
modifier|*
name|colum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|found
decl_stmt|;
name|char
name|clbuf
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|clbp
init|=
name|clbuf
decl_stmt|;
name|char
modifier|*
name|clear
decl_stmt|;
name|char
modifier|*
name|cm
decl_stmt|;
comment|/* the tegetflag doesnot work ? */
name|clear
operator|=
name|tgetstr
argument_list|(
name|option
argument_list|,
operator|&
name|clbp
argument_list|)
expr_stmt|;
comment|/*printf("option = %d , %s \n",clear,option);*/
if|if
condition|(
operator|!
name|clear
condition|)
block|{
name|found
operator|=
name|tgetnum
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
operator|(
name|found
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|PC
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"cm"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* if cursor motion, do it */
name|clear
operator|=
name|tgoto
argument_list|(
name|clear
argument_list|,
operator|*
name|colum
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|clear
operator|==
literal|'O'
condition|)
name|clear
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|clear
condition|)
comment|/* execute the feature */
name|tputs
argument_list|(
name|clear
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

