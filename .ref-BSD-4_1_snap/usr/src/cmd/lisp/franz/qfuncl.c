begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_expr_stmt
operator|.
name|asciz
literal|"@(#)qfuncl.c	35.4	5/26/82"
comment|/*   * lisp to C or lisp interface code  * This is written in assembler but must be passed through the C preprocessor  * before being assembled.  */
comment|/* we need the type numbers here, and it would be nice if we could include  * global.h but we can't due to the other C code in that file,  * we should seperate type numbers and other stuff, but for now:  */
define|#
directive|define
name|UNBO
value|-1
define|#
directive|define
name|STRNG
value|0
define|#
directive|define
name|ATOM
value|1
define|#
directive|define
name|INT
value|2
define|#
directive|define
name|DTPR
value|3
define|#
directive|define
name|DOUB
value|4
define|#
directive|define
name|BCD
value|5
define|#
directive|define
name|PORT
value|6
define|#
directive|define
name|ARRAY
value|7
define|#
directive|define
name|OTHER
value|8
define|#
directive|define
name|SDOT
value|9
define|#
directive|define
name|VALUE
value|10
comment|/* important offsets within data types for atoms */
define|#
directive|define
name|Atomfnbnd
value|8
comment|/*  for arrays */
define|#
directive|define
name|Arrayaccfun
value|0
ifdef|#
directive|ifdef
name|PROF
operator|.
name|set
name|indx
operator|,
literal|0
define|#
directive|define
name|Profile
define|\
value|movab	prbuf+indx,r0 \ 	.set 	indx,indx+4 \ 	jsb 	mcount
else|#
directive|else
define|#
directive|define
name|Profile
endif|#
directive|endif
comment|/*  * non existant function, call c function to take care of it,  * we could process it here but wish to minimize assembly language  * code.  * we should never return from this call  * the addr of the atom is already stacked  */
name|nonexf
operator|:
name|calls
name|$1
operator|,
name|_Undeff
operator|#
name|call
name|handler
name|clrl
name|r0
operator|#
end_expr_stmt

begin_return
return|return
name|nil
name|to
name|compiled
name|code
name|rsb
operator|#
end_return

begin_if
if|if ever should return here
comment|/*   transfer  table linkage routine  */
if|.globl	_qlinker _qlinker: 	.word 	0xfc0			# save all possible registers 	Profile 	tstl	_exception	        # any pending exceptions 	jeql	noexc 	tstl	_sigintcnt		# is it because of SIGINT 	jeql	noexc			# if not
operator|,
name|just
name|leave
name|pushl
name|$2
operator|#
else|else
name|push
name|SIGINT
name|calls
name|$1
decl_stmt|,
name|_sigcall
name|noexc
range|:
name|movl
literal|16
operator|(
name|fp
operator|)
decl_stmt|,
name|r0
decl|#
name|get
decl|return
name|pc
name|addl2
decl|-4
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r0
decl|#
name|get
name|pointer
name|to
name|table
name|movl
decl|4
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r1
decl|#
name|get
name|atom
name|pointer
name|retry
range|:
operator|#
name|come
name|here
name|after
name|undef
name|func
name|error
name|movl
name|Atomfnbnd
argument_list|(
name|r1
argument_list|)
decl_stmt|,
name|r2
decl|#
name|get
name|function
name|binding
name|jleq
name|nonex
decl|# if
name|none
decl_stmt|,
name|leave
name|tstl
name|_stattab
decl|+2
modifier|*
decl|4		#
name|see
decl|if
name|linking
name|possible
argument_list|(
name|Strans
argument_list|)
name|jeql
name|nolink
decl|#
name|no
decl_stmt|,
name|it
name|isn
decl|'t 	ashl	$-9,r2,r3		# check type of function 	cmpb	$/**/BCD,_typetable+1[r3]	 	jeql	linkin			# bcd, link it in! 	cmpb	$/**/ARRAY,_typetable+1[r3] # how about array? 	jeql	doarray			# yep   nolink: 	pushl	r1			# non, bcd, call interpreter 	calls	$1,_Lfuncal 	ret  /*  * handle arrays by pushing the array descriptor on the table and checking  * for a bcd array handler  */ doarray: 	ashl	$-9,Arrayaccfun(r2),r3	# get access function addr shifted 	cmpb	$/**/BCD,_typetable+1[r3]	# bcd?? 	jneq	nolink			# no, let funcal handle it 	movl	r2,(r6)+		# store array header on stack 	movl	*(r2),r2	# get in func addr 	jmp	2(r2)			# jump in beyond calls header 	 	 linkin:	 	ashl	$-9,4(r2),r3		# check type of function discipline 	cmpb	$0,_typetable+1[r3]	# is it string? 	jeql	nolink			# yes, it is a c call, so dont link in 	movl	(r2),r2			# get function addr 	movl	r2,(r0)			# put fcn addr in table 	jmp	2(r2)			# enter fcn after mask  nonex:	pushl	r0			# preserve table address 	pushl	r1			# non existant fcn 	calls	$1,_Undeff		# call processor 	movl	r0,r1			# back in r1 	movl	(sp)+,r0		# restore table address 	jbr	retry			# for the retry.   	.globl	__erthrow		# errmessage for uncaught throws __erthrow:  	.byte	'
name|U
decl_stmt|,'n,'
name|c
decl_stmt|,'a,'
name|u
decl_stmt|,'g,'
name|h
decl_stmt|,'t,' ,'t,'
name|h
decl_stmt|,'r,'
name|o
decl_stmt|,'w 	.byte	' ,'f,'
name|r
decl_stmt|,'o,'
name|m
decl_stmt|,' ,'
name|c
decl_stmt|,'o,'
name|m
decl_stmt|,'p,'
name|i
decl_stmt|,'l,'
name|e
decl_stmt|,'d 	.byte	' ,'c,'
name|o
decl_stmt|,'d,'
name|e
decl_stmt|,0  	.
name|globl
name|_tynames
name|_tynames
range|:
operator|.
name|long
literal|0
operator|#
name|nothing
name|here
operator|.
name|long
name|_lispsys
operator|+
literal|20
operator|*
literal|4
operator|#
name|str_name
operator|.
name|long
name|_lispsys
operator|+
literal|21
operator|*
literal|4
operator|#
name|atom_name
operator|.
name|long
name|_lispsys
operator|+
literal|19
operator|*
literal|4
operator|#
name|int_name
operator|.
name|long
name|_lispsys
operator|+
literal|23
operator|*
literal|4
operator|#
name|dtpr_name
operator|.
name|long
name|_lispsys
operator|+
literal|22
operator|*
literal|4
operator|#
name|doub_name
operator|.
name|long
name|_lispsys
operator|+
literal|58
operator|*
literal|4
operator|#
name|funct_name
operator|.
name|long
name|_lispsys
operator|+
literal|103
operator|*
literal|4
operator|#
name|port_name
operator|.
name|long
name|_lispsys
operator|+
literal|47
operator|*
literal|4
operator|#
name|array_name
operator|.
name|long
literal|0
operator|#
name|nothing
name|here
operator|.
name|long
name|_lispsys
operator|+
literal|50
operator|*
literal|4
operator|#
name|sdot_name
operator|.
name|long
name|_lispsys
operator|+
literal|53
operator|*
literal|4
operator|#
name|val_nam
comment|/*	Quickly allocate small fixnums  */
operator|.
name|globl
name|_qnewint
name|_qnewint
operator|:
name|Profile
name|cmpl
name|r5
decl_stmt|,
name|$1024
name|jgeq
name|alloc
name|cmpl
name|r5
decl_stmt|,
name|$
decl|-1024
name|jlss
name|alloc
name|moval
name|Fixzero
index|[
name|r5
index|]
decl_stmt|,
name|r0
name|rsb
name|alloc
range|:
name|movl
name|_int_str
decl_stmt|,
name|r0
decl|#
name|move
name|next
name|cell
name|addr
name|to
name|r0
name|jlss
name|callnewi
decl|# if
name|no
name|space
decl_stmt|,
name|allocate
name|incl
modifier|*
name|_lispsys
decl|+24
modifier|*
decl|4	#
name|inc
name|count
name|of
name|ints
name|movl
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|_int_str
decl|#
name|advance
name|free
name|list
name|movl
name|r5
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|put
name|baby
name|to
name|bed
operator|.
name|rsb
name|callnewi
range|:
name|pushl
name|r5
name|calls
name|$0
decl_stmt|,
name|_newint
name|movl
argument_list|(
name|sp
argument_list|)
decl|+
decl_stmt|,
argument_list|(
name|r0
argument_list|)
name|rsb
comment|/*  _qoneplus adds one to the boxed fixnum in r0  * and returns a boxed fixnum.  */
operator|.
name|globl
name|_qoneplus
name|_qoneplus
range|:
name|Profile
name|addl3
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|$1
decl_stmt|,
name|r5
name|jbr
name|_qnewint
comment|/* _qoneminus  subtracts one from the boxes fixnum in r0 and returns a  * boxed fixnum  */
operator|.
name|globl
name|_qoneminus
name|_qoneminus
range|:
name|Profile
name|subl3
name|$1
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r5
name|jbr
name|_qnewint
comment|/*  *	_qnewdoub quick allocation of a initialized double (float) cell.  *	This entry point is required by the compiler for symmetry reasons.  *	Passed to _qnewdoub in r4,r5 is a double precision floating point  *	number.  This routine allocates a new cell, initializes it with  *	the given value and then returns the cell.  */
operator|.
name|globl
name|_qnewdoub
name|_qnewdoub
range|:
name|Profile
name|movl
name|_doub_str
decl_stmt|,
name|r0
decl|#
name|move
name|next
name|cell
name|addr
name|to
name|r0
name|jlss
name|callnewd
decl|# if
name|no
name|space
decl_stmt|,
name|allocate
name|incl
modifier|*
name|_lispsys
decl|+30
modifier|*
decl|4	#
name|inc
name|count
name|of
name|doubs
name|movl
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|_doub_str
decl|#
name|advance
name|free
name|list
name|movq
name|r4
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|put
name|baby
name|to
name|bed
operator|.
name|rsb
name|callnewd
range|:
name|movq
name|r4
decl_stmt|,-
argument_list|(
name|sp
argument_list|)
decl_stmt|#
name|stack
name|initial
name|value
name|calls
name|$0
decl_stmt|,
name|_newdoub
name|movq
argument_list|(
name|sp
argument_list|)
decl|+
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|restore
name|initial
name|value
name|rsb
operator|.
name|globl
name|_qcons
comment|/*  * quick cons call, the car and cdr are stacked on the namestack  * and this function is jsb'ed to.  */
name|_qcons
range|:
name|Profile
name|movl
name|_dtpr_str
decl_stmt|,
name|r0
decl|#
name|move
name|next
name|cell
name|addr
name|to
name|r0
name|jlss
name|getnew
decl|# if
name|ran
name|out
name|of
name|space
name|jump
name|incl
modifier|*
name|_lispsys
decl|+28
modifier|*
decl|4	#
name|inc
name|count
name|of
name|dtprs
name|movl
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|_dtpr_str
decl|#
name|advance
name|free
name|list
name|storit
range|:
name|movl
operator|-
operator|(
name|r6
operator|)
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|store
name|in
name|cdr
name|movl
decl|-
argument_list|(
name|r6
argument_list|)
decl_stmt|,4
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|store
name|in
name|car
name|rsb
name|getnew
range|:
name|calls
name|$0
decl_stmt|,
name|_newdot
decl|#
name|must
name|gc
name|to
name|get
name|one
name|jbr
name|storit
decl|#
name|now
name|initialize
name|it
operator|.
comment|/*  * Fast equivalent of newdot, entered by jsb  */
decl|.
name|globl
name|_qnewdot
name|_qnewdot
range|:
name|Profile
name|movl
name|_dtpr_str
decl_stmt|,
name|r0
decl|#
name|mov
name|next
name|cell
name|addr
name|t0
name|r0
name|jlss
name|mustallo
decl|# if
name|ran
name|out
name|of
name|space
name|incl
modifier|*
name|_lispsys
decl|+28
modifier|*
decl|4	#
name|inc
name|count
name|of
name|dtprs
name|movl
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|_dtpr_str
decl|#
name|advance
name|free
name|list
name|clrq
argument_list|(
name|r0
argument_list|)
name|rsb
name|mustallo
range|:
name|calls
name|$0
decl_stmt|,
name|_newdot
name|rsb
comment|/*  prunel  - return a list of dtpr cells to the free list  * this is called by the pruneb after it has discarded the top bignum   * the dtpr cells are linked through their cars not their cdrs.  * this returns with an rsb  *  * method of operation: the dtpr list we get is linked by car's so we  * go through the list and link it by cdr's, then have the last dtpr  * point to the free list and then make the free list begin at the  * first dtpr.  */
name|qprunel
range|:
name|movl
name|r0
decl_stmt|,
name|r2
decl|#
name|remember
name|first
name|dtpr
name|location
name|rep
range|:
name|decl
operator|*
name|_lispsys
operator|+
literal|28
operator|*
literal|4
operator|#
name|decrement
name|used
name|dtpr
name|count
name|movl
literal|4
operator|(
name|r0
operator|)
decl_stmt|,
name|r1
decl|#
name|put
name|link
name|value
name|into
name|r1
name|jeql
name|endoflist
decl|# if
name|nil
decl_stmt|,
name|then
name|end
name|of
name|list
name|movl
name|r1
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|replace
name|cdr
name|with
name|save
name|value
name|as
name|car
name|movl
name|r1
decl_stmt|,
name|r0
decl|#
name|advance
name|to
name|next
name|dtpr
name|jbr
name|rep
decl|#
name|and
name|loop
name|around
name|endoflist
range|:
name|movl
name|_dtpr_str
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|make
name|last
name|one
name|point
name|to
name|free
name|list
name|movl
name|r2
decl_stmt|,
name|_dtpr_str
decl|#
name|and
name|free
name|list
name|begin
name|at
name|first
name|one
name|rsb
comment|/*  * qpruneb - called by the arithmetic routines to free an sdot and the dtprs  * which hang on it.  * called by  *	pushl	sdotaddr  *	jsb	_qpruneb  */
operator|.
name|globl
name|_qpruneb
name|_qpruneb
range|:
name|Profile
name|movl
literal|4
operator|(
name|sp
operator|)
decl_stmt|,
name|r0
decl|#
name|get
name|address
name|decl
modifier|*
name|_lispsys
decl|+48
modifier|*
decl|4		#
name|decr
name|count
name|of
name|used
name|sdots
name|movl
name|_sdot_str
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|have
name|new
name|sdot
name|point
name|to
name|free
name|list
name|movl
name|r0
decl_stmt|,
name|_sdot_str
decl|#
name|start
name|free
name|list
name|at
name|new
name|sdot
name|movl
decl|4
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r0
decl|#
name|get
name|address
name|of
name|first
name|dtpr
name|jneq
name|qprunel
decl|# if
name|exists
decl_stmt|,
name|prune
name|it
name|rsb
decl|# else return.
comment|/*  * _qprunei 	   *	called by the arithmetic routines to free a fixnum cell  * calling sequence  *	pushl	fixnumaddr  *	jsb	_qprunei  */
decl|.
name|globl
name|_qprunei
name|_qprunei
range|:
name|Profile
name|movl
literal|4
operator|(
name|sp
operator|)
decl_stmt|,
name|r0
decl|#
name|get
name|address
name|of
name|fixnum
name|cmpl
name|r0
decl_stmt|,
name|$_gstart
decl|#
name|is
name|it
name|a
name|small
name|fixnum
name|jlss
name|skipit
decl|# if
name|so
decl_stmt|,
name|leave
name|decl
modifier|*
name|_lispsys
decl|+24
modifier|*
decl|4		#
name|decr
name|count
name|of
name|used
name|ints
name|movl
name|_int_str
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|link
name|the
name|fixnum
name|into
name|the
name|free
name|list
name|movl
name|r0
decl_stmt|,
name|_int_str
name|skipit
range|:
name|rsb
operator|.
name|globl
name|_qpopnames
name|_qpopnames
operator|:
operator|#
name|equivalent
name|of
name|C
operator|-
name|code
name|popnames
decl_stmt|,
name|entered
name|by
name|jsb
operator|.
name|movl
argument_list|(
name|sp
argument_list|)
decl|+
decl_stmt|,
name|r0
decl|# return
name|address
name|movl
argument_list|(
name|sp
argument_list|)
decl|+
decl_stmt|,
name|r1
decl|#
name|Lower
name|limit
name|movl
name|_bnp
decl_stmt|,
name|r2
decl|#
name|pointer
name|to
name|bind
name|stack
name|entry
name|qploop
range|:
name|subl2
name|$8
decl_stmt|,
name|r2
decl|# for
argument_list|(;
end_if

begin_expr_stmt
operator|(
operator|--
name|r2
operator|)
operator|>
name|r1
expr_stmt|;
end_expr_stmt

begin_block
unit|)
block|{
name|cmpl
name|r2
decl_stmt|,
name|r1
decl|#
name|test
decl|for
name|done
name|jlss
name|qpdone
name|movl
argument_list|(
name|r2
argument_list|)
decl_stmt|,
modifier|*
decl_stmt|4
argument_list|(
name|r2
argument_list|)
decl_stmt|#
name|r2
operator|->
name|atm
operator|->
name|a
operator|.
name|clb
init|=
name|r2
operator|->
name|val
decl_stmt|;
name|brb
name|qploop
operator|#
block|}
end_block

begin_label
name|qpdone
label|:
end_label

begin_decl_stmt
name|movl
name|r1
decl_stmt|,
name|_bnp
decl|#
name|restore
name|bnp
name|jmp
argument_list|(
name|r0
argument_list|)
decl|# return
comment|/*  * _qget : fast get subroutine  *  (get 'atom 'ind)  * called with -8(r6) equal to the atom  *	      -4(r6) equal to the indicator  * no assumption is made about r7  * unfortunately, the atom may not in fact be an atom, it may  * be a list or nil, which are special cases.  * For nil, we grab the nil property list (stored in a special place)  * and for lists we punt and call the C routine since it is  most likely  * and error and we havent put in error checks yet.  */
decl|.
name|globl
name|_qget
name|_qget
range|:
name|Profile
name|movl
operator|-
literal|4
operator|(
name|r6
operator|)
decl_stmt|,
name|r1
decl|#
name|put
name|indicator
name|in
name|r1
name|movl
decl|-8
argument_list|(
name|r6
argument_list|)
decl_stmt|,
name|r0
decl|#
name|and
name|atom
name|into
name|r0
name|jeql
name|nilpli
decl|#
name|jump
decl|if
name|atom
name|is
name|nil
name|ashl
name|$
decl|-9
decl_stmt|,
name|r0
decl_stmt|,
name|r2
decl|#
name|check
name|type
name|cmpb
name|_typetable
decl|+1[
name|r2
decl|]
decl_stmt|,
name|$1
decl|#
name|is
name|it
name|a
name|symbol
decl|??
name|jneq
name|notsymb
decl|#
name|nope
name|movl
decl|4
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r0
decl|#
name|yes
decl_stmt|,
name|put
name|prop
name|list
name|in
name|r1
name|to
name|begin
name|scan
name|jeql
name|fail
decl|# if
name|no
name|prop
name|list
decl_stmt|,
name|we
name|lose
name|right
name|away
name|lp
range|:
name|cmpl
name|r1
decl_stmt|,4
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|is
name|car
name|of
name|list
name|eq
name|to
name|indicator
decl|?
name|jeql
name|good
decl|#
name|jump
decl|if
name|so
name|movl
modifier|*
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r0
decl|# else
name|cddr
name|down
name|list
name|jneq
name|lp
decl|#
name|and
name|jump
decl|if
name|more
name|list
name|to
name|go
operator|.
name|fail
range|:
name|subl2
name|$8
decl_stmt|,
name|r6
decl|#
name|unstack
name|args
name|rsb
decl|# return
name|with
name|r0
name|eq
name|to
name|nil
name|good
range|:
name|movl
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r0
decl|# return
name|cadr
name|of
name|list
name|movl
decl|4
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|r0
name|subl2
name|$8
decl_stmt|,
name|r6
decl|#
name|unstack
name|args
name|rsb
name|nilpli
range|:
name|movl
name|_lispsys
operator|+
literal|64
operator|*
literal|4
decl_stmt|,
name|r0
decl|#
name|want
name|nil
name|prop
name|list
decl_stmt|,
name|get
name|it
name|specially
name|jneq
name|lp
decl|#
name|and
name|process
decl|if
name|anything
name|there
name|subl2
name|$8
decl_stmt|,
name|r6
decl|#
name|unstack
name|args
name|rsb
decl|# else
name|fail
name|notsymb
range|:
name|movab
operator|-
literal|8
operator|(
name|r6
operator|)
decl_stmt|,
name|r7
decl|#
name|must
name|set
name|up
name|r7
name|before
name|calling
name|calls
name|$0
decl_stmt|,
name|_Lget
decl|#
name|not
name|a
name|symbol
decl_stmt|,
name|call
name|C
name|routine
name|to
name|error
name|check
name|subl2
name|$8
decl_stmt|,
name|r6
decl|#
name|unstack
name|args
name|rsb
decl|#
name|and
decl|return
name|what
name|it
name|returned
operator|.
comment|/*  * _qexarith 	exact arithmetic  * calculates x=a*b+c  where a,b and c are 32 bit 2's complement integers  * whose top two bits must be the same (i.e. the are members of the set  * of valid fixnum values for Franz Lisp).  The result, x, will be 64 bits  * long but since each of a, b and c had only 31 bits of precision, the  * result x only has 62 bits of precision.  The lower 30 bits are returned  * in *plo and the high 32 bits are returned in *phi.  If *phi is 0 or -1 then  * x doesn't need any more than 31 bits plus sign to describe, so we  * place the sign in the high two bits of *plo and return 0 from this  * routine.  A non zero return indicates that x requires more than 31 bits  * to describe.  */
decl|.
name|globl
name|_qexarith
comment|/* qexarith(a,b,c,phi,plo)  * int *phi, *plo;  */
name|_qexarith
range|:
name|emul
literal|4
operator|(
name|sp
operator|)
decl_stmt|,8
argument_list|(
name|sp
argument_list|)
decl_stmt|,12
argument_list|(
name|sp
argument_list|)
decl_stmt|,
name|r2
decl|#
name|r2
init|=
name|a
operator|*
name|b
operator|+
name|c
name|to
literal|64
name|bits
name|extzv
name|$0
decl_stmt|,
name|$30
decl_stmt|,
name|r2
decl_stmt|,
modifier|*
decl_stmt|20
argument_list|(
name|sp
argument_list|)
decl_stmt|#
name|get
name|new
name|lo
name|extv
name|$30
decl_stmt|,
name|$32
decl_stmt|,
name|r2
decl_stmt|,
name|r0
decl|#
name|get
name|new
name|carry
name|beql
name|out
decl|#
name|hi
init|=
literal|0
decl_stmt|,
name|no
name|work
name|necessary
name|movl
name|r0
decl_stmt|,
modifier|*
decl_stmt|16
argument_list|(
name|sp
argument_list|)
decl_stmt|#
name|save
name|hi
name|mcoml
name|r0
decl_stmt|,
name|r0
decl|#
name|Is
name|hi
init|=
operator|-
literal|1
operator|(
name|it
literal|'ll fit in one word) 	bneq	out			# it doesn'
name|t
name|bisl2
name|$0xc0000000
expr|,
operator|*
literal|20
operator|(
name|sp
operator|)
operator|#
name|alter
name|low
name|so
name|that
name|it
name|is
name|ok
operator|.
name|out
operator|:
name|rsb
comment|/*  * pushframe : stack a frame   * When this is called, the optional arguments and class have already been  * pushed on the stack as well as the return address (by virtue of the jsb)  * , we push on the rest of the stuff (see h/frame.h)  * for a picture of the save frame  */
operator|.
name|globl
name|_qpushframe
name|_qpushframe
operator|:
name|Profile
name|movl
name|_errp
expr|,
operator|-
operator|(
name|sp
operator|)
name|movl
name|_bnp
expr|,
operator|-
operator|(
name|sp
operator|)
name|movl
name|r6
expr|,
operator|-
operator|(
name|sp
operator|)
name|movl
name|r7
expr|,
operator|-
operator|(
name|sp
operator|)
name|pushr
name|$0x3f00
operator|#
name|save
name|r13
argument_list|(
name|fp
argument_list|)
expr|,
name|r12
argument_list|(
name|ap
argument_list|)
expr|,
name|r11
expr|,
name|r10
expr|,
name|r9
expr|,
name|r8
name|movab
literal|6
operator|*
literal|4
operator|(
name|sp
operator|)
expr|,
name|r0
operator|#
return|return
name|addr
name|of
name|lbot
name|on
name|stack
name|clrl
name|_retval
operator|#
name|set
name|retval
name|to
name|C_INITIAL
name|jmp
operator|*
literal|40
operator|(
name|sp
operator|)
operator|#
end_decl_stmt

begin_return
return|return
name|through
end_return

begin_return
return|return
name|address
comment|/*  * qretfromfr  * called with frame to ret to in r11.  The popnames has already been done.  * we must restore all registers, and jump to the ret addr. the popping  * must be done without reducing the stack pointer since an interrupt  * could come in at any time and this frame must remain on the stack.  * thus we can't use popr.  */
operator|.
name|globl
name|_qretfromfr
name|_qretfromfr
operator|:
name|Profile
name|movl
name|r11
operator|,
name|r0
operator|#
end_return

begin_return
return|return
name|error
name|frame
name|location
name|subl3
name|$24
operator|,
name|r11
operator|,
name|sp
operator|#
name|set
name|up
name|sp
name|at
name|bottom
name|of
name|frame
name|movl
name|sp
operator|,
name|r1
operator|#
name|prepare
name|to
name|pop
name|off
name|movq
argument_list|(
name|r1
argument_list|)
operator|+
operator|,
name|r8
operator|#
name|r8
operator|,
name|r9
name|movq
argument_list|(
name|r1
argument_list|)
operator|+
operator|,
name|r10
operator|#
name|r10
operator|,
name|r11
name|movq
argument_list|(
name|r1
argument_list|)
operator|+
operator|,
name|r12
operator|#
name|r12
operator|,
name|r13
name|movl
argument_list|(
name|r1
argument_list|)
operator|+
operator|,
name|r7
operator|#
name|r7
argument_list|(
argument|lbot
argument_list|)
name|movl
argument_list|(
name|r1
argument_list|)
operator|+
operator|,
name|r6
operator|#
name|r6
argument_list|(
argument|np
argument_list|)
name|jmp
operator|*
literal|40
operator|(
name|sp
operator|)
operator|#
name|jump
name|out
name|of
name|frame
comment|/* This must be at the end of the file.  If we are profiling, allocate  * space for the profile buffer  */
ifdef|#
directive|ifdef
name|PROF
operator|.
name|data
operator|.
name|lcomm
name|prbuf
operator|,
name|indx
operator|+
literal|4
operator|.
name|text
end_return

begin_endif
endif|#
directive|endif
end_endif

end_unit

