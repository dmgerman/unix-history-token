begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	This is the VMS version of the UNIX nlist function.  It will open  *	the specifed linker symbol table file (produced by the /SYMBOL_TABLE=  *	linker option) and return the addresses of the specified global  *	variables just like the UNIX nlist function.  */
end_comment

begin_include
include|#
directive|include
file|<aout.h>
end_include

begin_comment
comment|/*  * Define VMS object file (symbol table) global symbol stuff  */
end_comment

begin_define
define|#
directive|define
name|OBJ$C_GSD
value|1
end_define

begin_comment
comment|/* GSD record type */
end_comment

begin_define
define|#
directive|define
name|OBJ$C_GSD_PSC
value|0
end_define

begin_comment
comment|/* PSECT definition */
end_comment

begin_define
define|#
directive|define
name|OBJ$C_GSD_SYM
value|1
end_define

begin_comment
comment|/* GLOBAL symbol */
end_comment

begin_define
define|#
directive|define
name|OBJ$C_GSD_EPM
value|2
end_define

begin_comment
comment|/* ENTRY mask */
end_comment

begin_define
define|#
directive|define
name|OBJ$C_GSD_PRO
value|3
end_define

begin_comment
comment|/* FORMAL procedure */
end_comment

begin_define
define|#
directive|define
name|SPACE_SIZE
value|2048
end_define

begin_comment
comment|/* Size of read Buffer */
end_comment

begin_macro
name|nlist
argument_list|(
argument|name
argument_list|,
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to user's nlist list */
specifier|register
name|int
name|f
decl_stmt|,
name|i
decl_stmt|,
name|nreq
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|read_size
decl_stmt|;
comment|/* Size of last read request */
name|char
name|space
index|[
name|SPACE_SIZE
index|]
decl_stmt|;
comment|/* Read buffer */
name|char
name|real_name
index|[
literal|100
index|]
decl_stmt|;
comment|/* Possibly changed symtab filename */
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|code
decl_stmt|;
comment|/* 	 * Clear out the type and value parts of the user's nlist list 	 */
for|for
control|(
name|p
operator|=
name|list
operator|,
name|nreq
operator|=
literal|0
init|;
name|p
operator|->
name|n_un
operator|.
name|n_name
index|[
literal|0
index|]
condition|;
name|p
operator|++
operator|,
name|nreq
operator|++
control|)
block|{
name|p
operator|->
name|n_type
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|n_value
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Open the symtab file.  If there is no extension, use ".stb" 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cp
operator|=
name|name
init|;
operator|*
name|cp
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'.'
operator|)
condition|;
name|i
operator|++
control|)
name|real_name
index|[
name|i
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|real_name
index|[
name|i
index|]
operator|=
literal|'.'
expr_stmt|;
name|real_name
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'s'
expr_stmt|;
name|real_name
index|[
name|i
operator|+
literal|2
index|]
operator|=
literal|'t'
expr_stmt|;
name|real_name
index|[
name|i
operator|+
literal|3
index|]
operator|=
literal|'b'
expr_stmt|;
name|real_name
index|[
name|i
operator|+
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|open
argument_list|(
operator|*
name|cp
operator|==
literal|'.'
condition|?
name|name
else|:
name|real_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Cycle through the symtab file decoding the object records. 	 * When you hit a global symbol definition, check it against 	 * the list of requested symbols. 	 */
while|while
condition|(
name|read_size
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|space
argument_list|,
name|SPACE_SIZE
argument_list|)
condition|)
block|{
if|if
condition|(
name|space
index|[
literal|0
index|]
operator|!=
name|OBJ$C_GSD
condition|)
continue|continue;
comment|/* looking for GSD */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|read_size
condition|;
control|)
switch|switch
condition|(
name|code
operator|=
name|space
index|[
name|i
index|]
condition|)
block|{
case|case
name|OBJ$C_GSD_PSC
case|:
comment|/* PSECT, ignore it */
name|i
operator|+=
literal|9
operator|+
name|space
index|[
name|i
operator|+
literal|8
index|]
expr_stmt|;
break|break;
case|case
name|OBJ$C_GSD_SYM
case|:
comment|/* GLOBAL SYMBOL */
name|offset
operator|=
literal|9
expr_stmt|;
goto|goto
name|common
goto|;
case|case
name|OBJ$C_GSD_EPM
case|:
comment|/* ENTRY PT. MASK */
case|case
name|OBJ$C_GSD_PRO
case|:
comment|/* Proc decl. */
name|offset
operator|=
literal|11
expr_stmt|;
name|common
label|:
block|{
specifier|register
name|int
name|j
decl_stmt|,
name|nchars
decl_stmt|;
name|int
modifier|*
name|val
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* 					 * Get size of symbol string 					 */
name|nchars
operator|=
name|space
index|[
name|i
operator|+
name|offset
index|]
expr_stmt|;
comment|/* 					 * Search the list for this string 					 */
for|for
control|(
name|p
operator|=
name|list
init|;
name|p
operator|->
name|n_un
operator|.
name|n_name
index|[
literal|0
index|]
condition|;
name|p
operator|++
control|)
block|{
name|cp
operator|=
name|p
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
comment|/* 						 * Strip off a leading '_' 						 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'_'
condition|)
name|cp
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nchars
condition|;
name|j
operator|++
control|)
comment|/* 						    * Make the comparison 						    *  caseless 						    */
if|if
condition|(
operator|(
operator|(
operator|*
name|cp
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'z'
operator|)
condition|?
operator|*
name|cp
operator|++
operator|-
literal|'a'
operator|+
literal|'A'
else|:
operator|*
name|cp
operator|++
operator|)
operator|!=
name|space
index|[
name|i
operator|+
name|j
operator|+
name|offset
operator|+
literal|1
index|]
condition|)
goto|goto
name|cont
goto|;
comment|/* 						 * GOT IT! Extract its value 						 */
name|val
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|space
index|[
name|i
operator|+
literal|5
index|]
expr_stmt|;
name|p
operator|->
name|n_value
operator|=
operator|*
name|val
expr_stmt|;
name|p
operator|->
name|n_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
name|nreq
operator|==
literal|0
condition|)
goto|goto
name|alldone
goto|;
break|break;
name|cont
label|:
empty_stmt|;
block|}
block|}
name|i
operator|+=
name|offset
operator|+
literal|1
operator|+
name|space
index|[
name|i
operator|+
name|offset
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|OBJ$C_GSD_PRO
condition|)
block|{
comment|/* Dump the PRO arguments */
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|space
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|i
operator|+=
literal|2
operator|+
name|space
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"%d is an invalid GSD type\n"
argument_list|,
name|space
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|alldone
label|:
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

