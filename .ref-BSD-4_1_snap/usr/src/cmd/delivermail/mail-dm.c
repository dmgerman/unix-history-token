begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<arpa/netopen.h>
end_include

begin_include
include|#
directive|include
file|"srvrftp.h"
end_include

begin_include
include|#
directive|include
file|<statbuf.h>
end_include

begin_include
include|#
directive|include
file|<arpa/hostnames.h>
end_include

begin_include
include|#
directive|include
file|<io_buf.h>
end_include

begin_include
include|#
directive|include
file|<arpa/mail.h>
end_include

begin_include
include|#
directive|include
file|<ident.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<log.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|fout
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Name: 	mail  Function: 	handle the MAIL<user> command over the command connection  Algorithm: 	see if we have a known user  	if mailbox file can't be gotten 		return 	tell him it is ok to go ahead with mail  	while he doesn't type a period 		read and write data 	say completed  Parameters: 	username in arg  Returns: 	nothing  Globals: 	arg 	username=  Calls: 	strmove 	getuser 	loguser 	openmail 	closemail 	getline 	chown (sys) 	time (sys) 	printf (sys) 	getch	(util) 	putch	(util)  Called by: 	main thru command array  History: 	initial coding 		Mark Kampe UCLA-ATS 	modified 4/13/76 by S. F. Holmgren for Illinois version 	modified 6/30/76 by S. F. Holmgren to call getmbox 	modified 10/18/76 by J. S. Kravitz to improve net mail header 	chown removed by R. Balocca @ CAC, Sunday 1977 February 20 	getline removed and limit on line length removed by using 	getch and putch added by R. Balocca @ CAC, 1977 March 8 Tuesday 	Fixed oversight in above (forgot to translate<crlf> to<lf>) 		1977 March 10 Thursday by Rick Balocca @ CAC 	Added openmail& closemail, added logging, and fixed several 		bugs on or about 12/21/79 by Eric Allman, UCB/INGRES. 	Changed to always accept mail -- bad mail will be sent back -- 		1/9/80 by Eric Allman, UCB/INGRES. */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|gt
value|(c = getch())
end_define

begin_macro
name|mail
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* general use */
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* extern struct io_buf obuf; */
comment|/* get to open mailbox file descriptor */
name|fflush
argument_list|(
operator|&
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fout
operator|=
name|openmail
argument_list|(
name|arg
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
comment|/* obuf.unused = 0;	obuf.addr = 0;	/* fake a fcreat */
comment|/* say its ok to continue */
name|netreply
argument_list|(
literal|"350 Enter mail, end with a line containing only `.'\r\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
comment|/* while no error or<crlf>.<crlf> */
block|{
comment|/* we are at beginning of line */
if|if
condition|(
name|gt
operator|==
literal|'.'
condition|)
comment|/*"."*/
block|{
if|if
condition|(
name|gt
operator|==
literal|'\r'
condition|)
comment|/*".\r"*/
block|{
if|if
condition|(
name|gt
operator|==
literal|'\n'
condition|)
comment|/*".\r\n"*/
block|{
comment|/* end of message */
break|break;
block|}
else|else
block|{
comment|/*".\r"c*/
name|putch
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|putch
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/*"."c"*/
name|putch
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
comment|/*"-"*/
comment|/* c */
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
name|c
operator|!=
literal|'\r'
condition|;
name|gt
control|)
block|{
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
comment|/* fflush(&obuf); */
comment|/* write(obuf.fid, "\n***** Sender aborted connection *****\n", 39); */
name|fflush
argument_list|(
operator|&
name|fout
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fout
argument_list|,
literal|"\n***** Sender aborted connection *****\n"
argument_list|,
literal|39
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
name|putch
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/*"\r"*/
if|if
condition|(
name|gt
operator|==
literal|'\n'
condition|)
block|{
comment|/*"\r\n"*/
name|crlf
label|:
name|putch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/*"\r"c*/
name|crc
label|:
name|putch
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|gt
expr_stmt|;
comment|/* "\r\0" */
comment|/* is arpa escape for "\r" */
block|}
block|}
block|}
name|out
label|:
name|fflush
argument_list|(
operator|&
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
name|closemail
argument_list|(
name|fout
argument_list|)
operator|>=
literal|0
condition|)
name|netreply
argument_list|(
literal|"256 Mail accepted\r\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Name: 	datamail  Function: 	handle the MLFL command  Algorithm: 	fork 		make sure we have a valid user 			say bad user and exit 		send sock command 		open data connection 		get open mailbox file descriptor 		call rcvdata to receive mail  Parameters: 	username in arg  Returns: 	nothing  Globals: 	arg  Calls: 	fork (sys) 	strmove 	netreply 	sendsock 	dataconnection 	getmbox 	rcvdata 	printf (sys) 	time (sys)  Called by: 	main thru command array   History: 	initial coding 4/13/76 by S. F. Holmgren 	modified 10/18/76 by J. S. Kravitz to put net mail header 	chown removed by R. Balocca @ CAC, Sunday 1977 February 20 */
end_comment

begin_escape
end_escape

begin_macro
name|datamail
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|netdata
expr_stmt|;
comment|/* register mboxfid; */
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|netreply
argument_list|(
literal|"455 Mail server temporarily unavailable\r\n"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|fflush
argument_list|(
operator|&
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fout
operator|=
name|openmail
argument_list|(
name|arg
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* send sock command */
name|sendsock
argument_list|(
name|U4
argument_list|)
expr_stmt|;
comment|/* open data connection */
name|netdata
operator|=
name|dataconnection
argument_list|(
name|U4
argument_list|)
expr_stmt|;
comment|/* say its ok to proceed */
name|numreply
argument_list|(
name|NUM250
argument_list|)
expr_stmt|;
comment|/* get data from net connection and copy to mail file */
comment|/* rcvdata( netdata,mboxfid ); */
if|if
condition|(
name|rcvdata
argument_list|(
name|netdata
argument_list|,
name|fout
argument_list|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* close the mail, see if ok; if so say ok */
name|fflush
argument_list|(
operator|&
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
name|closemail
argument_list|(
name|fout
argument_list|)
operator|>=
literal|0
condition|)
name|numreply
argument_list|(
name|NUM252
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  OPENMAIL -- Open a channel to the mail server ** **	Gets the mail server started up ready to handle our **	mail. ** **	Algorithm: **		See if the user is specified. **			If not, send to user "root". **		See if the user exists. **			If not, signal error 450 and return. **		Fork. **		Create a pipe **			Signal "unavailable" and exit on failure. **		Fork. **			Signal "unavailable" and exit on failure **			In child: **				Call mailer: /etc/delivermail is preferred. **			In parent: **				Avoid pipe signals in case delivermail dies. **				Save the childs pid. **				Return file descriptor. ** **	Notes: **		The check to see if the user actually exists should **		go away so that we can do real mail forwarding. ** **	Parameters: **		who -- the user to send the mail to. ** **	Returns: **		File descriptor to send mail to. **		-1 on failure. ** **	Side Effects: **		Forks /etc/delivermail or /bin/mail or /usr/bin/mail. **		Becomes "network" in the child. ** **	Requires: **		strmove **		getuser **		netreply **		pipe (sys) **		fork (sys) **		close (sys) **		dup (sys) **		execl (sys) **		signal (sys) **		exit (sys) ** **	Called By: **		mail **		datamail ** **	History: **		1/9/80 -- Added 050& 455 reply messages if execl's **			fail.  Eric Allman UCB/INGRES. **		11/26/79 -- Modified to map upper case to lower **			case.  Eric Allman UCB/INGRES. **		11/10/79 -- Written by Eric Allman UCB/INGRES **		3/6/80 -- Dropped case mapping; delivermail does **			that now.  EPA UCB/INGRES. */
end_comment

begin_decl_stmt
name|int
name|Mail_pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Mail_user
decl_stmt|;
end_decl_stmt

begin_macro
name|openmail
argument_list|(
argument|who
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|who
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|w
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|pvect
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|w
operator|=
name|who
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
name|w
operator|=
literal|"root"
expr_stmt|;
comment|/* 	else 	{ 		for (p = w; *p != '\0'; p++) 		{ 			if (*p>= 'A'&& *p<= 'Z') 				*p =- 'A' - 'a'; 		} 	} */
name|Mail_user
operator|=
name|w
expr_stmt|;
comment|/* see if the user exists */
name|strmove
argument_list|(
name|w
argument_list|,
name|username
argument_list|)
expr_stmt|;
comment|/* 	if (getuser(0) == 0) 	{ 		netreply("450 User unknown\r\n"); 		return (-1); 	} */
comment|/* try to get a pipe to the mailer */
if|if
condition|(
name|pipe
argument_list|(
name|pvect
argument_list|)
operator|<
literal|0
condition|)
block|{
name|unavailable
label|:
name|netreply
argument_list|(
literal|"455 Mail server temporarily unavailable\r\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* fork */
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* failure */
name|close
argument_list|(
name|pvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|unavailable
goto|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* child */
name|close
argument_list|(
name|pvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|pvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|NETUID
argument_list|)
expr_stmt|;
comment|/* try to call something to deliver the mail */
name|execl
argument_list|(
literal|"/etc/delivermail"
argument_list|,
literal|"delivermail"
argument_list|,
literal|"-em"
argument_list|,
literal|"-a"
argument_list|,
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|netreply
argument_list|(
literal|"050 Not using normal mail server, beware!\r\n"
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/mail"
argument_list|,
literal|"mail"
argument_list|,
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/mail"
argument_list|,
literal|"mail"
argument_list|,
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* doesn't seem to be anything around */
name|netreply
argument_list|(
literal|"455 Mail server unavailable\r\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* else parent */
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|Mail_pid
operator|=
name|i
expr_stmt|;
name|close
argument_list|(
name|pvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|pvect
index|[
literal|1
index|]
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CLOSEMAIL -- Close the mail file and get actual status ** **	The mail file is closed. ** **	Algorithm: **		Wait for the mailer to die. **			If it wasn't there, be non-comittal. **		If it died a violent death, give error. ** **	Parameters: **		fd -- the file descriptor of the mail file. ** **	Returns: **		none. ** **	Side Effects: **		mailer is soaked up. ** **	Requires: **		close (sys) **		wait (sys) ** **	Called By: **		mail **		datamail ** **	History: **		1/9/80 -- Changed to not check for errors in mailing, **			since these will be mailed back. **		11/10/79 -- Written by Eric Allman UCB/INGRES. */
end_comment

begin_macro
name|closemail
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|auto
name|int
name|st
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* close the pipe -- mail should go away */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* wait for its body */
while|while
condition|(
operator|(
name|i
operator|=
name|wait
argument_list|(
operator|&
name|st
argument_list|)
operator|)
operator|!=
name|Mail_pid
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* how did this happen? */
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mail from host %d to %s: no child"
argument_list|,
name|openparams
operator|.
name|o_frnhost
operator|&
literal|0377
argument_list|,
name|Mail_user
argument_list|)
expr_stmt|;
goto|goto
name|unavailable
goto|;
block|}
block|}
comment|/* 'st' is now the status of the mailer */
if|if
condition|(
operator|(
name|st
operator|&
literal|0377
operator|)
operator|!=
literal|0
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mail from host %d to %s: status %o"
argument_list|,
name|openparams
operator|.
name|o_frnhost
operator|&
literal|0377
argument_list|,
name|Mail_user
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|unavailable
label|:
name|netreply
argument_list|(
literal|"455 Mail not delivered -- local system error\r\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

