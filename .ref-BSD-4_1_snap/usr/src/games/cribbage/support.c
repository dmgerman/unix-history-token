begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"deck.h"
end_include

begin_include
include|#
directive|include
file|"cribbage.h"
end_include

begin_define
define|#
directive|define
name|NTV
value|10
end_define

begin_comment
comment|/* number scores to test */
end_comment

begin_comment
comment|/* score to test reachability of, and order to test them in */
end_comment

begin_decl_stmt
name|int
name|tv
index|[
name|NTV
index|]
init|=
block|{
literal|8
block|,
literal|7
block|,
literal|9
block|,
literal|6
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|10
block|,
literal|5
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * computer chooses what to play in pegging...  * only called if no playable card will score points  */
end_comment

begin_macro
name|cchose
argument_list|(
argument|h
argument_list|,
argument|n
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|CARD
name|h
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|l
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|s
operator|<
literal|4
condition|)
block|{
comment|/* try for good value */
if|if
condition|(
operator|(
name|j
operator|=
name|anysumto
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|j
operator|)
return|;
if|if
condition|(
operator|(
name|j
operator|=
name|anysumto
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|s
operator|==
literal|0
condition|)
return|return
operator|(
name|j
operator|)
return|;
block|}
if|if
condition|(
name|s
operator|>
literal|0
operator|&&
name|s
operator|<
literal|20
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|10
condition|;
name|i
operator|++
control|)
block|{
comment|/* try for retaliation to 31 */
if|if
condition|(
operator|(
name|j
operator|=
name|anysumto
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
name|s
argument_list|,
literal|21
operator|-
name|i
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|l
operator|=
name|numofval
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
name|i
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|>
literal|1
operator|||
name|VAL
argument_list|(
name|h
index|[
name|j
index|]
operator|.
name|rank
argument_list|)
operator|!=
name|i
condition|)
return|return
operator|(
name|j
operator|)
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|s
operator|<
literal|15
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTV
condition|;
name|i
operator|++
control|)
block|{
comment|/* for retaliation after 15 */
if|if
condition|(
operator|(
name|j
operator|=
name|anysumto
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
name|s
argument_list|,
name|tv
index|[
name|i
index|]
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|l
operator|=
name|numofval
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
literal|15
operator|-
name|tv
index|[
name|i
index|]
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|>
literal|1
operator|||
name|VAL
argument_list|(
name|h
index|[
name|j
index|]
operator|.
name|rank
argument_list|)
operator|!=
literal|15
operator|-
name|tv
index|[
name|i
index|]
condition|)
return|return
operator|(
name|j
operator|)
return|;
block|}
block|}
block|}
block|}
name|j
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
comment|/* remember: h is sorted */
name|l
operator|=
name|s
operator|+
name|VAL
argument_list|(
name|h
index|[
name|i
index|]
operator|.
name|rank
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|31
condition|)
continue|continue;
if|if
condition|(
name|l
operator|!=
literal|5
operator|&&
name|l
operator|!=
literal|10
operator|&&
name|l
operator|!=
literal|21
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
return|return
operator|(
name|j
operator|)
return|;
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|l
operator|=
name|s
operator|+
name|VAL
argument_list|(
name|h
index|[
name|i
index|]
operator|.
name|rank
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|31
condition|)
continue|continue;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|j
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|l
operator|!=
literal|5
operator|&&
name|l
operator|!=
literal|21
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|j
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * evaluate and score a player hand or crib  */
end_comment

begin_macro
name|plyrhand
argument_list|(
argument|hand
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|CARD
name|hand
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|BOOLEAN
name|win
decl_stmt|;
name|printf
argument_list|(
literal|"Your %s is: "
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|prhand
argument_list|(
name|hand
argument_list|,
name|CINHAND
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ["
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|turnover
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"].   How many points? "
argument_list|)
expr_stmt|;
name|i
operator|=
name|scorehand
argument_list|(
name|hand
argument_list|,
name|turnover
argument_list|,
name|CINHAND
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* count */
if|if
condition|(
operator|(
name|j
operator|=
name|number
argument_list|(
literal|0
argument_list|,
literal|29
argument_list|)
operator|)
operator|==
literal|19
condition|)
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|j
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|j
condition|)
block|{
name|win
operator|=
name|chkscr
argument_list|(
operator|&
name|pscore
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"It's really only %d points, I get %d.\n"
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
name|win
operator|=
name|chkscr
argument_list|(
operator|&
name|cscore
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|win
operator|=
name|chkscr
argument_list|(
operator|&
name|pscore
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"You should have taken %d, not %d!\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|explain
condition|)
block|{
name|printf
argument_list|(
literal|"Explanation: %s\n"
argument_list|,
name|expl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|win
operator|=
name|chkscr
argument_list|(
operator|&
name|pscore
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|win
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * handle scoring and displaying the computers hand  */
end_comment

begin_macro
name|comphand
argument_list|(
argument|h
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|CARD
name|h
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|j
operator|=
name|scorehand
argument_list|(
name|h
argument_list|,
name|turnover
argument_list|,
name|CINHAND
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"My %s ( "
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|prhand
argument_list|(
name|h
argument_list|,
name|CINHAND
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ["
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|turnover
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"] ) scores %d.\n"
argument_list|,
operator|(
name|j
operator|==
literal|0
condition|?
literal|19
else|:
name|j
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|chkscr
argument_list|(
operator|&
name|cscore
argument_list|,
name|j
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * add inc to scr and test for> glimit  */
end_comment

begin_macro
name|chkscr
argument_list|(
argument|scr
argument_list|,
argument|inc
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|scr
decl_stmt|,
name|inc
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
operator|(
operator|*
name|scr
operator|+=
name|inc
operator|)
operator|>=
name|glimit
condition|?
name|TRUE
else|:
name|FALSE
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * cdiscard -- the computer figures out what is the best discard for  * the crib and puts the best two cards at the end  */
end_comment

begin_macro
name|cdiscard
argument_list|(
argument|mycrib
argument_list|)
end_macro

begin_decl_stmt
name|BOOLEAN
name|mycrib
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|CARD
name|d
index|[
name|CARDS
index|]
decl_stmt|,
name|h
index|[
name|FULLHAND
index|]
decl_stmt|,
name|cb
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|nc
decl_stmt|,
name|ns
decl_stmt|;
name|long
name|sums
index|[
literal|15
index|]
decl_stmt|;
specifier|static
name|int
name|undo1
index|[
literal|15
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|}
decl_stmt|;
specifier|static
name|int
name|undo2
index|[
literal|15
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|}
decl_stmt|;
name|makedeck
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|nc
operator|=
name|CARDS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|knownum
condition|;
name|i
operator|++
control|)
block|{
comment|/* get all other cards */
name|remove
argument_list|(
name|known
index|[
name|i
index|]
argument_list|,
name|d
argument_list|,
name|nc
operator|--
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
name|sums
index|[
name|i
index|]
operator|=
literal|0L
expr_stmt|;
name|ns
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|FULLHAND
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|cb
index|[
literal|0
index|]
operator|=
name|chand
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|FULLHAND
condition|;
name|j
operator|++
control|)
block|{
name|cb
index|[
literal|1
index|]
operator|=
name|chand
index|[
name|j
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|FULLHAND
condition|;
name|k
operator|++
control|)
name|h
index|[
name|k
index|]
operator|=
name|chand
index|[
name|k
index|]
expr_stmt|;
name|remove
argument_list|(
name|chand
index|[
name|i
index|]
argument_list|,
name|h
argument_list|,
name|FULLHAND
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|chand
index|[
name|j
index|]
argument_list|,
name|h
argument_list|,
name|FULLHAND
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nc
condition|;
name|k
operator|++
control|)
block|{
name|sums
index|[
name|ns
index|]
operator|+=
name|scorehand
argument_list|(
name|h
argument_list|,
name|d
index|[
name|k
index|]
argument_list|,
name|CINHAND
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mycrib
condition|)
name|sums
index|[
name|ns
index|]
operator|+=
name|adjust
argument_list|(
name|cb
argument_list|,
name|d
index|[
name|k
index|]
argument_list|)
expr_stmt|;
else|else
name|sums
index|[
name|ns
index|]
operator|-=
name|adjust
argument_list|(
name|cb
argument_list|,
name|d
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
operator|++
name|ns
expr_stmt|;
block|}
block|}
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sums
index|[
name|i
index|]
operator|>
name|sums
index|[
name|j
index|]
condition|)
name|j
operator|=
name|i
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|FULLHAND
condition|;
name|k
operator|++
control|)
name|h
index|[
name|k
index|]
operator|=
name|chand
index|[
name|k
index|]
expr_stmt|;
name|remove
argument_list|(
name|h
index|[
name|undo1
index|[
name|j
index|]
index|]
argument_list|,
name|chand
argument_list|,
name|FULLHAND
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|h
index|[
name|undo2
index|[
name|j
index|]
index|]
argument_list|,
name|chand
argument_list|,
name|FULLHAND
operator|-
literal|1
argument_list|)
expr_stmt|;
name|chand
index|[
literal|4
index|]
operator|=
name|h
index|[
name|undo1
index|[
name|j
index|]
index|]
expr_stmt|;
name|chand
index|[
literal|5
index|]
operator|=
name|h
index|[
name|undo2
index|[
name|j
index|]
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * returns true if some card in hand can be played without exceeding 31  */
end_comment

begin_macro
name|anymove
argument_list|(
argument|hand
argument_list|,
argument|n
argument_list|,
argument|sum
argument_list|)
end_macro

begin_decl_stmt
name|CARD
name|hand
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|j
operator|=
name|hand
index|[
literal|0
index|]
operator|.
name|rank
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hand
index|[
name|i
index|]
operator|.
name|rank
operator|<
name|j
condition|)
name|j
operator|=
name|hand
index|[
name|i
index|]
operator|.
name|rank
expr_stmt|;
block|}
return|return
operator|(
name|sum
operator|+
name|VAL
argument_list|(
name|j
argument_list|)
operator|<=
literal|31
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * anysumto returns the index (0<= i< n) of the card in hand that brings  * the s up to t, or -1 if there is none  */
end_comment

begin_macro
name|anysumto
argument_list|(
argument|hand
argument_list|,
argument|n
argument_list|,
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|CARD
name|hand
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|,
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|+
name|VAL
argument_list|(
name|hand
index|[
name|i
index|]
operator|.
name|rank
argument_list|)
operator|==
name|t
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * return the number of cards in h having the given rank value  */
end_comment

begin_macro
name|numofval
argument_list|(
argument|h
argument_list|,
argument|n
argument_list|,
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|CARD
name|h
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|VAL
argument_list|(
name|h
index|[
name|i
index|]
operator|.
name|rank
argument_list|)
operator|==
name|v
condition|)
operator|++
name|j
expr_stmt|;
block|}
return|return
operator|(
name|j
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * makeknown remembers all n cards in h for future recall  */
end_comment

begin_macro
name|makeknown
argument_list|(
argument|h
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|CARD
name|h
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|known
index|[
name|knownum
operator|++
index|]
operator|=
name|h
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_block

end_unit

