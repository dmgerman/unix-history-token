begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*      Re-coding of advent in C: file i/o and user i/o                 */
end_comment

begin_include
include|#
directive|include
file|"hdr.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_macro
name|getin
argument_list|(
argument|wrd1
argument_list|,
argument|wrd2
argument_list|)
end_macro

begin_comment
comment|/* get command from user        */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|wrd1
decl_stmt|,
modifier|*
modifier|*
name|wrd2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no prompt, usually           */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|static
name|char
name|wd1buf
index|[
name|MAXSTR
index|]
decl_stmt|,
name|wd2buf
index|[
name|MAXSTR
index|]
decl_stmt|;
name|int
name|first
decl_stmt|,
name|numch
decl_stmt|;
operator|*
name|wrd1
operator|=
name|wd1buf
expr_stmt|;
comment|/* return ptr to internal string*/
operator|*
name|wrd2
operator|=
name|wd2buf
expr_stmt|;
name|wd2buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* in case it isn't set here    */
for|for
control|(
name|s
operator|=
name|wd1buf
operator|,
name|first
operator|=
literal|1
operator|,
name|numch
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|=
name|getchar
argument_list|()
operator|)
operator|>=
literal|'A'
operator|&&
operator|*
name|s
operator|<=
literal|'Z'
condition|)
operator|*
name|s
operator|=
operator|*
name|s
operator|-
operator|(
literal|'A'
operator|-
literal|'a'
operator|)
expr_stmt|;
comment|/* convert to upper case        */
switch|switch
condition|(
operator|*
name|s
condition|)
comment|/* start reading from user      */
block|{
case|case
literal|'\n'
case|:
operator|*
name|s
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|' '
case|:
if|if
condition|(
name|s
operator|==
name|wd1buf
operator|||
name|s
operator|==
name|wd2buf
condition|)
comment|/* initial blank   */
continue|continue;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|first
condition|)
comment|/* finished 1st wd; start 2nd   */
block|{
name|first
operator|=
name|numch
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|wd2buf
expr_stmt|;
break|break;
block|}
else|else
comment|/* finished 2nd word            */
block|{
name|FLUSHLINE
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
return|return;
block|}
default|default:
if|if
condition|(
operator|++
name|numch
operator|>=
name|MAXSTR
condition|)
comment|/* string too long      */
block|{
name|printf
argument_list|(
literal|"Give me a break!!\n"
argument_list|)
expr_stmt|;
name|wd1buf
index|[
literal|0
index|]
operator|=
name|wd2buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|FLUSHLINE
expr_stmt|;
return|return;
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|confirm
argument_list|(
argument|mesg
argument_list|)
end_macro

begin_comment
comment|/* confirm irreversible action  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|mesg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|result
decl_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
comment|/* tell him what he did         */
if|if
condition|(
name|getchar
argument_list|()
operator|==
literal|'y'
condition|)
comment|/* was his first letter a 'y'?  */
name|result
operator|=
literal|1
expr_stmt|;
else|else
name|result
operator|=
literal|0
expr_stmt|;
name|FLUSHLINE
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_macro
name|yes
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|z
argument_list|)
end_macro

begin_comment
comment|/* confirm with rspeak          */
end_comment

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|result
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rspeak
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* tell him what we want*/
if|if
condition|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'y'
condition|)
name|result
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'n'
condition|)
name|result
operator|=
name|FALSE
expr_stmt|;
name|FLUSHLINE
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'y'
operator|||
name|ch
operator|==
literal|'n'
condition|)
break|break;
name|printf
argument_list|(
literal|"Please answer the question.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|TRUE
condition|)
name|rspeak
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|FALSE
condition|)
name|rspeak
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_macro
name|yesm
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|z
argument_list|)
end_macro

begin_comment
comment|/* confirm with mspeak          */
end_comment

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|result
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mspeak
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* tell him what we want*/
if|if
condition|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'y'
condition|)
name|result
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'n'
condition|)
name|result
operator|=
name|FALSE
expr_stmt|;
name|FLUSHLINE
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'y'
operator|||
name|ch
operator|==
literal|'n'
condition|)
break|break;
name|printf
argument_list|(
literal|"Please answer the question.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|TRUE
condition|)
name|mspeak
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|FALSE
condition|)
name|mspeak
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|FILE
modifier|*
name|inbuf
decl_stmt|,
modifier|*
name|outbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|adrptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current seek adr ptr         */
end_comment

begin_decl_stmt
name|int
name|outsw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* putting stuff to data file?  */
end_comment

begin_decl_stmt
name|char
name|iotape
index|[]
init|=
literal|"Ax3F'tt$8hqer*hnGKrX:!l"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tape
init|=
name|iotape
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to encryption tape   */
end_comment

begin_macro
name|next
argument_list|()
end_macro

begin_comment
comment|/* next char frm file, bump adr */
end_comment

begin_block
block|{
specifier|register
name|char
name|ch
decl_stmt|,
name|t
decl_stmt|;
name|adrptr
operator|++
expr_stmt|;
comment|/* seek address in file         */
name|ch
operator|=
name|getc
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|outsw
condition|)
comment|/* putting data in tmp file     */
block|{
if|if
condition|(
operator|*
name|tape
operator|==
literal|0
condition|)
name|tape
operator|=
name|iotape
expr_stmt|;
comment|/* rewind encryption tape    */
name|putc
argument_list|(
name|ch
operator|^
operator|*
name|tape
operator|++
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
comment|/* encrypt& output char     */
block|}
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
name|breakch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tell which char ended rnum   */
end_comment

begin_macro
name|rdata
argument_list|()
end_macro

begin_comment
comment|/* read all data from orig file */
end_comment

begin_block
block|{
specifier|register
name|int
name|sect
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
if|if
condition|(
operator|(
name|inbuf
operator|=
name|fopen
argument_list|(
name|DATFILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* all the data lives in here   */
block|{
name|printf
argument_list|(
literal|"Cannot open data file %s\n"
argument_list|,
name|DATFILE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|outbuf
operator|=
name|fopen
argument_list|(
name|TMPFILE
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* the text lines will go here  */
block|{
name|printf
argument_list|(
literal|"Cannot create output file %s\n"
argument_list|,
name|TMPFILE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|setup
operator|=
name|clsses
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
comment|/* read data sections           */
block|{
name|sect
operator|=
name|next
argument_list|()
operator|-
literal|'0'
expr_stmt|;
comment|/* 1st digit of section number  */
name|printf
argument_list|(
literal|"Section %c"
argument_list|,
name|sect
operator|+
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
name|next
argument_list|()
operator|)
operator|!=
name|LF
condition|)
comment|/* is there a second digit?     */
block|{
name|FLUSHLF
expr_stmt|;
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|sect
operator|=
literal|10
operator|*
name|sect
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sect
condition|)
block|{
case|case
literal|0
case|:
comment|/* finished reading database    */
name|fclose
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
comment|/* long form descriptions       */
name|rdesc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* short form descriptions      */
name|rdesc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* travel table                 */
name|rtrav
argument_list|()
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* vocabulary                   */
name|rvoc
argument_list|()
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* object descriptions          */
name|rdesc
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* arbitrary messages           */
name|rdesc
argument_list|(
literal|6
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* object locations             */
name|rlocs
argument_list|()
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* action defaults              */
name|rdflt
argument_list|()
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* liquid assets                */
name|rliq
argument_list|()
expr_stmt|;
break|break;
case|case
literal|10
case|:
comment|/* class messages               */
name|rdesc
argument_list|(
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
comment|/* hints                        */
name|rhints
argument_list|()
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* magic messages               */
name|rdesc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Invalid data section number: %d\n"
argument_list|,
name|sect
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
name|putchar
argument_list|(
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|breakch
operator|!=
name|LF
condition|)
comment|/* routines return after "-1"   */
name|FLUSHLF
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|char
name|nbf
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|rnum
argument_list|()
end_macro

begin_comment
comment|/* read initial location num    */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|tape
operator|=
name|iotape
expr_stmt|;
comment|/* restart encryption tape      */
for|for
control|(
name|s
operator|=
name|nbf
operator|,
operator|*
name|s
operator|=
literal|0
init|;
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|s
operator|=
name|next
argument_list|()
operator|)
operator|==
name|TAB
operator|||
operator|*
name|s
operator|==
literal|'\n'
operator|||
operator|*
name|s
operator|==
name|LF
condition|)
break|break;
name|breakch
operator|=
operator|*
name|s
expr_stmt|;
comment|/* save char for rtrav()        */
operator|*
name|s
operator|=
literal|0
expr_stmt|;
comment|/* got the number as ascii      */
if|if
condition|(
name|nbf
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* end of data                  */
return|return
operator|(
name|atoi
argument_list|(
name|nbf
argument_list|)
operator|)
return|;
comment|/* convert it to integer        */
block|}
end_block

begin_decl_stmt
name|int
name|seekhere
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial seek for output file */
end_comment

begin_macro
name|rdesc
argument_list|(
argument|sect
argument_list|)
end_macro

begin_comment
comment|/* read description-format msgs */
end_comment

begin_decl_stmt
name|int
name|sect
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|locc
decl_stmt|;
name|int
name|seekstart
decl_stmt|,
name|maystart
decl_stmt|,
name|adrstart
decl_stmt|;
name|char
modifier|*
name|entry
decl_stmt|;
name|outsw
operator|=
literal|1
expr_stmt|;
comment|/* these msgs go into tmp file  */
if|if
condition|(
name|sect
operator|==
literal|1
condition|)
name|putc
argument_list|(
literal|'X'
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
comment|/* so seekadr> 0               */
name|adrptr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|oldloc
operator|=
operator|-
literal|1
operator|,
name|seekstart
operator|=
name|seekhere
init|;
condition|;
control|)
block|{
name|maystart
operator|=
name|adrptr
expr_stmt|;
comment|/* maybe starting new entry     */
if|if
condition|(
operator|(
name|locc
operator|=
name|rnum
argument_list|()
operator|)
operator|!=
name|oldloc
operator|&&
name|oldloc
operator|>=
literal|0
comment|/* finished msg */
operator|&&
operator|!
operator|(
name|sect
operator|==
literal|5
operator|&&
operator|(
name|locc
operator|==
literal|0
operator|||
name|locc
operator|>=
literal|100
operator|)
operator|)
condition|)
comment|/* unless sect 5*/
block|{
switch|switch
condition|(
name|sect
condition|)
comment|/* now put it into right table  */
block|{
case|case
literal|1
case|:
comment|/* long descriptions            */
name|ltext
index|[
name|oldloc
index|]
operator|.
name|seekadr
operator|=
name|seekhere
expr_stmt|;
name|ltext
index|[
name|oldloc
index|]
operator|.
name|txtlen
operator|=
name|maystart
operator|-
name|seekstart
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* short descriptions           */
name|stext
index|[
name|oldloc
index|]
operator|.
name|seekadr
operator|=
name|seekhere
expr_stmt|;
name|stext
index|[
name|oldloc
index|]
operator|.
name|txtlen
operator|=
name|maystart
operator|-
name|seekstart
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* object descriptions          */
name|ptext
index|[
name|oldloc
index|]
operator|.
name|seekadr
operator|=
name|seekhere
expr_stmt|;
name|ptext
index|[
name|oldloc
index|]
operator|.
name|txtlen
operator|=
name|maystart
operator|-
name|seekstart
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* random messages              */
if|if
condition|(
name|oldloc
operator|>
name|RTXSIZ
condition|)
block|{
name|printf
argument_list|(
literal|"Too many random msgs\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|rtext
index|[
name|oldloc
index|]
operator|.
name|seekadr
operator|=
name|seekhere
expr_stmt|;
name|rtext
index|[
name|oldloc
index|]
operator|.
name|txtlen
operator|=
name|maystart
operator|-
name|seekstart
expr_stmt|;
break|break;
case|case
literal|10
case|:
comment|/* class messages               */
name|ctext
index|[
name|clsses
index|]
operator|.
name|seekadr
operator|=
name|seekhere
expr_stmt|;
name|ctext
index|[
name|clsses
index|]
operator|.
name|txtlen
operator|=
name|maystart
operator|-
name|seekstart
expr_stmt|;
name|cval
index|[
name|clsses
operator|++
index|]
operator|=
name|oldloc
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* magic messages               */
if|if
condition|(
name|oldloc
operator|>
name|MAGSIZ
condition|)
block|{
name|printf
argument_list|(
literal|"Too many magic msgs\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtext
index|[
name|oldloc
index|]
operator|.
name|seekadr
operator|=
name|seekhere
expr_stmt|;
name|mtext
index|[
name|oldloc
index|]
operator|.
name|txtlen
operator|=
name|maystart
operator|-
name|seekstart
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"rdesc called with bad section\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|seekhere
operator|+=
name|maystart
operator|-
name|seekstart
expr_stmt|;
block|}
if|if
condition|(
name|locc
operator|<
literal|0
condition|)
block|{
name|outsw
operator|=
literal|0
expr_stmt|;
comment|/* turn off output              */
name|seekhere
operator|+=
literal|3
expr_stmt|;
comment|/* -1<delimiter>                */
return|return;
block|}
if|if
condition|(
name|sect
operator|!=
literal|5
operator|||
operator|(
name|locc
operator|>
literal|0
operator|&&
name|locc
operator|<
literal|100
operator|)
condition|)
block|{
if|if
condition|(
name|oldloc
operator|!=
name|locc
condition|)
comment|/* starting a new message       */
name|seekstart
operator|=
name|maystart
expr_stmt|;
name|oldloc
operator|=
name|locc
expr_stmt|;
block|}
name|FLUSHLF
expr_stmt|;
comment|/* scan the line                */
block|}
block|}
end_block

begin_macro
name|rtrav
argument_list|()
end_macro

begin_comment
comment|/* read travel table            */
end_comment

begin_block
block|{
specifier|register
name|int
name|locc
decl_stmt|;
specifier|register
name|struct
name|travlist
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|buf
index|[
literal|12
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|,
name|entries
decl_stmt|;
for|for
control|(
name|oldloc
operator|=
operator|-
literal|1
init|;
condition|;
control|)
comment|/* get another line             */
block|{
if|if
condition|(
operator|(
name|locc
operator|=
name|rnum
argument_list|()
operator|)
operator|!=
name|oldloc
operator|&&
name|oldloc
operator|>=
literal|0
condition|)
comment|/* end of entry */
block|{
name|t
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* terminate the old entry      */
comment|/*      printf("%d:%d entries\n",oldloc,entries);       */
comment|/*      twrite(oldloc);                                 */
block|}
if|if
condition|(
name|locc
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|locc
operator|!=
name|oldloc
condition|)
comment|/* getting a new entry         */
block|{
name|t
operator|=
name|travel
index|[
name|locc
index|]
operator|=
operator|(
expr|struct
name|travlist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|travlist
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      printf("New travel list for %d\n",locc);        */
name|entries
operator|=
literal|0
expr_stmt|;
name|oldloc
operator|=
name|locc
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
name|buf
init|;
condition|;
operator|*
name|s
operator|++
control|)
comment|/* get the newloc number /ASCII */
if|if
condition|(
operator|(
operator|*
name|s
operator|=
name|next
argument_list|()
operator|)
operator|==
name|TAB
operator|||
operator|*
name|s
operator|==
name|LF
condition|)
break|break;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|length
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* quad long number handling    */
comment|/*      printf("Newloc: %s (%d chars)\n",buf,len);              */
if|if
condition|(
name|len
operator|<
literal|4
condition|)
comment|/* no "m" conditions            */
block|{
name|m
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* newloc mod 1000 = newloc     */
block|}
else|else
comment|/* a long integer               */
block|{
name|n
operator|=
name|atoi
argument_list|(
name|buf
operator|+
name|len
operator|-
literal|3
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* terminate newloc/1000        */
name|m
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|breakch
operator|!=
name|LF
condition|)
comment|/* only do one line at a time   */
block|{
if|if
condition|(
name|entries
operator|++
condition|)
name|t
operator|=
name|t
operator|->
name|next
operator|=
operator|(
expr|struct
name|travlist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|travlist
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|tverb
operator|=
name|rnum
argument_list|()
expr_stmt|;
comment|/* get verb from the file       */
name|t
operator|->
name|tloc
operator|=
name|n
expr_stmt|;
comment|/* table entry mod 1000         */
name|t
operator|->
name|conditions
operator|=
name|m
expr_stmt|;
comment|/* table entry / 1000           */
comment|/*      printf("entry %d for %d\n",entries,locc);       */
block|}
block|}
block|}
end_block

begin_macro
name|twrite
argument_list|(
argument|loq
argument_list|)
end_macro

begin_comment
comment|/* travel options from this loc */
end_comment

begin_decl_stmt
name|int
name|loq
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|travlist
modifier|*
name|t
decl_stmt|;
name|printf
argument_list|(
literal|"If"
argument_list|)
expr_stmt|;
name|speak
argument_list|(
operator|&
name|ltext
index|[
name|loq
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"then\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|travel
index|[
name|loq
index|]
init|;
name|t
operator|!=
literal|0
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"verb %d takes you to "
argument_list|,
name|t
operator|->
name|tverb
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|tloc
operator|<=
literal|300
condition|)
name|speak
argument_list|(
operator|&
name|ltext
index|[
name|t
operator|->
name|tloc
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|tloc
operator|<=
literal|500
condition|)
name|printf
argument_list|(
literal|"special code %d\n"
argument_list|,
name|t
operator|->
name|tloc
operator|-
literal|300
argument_list|)
expr_stmt|;
else|else
name|rspeak
argument_list|(
name|t
operator|->
name|tloc
operator|-
literal|500
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"under conditions %d\n"
argument_list|,
name|t
operator|->
name|conditions
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rvoc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* read the vocabulary          */
specifier|register
name|int
name|index
decl_stmt|;
name|char
name|buf
index|[
literal|6
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|index
operator|=
name|rnum
argument_list|()
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
break|break;
for|for
control|(
name|s
operator|=
name|buf
operator|,
operator|*
name|s
operator|=
literal|0
init|;
condition|;
name|s
operator|++
control|)
comment|/* get the word                 */
if|if
condition|(
operator|(
operator|*
name|s
operator|=
name|next
argument_list|()
operator|)
operator|==
name|TAB
operator|||
operator|*
name|s
operator|==
literal|'\n'
operator|||
operator|*
name|s
operator|==
name|LF
operator|||
operator|*
name|s
operator|==
literal|' '
condition|)
break|break;
comment|/* terminate word with newline, LF, tab, blank  */
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
name|LF
condition|)
name|FLUSHLF
expr_stmt|;
comment|/* can be comments    */
operator|*
name|s
operator|=
literal|0
expr_stmt|;
comment|/*      printf("\"%s\"=%d\n",buf,index);*/
name|vocab
argument_list|(
name|buf
argument_list|,
operator|-
literal|2
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|/*	prht();	*/
block|}
end_block

begin_macro
name|rlocs
argument_list|()
end_macro

begin_comment
comment|/* initial object locations     */
end_comment

begin_block
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|obj
operator|=
name|rnum
argument_list|()
operator|)
operator|<
literal|0
condition|)
break|break;
name|plac
index|[
name|obj
index|]
operator|=
name|rnum
argument_list|()
expr_stmt|;
comment|/* initial loc for this obj     */
if|if
condition|(
name|breakch
operator|==
name|TAB
condition|)
comment|/* there's another entry        */
name|fixd
index|[
name|obj
index|]
operator|=
name|rnum
argument_list|()
expr_stmt|;
else|else
name|fixd
index|[
name|obj
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rdflt
argument_list|()
end_macro

begin_comment
comment|/* default verb messages        */
end_comment

begin_block
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|verb
operator|=
name|rnum
argument_list|()
operator|)
operator|<
literal|0
condition|)
break|break;
name|actspk
index|[
name|verb
index|]
operator|=
name|rnum
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rliq
argument_list|()
end_macro

begin_comment
comment|/* liquid assets&c: cond bits  */
end_comment

begin_block
block|{
specifier|register
name|int
name|bitnum
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
comment|/* read new bit list            */
block|{
if|if
condition|(
operator|(
name|bitnum
operator|=
name|rnum
argument_list|()
operator|)
operator|<
literal|0
condition|)
break|break;
for|for
control|(
init|;
condition|;
control|)
comment|/* read locs for bits           */
block|{
name|cond
index|[
name|rnum
argument_list|()
index|]
operator||=
name|setbit
index|[
name|bitnum
index|]
expr_stmt|;
if|if
condition|(
name|breakch
operator|==
name|LF
condition|)
break|break;
block|}
block|}
block|}
end_block

begin_macro
name|rhints
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|hintnum
decl_stmt|,
name|i
decl_stmt|;
name|hntmax
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|hintnum
operator|=
name|rnum
argument_list|()
operator|)
operator|<
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|hints
index|[
name|hintnum
index|]
index|[
name|i
index|]
operator|=
name|rnum
argument_list|()
expr_stmt|;
if|if
condition|(
name|hintnum
operator|>
name|hntmax
condition|)
name|hntmax
operator|=
name|hintnum
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rspeak
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|msg
operator|!=
literal|0
condition|)
name|speak
argument_list|(
operator|&
name|rtext
index|[
name|msg
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|mspeak
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|msg
operator|!=
literal|0
condition|)
name|speak
argument_list|(
operator|&
name|mtext
index|[
name|msg
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|doseek
argument_list|(
argument|offset
argument_list|)
end_macro

begin_comment
comment|/* do 2 seeks to get to right place in the file         */
end_comment

begin_decl_stmt
name|unsigned
name|offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|unsigned
name|filesize
decl_stmt|;
name|lseek
argument_list|(
name|datfd
argument_list|,
operator|(
name|long
operator|)
name|offset
operator|+
operator|(
name|long
operator|)
name|filesize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|blockadr
operator|=
name|chadr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
comment|/* right place is offset+filesize*/
block|{
name|blockadr
operator|+=
literal|64
expr_stmt|;
comment|/* take off 32768 bytes         */
name|chadr
operator|+=
name|offset
operator|+
literal|32768
expr_stmt|;
comment|/*& make them into 64 blocks   */
block|}
else|else
name|chadr
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|filesize
operator|<
literal|0
condition|)
comment|/* data starts after file       */
block|{
name|blockadr
operator|+=
literal|64
expr_stmt|;
comment|/* which may also be large      */
name|chadr
operator|+=
name|filesize
operator|+
literal|32768
expr_stmt|;
block|}
else|else
name|chadr
operator|+=
name|filesize
expr_stmt|;
if|if
condition|(
name|chadr
operator|<
literal|0
condition|)
comment|/* and the leftovers may be lge */
block|{
name|blockadr
operator|+=
literal|64
expr_stmt|;
name|chadr
operator|+=
literal|32768
expr_stmt|;
block|}
name|seek
argument_list|(
name|datfd
argument_list|,
name|blockadr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* get within 32767             */
name|seek
argument_list|(
name|datfd
argument_list|,
name|chadr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* then the rest of the way     */
endif|#
directive|endif
block|}
end_block

begin_macro
name|speak
argument_list|(
argument|msg
argument_list|)
end_macro

begin_comment
comment|/* read, decrypt, and print a message (not ptext)      */
end_comment

begin_decl_stmt
name|struct
name|text
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* msg is a pointer to seek address and length of mess */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
name|nonfirst
decl_stmt|;
specifier|register
name|char
modifier|*
name|tbuf
decl_stmt|;
name|doseek
argument_list|(
name|msg
operator|->
name|seekadr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|msg
operator|->
name|txtlen
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|bug
argument_list|(
literal|109
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|datfd
argument_list|,
name|tbuf
argument_list|,
name|msg
operator|->
name|txtlen
argument_list|)
expr_stmt|;
name|s
operator|=
name|tbuf
expr_stmt|;
name|nonfirst
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|s
operator|-
name|tbuf
operator|<
name|msg
operator|->
name|txtlen
condition|)
comment|/* read a line at a time        */
block|{
name|tape
operator|=
name|iotape
expr_stmt|;
comment|/* restart decryption tape      */
while|while
condition|(
operator|(
operator|*
name|s
operator|++
operator|^
operator|*
name|tape
operator|++
operator|)
operator|!=
name|TAB
condition|)
empty_stmt|;
comment|/* read past loc num       */
comment|/* assume tape is longer than location number           */
comment|/*   plus the lookahead put together                    */
if|if
condition|(
operator|(
operator|*
name|s
operator|^
operator|*
name|tape
operator|)
operator|==
literal|'>'
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|^
operator|*
operator|(
name|tape
operator|+
literal|1
operator|)
operator|)
operator|==
literal|'$'
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
operator|^
operator|*
operator|(
name|tape
operator|+
literal|2
operator|)
operator|)
operator|==
literal|'<'
condition|)
break|break;
if|if
condition|(
name|blklin
operator|&&
operator|!
name|nonfirst
operator|++
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|tape
operator|==
literal|0
condition|)
name|tape
operator|=
name|iotape
expr_stmt|;
comment|/* rewind decryp tape */
name|putchar
argument_list|(
operator|*
name|s
operator|^
operator|*
name|tape
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|s
operator|++
operator|^
operator|*
name|tape
operator|++
operator|)
operator|!=
name|LF
condition|)
do|;
comment|/* better end with LF   */
block|}
name|free
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pspeak
argument_list|(
argument|msg
argument_list|,
argument|skip
argument_list|)
end_macro

begin_comment
comment|/* read, decrypt an print a ptext message              */
end_comment

begin_decl_stmt
name|int
name|msg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* msg is the number of all the p msgs for this place  */
end_comment

begin_decl_stmt
name|int
name|skip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assumes object 1 doesn't have prop 1, obj 2 no prop 2&c*/
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
name|nonfirst
decl_stmt|;
specifier|register
name|char
modifier|*
name|tbuf
decl_stmt|;
name|char
modifier|*
name|numst
decl_stmt|;
name|int
name|lstr
decl_stmt|;
name|doseek
argument_list|(
name|ptext
index|[
name|msg
index|]
operator|.
name|seekadr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|lstr
operator|=
name|ptext
index|[
name|msg
index|]
operator|.
name|txtlen
operator|)
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|bug
argument_list|(
literal|108
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|datfd
argument_list|,
name|tbuf
argument_list|,
name|lstr
argument_list|)
expr_stmt|;
name|s
operator|=
name|tbuf
expr_stmt|;
name|nonfirst
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|s
operator|-
name|tbuf
operator|<
name|lstr
condition|)
comment|/* read a line at a time        */
block|{
name|tape
operator|=
name|iotape
expr_stmt|;
comment|/* restart decryption tape      */
for|for
control|(
name|numst
operator|=
name|s
init|;
operator|(
operator|*
name|s
operator|^=
operator|*
name|tape
operator|++
operator|)
operator|!=
name|TAB
condition|;
name|s
operator|++
control|)
empty_stmt|;
comment|/* get number  */
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* decrypting number within the string          */
if|if
condition|(
name|atoi
argument_list|(
name|numst
argument_list|)
operator|!=
literal|100
operator|*
name|skip
operator|&&
name|skip
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
operator|*
name|s
operator|++
operator|^
operator|*
name|tape
operator|++
operator|)
operator|!=
name|LF
condition|)
comment|/* flush the line    */
if|if
condition|(
operator|*
name|tape
operator|==
literal|0
condition|)
name|tape
operator|=
name|iotape
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
operator|*
name|s
operator|^
operator|*
name|tape
operator|)
operator|==
literal|'>'
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|^
operator|*
operator|(
name|tape
operator|+
literal|1
operator|)
operator|)
operator|==
literal|'$'
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
operator|^
operator|*
operator|(
name|tape
operator|+
literal|2
operator|)
operator|)
operator|==
literal|'<'
condition|)
break|break;
if|if
condition|(
name|blklin
operator|&&
operator|!
name|nonfirst
operator|++
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|tape
operator|==
literal|0
condition|)
name|tape
operator|=
name|iotape
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|s
operator|^
operator|*
name|tape
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|s
operator|++
operator|^
operator|*
name|tape
operator|++
operator|)
operator|!=
name|LF
condition|)
do|;
comment|/* better end with LF   */
if|if
condition|(
name|skip
operator|<
literal|0
condition|)
break|break;
block|}
name|free
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

