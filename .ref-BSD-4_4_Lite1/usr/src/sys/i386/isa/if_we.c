begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Tim L. Tucker.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)if_we.c	8.1 (Berkeley) 6/11/93  */
end_comment

begin_comment
comment|/*  * Modification history  *  * 8/28/89 - Initial version(if_wd.c), Tim L Tucker  */
end_comment

begin_include
include|#
directive|include
file|"we.h"
end_include

begin_if
if|#
directive|if
name|NWE
operator|>
literal|0
end_if

begin_comment
comment|/*  * Western Digital 8003 ethernet/starlan adapter  *  * Supports the following interface cards:  * WD8003E, WD8003EBT, WD8003S, WD8003SBT, WD8013EBT  *  * The Western Digital card is one of many AT/MCA ethernet interfaces  * based on the National DS8390 Network Interface chip set.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/if_wereg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_comment
comment|/*  * This constant should really be 60 because the we adds 4 bytes of crc.  * However when set to 60 our packets are ignored by deuna's , 3coms are  * okay ??????????????????????????????????????????  */
end_comment

begin_define
define|#
directive|define
name|ETHER_MIN_LEN
value|64
end_define

begin_define
define|#
directive|define
name|ETHER_ADDR_LEN
value|6
end_define

begin_define
define|#
directive|define
name|ETHER_HDR_SIZE
value|14
end_define

begin_comment
comment|/*  * Ethernet software status per interface.  *  * Each interface is referenced by a network interface structure,  * qe_if, which the routing code uses to locate the interface.  * This structure contains the output queue for the interface, its address, ...  */
end_comment

begin_struct
struct|struct
name|we_softc
block|{
name|struct
name|arpcom
name|we_ac
decl_stmt|;
comment|/* Ethernet common part 	*/
define|#
directive|define
name|we_if
value|we_ac.ac_if
comment|/* network-visible interface 	*/
define|#
directive|define
name|we_addr
value|we_ac.ac_enaddr
comment|/* hardware Ethernet address 	*/
name|u_char
name|we_flags
decl_stmt|;
comment|/* software state		*/
define|#
directive|define
name|WDF_RUNNING
value|0x01
define|#
directive|define
name|WDF_TXBUSY
value|0x02
name|u_char
name|we_type
decl_stmt|;
comment|/* interface type code		*/
name|u_short
name|we_vector
decl_stmt|;
comment|/* interrupt vector 		*/
name|short
name|we_io_ctl_addr
decl_stmt|;
comment|/* i/o bus address, control	*/
name|short
name|we_io_nic_addr
decl_stmt|;
comment|/* i/o bus address, DS8390	*/
name|caddr_t
name|we_vmem_addr
decl_stmt|;
comment|/* card RAM virtual memory base */
name|u_long
name|we_vmem_size
decl_stmt|;
comment|/* card RAM bytes		*/
name|caddr_t
name|we_vmem_ring
decl_stmt|;
comment|/* receive ring RAM vaddress	*/
name|caddr_t
name|we_vmem_end
decl_stmt|;
comment|/* receive ring RAM end	*/
block|}
name|we_softc
index|[
name|NWE
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|weprobe
argument_list|()
decl_stmt|,
name|weattach
argument_list|()
decl_stmt|,
name|weintr
argument_list|()
decl_stmt|,
name|westart
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|weinit
argument_list|()
decl_stmt|,
name|ether_output
argument_list|()
decl_stmt|,
name|weioctl
argument_list|()
decl_stmt|,
name|wereset
argument_list|()
decl_stmt|,
name|wewatchdog
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|wedriver
init|=
block|{
name|weprobe
block|,
name|weattach
block|,
literal|"we"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Probe the WD8003 to see if it's there  */
end_comment

begin_macro
name|weprobe
argument_list|(
argument|is
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|is
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|is
operator|->
name|id_unit
index|]
decl_stmt|;
name|union
name|we_mem_sel
name|wem
decl_stmt|;
name|u_char
name|sum
decl_stmt|;
comment|/* 	 * Here we check the card ROM, if the checksum passes, and the 	 * type code and ethernet address check out, then we know we have 	 * a wd8003 card. 	 * 	 * Autoconfiguration: No warning message is printed on error. 	 */
for|for
control|(
name|sum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|sum
operator|+=
name|inb
argument_list|(
name|is
operator|->
name|id_iobase
operator|+
name|WD_ROM_OFFSET
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
name|WD_CHECKSUM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|we_type
operator|=
name|inb
argument_list|(
name|is
operator|->
name|id_iobase
operator|+
name|WD_ROM_OFFSET
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|we_type
operator|!=
name|WD_ETHER
operator|)
operator|&&
operator|(
name|sc
operator|->
name|we_type
operator|!=
name|WD_STARLAN
operator|)
operator|&&
operator|(
name|sc
operator|->
name|we_type
operator|!=
name|WD_ETHER2
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Setup card RAM area and i/o addresses 	 * Kernel Virtual to segment C0000-DFFFF????? 	 */
name|sc
operator|->
name|we_io_ctl_addr
operator|=
name|is
operator|->
name|id_iobase
expr_stmt|;
name|sc
operator|->
name|we_io_nic_addr
operator|=
name|sc
operator|->
name|we_io_ctl_addr
operator|+
name|WD_NIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|we_vector
operator|=
name|is
operator|->
name|id_irq
expr_stmt|;
name|sc
operator|->
name|we_vmem_addr
operator|=
operator|(
name|caddr_t
operator|)
name|is
operator|->
name|id_maddr
expr_stmt|;
name|sc
operator|->
name|we_vmem_size
operator|=
name|is
operator|->
name|id_msize
expr_stmt|;
name|sc
operator|->
name|we_vmem_ring
operator|=
name|sc
operator|->
name|we_vmem_addr
operator|+
operator|(
name|WD_PAGE_SIZE
operator|*
name|WD_TXBUF_SIZE
operator|)
expr_stmt|;
name|sc
operator|->
name|we_vmem_end
operator|=
name|sc
operator|->
name|we_vmem_addr
operator|+
name|is
operator|->
name|id_msize
expr_stmt|;
comment|/* 	 * Save board ROM station address 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|we_addr
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_ctl_addr
operator|+
name|WD_ROM_OFFSET
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Mapin interface memory, setup memory select register 	 */
comment|/* wem.ms_addr = (u_long)sc->we_vmem_addr>> 13; */
name|wem
operator|.
name|ms_addr
operator|=
call|(
name|u_long
call|)
argument_list|(
literal|0xd0000
argument_list|)
operator|>>
literal|13
expr_stmt|;
name|wem
operator|.
name|ms_enable
operator|=
literal|1
expr_stmt|;
name|wem
operator|.
name|ms_reset
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_ctl_addr
argument_list|,
name|wem
operator|.
name|ms_byte
argument_list|)
expr_stmt|;
comment|/* 	 * clear interface memory, then sum to make sure its valid 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|we_vmem_size
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|we_vmem_addr
index|[
name|i
index|]
operator|=
literal|0x0
expr_stmt|;
for|for
control|(
name|sum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|we_vmem_size
condition|;
operator|++
name|i
control|)
name|sum
operator|+=
name|sc
operator|->
name|we_vmem_addr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
literal|0x0
condition|)
block|{
name|printf
argument_list|(
literal|"we%d: wd8003 dual port RAM address error\n"
argument_list|,
name|is
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|WD_IO_PORTS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interface exists: make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  */
end_comment

begin_macro
name|weattach
argument_list|(
argument|is
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|is
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|is
operator|->
name|id_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|we_if
decl_stmt|;
name|union
name|we_command
name|wecmd
decl_stmt|;
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_stp
operator|=
literal|1
expr_stmt|;
name|wecmd
operator|.
name|cs_sta
operator|=
literal|0
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize ifnet structure 	 */
name|ifp
operator|->
name|if_unit
operator|=
name|is
operator|->
name|id_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"we"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_NOTRAILERS
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|weinit
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|westart
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|weioctl
expr_stmt|;
name|ifp
operator|->
name|if_reset
operator|=
name|wereset
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|wewatchdog
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Banner... 	 */
name|printf
argument_list|(
literal|" %s address %s"
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|we_type
operator|!=
name|WD_STARLAN
operator|)
condition|?
literal|"ethernet"
else|:
literal|"starlan"
operator|)
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|we_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Reset of interface.  */
end_comment

begin_macro
name|wereset
argument_list|(
argument|unit
argument_list|,
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|unit
operator|>=
name|NWE
condition|)
return|return;
name|printf
argument_list|(
literal|"we%d: reset\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/*	we_softc[unit].we_flags&= ~WDF_RUNNING; */
name|weinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Take interface offline.  */
end_comment

begin_macro
name|westop
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|unit
index|]
decl_stmt|;
name|union
name|we_command
name|wecmd
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Shutdown DS8390 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_stp
operator|=
literal|1
expr_stmt|;
name|wecmd
operator|.
name|cs_sta
operator|=
literal|0
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|wewatchdog
argument_list|(
argument|unit
argument_list|)
end_macro

begin_block
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"we%d: soft reset\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|westop
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|weinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|Bdry
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Initialization of interface (really just DS8390).   */
end_comment

begin_macro
name|weinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|we_if
decl_stmt|;
name|union
name|we_command
name|wecmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
comment|/* address not known */
if|if
condition|(
name|ifp
operator|->
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* already running */
comment|/*if (ifp->if_flags& IFF_RUNNING) return; */
comment|/* 	 * Initialize DS8390 in order given in NSC NIC manual. 	 * this is stock code...please see the National manual for details. 	 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|Bdry
operator|=
literal|0
expr_stmt|;
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_stp
operator|=
literal|1
expr_stmt|;
name|wecmd
operator|.
name|cs_sta
operator|=
literal|0
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_DCR
argument_list|,
name|WD_D_CONFIG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_RBCR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_RBCR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_RCR
argument_list|,
name|WD_R_MON
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_TCR
argument_list|,
name|WD_T_CONFIG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_TPSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_PSTART
argument_list|,
name|WD_TXBUF_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_PSTOP
argument_list|,
name|sc
operator|->
name|we_vmem_size
operator|/
name|WD_PAGE_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_BNRY
argument_list|,
name|WD_TXBUF_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_ISR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_IMR
argument_list|,
name|WD_I_CONFIG
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P1_PAR0
operator|+
name|i
argument_list|,
name|sc
operator|->
name|we_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
comment|/* == broadcast addr */
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P1_MAR0
operator|+
name|i
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P1_CURR
argument_list|,
name|WD_TXBUF_SIZE
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|wecmd
operator|.
name|cs_stp
operator|=
literal|0
expr_stmt|;
name|wecmd
operator|.
name|cs_sta
operator|=
literal|1
expr_stmt|;
name|wecmd
operator|.
name|cs_rd
operator|=
literal|0x4
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P1_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_RCR
argument_list|,
name|WD_R_CONFIG
argument_list|)
expr_stmt|;
comment|/* 	 * Take the interface out of reset, program the vector,  	 * enable interrupts, and tell the world we are up. 	 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|sc
operator|->
name|we_flags
operator|&=
operator|~
name|WDF_TXBUSY
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|westart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start output on interface.  */
end_comment

begin_macro
name|westart
argument_list|(
argument|ifp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
specifier|register
name|caddr_t
name|buffer
decl_stmt|;
name|int
name|len
decl_stmt|,
name|s
decl_stmt|;
name|union
name|we_command
name|wecmd
decl_stmt|;
comment|/* 	 * The DS8390 has only one transmit buffer, if it is busy we 	 * must wait until the transmit interrupt completes. 	 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|we_flags
operator|&
name|WDF_TXBUSY
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|we_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|we_flags
operator||=
name|WDF_TXBUSY
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the mbuf chain into the transmit buffer 	 */
name|buffer
operator|=
name|sc
operator|->
name|we_vmem_addr
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m0
operator|=
name|m
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* 	 * Init transmit length registers, and set transmit start flag. 	 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|len
operator|=
name|MAX
argument_list|(
name|len
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_TBCR0
argument_list|,
name|len
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_TBCR1
argument_list|,
name|len
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_txp
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Ethernet interface interrupt processor  */
end_comment

begin_macro
name|weintr
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|unit
index|]
decl_stmt|;
name|union
name|we_command
name|wecmd
decl_stmt|;
name|union
name|we_interrupt
name|weisr
decl_stmt|;
name|int
name|nloops
init|=
literal|10
decl_stmt|;
name|unit
operator|=
literal|0
expr_stmt|;
comment|/* disable onboard interrupts, then get interrupt status */
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|weisr
operator|.
name|is_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_ISR
argument_list|)
expr_stmt|;
name|loop
label|:
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_ISR
argument_list|,
name|weisr
operator|.
name|is_byte
argument_list|)
expr_stmt|;
comment|/* transmit error */
if|if
condition|(
name|weisr
operator|.
name|is_txe
condition|)
block|{
comment|/* need to read these registers to clear status */
name|sc
operator|->
name|we_if
operator|.
name|if_collisions
operator|+=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_TBCR0
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|we_if
operator|.
name|if_oerrors
expr_stmt|;
block|}
comment|/* receiver error */
if|if
condition|(
name|weisr
operator|.
name|is_rxe
condition|)
block|{
comment|/* need to read these registers to clear status */
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
literal|0xD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
literal|0xE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
literal|0xF
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|we_if
operator|.
name|if_ierrors
expr_stmt|;
block|}
comment|/* normal transmit complete */
if|if
condition|(
name|weisr
operator|.
name|is_ptx
operator|||
name|weisr
operator|.
name|is_txe
condition|)
name|wetint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* normal receive notification */
if|if
condition|(
name|weisr
operator|.
name|is_prx
operator|||
name|weisr
operator|.
name|is_rxe
condition|)
name|werint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* try to start transmit */
name|westart
argument_list|(
operator|&
name|sc
operator|->
name|we_if
argument_list|)
expr_stmt|;
comment|/* re-enable onboard interrupts */
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_IMR
argument_list|,
literal|0xff
comment|/*WD_I_CONFIG*/
argument_list|)
expr_stmt|;
name|weisr
operator|.
name|is_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_ISR
argument_list|)
expr_stmt|;
if|if
condition|(
name|weisr
operator|.
name|is_byte
condition|)
block|{
comment|/* 		 * I caught it looping forever here a couple of times, 		 * but I haven't had time to figure out why.  Just 		 * returning seems to be safe, and it does not appear 		 * to interfere with future packets.    - Pace 5/19/92 		 */
if|if
condition|(
operator|--
name|nloops
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"we0: weintr is looping\n"
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|loop
goto|;
block|}
block|}
end_block

begin_comment
comment|/*  * Ethernet interface transmit interrupt.  */
end_comment

begin_macro
name|wetint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|unit
index|]
decl_stmt|;
comment|/* 	 * Do some statistics (assume page zero of NIC mapped in) 	 */
name|sc
operator|->
name|we_flags
operator|&=
operator|~
name|WDF_TXBUSY
expr_stmt|;
name|sc
operator|->
name|we_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
operator|++
name|sc
operator|->
name|we_if
operator|.
name|if_opackets
expr_stmt|;
name|sc
operator|->
name|we_if
operator|.
name|if_collisions
operator|+=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_TBCR0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Ethernet interface receiver interrupt.  */
end_comment

begin_macro
name|werint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|unit
index|]
decl_stmt|;
name|u_char
name|bnry
decl_stmt|,
name|curr
decl_stmt|;
name|long
name|len
decl_stmt|;
name|union
name|we_command
name|wecmd
decl_stmt|;
name|struct
name|we_ring
modifier|*
name|wer
decl_stmt|;
comment|/* 	 * Traverse the receive ring looking for packets to pass back. 	 * The search is complete when we find a descriptor not in use. 	 */
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|bnry
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_BNRY
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|curr
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P1_CURR
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bdry
condition|)
name|bnry
operator|=
name|Bdry
expr_stmt|;
while|while
condition|(
name|bnry
operator|!=
name|curr
condition|)
block|{
comment|/* get pointer to this buffer header structure */
name|wer
operator|=
operator|(
expr|struct
name|we_ring
operator|*
operator|)
operator|(
name|sc
operator|->
name|we_vmem_addr
operator|+
operator|(
name|bnry
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
comment|/* count includes CRC */
name|len
operator|=
name|wer
operator|->
name|we_count
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|30
operator|&&
name|len
operator|<=
name|ETHERMTU
operator|+
literal|100
comment|/*&& (*(char *)wer  == 1 || *(char *) wer == 0x21)*/
condition|)
name|weread
argument_list|(
name|sc
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|wer
operator|+
literal|1
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"reject %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outofbufs
label|:
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
comment|/* advance on chip Boundry register */
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|wer
operator|+
name|WD_PAGE_SIZE
operator|-
literal|1
operator|>
name|sc
operator|->
name|we_vmem_end
condition|)
block|{
name|bnry
operator|=
name|WD_TXBUF_SIZE
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_BNRY
argument_list|,
name|sc
operator|->
name|we_vmem_size
operator|/
name|WD_PAGE_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>
literal|30
operator|&&
name|len
operator|<=
name|ETHERMTU
operator|+
literal|100
condition|)
name|bnry
operator|=
name|wer
operator|->
name|we_next_packet
expr_stmt|;
else|else
name|bnry
operator|=
name|curr
expr_stmt|;
comment|/* watch out for NIC overflow, reset Boundry if invalid */
if|if
condition|(
operator|(
name|bnry
operator|-
literal|1
operator|)
operator|<
name|WD_TXBUF_SIZE
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_BNRY
argument_list|,
operator|(
name|sc
operator|->
name|we_vmem_size
operator|/
name|WD_PAGE_SIZE
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bnry
operator|=
name|WD_TXBUF_SIZE
expr_stmt|;
block|}
else|else
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_BNRY
argument_list|,
name|bnry
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* refresh our copy of CURR */
name|wecmd
operator|.
name|cs_ps
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|curr
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P1_CURR
argument_list|)
expr_stmt|;
block|}
name|Bdry
operator|=
name|bnry
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|shit
end_ifdef

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_expr_stmt
name|weioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|weinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|we_addr
operator|)
expr_stmt|;
else|else
name|wesetaddr
argument_list|(
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|we_flags
operator|&
name|WDF_RUNNING
operator|)
condition|)
block|{
name|westop
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
name|IFF_UP
operator|)
operator|&&
operator|(
operator|(
name|sc
operator|->
name|we_flags
operator|&
name|WDF_RUNNING
operator|)
operator|==
literal|0
operator|)
condition|)
name|weinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_expr_stmt
name|weioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|weinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|ns_addr
operator|)
expr_stmt|;
else|else
block|{
comment|/*  				 * The manual says we can't change the address  				 * while the receiver is armed, 				 * so reset everything 				 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|ns_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|ns_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|weinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* does ne_setaddr() */
break|break;
block|}
endif|#
directive|endif
default|default:
name|weinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|westop
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|weinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|notdef
case|case
name|SIOCGHWADDR
case|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * set ethernet address for unit  */
end_comment

begin_macro
name|wesetaddr
argument_list|(
argument|physaddr
argument_list|,
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|physaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Rewrite ethernet address, and then force restart of NIC 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|we_addr
index|[
name|i
index|]
operator|=
name|physaddr
index|[
name|i
index|]
expr_stmt|;
name|sc
operator|->
name|we_flags
operator|&=
operator|~
name|WDF_RUNNING
expr_stmt|;
name|weinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|wedataaddr
parameter_list|(
name|sc
parameter_list|,
name|eh
parameter_list|,
name|off
parameter_list|,
name|type
parameter_list|)
define|\
value|((type) ((caddr_t)((eh)+1)+(off)>= (sc)->we_vmem_end) ? \ 		(((caddr_t)((eh)+1)+(off))) - (sc)->we_vmem_end \ 		+ (sc)->we_vmem_ring: \ 		((caddr_t)((eh)+1)+(off)))
end_define

begin_comment
comment|/*  * Pass a packet to the higher levels.  * We deal with the trailer protocol here.  */
end_comment

begin_expr_stmt
name|weread
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
specifier|register
expr|struct
name|we_softc
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|weget
argument_list|()
decl_stmt|;
name|int
name|off
decl_stmt|,
name|resid
decl_stmt|;
comment|/* 	 * Deal with trailer protocol: if type is trailer type 	 * get true type from first 16-bit word past data. 	 * Remember that type was trailer by setting off. 	 */
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|buf
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|>=
name|ETHERTYPE_TRAIL
operator|&&
name|eh
operator|->
name|ether_type
operator|<
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
condition|)
block|{
name|off
operator|=
operator|(
name|eh
operator|->
name|ether_type
operator|-
name|ETHERTYPE_TRAIL
operator|)
operator|*
literal|512
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|ETHERMTU
condition|)
return|return;
comment|/* sanity */
name|eh
operator|->
name|ether_type
operator|=
name|ntohs
argument_list|(
operator|*
name|wedataaddr
argument_list|(
name|sc
argument_list|,
name|eh
argument_list|,
name|off
argument_list|,
name|u_short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|resid
operator|=
name|ntohs
argument_list|(
operator|*
operator|(
name|wedataaddr
argument_list|(
name|sc
argument_list|,
name|eh
argument_list|,
name|off
operator|+
literal|2
argument_list|,
name|u_short
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|resid
operator|>
name|len
condition|)
return|return;
comment|/* sanity */
name|len
operator|=
name|off
operator|+
name|resid
expr_stmt|;
block|}
else|else
name|off
operator|=
literal|0
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return;
comment|/* 	 * Pull packet off interface.  Off is nonzero if packet 	 * has trailing header; neget will then force this header 	 * information to be at the front, but we still have to drop 	 * the type and length which are at the front of any trailer data. 	 */
name|m
operator|=
name|weget
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|off
argument_list|,
operator|&
name|sc
operator|->
name|we_if
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|we_if
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Supporting routines  */
end_comment

begin_comment
comment|/*  * Pull read data off a interface.  * Len is length of data, with local net header stripped.  * Off is non-zero if a trailer protocol was used, and  * gives the offset of the trailer information.  * We copy the trailer information and then all the normal  * data into mbufs.  When full cluster sized units are present  * we copy into clusters.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|weget
parameter_list|(
name|buf
parameter_list|,
name|totlen
parameter_list|,
name|off0
parameter_list|,
name|ifp
parameter_list|,
name|sc
parameter_list|)
name|caddr_t
name|buf
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|off0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|we_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|off
init|=
name|off0
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|caddr_t
name|cp
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|epkt
decl_stmt|;
name|int
name|tc
init|=
name|totlen
decl_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
name|epkt
operator|=
name|cp
operator|+
name|totlen
expr_stmt|;
if|if
condition|(
name|off
condition|)
block|{
name|cp
operator|+=
name|off
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|totlen
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
block|}
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
name|len
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|epkt
operator|-
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|m
operator|->
name|m_len
operator|=
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Place initial small packet/header at end of mbuf. 			 */
if|if
condition|(
name|len
operator|<
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
name|top
operator|==
literal|0
operator|&&
name|len
operator|+
name|max_linkhdr
operator|<=
name|m
operator|->
name|m_len
condition|)
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
else|else
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|totlen
operator|-=
name|len
expr_stmt|;
comment|/* only do up to end of buffer */
if|if
condition|(
name|cp
operator|+
name|len
operator|>
name|sc
operator|->
name|we_vmem_end
condition|)
block|{
name|unsigned
name|toend
init|=
name|sc
operator|->
name|we_vmem_end
operator|-
name|cp
decl_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|toend
argument_list|)
expr_stmt|;
name|cp
operator|=
name|sc
operator|->
name|we_vmem_ring
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|toend
argument_list|,
name|len
operator|-
name|toend
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
operator|-
name|toend
expr_stmt|;
name|epkt
operator|=
name|cp
operator|+
name|totlen
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
block|}
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|epkt
condition|)
block|{
name|cp
operator|=
name|buf
expr_stmt|;
name|epkt
operator|=
name|cp
operator|+
name|tc
expr_stmt|;
block|}
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

