begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Extended support for using errno values.    Copyright (C) 1992 Free Software Foundation, Inc.    Written by Fred Fish.  fnf@cygnus.com  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NEED_sys_errlist
end_ifndef

begin_comment
comment|/* Note that errno.h might declare sys_errlist in a way that the  * compiler might consider incompatible with our later declaration,  * perhaps by using const attributes.  So we hide the declaration  * in errno.h (if any) using a macro. */
end_comment

begin_define
define|#
directive|define
name|sys_errlist
value|sys_errlist__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NEED_sys_errlist
end_ifndef

begin_undef
undef|#
directive|undef
name|sys_errlist
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  Routines imported from standard C runtime libraries. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_function_decl
specifier|extern
name|void
modifier|*
name|malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* 4.10.3.3 */
end_comment

begin_function_decl
specifier|extern
name|void
modifier|*
name|memset
parameter_list|(
name|void
modifier|*
name|s
parameter_list|,
name|int
name|c
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* 4.11.6.1 */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__STDC__ */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Standard memory allocater */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|memset
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|NULL
value|(void *) 0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Translation table for errno values.  See intro(2) in most UNIX systems    Programmers Reference Manuals.     Note that this table is generally only accessed when it is used at runtime    to initialize errno name and message tables that are indexed by errno    value.     Not all of these errnos will exist on all systems.  This table is the only    thing that should have to be updated as new error numbers are introduced.    It's sort of ugly, but at least its portable. */
end_comment

begin_struct
specifier|static
struct|struct
name|error_info
block|{
name|int
name|value
decl_stmt|;
comment|/* The numeric value from<errno.h> */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The equivalent symbolic value */
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* Short message about this value */
block|}
name|error_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|EPERM
argument_list|)
name|EPERM
block|,
literal|"EPERM"
block|,
literal|"Not owner"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOENT
argument_list|)
name|ENOENT
block|,
literal|"ENOENT"
block|,
literal|"No such file or directory"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ESRCH
argument_list|)
name|ESRCH
block|,
literal|"ESRCH"
block|,
literal|"No such process"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EINTR
argument_list|)
name|EINTR
block|,
literal|"EINTR"
block|,
literal|"Interrupted system call"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EIO
argument_list|)
name|EIO
block|,
literal|"EIO"
block|,
literal|"I/O error"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENXIO
argument_list|)
name|ENXIO
block|,
literal|"ENXIO"
block|,
literal|"No such device or address"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|E2BIG
argument_list|)
name|E2BIG
block|,
literal|"E2BIG"
block|,
literal|"Arg list too long"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOEXEC
argument_list|)
name|ENOEXEC
block|,
literal|"ENOEXEC"
block|,
literal|"Exec format error"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBADF
argument_list|)
name|EBADF
block|,
literal|"EBADF"
block|,
literal|"Bad file number"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ECHILD
argument_list|)
name|ECHILD
block|,
literal|"ECHILD"
block|,
literal|"No child processes"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EWOULDBLOCK
argument_list|)
comment|/* Put before EAGAIN, sometimes aliased */
name|EWOULDBLOCK
block|,
literal|"EWOULDBLOCK"
block|,
literal|"Operation would block"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EAGAIN
argument_list|)
name|EAGAIN
block|,
literal|"EAGAIN"
block|,
literal|"No more processes"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOMEM
argument_list|)
name|ENOMEM
block|,
literal|"ENOMEM"
block|,
literal|"Not enough space"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EACCES
argument_list|)
name|EACCES
block|,
literal|"EACCES"
block|,
literal|"Permission denied"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EFAULT
argument_list|)
name|EFAULT
block|,
literal|"EFAULT"
block|,
literal|"Bad address"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTBLK
argument_list|)
name|ENOTBLK
block|,
literal|"ENOTBLK"
block|,
literal|"Block device required"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBUSY
argument_list|)
name|EBUSY
block|,
literal|"EBUSY"
block|,
literal|"Device busy"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EEXIST
argument_list|)
name|EEXIST
block|,
literal|"EEXIST"
block|,
literal|"File exists"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXDEV
argument_list|)
name|EXDEV
block|,
literal|"EXDEV"
block|,
literal|"Cross-device link"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENODEV
argument_list|)
name|ENODEV
block|,
literal|"ENODEV"
block|,
literal|"No such device"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTDIR
argument_list|)
name|ENOTDIR
block|,
literal|"ENOTDIR"
block|,
literal|"Not a directory"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EISDIR
argument_list|)
name|EISDIR
block|,
literal|"EISDIR"
block|,
literal|"Is a directory"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EINVAL
argument_list|)
name|EINVAL
block|,
literal|"EINVAL"
block|,
literal|"Invalid argument"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENFILE
argument_list|)
name|ENFILE
block|,
literal|"ENFILE"
block|,
literal|"File table overflow"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EMFILE
argument_list|)
name|EMFILE
block|,
literal|"EMFILE"
block|,
literal|"Too many open files"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTTY
argument_list|)
name|ENOTTY
block|,
literal|"ENOTTY"
block|,
literal|"Not a typewriter"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ETXTBSY
argument_list|)
name|ETXTBSY
block|,
literal|"ETXTBSY"
block|,
literal|"Text file busy"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EFBIG
argument_list|)
name|EFBIG
block|,
literal|"EFBIG"
block|,
literal|"File too large"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOSPC
argument_list|)
name|ENOSPC
block|,
literal|"ENOSPC"
block|,
literal|"No space left on device"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ESPIPE
argument_list|)
name|ESPIPE
block|,
literal|"ESPIPE"
block|,
literal|"Illegal seek"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EROFS
argument_list|)
name|EROFS
block|,
literal|"EROFS"
block|,
literal|"Read-only file system"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EMLINK
argument_list|)
name|EMLINK
block|,
literal|"EMLINK"
block|,
literal|"Too many links"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EPIPE
argument_list|)
name|EPIPE
block|,
literal|"EPIPE"
block|,
literal|"Broken pipe"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EDOM
argument_list|)
name|EDOM
block|,
literal|"EDOM"
block|,
literal|"Math argument out of domain of func"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ERANGE
argument_list|)
name|ERANGE
block|,
literal|"ERANGE"
block|,
literal|"Math result not representable"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOMSG
argument_list|)
name|ENOMSG
block|,
literal|"ENOMSG"
block|,
literal|"No message of desired type"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EIDRM
argument_list|)
name|EIDRM
block|,
literal|"EIDRM"
block|,
literal|"Identifier removed"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ECHRNG
argument_list|)
name|ECHRNG
block|,
literal|"ECHRNG"
block|,
literal|"Channel number out of range"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EL2NSYNC
argument_list|)
name|EL2NSYNC
block|,
literal|"EL2NSYNC"
block|,
literal|"Level 2 not synchronized"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EL3HLT
argument_list|)
name|EL3HLT
block|,
literal|"EL3HLT"
block|,
literal|"Level 3 halted"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EL3RST
argument_list|)
name|EL3RST
block|,
literal|"EL3RST"
block|,
literal|"Level 3 reset"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ELNRNG
argument_list|)
name|ELNRNG
block|,
literal|"ELNRNG"
block|,
literal|"Link number out of range"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EUNATCH
argument_list|)
name|EUNATCH
block|,
literal|"EUNATCH"
block|,
literal|"Protocol driver not attached"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOCSI
argument_list|)
name|ENOCSI
block|,
literal|"ENOCSI"
block|,
literal|"No CSI structure available"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EL2HLT
argument_list|)
name|EL2HLT
block|,
literal|"EL2HLT"
block|,
literal|"Level 2 halted"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EDEADLK
argument_list|)
name|EDEADLK
block|,
literal|"EDEADLK"
block|,
literal|"Deadlock condition"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOLCK
argument_list|)
name|ENOLCK
block|,
literal|"ENOLCK"
block|,
literal|"No record locks available"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBADE
argument_list|)
name|EBADE
block|,
literal|"EBADE"
block|,
literal|"Invalid exchange"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBADR
argument_list|)
name|EBADR
block|,
literal|"EBADR"
block|,
literal|"Invalid request descriptor"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXFULL
argument_list|)
name|EXFULL
block|,
literal|"EXFULL"
block|,
literal|"Exchange full"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOANO
argument_list|)
name|ENOANO
block|,
literal|"ENOANO"
block|,
literal|"No anode"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBADRQC
argument_list|)
name|EBADRQC
block|,
literal|"EBADRQC"
block|,
literal|"Invalid request code"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBADSLT
argument_list|)
name|EBADSLT
block|,
literal|"EBADSLT"
block|,
literal|"Invalid slot"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EDEADLOCK
argument_list|)
name|EDEADLOCK
block|,
literal|"EDEADLOCK"
block|,
literal|"File locking deadlock error"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBFONT
argument_list|)
name|EBFONT
block|,
literal|"EBFONT"
block|,
literal|"Bad font file format"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOSTR
argument_list|)
name|ENOSTR
block|,
literal|"ENOSTR"
block|,
literal|"Device not a stream"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENODATA
argument_list|)
name|ENODATA
block|,
literal|"ENODATA"
block|,
literal|"No data available"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ETIME
argument_list|)
name|ETIME
block|,
literal|"ETIME"
block|,
literal|"Timer expired"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOSR
argument_list|)
name|ENOSR
block|,
literal|"ENOSR"
block|,
literal|"Out of streams resources"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENONET
argument_list|)
name|ENONET
block|,
literal|"ENONET"
block|,
literal|"Machine is not on the network"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOPKG
argument_list|)
name|ENOPKG
block|,
literal|"ENOPKG"
block|,
literal|"Package not installed"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EREMOTE
argument_list|)
name|EREMOTE
block|,
literal|"EREMOTE"
block|,
literal|"Object is remote"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOLINK
argument_list|)
name|ENOLINK
block|,
literal|"ENOLINK"
block|,
literal|"Link has been severed"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EADV
argument_list|)
name|EADV
block|,
literal|"EADV"
block|,
literal|"Advertise error"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ESRMNT
argument_list|)
name|ESRMNT
block|,
literal|"ESRMNT"
block|,
literal|"Srmount error"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ECOMM
argument_list|)
name|ECOMM
block|,
literal|"ECOMM"
block|,
literal|"Communication error on send"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EPROTO
argument_list|)
name|EPROTO
block|,
literal|"EPROTO"
block|,
literal|"Protocol error"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EMULTIHOP
argument_list|)
name|EMULTIHOP
block|,
literal|"EMULTIHOP"
block|,
literal|"Multihop attempted"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EDOTDOT
argument_list|)
name|EDOTDOT
block|,
literal|"EDOTDOT"
block|,
literal|"RFS specific error"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBADMSG
argument_list|)
name|EBADMSG
block|,
literal|"EBADMSG"
block|,
literal|"Not a data message"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENAMETOOLONG
argument_list|)
name|ENAMETOOLONG
block|,
literal|"ENAMETOOLONG"
block|,
literal|"File name too long"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EOVERFLOW
argument_list|)
name|EOVERFLOW
block|,
literal|"EOVERFLOW"
block|,
literal|"Value too large for defined data type"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTUNIQ
argument_list|)
name|ENOTUNIQ
block|,
literal|"ENOTUNIQ"
block|,
literal|"Name not unique on network"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBADFD
argument_list|)
name|EBADFD
block|,
literal|"EBADFD"
block|,
literal|"File descriptor in bad state"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EREMCHG
argument_list|)
name|EREMCHG
block|,
literal|"EREMCHG"
block|,
literal|"Remote address changed"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ELIBACC
argument_list|)
name|ELIBACC
block|,
literal|"ELIBACC"
block|,
literal|"Can not access a needed shared library"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ELIBBAD
argument_list|)
name|ELIBBAD
block|,
literal|"ELIBBAD"
block|,
literal|"Accessing a corrupted shared library"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ELIBSCN
argument_list|)
name|ELIBSCN
block|,
literal|"ELIBSCN"
block|,
literal|".lib section in a.out corrupted"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ELIBMAX
argument_list|)
name|ELIBMAX
block|,
literal|"ELIBMAX"
block|,
literal|"Attempting to link in too many shared libraries"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ELIBEXEC
argument_list|)
name|ELIBEXEC
block|,
literal|"ELIBEXEC"
block|,
literal|"Cannot exec a shared library directly"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EILSEQ
argument_list|)
name|EILSEQ
block|,
literal|"EILSEQ"
block|,
literal|"Illegal byte sequence"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOSYS
argument_list|)
name|ENOSYS
block|,
literal|"ENOSYS"
block|,
literal|"Operation not applicable"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ELOOP
argument_list|)
name|ELOOP
block|,
literal|"ELOOP"
block|,
literal|"Too many symbolic links encountered"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ERESTART
argument_list|)
name|ERESTART
block|,
literal|"ERESTART"
block|,
literal|"Interrupted system call should be restarted"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ESTRPIPE
argument_list|)
name|ESTRPIPE
block|,
literal|"ESTRPIPE"
block|,
literal|"Streams pipe error"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTEMPTY
argument_list|)
name|ENOTEMPTY
block|,
literal|"ENOTEMPTY"
block|,
literal|"Directory not empty"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EUSERS
argument_list|)
name|EUSERS
block|,
literal|"EUSERS"
block|,
literal|"Too many users"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTSOCK
argument_list|)
name|ENOTSOCK
block|,
literal|"ENOTSOCK"
block|,
literal|"Socket operation on non-socket"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EDESTADDRREQ
argument_list|)
name|EDESTADDRREQ
block|,
literal|"EDESTADDRREQ"
block|,
literal|"Destination address required"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EMSGSIZE
argument_list|)
name|EMSGSIZE
block|,
literal|"EMSGSIZE"
block|,
literal|"Message too long"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EPROTOTYPE
argument_list|)
name|EPROTOTYPE
block|,
literal|"EPROTOTYPE"
block|,
literal|"Protocol wrong type for socket"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOPROTOOPT
argument_list|)
name|ENOPROTOOPT
block|,
literal|"ENOPROTOOPT"
block|,
literal|"Protocol not available"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EPROTONOSUPPORT
argument_list|)
name|EPROTONOSUPPORT
block|,
literal|"EPROTONOSUPPORT"
block|,
literal|"Protocol not supported"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ESOCKTNOSUPPORT
argument_list|)
name|ESOCKTNOSUPPORT
block|,
literal|"ESOCKTNOSUPPORT"
block|,
literal|"Socket type not supported"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EOPNOTSUPP
argument_list|)
name|EOPNOTSUPP
block|,
literal|"EOPNOTSUPP"
block|,
literal|"Operation not supported on transport endpoint"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EPFNOSUPPORT
argument_list|)
name|EPFNOSUPPORT
block|,
literal|"EPFNOSUPPORT"
block|,
literal|"Protocol family not supported"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EAFNOSUPPORT
argument_list|)
name|EAFNOSUPPORT
block|,
literal|"EAFNOSUPPORT"
block|,
literal|"Address family not supported by protocol"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EADDRINUSE
argument_list|)
name|EADDRINUSE
block|,
literal|"EADDRINUSE"
block|,
literal|"Address already in use"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EADDRNOTAVAIL
argument_list|)
name|EADDRNOTAVAIL
block|,
literal|"EADDRNOTAVAIL"
block|,
literal|"Cannot assign requested address"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENETDOWN
argument_list|)
name|ENETDOWN
block|,
literal|"ENETDOWN"
block|,
literal|"Network is down"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENETUNREACH
argument_list|)
name|ENETUNREACH
block|,
literal|"ENETUNREACH"
block|,
literal|"Network is unreachable"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENETRESET
argument_list|)
name|ENETRESET
block|,
literal|"ENETRESET"
block|,
literal|"Network dropped connection because of reset"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ECONNABORTED
argument_list|)
name|ECONNABORTED
block|,
literal|"ECONNABORTED"
block|,
literal|"Software caused connection abort"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ECONNRESET
argument_list|)
name|ECONNRESET
block|,
literal|"ECONNRESET"
block|,
literal|"Connection reset by peer"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOBUFS
argument_list|)
name|ENOBUFS
block|,
literal|"ENOBUFS"
block|,
literal|"No buffer space available"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EISCONN
argument_list|)
name|EISCONN
block|,
literal|"EISCONN"
block|,
literal|"Transport endpoint is already connected"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTCONN
argument_list|)
name|ENOTCONN
block|,
literal|"ENOTCONN"
block|,
literal|"Transport endpoint is not connected"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ESHUTDOWN
argument_list|)
name|ESHUTDOWN
block|,
literal|"ESHUTDOWN"
block|,
literal|"Cannot send after transport endpoint shutdown"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ETOOMANYREFS
argument_list|)
name|ETOOMANYREFS
block|,
literal|"ETOOMANYREFS"
block|,
literal|"Too many references: cannot splice"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ETIMEDOUT
argument_list|)
name|ETIMEDOUT
block|,
literal|"ETIMEDOUT"
block|,
literal|"Connection timed out"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ECONNREFUSED
argument_list|)
name|ECONNREFUSED
block|,
literal|"ECONNREFUSED"
block|,
literal|"Connection refused"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EHOSTDOWN
argument_list|)
name|EHOSTDOWN
block|,
literal|"EHOSTDOWN"
block|,
literal|"Host is down"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EHOSTUNREACH
argument_list|)
name|EHOSTUNREACH
block|,
literal|"EHOSTUNREACH"
block|,
literal|"No route to host"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EALREADY
argument_list|)
name|EALREADY
block|,
literal|"EALREADY"
block|,
literal|"Operation already in progress"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EINPROGRESS
argument_list|)
name|EINPROGRESS
block|,
literal|"EINPROGRESS"
block|,
literal|"Operation now in progress"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ESTALE
argument_list|)
name|ESTALE
block|,
literal|"ESTALE"
block|,
literal|"Stale NFS file handle"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EUCLEAN
argument_list|)
name|EUCLEAN
block|,
literal|"EUCLEAN"
block|,
literal|"Structure needs cleaning"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTNAM
argument_list|)
name|ENOTNAM
block|,
literal|"ENOTNAM"
block|,
literal|"Not a XENIX named type file"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENAVAIL
argument_list|)
name|ENAVAIL
block|,
literal|"ENAVAIL"
block|,
literal|"No XENIX semaphores available"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EISNAM
argument_list|)
name|EISNAM
block|,
literal|"EISNAM"
block|,
literal|"Is a named type file"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EREMOTEIO
argument_list|)
name|EREMOTEIO
block|,
literal|"EREMOTEIO"
block|,
literal|"Remote I/O error"
block|,
endif|#
directive|endif
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
struct|;
end_struct

begin_comment
comment|/* Translation table allocated and initialized at runtime.  Indexed by the    errno value to find the equivalent symbolic value. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|error_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_error_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table allocated and initialized at runtime, if it does not    already exist in the host environment.  Indexed by the errno value to find    the descriptive string.     We don't export it for use in other modules because even though it has the    same name, it differs from other implementations in that it is dynamically    initialized rather than statically initialized. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_sys_errlist
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|sys_errlist
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  NAME  	init_error_tables -- initialize the name and message tables  SYNOPSIS  	static void init_error_tables ();  DESCRIPTION  	Using the error_table, which is initialized at compile time, generate 	the error_names and the sys_errlist (if needed) tables, which are 	indexed at runtime by a specific errno value.  BUGS  	The initialization of the tables may fail under low memory conditions, 	in which case we don't do anything particularly useful, but we don't 	bomb either.  Who knows, it might succeed at a later point if we free 	some memory in the meantime.  In any case, the other routines know 	how to deal with lack of a table after trying to initialize it.  This 	may or may not be considered to be a bug, that we don't specifically 	warn about this particular failure mode.  */
end_comment

begin_function
specifier|static
name|void
name|init_error_tables
parameter_list|()
block|{
name|struct
name|error_info
modifier|*
name|eip
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
comment|/* If we haven't already scanned the error_table once to find the maximum      errno value, then go find it now. */
if|if
condition|(
name|num_error_names
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|eip
operator|=
name|error_table
init|;
name|eip
operator|->
name|name
operator|!=
name|NULL
condition|;
name|eip
operator|++
control|)
block|{
if|if
condition|(
name|eip
operator|->
name|value
operator|>=
name|num_error_names
condition|)
block|{
name|num_error_names
operator|=
name|eip
operator|->
name|value
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Now attempt to allocate the error_names table, zero it out, and then      initialize it from the statically initialized error_table. */
if|if
condition|(
name|error_names
operator|==
name|NULL
condition|)
block|{
name|nbytes
operator|=
name|num_error_names
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error_names
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|error_names
argument_list|,
literal|0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|eip
operator|=
name|error_table
init|;
name|eip
operator|->
name|name
operator|!=
name|NULL
condition|;
name|eip
operator|++
control|)
block|{
name|error_names
index|[
name|eip
operator|->
name|value
index|]
operator|=
name|eip
operator|->
name|name
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|NEED_sys_errlist
comment|/* Now attempt to allocate the sys_errlist table, zero it out, and then      initialize it from the statically initialized error_table. */
if|if
condition|(
name|sys_errlist
operator|==
name|NULL
condition|)
block|{
name|nbytes
operator|=
name|num_error_names
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sys_errlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|sys_errlist
argument_list|,
literal|0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|sys_nerr
operator|=
name|num_error_names
expr_stmt|;
for|for
control|(
name|eip
operator|=
name|error_table
init|;
name|eip
operator|->
name|name
operator|!=
name|NULL
condition|;
name|eip
operator|++
control|)
block|{
name|sys_errlist
index|[
name|eip
operator|->
name|value
index|]
operator|=
name|eip
operator|->
name|msg
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  NAME  	errno_max -- return the max errno value  SYNOPSIS  	int errno_max ();  DESCRIPTION  	Returns the maximum errno value for which a corresponding symbolic 	name or message is available.  Note that in the case where 	we use the sys_errlist supplied by the system, it is possible for 	there to be more symbolic names than messages, or vice versa. 	In fact, the manual page for perror(3C) explicitly warns that one 	should check the size of the table (sys_nerr) before indexing it, 	since new error codes may be added to the system before they are 	added to the table.  Thus sys_nerr might be smaller than value 	implied by the largest errno value defined in<errno.h>.  	We return the maximum value that can be used to obtain a meaningful 	symbolic name or message.  */
end_comment

begin_function
name|int
name|errno_max
parameter_list|()
block|{
name|int
name|maxsize
decl_stmt|;
if|if
condition|(
name|error_names
operator|==
name|NULL
condition|)
block|{
name|init_error_tables
argument_list|()
expr_stmt|;
block|}
name|maxsize
operator|=
name|MAX
argument_list|(
name|sys_nerr
argument_list|,
name|num_error_names
argument_list|)
expr_stmt|;
return|return
operator|(
name|maxsize
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_strerror
end_ifdef

begin_comment
comment|/*  NAME  	strerror -- map an error number to an error message string  SYNOPSIS  	char *strerror (int errnoval)  DESCRIPTION  	Maps an errno number to an error message string, the contents of 	which are implementation defined.  On systems which have the external 	variables sys_nerr and sys_errlist, these strings will be the same 	as the ones used by perror().  	If the supplied error number is within the valid range of indices 	for the sys_errlist, but no message is available for the particular 	error number, then returns the string "Error NUM", where NUM is the 	error number.  	If the supplied error number is not a valid index into sys_errlist, 	returns NULL.  	The returned string is only guaranteed to be valid only until the 	next call to strerror.  */
end_comment

begin_function
name|char
modifier|*
name|strerror
parameter_list|(
name|errnoval
parameter_list|)
name|int
name|errnoval
decl_stmt|;
block|{
name|char
modifier|*
name|msg
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NEED_sys_errlist
if|if
condition|(
name|error_names
operator|==
name|NULL
condition|)
block|{
name|init_error_tables
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|errnoval
operator|<
literal|0
operator|)
operator|||
operator|(
name|errnoval
operator|>=
name|sys_nerr
operator|)
condition|)
block|{
comment|/* Out of range, just return NULL */
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sys_errlist
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sys_errlist
index|[
name|errnoval
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* In range, but no sys_errlist or no entry at this index. */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Error %d"
argument_list|,
name|errnoval
argument_list|)
expr_stmt|;
name|msg
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* In range, and a valid message.  Just return the message. */
name|msg
operator|=
name|sys_errlist
index|[
name|errnoval
index|]
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEED_strerror */
end_comment

begin_comment
comment|/*  NAME  	strerrno -- map an error number to a symbolic name string  SYNOPSIS  	char *strerrno (int errnoval)  DESCRIPTION  	Given an error number returned from a system call (typically 	returned in errno), returns a pointer to a string containing the 	symbolic name of that error number, as found in<errno.h>.  	If the supplied error number is within the valid range of indices 	for symbolic names, but no name is available for the particular 	error number, then returns the string "Error NUM", where NUM is 	the error number.  	If the supplied error number is not within the range of valid 	indices, then returns NULL.  BUGS  	The contents of the location pointed to are only guaranteed to be 	valid until the next call to strerrno.  */
end_comment

begin_function
name|char
modifier|*
name|strerrno
parameter_list|(
name|errnoval
parameter_list|)
name|int
name|errnoval
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|error_names
operator|==
name|NULL
condition|)
block|{
name|init_error_tables
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|errnoval
operator|<
literal|0
operator|)
operator|||
operator|(
name|errnoval
operator|>=
name|num_error_names
operator|)
condition|)
block|{
comment|/* Out of range, just return NULL */
name|name
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error_names
operator|==
name|NULL
operator|)
operator|||
operator|(
name|error_names
index|[
name|errnoval
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* In range, but no error_names or no entry at this index. */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Error %d"
argument_list|,
name|errnoval
argument_list|)
expr_stmt|;
name|name
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* In range, and a valid name.  Just return the name. */
name|name
operator|=
name|error_names
index|[
name|errnoval
index|]
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  NAME  	strtoerrno -- map a symbolic errno name to a numeric value  SYNOPSIS  	int strtoerrno (char *name)  DESCRIPTION  	Given the symbolic name of a error number, map it to an errno value. 	If no translation is found, returns 0.  */
end_comment

begin_function
name|int
name|strtoerrno
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|errnoval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|error_names
operator|==
name|NULL
condition|)
block|{
name|init_error_tables
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|errnoval
operator|=
literal|0
init|;
name|errnoval
operator|<
name|num_error_names
condition|;
name|errnoval
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error_names
index|[
name|errnoval
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|error_names
index|[
name|errnoval
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|errnoval
operator|==
name|num_error_names
condition|)
block|{
name|errnoval
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|errnoval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A simple little main that does nothing but print all the errno translations    if MAIN is defined and this file is compiled and linked. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_function
name|main
parameter_list|()
block|{
name|int
name|errn
decl_stmt|;
name|int
name|errnmax
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|strerrno
parameter_list|()
function_decl|;
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
name|errnmax
operator|=
name|errno_max
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%d entries in names table.\n"
argument_list|,
name|num_error_names
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d entries in messages table.\n"
argument_list|,
name|sys_nerr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d is max useful index.\n"
argument_list|,
name|errnmax
argument_list|)
expr_stmt|;
comment|/* Keep printing values until we get to the end of *both* tables, not      *either* table.  Note that knowing the maximum useful index does *not*      relieve us of the responsibility of testing the return pointer for      NULL. */
for|for
control|(
name|errn
operator|=
literal|0
init|;
name|errn
operator|<=
name|errnmax
condition|;
name|errn
operator|++
control|)
block|{
name|name
operator|=
name|strerrno
argument_list|(
name|errn
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
literal|"<NULL>"
else|:
name|name
expr_stmt|;
name|msg
operator|=
name|strerror
argument_list|(
name|errn
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|msg
operator|==
name|NULL
operator|)
condition|?
literal|"<NULL>"
else|:
name|msg
expr_stmt|;
name|printf
argument_list|(
literal|"%-4d%-18s%s\n"
argument_list|,
name|errn
argument_list|,
name|name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

