begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * [.vms]vms_popen.c -- substitute routines for missing pipe calls.  */
end_comment

begin_comment
comment|/*  * Copyright (C) 1991 the Free Software Foundation, Inc.  *  * This file is part of GAWK, the GNU implementation of the  * AWK Progamming Language.  *  * GAWK is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * GAWK is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with GAWK; see the file COPYING.  If not, write to  * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_VMS_PIPES
end_ifndef

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_comment
comment|/* really "../awk.h" */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PIPES_SIMULATED
end_ifndef

begin_function
name|FILE
modifier|*
name|popen
parameter_list|(
specifier|const
name|char
modifier|*
name|command
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|fatal
argument_list|(
literal|" Cannot open pipe `%s' (not implemented)"
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pclose
parameter_list|(
name|FILE
modifier|*
name|current
parameter_list|)
block|{
name|fatal
argument_list|(
literal|" Internal error ('pclose' not implemented)"
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|fork
parameter_list|()
block|{
name|fatal
argument_list|(
literal|" Internal error ('fork' not implemented)"
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*PIPES_SIMULATED*/
end_comment

begin_comment
comment|/* 	 * Simulate pipes using temporary files; hope that the user 	 * doesn't expect pipe i/o to be interleaved with other i/o ;-}. 	 * 	 * This was initially based on the MSDOS version, but cannot 	 * use a static array to hold pipe info, because there's no 	 * fixed limit on the range of valid 'fileno's.  Another 	 * difference is that redirection is handled using LIB$SPAWN 	 * rather than constructing a command for system() which uses 	 * '<' or '>'. 	 */
end_comment

begin_include
include|#
directive|include
file|"vms.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<lnmdef.h>
end_include

begin_comment
comment|/* logical name definitions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|push_logicals
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_logicals
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Itm
modifier|*
name|save_translation
name|P
argument_list|(
operator|(
specifier|const
name|Dsc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restore_translation
name|P
argument_list|(
operator|(
specifier|const
name|Dsc
operator|*
operator|,
specifier|const
name|Itm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|unopened
init|=
literal|0
block|,
name|reading
block|,
name|writing
block|}
name|pipemode
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|pipe_info
block|{
name|char
modifier|*
name|command
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|pipemode
name|pmode
decl_stmt|;
block|}
name|PIPE
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|PIPE
modifier|*
name|pipes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipes_lim
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|psize
parameter_list|(
name|n
parameter_list|)
value|((n) * sizeof(PIPE))
end_define

begin_define
define|#
directive|define
name|expand_pipes
parameter_list|(
name|k
parameter_list|)
value|do {  PIPE *new_p; \ 	int new_p_lim = ((k) / _NFILE + 1) * _NFILE; \ 	emalloc(new_p, PIPE *, psize(new_p_lim), "expand_pipes"); \ 	if (pipes_lim> 0) \ 		memcpy(new_p, pipes, psize(pipes_lim)),  free(pipes); \ 	memset(new_p + psize(pipes_lim), 0, psize(new_p_lim - pipes_lim)); \ 	pipes = new_p,  pipes_lim = new_p_lim;  } while(0)
end_define

begin_function
name|FILE
modifier|*
name|popen
parameter_list|(
specifier|const
name|char
modifier|*
name|command
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|FILE
modifier|*
name|current
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|mktemp
argument_list|()
decl_stmt|;
name|int
name|cur
decl_stmt|,
name|strcmp
argument_list|()
decl_stmt|;
name|pipemode
name|curmode
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mode
argument_list|,
literal|"r"
argument_list|)
operator|==
literal|0
condition|)
name|curmode
operator|=
name|reading
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|mode
argument_list|,
literal|"w"
argument_list|)
operator|==
literal|0
condition|)
name|curmode
operator|=
name|writing
expr_stmt|;
else|else
return|return
name|NULL
return|;
comment|/* make a name for the temporary file */
if|if
condition|(
operator|(
name|name
operator|=
name|mktemp
argument_list|(
name|strdup
argument_list|(
literal|"sys$scratch:gawk-pipe_XXXXXX.tmp"
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|curmode
operator|==
name|reading
condition|)
block|{
comment|/* an input pipe reads a temporary file created by the command */
name|vms_execute
argument_list|(
name|command
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 'command>tempfile' */
block|}
if|if
condition|(
operator|(
name|current
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|,
literal|"mbc=24"
argument_list|,
literal|"mbf=2"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cur
operator|=
name|fileno
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|>=
name|pipes_lim
condition|)
name|expand_pipes
argument_list|(
name|cur
argument_list|)
expr_stmt|;
comment|/* assert( cur>= 0&& cur< pipes_lim ); */
name|pipes
index|[
name|cur
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|pipes
index|[
name|cur
index|]
operator|.
name|pmode
operator|=
name|curmode
expr_stmt|;
name|pipes
index|[
name|cur
index|]
operator|.
name|command
operator|=
name|strdup
argument_list|(
name|command
argument_list|)
expr_stmt|;
return|return
name|current
return|;
block|}
end_function

begin_function
name|int
name|pclose
parameter_list|(
name|FILE
modifier|*
name|current
parameter_list|)
block|{
name|int
name|rval
decl_stmt|,
name|cur
init|=
name|fileno
argument_list|(
name|current
argument_list|)
decl_stmt|;
comment|/* assert( cur>= 0&& cur< pipes_lim ); */
if|if
condition|(
name|pipes
index|[
name|cur
index|]
operator|.
name|pmode
operator|==
name|unopened
condition|)
return|return
operator|-
literal|1
return|;
comment|/* should never happen */
name|rval
operator|=
name|fclose
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|/* close temp file; if reading, we're done */
if|if
condition|(
name|pipes
index|[
name|cur
index|]
operator|.
name|pmode
operator|==
name|writing
condition|)
block|{
comment|/* an output pipe feeds the temporary file to the other program */
name|rval
operator|=
name|vms_execute
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|command
argument_list|,
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* clean up */
name|unlink
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* get rid of the temporary file */
name|pipes
index|[
name|cur
index|]
operator|.
name|pmode
operator|=
name|unopened
expr_stmt|;
name|free
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
operator|,
name|pipes
index|[
name|cur
index|]
operator|.
name|name
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|command
argument_list|)
operator|,
name|pipes
index|[
name|cur
index|]
operator|.
name|command
operator|=
literal|0
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*      * Create a process and execute a command in it.  This is essentially      * the same as system() but allows us to specify SYS$INPUT (stdin)      * and/or SYS$OUTPUT (stdout) for the process.      * [With more work it could truly simulate a pipe using mailboxes.]      */
end_comment

begin_function
name|int
name|vms_execute
parameter_list|(
specifier|const
name|char
modifier|*
name|command
parameter_list|,
specifier|const
name|char
modifier|*
name|input
parameter_list|,
specifier|const
name|char
modifier|*
name|output
parameter_list|)
block|{
name|Dsc
name|cmd
decl_stmt|,
name|in
decl_stmt|,
name|out
decl_stmt|,
modifier|*
name|in_p
decl_stmt|,
modifier|*
name|out_p
decl_stmt|;
name|u_long
name|sts
decl_stmt|,
name|cmpltn_sts
decl_stmt|,
name|LIB$SPAWN
argument_list|()
decl_stmt|;
name|cmd
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|cmd
operator|.
name|adr
operator|=
operator|(
name|char
operator|*
operator|)
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
condition|)
name|in
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|in
operator|.
name|adr
operator|=
operator|(
name|char
operator|*
operator|)
name|input
argument_list|)
operator|,
name|in_p
operator|=
operator|&
name|in
expr_stmt|;
else|else
name|in_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|output
condition|)
name|out
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|out
operator|.
name|adr
operator|=
operator|(
name|char
operator|*
operator|)
name|output
argument_list|)
operator|,
name|out_p
operator|=
operator|&
name|out
expr_stmt|;
else|else
name|out_p
operator|=
literal|0
expr_stmt|;
name|push_logicals
argument_list|()
expr_stmt|;
comment|/* guard against user-mode definitions of sys$Xput */
name|sts
operator|=
name|LIB$SPAWN
argument_list|(
operator|&
name|cmd
argument_list|,
name|in_p
argument_list|,
name|out_p
argument_list|,
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|Dsc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|u_long
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|cmpltn_sts
argument_list|)
expr_stmt|;
name|pop_logicals
argument_list|()
expr_stmt|;
comment|/* restore environment */
if|if
condition|(
name|vmswork
argument_list|(
name|sts
argument_list|)
operator|&&
name|vmsfail
argument_list|(
name|cmpltn_sts
argument_list|)
condition|)
name|sts
operator|=
name|cmpltn_sts
expr_stmt|;
if|if
condition|(
name|vmsfail
argument_list|(
name|sts
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EVMSERR
operator|,
name|vaxc$errno
operator|=
name|sts
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*----* 	This rigmarole is to guard against interference from the current 	environment.  User-mode definitions of SYS$INPUT and/or SYS$OUTPUT 	will interact with spawned subprocesses--including LIB$SPAWN with 	explicit input and/or output arguments specified--if they were 	defined without the 'CONFINED' attribute.  The definitions created 	in vms_args.c as part of command line I/O redirection happened to 	fall into this category :-(, but even though that's been fixed, 	there's still the possibility of the user doing something like 	 |$ define/user sys$output foo.out 	prior to starting the program.  Without ``/name_attr=confine'', 	that will really screw up pipe simulation, so we've got to work- 	around it here.  This is true whether pipes are implemented via 	mailboxes or temporary files, as long as lib$spawn() is being used.  	push_logicals() calls save_translation() the first time it's 	invoked; the latter allocates some memory to hold a full logical 	name translation and uses $trnlnm to fill that in.  Then if either 	sys$input or sys$output has a user-mode, non-confined translation, 	push_logicals() will delete the definition(s) using $dellnm. 	After the spawned command has returned, pop_logicals() is called; 	it calls restore_translation() for any deleted values; the latter 	uses $crllnm or $crelog to recreate the original definition.  	SYS$ERROR is currently ignored; perhaps it should receive the same 	treatment... *----*/
end_comment

begin_comment
comment|/* logical name table, and names of interest; these are all constant */
end_comment

begin_expr_stmt
specifier|static
specifier|const
name|Descrip
argument_list|(
name|lnmtable
argument_list|,
literal|"LNM$PROCESS_TABLE"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
specifier|const
name|Descrip
argument_list|(
name|sys_input
argument_list|,
literal|"SYS$INPUT"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
specifier|const
name|Descrip
argument_list|(
name|sys_output
argument_list|,
literal|"SYS$OUTPUT"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|acmode
init|=
name|PSL$C_USER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* only care about user-mode */
end_comment

begin_comment
comment|/* macros for simplfying the code a bunch */
end_comment

begin_define
define|#
directive|define
name|DelTrans
parameter_list|(
name|l
parameter_list|)
value|SYS$DELLNM(&lnmtable, (l),&acmode)
end_define

begin_define
define|#
directive|define
name|GetTrans
parameter_list|(
name|l
parameter_list|,
name|i
parameter_list|)
value|SYS$TRNLNM((u_long *)0,&lnmtable, (l),&acmode, (i))
end_define

begin_define
define|#
directive|define
name|SetTrans
parameter_list|(
name|l
parameter_list|,
name|i
parameter_list|)
value|SYS$CRELNM((u_long *)0,&lnmtable, (l),&acmode, (i))
end_define

begin_comment
comment|/* itemlist manipulation macros; separate versions for aggregate and scalar */
end_comment

begin_define
define|#
directive|define
name|SetItmA
parameter_list|(
name|i
parameter_list|,
name|c
parameter_list|,
name|p
parameter_list|,
name|r
parameter_list|)
value|((i).code = (c), (i).len = sizeof (p),\ 			  (i).buffer = (p), (i).retlen = (u_short *)(r))
end_define

begin_define
define|#
directive|define
name|SetItmS
parameter_list|(
name|i
parameter_list|,
name|c
parameter_list|,
name|p
parameter_list|)
value|((i).code = (c), (i).len = sizeof *(p),\ 			  (i).buffer = (p), (i).retlen = (u_short *)0)
end_define

begin_define
define|#
directive|define
name|EndItm0
parameter_list|(
name|i
parameter_list|)
value|((i).code = (i).len = 0)
end_define

begin_comment
comment|/* translate things once, then hold the results here for multiple re-use */
end_comment

begin_decl_stmt
specifier|static
name|Itm
modifier|*
name|input_definition
decl_stmt|,
modifier|*
name|output_definition
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|push_logicals
parameter_list|(
name|void
parameter_list|)
comment|/* deassign sys$input and/or sys$output */
block|{
specifier|static
name|int
name|init_done
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|init_done
condition|)
block|{
comment|/* do logical name lookups one-time only */
name|input_definition
operator|=
name|save_translation
argument_list|(
operator|&
name|sys_input
argument_list|)
expr_stmt|;
name|output_definition
operator|=
name|save_translation
argument_list|(
operator|&
name|sys_output
argument_list|)
expr_stmt|;
name|init_done
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|input_definition
condition|)
name|DelTrans
argument_list|(
operator|&
name|sys_input
argument_list|)
expr_stmt|;
comment|/* kill sys$input */
if|if
condition|(
name|output_definition
condition|)
name|DelTrans
argument_list|(
operator|&
name|sys_output
argument_list|)
expr_stmt|;
comment|/* and sys$output */
block|}
end_function

begin_function
specifier|static
name|void
name|pop_logicals
parameter_list|(
name|void
parameter_list|)
comment|/* redefine sys$input and/or sys$output */
block|{
if|if
condition|(
name|input_definition
condition|)
name|restore_translation
argument_list|(
operator|&
name|sys_input
argument_list|,
name|input_definition
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_definition
condition|)
name|restore_translation
argument_list|(
operator|&
name|sys_output
argument_list|,
name|output_definition
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Itm
modifier|*
name|save_translation
parameter_list|(
specifier|const
name|Dsc
modifier|*
name|logname
parameter_list|)
block|{
name|Itm
name|trans
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|itmlst
decl_stmt|;
name|long
name|trans_attr
decl_stmt|,
name|max_trans_indx
decl_stmt|;
comment|/* 0-based translation index count */
name|unsigned
name|char
name|trans_acmode
decl_stmt|;
comment|/* translation's access mode */
name|unsigned
name|itmlst_size
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|itmlst
operator|=
literal|0
expr_stmt|;
comment|/* Want translation index count for non-confined, user-mode definition; 	unfortunately, $trnlnm does not provide that much control.  Try to 	fetch several values of interest, then decide based on the result.      */
name|SetItmS
argument_list|(
name|trans
index|[
literal|0
index|]
argument_list|,
name|LNM$_MAX_INDEX
argument_list|,
operator|&
name|max_trans_indx
argument_list|)
operator|,
name|max_trans_indx
operator|=
operator|-
literal|1
expr_stmt|;
name|SetItmS
argument_list|(
name|trans
index|[
literal|1
index|]
argument_list|,
name|LNM$_ACMODE
argument_list|,
operator|&
name|trans_acmode
argument_list|)
operator|,
name|trans_acmode
operator|=
literal|0
expr_stmt|;
name|SetItmS
argument_list|(
name|trans
index|[
literal|2
index|]
argument_list|,
name|LNM$_ATTRIBUTES
argument_list|,
operator|&
name|trans_attr
argument_list|)
operator|,
name|trans_attr
operator|=
literal|0
expr_stmt|;
name|EndItm0
argument_list|(
name|trans
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmswork
argument_list|(
name|GetTrans
argument_list|(
name|logname
argument_list|,
name|trans
argument_list|)
argument_list|)
operator|&&
name|max_trans_indx
operator|>=
literal|0
operator|&&
name|trans_acmode
operator|==
name|PSL$C_USER
operator|&&
operator|!
operator|(
name|trans_attr
operator|&
name|LNM$M_CONFINE
operator|)
condition|)
block|{
comment|/* Now know that definition of interest exists; 	    allocate and initialize an item list and associated buffers; 	    use three entries for each translation. 	 */
name|itmlst_size
operator|=
operator|(
literal|3
operator|*
operator|(
name|max_trans_indx
operator|+
literal|1
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Itm
argument_list|)
expr_stmt|;
name|emalloc
argument_list|(
name|itmlst
argument_list|,
name|Itm
operator|*
argument_list|,
name|itmlst_size
argument_list|,
literal|"save_translation"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_trans_indx
condition|;
name|i
operator|++
control|)
block|{
struct|struct
name|def
block|{
name|u_long
name|indx
decl_stmt|,
name|attr
decl_stmt|;
name|u_short
name|len
decl_stmt|;
name|char
name|str
index|[
name|LNM$C_NAMLENGTH
index|]
decl_stmt|,
name|eos
decl_stmt|;
block|}
modifier|*
name|wrk
struct|;
name|emalloc
argument_list|(
name|wrk
argument_list|,
expr|struct
name|def
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|def
argument_list|)
argument_list|,
literal|"save_translation"
argument_list|)
expr_stmt|;
name|wrk
operator|->
name|indx
operator|=
operator|(
name|u_long
operator|)
name|i
expr_stmt|;
comment|/* this one's an input value for $trnlnm */
name|SetItmS
argument_list|(
name|itmlst
index|[
literal|3
operator|*
name|i
operator|+
literal|0
index|]
argument_list|,
name|LNM$_INDEX
argument_list|,
operator|&
name|wrk
operator|->
name|indx
argument_list|)
expr_stmt|;
name|SetItmS
argument_list|(
name|itmlst
index|[
literal|3
operator|*
name|i
operator|+
literal|1
index|]
argument_list|,
name|LNM$_ATTRIBUTES
argument_list|,
operator|&
name|wrk
operator|->
name|attr
argument_list|)
operator|,
name|wrk
operator|->
name|attr
operator|=
literal|0
expr_stmt|;
name|SetItmA
argument_list|(
name|itmlst
index|[
literal|3
operator|*
name|i
operator|+
literal|2
index|]
argument_list|,
name|LNM$_STRING
argument_list|,
operator|&
name|wrk
operator|->
name|str
argument_list|,
operator|&
name|wrk
operator|->
name|len
argument_list|)
operator|,
name|wrk
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|EndItm0
argument_list|(
name|itmlst
index|[
literal|3
operator|*
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* assert( i == max_trans_indx+1 ); */
comment|/* Time to perform full logical name translation, 	    then update item list for subsequent restoration. 	    If there are any holes [don't know whether that's possible] 	    collapse them out of the list; don't want them at restore time. 	 */
if|if
condition|(
name|vmswork
argument_list|(
name|GetTrans
argument_list|(
name|logname
argument_list|,
name|itmlst
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
name|max_trans_indx
condition|;
name|i
operator|++
control|)
block|{
name|u_long
modifier|*
name|attr_p
decl_stmt|;
name|attr_p
operator|=
name|itmlst
index|[
literal|3
operator|*
name|i
operator|+
literal|1
index|]
operator|.
name|buffer
expr_stmt|;
comment|/* copy (void *) to true type */
if|if
condition|(
operator|*
name|attr_p
operator|&
name|LNM$M_EXISTS
condition|)
block|{
operator|*
name|attr_p
operator|&=
operator|~
name|LNM$M_EXISTS
expr_stmt|;
comment|/* must clear this bit */
if|if
condition|(
operator|++
name|j
operator|<
name|i
condition|)
name|itmlst
index|[
literal|3
operator|*
name|j
operator|+
literal|0
index|]
operator|=
name|itmlst
index|[
literal|3
operator|*
name|i
operator|+
literal|0
index|]
operator|,
name|itmlst
index|[
literal|3
operator|*
name|j
operator|+
literal|1
index|]
operator|=
name|itmlst
index|[
literal|3
operator|*
name|i
operator|+
literal|1
index|]
operator|,
name|itmlst
index|[
literal|3
operator|*
name|j
operator|+
literal|2
index|]
operator|=
name|itmlst
index|[
literal|3
operator|*
name|i
operator|+
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|itmlst
index|[
literal|3
operator|*
name|j
operator|+
literal|2
index|]
operator|.
name|retlen
condition|)
block|{
comment|/* fixup buffer length */
name|itmlst
index|[
literal|3
operator|*
name|j
operator|+
literal|2
index|]
operator|.
name|len
operator|=
operator|*
name|itmlst
index|[
literal|3
operator|*
name|j
operator|+
literal|2
index|]
operator|.
name|retlen
expr_stmt|;
name|itmlst
index|[
literal|3
operator|*
name|j
operator|+
literal|2
index|]
operator|.
name|retlen
operator|=
operator|(
name|u_short
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|++
name|j
operator|<
name|i
condition|)
name|EndItm0
argument_list|(
name|itmlst
index|[
literal|3
operator|*
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* should never happen; tolerate potential memory leak */
name|free
argument_list|(
name|itmlst
argument_list|)
operator|,
name|itmlst
operator|=
literal|0
expr_stmt|;
comment|/*('wrk' buffer(s) will become lost)*/
block|}
return|return
name|itmlst
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|restore_translation
parameter_list|(
specifier|const
name|Dsc
modifier|*
name|logname
parameter_list|,
specifier|const
name|Itm
modifier|*
name|itemlist
parameter_list|)
block|{
name|Dsc
name|trans_val
decl_stmt|;
name|u_long
modifier|*
name|attr_p
decl_stmt|;
define|#
directive|define
name|LOG_PROCESS_TABLE
value|2
comment|/*<obsolete> */
define|#
directive|define
name|LOG_USERMODE
value|PSL$C_USER
comment|/* assert( itemlist[1].code == LNM$_ATTRIBUTES ); */
name|attr_p
operator|=
name|itemlist
index|[
literal|1
index|]
operator|.
name|buffer
expr_stmt|;
comment|/* copy (void *) to (u_long *) */
if|if
condition|(
operator|*
name|attr_p
operator|&
name|LNM$M_CRELOG
condition|)
block|{
comment|/* check original creation method */
comment|/* $crelog values can have only one translation; 	    so it'll be the first string entry in the itemlist. 	 */
comment|/* assert( itemlist[2].code == LNM$_STRING ); */
name|trans_val
operator|.
name|adr
operator|=
name|itemlist
index|[
literal|2
index|]
operator|.
name|buffer
expr_stmt|;
name|trans_val
operator|.
name|len
operator|=
name|itemlist
index|[
literal|2
index|]
operator|.
name|len
expr_stmt|;
operator|(
name|void
operator|)
name|SYS$CRELOG
argument_list|(
name|LOG_PROCESS_TABLE
argument_list|,
name|logname
argument_list|,
operator|&
name|trans_val
argument_list|,
name|LOG_USERMODE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* $crelnm definition; itemlist could specify multiple translations, 	    but has already been setup properly for use as-is. 	 */
operator|(
name|void
operator|)
name|SetTrans
argument_list|(
name|logname
argument_list|,
name|itemlist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*PIPES_SIMULATED*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!NO_VMS_PIPES*/
end_comment

end_unit

