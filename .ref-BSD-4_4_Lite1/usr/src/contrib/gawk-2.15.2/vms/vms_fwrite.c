begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * vms_fwrite.c - augmentation for the fwrite() function.  */
end_comment

begin_comment
comment|/*  * Copyright (C) 1991 the Free Software Foundation, Inc.  *  * This file is part of GAWK, the GNU implementation of the  * AWK Progamming Language.  *  * GAWK is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * GAWK is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with GAWK; see the file COPYING.  If not, write to  * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_comment
comment|/* really "../awk.h" */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TTY_FWRITE
end_ifndef

begin_include
include|#
directive|include
file|"vms.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VAXC_BUILTINS
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|builtins
end_pragma

begin_comment
comment|/* VAXC V3.0& up */
end_comment

begin_define
define|#
directive|define
name|find_c
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|,
name|c
parameter_list|)
value|((n) - _LOCC((c),(n),(s)))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*VAXC_BUILTINS*/
end_comment

begin_function
specifier|static
name|int
name|find_c
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|,
name|char
name|c
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|t
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|memchr
argument_list|(
name|s
argument_list|,
name|c
argument_list|,
name|n
argument_list|)
decl_stmt|;
return|return
operator|(
name|t
operator|==
literal|0
condition|?
name|n
else|:
name|t
operator|-
name|s
operator|)
return|;
comment|/* 0..n-1, or n if not found */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*VAXC_BUILTINS*/
end_comment

begin_define
define|#
directive|define
name|is_stdout
parameter_list|(
name|file_no
parameter_list|)
value|((file_no) == 1)
end_define

begin_comment
comment|/* fileno(stdout) */
end_comment

begin_define
define|#
directive|define
name|is_stderr
parameter_list|(
name|file_no
parameter_list|)
value|((file_no) == 2)
end_define

begin_comment
comment|/* fileno(stderr) */
end_comment

begin_define
define|#
directive|define
name|PREFIX_CR
value|0x008D0000
end_define

begin_comment
comment|/* leading carriage return */
end_comment

begin_define
define|#
directive|define
name|POSTFIX_CR
value|0x8D000000
end_define

begin_comment
comment|/* trailing carriage return (=> lf/cr) */
end_comment

begin_decl_stmt
specifier|static
name|short
name|channel
index|[
name|_NFILE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|prev_file
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prev_file_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      * VAXCRTL's fwrite() seems to flush after every character when      * writing to a terminal.  This routine is a limited functionality      * substitute that is *much* faster.  However, calls to fwrite()      * should not be mixed with other stdio calls to the same file      * unless fflush() is always called first.	Also, this routine      * will not detect that a freopen() call has finished with the      * original terminal; tty_fclose() should be used to close a file.      */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|fwrite
end_ifdef

begin_undef
undef|#
directive|undef
name|fwrite
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* tty_fwrite() - performance hack for fwrite() to a terminal */
end_comment

begin_function
name|size_t
name|tty_fwrite
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|number
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
specifier|static
name|long
name|evfn
init|=
operator|-
literal|1
decl_stmt|;
name|short
name|chan
decl_stmt|;
name|int
name|file_num
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|||
operator|!
operator|*
name|file
condition|)
return|return
literal|0
operator|*
operator|(
name|errno
operator|=
name|EBADF
operator|)
return|;
comment|/* kludge alert! */
elseif|else
if|if
condition|(
name|file
operator|==
name|prev_file
condition|)
name|file_num
operator|=
name|prev_file_num
expr_stmt|;
else|else
comment|/* note: VAXCRTL's fileno() is a function, not just a macro */
name|prev_file_num
operator|=
name|file_num
operator|=
name|fileno
argument_list|(
name|file
argument_list|)
operator|,
name|prev_file
operator|=
name|file
expr_stmt|;
name|chan
operator|=
name|file_num
operator|<
name|_NFILE
condition|?
name|channel
index|[
name|file_num
index|]
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|chan
operator|==
literal|0
condition|)
block|{
comment|/* if not initialized, need to assign a channel */
if|if
condition|(
name|isatty
argument_list|(
name|file_num
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* isatty: 1=yes, 0=no, -1=problem */
name|Dsc
name|device
decl_stmt|;
name|char
name|devnam
index|[
literal|255
operator|+
literal|1
index|]
decl_stmt|;
name|fgetname
argument_list|(
name|file
argument_list|,
name|devnam
argument_list|)
expr_stmt|;
comment|/* get 'file's name */
name|device
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|device
operator|.
name|adr
operator|=
name|devnam
argument_list|)
expr_stmt|;
comment|/* create descriptor */
if|if
condition|(
name|vmswork
argument_list|(
name|SYS$ASSIGN
argument_list|(
operator|&
name|device
argument_list|,
operator|&
name|chan
argument_list|,
literal|0
argument_list|,
operator|(
name|Dsc
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* get an event flag; use #0 if problem */
if|if
condition|(
name|evfn
operator|==
operator|-
literal|1
operator|&&
name|vmsfail
argument_list|(
name|LIB$GET_EF
argument_list|(
operator|&
name|evfn
argument_list|)
argument_list|)
condition|)
name|evfn
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|chan
operator|=
literal|0
expr_stmt|;
comment|/* $ASSIGN failed */
block|}
comment|/* store channel for later use; -1 => don't repeat failed init attempt */
name|channel
index|[
name|file_num
index|]
operator|=
operator|(
name|chan
operator|>
literal|0
condition|?
name|chan
else|:
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|chan
operator|>
literal|0
condition|)
block|{
comment|/* chan> 0 iff 'file' is a terminal */
struct|struct
name|_iosbw
block|{
name|u_short
name|status
decl_stmt|,
name|count
decl_stmt|;
name|u_long
name|rt_kludge
decl_stmt|;
block|}
name|iosb
struct|;
specifier|register
name|u_long
name|sts
init|=
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|pt
init|=
operator|(
name|char
operator|*
operator|)
name|buf
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|,
name|pos
decl_stmt|,
name|count
init|=
name|size
operator|*
name|number
decl_stmt|;
name|u_long
name|cc_fmt
decl_stmt|,
name|io_func
init|=
name|IO$_WRITEVBLK
decl_stmt|;
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_stderr
argument_list|(
name|file_num
argument_list|)
condition|)
comment|/* if it's SYS$ERROR (stderr)... */
name|io_func
operator||=
name|IO$M_CANCTRLO
expr_stmt|;
comment|/* cancel ^O (resume tty output) */
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|/* special handling for line-feeds to make them be 'newlines' */
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|pt
operator|==
literal|'\n'
condition|)
block|{
comment|/* got at least one leading line-feed */
name|cc_fmt
operator|=
name|PREFIX_CR
operator|,
name|extra
operator|++
expr_stmt|;
comment|/* precede 1st LF with a CR */
do|do
name|offset
operator|++
expr_stmt|;
do|while
condition|(
name|offset
operator|<
name|count
operator|&&
operator|*
operator|(
name|pt
operator|+
name|offset
operator|)
operator|==
literal|'\n'
condition|)
do|;
block|}
else|else
name|cc_fmt
operator|=
literal|0
expr_stmt|;
comment|/* look for another line-feed; if found, break line there */
name|pos
operator|=
name|offset
operator|+
name|find_c
argument_list|(
name|pt
operator|+
name|offset
argument_list|,
name|count
operator|-
name|offset
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|BUFSIZ
condition|)
name|pos
operator|=
name|BUFSIZ
operator|-
literal|1
expr_stmt|;
comment|/* throttle quota usage */
elseif|else
if|if
condition|(
name|pos
operator|<
name|count
condition|)
name|pos
operator|++
operator|,
name|cc_fmt
operator||=
name|POSTFIX_CR
operator|,
name|extra
operator|++
expr_stmt|;
comment|/* wait for previous write, if any, to complete */
if|if
condition|(
name|pt
operator|>
operator|(
name|char
operator|*
operator|)
name|buf
condition|)
block|{
name|sts
operator|=
name|SYS$SYNCH
argument_list|(
name|evfn
argument_list|,
operator|&
name|iosb
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmswork
argument_list|(
name|sts
argument_list|)
condition|)
name|sts
operator|=
name|iosb
operator|.
name|status
operator|,
name|result
operator|+=
name|iosb
operator|.
name|count
expr_stmt|;
if|if
condition|(
name|vmsfail
argument_list|(
name|sts
argument_list|)
condition|)
break|break;
block|}
comment|/* queue an asynchronous write */
name|sts
operator|=
name|SYS$QIO
argument_list|(
name|evfn
argument_list|,
name|chan
argument_list|,
name|io_func
argument_list|,
operator|&
name|iosb
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|,
literal|0L
argument_list|,
name|pt
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
name|cc_fmt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmsfail
argument_list|(
name|sts
argument_list|)
condition|)
break|break;
comment|/*(should never happen)*/
name|pt
operator|+=
name|pos
operator|,
name|count
operator|-=
name|pos
expr_stmt|;
block|}
comment|/* wait for last write to complete */
if|if
condition|(
name|pt
operator|>
operator|(
name|char
operator|*
operator|)
name|buf
operator|&&
name|vmswork
argument_list|(
name|sts
argument_list|)
condition|)
block|{
name|sts
operator|=
name|SYS$SYNCH
argument_list|(
name|evfn
argument_list|,
operator|&
name|iosb
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmswork
argument_list|(
name|sts
argument_list|)
condition|)
name|sts
operator|=
name|iosb
operator|.
name|status
operator|,
name|result
operator|+=
name|iosb
operator|.
name|count
expr_stmt|;
block|}
if|if
condition|(
name|vmsfail
argument_list|(
name|sts
argument_list|)
condition|)
name|errno
operator|=
name|EVMSERR
operator|,
name|vaxc$errno
operator|=
name|sts
expr_stmt|;
elseif|else
if|if
condition|(
name|iosb
operator|.
name|rt_kludge
operator|==
literal|0
condition|)
name|result
operator|=
name|number
operator|+
name|extra
expr_stmt|;
name|result
operator|-=
name|extra
expr_stmt|;
comment|/* subtract the additional carriage-returns */
block|}
else|else
block|{
comment|/* use stdio */
comment|/* Note: we assume that we're writing text, not binary data. 	   For stream format files, 'size' and 'number' are effectively 	   interchangable, and fwrite works fine.  However, for record 	   format files, 'size' governs the maximum record length, so 		fwrite(string, size(char), strlen(string), file) 	   will produce a sequence of 1-byte records, which is hardly 	   what we want in this (assumed) situation.  Line-feeds ('\n') 	   are converted into newlines (ie, record separators) by the 	   run-time library, but strings that don't end with a newline 	   still become separate records.  The simplest work around 	   is just to use fputs() instead of fwrite(); unfortunately, 	   we have to provide special treatment for NULs ('\0's). 	   At present, only stdout might be in record format (via>$'filename' redirection on the command line). 	*/
if|if
condition|(
name|size
operator|>
literal|1
condition|)
block|{
comment|/* not used by GAWK */
name|result
operator|=
name|fwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|,
name|number
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|number
operator|-
literal|1
operator|)
operator|==
literal|'\n'
operator|||
operator|!
name|is_stdout
argument_list|(
name|file_num
argument_list|)
condition|)
block|{
name|result
operator|=
name|fwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|number
argument_list|,
name|size
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|result
operator|=
name|result
operator|*
name|number
operator|/
name|size
expr_stmt|;
comment|/*(same as 'result = number')*/
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NO_ALLOCA
define|#
directive|define
name|alloca
parameter_list|(
name|n
parameter_list|)
value|((n)<= abuf_siz ? abuf : \ 		    (abuf_siz> 0 ? (void *)free(abuf) : (void *)0), \ 		    (abuf = malloc(abuf_siz = (n)+20)))
specifier|static
name|void
modifier|*
name|abuf
init|=
literal|0
decl_stmt|;
specifier|static
name|size_t
name|abuf_siz
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/*NO_ALLOCA*/
specifier|register
name|char
modifier|*
name|pt
init|=
operator|(
name|char
operator|*
operator|)
name|buf
decl_stmt|;
specifier|register
name|int
name|pos
decl_stmt|,
name|count
init|=
name|number
decl_stmt|;
if|if
condition|(
name|pt
index|[
name|count
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/*(out of bounds, but relatively safe)*/
name|pt
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pt
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
operator|,
name|pt
index|[
name|count
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* if exiting this block undoes the alloca(), we're hosed :-( */
block|}
name|result
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|pos
operator|=
name|find_c
argument_list|(
name|pt
argument_list|,
name|count
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fputs
argument_list|(
name|pt
argument_list|,
name|file
argument_list|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|pos
operator|<
name|count
condition|)
block|{
if|if
condition|(
name|fputc
argument_list|(
literal|'\0'
argument_list|,
name|file
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|pos
operator|++
expr_stmt|;
comment|/* 0..n-1 -> 1..n */
block|}
name|result
operator|+=
name|pos
operator|,
name|pt
operator|+=
name|pos
operator|,
name|count
operator|-=
name|pos
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|fwrite
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|,
name|f
parameter_list|)
value|tty_fwrite((b),(s),(n),(f))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|fclose
end_ifdef

begin_undef
undef|#
directive|undef
name|fclose
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* tty_fclose() - keep tty_fwrite() up to date when closing a file */
end_comment

begin_function
name|int
name|tty_fclose
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|file
operator|&&
operator|*
name|file
condition|)
block|{
comment|/* note: VAXCRTL stdio has extra level of indirection */
name|int
name|file_num
init|=
name|fileno
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|short
name|chan
init|=
name|file_num
operator|<
name|_NFILE
condition|?
name|channel
index|[
name|file_num
index|]
else|:
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|chan
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|SYS$DASSGN
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/* deassign the channel (ie, close) */
if|if
condition|(
name|file_num
operator|<
name|_NFILE
condition|)
name|channel
index|[
name|file_num
index|]
operator|=
literal|0
expr_stmt|;
comment|/* clear stale info */
block|}
name|prev_file
operator|=
literal|0
expr_stmt|;
comment|/* force tty_fwrite() to reset */
return|return
name|fclose
argument_list|(
name|file
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|fclose
parameter_list|(
name|f
parameter_list|)
value|tty_fclose(f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!NO_TTY_FWRITE*/
end_comment

end_unit

