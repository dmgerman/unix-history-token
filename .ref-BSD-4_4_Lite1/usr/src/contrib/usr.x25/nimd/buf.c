begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Miscellanious buffer management routines  *  * Frank Pronk  * The University of British Columbia  * Laboratory for Computational Vision  * Copyright (c)  */
end_comment

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * return a buffer that contains room  * for 'size' bytes of data.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|getbuf
parameter_list|(
name|size
parameter_list|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|+
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
literal|4
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bp
operator|->
name|b_next
operator|=
name|bp
operator|->
name|b_prev
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_top
operator|=
name|bp
operator|->
name|b_bot
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a buffer queue by  * freeing all buffers on the queue  * and resetting the queue to its  * initial state.  */
end_comment

begin_expr_stmt
name|InitQueue
argument_list|(
name|qp
argument_list|)
specifier|register
expr|struct
name|bufhd
operator|*
name|qp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|qp
operator|->
name|b_next
condition|)
while|while
condition|(
operator|!
name|QEMPTY
argument_list|(
name|qp
argument_list|)
condition|)
block|{
name|dequeue
argument_list|(
name|bp
operator|=
name|qp
operator|->
name|b_next
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
block|}
name|qp
operator|->
name|b_prev
operator|=
name|qp
operator|->
name|b_next
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|qp
expr_stmt|;
name|qp
operator|->
name|b_count
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Allocate a buffer and try to read 'size' bytes from 'fd'.  * Return zero on error; otherwise return a pointer to the buffer.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|FillBuf
parameter_list|(
name|fd
parameter_list|,
name|size
parameter_list|,
name|who
parameter_list|)
name|char
modifier|*
name|who
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|getbuf
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bp
operator|->
name|b_bot
argument_list|,
name|size
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bp
operator|->
name|b_top
operator|+=
name|n
expr_stmt|;
name|NimTrace
argument_list|(
name|who
argument_list|,
name|bp
operator|->
name|b_bot
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to flush the queue of buffers headed by 'qp'  * by writing to 'fd'.  Returns non-zero on error.  */
end_comment

begin_expr_stmt
name|FlushQueue
argument_list|(
name|fd
argument_list|,
name|qp
argument_list|,
name|who
argument_list|)
specifier|register
expr|struct
name|bufhd
operator|*
name|qp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|who
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cc
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
while|while
condition|(
operator|!
name|QEMPTY
argument_list|(
name|qp
argument_list|)
condition|)
block|{
name|bp
operator|=
name|qp
operator|->
name|b_next
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|bp
operator|->
name|b_bot
argument_list|,
name|SIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|NimTrace
argument_list|(
name|who
argument_list|,
name|bp
operator|->
name|b_bot
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bot
operator|+=
name|cc
expr_stmt|;
name|qp
operator|->
name|b_count
operator|-=
name|cc
expr_stmt|;
if|if
condition|(
name|ISEMPTY
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|dequeue
argument_list|(
name|bp
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Copy string 's' to buffer 'bp'.  */
end_comment

begin_expr_stmt
name|StrToBuf
argument_list|(
name|s
argument_list|,
name|bp
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
condition|)
name|PUTCHAR
argument_list|(
operator|*
name|s
operator|++
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Copy the contents of buffer 'from' to 'to'.  */
end_comment

begin_macro
name|BufCopy
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|l
init|=
name|SIZE
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|from
operator|->
name|b_bot
argument_list|,
name|to
operator|->
name|b_top
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|to
operator|->
name|b_top
operator|+=
name|l
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * place buffer 'bp' on the end of  * the queue headed by 'qp'.  */
end_comment

begin_expr_stmt
name|enqueue
argument_list|(
name|bp
argument_list|,
name|qp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|bufhd
modifier|*
name|qp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|qp
operator|->
name|b_prev
operator|->
name|b_next
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_prev
operator|=
name|qp
operator|->
name|b_prev
expr_stmt|;
name|qp
operator|->
name|b_prev
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_next
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|qp
expr_stmt|;
name|qp
operator|->
name|b_count
operator|+=
name|SIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * remove buffer 'bp' from the  * queue headed by 'qp'.  */
end_comment

begin_expr_stmt
name|dequeue
argument_list|(
name|bp
argument_list|,
name|qp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|bufhd
modifier|*
name|qp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bp
operator|->
name|b_prev
operator|->
name|b_next
operator|=
name|bp
operator|->
name|b_next
expr_stmt|;
name|bp
operator|->
name|b_next
operator|->
name|b_prev
operator|=
name|bp
operator|->
name|b_prev
expr_stmt|;
name|qp
operator|->
name|b_count
operator|-=
name|SIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

