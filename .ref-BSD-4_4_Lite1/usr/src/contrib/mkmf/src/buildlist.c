begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1985, 1991 Peter J. Nicklin.  * Copyright (c) 1991 Version Technology.  * All Rights Reserved.  *  * $License: VT.1.1 $  * Redistribution and use in source and binary forms,  with or without  * modification,  are permitted provided that the following conditions  * are met:  (1) Redistributions of source code must retain the  above  * copyright  notice,  this  list  of  conditions  and  the  following  * disclaimer.  (2) Redistributions in binary form must reproduce  the  * above  copyright notice,  this list of conditions and the following  * disclaimer in the  documentation  and/or other  materials  provided  * with  the  distribution.  (3) All advertising materials  mentioning  * features or  use  of  this  software  must  display  the  following  * acknowledgement:  ``This  product  includes  software  developed by  * Version Technology.''  Neither the name of Version  Technology  nor  * the  name  of  Peter J. Nicklin  may  be used to endorse or promote  * products derived from this software without specific prior  written  * permission.  *  * THIS SOFTWARE IS PROVIDED BY VERSION TECHNOLOGY ``AS IS''  AND  ANY  * EXPRESS OR IMPLIED WARRANTIES,  INCLUDING,  BUT NOT LIMITED TO, THE  * IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL  VERSION  TECHNOLOGY  BE  * LIABLE  FOR ANY DIRECT,  INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY,  * OR  CONSEQUENTIAL DAMAGES   (INCLUDING,   BUT   NOT   LIMITED   TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  * OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR  TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING  IN ANY WAY OUT OF THE  * USE OF THIS SOFTWARE,  EVEN  IF  ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * Report problems and direct questions to nicklin@netcom.com  *  * $Header: buildlist.c,v 4.10 91/11/25 19:44:59 nicklin Exp $  *  * Author: Peter J. Nicklin  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"Mkmf.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"null.h"
end_include

begin_include
include|#
directive|include
file|"path.h"
end_include

begin_include
include|#
directive|include
file|"slist.h"
end_include

begin_include
include|#
directive|include
file|"stringx.h"
end_include

begin_include
include|#
directive|include
file|"suffix.h"
end_include

begin_include
include|#
directive|include
file|"yesno.h"
end_include

begin_decl_stmt
specifier|extern
name|SLIST
modifier|*
name|HEADLIST
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* header file name list */
end_comment

begin_decl_stmt
specifier|extern
name|SLIST
modifier|*
name|SRCLIST
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* source file name list */
end_comment

begin_comment
comment|/*  * buftolist() copies the items from a buffer to a singly-linked list.  * Returns integer YES if successful, otherwise NO.  */
end_comment

begin_macro
name|buftolist
argument_list|(
argument|buf
argument_list|,
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* item buffer */
end_comment

begin_decl_stmt
name|SLIST
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* receiving list */
end_comment

begin_block
block|{
name|char
modifier|*
name|gettoken
parameter_list|()
function_decl|;
comment|/* get next token */
name|char
modifier|*
name|slappend
parameter_list|()
function_decl|;
comment|/* append file name to list */
name|char
name|token
index|[
name|PATHSIZE
index|]
decl_stmt|;
comment|/* item buffer */
while|while
condition|(
operator|(
name|buf
operator|=
name|gettoken
argument_list|(
name|token
argument_list|,
name|buf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|slappend
argument_list|(
name|token
argument_list|,
name|list
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * buildliblist() reads library pathnames from the LIBLIST macro  * definition, and adds them to the library pathname list. Libraries  * may be specified as `-lx'. Returns integer YES if successful,  * otherwise NO.  */
end_comment

begin_macro
name|buildliblist
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|getpath
parameter_list|()
function_decl|;
comment|/* get next path */
name|char
modifier|*
name|getoption
parameter_list|()
function_decl|;
comment|/* get library path option */
name|char
modifier|*
name|lp
decl_stmt|;
comment|/* library path pointer */
name|char
name|lpath
index|[
name|PATHSIZE
index|]
decl_stmt|;
comment|/* library path buffer */
specifier|extern
name|SLIST
modifier|*
name|LIBLIST
decl_stmt|;
comment|/* library pathname list */
specifier|extern
name|HASH
modifier|*
name|MDEFTABLE
decl_stmt|;
comment|/* macro definition table */
name|HASHBLK
modifier|*
name|htb
decl_stmt|;
comment|/* hash table block */
name|HASHBLK
modifier|*
name|htlookup
parameter_list|()
function_decl|;
comment|/* find hash table entry */
name|int
name|libbuftolist
parameter_list|()
function_decl|;
comment|/* load library pathnames into list */
name|SLIST
modifier|*
name|libpathlist
decl_stmt|;
comment|/* library directory search path */
comment|/* create the library search path list */
name|libpathlist
operator|=
name|slinit
argument_list|()
expr_stmt|;
comment|/* -L library path specification */
if|if
condition|(
name|htlookup
argument_list|(
name|MLDFLAGS
argument_list|,
name|MDEFTABLE
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|lp
operator|=
name|htdef
argument_list|(
name|MDEFTABLE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|lp
operator|=
name|getoption
argument_list|(
name|lpath
argument_list|,
name|lp
argument_list|,
literal|"-L"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|lpath
operator|==
literal|'\0'
condition|)
block|{
name|warns
argument_list|(
literal|"missing library in %s macro definition"
argument_list|,
name|htkey
argument_list|(
name|MDEFTABLE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|strcat
argument_list|(
name|lpath
argument_list|,
literal|"/lib"
argument_list|)
expr_stmt|;
if|if
condition|(
name|slappend
argument_list|(
name|lpath
argument_list|,
name|libpathlist
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
block|}
block|}
comment|/* LPATH environment variable library path specification */
if|if
condition|(
name|htlookup
argument_list|(
name|MLPATH
argument_list|,
name|MDEFTABLE
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|htdef
argument_list|(
name|MDEFTABLE
argument_list|)
operator|!=
literal|'\0'
condition|)
block|{
name|lp
operator|=
name|htdef
argument_list|(
name|MDEFTABLE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|lp
operator|=
name|getpath
argument_list|(
name|lpath
argument_list|,
name|lp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|lpath
argument_list|,
literal|"/lib"
argument_list|)
expr_stmt|;
if|if
condition|(
name|slappend
argument_list|(
name|lpath
argument_list|,
name|libpathlist
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|slappend
argument_list|(
literal|"/lib/lib"
argument_list|,
name|libpathlist
argument_list|)
operator|==
name|NULL
operator|||
name|slappend
argument_list|(
literal|"/usr/lib/lib"
argument_list|,
name|libpathlist
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
comment|/* search for the libraries */
name|LIBLIST
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|htb
operator|=
name|htlookup
argument_list|(
name|MLIBLIST
argument_list|,
name|MDEFTABLE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIBLIST
operator|=
name|slinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|libbuftolist
argument_list|(
name|htb
operator|->
name|h_def
argument_list|,
name|libpathlist
argument_list|,
name|LIBLIST
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
name|slrm
argument_list|(
name|libpathlist
argument_list|)
expr_stmt|;
name|htrm
argument_list|(
name|MLIBLIST
argument_list|,
name|MDEFTABLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * buildsrclist() takes source and header file names from command line  * macro definitions or the current directory and appends them to source  * or header file name lists as appropriate. Returns integer YES if  * successful, otherwise NO.  */
end_comment

begin_macro
name|buildsrclist
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|HASH
modifier|*
name|MDEFTABLE
decl_stmt|;
comment|/* macro definition table */
specifier|extern
name|int
name|MKSYMLINK
decl_stmt|;
comment|/* make symbolic links to current dir ?*/
name|HASHBLK
modifier|*
name|headhtb
decl_stmt|;
comment|/* HEADERS macro hash table block */
name|HASHBLK
modifier|*
name|htlookup
parameter_list|()
function_decl|;
comment|/* find hash table entry */
name|HASHBLK
modifier|*
name|srchtb
decl_stmt|;
comment|/* SOURCES macro hash table block */
name|int
name|buftolist
parameter_list|()
function_decl|;
comment|/* copy items from buffer to list */
name|int
name|mksrclist
parameter_list|()
function_decl|;
comment|/* compose a list of source files */
name|int
name|mksymlink
parameter_list|()
function_decl|;
comment|/* create symbolic source links */
name|int
name|needhdr
init|=
literal|1
decl_stmt|;
comment|/* need header file names */
name|int
name|needsrc
init|=
literal|1
decl_stmt|;
comment|/* need source file names */
name|int
name|read_dir
parameter_list|()
function_decl|;
comment|/* read dir for source and headers */
name|int
name|slsort
parameter_list|()
function_decl|;
comment|/* sort singly-linked list */
name|int
name|uniqsrclist
parameter_list|()
function_decl|;
comment|/* remove source dependencies */
name|SLIST
modifier|*
name|slinit
parameter_list|()
function_decl|;
comment|/* initialize singly-linked list */
name|HEADLIST
operator|=
name|slinit
argument_list|()
expr_stmt|;
name|SRCLIST
operator|=
name|slinit
argument_list|()
expr_stmt|;
comment|/* build lists from command line macro definitions */
if|if
condition|(
operator|(
name|headhtb
operator|=
name|htlookup
argument_list|(
name|MHEADERS
argument_list|,
name|MDEFTABLE
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|headhtb
operator|->
name|h_val
operator|==
name|VREADWRITE
condition|)
block|{
if|if
condition|(
name|buftolist
argument_list|(
name|headhtb
operator|->
name|h_def
argument_list|,
name|HEADLIST
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
name|needhdr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|srchtb
operator|=
name|htlookup
argument_list|(
name|MSOURCES
argument_list|,
name|MDEFTABLE
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|srchtb
operator|->
name|h_val
operator|==
name|VREADWRITE
condition|)
block|{
if|if
condition|(
name|buftolist
argument_list|(
name|srchtb
operator|->
name|h_def
argument_list|,
name|SRCLIST
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
name|needsrc
operator|=
literal|0
expr_stmt|;
block|}
comment|/* read directories to get source and header file names */
if|if
condition|(
name|needhdr
operator|||
name|needsrc
condition|)
block|{
if|if
condition|(
name|MKSYMLINK
condition|)
block|{
if|if
condition|(
name|mksymlink
argument_list|(
name|needsrc
argument_list|,
name|needhdr
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|mksrclist
argument_list|(
name|needsrc
argument_list|,
name|needhdr
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
block|}
if|if
condition|(
name|slsort
argument_list|(
name|strcmp
argument_list|,
name|HEADLIST
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
if|if
condition|(
name|slsort
argument_list|(
name|strcmp
argument_list|,
name|SRCLIST
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
if|if
condition|(
name|SLNUM
argument_list|(
name|SRCLIST
argument_list|)
operator|>
literal|0
operator|&&
name|uniqsrclist
argument_list|()
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * expandlibpath() converts a library file specified by `-lx' into a full  * pathname. Directories are searched for the library in the form libx.a.  * An integer YES is returned if the library was found, otherwise NO.  */
end_comment

begin_macro
name|expandlibpath
argument_list|(
argument|libtoken
argument_list|,
argument|libpath
argument_list|,
argument|libpathlist
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|libtoken
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* library file option */
end_comment

begin_decl_stmt
name|char
modifier|*
name|libpath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* library pathname */
end_comment

begin_decl_stmt
name|SLIST
modifier|*
name|libpathlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* library directory search path */
end_comment

begin_block
block|{
name|char
modifier|*
name|lp
decl_stmt|;
comment|/* library pathname pointer */
name|char
modifier|*
name|strpcpy
parameter_list|()
function_decl|;
comment|/* string copy and update pointer */
name|SLBLK
modifier|*
name|cblk
decl_stmt|;
comment|/* current list block */
name|libtoken
operator|+=
literal|2
expr_stmt|;
comment|/* skip -l option */
for|for
control|(
name|cblk
operator|=
name|libpathlist
operator|->
name|head
init|;
name|cblk
operator|!=
name|NULL
condition|;
name|cblk
operator|=
name|cblk
operator|->
name|next
control|)
block|{
name|lp
operator|=
name|strpcpy
argument_list|(
name|libpath
argument_list|,
name|cblk
operator|->
name|key
argument_list|)
expr_stmt|;
name|lp
operator|=
name|strpcpy
argument_list|(
name|lp
argument_list|,
name|libtoken
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strpcpy
argument_list|(
name|lp
argument_list|,
literal|".a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FILEXIST
argument_list|(
name|libpath
argument_list|)
condition|)
block|{
return|return
operator|(
name|YES
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * libbuftolist() appends each library pathname specified in libbuf to  * the liblist library pathname list.  */
end_comment

begin_macro
name|libbuftolist
argument_list|(
argument|libmacrobuf
argument_list|,
argument|libpathlist
argument_list|,
argument|liblist
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|libmacrobuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LIBS macro definition buffer */
end_comment

begin_decl_stmt
name|SLIST
modifier|*
name|libpathlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* library directory search path */
end_comment

begin_decl_stmt
name|SLIST
modifier|*
name|liblist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* library pathname list */
end_comment

begin_block
block|{
name|char
modifier|*
name|gettoken
parameter_list|()
function_decl|;
comment|/* get next token */
name|char
name|libpath
index|[
name|PATHSIZE
index|]
decl_stmt|;
comment|/* library pathname */
name|char
name|libtoken
index|[
name|PATHSIZE
index|]
decl_stmt|;
comment|/* library file option */
name|char
modifier|*
name|slappend
parameter_list|()
function_decl|;
comment|/* append file name to list */
name|int
name|expandlibpath
parameter_list|()
function_decl|;
comment|/* -lx -> full library pathname */
while|while
condition|(
operator|(
name|libmacrobuf
operator|=
name|gettoken
argument_list|(
name|libtoken
argument_list|,
name|libmacrobuf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|libtoken
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|libtoken
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|expandlibpath
argument_list|(
name|libtoken
argument_list|,
name|libpath
argument_list|,
name|libpathlist
argument_list|)
operator|==
name|NO
condition|)
block|{
name|warns
argument_list|(
literal|"can't find library %s"
argument_list|,
name|libtoken
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|slappend
argument_list|(
name|libpath
argument_list|,
name|liblist
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|slappend
argument_list|(
name|libtoken
argument_list|,
name|liblist
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
block|}
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * read_dir() reads filenames from the designated directory and adds them  * to the source or header file name lists as appropriate. Returns  * integer YES if successful, otherwise NO.  */
end_comment

begin_macro
name|read_dir
argument_list|(
argument|dirname
argument_list|,
argument|addfile
argument_list|,
argument|needsrc
argument_list|,
argument|needhdr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dirname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* specified directory name */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|addfile
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* function for adding source files */
end_comment

begin_decl_stmt
name|int
name|needsrc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* need source file names */
end_comment

begin_decl_stmt
name|int
name|needhdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* need header file names */
end_comment

begin_block
block|{
specifier|extern
name|int
name|AFLAG
decl_stmt|;
comment|/* list .source files? */
name|char
modifier|*
name|suffix
decl_stmt|;
comment|/* pointer to file name suffix */
name|DIR
modifier|*
name|dirp
decl_stmt|;
comment|/* directory stream */
name|DIRENT
modifier|*
name|dp
decl_stmt|;
comment|/* directory entry pointer */
name|int
name|lookupsfx
parameter_list|()
function_decl|;
comment|/* get suffix type */
name|int
name|sfxtyp
decl_stmt|;
comment|/* type of suffix */
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|dirname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warns
argument_list|(
literal|"%s: can't open directory"
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
for|for
control|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|suffix
operator|=
name|strrchr
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|*
name|dp
operator|->
name|d_name
operator|==
literal|'.'
operator|&&
name|AFLAG
operator|==
name|NO
operator|)
operator|||
operator|(
operator|*
name|dp
operator|->
name|d_name
operator|==
literal|'#'
operator|)
condition|)
continue|continue;
name|suffix
operator|++
expr_stmt|;
name|sfxtyp
operator|=
name|lookupsfx
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfxtyp
operator|==
name|SFXSRC
condition|)
block|{
if|if
condition|(
name|needsrc
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"s."
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* skip SCCS files */
if|if
condition|(
call|(
modifier|*
name|addfile
call|)
argument_list|(
name|dirname
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
literal|'s'
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sfxtyp
operator|==
name|SFXHEAD
condition|)
block|{
if|if
condition|(
name|needhdr
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"s."
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* skip SCCS files */
if|if
condition|(
call|(
modifier|*
name|addfile
call|)
argument_list|(
name|dirname
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
literal|'h'
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
block|}
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * uniqsrclist() scans the source file list and removes the names of  * any files that could have been generated by make rules from files  * in the same list. Returns NO if no source list or out of memory,  * otherwise YES.  */
end_comment

begin_macro
name|uniqsrclist
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|SLIST
modifier|*
name|SRCLIST
decl_stmt|;
comment|/* source file name list */
specifier|register
name|int
name|cbi
decl_stmt|;
comment|/* current block vector index */
specifier|register
name|int
name|fbi
decl_stmt|;
comment|/* first matching block vector index */
specifier|register
name|int
name|lbi
decl_stmt|;
comment|/* last block vector index */
name|int
name|length
decl_stmt|;
comment|/* source file basename length */
name|SLBLK
modifier|*
modifier|*
name|slvect
parameter_list|()
function_decl|;
comment|/* make linked list vector */
name|SLBLK
modifier|*
modifier|*
name|slv
decl_stmt|;
comment|/* ptr to singly-linked list vector */
name|void
name|slvtol
parameter_list|()
function_decl|;
comment|/* convert vector to linked list */
name|void
name|uniqsrcfile
parameter_list|()
function_decl|;
comment|/* make source files dependency-free */
if|if
condition|(
operator|(
name|slv
operator|=
name|slvect
argument_list|(
name|SRCLIST
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NO
operator|)
return|;
name|lbi
operator|=
name|SLNUM
argument_list|(
name|SRCLIST
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|fbi
operator|=
literal|0
operator|,
name|cbi
operator|=
literal|1
init|;
name|cbi
operator|<=
name|lbi
condition|;
name|cbi
operator|++
control|)
block|{
name|length
operator|=
name|strrchr
argument_list|(
name|slv
index|[
name|cbi
index|]
operator|->
name|key
argument_list|,
literal|'.'
argument_list|)
operator|-
name|slv
index|[
name|cbi
index|]
operator|->
name|key
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|slv
index|[
name|fbi
index|]
operator|->
name|key
argument_list|,
name|slv
index|[
name|cbi
index|]
operator|->
name|key
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
comment|/* find end of matching block */
block|}
elseif|else
if|if
condition|(
name|cbi
operator|-
name|fbi
operator|>
literal|1
condition|)
block|{
name|uniqsrcfile
argument_list|(
name|fbi
argument_list|,
name|cbi
operator|-
name|fbi
argument_list|,
name|slv
argument_list|)
expr_stmt|;
block|}
name|fbi
operator|=
name|cbi
expr_stmt|;
block|}
if|if
condition|(
name|cbi
operator|-
name|fbi
operator|>
literal|1
condition|)
comment|/* do last matching block */
block|{
name|uniqsrcfile
argument_list|(
name|fbi
argument_list|,
name|cbi
operator|-
name|fbi
argument_list|,
name|slv
argument_list|)
expr_stmt|;
block|}
name|slvtol
argument_list|(
name|SRCLIST
argument_list|,
name|slv
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * uniqsrcfile() scans a block of source files and removes the names of  * any files that could have been generated by make rules from files  * in the same block. The names of a source file is removed by setting  * the pointer to the source file block to NULL in the vector. To maintain  * the transitive property of each rule, the name of the source file is  * still maintained in the singly-linked list.  */
end_comment

begin_function
name|void
name|uniqsrcfile
parameter_list|(
name|fbi
parameter_list|,
name|nb
parameter_list|,
name|slv
parameter_list|)
specifier|register
name|int
name|fbi
decl_stmt|;
comment|/* index to first matching block */
name|int
name|nb
decl_stmt|;
comment|/* number of blocks */
name|SLBLK
modifier|*
modifier|*
name|slv
decl_stmt|;
comment|/* ptr to singly-linked list vector */
block|{
specifier|register
name|SLBLK
modifier|*
name|ibp
decl_stmt|;
comment|/* block pointer (i-loop) */
specifier|register
name|SLBLK
modifier|*
name|jbp
decl_stmt|;
comment|/* block pointer (j-loop) */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* i-loop index */
specifier|register
name|int
name|j
decl_stmt|;
comment|/* j-loop index */
name|char
name|rule
index|[
literal|2
operator|*
name|SUFFIXSIZE
operator|+
literal|3
index|]
decl_stmt|;
comment|/* rule buffer */
name|int
name|lookuprule
parameter_list|()
function_decl|;
comment|/* does source rule exist? */
name|int
name|nu
decl_stmt|;
comment|/* number of unique blocks */
name|SLBLK
modifier|*
name|fbp
decl_stmt|;
comment|/* pointer to first block */
name|void
name|makerule
parameter_list|()
function_decl|;
comment|/* make a rule from two suffixes */
name|nu
operator|=
name|nb
expr_stmt|;
name|fbp
operator|=
name|slv
index|[
name|fbi
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ibp
operator|=
name|fbp
init|;
name|i
operator|<
name|nb
condition|;
name|i
operator|++
operator|,
name|ibp
operator|=
name|ibp
operator|->
name|next
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|jbp
operator|=
name|fbp
init|;
name|j
operator|<
name|nb
condition|;
name|j
operator|++
operator|,
name|jbp
operator|=
name|jbp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|j
operator|&&
name|slv
index|[
name|fbi
operator|+
name|j
index|]
operator|!=
name|NULL
condition|)
block|{
name|makerule
argument_list|(
name|rule
argument_list|,
name|ibp
operator|->
name|key
argument_list|,
name|jbp
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookuprule
argument_list|(
name|rule
argument_list|)
operator|==
name|YES
condition|)
block|{
name|slv
index|[
name|fbi
operator|+
name|j
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|--
name|nu
operator|<
literal|2
condition|)
return|return;
block|}
block|}
block|}
block|}
block|}
end_function

end_unit

