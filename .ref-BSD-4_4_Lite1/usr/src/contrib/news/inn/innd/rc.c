begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.31 $ ** **  Routines for the remote connect channel.  Create an Internet stream socket **  that processes connect to.  If the incoming site is not one of our feeds, **  then we pass the connection off to the standard nntp daemon. */
end_comment

begin_include
include|#
directive|include
file|"innd.h"
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NETSWAP
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|htons
argument_list|)
end_if

begin_function_decl
specifier|extern
name|unsigned
name|short
name|htons
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(htons) */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|htonl
argument_list|)
end_if

begin_function_decl
specifier|extern
name|unsigned
name|long
name|htonl
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(htonl) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(NETSWAP) */
end_comment

begin_define
define|#
directive|define
name|COPYADDR
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
define|\
value|(void)memcpy((POINTER)dest, (POINTER)src, (SIZE_T)sizeof (INADDR))
end_define

begin_comment
comment|/* **  A remote host has an address and a password. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_REMOTEHOST
block|{
name|char
modifier|*
name|Name
decl_stmt|;
name|INADDR
name|Address
decl_stmt|;
name|char
modifier|*
name|Password
decl_stmt|;
name|char
modifier|*
modifier|*
name|Patterns
decl_stmt|;
block|}
name|REMOTEHOST
typedef|;
end_typedef

begin_decl_stmt
name|STATIC
name|INADDR
modifier|*
name|RCmaster
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|RCnmaster
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|RCslaveflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|RCnnrpd
index|[]
init|=
name|_PATH_NNRPD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|RCnnrqd
index|[]
init|=
name|_PATH_NNQRD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|RCnntpd
index|[]
init|=
name|_PATH_NNTPD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|CHANNEL
modifier|*
name|RCchan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|REMOTEHOST
modifier|*
name|RCpeerlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|RCnpeerlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|REMOTEHOST
modifier|*
name|RCnolimitlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|RCnnolimitlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  See if the site properly entered the password. */
end_comment

begin_function
name|BOOL
name|RCauthorized
parameter_list|(
name|cp
parameter_list|,
name|pass
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|pass
decl_stmt|;
block|{
specifier|register
name|REMOTEHOST
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|RCpeerlist
operator|,
name|i
operator|=
name|RCnpeerlist
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|rp
operator|++
control|)
comment|/* SUPPRESS 112 */
comment|/* Retrieving long where char is stored */
if|if
condition|(
name|cp
operator|->
name|Address
operator|.
name|s_addr
operator|==
name|rp
operator|->
name|Address
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|Password
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|EQ
argument_list|(
name|pass
argument_list|,
name|rp
operator|->
name|Password
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s bad_auth"
argument_list|,
name|inet_ntoa
argument_list|(
name|cp
operator|->
name|Address
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|AnyIncoming
condition|)
comment|/* Not found in our table; this can't happen. */
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s not_found"
argument_list|,
name|inet_ntoa
argument_list|(
name|cp
operator|->
name|Address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Anonymous hosts should not authenticate. */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* **  See if a host is in the "nolimit" file. */
end_comment

begin_function
name|BOOL
name|RCnolimit
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|REMOTEHOST
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|RCnolimitlist
operator|,
name|i
operator|=
name|RCnnolimitlist
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|rp
operator|++
control|)
comment|/* SUPPRESS 112 */
comment|/* Retrieving long where char is stored */
if|if
condition|(
name|cp
operator|->
name|Address
operator|.
name|s_addr
operator|==
name|rp
operator|->
name|Address
operator|.
name|s_addr
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* **  Is this an address of the master? */
end_comment

begin_function
name|BOOL
name|RCismaster
parameter_list|(
name|addr
parameter_list|)
name|INADDR
name|addr
decl_stmt|;
block|{
specifier|register
name|INADDR
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|AmSlave
condition|)
for|for
control|(
name|i
operator|=
name|RCnmaster
operator|,
name|ip
operator|=
name|RCmaster
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ip
operator|++
control|)
comment|/* SUPPRESS 112 */
comment|/* Retrieving long where char is stored */
if|if
condition|(
name|addr
operator|.
name|s_addr
operator|==
name|ip
operator|->
name|s_addr
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* **  Hand off a descriptor to NNRPD. */
end_comment

begin_function
name|void
name|RChandoff
parameter_list|(
name|fd
parameter_list|,
name|h
parameter_list|)
name|int
name|fd
decl_stmt|;
name|HANDOFF
name|h
decl_stmt|;
block|{
name|STRING
name|argv
index|[
literal|6
index|]
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|SetNonBlocking
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant nonblock %d in RChandoff %m"
argument_list|,
name|LogName
argument_list|,
name|fd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|h
condition|)
block|{
default|default:
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s internal RChandoff %d type %d"
argument_list|,
name|LogName
argument_list|,
name|fd
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|HOnnrpd
case|:
name|argv
index|[
literal|0
index|]
operator|=
name|RCnnrpd
expr_stmt|;
break|break;
case|case
name|HOnnrqd
case|:
name|argv
index|[
literal|0
index|]
operator|=
name|RCnnrqd
expr_stmt|;
break|break;
case|case
name|HOnntpd
case|:
name|argv
index|[
literal|0
index|]
operator|=
name|RCnntpd
expr_stmt|;
break|break;
block|}
name|argv
index|[
literal|1
index|]
operator|=
literal|"-s                                                "
expr_stmt|;
name|i
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|NNRPReason
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"-r%s"
argument_list|,
name|NNRPReason
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|buff
expr_stmt|;
block|}
if|if
condition|(
name|NNRPTracing
condition|)
name|argv
index|[
name|i
operator|++
index|]
operator|=
literal|"-t"
expr_stmt|;
if|if
condition|(
name|RCslaveflag
condition|)
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|RCslaveflag
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Call NNRP; don't send back a QUIT message if Spawn fails since        * that's a major error we want to find out about quickly. */
operator|(
name|void
operator|)
name|Spawn
argument_list|(
name|fd
argument_list|,
name|fd
argument_list|,
name|fd
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Read function.  Accept the connection and either create an NNTP channel **  or spawn an nnrpd to handle it. */
end_comment

begin_function
name|STATIC
name|FUNCTYPE
name|RCreader
parameter_list|(
name|cp
parameter_list|)
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|sockaddr_in
name|remote
decl_stmt|;
name|int
name|size
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|REMOTEHOST
modifier|*
name|rp
decl_stmt|;
name|CHANNEL
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|cp
operator|!=
name|RCchan
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s internal RCreader wrong channel 0x%x not 0x%x"
argument_list|,
name|LogName
argument_list|,
name|cp
argument_list|,
name|RCchan
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get the connection. */
name|size
operator|=
sizeof|sizeof
name|remote
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|accept
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|remote
argument_list|,
operator|&
name|size
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant accept RCreader %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* See if it's one of our servers. */
for|for
control|(
name|name
operator|=
name|NULL
operator|,
name|rp
operator|=
name|RCpeerlist
operator|,
name|i
operator|=
name|RCnpeerlist
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|rp
operator|++
control|)
comment|/* SUPPRESS 112 */
comment|/* Retrieving long where char is stored */
if|if
condition|(
name|rp
operator|->
name|Address
operator|.
name|s_addr
operator|==
name|remote
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|name
operator|=
name|rp
operator|->
name|Name
expr_stmt|;
break|break;
block|}
comment|/* If not a server, and not allowing anyone, hand him off. */
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|new
operator|=
name|NCcreate
argument_list|(
name|fd
argument_list|,
name|rp
operator|->
name|Password
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|AnyIncoming
condition|)
name|new
operator|=
name|NCcreate
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
name|RChandoff
argument_list|(
name|fd
argument_list|,
name|HOnntpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant close %d %m"
argument_list|,
name|LogName
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* SUPPRESS 112 */
comment|/* Retrieving long where char is stored */
name|new
operator|->
name|Address
operator|.
name|s_addr
operator|=
name|remote
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s connected %d"
argument_list|,
name|name
condition|?
name|name
else|:
name|inet_ntoa
argument_list|(
name|new
operator|->
name|Address
argument_list|)
argument_list|,
name|new
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Write-done function.  Shouldn't happen. */
end_comment

begin_function
name|STATIC
name|FUNCTYPE
name|RCwritedone
parameter_list|()
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s internal RCwritedone"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Read in the file listing the hosts we take news from, and fill in the **  global list of their Internet addresses.  On modern systems a host can **  have multiple addresses, so we take care to add all of them to the list. **  We can distinguish between the two because h_addr is a #define for the **  first element of the address list in modern systems, while it's a field **  name in old ones. */
end_comment

begin_function
name|STATIC
name|void
name|RCreadfile
parameter_list|(
name|list
parameter_list|,
name|count
parameter_list|,
name|filename
parameter_list|)
name|REMOTEHOST
modifier|*
modifier|*
name|list
decl_stmt|;
name|int
modifier|*
name|count
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|static
name|char
name|NOPASS
index|[]
init|=
literal|""
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|REMOTEHOST
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|pass
decl_stmt|;
name|char
modifier|*
name|pats
decl_stmt|;
name|int
name|errors
decl_stmt|;
comment|/* Free anything that might have been there. */
if|if
condition|(
operator|*
name|list
condition|)
block|{
for|for
control|(
name|rp
operator|=
operator|*
name|list
operator|,
name|i
operator|=
operator|*
name|count
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|rp
operator|++
control|)
block|{
name|DISPOSE
argument_list|(
name|rp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|rp
operator|->
name|Password
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|Patterns
condition|)
name|DISPOSE
argument_list|(
name|rp
operator|->
name|Patterns
argument_list|)
expr_stmt|;
block|}
name|DISPOSE
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Open the server file, count the lines. */
if|if
condition|(
operator|(
name|F
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant read %s %m"
argument_list|,
name|LogName
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|buff
index|[
literal|0
index|]
operator|!=
name|COMMENT_CHAR
operator|&&
name|buff
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|count
operator|=
name|i
expr_stmt|;
name|rp
operator|=
operator|*
name|list
operator|=
name|NEW
argument_list|(
name|REMOTEHOST
argument_list|,
operator|*
name|count
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DO_HAVE_UNIX_DOMAIN
argument_list|)
name|rp
operator|->
name|Address
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|LOOPBACK_HOST
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Name
operator|=
name|COPY
argument_list|(
literal|"localhost"
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Password
operator|=
name|COPY
argument_list|(
name|NOPASS
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Patterns
operator|=
name|NULL
expr_stmt|;
name|rp
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(DO_HAVE_UNIX_DOMAIN) */
comment|/* Now read the file to add all the hosts. */
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|F
argument_list|,
operator|(
name|OFFSET_T
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|errors
operator|=
literal|0
init|;
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
condition|;
control|)
block|{
comment|/* Ignore blank and comment lines. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
name|COMMENT_CHAR
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buff
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|pass
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|pass
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|pats
operator|=
name|strchr
argument_list|(
name|pass
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|pats
operator|++
operator|=
literal|'\0'
expr_stmt|;
else|else
name|pats
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|pass
operator|=
name|NOPASS
expr_stmt|;
name|pats
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Was host specified as as dotted quad? */
if|if
condition|(
operator|(
name|rp
operator|->
name|Address
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|buff
argument_list|)
operator|)
operator|!=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
block|{
name|rp
operator|->
name|Name
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Password
operator|=
name|COPY
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Patterns
operator|=
name|pats
condition|?
name|CommaSplit
argument_list|(
name|COPY
argument_list|(
name|pats
argument_list|)
argument_list|)
else|:
name|NULL
expr_stmt|;
name|rp
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Host specified as a text name? */
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|buff
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant gethostbyname %s %m"
argument_list|,
name|LogName
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|defined
argument_list|(
name|h_addr
argument_list|)
comment|/* Count the addresses and see if we have to grow the list. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s no_address %s %m"
argument_list|,
name|LogName
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
comment|/* Just one, no need to grow. */
name|COPYADDR
argument_list|(
operator|&
name|rp
operator|->
name|Address
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Name
operator|=
name|COPY
argument_list|(
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Password
operator|=
name|COPY
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Patterns
operator|=
name|pats
condition|?
name|CommaSplit
argument_list|(
name|COPY
argument_list|(
name|pats
argument_list|)
argument_list|)
else|:
name|NULL
expr_stmt|;
name|rp
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Note the relative position, grow the array, and restore it. */
name|j
operator|=
name|rp
operator|-
operator|*
name|list
expr_stmt|;
operator|*
name|count
operator|+=
name|i
operator|-
literal|1
expr_stmt|;
name|RENEW
argument_list|(
operator|*
name|list
argument_list|,
name|REMOTEHOST
argument_list|,
operator|*
name|count
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|*
name|list
operator|+
name|j
expr_stmt|;
comment|/* Add all the hosts. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|COPYADDR
argument_list|(
operator|&
name|rp
operator|->
name|Address
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Name
operator|=
name|COPY
argument_list|(
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Password
operator|=
name|COPY
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Patterns
operator|=
name|pats
condition|?
name|CommaSplit
argument_list|(
name|COPY
argument_list|(
name|pats
argument_list|)
argument_list|)
else|:
name|NULL
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
else|#
directive|else
comment|/* Old-style, single address, just add it. */
name|COPYADDR
argument_list|(
operator|&
name|rp
operator|->
name|Address
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Name
operator|=
name|COPY
argument_list|(
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Password
operator|=
name|COPY
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|rp
operator|->
name|Patterns
operator|=
name|pats
condition|?
name|CommaSplit
argument_list|(
name|COPY
argument_list|(
name|pats
argument_list|)
argument_list|)
else|:
name|NULL
expr_stmt|;
name|rp
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* defined(h_addr) */
block|}
operator|*
name|count
operator|=
name|rp
operator|-
operator|*
name|list
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|F
argument_list|)
operator|==
name|EOF
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant fclose %s %m"
argument_list|,
name|LogName
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s bad_hosts %d in %s"
argument_list|,
name|LogName
argument_list|,
name|errors
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|RCreadlist
parameter_list|()
block|{
specifier|static
name|char
name|INNDHOSTS
index|[]
init|=
name|_PATH_INNDHOSTS
decl_stmt|;
name|char
name|name
index|[
sizeof|sizeof
name|_PATH_INNDHOSTS
operator|+
sizeof|sizeof
expr|".nolimit"]
expr_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
name|RCreadfile
argument_list|(
operator|&
name|RCpeerlist
argument_list|,
operator|&
name|RCnpeerlist
argument_list|,
name|INNDHOSTS
argument_list|)
expr_stmt|;
name|FileGlue
argument_list|(
name|name
argument_list|,
name|INNDHOSTS
argument_list|,
literal|'.'
argument_list|,
literal|"nolimit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|Sb
argument_list|)
operator|>=
literal|0
condition|)
name|RCreadfile
argument_list|(
operator|&
name|RCnolimitlist
argument_list|,
operator|&
name|RCnnolimitlist
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Find the name of a remote host we've connected to. */
end_comment

begin_function
name|char
modifier|*
name|RChostname
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
specifier|register
name|REMOTEHOST
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|RCpeerlist
operator|,
name|i
operator|=
name|RCnpeerlist
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|rp
operator|++
control|)
comment|/* SUPPRESS 112 */
comment|/* Retrieving long where char is stored */
if|if
condition|(
name|cp
operator|->
name|Address
operator|.
name|s_addr
operator|==
name|rp
operator|->
name|Address
operator|.
name|s_addr
condition|)
return|return
name|rp
operator|->
name|Name
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buff
argument_list|,
name|inet_ntoa
argument_list|(
name|cp
operator|->
name|Address
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_comment
comment|/* **  Is the remote site allowed to post to this group? */
end_comment

begin_function
name|BOOL
name|RCcanpost
parameter_list|(
name|cp
parameter_list|,
name|group
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|group
decl_stmt|;
block|{
specifier|register
name|REMOTEHOST
modifier|*
name|rp
decl_stmt|;
specifier|register
name|BOOL
name|match
decl_stmt|;
specifier|register
name|BOOL
name|subvalue
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|char
modifier|*
name|pat
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|RCpeerlist
operator|,
name|i
operator|=
name|RCnpeerlist
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|rp
operator|++
control|)
block|{
comment|/* SUPPRESS 112 */
comment|/* Retrieving long where char is stored */
if|if
condition|(
name|cp
operator|->
name|Address
operator|.
name|s_addr
operator|!=
name|rp
operator|->
name|Address
operator|.
name|s_addr
condition|)
continue|continue;
if|if
condition|(
name|rp
operator|->
name|Patterns
operator|==
name|NULL
condition|)
break|break;
for|for
control|(
name|match
operator|=
name|TRUE
operator|,
name|argv
operator|=
name|rp
operator|->
name|Patterns
init|;
operator|(
name|pat
operator|=
operator|*
name|argv
operator|++
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|subvalue
operator|=
operator|*
name|pat
operator|!=
name|SUB_NEGATE
expr_stmt|;
if|if
condition|(
operator|!
name|subvalue
condition|)
name|pat
operator|++
expr_stmt|;
if|if
condition|(
name|wildmat
argument_list|(
name|group
argument_list|,
name|pat
argument_list|)
condition|)
name|match
operator|=
name|subvalue
expr_stmt|;
block|}
return|return
name|match
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  Create the channel. */
end_comment

begin_function
name|void
name|RCsetup
parameter_list|(
name|i
parameter_list|,
name|master
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|master
decl_stmt|;
block|{
name|struct
name|sockaddr_in
name|server
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|INADDR
name|a
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SO_REUSEADDR
argument_list|)
name|int
name|on
decl_stmt|;
endif|#
directive|endif
comment|/* defined(SO_REUSEADDR) */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Create a socket and name it. */
if|if
condition|(
operator|(
name|i
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant socket RCreader %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SO_REUSEADDR
argument_list|)
name|on
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|i
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant setsockopt RCreader %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(SO_REUSEADDR) */
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|POINTER
operator|)
operator|&
name|server
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|server
argument_list|)
expr_stmt|;
name|server
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NNTP_PORT
argument_list|)
expr_stmt|;
name|server
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|server
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|i
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server
argument_list|,
sizeof|sizeof
name|server
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant bind RCreader %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set it up to wait for connections. */
if|if
condition|(
name|listen
argument_list|(
name|i
argument_list|,
name|MAXLISTEN
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant listen RCreader %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|RCchan
operator|=
name|CHANcreate
argument_list|(
name|i
argument_list|,
name|CTremconn
argument_list|,
name|CSwaiting
argument_list|,
name|RCreader
argument_list|,
name|RCwritedone
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s rcsetup %s"
argument_list|,
name|LogName
argument_list|,
name|CHANname
argument_list|(
name|RCchan
argument_list|)
argument_list|)
expr_stmt|;
name|RCHANadd
argument_list|(
name|RCchan
argument_list|)
expr_stmt|;
comment|/* Get the list of hosts we handle. */
name|RCreadlist
argument_list|()
expr_stmt|;
comment|/* If we have a master, get all his addresses. */
name|AmSlave
operator|=
name|master
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|AmSlave
condition|)
block|{
comment|/* Dotted quad? */
if|if
condition|(
operator|(
name|a
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|master
argument_list|)
operator|)
operator|!=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
block|{
name|RCnmaster
operator|=
literal|1
expr_stmt|;
name|RCmaster
operator|=
name|NEW
argument_list|(
name|INADDR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|COPYADDR
argument_list|(
operator|&
name|RCmaster
index|[
literal|0
index|]
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Must be a text name. */
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|master
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant gethostbyname %s %m"
argument_list|,
name|LogName
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|h_addr
argument_list|)
comment|/* Count the addresses. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s no_address %s %m"
argument_list|,
name|LogName
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|RCnmaster
operator|=
name|i
expr_stmt|;
name|RCmaster
operator|=
name|NEW
argument_list|(
name|INADDR
argument_list|,
name|RCnmaster
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|COPYADDR
argument_list|(
operator|&
name|RCmaster
index|[
name|i
index|]
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|RCnmaster
operator|=
literal|1
expr_stmt|;
name|RCmaster
operator|=
name|NEW
argument_list|(
argument|INADDR
argument_list|,
literal|1
argument_list|)
name|COPYADDR
argument_list|(
operator|&
name|RCmaster
index|[
literal|0
index|]
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(h_addr) */
block|}
comment|/* Set flag for nnrp. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"-S%s"
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|RCslaveflag
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Cleanly shut down the channel. */
end_comment

begin_function
name|void
name|RCclose
parameter_list|()
block|{
specifier|register
name|REMOTEHOST
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CHANclose
argument_list|(
name|RCchan
argument_list|,
name|CHANname
argument_list|(
name|RCchan
argument_list|)
argument_list|)
expr_stmt|;
name|RCchan
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|RCpeerlist
condition|)
block|{
for|for
control|(
name|rp
operator|=
name|RCpeerlist
operator|,
name|i
operator|=
name|RCnpeerlist
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|rp
operator|++
control|)
block|{
name|DISPOSE
argument_list|(
name|rp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|rp
operator|->
name|Password
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|Patterns
condition|)
name|DISPOSE
argument_list|(
name|rp
operator|->
name|Patterns
argument_list|)
expr_stmt|;
block|}
name|DISPOSE
argument_list|(
name|RCpeerlist
argument_list|)
expr_stmt|;
name|RCpeerlist
operator|=
name|NULL
expr_stmt|;
name|RCnpeerlist
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|RCmaster
condition|)
block|{
name|DISPOSE
argument_list|(
name|RCmaster
argument_list|)
expr_stmt|;
name|RCmaster
operator|=
name|NULL
expr_stmt|;
name|RCnmaster
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

