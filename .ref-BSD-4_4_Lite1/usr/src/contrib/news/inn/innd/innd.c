begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.39 $ ** **  Variable definitions, miscellany, and main(). */
end_comment

begin_define
define|#
directive|define
name|DEFINE_DATA
end_define

begin_include
include|#
directive|include
file|"innd.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_if
if|#
directive|if
name|NOFILE_LIMIT
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOFILE_LIMIT> 0 */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_FAST_RESOLV
argument_list|)
end_if

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DO_FAST_RESOLV) */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETBUFFER
argument_list|)
end_if

begin_define
define|#
directive|define
name|SETBUFFER
parameter_list|(
name|F
parameter_list|,
name|buff
parameter_list|,
name|size
parameter_list|)
value|setbuffer((F), (buff), (size))
end_define

begin_decl_stmt
name|STATIC
name|int
name|LogBufferSize
init|=
literal|4096
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SETBUFFER
parameter_list|(
name|F
parameter_list|,
name|buff
parameter_list|,
name|size
parameter_list|)
value|setbuf((F), (buff))
end_define

begin_decl_stmt
name|STATIC
name|int
name|LogBufferSize
init|=
name|BUFSIZ
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(HAVE_SETBUFFER) */
end_comment

begin_decl_stmt
name|BOOL
name|AmRoot
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BOOL
name|BufferedLogs
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BOOL
name|NNRPTracing
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BOOL
name|Tracing
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|LogName
index|[]
init|=
literal|"ME"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|SPOOL
index|[]
init|=
name|_PATH_SPOOL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ErrorCount
init|=
name|IO_ERROR_COUNT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|MaxIncoming
init|=
name|DEFAULT_CONNECTIONS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SPOOLlen
init|=
name|STRLEN
argument_list|(
name|SPOOL
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|LargestArticle
init|=
name|MAX_ART_SIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|OPERATINGMODE
name|Mode
init|=
name|OMrunning
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|Cutoff
init|=
name|DEFAULT_CUTOFF
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__CENTERLINE__
argument_list|)
end_if

begin_decl_stmt
name|BOOL
name|Debug
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|BOOL
name|Debug
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__CENTERLINE__) */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|lint
argument_list|)
operator|||
name|defined
argument_list|(
name|__CENTERLINE__
argument_list|)
end_if

begin_decl_stmt
name|int
name|KeepLintQuiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(lint) || defined(__CENTERLINE__) */
end_comment

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|ErrlogBuffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|LogBuffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|ERRLOG
index|[]
init|=
name|_PATH_ERRLOG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|INNDDIR
index|[]
init|=
name|_PATH_INNDDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|LOG
index|[]
init|=
name|_PATH_LOGFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|PID
index|[]
init|=
name|_PATH_SERVERPID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|UID_T
name|NewsUID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|GID_T
name|NewsGID
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* **  Sprintf a long into a buffer with enough leading zero's so that it **  takes up width characters.  Don't add trailing NUL.  Return TRUE **  if it fit.  Used for updating high-water marks in the active file **  in-place. */
end_comment

begin_function
name|BOOL
name|FormatLong
parameter_list|(
name|p
parameter_list|,
name|value
parameter_list|,
name|width
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|long
name|value
decl_stmt|;
specifier|register
name|int
name|width
decl_stmt|;
block|{
for|for
control|(
name|p
operator|+=
name|width
operator|-
literal|1
init|;
name|width
operator|--
operator|>
literal|0
condition|;
control|)
block|{
operator|*
name|p
operator|--
operator|=
call|(
name|int
call|)
argument_list|(
name|value
operator|%
literal|10
argument_list|)
operator|+
literal|'0'
expr_stmt|;
name|value
operator|/=
literal|10
expr_stmt|;
block|}
return|return
name|value
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  Glue a string, a char, and a string together.  Useful for making **  filenames. */
end_comment

begin_function
name|void
name|FileGlue
parameter_list|(
name|p
parameter_list|,
name|n1
parameter_list|,
name|c
parameter_list|,
name|n2
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|n1
decl_stmt|;
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|n2
decl_stmt|;
block|{
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
name|n1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|n2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Turn any \r or \n in text into spaces.  Used to splice back multi-line **  headers into a single line. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|Join
parameter_list|(
name|text
parameter_list|)
specifier|register
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|text
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
return|return
name|text
return|;
block|}
end_function

begin_comment
comment|/* **  Return a short name that won't overrun our bufer or syslog's buffer. **  q should either be p, or point into p where the "interesting" part is. */
end_comment

begin_function
name|char
modifier|*
name|MaxLength
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|80
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Already short enough? */
name|i
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
sizeof|sizeof
name|buff
operator|-
literal|1
condition|)
return|return
name|Join
argument_list|(
name|p
argument_list|)
return|;
comment|/* Simple case of just want the begining? */
if|if
condition|(
name|q
operator|-
name|p
operator|<
sizeof|sizeof
name|buff
operator|-
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buff
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|buff
operator|-
literal|4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|buff
index|[
sizeof|sizeof
name|buff
operator|-
literal|4
index|]
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
comment|/* Is getting last 10 characters good enough? */
elseif|else
if|if
condition|(
operator|(
name|p
operator|+
name|i
operator|)
operator|-
name|q
operator|<
literal|10
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buff
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|buff
operator|-
literal|14
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|buff
index|[
sizeof|sizeof
name|buff
operator|-
literal|14
index|]
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|buff
index|[
sizeof|sizeof
name|buff
operator|-
literal|11
index|]
argument_list|,
operator|&
name|p
index|[
name|i
operator|-
literal|10
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not in last 10 bytes, so use double elipses. */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buff
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|buff
operator|-
literal|17
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|buff
index|[
sizeof|sizeof
name|buff
operator|-
literal|17
index|]
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
operator|&
name|buff
index|[
sizeof|sizeof
name|buff
operator|-
literal|14
index|]
argument_list|,
operator|&
name|q
index|[
operator|-
literal|5
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|buff
index|[
sizeof|sizeof
name|buff
operator|-
literal|4
index|]
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
return|return
name|Join
argument_list|(
name|buff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Split text into comma-separated fields.  Return an allocated **  NULL-terminated array of the fields within the modified argument that **  the caller is expected to save or free.  We don't use strchr() since **  the text is expected to be either relatively short or "comma-dense." */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|CommaSplit
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|char
modifier|*
modifier|*
name|save
decl_stmt|;
comment|/* How much space do we need? */
for|for
control|(
name|i
operator|=
literal|2
operator|,
name|p
operator|=
name|text
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
name|i
operator|++
expr_stmt|;
for|for
control|(
name|av
operator|=
name|save
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|i
argument_list|)
operator|,
operator|*
name|av
operator|++
operator|=
name|p
operator|=
name|text
init|;
operator|*
name|p
condition|;
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|av
operator|++
operator|=
name|p
expr_stmt|;
block|}
else|else
name|p
operator|++
expr_stmt|;
operator|*
name|av
operator|=
name|NULL
expr_stmt|;
return|return
name|save
return|;
block|}
end_function

begin_comment
comment|/* **  Do we need a shell for the command?  If not, av is filled in with **  the individual words of the command and the command is modified to **  have NUL's inserted. */
end_comment

begin_function
name|BOOL
name|NeedShell
parameter_list|(
name|p
parameter_list|,
name|av
parameter_list|,
name|end
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|end
decl_stmt|;
block|{
specifier|static
name|char
name|Metachars
index|[]
init|=
literal|";<>|*?[]{}()#$&=`'\"\\~\n"
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
comment|/* We don't use execvp(); works for users, fails out of /etc/rc. */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|strchr
argument_list|(
name|Metachars
argument_list|,
operator|*
name|q
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|end
operator|--
init|;
name|av
operator|<
name|end
condition|;
control|)
block|{
comment|/* Mark this word, check for shell meta-characters. */
for|for
control|(
operator|*
name|av
operator|++
operator|=
name|p
init|;
operator|*
name|p
operator|&&
operator|!
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
comment|/* If end of list, we're done. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|av
operator|=
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Skip whitespace, find next word. */
for|for
control|(
operator|*
name|p
operator|++
operator|=
literal|'\0'
init|;
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|av
operator|=
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Didn't fit. */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  Spawn a process, with I/O redirected as needed.  Return the PID or -1 **  (and a syslog'd message) on error. */
end_comment

begin_function
name|int
name|Spawn
parameter_list|(
name|fd0
parameter_list|,
name|fd1
parameter_list|,
name|fd2
parameter_list|,
name|av
parameter_list|)
name|int
name|fd0
decl_stmt|;
name|int
name|fd1
decl_stmt|;
name|int
name|fd2
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|NOCLOSE
index|[]
init|=
literal|"%s cant close %d in %s %m"
decl_stmt|;
specifier|static
name|char
name|NODUP2
index|[]
init|=
literal|"%s cant dup2 %d to %d in %s %m"
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Fork; on error, give up.  If not using the patched dbz, make      * this call fork! */
name|i
operator|=
name|FORK
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant fork %s %m"
argument_list|,
name|LogName
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* If parent, do nothing. */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
name|i
return|;
comment|/* Child -- do any I/O redirection. */
if|if
condition|(
name|fd0
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|fd0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
name|NODUP2
argument_list|,
name|LogName
argument_list|,
name|fd0
argument_list|,
literal|0
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd0
operator|!=
name|fd1
operator|&&
name|fd0
operator|!=
name|fd2
operator|&&
name|close
argument_list|(
name|fd0
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
name|NOCLOSE
argument_list|,
name|LogName
argument_list|,
name|fd0
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd1
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|fd1
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
name|NODUP2
argument_list|,
name|LogName
argument_list|,
name|fd1
argument_list|,
literal|1
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd1
operator|!=
name|fd2
operator|&&
name|close
argument_list|(
name|fd1
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
name|NOCLOSE
argument_list|,
name|LogName
argument_list|,
name|fd1
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd2
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|fd2
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
name|NODUP2
argument_list|,
name|LogName
argument_list|,
name|fd2
argument_list|,
literal|2
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fd2
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
name|NOCLOSE
argument_list|,
name|LogName
argument_list|,
name|fd2
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|CloseOnExec
argument_list|(
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|CloseOnExec
argument_list|(
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|CloseOnExec
argument_list|(
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Try to set our permissions. */
if|#
directive|if
name|defined
argument_list|(
name|DO_INND_NICE_KIDS
argument_list|)
operator|(
name|void
operator|)
name|nice
argument_list|(
name|INND_NICE_VALUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_INND_NICE_KIDS) */
if|if
condition|(
name|setgid
argument_list|(
name|NewsGID
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant setgid in %s %m"
argument_list|,
name|LogName
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|NewsUID
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant setuid in %s %m"
argument_list|,
name|LogName
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Close the DBZ database without doing any writing. */
comment|/* Not needed with the patched DBZ; can't be used with vfork.      * (void)dbzcancel();      * (void)dbmclose();      */
comment|/* Start the desired process (finally!). */
operator|(
name|void
operator|)
name|execv
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
name|av
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant exec in %s %m"
argument_list|,
name|LogName
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* **  Stat our control directory and see who should own things. */
end_comment

begin_function
name|STATIC
name|BOOL
name|GetNewsOwnerships
parameter_list|()
block|{
name|struct
name|stat
name|Sb
decl_stmt|;
comment|/* Make sure item exists and is of the right type. */
if|if
condition|(
name|stat
argument_list|(
name|INNDDIR
argument_list|,
operator|&
name|Sb
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|Sb
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|NewsUID
operator|=
name|Sb
operator|.
name|st_uid
expr_stmt|;
name|NewsGID
operator|=
name|Sb
operator|.
name|st_gid
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  Change the onwership of a file. */
end_comment

begin_function
name|void
name|xchown
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|chown
argument_list|(
name|p
argument_list|,
name|NewsUID
argument_list|,
name|NewsGID
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant chown %s %m"
argument_list|,
name|LogName
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Try to make one directory.  Return FALSE on error. */
end_comment

begin_function
name|STATIC
name|BOOL
name|MakeDir
parameter_list|(
name|Name
parameter_list|)
name|char
modifier|*
name|Name
decl_stmt|;
block|{
name|struct
name|stat
name|Sb
decl_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|Name
argument_list|,
name|GROUPDIR_MODE
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|AmRoot
condition|)
name|xchown
argument_list|(
name|Name
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* See if it failed because it already exists. */
return|return
name|stat
argument_list|(
name|Name
argument_list|,
operator|&
name|Sb
argument_list|)
operator|>=
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|Sb
operator|.
name|st_mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Given a directory, comp/foo/bar, create that directory and all **  intermediate directories needed.  Return 0 if ok, else -1. */
end_comment

begin_function
name|BOOL
name|MakeSpoolDirectory
parameter_list|(
name|Name
parameter_list|)
specifier|register
name|char
modifier|*
name|Name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|BOOL
name|made
decl_stmt|;
comment|/* Optimize common case -- parent almost always exists. */
if|if
condition|(
name|MakeDir
argument_list|(
name|Name
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Try to make each of comp and comp/foo in turn. */
for|for
control|(
name|p
operator|=
name|Name
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|made
operator|=
name|MakeDir
argument_list|(
name|Name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
operator|!
name|made
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|MakeDir
argument_list|(
name|Name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Flush one log file, with pessimistic size of working filename buffer. */
end_comment

begin_function
name|void
name|ReopenLog
parameter_list|(
name|F
parameter_list|)
name|FILE
modifier|*
name|F
decl_stmt|;
block|{
name|char
name|buff
index|[
sizeof|sizeof
name|LOG
operator|+
sizeof|sizeof
name|ERRLOG
operator|+
literal|4
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|Name
decl_stmt|;
name|char
modifier|*
name|Buffer
decl_stmt|;
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|Debug
condition|)
return|return;
if|if
condition|(
name|F
operator|==
name|Log
condition|)
block|{
name|Name
operator|=
name|LOG
expr_stmt|;
name|Buffer
operator|=
name|LogBuffer
expr_stmt|;
block|}
else|else
block|{
name|Name
operator|=
name|ERRLOG
expr_stmt|;
name|Buffer
operator|=
name|ErrlogBuffer
expr_stmt|;
block|}
name|FileGlue
argument_list|(
name|buff
argument_list|,
name|Name
argument_list|,
literal|'.'
argument_list|,
literal|"old"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|Name
argument_list|,
name|buff
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant rename %s to %s %m"
argument_list|,
name|LogName
argument_list|,
name|Name
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|mask
operator|=
name|umask
argument_list|(
literal|033
argument_list|)
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|Name
argument_list|,
literal|"a"
argument_list|,
name|F
argument_list|)
operator|!=
name|F
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant freopen %s %m"
argument_list|,
name|LogName
argument_list|,
name|Name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|AmRoot
condition|)
name|xchown
argument_list|(
name|Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufferedLogs
condition|)
name|SETBUFFER
argument_list|(
name|F
argument_list|,
name|Buffer
argument_list|,
name|LogBufferSize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Function called when memory allocation fails. */
end_comment

begin_function
name|STATIC
name|int
name|AllocationFailure
parameter_list|(
name|what
parameter_list|,
name|i
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
block|{
comment|/* Print i as %d so huge values are real obvious. */
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant %s %d bytes %m"
argument_list|,
name|LogName
argument_list|,
name|what
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* **  We ran out of space or other I/O error, throttle ourselves. */
end_comment

begin_function
name|void
name|ThrottleIOError
parameter_list|(
name|when
parameter_list|)
name|char
modifier|*
name|when
decl_stmt|;
block|{
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
name|STRING
name|p
decl_stmt|;
name|int
name|oerrno
decl_stmt|;
if|if
condition|(
name|Mode
operator|==
name|OMrunning
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|Reservation
condition|)
block|{
name|DISPOSE
argument_list|(
name|Reservation
argument_list|)
expr_stmt|;
name|Reservation
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s writing %s file -- throttling"
argument_list|,
name|strerror
argument_list|(
name|oerrno
argument_list|)
argument_list|,
name|when
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|CCblock
argument_list|(
name|OMthrottled
argument_list|,
name|buff
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant throttle %s"
argument_list|,
name|LogName
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s throttle %s"
argument_list|,
name|LogName
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Close down all parts of the system (e.g., before calling exit or exec). */
end_comment

begin_function
name|void
name|JustCleanup
parameter_list|()
block|{
name|SITEflushall
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* PROCclose(FALSE); */
name|CCclose
argument_list|()
expr_stmt|;
name|LCclose
argument_list|()
expr_stmt|;
name|NCclose
argument_list|()
expr_stmt|;
name|RCclose
argument_list|()
expr_stmt|;
name|ICDclose
argument_list|()
expr_stmt|;
name|HISclose
argument_list|()
expr_stmt|;
name|ARTclose
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* PROCclose(TRUE); */
if|if
condition|(
name|unlink
argument_list|(
name|PID
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant unlink %s %m"
argument_list|,
name|LogName
argument_list|,
name|PID
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  The name is self-explanatory. */
end_comment

begin_function
name|NORETURN
name|CleanupAndExit
parameter_list|(
name|x
parameter_list|,
name|why
parameter_list|)
name|int
name|x
decl_stmt|;
name|char
modifier|*
name|why
decl_stmt|;
block|{
name|JustCleanup
argument_list|()
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s shutdown %s"
argument_list|,
name|LogName
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NOFILE_LIMIT
operator|>
literal|0
end_if

begin_comment
comment|/* **  Set the limit on the number of open files we can have.  I don't **  like having to do this. */
end_comment

begin_function
name|STATIC
name|void
name|SetDescriptorLimit
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|struct
name|rlimit
name|rl
decl_stmt|;
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|rl
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant getrlimit(NOFILE) %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
return|return;
block|}
name|rl
operator|.
name|rlim_cur
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|rl
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant setrlimit(NOFILE) %d %m"
argument_list|,
name|LogName
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOFILE_LIMIT> 0 */
end_comment

begin_comment
comment|/* **  Signal handler to catch SIGTERM and queue a clean shutdown. */
end_comment

begin_function
name|STATIC
name|SIGHANDLER
name|CatchTerminate
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
name|GotTerminate
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|s
argument_list|,
name|CatchTerminate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Print a usage message and exit. */
end_comment

begin_function
name|STATIC
name|NORETURN
name|Usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage error.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|WHEN
index|[]
init|=
literal|"PID file"
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|logflags
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
name|char
modifier|*
name|master
decl_stmt|;
name|STRING
name|path
decl_stmt|;
name|STRING
name|p
decl_stmt|;
name|FILE
modifier|*
name|F
decl_stmt|;
name|BOOL
name|ShouldFork
decl_stmt|;
name|BOOL
name|ShouldRenumber
decl_stmt|;
name|BOOL
name|ShouldSyntaxCheck
decl_stmt|;
name|long
name|pid
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG_MALLOC_INC
argument_list|)
name|union
name|malloptarg
name|m
decl_stmt|;
endif|#
directive|endif
comment|/* defined(_DEBUG_MALLOC_INC) */
comment|/* Set up the pathname, first thing. */
name|path
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
operator|||
operator|*
name|path
operator|==
literal|'\0'
condition|)
name|path
operator|=
literal|"innd"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|path
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|ONALLLOCFAIL
argument_list|(
name|AllocationFailure
argument_list|)
expr_stmt|;
name|Version
operator|=
name|INNVersion
argument_list|()
expr_stmt|;
comment|/* Handle malloc debugging. */
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG_MALLOC_INC
argument_list|)
name|m
operator|.
name|i
operator|=
name|M_HANDLE_ABORT
expr_stmt|;
name|dbmallopt
argument_list|(
name|MALLOC_WARN
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|dbmallopt
argument_list|(
name|MALLOC_FATAL
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|m
operator|.
name|i
operator|=
literal|3
expr_stmt|;
name|dbmallopt
argument_list|(
name|MALLOC_FILLAREA
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|m
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|dbmallopt
argument_list|(
name|MALLOC_CKCHAIN
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|dbmallopt
argument_list|(
name|MALLOC_CKDATA
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(_DEBUG_MALLOC_INC) */
comment|/* Set defaults. */
name|TimeOut
operator|.
name|tv_sec
operator|=
name|DEFAULT_TIMEOUT
expr_stmt|;
name|ShouldFork
operator|=
name|TRUE
expr_stmt|;
name|ShouldRenumber
operator|=
name|FALSE
expr_stmt|;
name|ShouldSyntaxCheck
operator|=
name|FALSE
expr_stmt|;
name|logflags
operator|=
name|L_OPENLOG_FLAGS
operator||
name|LOG_NOWAIT
expr_stmt|;
name|port
operator|=
operator|-
literal|1
expr_stmt|;
name|master
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DONT_ALLOW_READERS
argument_list|)
name|NNRPFollows
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DONT_ALLOW_READERS) */
if|#
directive|if
name|defined
argument_list|(
name|DO_FAST_RESOLV
argument_list|)
comment|/* We only use FQDN's in the hosts.nntp file. */
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_FAST_RESOLV) */
comment|/* Parse JCL. */
name|CCcopyargv
argument_list|(
name|av
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"ac:dfi:l:m:o:n:p:rsS:t:ux"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|Usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'a'
case|:
name|AnyIncoming
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|Cutoff
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|Debug
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOG_PERROR
argument_list|)
name|logflags
operator|=
name|LOG_PERROR
operator||
operator|(
name|logflags
operator|&
operator|~
name|LOG_CONS
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(LOG_PERROR) */
break|break;
case|case
literal|'f'
case|:
name|ShouldFork
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|MaxIncoming
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|LargestArticle
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|ModeReason
condition|)
name|DISPOSE
argument_list|(
name|ModeReason
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|optarg
condition|)
block|{
default|default:
name|Usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'g'
case|:
name|Mode
operator|=
name|OMrunning
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|Mode
operator|=
name|OMpaused
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|Mode
operator|=
name|OMthrottled
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Mode
operator|!=
name|OMrunning
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%sed from command line"
argument_list|,
name|Mode
operator|==
name|OMpaused
condition|?
literal|"Paus"
else|:
literal|"Throttl"
argument_list|)
expr_stmt|;
name|ModeReason
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
switch|switch
condition|(
operator|*
name|optarg
condition|)
block|{
default|default:
name|Usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'n'
case|:
name|NNRPFollows
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|NNRPFollows
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'o'
case|:
name|MaxOutgoing
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Silently ignore multiple -p flags, in case ctlinnd xexec 	     * called inndstart. */
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
block|{
name|port
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|AmRoot
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
name|ShouldRenumber
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ShouldSyntaxCheck
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|master
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|TimeOut
operator|.
name|tv_sec
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|BufferedLogs
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|AlwaysCrosspost
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|ac
operator|-=
name|optind
expr_stmt|;
if|if
condition|(
name|ac
operator|!=
literal|0
condition|)
name|Usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|ModeReason
operator|&&
name|NNRPFollows
condition|)
name|NNRPReason
operator|=
name|COPY
argument_list|(
name|ModeReason
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
name|path
argument_list|,
name|logflags
argument_list|,
name|LOG_INN_SERVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ShouldSyntaxCheck
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|CCcheckfile
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Go to where the data is. */
if|if
condition|(
name|chdir
argument_list|(
name|SPOOL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant chdir %s %m"
argument_list|,
name|LogName
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Get the Path entry. */
if|if
condition|(
operator|(
name|path
operator|=
name|GetConfigValue
argument_list|(
name|_CONF_PATHHOST
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant GetConfigValue %s %m"
argument_list|,
name|LogName
argument_list|,
name|_CONF_PATHHOST
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Path
operator|.
name|Used
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
expr_stmt|;
name|Path
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|Path
operator|.
name|Used
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Path
operator|.
name|Data
argument_list|,
literal|"%s!"
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Get the Xref prefix. */
name|Xref
operator|.
name|Size
operator|=
name|SMBUF
expr_stmt|;
name|Xref
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|Xref
operator|.
name|Size
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Xref
operator|.
name|Data
argument_list|,
literal|"Xref: %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|Xref
operator|.
name|Used
operator|=
name|strlen
argument_list|(
name|Xref
operator|.
name|Data
argument_list|)
expr_stmt|;
name|Xrefbase
operator|=
name|Xref
operator|.
name|Used
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__CENTERLINE__
argument_list|)
comment|/* Set standard input to /dev/null. */
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant open /dev/null %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dup2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s cant dup2 %d to 0 %m"
argument_list|,
name|LogName
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(__CENTERLINE__) */
comment|/* Set up our permissions. */
operator|(
name|void
operator|)
name|umask
argument_list|(
name|NEWSUMASK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GetNewsOwnerships
argument_list|()
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s internal cant stat control directory %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|!=
operator|-
literal|1
operator|&&
name|setgid
argument_list|(
name|NewsGID
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant setgid running as %d not %d %m"
argument_list|,
name|LogName
argument_list|,
operator|(
name|int
operator|)
name|getgid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|NewsGID
argument_list|)
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
block|{
name|Log
operator|=
name|stdout
expr_stmt|;
name|Errlog
operator|=
name|stderr
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|CatchTerminate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ShouldFork
condition|)
block|{
comment|/* Become a server. */
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant fork %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCNOTTY
argument_list|)
comment|/* Disassociate from terminal. */
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|i
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant ioctl(TIOCNOTTY) %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant close /dev/tty %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(TIOCNOTTY) */
if|#
directive|if
name|defined
argument_list|(
name|DO_HAVE_SETSID
argument_list|)
operator|(
name|void
operator|)
name|setsid
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_HAVE_SETSID) */
block|}
comment|/* Open the Log. */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Log
operator|=
name|fopen
argument_list|(
name|LOG
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant fopen %s %m"
argument_list|,
name|LogName
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AmRoot
condition|)
name|xchown
argument_list|(
name|LOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufferedLogs
operator|&&
operator|(
name|LogBuffer
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|LogBufferSize
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|SETBUFFER
argument_list|(
name|Log
argument_list|,
name|LogBuffer
argument_list|,
name|LogBufferSize
argument_list|)
expr_stmt|;
comment|/* Open the Errlog. */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Errlog
operator|=
name|fopen
argument_list|(
name|ERRLOG
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant fopen %s %m"
argument_list|,
name|LogName
argument_list|,
name|ERRLOG
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AmRoot
condition|)
name|xchown
argument_list|(
name|ERRLOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufferedLogs
operator|&&
operator|(
name|ErrlogBuffer
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|LogBufferSize
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|SETBUFFER
argument_list|(
name|Errlog
argument_list|,
name|ErrlogBuffer
argument_list|,
name|LogBufferSize
argument_list|)
expr_stmt|;
block|}
comment|/* Set number of open channels. */
if|#
directive|if
name|NOFILE_LIMIT
operator|>
literal|0
if|if
condition|(
name|AmRoot
condition|)
name|SetDescriptorLimit
argument_list|(
name|NOFILE_LIMIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOFILE_LIMIT> 0 */
comment|/* Get number of open channels. */
if|if
condition|(
operator|(
name|i
operator|=
name|getfdcount
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant getfdcount %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s descriptors %d"
argument_list|,
name|LogName
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|MaxOutgoing
operator|==
literal|0
condition|)
block|{
comment|/* getfdcount() - (stdio + dbz + cc + lc + rc + art + fudge) */
name|MaxOutgoing
operator|=
name|i
operator|-
operator|(
literal|3
operator|+
literal|3
operator|+
literal|2
operator|+
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|2
operator|)
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s outgoing %d"
argument_list|,
name|LogName
argument_list|,
name|MaxOutgoing
argument_list|)
expr_stmt|;
block|}
comment|/* See if another instance is alive. */
if|if
condition|(
operator|(
name|F
operator|=
name|fopen
argument_list|(
name|PID
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|pid
operator|=
name|atoi
argument_list|(
name|buff
argument_list|)
operator|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|kill
argument_list|(
operator|(
name|PID_T
operator|)
name|pid
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
operator|||
name|errno
operator|!=
name|ESRCH
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s already_running pid %d"
argument_list|,
name|LogName
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the various parts of the system.  Channel feeds start      * processes so call PROCsetup before ICDsetup.  NNTP needs to know      * if it's a slave, so call RCsetup before NCsetup. */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|CatchTerminate
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGDANGER
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGDANGER
argument_list|,
name|CatchTerminate
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(SIGDANGER) */
name|CHANsetup
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|PROCsetup
argument_list|(
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|HISsetup
argument_list|()
expr_stmt|;
name|CCsetup
argument_list|()
expr_stmt|;
name|LCsetup
argument_list|()
expr_stmt|;
name|RCsetup
argument_list|(
name|port
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|NCsetup
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ARTsetup
argument_list|()
expr_stmt|;
name|ICDsetup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG_MALLOC_INC
argument_list|)
name|m
operator|.
name|i
operator|=
literal|1
expr_stmt|;
name|dbmallopt
argument_list|(
name|MALLOC_CKCHAIN
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|dbmallopt
argument_list|(
name|MALLOC_CKDATA
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(_DEBUG_MALLOC_INC) */
comment|/* Record our PID. */
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|F
operator|=
name|fopen
argument_list|(
name|PID
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant fopen %s %m"
argument_list|,
name|LogName
argument_list|,
name|PID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|)
operator|==
name|EOF
operator|||
name|ferror
argument_list|(
name|F
argument_list|)
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant fprintf %s %m"
argument_list|,
name|LogName
argument_list|,
name|PID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|F
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant fclose %s %m"
argument_list|,
name|LogName
argument_list|,
name|PID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|PID
argument_list|,
literal|0664
argument_list|)
operator|<
literal|0
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant chmod %s %m"
argument_list|,
name|LogName
argument_list|,
name|PID
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* And away we go... */
if|if
condition|(
name|ShouldRenumber
condition|)
block|{
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s renumbering"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|ICDrenumberactive
argument_list|()
expr_stmt|;
block|}
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s starting"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|CHANreadloop
argument_list|()
expr_stmt|;
name|CleanupAndExit
argument_list|(
literal|1
argument_list|,
literal|"CHANreadloop returned"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

end_unit

