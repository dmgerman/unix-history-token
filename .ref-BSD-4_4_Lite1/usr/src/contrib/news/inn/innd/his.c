begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.21 $ ** **  History file routines. */
end_comment

begin_include
include|#
directive|include
file|"innd.h"
end_include

begin_include
include|#
directive|include
file|"dbz.h"
end_include

begin_decl_stmt
name|STATIC
name|char
name|HIShistpath
index|[]
init|=
name|_PATH_HISTORY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|FILE
modifier|*
name|HISwritefp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|HISreadfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|HISdirty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|HISincore
init|=
name|INND_DBZINCORE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Set up the history files. */
end_comment

begin_function
name|void
name|HISsetup
parameter_list|()
block|{
if|if
condition|(
name|HISwritefp
operator|==
name|NULL
condition|)
block|{
comment|/* Open the history file for appending formatted I/O. */
if|if
condition|(
operator|(
name|HISwritefp
operator|=
name|fopen
argument_list|(
name|HIShistpath
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant fopen %s %m"
argument_list|,
name|LogName
argument_list|,
name|HIShistpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|CloseOnExec
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|HISwritefp
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Open the history file for reading. */
if|if
condition|(
operator|(
name|HISreadfd
operator|=
name|open
argument_list|(
name|HIShistpath
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant open %s %m"
argument_list|,
name|LogName
argument_list|,
name|HIShistpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|CloseOnExec
argument_list|(
name|HISreadfd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Open the DBZ file. */
operator|(
name|void
operator|)
name|dbzincore
argument_list|(
name|HISincore
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dbzwritethrough
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbminit
argument_list|(
name|HIShistpath
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant dbminit %s %m"
argument_list|,
name|HIShistpath
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  Synchronize the in-core history file (flush it). */
end_comment

begin_function
name|void
name|HISsync
parameter_list|()
block|{
if|if
condition|(
name|HISdirty
condition|)
block|{
if|if
condition|(
name|dbzsync
argument_list|()
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant dbzsync %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|HISdirty
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Close the history files. */
end_comment

begin_function
name|void
name|HISclose
parameter_list|()
block|{
if|if
condition|(
name|HISwritefp
operator|!=
name|NULL
condition|)
block|{
comment|/* Since dbmclose calls dbzsync we could replace this line with 	 * "HISdirty = 0;".  Oh well, it keeps the abstraction clean. */
name|HISsync
argument_list|()
expr_stmt|;
if|if
condition|(
name|dbmclose
argument_list|()
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant dbmclose %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|HISwritefp
argument_list|)
operator|==
name|EOF
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant fclose history %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|HISwritefp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|HISreadfd
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant close history %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|HISreadfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  File in the DBZ datum for a Message-ID, making sure not to copy any **  illegal characters. */
end_comment

begin_function
name|STATIC
name|void
name|HISsetkey
parameter_list|(
name|p
parameter_list|,
name|keyp
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|datum
modifier|*
name|keyp
decl_stmt|;
block|{
specifier|static
name|BUFFER
name|MessageID
decl_stmt|;
specifier|register
name|char
modifier|*
name|dest
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Get space to hold the ID. */
name|i
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|MessageID
operator|.
name|Data
operator|==
name|NULL
condition|)
block|{
name|MessageID
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|MessageID
operator|.
name|Size
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MessageID
operator|.
name|Size
operator|<
name|i
condition|)
block|{
name|RENEW
argument_list|(
name|MessageID
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|MessageID
operator|.
name|Size
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|keyp
operator|->
name|dptr
operator|=
name|dest
operator|=
name|MessageID
operator|.
name|Data
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|HIS_FIELDSEP
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
operator|*
name|dest
operator|++
operator|=
name|HIS_BADCHAR
expr_stmt|;
else|else
operator|*
name|dest
operator|++
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
name|keyp
operator|->
name|dsize
operator|=
name|dest
operator|-
name|MessageID
operator|.
name|Data
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Get the list of files under which a Message-ID is stored. */
end_comment

begin_function
name|char
modifier|*
name|HISfilesfor
parameter_list|(
name|MessageID
parameter_list|)
name|char
modifier|*
name|MessageID
decl_stmt|;
block|{
specifier|static
name|BUFFER
name|Files
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
name|datum
name|key
decl_stmt|;
name|datum
name|val
decl_stmt|;
name|long
name|offset
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Get the seek value into the history file. */
name|HISsetkey
argument_list|(
name|MessageID
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|val
operator|=
name|dbzfetch
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|dptr
operator|==
name|NULL
operator|||
name|val
operator|.
name|dsize
operator|!=
sizeof|sizeof
name|offset
condition|)
return|return
name|NULL
return|;
comment|/* Get space. */
if|if
condition|(
name|Files
operator|.
name|Data
operator|==
name|NULL
condition|)
block|{
name|Files
operator|.
name|Size
operator|=
name|BUFSIZ
expr_stmt|;
name|Files
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|Files
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the value to an aligned spot. */
for|for
control|(
name|p
operator|=
name|val
operator|.
name|dptr
operator|,
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|offset
operator|,
name|i
operator|=
sizeof|sizeof
name|offset
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|dest
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|HISreadfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
comment|/* Read the text until \n or EOF. */
for|for
control|(
name|Files
operator|.
name|Used
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|i
operator|=
name|read
argument_list|(
name|HISreadfd
argument_list|,
operator|&
name|Files
operator|.
name|Data
index|[
name|Files
operator|.
name|Used
index|]
argument_list|,
name|Files
operator|.
name|Size
operator|-
name|Files
operator|.
name|Used
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
name|Files
operator|.
name|Used
operator|+=
name|i
expr_stmt|;
name|Files
operator|.
name|Data
index|[
name|Files
operator|.
name|Used
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|Files
operator|.
name|Data
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
comment|/* If we have half our buffer left, get more space. */
if|if
condition|(
name|Files
operator|.
name|Size
operator|-
name|Files
operator|.
name|Used
operator|<
name|Files
operator|.
name|Size
operator|/
literal|2
condition|)
block|{
name|Files
operator|.
name|Size
operator|+=
name|BUFSIZ
expr_stmt|;
name|RENEW
argument_list|(
name|Files
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|Files
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Move past the first two fields -- Message-ID and date info. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|Files
operator|.
name|Data
argument_list|,
name|HIS_FIELDSEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|HIS_FIELDSEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Translate newsgroup separators to slashes, return the fieldstart. */
for|for
control|(
name|dest
operator|=
operator|++
name|p
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* **  Have we already seen an article? */
end_comment

begin_function
name|BOOL
name|HIShavearticle
parameter_list|(
name|MessageID
parameter_list|)
name|char
modifier|*
name|MessageID
decl_stmt|;
block|{
name|datum
name|key
decl_stmt|;
name|datum
name|val
decl_stmt|;
name|HISsetkey
argument_list|(
name|MessageID
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|val
operator|=
name|dbzfetch
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|val
operator|.
name|dptr
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Turn a history filename entry from slashes to dots.  It's a pity **  we have to do this. */
end_comment

begin_function
name|STATIC
name|void
name|HISslashify
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|last
decl_stmt|;
for|for
control|(
name|last
operator|=
name|NULL
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
operator|*
name|p
operator|=
literal|'.'
expr_stmt|;
name|last
operator|=
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|&&
name|last
operator|!=
name|NULL
condition|)
operator|*
name|last
operator|=
literal|'/'
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
operator|*
name|last
operator|=
literal|'/'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Write a history entry. */
end_comment

begin_function
name|BOOL
name|HISwrite
parameter_list|(
name|Data
parameter_list|,
name|paths
parameter_list|)
name|ARTDATA
modifier|*
name|Data
decl_stmt|;
name|char
modifier|*
name|paths
decl_stmt|;
block|{
specifier|static
name|char
name|NOPATHS
index|[]
init|=
literal|""
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|datum
name|key
decl_stmt|;
name|datum
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HISsetkey
argument_list|(
name|Data
operator|->
name|MessageID
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|paths
operator|!=
name|NULL
operator|&&
name|paths
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|HISslashify
argument_list|(
name|paths
argument_list|)
expr_stmt|;
else|else
name|paths
operator|=
name|NOPATHS
expr_stmt|;
name|offset
operator|=
name|ftell
argument_list|(
name|HISwritefp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Data
operator|->
name|Expires
operator|>
literal|0
condition|)
name|i
operator|=
name|fprintf
argument_list|(
name|HISwritefp
argument_list|,
literal|"%s%c%ld%c%ld%c%ld%c%s\n"
argument_list|,
name|key
operator|.
name|dptr
argument_list|,
name|HIS_FIELDSEP
argument_list|,
operator|(
name|long
operator|)
name|Data
operator|->
name|Arrived
argument_list|,
name|HIS_SUBFIELDSEP
argument_list|,
operator|(
name|long
operator|)
name|Data
operator|->
name|Expires
argument_list|,
name|HIS_SUBFIELDSEP
argument_list|,
operator|(
name|long
operator|)
name|Data
operator|->
name|Posted
argument_list|,
name|HIS_FIELDSEP
argument_list|,
name|paths
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|fprintf
argument_list|(
name|HISwritefp
argument_list|,
literal|"%s%c%ld%c%s%c%ld%c%s\n"
argument_list|,
name|key
operator|.
name|dptr
argument_list|,
name|HIS_FIELDSEP
argument_list|,
operator|(
name|long
operator|)
name|Data
operator|->
name|Arrived
argument_list|,
name|HIS_SUBFIELDSEP
argument_list|,
name|HIS_NOEXP
argument_list|,
name|HIS_SUBFIELDSEP
argument_list|,
operator|(
name|long
operator|)
name|Data
operator|->
name|Posted
argument_list|,
name|HIS_FIELDSEP
argument_list|,
name|paths
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EOF
operator|||
name|fflush
argument_list|(
name|HISwritefp
argument_list|)
operator|==
name|EOF
condition|)
block|{
comment|/* The history line is now an orphan... */
name|IOError
argument_list|(
literal|"history"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write history %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Set up the database values and write them. */
name|val
operator|.
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|offset
expr_stmt|;
name|val
operator|.
name|dsize
operator|=
sizeof|sizeof
name|offset
expr_stmt|;
if|if
condition|(
name|dbzstore
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
operator|<
literal|0
condition|)
block|{
name|IOError
argument_list|(
literal|"history database"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant dbzstore %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|++
name|HISdirty
operator|>=
name|ICD_SYNC_COUNT
condition|)
name|HISsync
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

