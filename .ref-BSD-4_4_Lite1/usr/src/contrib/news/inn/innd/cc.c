begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.41 $ ** **  Routines for the control channel.  Create a Unix-domain datagram socket **  that processes on the local server send messages to.  The control **  channel is used only by ctlinnd to tell the server to perform **  special functions.  We use datagrams so that we don't need to do an **  accept() and tie up another descriptor.  Recvfrom seems to be broken on **  several systems, so the client passes in the socket name. ** **  This module completely rips away all pretense of software layering. */
end_comment

begin_include
include|#
directive|include
file|"innd.h"
end_include

begin_include
include|#
directive|include
file|"inndcomm.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_HAVE_UNIX_DOMAIN
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DO_HAVE_UNIX_DOMAIN) */
end_comment

begin_comment
comment|/* **  An entry in the dispatch table.  The name, and implementing function, **  of every command we support. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_CCDISPATCH
block|{
name|char
name|Name
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|STRING
function_decl|(
modifier|*
name|Function
function_decl|)
parameter_list|()
function_decl|;
block|}
name|CCDISPATCH
typedef|;
end_typedef

begin_function_decl
name|STATIC
name|STRING
name|CCaddhist
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCallow
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCbegin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCchgroup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCdrop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCflush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCflushlogs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCgo
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CChangup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCreserve
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCmode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCnewgroup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCparam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCpause
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCreaders
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCrefile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCreject
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCreload
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCrenumber
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCrmgroup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCsend
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCshutdown
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCsignal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCthrottle
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCtrace
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCxabort
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|STRING
name|CCxexec
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|STATIC
name|char
name|CCpath
index|[]
init|=
name|_PATH_NEWSCONTROL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
modifier|*
name|CCargv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|CCnosite
index|[]
init|=
literal|"1 No such site"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|CCwrongtype
index|[]
init|=
literal|"1 Wrong site type"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|CCnogroup
index|[]
init|=
literal|"1 No such group"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|CCnochannel
index|[]
init|=
literal|"1 No such channel"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|CCnoreason
index|[]
init|=
literal|"1 Empty reason"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|CCnotrunning
index|[]
init|=
literal|"1 Must be running"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BUFFER
name|CCreply
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|CHANNEL
modifier|*
name|CCchan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|CCwriter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|CCDISPATCH
name|CCcommands
index|[]
init|=
block|{
block|{
name|SC_ADDHIST
block|,
literal|5
block|,
name|CCaddhist
block|}
block|,
block|{
name|SC_ALLOW
block|,
literal|1
block|,
name|CCallow
block|}
block|,
block|{
name|SC_BEGIN
block|,
literal|1
block|,
name|CCbegin
block|}
block|,
block|{
name|SC_CANCEL
block|,
literal|1
block|,
name|CCcancel
block|}
block|,
block|{
name|SC_CHANGEGROUP
block|,
literal|2
block|,
name|CCchgroup
block|}
block|,
block|{
name|SC_CHECKFILE
block|,
literal|0
block|,
name|CCcheckfile
block|}
block|,
block|{
name|SC_DROP
block|,
literal|1
block|,
name|CCdrop
block|}
block|,
block|{
name|SC_FLUSH
block|,
literal|1
block|,
name|CCflush
block|}
block|,
block|{
name|SC_FLUSHLOGS
block|,
literal|0
block|,
name|CCflushlogs
block|}
block|,
block|{
name|SC_GO
block|,
literal|1
block|,
name|CCgo
block|}
block|,
block|{
name|SC_HANGUP
block|,
literal|1
block|,
name|CChangup
block|}
block|,
block|{
name|SC_MODE
block|,
literal|0
block|,
name|CCmode
block|}
block|,
block|{
name|SC_NAME
block|,
literal|1
block|,
name|CCname
block|}
block|,
block|{
name|SC_NEWGROUP
block|,
literal|3
block|,
name|CCnewgroup
block|}
block|,
block|{
name|SC_PARAM
block|,
literal|2
block|,
name|CCparam
block|}
block|,
block|{
name|SC_PAUSE
block|,
literal|1
block|,
name|CCpause
block|}
block|,
block|{
name|SC_READERS
block|,
literal|2
block|,
name|CCreaders
block|}
block|,
block|{
name|SC_REFILE
block|,
literal|2
block|,
name|CCrefile
block|}
block|,
block|{
name|SC_REJECT
block|,
literal|1
block|,
name|CCreject
block|}
block|,
block|{
name|SC_RENUMBER
block|,
literal|1
block|,
name|CCrenumber
block|}
block|,
block|{
name|SC_RELOAD
block|,
literal|2
block|,
name|CCreload
block|}
block|,
block|{
name|SC_RESERVE
block|,
literal|1
block|,
name|CCreserve
block|}
block|,
block|{
name|SC_RMGROUP
block|,
literal|1
block|,
name|CCrmgroup
block|}
block|,
block|{
name|SC_SEND
block|,
literal|2
block|,
name|CCsend
block|}
block|,
block|{
name|SC_SHUTDOWN
block|,
literal|1
block|,
name|CCshutdown
block|}
block|,
block|{
name|SC_SIGNAL
block|,
literal|2
block|,
name|CCsignal
block|}
block|,
block|{
name|SC_THROTTLE
block|,
literal|1
block|,
name|CCthrottle
block|}
block|,
block|{
name|SC_TRACE
block|,
literal|2
block|,
name|CCtrace
block|}
block|,
block|{
name|SC_XABORT
block|,
literal|1
block|,
name|CCxabort
block|}
block|,
block|{
name|SC_XEXEC
block|,
literal|1
block|,
name|CCxexec
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|CCcopyargv
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Get the vector size. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|av
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
continue|continue;
comment|/* Get the vector, copy each element. */
for|for
control|(
name|v
operator|=
name|CCargv
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|i
operator|+
literal|1
argument_list|)
init|;
operator|*
name|av
condition|;
name|av
operator|++
control|)
operator|*
name|v
operator|++
operator|=
name|COPY
argument_list|(
operator|*
name|av
argument_list|)
expr_stmt|;
operator|*
name|v
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Add<> around Message-ID if needed. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCgetid
parameter_list|(
name|p
parameter_list|,
name|store
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|store
decl_stmt|;
block|{
specifier|static
name|char
name|NULLMESGID
index|[]
init|=
literal|"1 Empty Message-ID"
decl_stmt|;
specifier|static
name|BUFFER
name|Save
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|NULLMESGID
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
return|return
name|NULLMESGID
return|;
operator|*
name|store
operator|=
name|p
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Make sure the Message-ID buffer has room. */
name|i
operator|=
literal|1
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|Save
operator|.
name|Data
operator|==
name|NULL
condition|)
block|{
name|Save
operator|.
name|Size
operator|=
name|i
expr_stmt|;
name|Save
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|Save
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Save
operator|.
name|Size
operator|<
name|i
condition|)
block|{
name|Save
operator|.
name|Size
operator|=
name|i
expr_stmt|;
name|RENEW
argument_list|(
name|Save
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|Save
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
operator|*
name|store
operator|=
name|Save
operator|.
name|Data
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
operator|*
name|store
argument_list|,
literal|"<%s>"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Abort and dump core. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCxabort
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s abort %s"
argument_list|,
name|LogName
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant abort %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|CleanupAndExit
argument_list|(
literal|1
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* **  Do the work needed to add a history entry. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCaddhist
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|DIGITS
index|[]
init|=
literal|"0123456789"
decl_stmt|;
name|ARTDATA
name|Data
decl_stmt|;
name|STRING
name|p
decl_stmt|;
name|BOOL
name|ok
decl_stmt|;
comment|/* Check the fields. */
if|if
condition|(
operator|(
name|p
operator|=
name|CCgetid
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|Data
operator|.
name|MessageID
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|p
return|;
if|if
condition|(
name|HIShavearticle
argument_list|(
name|Data
operator|.
name|MessageID
argument_list|)
condition|)
return|return
literal|"1 Duplicate"
return|;
if|if
condition|(
name|strspn
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
name|DIGITS
argument_list|)
operator|!=
name|strlen
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|"1 Bad arrival date"
return|;
name|Data
operator|.
name|Arrived
operator|=
name|atol
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strspn
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
name|DIGITS
argument_list|)
operator|!=
name|strlen
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
literal|"1 Bad expiration date"
return|;
name|Data
operator|.
name|Expires
operator|=
name|atol
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strspn
argument_list|(
name|av
index|[
literal|3
index|]
argument_list|,
name|DIGITS
argument_list|)
operator|!=
name|strlen
argument_list|(
name|av
index|[
literal|3
index|]
argument_list|)
condition|)
return|return
literal|"1 Bad posted date"
return|;
name|Data
operator|.
name|Posted
operator|=
name|atol
argument_list|(
name|av
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mode
operator|==
name|OMrunning
condition|)
name|ok
operator|=
name|HISwrite
argument_list|(
operator|&
name|Data
argument_list|,
name|av
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Possible race condition, but documented in ctlinnd manpage. */
name|HISsetup
argument_list|()
expr_stmt|;
name|ok
operator|=
name|HISwrite
argument_list|(
operator|&
name|Data
argument_list|,
name|av
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|HISclose
argument_list|()
expr_stmt|;
block|}
return|return
name|ok
condition|?
name|NULL
else|:
literal|"1 Write failed"
return|;
block|}
end_function

begin_comment
comment|/* **  Do the work to allow foreign connectiosn. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCallow
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|RejectReason
operator|==
name|NULL
condition|)
return|return
literal|"1 Already allowed"
return|;
name|p
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&&
operator|!
name|EQ
argument_list|(
name|p
argument_list|,
name|RejectReason
argument_list|)
condition|)
return|return
literal|"1 Wrong reason"
return|;
name|DISPOSE
argument_list|(
name|RejectReason
argument_list|)
expr_stmt|;
name|RejectReason
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Do the work needed to start feeding a (new) site. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCbegin
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|SITE
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|STRING
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|strings
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
name|STRING
name|error
decl_stmt|;
name|char
modifier|*
name|subbed
decl_stmt|;
comment|/* If site already exists, drop it. */
if|if
condition|(
name|SITEfind
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|=
name|CCdrop
argument_list|(
name|av
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|p
return|;
comment|/* Find the named site. */
name|length
operator|=
name|strlen
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|strings
operator|=
name|SITEreadfile
argument_list|(
name|TRUE
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|strings
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|p
index|[
name|length
index|]
operator|==
name|NF_FIELD_SEP
operator|||
name|p
index|[
name|length
index|]
operator|==
name|NF_SUBFIELD_SEP
operator|)
operator|&&
name|caseEQn
argument_list|(
name|p
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|,
name|length
argument_list|)
condition|)
block|{
name|p
operator|=
name|COPY
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|CCnosite
return|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'M'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'E'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
name|NF_FIELD_SEP
condition|)
name|sp
operator|=
operator|&
name|ME
expr_stmt|;
else|else
block|{
comment|/* Get space for the new site entry, and space for it in all 	 * the groups. */
for|for
control|(
name|i
operator|=
name|nSites
operator|,
name|sp
operator|=
name|Sites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|Name
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|nSites
operator|++
expr_stmt|;
name|RENEW
argument_list|(
name|Sites
argument_list|,
name|SITE
argument_list|,
name|nSites
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|&
name|Sites
index|[
name|nSites
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nGroups
operator|,
name|ngp
operator|=
name|Groups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
control|)
name|RENEW
argument_list|(
name|ngp
operator|->
name|Sites
argument_list|,
name|int
argument_list|,
name|nSites
argument_list|)
expr_stmt|;
block|}
name|SITElinkall
argument_list|()
expr_stmt|;
block|}
comment|/* Parse. */
name|subbed
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|nGroups
argument_list|)
expr_stmt|;
name|error
operator|=
name|SITEparseone
argument_list|(
name|p
argument_list|,
name|sp
argument_list|,
name|subbed
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|subbed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|NULL
condition|)
block|{
name|DISPOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s bad_newsfeeds %s"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
literal|"1 Parse error"
return|;
block|}
if|if
condition|(
name|sp
operator|!=
operator|&
name|ME
operator|&&
operator|(
operator|!
name|SITEsetup
argument_list|(
name|sp
argument_list|)
operator|||
operator|!
name|SITEfunnelpatch
argument_list|()
operator|)
condition|)
return|return
literal|"1 Startup error"
return|;
name|SITEforward
argument_list|(
name|sp
argument_list|,
literal|"begin"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Common code to change a group's flags. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCdochange
parameter_list|(
name|ngp
parameter_list|,
name|Rest
parameter_list|)
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
name|char
modifier|*
name|Rest
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ngp
operator|->
name|Rest
index|[
literal|0
index|]
operator|==
name|Rest
index|[
literal|0
index|]
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|Rest
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngp
operator|->
name|Rest
index|[
name|length
index|]
operator|==
literal|'\n'
operator|&&
name|EQn
argument_list|(
name|ngp
operator|->
name|Rest
argument_list|,
name|Rest
argument_list|,
name|length
argument_list|)
condition|)
return|return
literal|"0 Group status unchanged"
return|;
block|}
if|if
condition|(
name|Mode
operator|!=
name|OMrunning
condition|)
return|return
name|CCnotrunning
return|;
name|p
operator|=
name|COPY
argument_list|(
name|ngp
operator|->
name|Name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ICDchangegroup
argument_list|(
name|ngp
argument_list|,
name|Rest
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s cant change_group %s to %s"
argument_list|,
name|LogName
argument_list|,
name|p
argument_list|,
name|Rest
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|"1 Change failed (probably can't write active?)"
return|;
block|}
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s change_group %s to %s"
argument_list|,
name|LogName
argument_list|,
name|p
argument_list|,
name|Rest
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Change the mode of a newsgroup. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCchgroup
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
name|char
modifier|*
name|Rest
decl_stmt|;
if|if
condition|(
operator|(
name|ngp
operator|=
name|NGfind
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|CCnogroup
return|;
name|Rest
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|Rest
index|[
literal|0
index|]
operator|!=
name|NF_FLAG_ALIAS
condition|)
block|{
name|Rest
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|CTYPE
argument_list|(
name|isupper
argument_list|,
name|Rest
index|[
literal|0
index|]
argument_list|)
condition|)
name|Rest
index|[
literal|0
index|]
operator|=
name|tolower
argument_list|(
name|Rest
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|CCdochange
argument_list|(
name|ngp
argument_list|,
name|Rest
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Cancel a message. */
end_comment

begin_function
name|STRING
name|CCcancel
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|ARTDATA
name|Data
decl_stmt|;
name|STRING
name|p
decl_stmt|;
name|Data
operator|.
name|Posted
operator|=
name|Now
operator|.
name|time
expr_stmt|;
name|Data
operator|.
name|Expires
operator|=
literal|0
expr_stmt|;
name|Data
operator|.
name|Feedsite
operator|=
literal|"?"
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|CCgetid
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|Data
operator|.
name|MessageID
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|p
return|;
if|if
condition|(
name|Mode
operator|==
name|OMrunning
condition|)
name|ARTcancel
argument_list|(
operator|&
name|Data
argument_list|,
name|Data
operator|.
name|MessageID
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Possible race condition, but documented in ctlinnd manpage. */
name|HISsetup
argument_list|()
expr_stmt|;
name|ARTcancel
argument_list|(
operator|&
name|Data
argument_list|,
name|Data
operator|.
name|MessageID
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|HISclose
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DO_LOG_CANCEL_COMMANDS
argument_list|)
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s cancelled %s"
argument_list|,
name|LogName
argument_list|,
name|Data
operator|.
name|MessageID
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_LOG_CANCEL_COMMANDS) */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Syntax-check the newsfeeds file. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|STRING
name|CCcheckfile
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|strings
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|errors
decl_stmt|;
name|STRING
name|error
decl_stmt|;
name|SITE
name|fake
decl_stmt|;
comment|/* Parse all site entries. */
name|strings
operator|=
name|SITEreadfile
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|fake
operator|.
name|Buffer
operator|.
name|Size
operator|=
literal|0
expr_stmt|;
name|fake
operator|.
name|Buffer
operator|.
name|Data
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|errors
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|strings
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|SITEparseone
argument_list|(
name|p
argument_list|,
operator|&
name|fake
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s bad_newsfeeds %s"
argument_list|,
name|MaxLength
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
name|SITEfree
argument_list|(
operator|&
name|fake
argument_list|)
expr_stmt|;
block|}
name|DISPOSE
argument_list|(
name|strings
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|CCreply
operator|.
name|Data
argument_list|,
literal|"1 Found %d errors -- see syslog"
argument_list|,
name|errors
argument_list|)
expr_stmt|;
return|return
name|CCreply
operator|.
name|Data
return|;
block|}
end_function

begin_comment
comment|/* **  Drop a site. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCdrop
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|SITE
modifier|*
name|sp
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
specifier|register
name|int
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|idx
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|SITEfind
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|CCnosite
return|;
name|SITEdrop
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Loop over all groups, and if the site is in a group, clobber it. */
for|for
control|(
name|idx
operator|=
name|sp
operator|-
name|Sites
operator|,
name|i
operator|=
name|nGroups
operator|,
name|ngp
operator|=
name|Groups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
control|)
for|for
control|(
name|j
operator|=
name|ngp
operator|->
name|nSites
operator|,
name|ip
operator|=
name|ngp
operator|->
name|Sites
init|;
operator|--
name|j
operator|>=
literal|0
condition|;
name|ip
operator|++
control|)
if|if
condition|(
operator|*
name|ip
operator|==
name|idx
condition|)
operator|*
name|ip
operator|=
name|NOSITE
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Flush all sites or one site. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCflush
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|ICDwrite
argument_list|()
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|Sites
operator|,
name|i
operator|=
name|nSites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
name|SITEflush
argument_list|(
name|sp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s flush_all"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sp
operator|=
name|SITEfind
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|CCnosite
return|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s flush"
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|SITEflush
argument_list|(
name|sp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Flush the log files. */
end_comment

begin_comment
comment|/* ARGSUSED0 */
end_comment

begin_function
name|STATIC
name|STRING
name|CCflushlogs
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
if|if
condition|(
name|Debug
condition|)
return|return
literal|"1 In debug mode"
return|;
name|ICDwrite
argument_list|()
expr_stmt|;
name|ReopenLog
argument_list|(
name|Log
argument_list|)
expr_stmt|;
name|ReopenLog
argument_list|(
name|Errlog
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Leave paused or throttled mode. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCgo
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|YES
index|[]
init|=
literal|"y"
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|Reservation
operator|&&
name|EQ
argument_list|(
name|p
argument_list|,
name|Reservation
argument_list|)
condition|)
block|{
name|DISPOSE
argument_list|(
name|Reservation
argument_list|)
expr_stmt|;
name|Reservation
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|RejectReason
operator|&&
name|EQ
argument_list|(
name|p
argument_list|,
name|RejectReason
argument_list|)
condition|)
block|{
name|DISPOSE
argument_list|(
name|RejectReason
argument_list|)
expr_stmt|;
name|RejectReason
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|Mode
operator|==
name|OMrunning
condition|)
return|return
literal|"1 Already running"
return|;
if|if
condition|(
operator|*
name|p
operator|&&
operator|!
name|EQ
argument_list|(
name|p
argument_list|,
name|ModeReason
argument_list|)
condition|)
return|return
literal|"1 Wrong reason"
return|;
name|DISPOSE
argument_list|(
name|ModeReason
argument_list|)
expr_stmt|;
name|ModeReason
operator|=
name|NULL
expr_stmt|;
name|Mode
operator|=
name|OMrunning
expr_stmt|;
if|if
condition|(
name|NNRPReason
operator|&&
name|NNRPFollows
condition|)
block|{
name|av
index|[
literal|0
index|]
operator|=
name|YES
expr_stmt|;
name|av
index|[
literal|1
index|]
operator|=
name|p
expr_stmt|;
operator|(
name|void
operator|)
name|CCreaders
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ErrorCount
operator|<
literal|0
condition|)
name|ErrorCount
operator|=
name|IO_ERROR_COUNT
expr_stmt|;
name|HISsetup
argument_list|()
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s running"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ICDneedsetup
condition|)
name|ICDsetup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|SCHANwakeup
argument_list|(
operator|(
name|POINTER
operator|)
operator|&
name|Mode
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Hangup a channel. */
end_comment

begin_function
name|STATIC
name|STRING
name|CChangup
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Parse the argument, a channel number. */
for|for
control|(
name|p
operator|=
name|av
index|[
literal|0
index|]
operator|,
name|fd
operator|=
literal|0
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
operator|*
name|p
argument_list|)
condition|)
return|return
literal|"1 Bad channel number"
return|;
name|fd
operator|=
name|fd
operator|*
literal|10
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
block|}
comment|/* Loop over all channels for the desired one. */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|cp
operator|=
name|CHANiter
argument_list|(
operator|&
name|i
argument_list|,
name|CTany
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|cp
operator|->
name|fd
operator|==
name|fd
condition|)
block|{
name|p
operator|=
name|CHANname
argument_list|(
name|cp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|Type
condition|)
block|{
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|CCreply
operator|.
name|Data
argument_list|,
literal|"1 Can't close %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|CCreply
operator|.
name|Data
return|;
case|case
name|CTexploder
case|:
case|case
name|CTprocess
case|:
case|case
name|CTfile
case|:
case|case
name|CTnntp
case|:
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s hangup"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|CHANclose
argument_list|(
name|cp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
literal|"1 Not active"
return|;
block|}
end_function

begin_comment
comment|/* **  Return our operating mode. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|STATIC
name|STRING
name|CCmode
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|h
decl_stmt|;
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|p
operator|=
name|buff
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"0 Server "
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Server's mode. */
switch|switch
condition|(
name|Mode
condition|)
block|{
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"Unknown %d"
argument_list|,
name|Mode
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMrunning
case|:
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"running"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMpaused
case|:
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"paused "
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
name|ModeReason
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMthrottled
case|:
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"throttled "
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
name|ModeReason
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|RejectReason
condition|)
block|{
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"Rejecting "
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
name|RejectReason
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"Allowing remote connections"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Server parameters. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|h
operator|=
literal|0
init|;
name|CHANiter
argument_list|(
operator|&
name|h
argument_list|,
name|CTnntp
argument_list|)
operator|!=
name|NULL
condition|;
control|)
name|i
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"Parameters c %ld i %d (%d) l %ld o %d t %ld %s %s"
argument_list|,
operator|(
name|long
operator|)
name|Cutoff
operator|/
operator|(
literal|24L
operator|*
literal|60L
operator|*
literal|60L
operator|)
argument_list|,
name|MaxIncoming
argument_list|,
name|i
argument_list|,
name|LargestArticle
argument_list|,
name|MaxOutgoing
argument_list|,
operator|(
name|long
operator|)
name|TimeOut
operator|.
name|tv_sec
argument_list|,
name|AmSlave
condition|?
literal|"slave"
else|:
literal|"normal"
argument_list|,
name|AnyIncoming
condition|?
literal|"any"
else|:
literal|"specified"
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Reservation. */
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|Reservation
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"Reserved %s"
argument_list|,
name|Reservation
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"Not reserved"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Newsreaders. */
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"Readers "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NNRPFollows
condition|)
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"follow "
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"separate "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NNRPReason
operator|==
name|NULL
condition|)
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"enabled"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"disabled %s"
argument_list|,
name|NNRPReason
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|CCreply
operator|.
name|Size
operator|<=
name|i
condition|)
block|{
name|CCreply
operator|.
name|Size
operator|=
name|i
expr_stmt|;
name|RENEW
argument_list|(
name|CCreply
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|CCreply
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|CCreply
operator|.
name|Data
argument_list|,
name|buff
argument_list|)
expr_stmt|;
return|return
name|CCreply
operator|.
name|Data
return|;
block|}
end_function

begin_comment
comment|/* **  Name the channels.  ("Name the bats -- simple names.") */
end_comment

begin_function
name|STATIC
name|STRING
name|CCname
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|NL
index|[]
init|=
literal|"\n"
decl_stmt|;
specifier|static
name|char
name|NIL
index|[]
init|=
literal|"\0"
decl_stmt|;
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|CHANfromdescriptor
argument_list|(
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|COPY
argument_list|(
name|CCnochannel
argument_list|)
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|CCreply
operator|.
name|Data
argument_list|,
literal|"0 %s"
argument_list|,
name|CHANname
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|CCreply
operator|.
name|Data
return|;
block|}
name|BUFFset
argument_list|(
operator|&
name|CCreply
argument_list|,
literal|"0 "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|cp
operator|=
name|CHANiter
argument_list|(
operator|&
name|i
argument_list|,
name|CTany
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|cp
operator|->
name|Type
operator|==
name|CTfree
condition|)
continue|continue;
if|if
condition|(
operator|++
name|count
operator|>
literal|1
condition|)
name|BUFFappend
argument_list|(
operator|&
name|CCreply
argument_list|,
name|NL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|CHANname
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|BUFFappend
argument_list|(
operator|&
name|CCreply
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BUFFappend
argument_list|(
operator|&
name|CCreply
argument_list|,
name|NIL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|CCreply
operator|.
name|Data
return|;
block|}
end_function

begin_comment
comment|/* **  Create a newsgroup. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCnewgroup
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|TIMES
index|[]
init|=
name|_PATH_ACTIVETIMES
decl_stmt|;
specifier|static
name|char
name|WHEN
index|[]
init|=
literal|"updating active.times"
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
name|char
modifier|*
name|Name
decl_stmt|;
name|char
modifier|*
name|Rest
decl_stmt|;
name|STRING
name|who
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
name|Name
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|Name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|strspn
argument_list|(
name|Name
argument_list|,
literal|"0123456789"
argument_list|)
operator|==
name|strlen
argument_list|(
name|Name
argument_list|)
condition|)
return|return
literal|"1 Illegal newsgroup name"
return|;
for|for
control|(
name|p
operator|=
name|Name
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|"1 Double or trailing period in newsgroup name"
return|;
block|}
elseif|else
if|if
condition|(
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|':'
operator|||
operator|*
name|p
operator|==
literal|'!'
condition|)
return|return
literal|"1 Illegal character in newsgroup name"
return|;
name|Rest
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|Rest
index|[
literal|0
index|]
operator|!=
name|NF_FLAG_ALIAS
condition|)
block|{
name|Rest
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|CTYPE
argument_list|(
name|isupper
argument_list|,
name|Rest
index|[
literal|0
index|]
argument_list|)
condition|)
name|Rest
index|[
literal|0
index|]
operator|=
name|tolower
argument_list|(
name|Rest
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ngp
operator|=
name|NGfind
argument_list|(
name|Name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|CCdochange
argument_list|(
name|ngp
argument_list|,
name|Rest
argument_list|)
return|;
comment|/* Update the log of groups created.  Don't use stdio because SunOS      * 4.1 has broken libc which can't handle fd's greater than 127. */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|TIMES
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
operator||
name|O_CREAT
argument_list|,
literal|0664
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant fopen %s %m"
argument_list|,
name|LogName
argument_list|,
name|TIMES
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|who
operator|=
name|av
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|who
operator|==
literal|'\0'
condition|)
name|who
operator|=
name|NEWSMASTER
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %ld %s\n"
argument_list|,
name|Name
argument_list|,
name|Now
operator|.
name|time
argument_list|,
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
name|xwrite
argument_list|(
name|fd
argument_list|,
name|buff
argument_list|,
name|strlen
argument_list|(
name|buff
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write %s %m"
argument_list|,
name|LogName
argument_list|,
name|TIMES
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant close %s %m"
argument_list|,
name|LogName
argument_list|,
name|TIMES
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AmRoot
condition|)
name|xchown
argument_list|(
name|TIMES
argument_list|)
expr_stmt|;
block|}
comment|/* Update the in-core data. */
if|if
condition|(
operator|!
name|ICDnewgroup
argument_list|(
name|Name
argument_list|,
name|Rest
argument_list|)
condition|)
return|return
literal|"1 Failed"
return|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s newgroup %s as %s"
argument_list|,
name|LogName
argument_list|,
name|Name
argument_list|,
name|Rest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|Rest
operator|!=
name|NF_FLAG_ALIAS
condition|)
block|{
comment|/* Create the spool directory. */
for|for
control|(
name|p
operator|=
name|Name
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
operator|!
name|MakeSpoolDirectory
argument_list|(
name|Name
argument_list|)
condition|)
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s cant mkdir %s %m"
argument_list|,
name|LogName
argument_list|,
name|Name
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Parse and set a boolean flag. */
end_comment

begin_function
name|STATIC
name|BOOL
name|CCparsebool
parameter_list|(
name|name
parameter_list|,
name|bp
parameter_list|,
name|value
parameter_list|)
name|char
name|name
decl_stmt|;
name|BOOL
modifier|*
name|bp
decl_stmt|;
name|char
name|value
decl_stmt|;
block|{
switch|switch
condition|(
name|value
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|'y'
case|:
operator|*
name|bp
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|bp
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s changed -%c %c"
argument_list|,
name|LogName
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  Change a running parameter. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCparam
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|BADVAL
index|[]
init|=
literal|"1 Bad value"
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|av
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|)
block|{
default|default:
return|return
literal|"1 Unknown parameter"
return|;
case|case
literal|'a'
case|:
if|if
condition|(
operator|!
name|CCparsebool
argument_list|(
literal|'a'
argument_list|,
operator|&
name|AnyIncoming
argument_list|,
operator|*
name|p
argument_list|)
condition|)
return|return
name|BADVAL
return|;
break|break;
case|case
literal|'c'
case|:
name|Cutoff
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s changed -c %d"
argument_list|,
name|LogName
argument_list|,
name|Cutoff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|MaxIncoming
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s changed -i %d"
argument_list|,
name|LogName
argument_list|,
name|MaxIncoming
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|LargestArticle
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s changed -l %ld"
argument_list|,
name|LogName
argument_list|,
name|LargestArticle
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
operator|!
name|CCparsebool
argument_list|(
literal|'n'
argument_list|,
operator|&
name|NNRPFollows
argument_list|,
operator|*
name|p
argument_list|)
condition|)
return|return
name|BADVAL
return|;
break|break;
case|case
literal|'o'
case|:
name|MaxOutgoing
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s changed -o %d"
argument_list|,
name|LogName
argument_list|,
name|MaxOutgoing
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|TimeOut
operator|.
name|tv_sec
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s changed -t %ld"
argument_list|,
name|LogName
argument_list|,
operator|(
name|long
operator|)
name|TimeOut
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Common code to implement a pause or throttle. */
end_comment

begin_function
name|STRING
name|CCblock
parameter_list|(
name|NewMode
parameter_list|,
name|reason
parameter_list|)
name|OPERATINGMODE
name|NewMode
decl_stmt|;
name|char
modifier|*
name|reason
decl_stmt|;
block|{
specifier|static
name|char
name|NO
index|[]
init|=
literal|"n"
decl_stmt|;
name|STRING
name|av
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|reason
operator|==
literal|'\0'
condition|)
return|return
name|CCnoreason
return|;
if|if
condition|(
name|Reservation
condition|)
block|{
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|reason
argument_list|,
name|Reservation
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|CCreply
operator|.
name|Data
argument_list|,
literal|"1 Reserved \"%s\""
argument_list|,
name|Reservation
argument_list|)
expr_stmt|;
return|return
name|CCreply
operator|.
name|Data
return|;
block|}
name|DISPOSE
argument_list|(
name|Reservation
argument_list|)
expr_stmt|;
name|Reservation
operator|=
name|NULL
expr_stmt|;
block|}
name|ICDwrite
argument_list|()
expr_stmt|;
name|HISclose
argument_list|()
expr_stmt|;
name|Mode
operator|=
name|NewMode
expr_stmt|;
if|if
condition|(
name|ModeReason
condition|)
name|DISPOSE
argument_list|(
name|ModeReason
argument_list|)
expr_stmt|;
name|ModeReason
operator|=
name|COPY
argument_list|(
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|NNRPReason
operator|==
name|NULL
operator|&&
name|NNRPFollows
condition|)
block|{
name|av
index|[
literal|0
index|]
operator|=
name|NO
expr_stmt|;
name|av
index|[
literal|1
index|]
operator|=
name|ModeReason
expr_stmt|;
operator|(
name|void
operator|)
name|CCreaders
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s %s %s"
argument_list|,
name|LogName
argument_list|,
name|NewMode
operator|==
name|OMpaused
condition|?
literal|"paused"
else|:
literal|"throttled"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Enter paused mode. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCpause
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
switch|switch
condition|(
name|Mode
condition|)
block|{
case|case
name|OMrunning
case|:
return|return
name|CCblock
argument_list|(
name|OMpaused
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
return|;
case|case
name|OMpaused
case|:
return|return
literal|"1 Already paused"
return|;
case|case
name|OMthrottled
case|:
return|return
literal|"1 Already throttled"
return|;
block|}
return|return
literal|"1 Unknown mode"
return|;
block|}
end_function

begin_comment
comment|/* **  Allow or disallow newsreaders. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCreaders
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|av
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|)
block|{
default|default:
return|return
literal|"1 Bad flag"
return|;
case|case
literal|'y'
case|:
if|if
condition|(
name|NNRPReason
operator|==
name|NULL
condition|)
return|return
literal|"1 Already allowing readers"
return|;
name|p
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&&
operator|!
name|EQ
argument_list|(
name|p
argument_list|,
name|NNRPReason
argument_list|)
condition|)
return|return
literal|"1 Wrong reason"
return|;
name|DISPOSE
argument_list|(
name|NNRPReason
argument_list|)
expr_stmt|;
name|NNRPReason
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|NNRPReason
condition|)
return|return
literal|"1 Already not allowing readers"
return|;
name|p
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|CCnoreason
return|;
name|NNRPReason
operator|=
name|COPY
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Re-exec ourselves. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCxexec
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|INND
index|[]
init|=
name|_PATH_INND
decl_stmt|;
specifier|static
name|char
name|INNDSTART
index|[]
init|=
name|_PATH_INNDSTART
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|CCargv
operator|==
name|NULL
condition|)
return|return
literal|"1 no argv!"
return|;
comment|/* Get the pathname. */
name|p
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|CCargv
index|[
literal|0
index|]
operator|=
name|AmRoot
condition|?
name|INND
else|:
name|INNDSTART
expr_stmt|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|p
argument_list|,
literal|"innd"
argument_list|)
condition|)
name|CCargv
index|[
literal|0
index|]
operator|=
name|INND
expr_stmt|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|p
argument_list|,
literal|"inndstart"
argument_list|)
condition|)
name|CCargv
index|[
literal|0
index|]
operator|=
name|INNDSTART
expr_stmt|;
else|else
return|return
literal|"1 Bad value"
return|;
name|JustCleanup
argument_list|()
expr_stmt|;
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s execv %s"
argument_list|,
name|LogName
argument_list|,
name|CCargv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execv
argument_list|(
name|CCargv
index|[
literal|0
index|]
argument_list|,
name|CCargv
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant execv %s %m"
argument_list|,
name|LogName
argument_list|,
name|CCargv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* **  Refile an article. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCrefile
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|head
decl_stmt|;
comment|/* xxx multiple groups? */
if|if
condition|(
name|NGfind
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|CCnogroup
return|;
name|head
operator|=
name|ARTreadheader
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
return|return
literal|"1 No such article"
return|;
return|return
literal|"1 Not yet implemented"
return|;
block|}
end_function

begin_comment
comment|/* **  Reject remote readers. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCreject
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
if|if
condition|(
name|RejectReason
condition|)
return|return
literal|"1 Already rejecting"
return|;
name|RejectReason
operator|=
name|COPY
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Re-read all in-core data. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCreload
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|BADSCHEMA
index|[]
init|=
literal|"1 Can't read schema"
decl_stmt|;
name|STRING
name|p
decl_stmt|;
name|p
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
name|EQ
argument_list|(
name|p
argument_list|,
literal|"all"
argument_list|)
condition|)
block|{
name|SITEflushall
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|HISclose
argument_list|()
expr_stmt|;
name|RCreadlist
argument_list|()
expr_stmt|;
name|HISsetup
argument_list|()
expr_stmt|;
name|ICDwrite
argument_list|()
expr_stmt|;
name|ICDsetup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ARTreadschema
argument_list|()
condition|)
return|return
name|BADSCHEMA
return|;
name|p
operator|=
literal|"all"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|p
argument_list|,
literal|"active"
argument_list|)
operator|||
name|EQ
argument_list|(
name|p
argument_list|,
literal|"newsfeeds"
argument_list|)
condition|)
block|{
name|SITEflushall
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|ICDwrite
argument_list|()
expr_stmt|;
name|ICDsetup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|p
argument_list|,
literal|"history"
argument_list|)
condition|)
block|{
name|HISclose
argument_list|()
expr_stmt|;
name|HISsetup
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|p
argument_list|,
literal|"hosts.nntp"
argument_list|)
condition|)
name|RCreadlist
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|p
argument_list|,
literal|"overview.fmt"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ARTreadschema
argument_list|()
condition|)
return|return
name|BADSCHEMA
return|;
block|}
else|else
return|return
literal|"1 Unknown reload type"
return|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s reload %s %s"
argument_list|,
name|LogName
argument_list|,
name|p
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Renumber the active file. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCrenumber
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
if|if
condition|(
name|Mode
operator|!=
name|OMrunning
condition|)
return|return
name|CCnotrunning
return|;
if|if
condition|(
name|ICDneedsetup
condition|)
return|return
literal|"1 Must first reload newsfeeds"
return|;
name|p
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|(
name|ngp
operator|=
name|NGfind
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|CCnogroup
return|;
if|if
condition|(
operator|!
name|NGrenumber
argument_list|(
name|ngp
argument_list|)
condition|)
return|return
literal|"1 Failed (see syslog)"
return|;
block|}
else|else
name|ICDrenumberactive
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Reserve a lock. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCreserve
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|Mode
operator|!=
name|OMrunning
condition|)
return|return
name|CCnotrunning
return|;
name|p
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
comment|/* Trying to make a reservation. */
if|if
condition|(
name|Reservation
condition|)
return|return
literal|"1 Already reserved"
return|;
name|Reservation
operator|=
name|COPY
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Trying to remove a reservation. */
if|if
condition|(
name|Reservation
operator|==
name|NULL
condition|)
return|return
literal|"1 Not reserved"
return|;
name|DISPOSE
argument_list|(
name|Reservation
argument_list|)
expr_stmt|;
name|Reservation
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Remove a newsgroup. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCrmgroup
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
if|if
condition|(
operator|(
name|ngp
operator|=
name|NGfind
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|CCnogroup
return|;
comment|/* Update the in-core data. */
if|if
condition|(
operator|!
name|ICDrmgroup
argument_list|(
name|ngp
argument_list|)
condition|)
return|return
literal|"1 Failed"
return|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s rmgroup %s"
argument_list|,
name|LogName
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Send a command line to an exploder. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCsend
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|SITE
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|SITEfind
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|CCnosite
return|;
if|if
condition|(
name|sp
operator|->
name|Type
operator|!=
name|FTexploder
condition|)
return|return
name|CCwrongtype
return|;
name|SITEwrite
argument_list|(
name|sp
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Shut down the system. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCshutdown
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s shutdown %s"
argument_list|,
name|LogName
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CleanupAndExit
argument_list|(
literal|0
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* **  Send a signal to a site's feed. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCsignal
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|oerrno
decl_stmt|;
comment|/* Parse the signal. */
name|p
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|caseEQ
argument_list|(
name|p
argument_list|,
literal|"HUP"
argument_list|)
condition|)
name|s
operator|=
name|SIGHUP
expr_stmt|;
elseif|else
if|if
condition|(
name|caseEQ
argument_list|(
name|p
argument_list|,
literal|"INT"
argument_list|)
condition|)
name|s
operator|=
name|SIGINT
expr_stmt|;
elseif|else
if|if
condition|(
name|caseEQ
argument_list|(
name|p
argument_list|,
literal|"TERM"
argument_list|)
condition|)
name|s
operator|=
name|SIGTERM
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
literal|"1 Invalid signal"
return|;
comment|/* Parse the site. */
name|p
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|SITEfind
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|CCnosite
return|;
if|if
condition|(
name|sp
operator|->
name|Type
operator|!=
name|FTchannel
operator|&&
name|sp
operator|->
name|Type
operator|!=
name|FTexploder
condition|)
return|return
name|CCwrongtype
return|;
if|if
condition|(
name|sp
operator|->
name|Spooling
operator|||
name|sp
operator|->
name|Process
operator|<
literal|0
condition|)
return|return
literal|"1 Site has no process"
return|;
comment|/* Do it. */
if|if
condition|(
name|kill
argument_list|(
name|sp
operator|->
name|pid
argument_list|,
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant kill %d %d site %s, %m"
argument_list|,
name|sp
operator|->
name|Process
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|CCreply
operator|.
name|Data
argument_list|,
literal|"1 Can't signal process %d, %s"
argument_list|,
name|sp
operator|->
name|Process
argument_list|,
name|strerror
argument_list|(
name|oerrno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|CCreply
operator|.
name|Data
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Enter throttled mode. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCthrottle
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|Mode
condition|)
block|{
case|case
name|OMpaused
case|:
if|if
condition|(
operator|*
name|p
operator|&&
operator|!
name|EQ
argument_list|(
name|p
argument_list|,
name|ModeReason
argument_list|)
condition|)
return|return
literal|"1 Already paused"
return|;
comment|/* FALLTHROUGH */
case|case
name|OMrunning
case|:
return|return
name|CCblock
argument_list|(
name|OMthrottled
argument_list|,
name|p
argument_list|)
return|;
case|case
name|OMthrottled
case|:
return|return
literal|"1 Already throttled"
return|;
block|}
return|return
literal|"1 unknown mode"
return|;
block|}
end_function

begin_comment
comment|/* **  Add or remove tracing. */
end_comment

begin_function
name|STATIC
name|STRING
name|CCtrace
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|BOOL
name|Flag
decl_stmt|;
name|STRING
name|word
decl_stmt|;
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
comment|/* Parse the flag. */
name|p
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
default|default:
return|return
literal|"1 Bad trace flag"
return|;
case|case
literal|'y'
case|:
case|case
literal|'Y'
case|:
name|Flag
operator|=
name|TRUE
expr_stmt|;
name|word
operator|=
literal|"on"
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
name|Flag
operator|=
name|FALSE
expr_stmt|;
name|word
operator|=
literal|"off"
expr_stmt|;
break|break;
block|}
comment|/* Parse what's being traced. */
name|p
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
default|default:
return|return
literal|"1 Bad trace item"
return|;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
name|Tracing
operator|=
name|Flag
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s trace innd %s"
argument_list|,
name|LogName
argument_list|,
name|word
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
name|NNRPTracing
operator|=
name|Flag
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s trace nnrpd %s"
argument_list|,
name|LogName
argument_list|,
name|word
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
operator|(
name|cp
operator|=
name|CHANfromdescriptor
argument_list|(
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|CCnochannel
return|;
name|CHANtracing
argument_list|(
name|cp
argument_list|,
name|Flag
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Split up the text into fields and stuff them in argv.  Return the **  number of elements or -1 on error. */
end_comment

begin_function
name|STATIC
name|int
name|CCargsplit
parameter_list|(
name|p
parameter_list|,
name|end
parameter_list|,
name|argv
parameter_list|,
name|size
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|save
decl_stmt|;
for|for
control|(
name|save
operator|=
name|argv
operator|,
operator|*
name|argv
operator|++
operator|=
name|p
operator|,
name|size
operator|--
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|SC_SEP
condition|)
block|{
if|if
condition|(
operator|--
name|size
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|argv
operator|++
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
operator|*
name|argv
operator|=
name|NULL
expr_stmt|;
return|return
name|argv
operator|-
name|save
return|;
block|}
end_function

begin_comment
comment|/* **  Read function.  Read and process the message. */
end_comment

begin_function
name|STATIC
name|FUNCTYPE
name|CCreader
parameter_list|(
name|cp
parameter_list|)
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
block|{
specifier|static
name|char
name|TOOLONG
index|[]
init|=
literal|"0 Reply too long for server to send"
decl_stmt|;
specifier|register
name|CCDISPATCH
modifier|*
name|dp
decl_stmt|;
specifier|register
name|STRING
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DO_HAVE_UNIX_DOMAIN
argument_list|)
name|struct
name|sockaddr_un
name|client
decl_stmt|;
else|#
directive|else
name|int
name|written
decl_stmt|;
endif|#
directive|endif
comment|/* defined(DO_HAVE_UNIX_DOMAIN) */
name|int
name|i
decl_stmt|;
name|char
name|buff
index|[
name|BUFSIZ
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|copy
index|[
name|BUFSIZ
operator|+
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|argv
index|[
name|SC_MAXFIELDS
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|cp
operator|!=
name|CCchan
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s internal CCreader wrong channel 0x%x not 0x%x"
argument_list|,
name|LogName
argument_list|,
name|cp
argument_list|,
name|CCchan
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get the message. */
name|i
operator|=
name|RECVorREAD
argument_list|(
name|CCchan
operator|->
name|fd
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
name|buff
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant recv CCreader %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant recv CCreader empty"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
return|return;
block|}
name|buff
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Copy to a printable buffer, and log. */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|copy
argument_list|,
name|buff
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|NULL
operator|,
name|q
operator|=
name|copy
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
name|SC_SEP
condition|)
block|{
operator|*
name|q
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
name|syslog
argument_list|(
name|L_CC_CMD
argument_list|,
literal|"%s"
argument_list|,
name|p
condition|?
name|p
else|:
name|copy
argument_list|)
expr_stmt|;
comment|/* Split up the fields, get the command letter. */
if|if
condition|(
operator|(
name|argc
operator|=
name|CCargsplit
argument_list|(
name|buff
argument_list|,
operator|&
name|buff
index|[
name|i
index|]
argument_list|,
name|argv
argument_list|,
name|SIZEOF
argument_list|(
name|argv
argument_list|)
argument_list|)
operator|)
operator|<
literal|2
operator|||
name|argc
operator|==
name|SIZEOF
argument_list|(
name|argv
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s bad_fields CCreader"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Dispatch to the command function. */
for|for
control|(
name|argc
operator|-=
literal|2
operator|,
name|dp
operator|=
name|CCcommands
init|;
name|dp
operator|<
name|ENDOF
argument_list|(
name|CCcommands
argument_list|)
condition|;
name|dp
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|dp
operator|->
name|Name
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
name|dp
operator|->
name|argc
condition|)
name|p
operator|=
literal|"1 Wrong number of parameters"
expr_stmt|;
else|else
name|p
operator|=
call|(
modifier|*
name|dp
operator|->
name|Function
call|)
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dp
operator|==
name|ENDOF
argument_list|(
name|CCcommands
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s bad_message %c"
argument_list|,
name|LogName
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
literal|"1 Bad command"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
literal|"0 Ok"
expr_stmt|;
comment|/* Build the reply address and send the reply. */
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DO_HAVE_UNIX_DOMAIN
argument_list|)
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|POINTER
operator|)
operator|&
name|client
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|client
argument_list|)
expr_stmt|;
name|client
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|client
operator|.
name|sun_path
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|CCwriter
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client
argument_list|,
name|AF_UNIX_SOCKSIZE
argument_list|(
name|client
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|errno
expr_stmt|;
name|syslog
argument_list|(
name|i
operator|==
name|ENOENT
condition|?
name|L_NOTICE
else|:
name|L_ERROR
argument_list|,
literal|"%s cant sendto CCreader bytes %d %m"
argument_list|,
name|LogName
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EMSGSIZE
condition|)
operator|(
name|void
operator|)
name|sendto
argument_list|(
name|CCwriter
argument_list|,
name|TOOLONG
argument_list|,
name|STRLEN
argument_list|(
name|TOOLONG
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client
argument_list|,
name|AF_UNIX_SOCKSIZE
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|O_WRONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant open %s %m"
argument_list|,
name|LogName
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|written
operator|=
name|write
argument_list|(
name|i
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
name|len
condition|)
if|if
condition|(
name|written
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write %s %m"
argument_list|,
name|LogName
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write %s"
argument_list|,
name|LogName
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant close %s %m"
argument_list|,
name|LogName
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(DO_HAVE_UNIX_DOMAIN) */
block|}
end_function

begin_comment
comment|/* **  Called when a write-in-progress is done on the channel.  Shouldn't happen. */
end_comment

begin_function
name|STATIC
name|FUNCTYPE
name|CCwritedone
parameter_list|()
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s internal CCwritedone"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Create the channel. */
end_comment

begin_function
name|void
name|CCsetup
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DO_HAVE_UNIX_DOMAIN
argument_list|)
name|struct
name|sockaddr_un
name|server
decl_stmt|;
endif|#
directive|endif
comment|/* defined(DO_HAVE_UNIX_DOMAIN) */
comment|/* Remove old detritus. */
if|if
condition|(
name|unlink
argument_list|(
name|CCpath
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant unlink %s %m"
argument_list|,
name|LogName
argument_list|,
name|CCpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DO_HAVE_UNIX_DOMAIN
argument_list|)
comment|/* Create a socket and name it. */
if|if
condition|(
operator|(
name|i
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant socket %s %m"
argument_list|,
name|LogName
argument_list|,
name|CCpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|POINTER
operator|)
operator|&
name|server
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|server
argument_list|)
expr_stmt|;
name|server
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|server
operator|.
name|sun_path
argument_list|,
name|CCpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|i
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server
argument_list|,
name|AF_UNIX_SOCKSIZE
argument_list|(
name|server
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant bind %s %m"
argument_list|,
name|LogName
argument_list|,
name|CCpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Create an unbound socket to reply on. */
if|if
condition|(
operator|(
name|CCwriter
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant socket unbound %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Create a named pipe and open it. */
if|if
condition|(
name|mkfifo
argument_list|(
name|CCpath
argument_list|,
literal|0666
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant mkfifo %s %m"
argument_list|,
name|LogName
argument_list|,
name|CCpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|CCpath
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant open %s %m"
argument_list|,
name|LogName
argument_list|,
name|CCpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(DO_HAVE_UNIX_DOMAIN) */
name|CCchan
operator|=
name|CHANcreate
argument_list|(
name|i
argument_list|,
name|CTcontrol
argument_list|,
name|CSwaiting
argument_list|,
name|CCreader
argument_list|,
name|CCwritedone
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s ccsetup %s"
argument_list|,
name|LogName
argument_list|,
name|CHANname
argument_list|(
name|CCchan
argument_list|)
argument_list|)
expr_stmt|;
name|RCHANadd
argument_list|(
name|CCchan
argument_list|)
expr_stmt|;
name|CCreply
operator|.
name|Size
operator|=
name|SMBUF
expr_stmt|;
name|CCreply
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|CCreply
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Cleanly shut down the channel. */
end_comment

begin_function
name|void
name|CCclose
parameter_list|()
block|{
name|CHANclose
argument_list|(
name|CCchan
argument_list|,
name|CHANname
argument_list|(
name|CCchan
argument_list|)
argument_list|)
expr_stmt|;
name|CCchan
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|CCpath
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant unlink %s %m"
argument_list|,
name|LogName
argument_list|,
name|CCpath
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DO_HAVE_UNIX_DOMAIN
argument_list|)
if|if
condition|(
name|close
argument_list|(
name|CCwriter
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant close unbound %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_HAVE_UNIX_DOMAIN) */
block|}
end_function

end_unit

