begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.11 $ ** **  Process control routines. */
end_comment

begin_include
include|#
directive|include
file|"innd.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
name|STATIC
name|PROCESS
modifier|*
name|PROCtable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|PROCtablesize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|PROCESS
name|PROCnull
init|=
block|{
name|PSfree
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Collect dead processes. */
end_comment

begin_function
name|STATIC
name|void
name|PROCreap
parameter_list|()
block|{
name|int
name|status
decl_stmt|;
specifier|register
name|PROCESS
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|pid
operator|=
name|waitnb
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ECHILD
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant wait %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|pp
operator|=
name|PROCtable
operator|,
name|i
operator|=
name|PROCtablesize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|Pid
operator|==
name|pid
condition|)
block|{
name|PROCneedscan
operator|=
name|TRUE
expr_stmt|;
name|pp
operator|->
name|Status
operator|=
name|status
expr_stmt|;
name|pp
operator|->
name|State
operator|=
name|PSdead
expr_stmt|;
name|pp
operator|->
name|Collected
operator|=
name|Now
operator|.
name|time
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  Signal handler that collects the processes, then resets the signal. */
end_comment

begin_function
name|STATIC
name|SIGHANDLER
name|PROCcatchsignal
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
name|PROCreap
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|s
argument_list|,
name|PROCcatchsignal
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Synchronous version that notifies a site when its process went away. */
end_comment

begin_function
name|void
name|PROCscan
parameter_list|()
block|{
specifier|register
name|PROCESS
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|PROCtable
operator|,
name|i
operator|=
name|PROCtablesize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|State
operator|==
name|PSdead
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|Site
operator|>
literal|0
condition|)
name|SITEprocdied
argument_list|(
operator|&
name|Sites
index|[
name|pp
operator|->
name|Site
index|]
argument_list|,
name|pp
operator|-
name|PROCtable
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|pp
operator|->
name|State
operator|=
name|PSfree
expr_stmt|;
block|}
name|PROCneedscan
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* **  Close down all processes. */
end_comment

begin_comment
unit|void PROCclose(Quickly)     BOOL		Quickly; {     register int	sig;     register PROCESS	*pp;     register int	i;
comment|/* What signal are we sending? */
end_comment

begin_comment
unit|sig = Quickly ? SIGKILL : SIGTERM;
comment|/* Send the signal to all living processes. */
end_comment

begin_comment
unit|for (pp = PROCtable, i = PROCtablesize; --i>= 0; pp++) { 	if (pp->State != PSrunning) 	    continue; 	if (kill(pp->Pid, sig)< 0&& errno != ESRCH) 	    syslog(L_ERROR, "%s cant kill %s %d %m", 		LogName, Quickly ? "KILL" : "TERM", pp->Pid);     }
comment|/* Collect any who might have died. */
end_comment

begin_endif
unit|PROCreap();     for (pp = PROCtable, i = PROCtablesize; --i>= 0; pp++) 	if (pp->State == PSdead) 	    *pp = PROCnull; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* **  Stop watching a process -- we don't care about it any more. */
end_comment

begin_function
name|void
name|PROCunwatch
parameter_list|(
name|process
parameter_list|)
name|int
name|process
decl_stmt|;
block|{
if|if
condition|(
name|process
operator|<
literal|0
operator|||
name|process
operator|>=
name|PROCtablesize
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s internal PROCunwatch %d"
argument_list|,
name|LogName
argument_list|,
name|process
argument_list|)
expr_stmt|;
return|return;
block|}
name|PROCtable
index|[
name|process
index|]
operator|.
name|Site
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Add a pid to the list of processes we watch. */
end_comment

begin_function
name|int
name|PROCwatch
parameter_list|(
name|pid
parameter_list|,
name|site
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|site
decl_stmt|;
block|{
specifier|register
name|PROCESS
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Find a free slot for this process. */
for|for
control|(
name|pp
operator|=
name|PROCtable
operator|,
name|i
operator|=
name|PROCtablesize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|State
operator|==
name|PSfree
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Ran out of room -- grow the table. */
name|RENEW
argument_list|(
name|PROCtable
argument_list|,
name|PROCESS
argument_list|,
name|PROCtablesize
operator|+
literal|20
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|&
name|PROCtable
index|[
name|PROCtablesize
index|]
expr_stmt|;
name|PROCtablesize
operator|+=
literal|20
expr_stmt|;
block|}
name|pp
operator|->
name|State
operator|=
name|PSrunning
expr_stmt|;
name|pp
operator|->
name|Pid
operator|=
name|pid
expr_stmt|;
name|pp
operator|->
name|Started
operator|=
name|Now
operator|.
name|time
expr_stmt|;
name|pp
operator|->
name|Site
operator|=
name|site
expr_stmt|;
return|return
name|pp
operator|-
name|PROCtable
return|;
block|}
end_function

begin_comment
comment|/* **  Setup. */
end_comment

begin_function
name|void
name|PROCsetup
parameter_list|(
name|i
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
block|{
specifier|register
name|PROCESS
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|PROCtable
condition|)
name|DISPOSE
argument_list|(
name|PROCtable
argument_list|)
expr_stmt|;
name|PROCtablesize
operator|=
name|i
expr_stmt|;
name|PROCtable
operator|=
name|NEW
argument_list|(
name|PROCESS
argument_list|,
name|PROCtablesize
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|PROCtable
operator|,
name|i
operator|=
name|PROCtablesize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|pp
operator|++
control|)
operator|*
name|pp
operator|=
name|PROCnull
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|PROCcatchsignal
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(SIGCHLD) */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|PROCcatchsignal
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

