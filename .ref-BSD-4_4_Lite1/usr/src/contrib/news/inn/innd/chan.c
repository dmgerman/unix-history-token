begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.30 $ ** **  I/O channel (and buffer) processing. */
end_comment

begin_include
include|#
directive|include
file|"innd.h"
end_include

begin_decl_stmt
name|STATIC
name|FDSET
name|RCHANmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|FDSET
name|SCHANmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|FDSET
name|WCHANmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|SCHANcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|CHANlastfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|CHANlastsleepfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|CHANccfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|CHANtablesize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|CHANNEL
modifier|*
name|CHANtable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|CHANNEL
modifier|*
name|CHANcc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|CHANNEL
name|CHANnull
init|=
block|{
name|CTfree
block|,
name|CSerror
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Set a buffer's contents, ignoring anything that might have **  been there. */
end_comment

begin_function
name|void
name|BUFFset
parameter_list|(
name|bp
parameter_list|,
name|p
parameter_list|,
name|length
parameter_list|)
specifier|register
name|BUFFER
modifier|*
name|bp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|dest
decl_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|Left
operator|=
name|length
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Need more space? */
if|if
condition|(
name|bp
operator|->
name|Size
operator|<
name|length
condition|)
block|{
name|bp
operator|->
name|Size
operator|=
name|GROW_AMOUNT
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|RENEW
argument_list|(
name|bp
operator|->
name|Data
argument_list|,
name|char
argument_list|,
name|bp
operator|->
name|Size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
name|MEMCPY_THRESHOLD
condition|)
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|POINTER
operator|)
name|bp
operator|->
name|Data
argument_list|,
operator|(
name|POINTER
operator|)
name|p
argument_list|,
operator|(
name|SIZE_T
operator|)
name|length
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|dest
operator|=
name|bp
operator|->
name|Data
operator|,
name|length
operator|++
init|;
operator|--
name|length
operator|>
literal|0
condition|;
control|)
operator|*
name|dest
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
name|bp
operator|->
name|Used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Initialize all the I/O channels. */
end_comment

begin_function
name|void
name|CHANsetup
parameter_list|(
name|i
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
block|{
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|RCHANmask
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|SCHANmask
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|WCHANmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHANtable
condition|)
name|DISPOSE
argument_list|(
name|CHANtable
argument_list|)
expr_stmt|;
name|CHANtablesize
operator|=
name|i
expr_stmt|;
name|CHANtable
operator|=
name|NEW
argument_list|(
name|CHANNEL
argument_list|,
name|CHANtablesize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|POINTER
operator|)
name|CHANtable
argument_list|,
literal|0
argument_list|,
call|(
name|SIZE_T
call|)
argument_list|(
name|CHANtablesize
operator|*
sizeof|sizeof
expr|*
name|CHANtable
argument_list|)
argument_list|)
expr_stmt|;
name|CHANnull
operator|.
name|NextLog
operator|=
name|CHANNEL_INACTIVE_TIME
expr_stmt|;
name|CHANnull
operator|.
name|Address
operator|.
name|s_addr
operator|=
name|MyAddress
operator|.
name|s_addr
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|CHANtable
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|cp
operator|++
control|)
operator|*
name|cp
operator|=
name|CHANnull
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Create a channel from a descriptor. */
end_comment

begin_function
name|CHANNEL
modifier|*
name|CHANcreate
parameter_list|(
name|fd
parameter_list|,
name|Type
parameter_list|,
name|State
parameter_list|,
name|Reader
parameter_list|,
name|WriteDone
parameter_list|)
name|int
name|fd
decl_stmt|;
name|CHANNELTYPE
name|Type
decl_stmt|;
name|CHANNELSTATE
name|State
decl_stmt|;
name|FUNCPTR
name|Reader
decl_stmt|;
name|FUNCPTR
name|WriteDone
decl_stmt|;
block|{
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
name|BUFFER
name|in
decl_stmt|;
name|BUFFER
name|out
decl_stmt|;
name|cp
operator|=
operator|&
name|CHANtable
index|[
name|fd
index|]
expr_stmt|;
comment|/* Don't overwrite the buffers with CHANnull. */
name|in
operator|=
name|cp
operator|->
name|In
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|Size
operator|==
literal|0
condition|)
block|{
name|in
operator|.
name|Size
operator|=
name|START_BUFF_SIZE
expr_stmt|;
name|in
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|in
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
name|in
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
name|in
operator|.
name|Left
operator|=
name|in
operator|.
name|Size
expr_stmt|;
name|out
operator|=
name|cp
operator|->
name|Out
expr_stmt|;
if|if
condition|(
name|out
operator|.
name|Size
operator|==
literal|0
condition|)
block|{
name|out
operator|.
name|Size
operator|=
name|SMBUF
expr_stmt|;
name|out
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|out
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
name|out
operator|.
name|Left
operator|=
literal|0
expr_stmt|;
comment|/* Set up the channel's info. */
operator|*
name|cp
operator|=
name|CHANnull
expr_stmt|;
name|cp
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|cp
operator|->
name|Type
operator|=
name|Type
expr_stmt|;
name|cp
operator|->
name|State
operator|=
name|State
expr_stmt|;
name|cp
operator|->
name|Reader
operator|=
name|Reader
expr_stmt|;
name|cp
operator|->
name|WriteDone
operator|=
name|WriteDone
expr_stmt|;
name|cp
operator|->
name|Started
operator|=
name|cp
operator|->
name|LastActive
operator|=
name|Now
operator|.
name|time
expr_stmt|;
name|cp
operator|->
name|In
operator|=
name|in
expr_stmt|;
name|cp
operator|->
name|Out
operator|=
name|out
expr_stmt|;
name|cp
operator|->
name|Tracing
operator|=
name|Tracing
expr_stmt|;
comment|/* Make the descriptor close-on-exec and non-blocking. */
name|CloseOnExec
argument_list|(
name|fd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ENOTSOCK
argument_list|)
if|if
condition|(
name|SetNonBlocking
argument_list|(
name|fd
argument_list|,
name|TRUE
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOTSOCK
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant nonblock %d %m"
argument_list|,
name|LogName
argument_list|,
name|fd
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|SetNonBlocking
argument_list|(
name|fd
argument_list|,
name|TRUE
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant nonblock %d %m"
argument_list|,
name|LogName
argument_list|,
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(ENOTSOCK) */
comment|/* Note control channel, for efficiency. */
if|if
condition|(
name|Type
operator|==
name|CTcontrol
condition|)
block|{
name|CHANcc
operator|=
name|cp
expr_stmt|;
name|CHANccfd
operator|=
name|fd
expr_stmt|;
block|}
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/* **  Start tracing a channel. */
end_comment

begin_function
name|void
name|CHANtracing
parameter_list|(
name|cp
parameter_list|,
name|Flag
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
name|BOOL
name|Flag
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|CHANname
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s trace %s"
argument_list|,
name|p
argument_list|,
name|Flag
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|cp
operator|->
name|Tracing
operator|=
name|Flag
expr_stmt|;
if|if
condition|(
name|Flag
condition|)
block|{
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s trace badwrites %d blockwrites %d badreads %d"
argument_list|,
name|p
argument_list|,
name|cp
operator|->
name|BadWrites
argument_list|,
name|cp
operator|->
name|BadReads
argument_list|,
name|cp
operator|->
name|BlockedWrites
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s trace address %s lastactive %ld nextlod %ld"
argument_list|,
name|p
argument_list|,
name|inet_ntoa
argument_list|(
name|cp
operator|->
name|Address
argument_list|)
argument_list|,
name|cp
operator|->
name|LastActive
argument_list|,
name|cp
operator|->
name|NextLog
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|SCHANmask
argument_list|)
condition|)
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s trace sleeping %ld 0x%x"
argument_list|,
name|p
argument_list|,
operator|(
name|long
operator|)
name|cp
operator|->
name|Waketime
argument_list|,
name|cp
operator|->
name|Waker
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|RCHANmask
argument_list|)
condition|)
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s trace reading %d %s"
argument_list|,
name|p
argument_list|,
name|cp
operator|->
name|In
operator|.
name|Used
argument_list|,
name|MaxLength
argument_list|(
name|cp
operator|->
name|In
operator|.
name|Data
argument_list|,
name|cp
operator|->
name|In
operator|.
name|Data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|WCHANmask
argument_list|)
condition|)
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s trace writing %d %s"
argument_list|,
name|p
argument_list|,
name|cp
operator|->
name|Out
operator|.
name|Left
argument_list|,
name|MaxLength
argument_list|(
name|cp
operator|->
name|Out
operator|.
name|Data
argument_list|,
name|cp
operator|->
name|Out
operator|.
name|Data
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Close a channel. */
end_comment

begin_function
name|void
name|CHANclose
parameter_list|(
name|cp
parameter_list|,
name|name
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|cp
operator|->
name|Type
operator|==
name|CTfree
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s internal closing free channel"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cp
operator|->
name|Type
operator|==
name|CTnntp
condition|)
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s closed seconds %ld accepted %ld refused %ld rejected %ld"
argument_list|,
name|name
argument_list|,
call|(
name|long
call|)
argument_list|(
name|Now
operator|.
name|time
operator|-
name|cp
operator|->
name|Started
argument_list|)
argument_list|,
name|cp
operator|->
name|Received
argument_list|,
name|cp
operator|->
name|Refused
argument_list|,
name|cp
operator|->
name|Rejected
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s closed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|WCHANremove
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|RCHANremove
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|SCHANremove
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|Argument
operator|!=
name|NULL
condition|)
comment|/* Set to NULL below. */
name|DISPOSE
argument_list|(
name|cp
operator|->
name|Argument
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|fd
operator|>=
literal|0
operator|&&
name|close
argument_list|(
name|cp
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant close %s %m"
argument_list|,
name|LogName
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Mark it unused. */
name|cp
operator|->
name|Type
operator|=
name|CTfree
expr_stmt|;
name|cp
operator|->
name|State
operator|=
name|CSerror
expr_stmt|;
name|cp
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|cp
operator|->
name|Argument
operator|=
name|NULL
expr_stmt|;
comment|/* Free the buffers if they got big. */
if|if
condition|(
name|cp
operator|->
name|In
operator|.
name|Size
operator|>
name|BIG_BUFFER
condition|)
block|{
name|cp
operator|->
name|In
operator|.
name|Size
operator|=
literal|0
expr_stmt|;
name|DISPOSE
argument_list|(
name|cp
operator|->
name|In
operator|.
name|Data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|Out
operator|.
name|Size
operator|>
name|BIG_BUFFER
condition|)
block|{
name|cp
operator|->
name|Out
operator|.
name|Size
operator|=
literal|0
expr_stmt|;
name|DISPOSE
argument_list|(
name|cp
operator|->
name|Out
operator|.
name|Data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Return a printable name for the channel. */
end_comment

begin_function
name|char
modifier|*
name|CHANname
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
name|STRING
name|p
decl_stmt|;
name|PID_T
name|pid
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|Type
condition|)
block|{
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"?%d(#%d@%d)?"
argument_list|,
name|cp
operator|->
name|Type
argument_list|,
name|cp
operator|->
name|fd
argument_list|,
name|cp
operator|-
name|CHANtable
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTany
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"any:%d"
argument_list|,
name|cp
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTfree
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"free:%d"
argument_list|,
name|cp
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTremconn
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"remconn:%d"
argument_list|,
name|cp
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTnntp
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s:%d"
argument_list|,
name|cp
operator|->
name|Address
operator|.
name|s_addr
operator|==
literal|0
condition|?
literal|"localhost"
else|:
name|RChostname
argument_list|(
name|cp
argument_list|)
argument_list|,
name|cp
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTlocalconn
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"localconn:%d"
argument_list|,
name|cp
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTcontrol
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"control:%d"
argument_list|,
name|cp
operator|->
name|fd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTexploder
case|:
case|case
name|CTfile
case|:
case|case
name|CTprocess
case|:
comment|/* Find the site that has this channel. */
for|for
control|(
name|p
operator|=
literal|"?"
operator|,
name|i
operator|=
name|nSites
operator|,
name|sp
operator|=
name|Sites
operator|,
name|pid
operator|=
literal|0
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|Channel
operator|==
name|cp
condition|)
block|{
name|p
operator|=
name|sp
operator|->
name|Name
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|Type
operator|!=
name|CTfile
condition|)
name|pid
operator|=
name|sp
operator|->
name|pid
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s:%d:%s"
argument_list|,
name|MaxLength
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
argument_list|,
name|cp
operator|->
name|fd
argument_list|,
name|cp
operator|->
name|Type
operator|==
name|CTfile
condition|?
literal|"file"
else|:
literal|"proc"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s:%d:%s:%ld"
argument_list|,
name|MaxLength
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
argument_list|,
name|cp
operator|->
name|fd
argument_list|,
name|cp
operator|->
name|Type
operator|==
name|CTfile
condition|?
literal|"file"
else|:
literal|"proc"
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|buff
return|;
block|}
end_function

begin_comment
comment|/* **  Return the channel for a specified descriptor. */
end_comment

begin_function
name|CHANNEL
modifier|*
name|CHANfromdescriptor
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|fd
operator|>
name|CHANtablesize
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|CHANtable
index|[
name|fd
index|]
return|;
block|}
end_function

begin_comment
comment|/* **  Iterate over all channels of a specified type. */
end_comment

begin_function
name|CHANNEL
modifier|*
name|CHANiter
parameter_list|(
name|ip
parameter_list|,
name|Type
parameter_list|)
name|int
modifier|*
name|ip
decl_stmt|;
name|CHANNELTYPE
name|Type
decl_stmt|;
block|{
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
operator|*
name|ip
operator|)
operator|>=
literal|0
operator|&&
name|i
operator|<
name|CHANtablesize
condition|)
block|{
do|do
block|{
name|cp
operator|=
operator|&
name|CHANtable
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|Type
operator|==
name|CTany
operator|||
name|cp
operator|->
name|Type
operator|==
name|Type
condition|)
block|{
operator|*
name|ip
operator|=
operator|++
name|i
expr_stmt|;
return|return
name|cp
return|;
block|}
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|CHANtablesize
condition|)
do|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Mark a channel as an active reader. */
end_comment

begin_function
name|void
name|RCHANadd
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
block|{
name|FD_SET
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|RCHANmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|fd
operator|>
name|CHANlastfd
condition|)
name|CHANlastfd
operator|=
name|cp
operator|->
name|fd
expr_stmt|;
comment|/* Start reading at the beginning of the buffer. */
name|cp
operator|->
name|In
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Remove a channel from the set of readers. */
end_comment

begin_function
name|void
name|RCHANremove
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|RCHANmask
argument_list|)
condition|)
block|{
name|FD_CLR
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|RCHANmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|fd
operator|==
name|CHANlastfd
condition|)
block|{
comment|/* This was the highest descriptor, get a new highest. */
while|while
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|CHANlastfd
argument_list|,
operator|&
name|RCHANmask
argument_list|)
operator|&&
operator|!
name|FD_ISSET
argument_list|(
name|CHANlastfd
argument_list|,
operator|&
name|WCHANmask
argument_list|)
operator|&&
name|CHANlastfd
operator|>
literal|1
condition|)
name|CHANlastfd
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  Put a channel to sleep, call a function when it wakes. **  Note that the Argument must be NULL or allocated memory! */
end_comment

begin_function
name|void
name|SCHANadd
parameter_list|(
name|cp
parameter_list|,
name|Waketime
parameter_list|,
name|Event
parameter_list|,
name|Waker
parameter_list|,
name|Argument
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
name|time_t
name|Waketime
decl_stmt|;
name|POINTER
name|Event
decl_stmt|;
name|FUNCPTR
name|Waker
decl_stmt|;
name|POINTER
name|Argument
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|SCHANmask
argument_list|)
condition|)
block|{
name|SCHANcount
operator|++
expr_stmt|;
name|FD_SET
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|SCHANmask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|fd
operator|>
name|CHANlastsleepfd
condition|)
name|CHANlastsleepfd
operator|=
name|cp
operator|->
name|fd
expr_stmt|;
name|cp
operator|->
name|Waketime
operator|=
name|Waketime
expr_stmt|;
name|cp
operator|->
name|Waker
operator|=
name|Waker
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|Argument
operator|!=
name|Argument
condition|)
block|{
name|DISPOSE
argument_list|(
name|cp
operator|->
name|Argument
argument_list|)
expr_stmt|;
name|cp
operator|->
name|Argument
operator|=
name|Argument
expr_stmt|;
block|}
name|cp
operator|->
name|Event
operator|=
name|Event
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Take a channel off the sleep list. */
end_comment

begin_function
name|void
name|SCHANremove
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|SCHANmask
argument_list|)
condition|)
block|{
name|FD_CLR
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|SCHANmask
argument_list|)
expr_stmt|;
name|SCHANcount
operator|--
expr_stmt|;
name|cp
operator|->
name|Waketime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|fd
operator|==
name|CHANlastsleepfd
condition|)
block|{
comment|/* This was the highest descriptor, get a new highest. */
while|while
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|CHANlastsleepfd
argument_list|,
operator|&
name|WCHANmask
argument_list|)
operator|&&
name|CHANlastsleepfd
operator|>
literal|1
condition|)
name|CHANlastsleepfd
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  Is a channel on the sleep list? */
end_comment

begin_function
name|BOOL
name|CHANsleeping
parameter_list|(
name|cp
parameter_list|)
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
block|{
return|return
name|FD_ISSET
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|SCHANmask
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Wake up channels waiting for a specific event. */
end_comment

begin_function
name|void
name|SCHANwakeup
parameter_list|(
name|Event
parameter_list|)
specifier|register
name|POINTER
name|Event
decl_stmt|;
block|{
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|CHANtable
operator|,
name|i
operator|=
name|CHANtablesize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|cp
operator|->
name|Type
operator|!=
name|CTfree
operator|&&
name|cp
operator|->
name|Event
operator|==
name|Event
operator|&&
name|CHANsleeping
argument_list|(
name|cp
argument_list|)
condition|)
name|cp
operator|->
name|Waketime
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Mark a channel as an active writer.  Don't reset the Out->Left field **  since we could have buffered I/O already in there. */
end_comment

begin_function
name|void
name|WCHANadd
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|cp
operator|->
name|Out
operator|.
name|Left
operator|>
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|WCHANmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|fd
operator|>
name|CHANlastfd
condition|)
name|CHANlastfd
operator|=
name|cp
operator|->
name|fd
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Remove a channel from the set of writers. */
end_comment

begin_function
name|void
name|WCHANremove
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|WCHANmask
argument_list|)
condition|)
block|{
name|FD_CLR
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|WCHANmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|Out
operator|.
name|Left
operator|<=
literal|0
condition|)
block|{
comment|/* No data left -- reset used so we don't grow the buffer. */
name|cp
operator|->
name|Out
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|Out
operator|.
name|Left
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|fd
operator|==
name|CHANlastfd
condition|)
block|{
comment|/* This was the highest descriptor, get a new highest. */
while|while
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|CHANlastfd
argument_list|,
operator|&
name|RCHANmask
argument_list|)
operator|&&
operator|!
name|FD_ISSET
argument_list|(
name|CHANlastfd
argument_list|,
operator|&
name|WCHANmask
argument_list|)
operator|&&
name|CHANlastfd
operator|>
literal|1
condition|)
name|CHANlastfd
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  Set a channel to start off with the contents of an existing channel. */
end_comment

begin_function
name|void
name|WCHANsetfrombuffer
parameter_list|(
name|cp
parameter_list|,
name|bp
parameter_list|)
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
name|BUFFER
modifier|*
name|bp
decl_stmt|;
block|{
name|WCHANset
argument_list|(
name|cp
argument_list|,
operator|&
name|bp
operator|->
name|Data
index|[
name|bp
operator|->
name|Used
index|]
argument_list|,
name|bp
operator|->
name|Left
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Read in text data, return the amount we read. */
end_comment

begin_function
name|int
name|CHANreadtext
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|BUFFER
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|CHANname
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* Read in whatever is there. */
name|bp
operator|=
operator|&
name|cp
operator|->
name|In
expr_stmt|;
name|bp
operator|->
name|Left
operator|=
name|bp
operator|->
name|Size
operator|-
name|bp
operator|->
name|Used
expr_stmt|;
name|i
operator|=
name|read
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|&
name|bp
operator|->
name|Data
index|[
name|bp
operator|->
name|Used
index|]
argument_list|,
name|bp
operator|->
name|Left
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant read %m"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s readclose"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|CHANclose
argument_list|(
name|cp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Update values, grow buffer if we're getting close. */
name|bp
operator|->
name|Used
operator|+=
name|i
expr_stmt|;
name|bp
operator|->
name|Left
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|Left
operator|<=
name|LOW_WATER
condition|)
block|{
name|i
operator|=
name|GROW_AMOUNT
argument_list|(
name|bp
operator|->
name|Size
argument_list|)
expr_stmt|;
name|bp
operator|->
name|Size
operator|+=
name|i
expr_stmt|;
name|bp
operator|->
name|Left
operator|+=
name|i
expr_stmt|;
name|RENEW
argument_list|(
name|bp
operator|->
name|Data
argument_list|,
name|char
argument_list|,
name|bp
operator|->
name|Size
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* **  If I/O backs up a lot, we can get EMSGSIZE on some systems.  If that **  happens we want to do the I/O in chunks.  We assume stdio's BUFSIZ is **  a good chunk value. */
end_comment

begin_function
name|STATIC
name|int
name|largewrite
parameter_list|(
name|fd
parameter_list|,
name|p
parameter_list|,
name|length
parameter_list|)
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|save
decl_stmt|;
do|do
block|{
comment|/* Try the standard case -- write it all. */
name|i
operator|=
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|POINTER
operator|)
name|p
argument_list|,
operator|(
name|SIZE_T
operator|)
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|||
operator|(
name|i
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EMSGSIZE
operator|&&
name|errno
operator|!=
name|EINTR
operator|)
condition|)
return|return
name|i
return|;
block|}
do|while
condition|(
name|i
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
comment|/* Write it in pieces. */
for|for
control|(
name|save
operator|=
name|p
operator|,
name|i
operator|=
literal|0
init|;
name|length
condition|;
name|p
operator|+=
name|i
operator|,
name|length
operator|-=
name|i
control|)
block|{
name|i
operator|=
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|POINTER
operator|)
name|p
argument_list|,
call|(
name|SIZE_T
call|)
argument_list|(
name|length
operator|>
name|BUFSIZ
condition|?
name|BUFSIZ
else|:
name|length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
block|}
comment|/* Return error, or partial results if we got something. */
return|return
name|p
operator|==
name|save
condition|?
name|i
else|:
name|p
operator|-
name|save
return|;
block|}
end_function

begin_comment
comment|/* **  Try to flush out the buffer.  Use this only on file channels! */
end_comment

begin_function
name|BOOL
name|WCHANflush
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|BUFFER
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If nothing in there, or nothing left, nothing to do. */
name|bp
operator|=
operator|&
name|cp
operator|->
name|Out
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|Left
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Write it. */
while|while
condition|(
name|bp
operator|->
name|Left
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|write
argument_list|(
name|cp
operator|->
name|fd
argument_list|,
operator|(
name|POINTER
operator|)
operator|&
name|bp
operator|->
name|Data
index|[
name|bp
operator|->
name|Used
index|]
argument_list|,
operator|(
name|SIZE_T
operator|)
name|bp
operator|->
name|Left
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant flush count %d %m"
argument_list|,
name|CHANname
argument_list|(
name|cp
argument_list|)
argument_list|,
name|bp
operator|->
name|Left
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant flush count %d"
argument_list|,
name|CHANname
argument_list|(
name|cp
argument_list|)
argument_list|,
name|bp
operator|->
name|Left
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bp
operator|->
name|Left
operator|-=
name|i
expr_stmt|;
name|bp
operator|->
name|Used
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|Left
operator|<=
literal|0
condition|)
name|WCHANremove
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Wakeup routine called after a write channel was put to sleep. */
end_comment

begin_function
name|STATIC
name|FUNCTYPE
name|CHANwakeup
parameter_list|(
name|cp
parameter_list|)
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
block|{
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s wakeup"
argument_list|,
name|CHANname
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|WCHANadd
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Attempting to write would block; stop output or give up. */
end_comment

begin_function
name|STATIC
name|void
name|CHANwritesleep
parameter_list|(
name|cp
parameter_list|,
name|p
parameter_list|)
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
operator|++
operator|(
name|cp
operator|->
name|BlockedWrites
operator|)
operator|)
operator|>
name|BAD_IO_COUNT
condition|)
switch|switch
condition|(
name|cp
operator|->
name|Type
condition|)
block|{
default|default:
break|break;
case|case
name|CTnntp
case|:
case|case
name|CTfile
case|:
case|case
name|CTexploder
case|:
case|case
name|CTprocess
case|:
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s blocked closing"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|SITEchanclose
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|CHANclose
argument_list|(
name|cp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|*=
name|BLOCK_BACKOFF
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s blocked sleeping %d"
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SCHANadd
argument_list|(
name|cp
argument_list|,
call|(
name|time_t
call|)
argument_list|(
name|Now
operator|.
name|time
operator|+
name|i
argument_list|)
argument_list|,
operator|(
name|POINTER
operator|)
name|NULL
argument_list|,
name|CHANwakeup
argument_list|,
operator|(
name|POINTER
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INND_FIND_BAD_FDS
argument_list|)
end_if

begin_comment
comment|/* **  We got an unknown error in select.  Find out the culprit. **  Not really ready for production use yet, and it's expensive, too. */
end_comment

begin_function
name|STATIC
name|void
name|CHANdiagnose
parameter_list|()
block|{
name|FDSET
name|Test
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|Test
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CHANlastfd
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|RCHANmask
argument_list|)
condition|)
block|{
name|FD_SET
argument_list|(
name|i
argument_list|,
operator|&
name|Test
argument_list|)
expr_stmt|;
name|t
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|i
operator|+
literal|1
argument_list|,
operator|&
name|Test
argument_list|,
operator|(
name|FDSET
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|FDSET
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|t
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s Bad Read File %d"
argument_list|,
name|LogName
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|RCHANmask
argument_list|)
expr_stmt|;
comment|/* Probably do something about the file descriptor here; call 		 * CHANclose on it? */
block|}
name|FD_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|Test
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|WCHANmask
argument_list|)
condition|)
block|{
name|FD_SET
argument_list|(
name|i
argument_list|,
operator|&
name|Test
argument_list|)
expr_stmt|;
name|t
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|i
operator|+
literal|1
argument_list|,
operator|(
name|FDSET
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|Test
argument_list|,
operator|(
name|FDSET
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|t
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s Bad Write File %d"
argument_list|,
name|LogName
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|WCHANmask
argument_list|)
expr_stmt|;
comment|/* Probably do something about the file descriptor here; call 		 * CHANclose on it? */
block|}
name|FD_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|Test
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(INND_FIND_BAD_FDS) */
end_comment

begin_comment
comment|/* **  Main I/O loop.  Wait for data, call the channel's handler when there is **  something to read or when the queued write is finished.  In order to **  be fair (i.e., don't always give descriptor n priority over n+1), we **  remember where we last had something and pick up from there. */
end_comment

begin_function
name|void
name|CHANreadloop
parameter_list|()
block|{
specifier|static
name|char
name|EXITING
index|[]
init|=
literal|"INND exiting because of signal\n"
decl_stmt|;
specifier|static
name|int
name|fd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|startpoint
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|lastfd
decl_stmt|;
name|int
name|oerrno
decl_stmt|;
specifier|register
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
specifier|register
name|BUFFER
modifier|*
name|bp
decl_stmt|;
name|FDSET
name|MyRead
decl_stmt|;
name|FDSET
name|MyWrite
decl_stmt|;
name|struct
name|timeval
name|MyTime
decl_stmt|;
name|long
name|silence
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* See if any processes died. */
name|PROCscan
argument_list|()
expr_stmt|;
comment|/* Wait for data, note the time. */
name|MyRead
operator|=
name|RCHANmask
expr_stmt|;
name|MyWrite
operator|=
name|WCHANmask
expr_stmt|;
name|MyTime
operator|=
name|TimeOut
expr_stmt|;
name|count
operator|=
name|select
argument_list|(
name|CHANlastfd
operator|+
literal|1
argument_list|,
operator|&
name|MyRead
argument_list|,
operator|&
name|MyWrite
argument_list|,
operator|(
name|FDSET
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|MyTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|GotTerminate
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
literal|2
argument_list|,
name|EXITING
argument_list|,
name|STRLEN
argument_list|(
name|EXITING
argument_list|)
argument_list|)
expr_stmt|;
name|CleanupAndExit
argument_list|(
literal|0
argument_list|,
literal|"received signal"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant select %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INND_FIND_BAD_FDS
argument_list|)
name|CHANdiagnose
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* defined(INND_FIND_BAD_FDS) */
block|}
continue|continue;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* No channels active, so flush and skip if nobody's 	     * sleeping. */
if|if
condition|(
name|Mode
operator|==
name|OMrunning
condition|)
name|ICDwrite
argument_list|()
expr_stmt|;
if|if
condition|(
name|SCHANcount
operator|==
literal|0
condition|)
continue|continue;
block|}
comment|/* Update the "reasonably accurate" time. */
if|if
condition|(
name|GetTimeInfo
argument_list|(
operator|&
name|Now
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant gettimeinfo %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
comment|/* Try the control channel first. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|CHANccfd
argument_list|,
operator|&
name|RCHANmask
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|CHANccfd
argument_list|,
operator|&
name|MyRead
argument_list|)
condition|)
block|{
name|count
operator|--
expr_stmt|;
call|(
modifier|*
name|CHANcc
operator|->
name|Reader
call|)
argument_list|(
name|CHANcc
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|CHANccfd
argument_list|,
operator|&
name|MyRead
argument_list|)
expr_stmt|;
block|}
comment|/* Loop through all active channels.  Somebody could have closed 	 * closed a channel so we double-check the global mask before 	 * looking at what select returned.  The code here is written so 	 * that a channel could be reading and writing and sleeping at the 	 * same time, even though that's not possible.  (Just as well, 	 * since in SysVr4 the count would be wrong.) */
name|lastfd
operator|=
name|CHANlastfd
expr_stmt|;
if|if
condition|(
name|lastfd
operator|<
name|CHANlastsleepfd
condition|)
name|lastfd
operator|=
name|CHANlastsleepfd
expr_stmt|;
if|if
condition|(
name|fd
operator|>
name|lastfd
condition|)
name|fd
operator|=
literal|0
expr_stmt|;
name|startpoint
operator|=
name|fd
expr_stmt|;
do|do
block|{
name|cp
operator|=
operator|&
name|CHANtable
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|Type
operator|==
name|CTfree
condition|)
goto|goto
name|Next
goto|;
comment|/* Anything to read? */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|RCHANmask
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|MyRead
argument_list|)
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|cp
operator|->
name|LastActive
operator|=
name|Now
operator|.
name|time
expr_stmt|;
call|(
modifier|*
name|cp
operator|->
name|Reader
call|)
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* Possibly recheck for dead children so we don't get SIGPIPE 	     * on readerless channels. */
if|if
condition|(
name|PROCneedscan
condition|)
name|PROCscan
argument_list|()
expr_stmt|;
comment|/* Ready to write? */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|WCHANmask
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|MyWrite
argument_list|)
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|bp
operator|=
operator|&
name|cp
operator|->
name|Out
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|Left
condition|)
block|{
name|cp
operator|->
name|LastActive
operator|=
name|Now
operator|.
name|time
expr_stmt|;
name|i
operator|=
name|largewrite
argument_list|(
name|fd
argument_list|,
operator|&
name|bp
operator|->
name|Data
index|[
name|bp
operator|->
name|Used
index|]
argument_list|,
name|bp
operator|->
name|Left
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
name|p
operator|=
name|CHANname
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write %m"
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|cp
operator|->
name|BadWrites
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|oerrno
operator|==
name|EPIPE
condition|)
block|{
name|SITEchanclose
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|CHANclose
argument_list|(
name|cp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|oerrno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|WCHANremove
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|CHANwritesleep
argument_list|(
name|cp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|->
name|BadWrites
operator|>=
name|BAD_IO_COUNT
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s sleeping"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|WCHANremove
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|SCHANadd
argument_list|(
name|cp
argument_list|,
call|(
name|time_t
call|)
argument_list|(
name|Now
operator|.
name|time
operator|+
name|PAUSE_RETRY_TIME
argument_list|)
argument_list|,
operator|(
name|POINTER
operator|)
name|NULL
argument_list|,
name|CHANwakeup
argument_list|,
operator|(
name|POINTER
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cp
operator|->
name|BadWrites
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|BlockedWrites
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|Left
operator|-=
name|i
expr_stmt|;
name|bp
operator|->
name|Used
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|Left
operator|<=
literal|0
condition|)
block|{
name|WCHANremove
argument_list|(
name|cp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cp
operator|->
name|WriteDone
call|)
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Coming off a sleep? */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|SCHANmask
argument_list|)
operator|&&
name|cp
operator|->
name|Waketime
operator|<=
name|Now
operator|.
name|time
condition|)
block|{
name|cp
operator|->
name|LastActive
operator|=
name|Now
operator|.
name|time
expr_stmt|;
name|SCHANremove
argument_list|(
name|cp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cp
operator|->
name|Waker
call|)
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* Has this channel been inactive very long? */
if|if
condition|(
name|cp
operator|->
name|Type
operator|==
name|CTnntp
operator|&&
name|cp
operator|->
name|LastActive
operator|+
name|cp
operator|->
name|NextLog
operator|<
name|Now
operator|.
name|time
condition|)
block|{
name|p
operator|=
name|CHANname
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|silence
operator|=
name|Now
operator|.
name|time
operator|-
name|cp
operator|->
name|LastActive
expr_stmt|;
name|cp
operator|->
name|NextLog
operator|+=
name|CHANNEL_INACTIVE_TIME
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s inactive %ld"
argument_list|,
name|p
argument_list|,
name|silence
operator|/
literal|60L
argument_list|)
expr_stmt|;
if|if
condition|(
name|silence
operator|>
name|PEER_TIMEOUT
condition|)
block|{
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s timeout"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|CHANclose
argument_list|(
name|cp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|Next
label|:
comment|/* Bump pointer, modulo the table size. */
if|if
condition|(
name|fd
operator|>=
name|lastfd
condition|)
name|fd
operator|=
literal|0
expr_stmt|;
else|else
name|fd
operator|++
expr_stmt|;
comment|/* If there is nothing to do, break out. */
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|SCHANcount
operator|==
literal|0
condition|)
break|break;
block|}
do|while
condition|(
name|fd
operator|!=
name|startpoint
condition|)
do|;
block|}
block|}
end_function

end_unit

