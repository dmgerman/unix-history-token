begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.31 $ ** **  Routines for the in-core data structures for the newsfeeds file. */
end_comment

begin_include
include|#
directive|include
file|"innd.h"
end_include

begin_decl_stmt
name|STATIC
name|SITE
name|SITEnull
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|SITEfeedspath
index|[]
init|=
name|_PATH_NEWSFEEDS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Return a copy of an array of strings. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
modifier|*
name|SITEcopystrings
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|new
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
modifier|*
name|save
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|av
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
continue|continue;
for|for
control|(
name|new
operator|=
name|save
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|pp
operator|-
name|av
operator|+
literal|1
argument_list|)
operator|,
name|pp
operator|=
name|av
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
operator|*
name|new
operator|++
operator|=
name|COPY
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|new
operator|=
name|NULL
expr_stmt|;
return|return
name|save
return|;
block|}
end_function

begin_comment
comment|/* **  Read the newsfeeds file, return a string array of entries. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|SITEreadfile
parameter_list|(
name|ReadOnly
parameter_list|)
name|BOOL
name|ReadOnly
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
modifier|*
name|old_strings
decl_stmt|;
specifier|static
name|time_t
name|old_mtime
decl_stmt|;
specifier|static
name|ino_t
name|old_ino
decl_stmt|;
specifier|static
name|off_t
name|old_size
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|char
modifier|*
name|site
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|old_strings
operator|!=
name|NULL
condition|)
block|{
comment|/* If the file hasn't changed, return a copy of the old data. */
if|if
condition|(
name|stat
argument_list|(
name|SITEfeedspath
argument_list|,
operator|&
name|Sb
argument_list|)
operator|>=
literal|0
operator|&&
name|Sb
operator|.
name|st_ino
operator|==
name|old_ino
operator|&&
name|Sb
operator|.
name|st_size
operator|==
name|old_size
operator|&&
name|Sb
operator|.
name|st_mtime
operator|==
name|old_mtime
condition|)
return|return
name|ReadOnly
condition|?
name|old_strings
else|:
name|SITEcopystrings
argument_list|(
name|old_strings
argument_list|)
return|;
comment|/* Data's bad, toss it. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|old_strings
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|DISPOSE
argument_list|(
name|old_strings
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|old_strings
argument_list|)
expr_stmt|;
block|}
comment|/* Read in the file, note its statistics. */
if|if
condition|(
operator|(
name|data
operator|=
name|ReadInFile
argument_list|(
name|SITEfeedspath
argument_list|,
operator|&
name|Sb
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant read %s %m"
argument_list|,
name|LogName
argument_list|,
name|SITEfeedspath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|old_mtime
operator|=
name|Sb
operator|.
name|st_mtime
expr_stmt|;
name|old_ino
operator|=
name|Sb
operator|.
name|st_ino
expr_stmt|;
name|old_size
operator|=
name|Sb
operator|.
name|st_size
expr_stmt|;
comment|/* Get a gross count of the number of sites. */
for|for
control|(
name|p
operator|=
name|data
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
operator|,
name|i
operator|++
control|)
continue|continue;
comment|/* Scan the file, parse all multi-line entries. */
for|for
control|(
name|old_strings
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|,
name|i
operator|=
literal|0
operator|,
name|to
operator|=
name|p
operator|=
name|data
init|;
operator|*
name|p
condition|;
control|)
block|{
for|for
control|(
name|site
operator|=
name|to
init|;
operator|*
name|p
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|p
operator|++
expr_stmt|;
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
while|while
condition|(
operator|*
operator|++
name|p
operator|&&
name|CTYPE
argument_list|(
name|isspace
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
else|else
operator|*
name|to
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|to
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|site
operator|==
name|COMMENT_CHAR
operator|||
operator|*
name|site
operator|==
literal|'\0'
condition|)
continue|continue;
name|old_strings
index|[
name|i
operator|++
index|]
operator|=
name|COPY
argument_list|(
name|site
argument_list|)
expr_stmt|;
block|}
name|old_strings
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|DISPOSE
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|ReadOnly
condition|?
name|old_strings
else|:
name|SITEcopystrings
argument_list|(
name|old_strings
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Modify "subbed" according to the patterns in "patlist." */
end_comment

begin_function
name|STATIC
name|void
name|SITEsetlist
parameter_list|(
name|patlist
parameter_list|,
name|subbed
parameter_list|)
name|char
modifier|*
modifier|*
name|patlist
decl_stmt|;
name|char
modifier|*
name|subbed
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|pat
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|subvalue
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|(
name|pat
operator|=
operator|*
name|patlist
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
name|subvalue
operator|=
operator|*
name|pat
operator|!=
name|SUB_NEGATE
expr_stmt|;
if|if
condition|(
operator|!
name|subvalue
condition|)
name|pat
operator|++
expr_stmt|;
comment|/* See if pattern is a simple newsgroup name.  If so, set the 	 * right subbed element for that one group (if found); if not, 	 * pattern-match against all the groups. */
for|for
control|(
name|p
operator|=
name|pat
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'?'
operator|||
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'['
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
comment|/* Simple string; look it up, set it. */
if|if
condition|(
operator|(
name|ngp
operator|=
name|NGfind
argument_list|(
name|pat
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|subbed
index|[
name|ngp
operator|-
name|Groups
index|]
operator|=
name|subvalue
expr_stmt|;
block|}
else|else
for|for
control|(
name|p
operator|=
name|subbed
operator|,
name|ngp
operator|=
name|Groups
operator|,
name|i
operator|=
name|nGroups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|wildmat
argument_list|(
name|ngp
operator|->
name|Name
argument_list|,
name|pat
argument_list|)
condition|)
operator|*
name|p
operator|=
name|subvalue
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Parse an individual site entry.  Subbed is used to build the subscription **  list.  Since this routine is called once for each site, the caller **  allocates subbed once, and frees it after the last site has been parsed. **  If subbed is NULL, we don't update the SITE array, since we're just **  doing syntax checking. */
end_comment

begin_function
name|STRING
name|SITEparseone
parameter_list|(
name|Entry
parameter_list|,
name|sp
parameter_list|,
name|subbed
parameter_list|)
name|char
modifier|*
name|Entry
decl_stmt|;
name|SITE
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|subbed
decl_stmt|;
block|{
specifier|static
name|char
name|BATCH
index|[]
init|=
name|_PATH_BATCHDIR
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|f2
decl_stmt|;
name|char
modifier|*
name|f3
decl_stmt|;
name|char
modifier|*
name|f4
decl_stmt|;
name|char
modifier|*
modifier|*
name|save
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|BOOL
name|JustModerated
decl_stmt|;
name|BOOL
name|JustUnmoderated
decl_stmt|;
name|int
name|isp
decl_stmt|;
name|SITE
modifier|*
name|nsp
decl_stmt|;
name|BUFFER
name|b
decl_stmt|;
name|b
operator|=
name|sp
operator|->
name|Buffer
expr_stmt|;
operator|*
name|sp
operator|=
name|SITEnull
expr_stmt|;
name|sp
operator|->
name|Buffer
operator|=
name|b
expr_stmt|;
name|sp
operator|->
name|Master
operator|=
name|NOSITE
expr_stmt|;
name|sp
operator|->
name|Funnel
operator|=
name|NOSITE
expr_stmt|;
name|sp
operator|->
name|Process
operator|=
operator|-
literal|1
expr_stmt|;
name|sp
operator|->
name|Entry
operator|=
name|Entry
expr_stmt|;
name|sp
operator|->
name|FileFlags
index|[
literal|0
index|]
operator|=
name|FEED_NAME
expr_stmt|;
name|sp
operator|->
name|FileFlags
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Nip off the first field, the site name. */
if|if
condition|(
operator|(
name|f2
operator|=
name|strchr
argument_list|(
name|Entry
argument_list|,
name|NF_FIELD_SEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|"missing field 2"
return|;
operator|*
name|f2
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sp
operator|->
name|Name
operator|=
name|Entry
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|sp
operator|->
name|Name
argument_list|,
name|NF_SUBFIELD_SEP
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Exclusions within the site field. */
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sp
operator|->
name|Exclusions
operator|=
name|CommaSplit
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|NameLength
operator|=
name|strlen
argument_list|(
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
comment|/* Parse the second field, the subscriptions. */
if|if
condition|(
operator|(
name|f3
operator|=
name|strchr
argument_list|(
name|f2
argument_list|,
name|NF_FIELD_SEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|"missing field 3"
return|;
operator|*
name|f3
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|f2
argument_list|,
name|NF_SUBFIELD_SEP
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Distributions within the subscription field. */
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sp
operator|->
name|Distributions
operator|=
name|CommaSplit
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|Patterns
operator|=
name|CommaSplit
argument_list|(
name|f2
argument_list|)
expr_stmt|;
if|if
condition|(
name|subbed
condition|)
block|{
comment|/* Read the subscription patterns and set the bits. */
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|POINTER
operator|)
name|subbed
argument_list|,
name|SUB_DEFAULT
argument_list|,
operator|(
name|SIZE_T
operator|)
name|nGroups
argument_list|)
expr_stmt|;
if|if
condition|(
name|ME
operator|.
name|Patterns
condition|)
name|SITEsetlist
argument_list|(
name|ME
operator|.
name|Patterns
argument_list|,
name|subbed
argument_list|)
expr_stmt|;
name|SITEsetlist
argument_list|(
name|sp
operator|->
name|Patterns
argument_list|,
name|subbed
argument_list|)
expr_stmt|;
block|}
comment|/* Get the third field, the flags. */
if|if
condition|(
operator|(
name|f4
operator|=
name|strchr
argument_list|(
name|f3
argument_list|,
name|NF_FIELD_SEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|"missing field 4"
return|;
operator|*
name|f4
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|JustModerated
operator|=
name|FALSE
expr_stmt|;
name|JustUnmoderated
operator|=
name|FALSE
expr_stmt|;
name|sp
operator|->
name|Type
operator|=
name|FTfile
expr_stmt|;
for|for
control|(
name|save
operator|=
name|argv
operator|=
name|CommaSplit
argument_list|(
name|f3
argument_list|)
init|;
operator|(
name|p
operator|=
operator|*
name|argv
operator|++
operator|)
operator|!=
name|NULL
condition|;
control|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
default|default:
return|return
literal|"unknown field 3 flag"
return|;
case|case
literal|'\0'
case|:
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
operator|*
operator|++
name|p
operator|&&
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
operator|*
name|p
argument_list|)
condition|)
name|sp
operator|->
name|MaxSize
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
while|while
condition|(
operator|*
operator|++
name|p
condition|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
default|default:
return|return
literal|"unknown A param in field 3"
return|;
case|case
literal|'d'
case|:
name|sp
operator|->
name|DistRequired
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|sp
operator|->
name|IgnorePath
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
operator|*
operator|++
name|p
operator|&&
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
operator|*
name|p
argument_list|)
condition|)
block|{
name|sp
operator|->
name|StartWriting
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|NF_SUBFIELD_SEP
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
operator|++
name|p
operator|&&
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
operator|*
name|p
argument_list|)
condition|)
name|sp
operator|->
name|StopWriting
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'/'
condition|)
name|sp
operator|->
name|SpoolName
operator|=
name|COPY
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
block|{
name|sp
operator|->
name|SpoolName
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|STRLEN
argument_list|(
name|BATCH
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FileGlue
argument_list|(
name|sp
operator|->
name|SpoolName
argument_list|,
name|BATCH
argument_list|,
literal|'/'
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'G'
case|:
if|if
condition|(
operator|*
operator|++
name|p
operator|&&
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
operator|*
name|p
argument_list|)
condition|)
name|sp
operator|->
name|Groupcount
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|sp
operator|->
name|Groupcount
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
operator|*
operator|++
name|p
operator|&&
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
operator|*
name|p
argument_list|)
condition|)
name|sp
operator|->
name|Hops
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|sp
operator|->
name|Hops
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
operator|*
operator|++
name|p
operator|&&
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
operator|*
name|p
argument_list|)
condition|)
name|sp
operator|->
name|Flushpoint
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
while|while
condition|(
operator|*
operator|++
name|p
condition|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
default|default:
return|return
literal|"unknown N param in field 3"
return|;
case|case
literal|'m'
case|:
name|JustModerated
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|JustUnmoderated
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
operator|*
operator|++
name|p
operator|&&
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
operator|*
name|p
argument_list|)
condition|)
name|sp
operator|->
name|StartSpooling
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
default|default:
return|return
literal|"unknown T param in field 3"
return|;
case|case
literal|'c'
case|:
name|sp
operator|->
name|Type
operator|=
name|FTchannel
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|sp
operator|->
name|Type
operator|=
name|FTlogonly
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|sp
operator|->
name|Type
operator|=
name|FTfile
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|sp
operator|->
name|Type
operator|=
name|FTfunnel
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|sp
operator|->
name|Type
operator|=
name|FTprogram
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|sp
operator|->
name|Type
operator|=
name|FTexploder
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'W'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
operator|++
name|p
operator|&&
name|i
operator|<
name|FEED_MAXFLAGS
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
default|default:
return|return
literal|"unknown W param in field 3"
return|;
case|case
name|FEED_FNLNAMES
case|:
comment|/* Funnel feed names	*/
name|sp
operator|->
name|FNLwantsnames
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FEED_HEADERS
case|:
comment|/* Article headers	*/
name|NeedHeaders
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FEED_OVERVIEW
case|:
name|NeedOverview
operator|=
name|TRUE
expr_stmt|;
comment|/* Overview data	*/
break|break;
case|case
name|FEED_BYTESIZE
case|:
comment|/* Size in bytes	*/
case|case
name|FEED_FULLNAME
case|:
comment|/* Full filename	*/
case|case
name|FEED_HDR_DISTRIB
case|:
comment|/* Distribution header	*/
case|case
name|FEED_HDR_NEWSGROUP
case|:
comment|/* Newsgroup header	*/
case|case
name|FEED_MESSAGEID
case|:
comment|/* Message-ID		*/
case|case
name|FEED_NAME
case|:
comment|/* Filename		*/
case|case
name|FEED_NEWSGROUP
case|:
comment|/* Newsgroup		*/
case|case
name|FEED_REPLIC
case|:
comment|/* Replication data	*/
case|case
name|FEED_SITE
case|:
comment|/* Site that gave it	*/
case|case
name|FEED_TIMERECEIVED
case|:
comment|/* When received	*/
break|break;
block|}
name|sp
operator|->
name|FileFlags
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
condition|)
return|return
literal|"too many W param values"
return|;
name|sp
operator|->
name|FileFlags
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|DISPOSE
argument_list|(
name|save
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|Flushpoint
operator|&&
name|sp
operator|->
name|Type
operator|!=
name|FTfile
condition|)
return|return
literal|"I param with non-file feed"
return|;
if|if
condition|(
name|subbed
condition|)
block|{
comment|/* Modify the subscription list based on the flags. */
if|if
condition|(
name|JustModerated
condition|)
for|for
control|(
name|p
operator|=
name|subbed
operator|,
name|ngp
operator|=
name|Groups
operator|,
name|i
operator|=
name|nGroups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|ngp
operator|->
name|Rest
index|[
literal|0
index|]
operator|!=
name|NF_FLAG_MODERATED
condition|)
operator|*
name|p
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|JustUnmoderated
condition|)
for|for
control|(
name|p
operator|=
name|subbed
operator|,
name|ngp
operator|=
name|Groups
operator|,
name|i
operator|=
name|nGroups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|ngp
operator|->
name|Rest
index|[
literal|0
index|]
operator|==
name|NF_FLAG_MODERATED
condition|)
operator|*
name|p
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Get the fourth field, the param. */
if|if
condition|(
operator|*
name|f4
operator|==
literal|'\0'
operator|&&
name|sp
operator|!=
operator|&
name|ME
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|Type
operator|!=
name|FTfile
operator|&&
name|sp
operator|->
name|Type
operator|!=
name|FTlogonly
condition|)
return|return
literal|"empty field 4"
return|;
name|sp
operator|->
name|Param
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|STRLEN
argument_list|(
name|BATCH
argument_list|)
operator|+
literal|1
operator|+
name|sp
operator|->
name|NameLength
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FileGlue
argument_list|(
name|sp
operator|->
name|Param
argument_list|,
name|BATCH
argument_list|,
literal|'/'
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|Type
operator|==
name|FTfile
operator|&&
operator|*
name|f4
operator|!=
literal|'/'
condition|)
block|{
name|sp
operator|->
name|Param
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|STRLEN
argument_list|(
name|BATCH
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|f4
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FileGlue
argument_list|(
name|sp
operator|->
name|Param
argument_list|,
name|BATCH
argument_list|,
literal|'/'
argument_list|,
name|f4
argument_list|)
expr_stmt|;
block|}
else|else
name|sp
operator|->
name|Param
operator|=
name|COPY
argument_list|(
name|f4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|SpoolName
operator|==
name|NULL
condition|)
block|{
name|sp
operator|->
name|SpoolName
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|STRLEN
argument_list|(
name|BATCH
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|sp
operator|->
name|Name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FileGlue
argument_list|(
name|sp
operator|->
name|SpoolName
argument_list|,
name|BATCH
argument_list|,
literal|'/'
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure there is only one %s, and only one *. */
if|if
condition|(
name|sp
operator|->
name|Type
operator|==
name|FTprogram
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|sp
operator|->
name|Param
argument_list|,
literal|'%'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'*'
operator|&&
operator|!
name|CTYPE
argument_list|(
name|isalpha
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'s'
operator|||
name|strchr
argument_list|(
name|p
argument_list|,
literal|'%'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
literal|"bad sprintf format for field 4"
return|;
block|}
if|if
condition|(
name|sp
operator|->
name|FNLwantsnames
operator|&&
operator|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|sp
operator|->
name|Param
argument_list|,
literal|'*'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|strchr
argument_list|(
operator|++
name|p
argument_list|,
literal|'*'
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
return|return
literal|"multiple or no *'s in field 4"
return|;
block|}
comment|/* Now tell the groups this site gets that they should feed this site. */
if|if
condition|(
name|sp
operator|!=
operator|&
name|ME
operator|&&
name|subbed
condition|)
block|{
name|isp
operator|=
name|sp
operator|-
name|Sites
expr_stmt|;
for|for
control|(
name|p
operator|=
name|subbed
operator|,
name|ngp
operator|=
name|Groups
operator|,
name|i
operator|=
name|nGroups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|++
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ngp
operator|->
name|nSites
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|ngp
operator|->
name|Sites
index|[
name|j
index|]
operator|==
name|NOSITE
condition|)
block|{
name|ngp
operator|->
name|Sites
index|[
name|j
index|]
operator|=
name|isp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|ngp
operator|->
name|nSites
condition|)
name|ngp
operator|->
name|Sites
index|[
name|ngp
operator|->
name|nSites
operator|++
index|]
operator|=
name|isp
expr_stmt|;
block|}
block|}
comment|/* If this is a duplicate name, find the master. */
name|nsp
operator|=
name|SITEfind
argument_list|(
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsp
operator|==
name|sp
condition|)
name|nsp
operator|=
name|SITEfindnext
argument_list|(
name|sp
operator|->
name|Name
argument_list|,
name|nsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nsp
operator|->
name|Master
operator|!=
name|NOSITE
condition|)
name|nsp
operator|=
operator|&
name|Sites
index|[
name|nsp
operator|->
name|Master
index|]
expr_stmt|;
if|if
condition|(
name|nsp
operator|!=
name|sp
condition|)
block|{
name|sp
operator|->
name|Master
operator|=
name|nsp
operator|-
name|Sites
expr_stmt|;
name|nsp
operator|->
name|IsMaster
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Patch up the funnel references. */
end_comment

begin_function
name|BOOL
name|SITEfunnelpatch
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
name|SITE
modifier|*
name|funnel
decl_stmt|;
name|BOOL
name|result
decl_stmt|;
comment|/* Get worst-case length of all sitenames. */
for|for
control|(
name|length
operator|=
literal|0
operator|,
name|i
operator|=
name|nSites
operator|,
name|sp
operator|=
name|Sites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|Name
operator|!=
name|NULL
condition|)
name|length
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
comment|/* Loop over all funnel feeds. */
for|for
control|(
name|result
operator|=
name|TRUE
operator|,
name|i
operator|=
name|nSites
operator|,
name|sp
operator|=
name|Sites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|Type
operator|!=
name|FTfunnel
condition|)
continue|continue;
comment|/* Find the entry they feed in to, give that entry a buffer. */
if|if
condition|(
name|sp
operator|->
name|Param
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s funnel NULL"
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|SITEfree
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|result
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|funnel
operator|=
name|SITEfind
argument_list|(
name|sp
operator|->
name|Param
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s funnel_bad"
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|SITEfree
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|result
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|funnel
operator|->
name|Type
operator|==
name|FTfunnel
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s funnels to funnel %s"
argument_list|,
name|sp
operator|->
name|Name
argument_list|,
name|funnel
operator|->
name|Name
argument_list|)
expr_stmt|;
name|SITEfree
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|result
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|funnel
operator|->
name|FNLnames
operator|.
name|Data
operator|==
name|NULL
condition|)
block|{
name|funnel
operator|->
name|FNLnames
operator|.
name|Size
operator|=
name|length
expr_stmt|;
name|funnel
operator|->
name|FNLnames
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|funnel
operator|->
name|FNLnames
operator|.
name|Size
operator|!=
name|length
condition|)
block|{
name|funnel
operator|->
name|FNLnames
operator|.
name|Size
operator|=
name|length
expr_stmt|;
name|RENEW
argument_list|(
name|funnel
operator|->
name|FNLnames
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|Funnel
operator|=
name|funnel
operator|-
name|Sites
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* **  Read the entries in the newsfeeds file, and parse them one at a time. */
end_comment

begin_function
name|void
name|SITEparsefile
parameter_list|(
name|StartSite
parameter_list|)
name|BOOL
name|StartSite
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|strings
decl_stmt|;
name|SITE
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|subbed
decl_stmt|;
name|STRING
name|error
decl_stmt|;
name|int
name|errors
decl_stmt|;
comment|/* Free old sites info. */
if|if
condition|(
name|Sites
condition|)
block|{
for|for
control|(
name|i
operator|=
name|nSites
operator|,
name|sp
operator|=
name|Sites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
block|{
name|SITEflush
argument_list|(
name|sp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|SITEfree
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|DISPOSE
argument_list|(
name|Sites
argument_list|)
expr_stmt|;
name|SITEfree
argument_list|(
operator|&
name|ME
argument_list|)
expr_stmt|;
block|}
comment|/* Count the number of sites. */
for|for
control|(
name|strings
operator|=
name|SITEreadfile
argument_list|(
name|FALSE
argument_list|)
operator|,
name|nSites
operator|=
literal|0
init|;
name|strings
index|[
name|nSites
index|]
condition|;
name|nSites
operator|++
control|)
continue|continue;
name|Sites
operator|=
name|NEW
argument_list|(
name|SITE
argument_list|,
name|nSites
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|Sites
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nSites
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
name|sp
operator|->
name|Name
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|Buffer
operator|.
name|Data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Set up scratch subscription list. */
name|subbed
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|nGroups
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|Sites
operator|,
name|errors
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nSites
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|strings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'M'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'E'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
name|NF_FIELD_SEP
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|SITEparseone
argument_list|(
name|p
argument_list|,
operator|&
name|ME
argument_list|,
name|subbed
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s bad_newsfeeds %s"
argument_list|,
name|MaxLength
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|SITEparseone
argument_list|(
name|p
argument_list|,
name|sp
argument_list|,
name|subbed
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s bad_newsfeeds %s"
argument_list|,
name|MaxLength
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|StartSite
operator|&&
operator|!
name|SITEsetup
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant setup %m"
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
continue|continue;
block|}
name|sp
operator|->
name|Working
operator|=
name|TRUE
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|errors
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s syntax_error %s"
argument_list|,
name|LogName
argument_list|,
name|SITEfeedspath
argument_list|)
expr_stmt|;
name|JustCleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Free our scratch array, set up the funnel links. */
name|nSites
operator|=
name|sp
operator|-
name|Sites
expr_stmt|;
name|DISPOSE
argument_list|(
name|subbed
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|strings
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SITEfunnelpatch
argument_list|()
condition|)
block|{
name|JustCleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|SITElinkall
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

