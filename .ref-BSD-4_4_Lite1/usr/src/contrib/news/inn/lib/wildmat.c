begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.9 $ ** **  Do shell-style pattern matching for ?, \, [], and * characters. **  Might not be robust in face of malformed patterns; e.g., "foo[a-" **  could cause a segmentation violation.  It is 8bit clean. ** **  Written by Rich $alz, mirror!rs, Wed Nov 26 19:03:17 EST 1986. **  Rich $alz is now<rsalz@osf.org>. **  April, 1991:  Replaced mutually-recursive calls with in-line code **  for the star character. ** **  Special thanks to Lars Mathiesen<thorinn@diku.dk> for the ABORT code. **  This can greatly speed up failing wildcard patterns.  For example: **	pattern: -*-*-*-*-*-*-12-*-*-*-m-*-*-* **	text 1:	 -adobe-courier-bold-o-normal--12-120-75-75-m-70-iso8859-1 **	text 2:	 -adobe-courier-bold-o-normal--12-120-75-75-X-70-iso8859-1 **  Text 1 matches with 51 calls, while text 2 fails with 54 calls.  Without **  the ABORT code, it takes 22310 calls to fail.  Ugh.  The following **  explanation is from Lars: **  The precondition that must be fulfilled is that DoMatch will consume **  at least one character in text.  This is true if *p is neither '*' nor **  '\0'.)  The last return has ABORT instead of FALSE to avoid quadratic **  behaviour in cases like pattern "*a*b*c*d" with text "abcxxxxx".  With **  FALSE, each star-loop has to run to the end of the text; with ABORT **  only the last one does. ** **  Once the control of one instance of DoMatch enters the star-loop, that **  instance will return either TRUE or ABORT, and any calling instance **  will therefore return immediately after (without calling recursively **  again).  In effect, only one star-loop is ever active.  It would be **  possible to modify the code to maintain this context explicitly, **  eliminating all recursive calls at the cost of some complication and **  loss of clarity (and the ABORT stuff seems to be unclear enough by **  itself).  I think it would be unwise to try to get this into a **  released version unless you have a good test data base to try it out **  on. */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|ABORT
value|-1
end_define

begin_comment
comment|/* What character marks an inverted character class? */
end_comment

begin_define
define|#
directive|define
name|NEGATE_CLASS
value|'^'
end_define

begin_comment
comment|/* Is "*" a common pattern? */
end_comment

begin_define
define|#
directive|define
name|OPTIMIZE_JUST_STAR
end_define

begin_comment
comment|/* Do tar(1) matching rules, which ignore a trailing slash? */
end_comment

begin_undef
undef|#
directive|undef
name|MATCH_TAR_PATTERN
end_undef

begin_comment
comment|/* **  Match text and p, return TRUE, FALSE, or ABORT. */
end_comment

begin_function
specifier|static
name|int
name|DoMatch
parameter_list|(
name|text
parameter_list|,
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|text
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|last
decl_stmt|;
specifier|register
name|int
name|matched
decl_stmt|;
specifier|register
name|int
name|reverse
decl_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
name|text
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|text
operator|==
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'*'
condition|)
return|return
name|ABORT
return|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
comment|/* Literal match with following character. */
name|p
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
operator|*
name|text
operator|!=
operator|*
name|p
condition|)
return|return
name|FALSE
return|;
continue|continue;
case|case
literal|'?'
case|:
comment|/* Match anything. */
continue|continue;
case|case
literal|'*'
case|:
while|while
condition|(
operator|*
operator|++
name|p
operator|==
literal|'*'
condition|)
comment|/* Consecutive stars act just like one. */
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
comment|/* Trailing star matches everything. */
return|return
name|TRUE
return|;
while|while
condition|(
operator|*
name|text
condition|)
if|if
condition|(
operator|(
name|matched
operator|=
name|DoMatch
argument_list|(
name|text
operator|++
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|FALSE
condition|)
return|return
name|matched
return|;
return|return
name|ABORT
return|;
case|case
literal|'['
case|:
name|reverse
operator|=
name|p
index|[
literal|1
index|]
operator|==
name|NEGATE_CLASS
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
comment|/* Inverted character class. */
name|p
operator|++
expr_stmt|;
name|matched
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|']'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
if|if
condition|(
operator|*
operator|++
name|p
operator|==
operator|*
name|text
condition|)
name|matched
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|last
operator|=
operator|*
name|p
init|;
operator|*
operator|++
name|p
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|;
name|last
operator|=
operator|*
name|p
control|)
comment|/* This next line requires a good C compiler. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|']'
condition|?
operator|*
name|text
operator|<=
operator|*
operator|++
name|p
operator|&&
operator|*
name|text
operator|>=
name|last
else|:
operator|*
name|text
operator|==
operator|*
name|p
condition|)
name|matched
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|matched
operator|==
name|reverse
condition|)
return|return
name|FALSE
return|;
continue|continue;
block|}
block|}
ifdef|#
directive|ifdef
name|MATCH_TAR_PATTERN
if|if
condition|(
operator|*
name|text
operator|==
literal|'/'
condition|)
return|return
name|TRUE
return|;
endif|#
directive|endif
comment|/* MATCH_TAR_ATTERN */
return|return
operator|*
name|text
operator|==
literal|'\0'
return|;
block|}
end_function

begin_comment
comment|/* **  User-level routine.  Returns TRUE or FALSE. */
end_comment

begin_function
name|int
name|wildmat
parameter_list|(
name|text
parameter_list|,
name|p
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OPTIMIZE_JUST_STAR
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
endif|#
directive|endif
comment|/* OPTIMIZE_JUST_STAR */
return|return
name|DoMatch
argument_list|(
name|text
argument_list|,
name|p
argument_list|)
operator|==
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TEST
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Yes, we use gets not fgets.  Sue me. */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|gets
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|()
block|{
name|char
name|p
index|[
literal|80
index|]
decl_stmt|;
name|char
name|text
index|[
literal|80
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"Wildmat tester.  Enter pattern, then strings to test.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"A blank line gets prompts for a new pattern; a blank pattern\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"exits the program.\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"\nEnter pattern:  "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|gets
argument_list|(
name|p
argument_list|)
operator|==
name|NULL
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"Enter text:  "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|gets
argument_list|(
name|text
argument_list|)
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* Blank line; go back and get a new pattern. */
break|break;
name|printf
argument_list|(
literal|"      %s\n"
argument_list|,
name|wildmat
argument_list|(
name|text
argument_list|,
name|p
argument_list|)
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(TEST) */
end_comment

end_unit

