begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.9 $ ** */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"configdata.h"
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|"clibrary.h"
end_include

begin_include
include|#
directive|include
file|"libinn.h"
end_include

begin_include
include|#
directive|include
file|"nntp.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_decl_stmt
name|STATIC
name|char
name|CApathname
index|[
sizeof|sizeof
name|_PATH_TEMPACTIVE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|FILE
modifier|*
name|CAfp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Get a copy of the active file for a client host to use, locally or **  remotely. */
end_comment

begin_function
name|FILE
modifier|*
name|CAopen
parameter_list|(
name|FromServer
parameter_list|,
name|ToServer
parameter_list|)
name|FILE
modifier|*
name|FromServer
decl_stmt|;
name|FILE
modifier|*
name|ToServer
decl_stmt|;
block|{
comment|/* Use a local (or NFS-mounted) copy if available.  Make sure we don't      * try to delete it when we close it. */
if|if
condition|(
operator|(
name|CAfp
operator|=
name|fopen
argument_list|(
name|_PATH_CLIENTACTIVE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|CApathname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|CAfp
return|;
block|}
comment|/* Use the active file from the server */
return|return
name|CAlistopen
argument_list|(
name|FromServer
argument_list|,
name|ToServer
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Internal library routine. */
end_comment

begin_function
name|FILE
modifier|*
name|CA_listopen
parameter_list|(
name|pathname
parameter_list|,
name|FromServer
parameter_list|,
name|ToServer
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
name|FILE
modifier|*
name|FromServer
decl_stmt|;
name|FILE
modifier|*
name|ToServer
decl_stmt|;
name|char
modifier|*
name|request
decl_stmt|;
block|{
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|oerrno
decl_stmt|;
name|FILE
modifier|*
name|F
decl_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|F
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Send a LIST command to and capture the output. */
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"list\r\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"list %s\r\n"
argument_list|,
name|request
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ToServer
argument_list|)
expr_stmt|;
comment|/* Get the server's reply to our command. */
if|if
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|FromServer
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|EQn
argument_list|(
name|buff
argument_list|,
name|NNTP_LIST_FOLLOWS
argument_list|,
name|STRLEN
argument_list|(
name|NNTP_LIST_FOLLOWS
argument_list|)
argument_list|)
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
name|CAclose
argument_list|()
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Slurp up the rest of the response. */
while|while
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|FromServer
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\r'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buff
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|buff
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|F
argument_list|)
operator|||
name|fflush
argument_list|(
name|F
argument_list|)
operator|==
name|EOF
operator|||
name|fclose
argument_list|(
name|F
argument_list|)
operator|==
name|EOF
condition|)
break|break;
return|return
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"r"
argument_list|)
return|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"%s\n"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
comment|/* Ran out of input before finding the terminator; quit. */
name|oerrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
name|CAclose
argument_list|()
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Use the NNTP list command to get a file from a server.  Default is **  the active file, otherwise ask for whatever is in the request param. */
end_comment

begin_function
name|FILE
modifier|*
name|CAlistopen
parameter_list|(
name|FromServer
parameter_list|,
name|ToServer
parameter_list|,
name|request
parameter_list|)
name|FILE
modifier|*
name|FromServer
decl_stmt|;
name|FILE
modifier|*
name|ToServer
decl_stmt|;
name|char
modifier|*
name|request
decl_stmt|;
block|{
comment|/* Gotta talk to the server -- see if we can. */
if|if
condition|(
name|FromServer
operator|==
name|NULL
operator|||
name|ToServer
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|CApathname
argument_list|,
name|_PATH_TEMPACTIVE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|CApathname
argument_list|)
expr_stmt|;
return|return
name|CAfp
operator|=
name|CA_listopen
argument_list|(
name|CApathname
argument_list|,
name|FromServer
argument_list|,
name|ToServer
argument_list|,
name|request
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Close the file opened by CAopen or CAlistopen. */
end_comment

begin_function
name|void
name|CAclose
parameter_list|()
block|{
if|if
condition|(
name|CAfp
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|CAfp
argument_list|)
expr_stmt|;
name|CAfp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|CApathname
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|CApathname
argument_list|)
expr_stmt|;
name|CApathname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

end_unit

