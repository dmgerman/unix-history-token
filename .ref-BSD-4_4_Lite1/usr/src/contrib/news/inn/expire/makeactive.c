begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.9 $ ** **  Build an active file from either an old copy or by calling find **  to get the directory names. */
end_comment

begin_include
include|#
directive|include
file|"configdata.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|"libinn.h"
end_include

begin_include
include|#
directive|include
file|"clibrary.h"
end_include

begin_include
include|#
directive|include
file|"mydir.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_decl_stmt
name|STATIC
name|char
name|ACTIVE
index|[]
init|=
name|_PATH_ACTIVE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Given an newsgroup name, write the active file entry. */
end_comment

begin_function
name|STATIC
name|BOOL
name|MakeEntry
parameter_list|(
name|name
parameter_list|,
name|rest
parameter_list|,
name|oldhimark
parameter_list|,
name|oldlomark
parameter_list|,
name|ComputeMarks
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|rest
decl_stmt|;
name|long
name|oldhimark
decl_stmt|;
name|long
name|oldlomark
decl_stmt|;
name|BOOL
name|ComputeMarks
decl_stmt|;
block|{
specifier|register
name|long
name|himark
decl_stmt|;
specifier|register
name|long
name|lomark
decl_stmt|;
specifier|register
name|DIR
modifier|*
name|dp
decl_stmt|;
specifier|register
name|DIRENTRY
modifier|*
name|ep
decl_stmt|;
specifier|register
name|long
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Turn group name into directory name. */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
comment|/* Set initial hi and lo marks. */
if|if
condition|(
name|ComputeMarks
condition|)
block|{
name|himark
operator|=
literal|0
expr_stmt|;
name|lomark
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|himark
operator|=
name|oldhimark
expr_stmt|;
name|lomark
operator|=
name|oldlomark
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dp
operator|=
name|opendir
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Scan through all entries in the directory. */
while|while
condition|(
operator|(
name|ep
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|ep
operator|->
name|d_name
expr_stmt|;
if|if
condition|(
operator|!
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
operator|||
name|strspn
argument_list|(
name|p
argument_list|,
literal|"0123456789"
argument_list|)
operator|!=
name|strlen
argument_list|(
name|p
argument_list|)
operator|||
operator|(
name|j
operator|=
name|atol
argument_list|(
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lomark
operator|==
literal|0
operator|||
name|j
operator|<
name|lomark
condition|)
name|lomark
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|himark
condition|)
name|himark
operator|=
name|j
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lomark
operator|==
literal|0
operator|||
name|lomark
operator|-
literal|1
operator|>
name|himark
condition|)
name|lomark
operator|=
name|himark
operator|+
literal|1
expr_stmt|;
comment|/* Reset marks if computed them and didn't find any articles. */
if|if
condition|(
name|ComputeMarks
operator|&&
name|lomark
operator|==
literal|1
operator|&&
name|himark
operator|==
literal|0
condition|)
block|{
name|himark
operator|=
name|oldhimark
expr_stmt|;
name|lomark
operator|=
name|oldlomark
expr_stmt|;
block|}
comment|/* Turn the directory name back into a newsgroup name. */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|*
name|p
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|printf
argument_list|(
literal|"%s %010.10ld %010.10ld %s\n"
argument_list|,
name|name
argument_list|,
name|himark
argument_list|,
name|lomark
argument_list|,
name|rest
argument_list|)
operator|==
name|EOF
operator|||
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|==
name|EOF
operator|||
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error writing %s entry, %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  See if a line is too long to be a newsgroup name, return TRUE if so. */
end_comment

begin_function
name|STATIC
name|BOOL
name|TooLong
parameter_list|(
name|buff
parameter_list|,
name|i
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d is too long:  \"%.40s\"...\n"
argument_list|,
name|i
argument_list|,
name|buff
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|-
name|buff
operator|>
name|SMBUF
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Group line %d is too long: \"%.40s\"...\n"
argument_list|,
name|i
argument_list|,
name|buff
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* **  Renumber the active file based on the old active file. */
end_comment

begin_function
name|STATIC
name|BOOL
name|RebuildFromOld
parameter_list|(
name|ComputeMarks
parameter_list|)
name|BOOL
name|ComputeMarks
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|BOOL
name|Ok
decl_stmt|;
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|STRING
name|rest
decl_stmt|;
name|long
name|lomark
decl_stmt|;
name|long
name|himark
decl_stmt|;
name|char
modifier|*
name|save1
decl_stmt|;
name|char
modifier|*
name|save2
decl_stmt|;
comment|/* Open the file. */
if|if
condition|(
operator|(
name|F
operator|=
name|fopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open \"%s\", %s\n"
argument_list|,
name|ACTIVE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Process each entry. */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|Ok
operator|=
name|TRUE
init|;
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TooLong
argument_list|(
name|buff
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|Ok
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
comment|/* Set default fields. */
name|lomark
operator|=
literal|0
expr_stmt|;
name|himark
operator|=
literal|0
expr_stmt|;
name|rest
operator|=
literal|"y"
expr_stmt|;
comment|/* Try to parse the other fields. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|save1
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|save2
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|rest
operator|=
name|p
expr_stmt|;
name|lomark
operator|=
name|atol
argument_list|(
name|save2
argument_list|)
expr_stmt|;
name|himark
operator|=
name|atol
argument_list|(
name|save1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|MakeEntry
argument_list|(
name|buff
argument_list|,
name|rest
argument_list|,
name|himark
argument_list|,
name|lomark
argument_list|,
name|ComputeMarks
argument_list|)
condition|)
block|{
name|Ok
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
return|return
name|Ok
return|;
block|}
end_function

begin_function
name|STATIC
name|BOOL
name|RebuildFromFind
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
specifier|register
name|BOOL
name|Ok
decl_stmt|;
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* Start getting a list of the directories. */
if|#
directive|if
name|defined
argument_list|(
name|DO_HAVE_SYMLINK
argument_list|)
name|F
operator|=
name|popen
argument_list|(
literal|"exec find . -follow -type d -print"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|#
directive|else
name|F
operator|=
name|popen
argument_list|(
literal|"exec find . -type d -print"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_HAVE_SYMLINK) */
if|if
condition|(
name|F
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't start find, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Loop over all input. */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|Ok
operator|=
name|TRUE
init|;
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TooLong
argument_list|(
name|buff
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|Ok
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
comment|/* Skip leading "./" and some known-to-be-bad directories. */
name|p
operator|=
name|buff
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|buff
index|[
literal|1
index|]
operator|==
literal|'/'
condition|?
operator|&
name|buff
index|[
literal|2
index|]
else|:
name|buff
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|p
argument_list|,
literal|"lost+found"
argument_list|)
operator|||
name|strchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MakeEntry
argument_list|(
name|p
argument_list|,
literal|"y"
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|Ok
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
comment|/* Clean up. */
name|i
operator|=
name|pclose
argument_list|(
name|F
argument_list|)
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Find exited with status %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Ok
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|Ok
return|;
block|}
end_function

begin_comment
comment|/* **  Print a usage message and exit. */
end_comment

begin_function
name|STATIC
name|NORETURN
name|Usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: makeactive [-o [-m] ]>output\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|BOOL
name|Ok
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|BOOL
name|OldFile
decl_stmt|;
name|BOOL
name|ComputeMarks
decl_stmt|;
comment|/* Set defaults. */
name|OldFile
operator|=
name|FALSE
expr_stmt|;
name|ComputeMarks
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|NEWSUMASK
argument_list|)
expr_stmt|;
comment|/* Parse JCL. */
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"mo"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|Usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'m'
case|:
name|ComputeMarks
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|OldFile
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|ac
operator|-=
name|optind
expr_stmt|;
name|av
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|ac
operator|||
operator|(
name|ComputeMarks
operator|&&
operator|!
name|OldFile
operator|)
condition|)
name|Usage
argument_list|()
expr_stmt|;
comment|/* Go to where the articles are. */
if|if
condition|(
name|chdir
argument_list|(
name|_PATH_SPOOL
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't change to spool directory, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OldFile
condition|)
name|Ok
operator|=
name|RebuildFromOld
argument_list|(
name|ComputeMarks
argument_list|)
expr_stmt|;
else|else
name|Ok
operator|=
name|RebuildFromFind
argument_list|()
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't flush stdout, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|Ok
operator|=
name|FALSE
expr_stmt|;
block|}
name|exit
argument_list|(
name|Ok
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

end_unit

