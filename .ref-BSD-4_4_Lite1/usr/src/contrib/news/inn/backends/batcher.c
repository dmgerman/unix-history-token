begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.17 $ ** **  Read batchfiles on standard input and spew out batches. */
end_comment

begin_include
include|#
directive|include
file|"configdata.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_NEED_TIME
argument_list|)
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DO_NEED_TIME) */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|"libinn.h"
end_include

begin_include
include|#
directive|include
file|"logging.h"
end_include

begin_include
include|#
directive|include
file|"clibrary.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_comment
comment|/* **  Global variables. */
end_comment

begin_decl_stmt
name|STATIC
name|BOOL
name|BATCHopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BOOL
name|STATprint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|double
name|STATbegin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|double
name|STATend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|Host
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|InitialString
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|Input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|Processor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|ArtsInBatch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|ArtsWritten
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|BATCHcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|MaxBatches
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|BATCHstatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|BytesInBatch
init|=
literal|60
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|BytesWritten
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|MaxArts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|MaxBytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|SIGVAR
name|GotInterrupt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|STRING
name|Separator
init|=
literal|"#! rnews %ld"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Start a batch process. */
end_comment

begin_function
name|STATIC
name|FILE
modifier|*
name|BATCHstart
parameter_list|()
block|{
name|FILE
modifier|*
name|F
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
if|if
condition|(
name|Processor
operator|&&
operator|*
name|Processor
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|Processor
argument_list|,
name|Host
argument_list|)
expr_stmt|;
name|F
operator|=
name|popen
argument_list|(
name|buff
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
else|else
name|F
operator|=
name|stdout
expr_stmt|;
name|BATCHopen
operator|=
name|TRUE
expr_stmt|;
name|BATCHcount
operator|++
expr_stmt|;
return|return
name|F
return|;
block|}
end_function

begin_comment
comment|/* **  Close a batch, return exit status. */
end_comment

begin_function
name|STATIC
name|int
name|BATCHclose
parameter_list|(
name|F
parameter_list|)
name|FILE
modifier|*
name|F
decl_stmt|;
block|{
name|BATCHopen
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|F
operator|==
name|stdout
condition|)
return|return
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|==
name|EOF
condition|?
literal|1
else|:
literal|0
return|;
return|return
name|pclose
argument_list|(
name|F
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Update the batch file and exit. */
end_comment

begin_function
name|STATIC
name|NORETURN
name|RequeueAndExit
parameter_list|(
name|Cookie
parameter_list|,
name|line
parameter_list|,
name|BytesInArt
parameter_list|)
name|OFFSET_T
name|Cookie
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|long
name|BytesInArt
decl_stmt|;
block|{
specifier|static
name|char
name|LINE1
index|[]
init|=
literal|"batcher %s times user %.3f system %.3f elapsed %.3f"
decl_stmt|;
specifier|static
name|char
name|LINE2
index|[]
init|=
literal|"batcher %s stats batches %d articles %d bytes %ld"
decl_stmt|;
specifier|static
name|char
name|NOWRITE
index|[]
init|=
literal|"batcher %s cant write spool %s\n"
decl_stmt|;
specifier|static
name|char
name|BATCHDIR
index|[]
init|=
name|_PATH_BATCHDIR
decl_stmt|;
name|char
name|temp
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|F
decl_stmt|;
name|TIMEINFO
name|Now
decl_stmt|;
name|double
name|usertime
decl_stmt|;
name|double
name|systime
decl_stmt|;
comment|/* Do statistics. */
operator|(
name|void
operator|)
name|GetTimeInfo
argument_list|(
operator|&
name|Now
argument_list|)
expr_stmt|;
name|STATend
operator|=
name|TIMEINFOasDOUBLE
argument_list|(
name|Now
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetResourceUsage
argument_list|(
operator|&
name|usertime
argument_list|,
operator|&
name|systime
argument_list|)
operator|<
literal|0
condition|)
block|{
name|usertime
operator|=
literal|0
expr_stmt|;
name|systime
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|STATprint
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|LINE1
argument_list|,
name|Host
argument_list|,
name|usertime
argument_list|,
name|systime
argument_list|,
name|STATend
operator|-
name|STATbegin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|LINE2
argument_list|,
name|Host
argument_list|,
name|BATCHcount
argument_list|,
name|ArtsWritten
argument_list|,
name|BytesWritten
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|openlog
argument_list|(
literal|"batcher"
argument_list|,
name|L_OPENLOG_FLAGS
operator||
name|LOG_PID
argument_list|,
name|LOG_INN_PROG
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
name|LINE1
argument_list|,
name|Host
argument_list|,
name|usertime
argument_list|,
name|systime
argument_list|,
name|STATend
operator|-
name|STATbegin
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
name|LINE2
argument_list|,
name|Host
argument_list|,
name|BATCHcount
argument_list|,
name|ArtsWritten
argument_list|,
name|BytesWritten
argument_list|)
expr_stmt|;
comment|/* Last batch exit okay? */
if|if
condition|(
name|BATCHstatus
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
comment|/* Yes, and we're all done -- remove input and exit. */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|Input
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|Input
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Don't seek back -- batch was fine. */
name|Cookie
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Make an appropriate spool file. */
if|if
condition|(
name|Input
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/%s"
argument_list|,
name|BATCHDIR
argument_list|,
name|Host
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s.bch"
argument_list|,
name|Input
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|F
operator|=
name|xfopena
argument_list|(
name|temp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"batcher %s cant open %s %s\n"
argument_list|,
name|Host
argument_list|,
name|temp
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If we can back up to where the batch started, do so. */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Cookie
operator|!=
operator|-
literal|1
operator|&&
name|fseek
argument_list|(
name|stdin
argument_list|,
name|Cookie
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"batcher %s cant seek %s\n"
argument_list|,
name|Host
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Write the line we had; if the fseek worked, this will be an      * extra line, but that's okay. */
if|if
condition|(
name|line
operator|&&
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"%s %ld\n"
argument_list|,
name|line
argument_list|,
name|BytesInArt
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|NOWRITE
argument_list|,
name|Host
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Write rest of stdin to spool. */
while|while
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|fputs
argument_list|(
name|buff
argument_list|,
name|F
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|NOWRITE
argument_list|,
name|Host
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|F
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"batcher %s cant close spool %s\n"
argument_list|,
name|Host
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we had a named input file, try to rename the spool. */
if|if
condition|(
name|Input
operator|!=
name|NULL
operator|&&
name|rename
argument_list|(
name|temp
argument_list|,
name|Input
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"batcher %s cant rename spool %s\n"
argument_list|,
name|Host
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
name|exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* **  Mark that we got interrupted. */
end_comment

begin_function
name|STATIC
name|SIGHANDLER
name|CATCHinterrupt
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
name|GotInterrupt
operator|=
name|TRUE
expr_stmt|;
comment|/* Let two interrupts kill us. */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|s
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Print a usage message and exit. */
end_comment

begin_function
name|STATIC
name|NORETURN
name|Usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"batcher usage_error.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|SKIPPING
index|[]
init|=
literal|"batcher %s skipping \"%.40s...\" %s\n"
decl_stmt|;
specifier|static
name|char
name|SPOOL
index|[]
init|=
name|_PATH_SPOOL
decl_stmt|;
specifier|static
name|char
name|BATCHDIR
index|[]
init|=
name|_PATH_BATCHDIR
decl_stmt|;
name|BOOL
name|Redirect
decl_stmt|;
name|FILE
modifier|*
name|F
decl_stmt|;
name|STRING
name|AltSpool
decl_stmt|;
name|TIMEINFO
name|Now
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|long
name|BytesInArt
decl_stmt|;
name|long
name|BytesInCB
decl_stmt|;
name|OFFSET_T
name|Cookie
decl_stmt|;
name|SIZE_T
name|datasize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|artfd
decl_stmt|;
name|int
name|ArtsInCB
decl_stmt|;
name|int
name|length
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
comment|/* Set defaults. */
name|AltSpool
operator|=
name|NULL
expr_stmt|;
name|Redirect
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|NEWSUMASK
argument_list|)
expr_stmt|;
comment|/* Parse JCL. */
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"a:A:b:B:i:N:p:rs:S:v"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|Usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'a'
case|:
name|ArtsInBatch
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|MaxArts
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|BytesInBatch
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|MaxBytes
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|InitialString
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|MaxBatches
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|Processor
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|Redirect
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|Separator
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|AltSpool
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|STATprint
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|MaxArts
operator|&&
name|ArtsInBatch
operator|==
literal|0
condition|)
name|ArtsInBatch
operator|=
name|MaxArts
expr_stmt|;
if|if
condition|(
name|MaxBytes
operator|&&
name|BytesInBatch
operator|==
literal|0
condition|)
name|BytesInBatch
operator|=
name|MaxBytes
expr_stmt|;
comment|/* Parse arguments. */
name|ac
operator|-=
name|optind
expr_stmt|;
name|av
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|ac
operator|!=
literal|1
operator|&&
name|ac
operator|!=
literal|2
condition|)
name|Usage
argument_list|()
expr_stmt|;
name|Host
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|Input
operator|=
name|av
index|[
literal|1
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|Input
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|Input
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|STRLEN
argument_list|(
name|BATCHDIR
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Input
argument_list|,
literal|"%s/%s"
argument_list|,
name|BATCHDIR
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freopen
argument_list|(
name|Input
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"batcher %s cant open %s %s\n"
argument_list|,
name|Host
argument_list|,
name|Input
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Redirect
condition|)
operator|(
name|void
operator|)
name|freopen
argument_list|(
name|_PATH_ERRLOG
argument_list|,
literal|"a"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* Go to where the articles are. */
if|if
condition|(
name|chdir
argument_list|(
name|SPOOL
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"batcher %s cant cd %s %s\n"
argument_list|,
name|Host
argument_list|,
name|SPOOL
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Set initial counters, etc. */
name|datasize
operator|=
literal|8
operator|*
literal|1024
expr_stmt|;
name|data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
name|BytesInCB
operator|=
literal|0
expr_stmt|;
name|ArtsInCB
operator|=
literal|0
expr_stmt|;
name|Cookie
operator|=
operator|-
literal|1
expr_stmt|;
name|GotInterrupt
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|CATCHinterrupt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|CATCHinterrupt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|CATCHinterrupt
argument_list|)
expr_stmt|;
comment|/* (void)signal(SIGPIPE, CATCHinterrupt); */
operator|(
name|void
operator|)
name|GetTimeInfo
argument_list|(
operator|&
name|Now
argument_list|)
expr_stmt|;
name|STATbegin
operator|=
name|TIMEINFOasDOUBLE
argument_list|(
name|Now
argument_list|)
expr_stmt|;
name|F
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Record line length in case we do an ftell. Not portable to 	 * systems with non-Unix file formats. */
name|length
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Get lines like "name size" */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|SKIPPING
argument_list|,
name|Host
argument_list|,
name|line
argument_list|,
literal|"too long"
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|line
index|[
literal|0
index|]
operator|==
name|COMMENT_CHAR
condition|)
continue|continue;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|BytesInArt
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|BytesInArt
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Strip of leading spool pathname. */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|line
index|[
name|STRLEN
argument_list|(
name|SPOOL
argument_list|)
index|]
operator|==
literal|'/'
operator|&&
name|EQn
argument_list|(
name|line
argument_list|,
name|SPOOL
argument_list|,
name|STRLEN
argument_list|(
name|SPOOL
argument_list|)
argument_list|)
condition|)
name|p
operator|=
name|line
operator|+
name|STRLEN
argument_list|(
name|SPOOL
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|p
operator|=
name|line
expr_stmt|;
comment|/* Open the file. */
if|if
condition|(
operator|(
name|artfd
operator|=
name|open
argument_list|(
name|p
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|SKIPPING
argument_list|,
name|Host
argument_list|,
name|p
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|AltSpool
operator|==
name|NULL
condition|)
continue|continue;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s/%s"
argument_list|,
name|AltSpool
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|artfd
operator|=
name|open
argument_list|(
name|buff
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|SKIPPING
argument_list|,
name|Host
argument_list|,
name|buff
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If we need to, get its size. */
if|if
condition|(
name|BytesInArt
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|artfd
argument_list|,
operator|&
name|Sb
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|SKIPPING
argument_list|,
name|Host
argument_list|,
name|line
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|artfd
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|Sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|SKIPPING
argument_list|,
name|Host
argument_list|,
name|line
argument_list|,
literal|"not a file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|artfd
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|BytesInArt
operator|=
name|Sb
operator|.
name|st_size
expr_stmt|;
block|}
comment|/* Have an open article, do we need to open a batch?  This code 	 * is here (rather then up before the while loop) so that we 	 * can avoid sending an empty batch.  The goto makes the code 	 * a bit more clear. */
if|if
condition|(
name|F
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|GotInterrupt
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|artfd
argument_list|)
expr_stmt|;
name|RequeueAndExit
argument_list|(
name|Cookie
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|F
operator|=
name|BATCHstart
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"batcher %s cant startbatch %d %s\n"
argument_list|,
name|Host
argument_list|,
name|BATCHcount
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|artfd
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|InitialString
operator|&&
operator|*
name|InitialString
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"%s\n"
argument_list|,
name|InitialString
argument_list|)
expr_stmt|;
name|BytesInCB
operator|+=
name|strlen
argument_list|(
name|InitialString
argument_list|)
operator|+
literal|1
expr_stmt|;
name|BytesWritten
operator|+=
name|strlen
argument_list|(
name|InitialString
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|Cookie
operator|=
name|ftell
argument_list|(
name|stdin
argument_list|)
operator|-
name|length
expr_stmt|;
goto|goto
name|SendIt
goto|;
block|}
comment|/* We're writing a batch, see if adding the current article 	 * would exceed the limits. */
if|if
condition|(
operator|(
name|ArtsInBatch
operator|>
literal|0
operator|&&
name|ArtsInCB
operator|+
literal|1
operator|>=
name|ArtsInBatch
operator|)
operator|||
operator|(
name|BytesInBatch
operator|>
literal|0
operator|&&
name|BytesInCB
operator|+
name|BytesInArt
operator|>=
name|BytesInBatch
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|BATCHstatus
operator|=
name|BATCHclose
argument_list|(
name|F
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|BATCHstatus
operator|==
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"batcher %s cant closebatch %d %s\n"
argument_list|,
name|Host
argument_list|,
name|BATCHcount
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"batcher %s batch %d exit %d\n"
argument_list|,
name|Host
argument_list|,
name|BATCHcount
argument_list|,
name|BATCHstatus
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|artfd
argument_list|)
expr_stmt|;
break|break;
block|}
name|ArtsInCB
operator|=
literal|0
expr_stmt|;
name|BytesInCB
operator|=
literal|0
expr_stmt|;
comment|/* See if we can start a new batch. */
if|if
condition|(
operator|(
name|MaxBatches
operator|>
literal|0
operator|&&
name|BATCHcount
operator|>=
name|MaxBatches
operator|)
operator|||
operator|(
name|MaxBytes
operator|>
literal|0
operator|&&
name|BytesWritten
operator|+
name|BytesInArt
operator|>=
name|MaxBytes
operator|)
operator|||
operator|(
name|MaxArts
operator|>
literal|0
operator|&&
name|ArtsWritten
operator|+
literal|1
operator|>=
name|MaxArts
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|artfd
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GotInterrupt
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|artfd
argument_list|)
expr_stmt|;
name|RequeueAndExit
argument_list|(
name|Cookie
argument_list|,
name|line
argument_list|,
name|BytesInArt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|F
operator|=
name|BATCHstart
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"batcher %s cant startbatch %d %s\n"
argument_list|,
name|Host
argument_list|,
name|BATCHcount
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|artfd
argument_list|)
expr_stmt|;
break|break;
block|}
name|Cookie
operator|=
name|ftell
argument_list|(
name|stdin
argument_list|)
operator|-
name|length
expr_stmt|;
block|}
name|SendIt
label|:
comment|/* Now we can start to send the article! */
if|if
condition|(
name|Separator
operator|&&
operator|*
name|Separator
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|Separator
argument_list|,
name|BytesInArt
argument_list|)
expr_stmt|;
name|BytesInCB
operator|+=
name|strlen
argument_list|(
name|buff
argument_list|)
operator|+
literal|1
expr_stmt|;
name|BytesWritten
operator|+=
name|strlen
argument_list|(
name|buff
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"%s\n"
argument_list|,
name|buff
argument_list|)
operator|==
name|EOF
operator|||
name|ferror
argument_list|(
name|F
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"batcher %s cant write separator %s\n"
argument_list|,
name|Host
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|artfd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Write the article.  In case of interrupts, retry the read but 	 * not the fwrite because we can't check that reliably and 	 * portably. */
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|artfd
argument_list|,
operator|(
name|POINTER
operator|)
name|data
argument_list|,
name|datasize
argument_list|)
operator|)
operator|>
literal|0
operator|||
name|errno
operator|==
name|EINTR
condition|)
if|if
condition|(
name|fwrite
argument_list|(
operator|(
name|POINTER
operator|)
name|data
argument_list|,
operator|(
name|SIZE_T
operator|)
literal|1
argument_list|,
operator|(
name|SIZE_T
operator|)
name|i
argument_list|,
name|F
argument_list|)
operator|!=
name|i
condition|)
break|break;
if|if
condition|(
name|ferror
argument_list|(
name|F
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"batcher %s cant write article %s\n"
argument_list|,
name|Host
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|artfd
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|artfd
argument_list|)
expr_stmt|;
comment|/* Update the counts. */
name|BytesInCB
operator|+=
name|BytesInArt
expr_stmt|;
name|BytesWritten
operator|+=
name|BytesInArt
expr_stmt|;
name|ArtsInCB
operator|++
expr_stmt|;
name|ArtsWritten
operator|++
expr_stmt|;
if|if
condition|(
name|GotInterrupt
condition|)
block|{
name|BATCHstatus
operator|=
name|BATCHclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
name|RequeueAndExit
argument_list|(
name|Cookie
argument_list|,
name|line
argument_list|,
name|BytesInArt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BATCHopen
condition|)
name|BATCHstatus
operator|=
name|BATCHclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
name|RequeueAndExit
argument_list|(
name|Cookie
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

end_unit

