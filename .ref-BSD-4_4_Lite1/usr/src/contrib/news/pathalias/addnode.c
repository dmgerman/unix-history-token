begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pathalias -- by steve bellovin, as told to peter honeyman */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)addnode.c	9.7 91/05/23"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"def.h"
end_include

begin_define
define|#
directive|define
name|EQ
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
value|(*(n)->n_name == *(s)&& strcmp((n)->n_name, (s)) == 0)
end_define

begin_comment
comment|/* exports */
end_comment

begin_decl_stmt
name|node
modifier|*
name|addnode
argument_list|()
decl_stmt|,
modifier|*
name|addprivate
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|alias
argument_list|()
decl_stmt|,
name|hashanalyze
argument_list|()
decl_stmt|,
name|fixprivate
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|node
modifier|*
modifier|*
name|Table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table ^ priority queue */
end_comment

begin_decl_stmt
name|long
name|Tabsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of Table */
end_comment

begin_comment
comment|/* imports */
end_comment

begin_function_decl
specifier|extern
name|link
modifier|*
name|addlink
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|node
modifier|*
name|newnode
argument_list|()
decl_stmt|,
modifier|*
modifier|*
name|newtable
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|strsave
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|Iflag
decl_stmt|,
name|Tflag
decl_stmt|,
name|Vflag
decl_stmt|,
name|InetFlag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|node
modifier|*
modifier|*
name|Table
decl_stmt|,
modifier|*
name|Home
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|Ncount
decl_stmt|,
name|Tabsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|Argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|atrace
argument_list|()
decl_stmt|,
name|die
argument_list|()
decl_stmt|,
name|freetable
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|strcmp
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* privates */
end_comment

begin_decl_stmt
name|STATIC
name|void
name|crcinit
argument_list|()
decl_stmt|,
name|rehash
argument_list|()
decl_stmt|,
name|lowercase
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|STATIC
name|long
name|fold
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|long
name|hash
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|node
modifier|*
name|isprivate
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|node
modifier|*
name|Private
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of private nodes in current input file */
end_comment

begin_comment
comment|/*  * these numbers are chosen because:  *	-> they are prime,  *	-> they are monotonic increasing,  *	-> each is a tad smaller than a multiple of 1024,  *	-> they form a fibonacci sequence (almost).  * the first point yields good hash functions, the second is used for the  * standard re-hashing implementation of open addressing, the third  * optimizes for quirks in some mallocs i have seen, and the fourth simply  * appeals to me.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|Primes
index|[]
init|=
block|{
literal|1021
block|,
literal|2039
block|,
literal|3067
block|,
literal|5113
block|,
literal|8179
block|,
literal|13309
block|,
literal|21499
block|,
literal|34807
block|,
literal|56311
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Tabindex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|Tab128
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tabsize * 128 */
end_comment

begin_function
name|node
modifier|*
name|addnode
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|long
name|i
decl_stmt|;
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
name|dot
decl_stmt|;
if|if
condition|(
name|Iflag
condition|)
name|lowercase
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* is it a private host? */
name|n
operator|=
name|isprivate
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
name|i
operator|=
name|hash
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Table
index|[
name|i
index|]
condition|)
return|return
name|Table
index|[
name|i
index|]
return|;
name|n
operator|=
name|newnode
argument_list|()
expr_stmt|;
name|n
operator|->
name|n_name
operator|=
name|strsave
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|Table
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|n_tloc
operator|=
name|i
expr_stmt|;
comment|/* essentially a back link to the table */
if|if
condition|(
name|InetFlag
operator|&&
name|Home
operator|!=
literal|0
operator|&&
operator|(
name|dot
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|isadomain
argument_list|(
name|dot
operator|+
literal|1
argument_list|)
condition|)
name|addlink
argument_list|(
name|Home
argument_list|,
name|n
argument_list|,
literal|100
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|DEFNET
argument_list|,
name|DEFDIR
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|void
name|alias
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|)
name|node
modifier|*
name|n1
decl_stmt|,
decl|*
name|n2
decl_stmt|;
end_function

begin_block
block|{
name|link
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|ISADOMAIN
argument_list|(
name|n1
argument_list|)
operator|&&
name|ISADOMAIN
argument_list|(
name|n2
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: domain alias %s = %s is illegal\n"
argument_list|,
name|Argv
index|[
literal|0
index|]
argument_list|,
name|n1
operator|->
name|n_name
argument_list|,
name|n2
operator|->
name|n_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|l
operator|=
name|addlink
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|,
operator|(
name|Cost
operator|)
literal|0
argument_list|,
name|DEFNET
argument_list|,
name|DEFDIR
argument_list|)
expr_stmt|;
name|l
operator|->
name|l_flag
operator||=
name|LALIAS
expr_stmt|;
name|l
operator|=
name|addlink
argument_list|(
name|n2
argument_list|,
name|n1
argument_list|,
operator|(
name|Cost
operator|)
literal|0
argument_list|,
name|DEFNET
argument_list|,
name|DEFDIR
argument_list|)
expr_stmt|;
name|l
operator|->
name|l_flag
operator||=
name|LALIAS
expr_stmt|;
if|if
condition|(
name|Tflag
condition|)
name|atrace
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * fold a string into a long int.  31 bit crc (from andrew appel).  * the crc table is computed at run time by crcinit() -- we could  * precompute, but it takes 1 clock tick on a 750.  *  * This fast table calculation works only if POLY is a prime polynomial  * in the field of integers modulo 2.  Since the coefficients of a  * 32-bit polynomail won't fit in a 32-bit word, the high-order bit is  * implicit.  IT MUST ALSO BE THE CASE that the coefficients of orders  * 31 down to 25 are zero.  Happily, we have candidates, from  * E. J.  Watson, "Primitive Polynomials (Mod 2)", Math. Comp. 16 (1962):  *	x^32 + x^7 + x^5 + x^3 + x^2 + x^1 + x^0  *	x^31 + x^3 + x^0  *  * We reverse the bits to get:  *	111101010000000000000000000000001 but drop the last 1  *         f   5   0   0   0   0   0   0  *	010010000000000000000000000000001 ditto, for 31-bit crc  *	   4   8   0   0   0   0   0   0  */
end_comment

begin_define
define|#
directive|define
name|POLY32
value|0xf5000000
end_define

begin_comment
comment|/* 32-bit polynomial */
end_comment

begin_define
define|#
directive|define
name|POLY31
value|0x48000000
end_define

begin_comment
comment|/* 31-bit polynomial */
end_comment

begin_define
define|#
directive|define
name|POLY
value|POLY31
end_define

begin_comment
comment|/* use 31-bit to avoid sign problems */
end_comment

begin_decl_stmt
specifier|static
name|long
name|CrcTable
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|STATIC
name|void
name|crcinit
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|long
name|sum
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|7
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|i
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
name|sum
operator|^=
name|POLY
operator|>>
name|j
expr_stmt|;
name|CrcTable
index|[
name|i
index|]
operator|=
name|sum
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|long
name|fold
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|long
name|sum
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|0
condition|)
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|7
operator|)
operator|^
name|CrcTable
index|[
operator|(
name|sum
operator|^
name|c
operator|)
operator|&
literal|0x7f
index|]
expr_stmt|;
return|return
name|sum
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HASH1
parameter_list|(
name|n
parameter_list|)
value|((n) % Tabsize);
end_define

begin_define
define|#
directive|define
name|HASH2
parameter_list|(
name|n
parameter_list|)
value|(Tabsize - 2 - ((n) % (Tabsize-2)))
end_define

begin_comment
comment|/* sedgewick */
end_comment

begin_comment
comment|/*  * when alpha is 0.79, there should be 2 probes per access (gonnet).  * use long constant to force promotion.  Tab128 biases HIGHWATER by  * 128/100 for reduction in strength in isfull().  */
end_comment

begin_define
define|#
directive|define
name|HIGHWATER
value|79L
end_define

begin_define
define|#
directive|define
name|isfull
parameter_list|(
name|n
parameter_list|)
value|((n) * 128>= Tab128)
end_define

begin_function
name|STATIC
name|long
name|hash
parameter_list|(
name|name
parameter_list|,
name|unique
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|unique
decl_stmt|;
block|{
specifier|register
name|long
name|probe
decl_stmt|;
specifier|register
name|long
name|hash2
decl_stmt|;
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|isfull
argument_list|(
name|Ncount
argument_list|)
condition|)
block|{
if|if
condition|(
name|Tabsize
operator|==
literal|0
condition|)
block|{
comment|/* first time */
name|crcinit
argument_list|()
expr_stmt|;
name|Tabindex
operator|=
literal|0
expr_stmt|;
name|Tabsize
operator|=
name|Primes
index|[
literal|0
index|]
expr_stmt|;
name|Table
operator|=
name|newtable
argument_list|(
name|Tabsize
argument_list|)
expr_stmt|;
name|Tab128
operator|=
operator|(
name|HIGHWATER
operator|*
name|Tabsize
operator|*
literal|128L
operator|)
operator|/
literal|100L
expr_stmt|;
block|}
else|else
name|rehash
argument_list|()
expr_stmt|;
comment|/* more, more! */
block|}
name|probe
operator|=
name|fold
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|hash2
operator|=
name|HASH2
argument_list|(
name|probe
argument_list|)
expr_stmt|;
name|probe
operator|=
name|HASH1
argument_list|(
name|probe
argument_list|)
expr_stmt|;
comment|/* 	 * probe the hash table. 	 * if unique is set, we require a fresh slot. 	 * otherwise, use double hashing to find either 	 *  (1) an empty slot, or 	 *  (2) a non-private copy of this host name 	 * 	 * this is an "inner loop." 	 */
while|while
condition|(
operator|(
name|n
operator|=
name|Table
index|[
name|probe
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|n
argument_list|,
name|name
argument_list|)
operator|&&
operator|!
operator|(
name|n
operator|->
name|n_flag
operator|&
name|ISPRIVATE
operator|)
operator|&&
operator|!
name|unique
condition|)
return|return
name|probe
return|;
comment|/* this is it! */
name|probe
operator|-=
name|hash2
expr_stmt|;
comment|/* double hashing */
if|if
condition|(
name|probe
operator|<
literal|0
condition|)
name|probe
operator|+=
name|Tabsize
expr_stmt|;
block|}
return|return
name|probe
return|;
comment|/* brand new */
block|}
end_function

begin_function
name|STATIC
name|void
name|rehash
parameter_list|()
block|{
specifier|register
name|node
modifier|*
modifier|*
name|otable
decl_stmt|,
modifier|*
modifier|*
name|optr
decl_stmt|;
specifier|register
name|long
name|probe
decl_stmt|;
name|long
name|osize
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|hashanalyze
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|optr
operator|=
name|Table
operator|+
name|Tabsize
operator|-
literal|1
expr_stmt|;
comment|/* ptr to last */
name|otable
operator|=
name|Table
expr_stmt|;
name|osize
operator|=
name|Tabsize
expr_stmt|;
name|Tabsize
operator|=
name|Primes
index|[
operator|++
name|Tabindex
index|]
expr_stmt|;
if|if
condition|(
name|Tabsize
operator|==
literal|0
condition|)
name|die
argument_list|(
literal|"too many hosts"
argument_list|)
expr_stmt|;
comment|/* need more prime numbers */
name|vprintf
argument_list|(
name|stderr
argument_list|,
literal|"rehash into %d\n"
argument_list|,
name|Tabsize
argument_list|)
expr_stmt|;
name|Table
operator|=
name|newtable
argument_list|(
name|Tabsize
argument_list|)
expr_stmt|;
name|Tab128
operator|=
operator|(
name|HIGHWATER
operator|*
name|Tabsize
operator|*
literal|128L
operator|)
operator|/
literal|100L
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|optr
operator|==
literal|0
condition|)
continue|continue;
comment|/* empty slot in old table */
name|probe
operator|=
name|hash
argument_list|(
operator|(
operator|*
name|optr
operator|)
operator|->
name|n_name
argument_list|,
operator|(
operator|(
operator|*
name|optr
operator|)
operator|->
name|n_flag
operator|&
name|ISPRIVATE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Table
index|[
name|probe
index|]
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"rehash error"
argument_list|)
expr_stmt|;
name|Table
index|[
name|probe
index|]
operator|=
operator|*
name|optr
expr_stmt|;
operator|(
operator|*
name|optr
operator|)
operator|->
name|n_tloc
operator|=
name|probe
expr_stmt|;
block|}
do|while
condition|(
name|optr
operator|--
operator|>
name|otable
condition|)
do|;
name|freetable
argument_list|(
name|otable
argument_list|,
name|osize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hashanalyze
parameter_list|()
if|#
directive|if
literal|0
function|{ 	long	probe, hash2; 	int	count, i, collision[8]; 	int	longest = 0, total = 0, slots = 0, longprobe = 0; 	int	nslots = sizeof(collision)/sizeof(collision[0]);  	if (!Vflag) 		return;  	strclear((char *) collision, sizeof(collision)); 	for (i = 0; i< Tabsize; i++) { 		if (Table[i] == 0) 			continue;
comment|/* private hosts too hard to account for ... */
function|if (Table[i]->n_flag& ISPRIVATE) 			continue; 		count = 1; 		probe = fold(Table[i]->n_name);
comment|/* don't change the order of the next two lines */
function|hash2 = HASH2(probe); 		probe = HASH1(probe);
comment|/* thank you! */
function|while (Table[probe] != 0&& strcmp(Table[probe]->n_name, Table[i]->n_name) != 0) { 			count++; 			probe -= hash2; 			if (probe< 0) 				probe += Tabsize; 		} 		if (Table[probe] == 0) 			die("impossible hash error"); 		 		total += count; 		slots++; 		if (count> longest) { 			longest = count; 			longprobe = i; 		} 		if (count>= nslots) 			count = 0; 		collision[count]++; 	} 	for (i = 1; i< nslots; i++) 		if (collision[i]) 			fprintf(stderr, "%d chains: %d (%ld%%)\n", 				i, collision[i], (collision[i] * 100L)/ slots); 		if (collision[0]) 			fprintf(stderr, "> %d chains: %d (%ld%%)\n", 				nslots - 1, collision[0], 				(collision[0] * 100L)/ slots); 	fprintf(stderr, "%2.2f probes per access, longest chain: %d, %s\n", 		(double) total / slots, longest, Table[longprobe]->n_name); 	if (Vflag< 2) 		return; 	probe = fold(Table[longprobe]->n_name); 	hash2 = HASH2(probe); 	probe = HASH1(probe); 	while (Table[probe] != 0&& strcmp(Table[probe]->n_name, Table[longprobe]->n_name) != 0) { 		fprintf(stderr, "%5d %s\n", probe, Table[probe]->n_name); 		probe -= hash2; 		if (probe< 0) 			probe += Tabsize; 	} 	fprintf(stderr, "%5d %s\n", probe, Table[probe]->n_name); 	 }
else|#
directive|else
block|{
comment|/* the hash algorithms are perfect -- leave them alone */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* convert to lower case in place */
end_comment

begin_function
name|STATIC
name|void
name|lowercase
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
do|do
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|-=
literal|'A'
operator|-
literal|'a'
expr_stmt|;
comment|/* ASCII */
block|}
do|while
condition|(
operator|*
name|s
operator|++
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * this might need change if privates catch on  */
end_comment

begin_function
name|STATIC
name|node
modifier|*
name|isprivate
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|Private
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|=
name|n
operator|->
name|n_private
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|n
operator|->
name|n_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|n
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  Add a private node so private that nobody can find it.  */
end_comment

begin_function
name|node
modifier|*
name|addhidden
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Iflag
condition|)
name|lowercase
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|n
operator|=
name|newnode
argument_list|()
expr_stmt|;
name|n
operator|->
name|n_name
operator|=
name|strsave
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_flag
operator|=
name|ISPRIVATE
expr_stmt|;
name|i
operator|=
name|hash
argument_list|(
name|n
operator|->
name|n_name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Table
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"impossible hidden node error"
argument_list|)
expr_stmt|;
name|Table
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|n_tloc
operator|=
name|i
expr_stmt|;
name|n
operator|->
name|n_private
operator|=
literal|0
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|void
name|fixprivate
parameter_list|()
block|{
specifier|register
name|node
modifier|*
name|n
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
for|for
control|(
name|n
operator|=
name|Private
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|=
name|next
control|)
block|{
name|n
operator|->
name|n_flag
operator||=
name|ISPRIVATE
expr_stmt|;
comment|/* overkill, but safe */
name|i
operator|=
name|hash
argument_list|(
name|n
operator|->
name|n_name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Table
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"impossible private node error"
argument_list|)
expr_stmt|;
name|Table
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|n_tloc
operator|=
name|i
expr_stmt|;
comment|/* essentially a back link to the table */
name|next
operator|=
name|n
operator|->
name|n_private
expr_stmt|;
name|n
operator|->
name|n_private
operator|=
literal|0
expr_stmt|;
comment|/* clear for later use */
block|}
name|Private
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|node
modifier|*
name|addprivate
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|Iflag
condition|)
name|lowercase
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|isprivate
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|n
return|;
name|n
operator|=
name|newnode
argument_list|()
expr_stmt|;
name|n
operator|->
name|n_name
operator|=
name|strsave
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_private
operator|=
name|Private
expr_stmt|;
name|Private
operator|=
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

end_unit

