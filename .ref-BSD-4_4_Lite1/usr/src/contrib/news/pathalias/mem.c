begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pathalias -- by steve bellovin, as told to peter honeyman */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)mem.c	9.6 92/08/25"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"def.h"
end_include

begin_comment
comment|/* exports */
end_comment

begin_decl_stmt
name|long
name|Ncount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|freelink
argument_list|()
decl_stmt|,
name|wasted
argument_list|()
decl_stmt|,
name|freetable
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|long
name|allocation
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* imports */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Netchars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Vflag
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|die
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|strlen
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* privates */
end_comment

begin_function_decl
name|STATIC
name|void
name|nomem
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|link
modifier|*
name|Lcache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|Memwaste
decl_stmt|;
end_decl_stmt

begin_function
name|link
modifier|*
name|newlink
parameter_list|()
block|{
specifier|register
name|link
modifier|*
name|rval
decl_stmt|;
if|if
condition|(
name|Lcache
condition|)
block|{
name|rval
operator|=
name|Lcache
expr_stmt|;
name|Lcache
operator|=
name|Lcache
operator|->
name|l_next
expr_stmt|;
name|strclear
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rval
argument_list|,
sizeof|sizeof
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rval
operator|=
operator|(
name|link
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|link
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* caution: this destroys the contents of l_next */
end_comment

begin_function
name|void
name|freelink
parameter_list|(
name|l
parameter_list|)
name|link
modifier|*
name|l
decl_stmt|;
block|{
name|l
operator|->
name|l_next
operator|=
name|Lcache
expr_stmt|;
name|Lcache
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_function
name|node
modifier|*
name|newnode
parameter_list|()
block|{
specifier|register
name|node
modifier|*
name|rval
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
operator|(
name|node
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|node
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|Ncount
operator|++
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
name|dom
modifier|*
name|newdom
parameter_list|()
block|{
specifier|register
name|dom
modifier|*
name|rval
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
operator|(
name|dom
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|dom
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|strsave
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|strclear
end_ifndef

begin_function
name|void
name|strclear
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
specifier|register
name|long
name|len
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
operator|*
name|str
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*strclear*/
end_comment

begin_function
name|node
modifier|*
modifier|*
name|newtable
parameter_list|(
name|size
parameter_list|)
name|long
name|size
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
modifier|*
name|rval
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
operator|(
name|node
operator|*
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|size
operator|*
sizeof|sizeof
argument_list|(
name|node
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
name|void
name|freetable
parameter_list|(
name|t
parameter_list|,
name|size
parameter_list|)
name|node
modifier|*
modifier|*
name|t
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MYMALLOC
name|STATIC
name|void
name|addtoheap
parameter_list|()
function_decl|;
name|addtoheap
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|node
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|STATIC
name|void
name|nomem
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DEBUG
specifier|static
name|char
name|epitaph
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|epitaph
argument_list|,
literal|"out of memory (%ldk allocated)"
argument_list|,
name|allocation
argument_list|()
argument_list|)
expr_stmt|;
name|die
argument_list|(
name|epitaph
argument_list|)
expr_stmt|;
else|#
directive|else
name|die
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* data space allocation -- main sets `dataspace' very early */
end_comment

begin_function
name|long
name|allocation
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DEBUG
specifier|static
name|char
modifier|*
name|dataspace
decl_stmt|;
name|long
name|rval
decl_stmt|;
if|if
condition|(
name|dataspace
operator|==
literal|0
condition|)
block|{
comment|/* first time */
name|dataspace
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rval
operator|=
operator|(
name|sbrk
argument_list|(
literal|0
argument_list|)
operator|-
name|dataspace
operator|)
operator|/
literal|1024
expr_stmt|;
if|if
condition|(
name|rval
operator|<
literal|0
condition|)
comment|/* funny architecture? */
name|rval
operator|=
operator|-
name|rval
expr_stmt|;
return|return
name|rval
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* how much memory has been wasted? */
end_comment

begin_function
name|void
name|wasted
parameter_list|()
block|{
if|if
condition|(
name|Memwaste
operator|==
literal|0
condition|)
return|return;
name|vprintf
argument_list|(
name|stderr
argument_list|,
literal|"memory allocator wasted %ld bytes\n"
argument_list|,
name|Memwaste
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MYMALLOC
end_ifdef

begin_comment
comment|/* use c library malloc/calloc here, and here only */
end_comment

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_undef
undef|#
directive|undef
name|calloc
end_undef

begin_comment
comment|/* imports */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|calloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* private */
end_comment

begin_function_decl
name|STATIC
name|int
name|align
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* allocate in MBUFSIZ chunks.  4k works ok (less 16 for malloc quirks). */
end_comment

begin_define
define|#
directive|define
name|MBUFSIZ
value|(4 * 1024 - 16)
end_define

begin_comment
comment|/*   * mess with ALIGN at your peril.  longword (== 0 mod 4)  * alignment seems to work everywhere.  */
end_comment

begin_define
define|#
directive|define
name|ALIGN
value|2
end_define

begin_typedef
typedef|typedef
name|struct
name|heap
name|heap
typedef|;
end_typedef

begin_struct
struct|struct
name|heap
block|{
name|heap
modifier|*
name|h_next
decl_stmt|;
name|long
name|h_size
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|heap
modifier|*
name|Mheap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not to be confused with a priority queue */
end_comment

begin_function
name|STATIC
name|void
name|addtoheap
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|int
name|adjustment
decl_stmt|;
name|heap
modifier|*
name|pheap
decl_stmt|;
comment|/* p is aligned, but it doesn't hurt to check */
name|adjustment
operator|=
name|align
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|adjustment
expr_stmt|;
name|size
operator|-=
name|adjustment
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1024
condition|)
return|return;
comment|/* can't happen */
name|pheap
operator|=
operator|(
name|heap
operator|*
operator|)
name|p
expr_stmt|;
comment|/* pheap is shorthand */
name|pheap
operator|->
name|h_next
operator|=
name|Mheap
expr_stmt|;
name|pheap
operator|->
name|h_size
operator|=
name|size
expr_stmt|;
name|Mheap
operator|=
name|pheap
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * buffered malloc()  *	returns space initialized to 0.  calloc isn't used, since  *	strclear can be faster.  *  * free is ignored, except for very large objects,  * which are returned to the heap with addtoheap().   */
end_comment

begin_function
name|char
modifier|*
name|mymalloc
parameter_list|(
name|n
parameter_list|)
specifier|register
name|unsigned
name|int
name|n
decl_stmt|;
block|{
specifier|static
name|unsigned
name|int
name|size
decl_stmt|;
comment|/* how much do we have on hand? */
specifier|static
name|char
modifier|*
name|mstash
decl_stmt|;
comment|/* where is it? */
specifier|register
name|char
modifier|*
name|rval
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|1024
condition|)
block|{
comment|/* for hash table */
name|rval
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* aligned */
if|if
condition|(
name|rval
condition|)
name|strclear
argument_list|(
name|rval
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
name|n
operator|+=
name|align
argument_list|(
operator|(
name|char
operator|*
operator|)
name|n
argument_list|)
expr_stmt|;
comment|/* keep everything aligned */
if|if
condition|(
name|n
operator|>
name|size
condition|)
block|{
name|Memwaste
operator|+=
name|size
expr_stmt|;
comment|/* toss the fragment */
comment|/* look in the heap */
if|if
condition|(
name|Mheap
condition|)
block|{
name|mstash
operator|=
operator|(
name|char
operator|*
operator|)
name|Mheap
expr_stmt|;
comment|/* aligned */
name|size
operator|=
name|Mheap
operator|->
name|h_size
expr_stmt|;
name|Mheap
operator|=
name|Mheap
operator|->
name|h_next
expr_stmt|;
block|}
else|else
block|{
name|mstash
operator|=
name|malloc
argument_list|(
name|MBUFSIZ
argument_list|)
expr_stmt|;
comment|/* aligned */
if|if
condition|(
name|mstash
operator|==
literal|0
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|size
operator|=
name|MBUFSIZ
expr_stmt|;
block|}
name|strclear
argument_list|(
name|mstash
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* what if size> 2^16? */
block|}
name|rval
operator|=
name|mstash
expr_stmt|;
name|mstash
operator|+=
name|n
expr_stmt|;
name|size
operator|-=
name|n
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * what's the (mis-)alignment of n?  return the complement of  * n mod 2^ALIGN  */
end_comment

begin_function
name|STATIC
name|int
name|align
parameter_list|(
name|n
parameter_list|)
name|char
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|abits
decl_stmt|;
comment|/* misalignment bits in n */
name|abits
operator|=
operator|(
name|int
operator|)
name|n
operator|&
operator|~
operator|(
literal|0xff
operator|<<
name|ALIGN
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|abits
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
literal|1
operator|<<
name|ALIGN
operator|)
operator|-
name|abits
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*MYMALLOC*/
end_comment

end_unit

