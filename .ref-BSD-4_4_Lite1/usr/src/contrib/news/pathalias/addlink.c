begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pathalias -- by steve bellovin, as told to peter honeyman */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)addlink.c	9.7 88/06/10"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_include
include|#
directive|include
file|"def.h"
end_include

begin_comment
comment|/* exports */
end_comment

begin_function_decl
specifier|extern
name|link
modifier|*
name|addlink
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|void
name|deadlink
argument_list|()
decl_stmt|,
name|atrace
argument_list|()
decl_stmt|,
name|freelink
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tracelink
argument_list|()
decl_stmt|,
name|maptrace
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Netchars
init|=
literal|"!:@%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sparse, but sufficient */
end_comment

begin_decl_stmt
name|long
name|Lcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many edges? */
end_comment

begin_comment
comment|/* imports */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|Tflag
decl_stmt|,
name|Dflag
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|link
modifier|*
name|newlink
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|node
modifier|*
name|addnode
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|void
name|yyerror
argument_list|()
decl_stmt|,
name|die
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|strcmp
argument_list|()
decl_stmt|,
name|strlen
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* privates */
end_comment

begin_decl_stmt
name|STATIC
name|void
name|netbits
argument_list|()
decl_stmt|,
name|ltrace
argument_list|()
decl_stmt|,
name|ltrprint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|link
modifier|*
name|Trace
index|[
name|NTRACE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Tracecount
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EQ
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|)
value|(strcmp((n1)->n_name, (n2)->n_name) == 0)
end_define

begin_define
define|#
directive|define
name|LTRACE
value|if (Tflag) ltrace
end_define

begin_function
name|link
modifier|*
name|addlink
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|cost
parameter_list|,
name|netchar
parameter_list|,
name|netdir
parameter_list|)
name|node
modifier|*
name|from
decl_stmt|;
specifier|register
name|node
modifier|*
name|to
decl_stmt|;
name|Cost
name|cost
decl_stmt|;
name|char
name|netchar
decl_stmt|,
name|netdir
decl_stmt|;
block|{
specifier|register
name|link
modifier|*
name|l
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
name|LTRACE
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|cost
argument_list|,
name|netchar
argument_list|,
name|netdir
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * maintain uniqueness for dead links (only). 	 */
for|for
control|(
name|l
operator|=
name|from
operator|->
name|n_link
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|l_next
control|)
block|{
if|if
condition|(
operator|!
name|DEADLINK
argument_list|(
name|l
argument_list|)
condition|)
break|break;
if|if
condition|(
name|to
operator|==
name|l
operator|->
name|l_to
condition|)
block|{
comment|/* what the hell, use cheaper dead cost */
if|if
condition|(
name|cost
operator|<
name|l
operator|->
name|l_cost
condition|)
block|{
name|l
operator|->
name|l_cost
operator|=
name|cost
expr_stmt|;
name|netbits
argument_list|(
name|l
argument_list|,
name|netchar
argument_list|,
name|netdir
argument_list|)
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
name|prev
operator|=
name|l
expr_stmt|;
block|}
comment|/* allocate and link in the new link struct */
name|l
operator|=
name|newlink
argument_list|()
expr_stmt|;
if|if
condition|(
name|cost
operator|!=
name|INF
condition|)
comment|/* ignore back links */
name|Lcount
operator|++
expr_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|l
operator|->
name|l_next
operator|=
name|prev
operator|->
name|l_next
expr_stmt|;
name|prev
operator|->
name|l_next
operator|=
name|l
expr_stmt|;
block|}
else|else
block|{
name|l
operator|->
name|l_next
operator|=
name|from
operator|->
name|n_link
expr_stmt|;
name|from
operator|->
name|n_link
operator|=
name|l
expr_stmt|;
block|}
name|l
operator|->
name|l_to
operator|=
name|to
expr_stmt|;
comment|/* add penalty */
if|if
condition|(
operator|(
name|l
operator|->
name|l_cost
operator|=
name|cost
operator|+
name|from
operator|->
name|n_cost
operator|)
operator|<
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|l
operator|->
name|l_flag
operator||=
name|LDEAD
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"link to %s ignored with negative cost"
argument_list|,
name|to
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|netchar
operator|==
literal|0
condition|)
block|{
name|netchar
operator|=
name|DEFNET
expr_stmt|;
name|netdir
operator|=
name|DEFDIR
expr_stmt|;
block|}
name|netbits
argument_list|(
name|l
argument_list|,
name|netchar
argument_list|,
name|netdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|Dflag
operator|&&
name|ISADOMAIN
argument_list|(
name|from
argument_list|)
condition|)
name|l
operator|->
name|l_flag
operator||=
name|LTERMINAL
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_function
name|void
name|deadlink
parameter_list|(
name|nleft
parameter_list|,
name|nright
parameter_list|)
name|node
modifier|*
name|nleft
decl_stmt|,
decl|*
name|nright
decl_stmt|;
end_function

begin_block
block|{
name|link
modifier|*
name|l
decl_stmt|,
modifier|*
name|lhold
init|=
literal|0
decl_stmt|,
modifier|*
name|lprev
decl_stmt|,
modifier|*
name|lnext
decl_stmt|;
comment|/* DEAD host */
if|if
condition|(
name|nright
operator|==
literal|0
condition|)
block|{
name|nleft
operator|->
name|n_flag
operator||=
name|NDEAD
expr_stmt|;
comment|/* DEAD host */
return|return;
block|}
comment|/* DEAD link */
comment|/* grab<nleft, nright> instances at head of nleft adjacency list */
while|while
condition|(
operator|(
name|l
operator|=
name|nleft
operator|->
name|n_link
operator|)
operator|!=
literal|0
operator|&&
name|l
operator|->
name|l_to
operator|==
name|nright
condition|)
block|{
name|nleft
operator|->
name|n_link
operator|=
name|l
operator|->
name|l_next
expr_stmt|;
comment|/* disconnect */
name|l
operator|->
name|l_next
operator|=
name|lhold
expr_stmt|;
comment|/* terminate */
name|lhold
operator|=
name|l
expr_stmt|;
comment|/* add to lhold */
block|}
comment|/* move remaining<nleft, nright> instances */
for|for
control|(
name|lprev
operator|=
name|nleft
operator|->
name|n_link
init|;
name|lprev
operator|&&
name|lprev
operator|->
name|l_next
condition|;
name|lprev
operator|=
name|lprev
operator|->
name|l_next
control|)
block|{
if|if
condition|(
name|lprev
operator|->
name|l_next
operator|->
name|l_to
operator|==
name|nright
condition|)
block|{
name|l
operator|=
name|lprev
operator|->
name|l_next
expr_stmt|;
name|lprev
operator|->
name|l_next
operator|=
name|l
operator|->
name|l_next
expr_stmt|;
comment|/* disconnect */
name|l
operator|->
name|l_next
operator|=
name|lhold
expr_stmt|;
comment|/* terminate */
name|lhold
operator|=
name|l
expr_stmt|;
block|}
block|}
comment|/* check for emptiness */
if|if
condition|(
name|lhold
operator|==
literal|0
condition|)
block|{
name|addlink
argument_list|(
name|nleft
argument_list|,
name|nright
argument_list|,
name|INF
operator|/
literal|2
argument_list|,
name|DEFNET
argument_list|,
name|DEFDIR
argument_list|)
operator|->
name|l_flag
operator||=
name|LDEAD
expr_stmt|;
return|return;
block|}
comment|/* reinsert deleted edges as DEAD links */
for|for
control|(
name|l
operator|=
name|lhold
init|;
name|l
condition|;
name|l
operator|=
name|lnext
control|)
block|{
name|lnext
operator|=
name|l
operator|->
name|l_next
expr_stmt|;
name|addlink
argument_list|(
name|nleft
argument_list|,
name|nright
argument_list|,
name|l
operator|->
name|l_cost
argument_list|,
name|NETCHAR
argument_list|(
name|l
argument_list|)
argument_list|,
name|NETDIR
argument_list|(
name|l
argument_list|)
argument_list|)
operator|->
name|l_flag
operator||=
name|LDEAD
expr_stmt|;
name|freelink
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|STATIC
name|void
name|netbits
parameter_list|(
name|l
parameter_list|,
name|netchar
parameter_list|,
name|netdir
parameter_list|)
specifier|register
name|link
modifier|*
name|l
decl_stmt|;
name|char
name|netchar
decl_stmt|,
name|netdir
decl_stmt|;
block|{
name|l
operator|->
name|l_flag
operator|&=
operator|~
name|LDIR
expr_stmt|;
name|l
operator|->
name|l_flag
operator||=
name|netdir
expr_stmt|;
name|l
operator|->
name|l_netop
operator|=
name|netchar
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tracelink
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|bang
decl_stmt|;
name|link
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|Tracecount
operator|>=
name|NTRACE
condition|)
return|return
operator|-
literal|1
return|;
name|l
operator|=
name|newlink
argument_list|()
expr_stmt|;
name|bang
operator|=
name|index
argument_list|(
name|arg
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|bang
condition|)
block|{
operator|*
name|bang
operator|=
literal|0
expr_stmt|;
name|l
operator|->
name|l_to
operator|=
name|addnode
argument_list|(
name|bang
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|l
operator|->
name|l_to
operator|=
literal|0
expr_stmt|;
name|l
operator|->
name|l_from
operator|=
name|addnode
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|Trace
index|[
name|Tracecount
operator|++
index|]
operator|=
name|l
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * the obvious choice for testing equality is to compare struct  * addresses, but that misses private nodes, so we use strcmp().  */
end_comment

begin_function
name|STATIC
name|void
name|ltrace
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|cost
parameter_list|,
name|netchar
parameter_list|,
name|netdir
parameter_list|,
name|message
parameter_list|)
name|node
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
name|Cost
name|cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|netchar
decl_stmt|,
name|netdir
decl_stmt|,
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|link
modifier|*
name|l
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Tracecount
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
name|Trace
index|[
name|i
index|]
expr_stmt|;
comment|/* overkill, but you asked for it! */
if|if
condition|(
name|l
operator|->
name|l_to
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|from
argument_list|,
name|l
operator|->
name|l_from
argument_list|)
operator|||
name|EQ
argument_list|(
name|to
argument_list|,
name|l
operator|->
name|l_from
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|from
argument_list|,
name|l
operator|->
name|l_from
argument_list|)
operator|&&
name|EQ
argument_list|(
name|to
argument_list|,
name|l
operator|->
name|l_to
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|from
argument_list|,
name|l
operator|->
name|l_to
argument_list|)
operator|&&
name|EQ
argument_list|(
name|to
argument_list|,
name|l
operator|->
name|l_from
argument_list|)
condition|)
break|break;
comment|/* potential dead backlink */
block|}
if|if
condition|(
name|i
operator|<
name|Tracecount
condition|)
name|ltrprint
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|cost
argument_list|,
name|netchar
argument_list|,
name|netdir
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* print a trace item */
end_comment

begin_function
name|STATIC
name|void
name|ltrprint
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|cost
parameter_list|,
name|netchar
parameter_list|,
name|netdir
parameter_list|,
name|message
parameter_list|)
name|node
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
name|Cost
name|cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|netchar
decl_stmt|,
name|netdir
decl_stmt|,
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|bptr
init|=
name|buf
decl_stmt|;
name|strcpy
argument_list|(
name|bptr
argument_list|,
name|from
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|bptr
operator|+=
name|strlen
argument_list|(
name|bptr
argument_list|)
expr_stmt|;
operator|*
name|bptr
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|netdir
operator|==
name|LRIGHT
condition|)
comment|/* @% */
operator|*
name|bptr
operator|++
operator|=
name|netchar
expr_stmt|;
name|strcpy
argument_list|(
name|bptr
argument_list|,
name|to
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|bptr
operator|+=
name|strlen
argument_list|(
name|bptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|netdir
operator|==
name|LLEFT
condition|)
comment|/* !: */
operator|*
name|bptr
operator|++
operator|=
name|netchar
expr_stmt|;
name|sprintf
argument_list|(
name|bptr
argument_list|,
literal|"(%ld) %s"
argument_list|,
name|cost
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|atrace
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|)
name|node
modifier|*
name|n1
decl_stmt|,
decl|*
name|n2
decl_stmt|;
end_function

begin_block
block|{
name|link
modifier|*
name|l
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Tracecount
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
name|Trace
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|l_to
operator|==
literal|0
operator|&&
operator|(
operator|(
name|node
operator|*
operator|)
name|l
operator|->
name|l_from
operator|==
name|n1
operator|||
operator|(
name|node
operator|*
operator|)
name|l
operator|->
name|l_from
operator|==
name|n2
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s = %s"
argument_list|,
name|n1
operator|->
name|n_name
argument_list|,
name|n2
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_function
name|int
name|maptrace
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|register
name|node
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|link
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Tracecount
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
name|Trace
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|l_to
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|from
argument_list|,
name|l
operator|->
name|l_from
argument_list|)
operator|||
name|EQ
argument_list|(
name|to
argument_list|,
name|l
operator|->
name|l_from
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|from
argument_list|,
name|l
operator|->
name|l_from
argument_list|)
operator|&&
name|EQ
argument_list|(
name|to
argument_list|,
name|l
operator|->
name|l_to
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_function
name|void
name|deletelink
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|node
modifier|*
name|from
decl_stmt|;
name|node
modifier|*
name|to
decl_stmt|;
block|{
specifier|register
name|link
modifier|*
name|l
decl_stmt|,
modifier|*
name|lnext
decl_stmt|;
name|l
operator|=
name|from
operator|->
name|n_link
expr_stmt|;
comment|/* delete all neighbors of from */
if|if
condition|(
name|to
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|l
condition|)
block|{
name|LTRACE
argument_list|(
name|from
argument_list|,
name|l
operator|->
name|l_to
argument_list|,
name|l
operator|->
name|l_cost
argument_list|,
name|NETCHAR
argument_list|(
name|l
argument_list|)
argument_list|,
name|NETDIR
argument_list|(
name|l
argument_list|)
argument_list|,
literal|"DELETED"
argument_list|)
expr_stmt|;
name|lnext
operator|=
name|l
operator|->
name|l_next
expr_stmt|;
name|freelink
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|lnext
expr_stmt|;
block|}
name|from
operator|->
name|n_link
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* delete from head of list */
while|while
condition|(
name|l
operator|&&
name|EQ
argument_list|(
name|to
argument_list|,
name|l
operator|->
name|l_to
argument_list|)
condition|)
block|{
name|LTRACE
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|l
operator|->
name|l_cost
argument_list|,
name|NETCHAR
argument_list|(
name|l
argument_list|)
argument_list|,
name|NETDIR
argument_list|(
name|l
argument_list|)
argument_list|,
literal|"DELETED"
argument_list|)
expr_stmt|;
name|lnext
operator|=
name|l
operator|->
name|l_next
expr_stmt|;
name|freelink
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|from
operator|->
name|n_link
operator|=
name|lnext
expr_stmt|;
block|}
comment|/* delete from interior of list */
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|lnext
operator|=
name|l
operator|->
name|l_next
init|;
name|lnext
condition|;
name|lnext
operator|=
name|l
operator|->
name|l_next
control|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|to
argument_list|,
name|lnext
operator|->
name|l_to
argument_list|)
condition|)
block|{
name|LTRACE
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|l
operator|->
name|l_cost
argument_list|,
name|NETCHAR
argument_list|(
name|l
argument_list|)
argument_list|,
name|NETDIR
argument_list|(
name|l
argument_list|)
argument_list|,
literal|"DELETED"
argument_list|)
expr_stmt|;
name|l
operator|->
name|l_next
operator|=
name|lnext
operator|->
name|l_next
expr_stmt|;
name|freelink
argument_list|(
name|lnext
argument_list|)
expr_stmt|;
comment|/* continue processing this link */
block|}
else|else
name|l
operator|=
name|lnext
expr_stmt|;
comment|/* next link */
block|}
block|}
end_function

end_unit

