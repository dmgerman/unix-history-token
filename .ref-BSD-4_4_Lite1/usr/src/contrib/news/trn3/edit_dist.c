begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_comment
comment|/* Declare MEM_SIZE */
end_comment

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_comment
comment|/* Declare safemalloc() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EDIT_DISTANCE
end_ifdef

begin_comment
comment|/* edit_dist -- returns the minimum edit distance between two strings  	Program by:  Mark Maimone   CMU Computer Science   13 Nov 89 	Last Modified:  28 Jan 90     If the input strings have length n and m, the algorithm runs in time    O(nm) and space O(min(m,n)).  HISTORY    13 Nov 89 (mwm) Created edit_dist() and set_costs().     28 Jan 90 (mwm) Added view_costs().  Should verify that THRESHOLD    computations will work even when THRESHOLD is not a multiple of    sizeof(int).     17 May 93 (mwm) Improved performance when used with trn's newsgroup    processing; assume all costs are 1, and you can terminate when a    threshold is exceeded. */
end_comment

begin_define
define|#
directive|define
name|TRN_SPEEDUP
end_define

begin_comment
comment|/* Use a less-general version of the 				   routine, one that's better for trn. 				   All change costs are 1, and it's okay 				   to terminate if the edit distance is 				   known to exceed MIN_DIST */
end_comment

begin_define
define|#
directive|define
name|THRESHOLD
value|4000
end_define

begin_comment
comment|/* worry about allocating more memory only 				   when this # of bytes is exceeded */
end_comment

begin_define
define|#
directive|define
name|STRLENTHRESHOLD
value|((int) ((THRESHOLD / sizeof (int) - 3) / 2))
end_define

begin_define
define|#
directive|define
name|SAFE_ASSIGN
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) != NULL) ? (*(x) = (y)) : (y))
end_define

begin_define
define|#
directive|define
name|swap_int
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(_iswap = (x), (x) = (y), (y) = _iswap)
end_define

begin_define
define|#
directive|define
name|swap_char
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(_cswap = (x), (x) = (y), (y) = _cswap)
end_define

begin_define
define|#
directive|define
name|min3
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(_mx = (x), _my = (y), _mz = (z), (_mx< _my ? (_mx< _mz ? _mx : _mz) : (_mz< _my) ? _mz : _my))
end_define

begin_define
define|#
directive|define
name|min2
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(_mx = (x), _my = (y), (_mx< _my ? _mx : _my))
end_define

begin_decl_stmt
specifier|static
name|int
name|insert_cost
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|delete_cost
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|change_cost
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swap_cost
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_iswap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* swap_int temp variable */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_cswap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* swap_char temp variable */
end_comment

begin_decl_stmt
specifier|static
name|int
name|_mx
decl_stmt|,
name|_my
decl_stmt|,
name|_mz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* min2, min3 temp variables */
end_comment

begin_function
name|void
name|view_costs
parameter_list|(
name|ins
parameter_list|,
name|del
parameter_list|,
name|ch
parameter_list|,
name|swap
parameter_list|)
name|int
modifier|*
name|ins
decl_stmt|,
decl|*
name|del
decl_stmt|,
modifier|*
name|ch
decl_stmt|,
modifier|*
name|swap
decl_stmt|;
end_function

begin_block
block|{
name|SAFE_ASSIGN
argument_list|(
name|ins
argument_list|,
name|insert_cost
argument_list|)
expr_stmt|;
name|SAFE_ASSIGN
argument_list|(
name|del
argument_list|,
name|delete_cost
argument_list|)
expr_stmt|;
name|SAFE_ASSIGN
argument_list|(
name|ch
argument_list|,
name|change_cost
argument_list|)
expr_stmt|;
name|SAFE_ASSIGN
argument_list|(
name|swap
argument_list|,
name|swap_cost
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* view_costs */
end_comment

begin_function
name|void
name|set_costs
parameter_list|(
name|ins
parameter_list|,
name|del
parameter_list|,
name|ch
parameter_list|,
name|swap
parameter_list|)
name|int
name|ins
decl_stmt|,
name|del
decl_stmt|,
name|ch
decl_stmt|,
name|swap
decl_stmt|;
block|{
name|insert_cost
operator|=
name|ins
expr_stmt|;
name|delete_cost
operator|=
name|del
expr_stmt|;
name|change_cost
operator|=
name|ch
expr_stmt|;
name|swap_cost
operator|=
name|swap
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_costs */
end_comment

begin_comment
comment|/* edit_distn -- returns the edit distance between two strings, or -1 on    failure */
end_comment

begin_function
name|int
name|edit_distn
parameter_list|(
name|from
parameter_list|,
name|from_len
parameter_list|,
name|to
parameter_list|,
name|to_len
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|from_len
decl_stmt|,
name|to_len
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|TRN_SPEEDUP
specifier|register
name|int
name|ins
decl_stmt|,
name|del
decl_stmt|,
name|ch
decl_stmt|;
comment|/* local copies of edit costs */
endif|#
directive|endif
specifier|register
name|int
name|row
decl_stmt|,
name|col
decl_stmt|,
name|index
decl_stmt|;
comment|/* dynamic programming counters */
specifier|register
name|int
name|radix
decl_stmt|;
comment|/* radix for modular indexing */
ifdef|#
directive|ifdef
name|TRN_SPEEDUP
specifier|register
name|int
name|low
decl_stmt|;
endif|#
directive|endif
name|int
modifier|*
name|buffer
decl_stmt|;
comment|/* pointer to storage for one row 					   of the d.p. array */
specifier|static
name|int
name|store
index|[
name|THRESHOLD
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
comment|/* a small amount of static 					   storage, to be used when the 					   input strings are small enough */
comment|/* Handle trivial cases when one string is empty */
if|if
condition|(
name|from
operator|==
name|NULL
operator|||
operator|!
name|from_len
condition|)
if|if
condition|(
name|to
operator|==
name|NULL
operator|||
operator|!
name|to_len
condition|)
return|return
literal|0
return|;
else|else
return|return
name|to_len
operator|*
name|insert_cost
return|;
elseif|else
if|if
condition|(
name|to
operator|==
name|NULL
operator|||
operator|!
name|to_len
condition|)
return|return
name|from_len
operator|*
name|delete_cost
return|;
comment|/* Initialize registers */
name|radix
operator|=
literal|2
operator|*
name|from_len
operator|+
literal|3
expr_stmt|;
ifdef|#
directive|ifdef
name|TRN_SPEEDUP
define|#
directive|define
name|ins
value|1
define|#
directive|define
name|del
value|1
define|#
directive|define
name|ch
value|1
define|#
directive|define
name|swap_cost
value|1
else|#
directive|else
name|ins
operator|=
name|insert_cost
expr_stmt|;
name|del
operator|=
name|delete_cost
expr_stmt|;
name|ch
operator|=
name|change_cost
expr_stmt|;
endif|#
directive|endif
comment|/* Make   from   short enough to fit in the static storage, if it's at all    possible */
if|if
condition|(
name|from_len
operator|>
name|to_len
operator|&&
name|from_len
operator|>
name|STRLENTHRESHOLD
condition|)
block|{
name|swap_int
argument_list|(
name|from_len
argument_list|,
name|to_len
argument_list|)
expr_stmt|;
name|swap_char
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TRN_SPEEDUP
name|swap_int
argument_list|(
name|ins
argument_list|,
name|del
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* if from_len> to_len */
comment|/* Allocate the array storage (from the heap if necessary) */
if|if
condition|(
name|from_len
operator|<=
name|STRLENTHRESHOLD
condition|)
name|buffer
operator|=
name|store
expr_stmt|;
else|else
name|buffer
operator|=
operator|(
name|int
operator|*
operator|)
name|safemalloc
argument_list|(
operator|(
name|MEM_SIZE
operator|)
name|radix
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Here's where the fun begins.  We will find the minimum edit distance    using dynamic programming.  We only need to store two rows of the matrix    at a time, since we always progress down the matrix.  For example,    given the strings "one" and "two", and insert, delete and change costs    equal to 1:  	   _  o  n  e 	_  0  1  2  3 	t  1  1  2  3 	w  2  2  2  3 	o  3  2  3  3     The dynamic programming recursion is defined as follows:  	ar(x,0) := x * insert_cost 	ar(0,y) := y * delete_cost 	ar(x,y) := min(a(x - 1, y - 1) + (from[x] == to[y] ? 0 : change), 		       a(x - 1, y) + insert_cost, 		       a(x, y - 1) + delete_cost, 		       a(x - 2, y - 2) + (from[x] == to[y-1]&& 					  from[x-1] == to[y] ? swap_cost : 					  infinity))     Since this only looks at most two rows and three columns back, we need    only store the values for the two preceeding rows.  In this    implementation, we do not explicitly store the zero column, so only 2 *    from_len + 2   words are needed.  However, in the implementation of the    swap_cost   check, the current matrix value is used as a buffer; we    can't overwrite the earlier value until the   swap_cost   check has    been performed.  So we use   2 * from_len + 3   elements in the buffer. */
define|#
directive|define
name|ar
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|index
parameter_list|)
value|(((x) == 0) ? (y) * del : (((y) == 0) ? (x) * ins : \ 	buffer[mod(index)]))
define|#
directive|define
name|NW
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|ar(x, y, index + from_len + 2)
define|#
directive|define
name|N
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|ar(x, y, index + from_len + 3)
define|#
directive|define
name|W
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|ar(x, y, index + radix - 1)
define|#
directive|define
name|NNWW
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|ar(x, y, index + 1)
define|#
directive|define
name|mod
parameter_list|(
name|x
parameter_list|)
value|((x) % radix)
name|index
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_EDITDIST
name|printf
argument_list|(
literal|"      "
argument_list|)
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|from_len
condition|;
name|col
operator|++
control|)
name|printf
argument_list|(
literal|" %c "
argument_list|,
name|from
index|[
name|col
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n   "
argument_list|)
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<=
name|from_len
condition|;
name|col
operator|++
control|)
name|printf
argument_list|(
literal|"%2d "
argument_list|,
name|col
operator|*
name|del
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Row 0 is handled implicitly; its value at a given column is   col*del.    The loop below computes the values for Row 1.  At this point we know the    strings are nonempty.  We also don't need to consider swap costs in row    1.     COMMENT:  the indicies   row and col   below point into the STRING, so    the corresponding MATRIX indicies are   row+1 and col+1. */
name|buffer
index|[
name|index
operator|++
index|]
operator|=
name|min2
argument_list|(
name|ins
operator|+
name|del
argument_list|,
operator|(
name|from
index|[
literal|0
index|]
operator|==
name|to
index|[
literal|0
index|]
condition|?
literal|0
else|:
name|ch
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRN_SPEEDUP
name|low
operator|=
name|buffer
index|[
name|mod
argument_list|(
name|index
operator|+
name|radix
operator|-
literal|1
argument_list|)
index|]
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG_EDITDIST
name|printf
argument_list|(
literal|"\n %c %2d %2d "
argument_list|,
name|to
index|[
literal|0
index|]
argument_list|,
name|ins
argument_list|,
name|buffer
index|[
name|index
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|col
operator|=
literal|1
init|;
name|col
operator|<
name|from_len
condition|;
name|col
operator|++
control|)
block|{
name|buffer
index|[
name|index
index|]
operator|=
name|min3
argument_list|(
name|col
operator|*
name|del
operator|+
operator|(
operator|(
name|from
index|[
name|col
index|]
operator|==
name|to
index|[
literal|0
index|]
operator|)
condition|?
literal|0
else|:
name|ch
operator|)
argument_list|,
operator|(
name|col
operator|+
literal|1
operator|)
operator|*
name|del
operator|+
name|ins
argument_list|,
name|buffer
index|[
name|index
operator|-
literal|1
index|]
operator|+
name|del
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRN_SPEEDUP
if|if
condition|(
name|buffer
index|[
name|index
index|]
operator|<
name|low
condition|)
name|low
operator|=
name|buffer
index|[
name|index
index|]
expr_stmt|;
endif|#
directive|endif
name|index
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_EDITDIST
name|printf
argument_list|(
literal|"%2d "
argument_list|,
name|buffer
index|[
name|index
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* for col = 1 */
ifdef|#
directive|ifdef
name|DEBUG_EDITDIST
name|printf
argument_list|(
literal|"\n %c %2d "
argument_list|,
name|to
index|[
literal|1
index|]
argument_list|,
literal|2
operator|*
name|ins
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now handle the rest of the matrix */
for|for
control|(
name|row
operator|=
literal|1
init|;
name|row
operator|<
name|to_len
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|from_len
condition|;
name|col
operator|++
control|)
block|{
name|buffer
index|[
name|index
index|]
operator|=
name|min3
argument_list|(
name|NW
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
operator|+
operator|(
operator|(
name|from
index|[
name|col
index|]
operator|==
name|to
index|[
name|row
index|]
operator|)
condition|?
literal|0
else|:
name|ch
operator|)
argument_list|,
name|N
argument_list|(
name|row
argument_list|,
name|col
operator|+
literal|1
argument_list|)
operator|+
name|ins
argument_list|,
name|W
argument_list|(
name|row
operator|+
literal|1
argument_list|,
name|col
argument_list|)
operator|+
name|del
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
index|[
name|col
index|]
operator|==
name|to
index|[
name|row
operator|-
literal|1
index|]
operator|&&
name|col
operator|>
literal|0
operator|&&
name|from
index|[
name|col
operator|-
literal|1
index|]
operator|==
name|to
index|[
name|row
index|]
condition|)
name|buffer
index|[
name|index
index|]
operator|=
name|min2
argument_list|(
name|buffer
index|[
name|index
index|]
argument_list|,
name|NNWW
argument_list|(
name|row
operator|-
literal|1
argument_list|,
name|col
operator|-
literal|1
argument_list|)
operator|+
name|swap_cost
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_EDITDIST
name|printf
argument_list|(
literal|"%2d "
argument_list|,
name|buffer
index|[
name|index
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRN_SPEEDUP
if|if
condition|(
name|buffer
index|[
name|index
index|]
operator|<
name|low
operator|||
name|col
operator|==
literal|0
condition|)
name|low
operator|=
name|buffer
index|[
name|index
index|]
expr_stmt|;
endif|#
directive|endif
name|index
operator|=
name|mod
argument_list|(
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* for col = 1 */
ifdef|#
directive|ifdef
name|DEBUG_EDITDIST
if|if
condition|(
name|row
operator|<
name|to_len
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"\n %c %2d "
argument_list|,
name|to
index|[
name|row
operator|+
literal|1
index|]
argument_list|,
operator|(
name|row
operator|+
literal|2
operator|)
operator|*
name|ins
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRN_SPEEDUP
if|if
condition|(
name|low
operator|>
name|MIN_DIST
condition|)
break|break;
endif|#
directive|endif
block|}
comment|/* for row = 1 */
name|row
operator|=
name|buffer
index|[
name|mod
argument_list|(
name|index
operator|+
name|radix
operator|-
literal|1
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|buffer
operator|!=
name|store
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|)
expr_stmt|;
return|return
name|row
return|;
block|}
end_block

begin_comment
comment|/* edit_distn */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EDIT_DISTANCE */
end_comment

end_unit

