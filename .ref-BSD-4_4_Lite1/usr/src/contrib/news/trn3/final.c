begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: final.c,v 3.0 1992/02/01 03:09:32 davison Trn $  */
end_comment

begin_comment
comment|/* This software is Copyright 1991 by Stan Barber.   *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"init.h"
end_include

begin_include
include|#
directive|include
file|"last.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"artio.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"nntp.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|sigmask
end_ifndef

begin_define
define|#
directive|define
name|sigmask
parameter_list|(
name|m
parameter_list|)
value|(1<< ((m)-1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|final_init
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|SIGTSTP
name|sigset
argument_list|(
name|SIGTSTP
argument_list|,
name|stop_catcher
argument_list|)
expr_stmt|;
comment|/* job control signals */
name|sigset
argument_list|(
name|SIGTTOU
argument_list|,
name|stop_catcher
argument_list|)
expr_stmt|;
comment|/* job control signals */
name|sigset
argument_list|(
name|SIGTTIN
argument_list|,
name|stop_catcher
argument_list|)
expr_stmt|;
comment|/* job control signals */
endif|#
directive|endif
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|int_catcher
argument_list|)
expr_stmt|;
comment|/* always catch interrupts */
ifdef|#
directive|ifdef
name|SIGHUP
name|sigset
argument_list|(
name|SIGHUP
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
comment|/* and hangups */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGWINCH
name|sigset
argument_list|(
name|SIGWINCH
argument_list|,
name|winch_catcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|lint
ifdef|#
directive|ifdef
name|SIGEMT
name|sigignore
argument_list|(
name|SIGEMT
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
comment|/* sometimes we WANT a core dump */
if|if
condition|(
name|debug
operator|&
name|DEB_COREDUMPSOK
condition|)
return|return;
endif|#
directive|endif
name|sigset
argument_list|(
name|SIGILL
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTRAP
name|sigset
argument_list|(
name|SIGTRAP
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigset
argument_list|(
name|SIGFPE
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGBUS
name|sigset
argument_list|(
name|SIGBUS
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigset
argument_list|(
name|SIGSEGV
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGSYS
name|sigset
argument_list|(
name|SIGSYS
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigset
argument_list|(
name|SIGTERM
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGXCPU
name|sigset
argument_list|(
name|SIGXCPU
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
name|sigset
argument_list|(
name|SIGXFSZ
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
comment|/* very much void */
name|finalize
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|termlib_reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|bizarre
condition|)
name|resetty
argument_list|()
expr_stmt|;
if|if
condition|(
name|lockname
operator|&&
operator|*
name|lockname
condition|)
name|UNLINK
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_NNTP
name|nntp_cleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|chdir
argument_list|(
literal|"/usr/tmp"
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGILL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_SIGBLOCK
name|sigsetmask
argument_list|(
name|sigblock
argument_list|(
literal|0
argument_list|)
operator|&
operator|~
operator|(
name|sigmask
argument_list|(
name|SIGILL
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGIOT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* come here on interrupt */
end_comment

begin_function
name|Signal_t
name|int_catcher
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
decl_stmt|;
block|{
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|int_catcher
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"int_catcher\n"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|waiting
condition|)
block|{
if|if
condition|(
name|int_count
condition|)
block|{
comment|/* was there already an interrupt? */
name|write
argument_list|(
literal|2
argument_list|,
literal|"\nBye-bye.\n"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* emulate the other signals */
block|}
name|int_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* come here on signal other than interrupt, stop, or cont */
end_comment

begin_function
name|Signal_t
name|sig_catcher
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VERBOSE
specifier|static
name|char
modifier|*
name|signame
index|[]
init|=
block|{
literal|""
block|,
literal|"HUP"
block|,
literal|"INT"
block|,
literal|"QUIT"
block|,
literal|"ILL"
block|,
literal|"TRAP"
block|,
literal|"IOT"
block|,
literal|"EMT"
block|,
literal|"FPE"
block|,
literal|"KILL"
block|,
literal|"BUS"
block|,
literal|"SEGV"
block|,
literal|"SYS"
block|,
literal|"PIPE"
block|,
literal|"ALRM"
block|,
literal|"TERM"
block|,
literal|"???"
ifdef|#
directive|ifdef
name|SIGTSTP
block|,
literal|"STOP"
block|,
literal|"TSTP"
block|,
literal|"CONT"
block|,
literal|"CHLD"
block|,
literal|"TTIN"
block|,
literal|"TTOU"
block|,
literal|"TINT"
block|,
literal|"XCPU"
block|,
literal|"XFSZ"
ifdef|#
directive|ifdef
name|SIGPROF
block|,
literal|"VTALARM"
block|,
literal|"PROF"
endif|#
directive|endif
endif|#
directive|endif
block|}
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"\nSIG%s--.newsrc not restored in debug\n"
argument_list|,
name|signame
index|[
name|signo
index|]
argument_list|)
expr_stmt|;
name|finalize
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|panic
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_SIGBLOCK
name|sigsetmask
argument_list|(
name|sigblock
argument_list|(
literal|0
argument_list|)
operator|&
operator|~
operator|(
name|sigmask
argument_list|(
name|SIGILL
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGIOT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGILL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|panic
operator|=
name|TRUE
expr_stmt|;
comment|/* disable terminal I/O */
if|if
condition|(
name|doing_ng
condition|)
block|{
comment|/* need we reconstitute rc line? */
name|yankback
argument_list|()
expr_stmt|;
name|bits_to_rc
argument_list|()
expr_stmt|;
comment|/* then do so (hope this works) */
block|}
name|doing_ng
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|rc_changed
condition|)
comment|/* need we write .newsrc out? */
name|write_rc
argument_list|()
expr_stmt|;
comment|/* then do so */
name|rc_changed
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGHUP
if|if
condition|(
name|signo
operator|!=
name|SIGHUP
condition|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nCaught %s%s--.newsrc restored\n"
argument_list|,
name|signo
condition|?
literal|"a SIG"
else|:
literal|"an internal error"
argument_list|,
name|signame
index|[
name|signo
index|]
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\nSignal %d--bye bye\n"
argument_list|,
name|signo
argument_list|)
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|signo
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGBUS
case|case
name|SIGBUS
case|:
endif|#
directive|endif
case|case
name|SIGILL
case|:
case|case
name|SIGSEGV
case|:
name|finalize
argument_list|(
operator|-
name|signo
argument_list|)
expr_stmt|;
block|}
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* and blow up */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_comment
comment|/* come here on stop signal */
end_comment

begin_function
name|Signal_t
name|stop_catcher
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|waiting
condition|)
block|{
name|checkpoint_rc
argument_list|()
expr_stmt|;
comment|/* good chance of crash while stopped */
if|if
condition|(
name|clear_on_stop
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
block|}
name|termlib_reset
argument_list|()
expr_stmt|;
name|resetty
argument_list|()
expr_stmt|;
comment|/* this is the point of all this */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"stop_catcher\n"
argument_list|,
literal|13
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigset
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* enable stop */
ifdef|#
directive|ifdef
name|HAS_SIGBLOCK
name|sigsetmask
argument_list|(
name|sigblock
argument_list|(
literal|0
argument_list|)
operator|&
operator|~
operator|(
literal|1
operator|<<
operator|(
name|signo
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kill
argument_list|(
literal|0
argument_list|,
name|signo
argument_list|)
expr_stmt|;
comment|/* and do the stop */
name|savetty
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MAILCALL
name|mailcount
operator|=
literal|0
expr_stmt|;
comment|/* force recheck */
endif|#
directive|endif
if|if
condition|(
operator|!
name|panic
condition|)
block|{
if|if
condition|(
operator|!
name|waiting
condition|)
block|{
name|termlib_init
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
comment|/* set no echo */
name|crmode
argument_list|()
expr_stmt|;
comment|/* set cbreak mode */
name|forceme
argument_list|(
literal|"\f"
argument_list|)
expr_stmt|;
comment|/* cause a refresh */
comment|/* (defined only if TIOCSTI defined) */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* needed for getcmd */
block|}
block|}
block|}
name|sigset
argument_list|(
name|signo
argument_list|,
name|stop_catcher
argument_list|)
expr_stmt|;
comment|/* unenable the stop */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

