begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: bits.c,v 3.0 1992/02/01 03:09:32 davison Trn $  */
end_comment

begin_comment
comment|/* This software is Copyright 1991 by Stan Barber.   *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"trn.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"artio.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"rcln.h"
end_include

begin_include
include|#
directive|include
file|"ndir.h"
end_include

begin_include
include|#
directive|include
file|"nntp.h"
end_include

begin_include
include|#
directive|include
file|"rthread.h"
end_include

begin_include
include|#
directive|include
file|"rt-select.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DBM_XREFS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NULL
end_ifdef

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dbm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|bits_init
parameter_list|()
block|{
empty_stmt|;
block|}
end_function

begin_function
name|void
name|rc_to_bits
parameter_list|()
block|{
name|char
modifier|*
name|mybuf
init|=
name|buf
decl_stmt|;
comment|/* place to decode rc line */
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|h
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
specifier|register
name|ART_NUM
name|unread
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
comment|/* modify the article flags to reflect what has already been read */
for|for
control|(
name|s
operator|=
name|rcline
index|[
name|ng
index|]
operator|+
name|rcnums
index|[
name|ng
index|]
init|;
operator|*
name|s
operator|==
literal|' '
condition|;
name|s
operator|++
control|)
empty_stmt|;
comment|/* find numbers in rc line */
name|i
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
name|i
operator|>=
name|LBUFLEN
operator|-
literal|2
condition|)
comment|/* bigger than buf? */
name|mybuf
operator|=
name|safemalloc
argument_list|(
call|(
name|MEM_SIZE
call|)
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|mybuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* make scratch copy of line */
name|mybuf
index|[
name|i
operator|++
index|]
operator|=
literal|','
expr_stmt|;
comment|/* put extra comma on the end */
name|mybuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|mybuf
expr_stmt|;
comment|/* initialize the for loop below */
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"1-"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* can we save some time here? */
name|firstart
operator|=
name|atol
argument_list|(
name|s
operator|+
literal|2
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* process first range thusly */
name|s
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|absfirst
operator|,
name|ap
operator|=
name|article_ptr
argument_list|(
name|i
argument_list|)
init|;
name|i
operator|<
name|firstart
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
name|ap
operator|->
name|flags
operator||=
name|AF_READ
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|firstart
operator|=
name|absfirst
expr_stmt|;
name|ap
operator|=
name|article_ptr
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|unread
operator|=
name|lastart
operator|-
name|firstart
operator|+
literal|1
expr_stmt|;
comment|/* assume this range unread */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DEB_CTLAREA_BITMAP
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
argument|mybuf
argument_list|)
name|FLUSH
expr_stmt|;
for|for
control|(
name|i
operator|=
name|absfirst
operator|,
name|ap
operator|=
name|article_ptr
argument_list|(
name|i
argument_list|)
init|;
name|i
operator|<
name|firstart
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
operator|)
condition|)
name|printf
argument_list|(
literal|"%ld "
argument_list|,
argument|(long)i
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
init|;
operator|(
name|c
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|Nullch
condition|;
name|s
operator|=
operator|++
name|c
control|)
block|{
comment|/* for each range */
name|ART_NUM
name|min
decl_stmt|,
name|max
decl_stmt|;
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
comment|/* do not let index see past comma */
name|h
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|min
operator|=
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
comment|/* is there a dash? */
name|max
operator|=
name|atol
argument_list|(
name|h
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|max
operator|=
name|min
expr_stmt|;
if|if
condition|(
name|min
operator|<
name|firstart
condition|)
comment|/* make sure range is in range */
name|min
operator|=
name|firstart
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|lastart
condition|)
name|min
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|min
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
name|ap
operator|->
name|flags
operator|&=
operator|~
name|AF_READ
expr_stmt|;
if|if
condition|(
name|max
operator|>
name|lastart
condition|)
name|max
operator|=
name|lastart
expr_stmt|;
if|if
condition|(
name|min
operator|<=
name|max
condition|)
block|{
comment|/* non-null range? */
name|unread
operator|-=
name|max
operator|-
name|min
operator|+
literal|1
expr_stmt|;
comment|/* adjust unread count */
comment|/* mark all arts in range as read */
for|for
control|(
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
name|ap
operator|->
name|flags
operator||=
name|AF_READ
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DEB_CTLAREA_BITMAP
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
argument|s
argument_list|)
name|FLUSH
expr_stmt|;
for|for
control|(
name|i
operator|=
name|absfirst
init|;
name|i
operator|<=
name|lastart
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|was_read
argument_list|(
name|i
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%ld "
argument_list|,
argument|(long)i
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
block|}
for|for
control|(
init|;
name|i
operator|<=
name|lastart
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
name|ap
operator|->
name|flags
operator|&=
operator|~
name|AF_READ
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DEB_CTLAREA_BITMAP
condition|)
block|{
name|fputs
argument_list|(
literal|"\n(hit CR)"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|gets
argument_list|(
name|cmd_buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mybuf
operator|!=
name|buf
condition|)
name|free
argument_list|(
name|mybuf
argument_list|)
expr_stmt|;
name|toread
index|[
name|ng
index|]
operator|=
name|unread
expr_stmt|;
block|}
end_function

begin_comment
comment|/* reconstruct the .newsrc line in a human readable form */
end_comment

begin_function
name|void
name|bits_to_rc
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|mybuf
init|=
name|buf
decl_stmt|;
specifier|register
name|ART_NUM
name|i
decl_stmt|;
name|ART_NUM
name|count
init|=
literal|0
decl_stmt|;
name|int
name|safelen
init|=
name|LBUFLEN
operator|-
literal|32
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|rcline
index|[
name|ng
index|]
argument_list|)
expr_stmt|;
comment|/* start with the newsgroup name */
name|s
operator|=
name|buf
operator|+
name|rcnums
index|[
name|ng
index|]
operator|-
literal|1
expr_stmt|;
comment|/* use s for buffer pointer */
operator|*
name|s
operator|++
operator|=
name|RCCHAR
argument_list|(
name|rcchar
index|[
name|ng
index|]
argument_list|)
expr_stmt|;
comment|/* put the requisite : or !*/
for|for
control|(
name|i
operator|=
name|absfirst
init|;
name|i
operator|<=
name|lastart
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|was_read
argument_list|(
name|i
argument_list|)
condition|)
break|break;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|" 1-%ld,"
argument_list|,
operator|(
name|long
operator|)
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|lastart
condition|;
name|i
operator|++
control|)
block|{
comment|/* for each article in newsgroup */
if|if
condition|(
name|s
operator|-
name|mybuf
operator|>
name|safelen
condition|)
block|{
comment|/* running out of room? */
name|safelen
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|mybuf
operator|==
name|buf
condition|)
block|{
comment|/* currently static? */
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|mybuf
operator|=
name|safemalloc
argument_list|(
operator|(
name|MEM_SIZE
operator|)
name|safelen
operator|+
literal|32
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mybuf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* so we must copy it */
name|s
operator|=
name|mybuf
operator|+
operator|(
name|s
operator|-
name|buf
operator|)
expr_stmt|;
comment|/* fix the pointer, too */
block|}
else|else
block|{
comment|/* just grow in place, if possible */
name|char
modifier|*
name|newbuf
decl_stmt|;
name|newbuf
operator|=
name|saferealloc
argument_list|(
name|mybuf
argument_list|,
operator|(
name|MEM_SIZE
operator|)
name|safelen
operator|+
literal|32
argument_list|)
expr_stmt|;
name|s
operator|=
name|newbuf
operator|+
operator|(
name|s
operator|-
name|mybuf
operator|)
expr_stmt|;
name|mybuf
operator|=
name|newbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|was_read
argument_list|(
name|i
argument_list|)
condition|)
comment|/* still unread? */
name|count
operator|++
expr_stmt|;
comment|/* then count it */
else|else
block|{
comment|/* article was read */
name|ART_NUM
name|oldi
decl_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
expr_stmt|;
comment|/* put out the min of the range */
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* keeping house */
name|oldi
operator|=
name|i
expr_stmt|;
comment|/* remember this spot */
do|do
name|i
operator|++
expr_stmt|;
do|while
condition|(
name|i
operator|<=
name|lastart
operator|&&
name|was_read
argument_list|(
name|i
argument_list|)
condition|)
do|;
comment|/* find 1st unread article or end */
name|i
operator|--
expr_stmt|;
comment|/* backup to last read article */
if|if
condition|(
name|i
operator|>
name|oldi
condition|)
block|{
comment|/* range of more than 1? */
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"-%ld,"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
expr_stmt|;
comment|/* then it out as a range */
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* and housekeep */
block|}
else|else
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
comment|/* otherwise, just a comma will do */
block|}
block|}
if|if
condition|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|','
condition|)
comment|/* is there a final ','? */
name|s
operator|--
expr_stmt|;
comment|/* take it back */
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* and terminate string */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DEB_NEWSRC_LINE
operator|&&
operator|!
name|panic
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
argument|rcline[ng]
argument_list|,
argument|rcline[ng]+rcnums[ng]
argument_list|)
name|FLUSH
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
argument|mybuf
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|rcline
index|[
name|ng
index|]
argument_list|)
expr_stmt|;
comment|/* return old rc line */
if|if
condition|(
name|mybuf
operator|==
name|buf
condition|)
block|{
name|rcline
index|[
name|ng
index|]
operator|=
name|safemalloc
argument_list|(
call|(
name|MEM_SIZE
call|)
argument_list|(
name|s
operator|-
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* grab a new rc line */
name|strcpy
argument_list|(
name|rcline
index|[
name|ng
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* and load it */
block|}
else|else
block|{
name|mybuf
operator|=
name|saferealloc
argument_list|(
name|mybuf
argument_list|,
call|(
name|MEM_SIZE
call|)
argument_list|(
name|s
operator|-
name|mybuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* be nice to the heap */
name|rcline
index|[
name|ng
index|]
operator|=
name|mybuf
expr_stmt|;
block|}
operator|*
operator|(
name|rcline
index|[
name|ng
index|]
operator|+
name|rcnums
index|[
name|ng
index|]
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rcchar
index|[
name|ng
index|]
operator|==
name|NEGCHAR
condition|)
block|{
comment|/* did they unsubscribe? */
name|printf
argument_list|(
argument|unsubto
argument_list|,
argument|ngname
argument_list|)
name|FLUSH
expr_stmt|;
name|toread
index|[
name|ng
index|]
operator|=
name|TR_UNSUB
expr_stmt|;
comment|/* make line invisible */
block|}
else|else
comment|/*NOSTRICT*/
name|toread
index|[
name|ng
index|]
operator|=
operator|(
name|ART_UNREAD
operator|)
name|count
expr_stmt|;
comment|/* remember how many unread there are */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_NNTP
end_ifdef

begin_comment
comment|/* Parse the LISTGROUP output and set anything not mentioned as missing. */
end_comment

begin_function
name|void
name|setmissingbits
parameter_list|()
comment|/* NNTP version */
block|{
specifier|register
name|ART_NUM
name|num
decl_stmt|,
name|priornum
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|nntp_listgroup
argument_list|()
condition|)
return|return;
for|for
control|(
name|priornum
operator|=
name|absfirst
operator|-
literal|1
operator|,
name|ap
operator|=
name|article_ptr
argument_list|(
name|absfirst
argument_list|)
init|;
condition|;
name|ap
operator|++
control|)
block|{
name|nntp_gets
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
name|ser_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ser_line
operator|==
literal|'.'
condition|)
break|break;
name|num
operator|=
name|atol
argument_list|(
name|ser_line
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|priornum
operator|<
name|num
condition|)
name|uncache_article
argument_list|(
name|ap
operator|++
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USE_NNTP */
end_comment

begin_comment
comment|/* Scan the directory to find which articles are present. */
end_comment

begin_function
name|void
name|setfoundbits
parameter_list|()
block|{
specifier|register
name|ART_NUM
name|first
init|=
name|lastart
operator|+
literal|1
decl_stmt|;
specifier|register
name|DIR
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|long
name|an
decl_stmt|;
name|char
name|ch
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
condition|)
return|return;
name|found_min
operator|=
name|absfirst
expr_stmt|;
name|an
operator|=
operator|(
name|lastart
operator|-
name|found_min
operator|)
operator|/
name|BITSPERBYTE
operator|+
literal|20
expr_stmt|;
name|found_bits
operator|=
name|safemalloc
argument_list|(
operator|(
name|MEM_SIZE
operator|)
name|an
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|found_bits
argument_list|,
name|an
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|Null
argument_list|(
expr|struct
name|direct
operator|*
argument_list|)
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"%ld%c"
argument_list|,
operator|&
name|an
argument_list|,
operator|&
name|ch
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|an
operator|<=
name|lastart
operator|&&
name|an
operator|>=
name|found_min
condition|)
block|{
if|if
condition|(
name|an
operator|<
name|first
condition|)
name|first
operator|=
name|an
expr_stmt|;
name|foundart
argument_list|(
name|an
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|abs1st
index|[
name|ng
index|]
operator|=
name|first
expr_stmt|;
if|if
condition|(
name|first
operator|>
name|absfirst
condition|)
name|checkexpired
argument_list|(
name|ng
argument_list|)
expr_stmt|;
name|absfirst
operator|=
name|first
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setmissingbits
parameter_list|()
comment|/* non-NNTP version */
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
specifier|register
name|ART_NUM
name|an
decl_stmt|;
if|if
condition|(
operator|!
name|found_bits
condition|)
return|return;
for|for
control|(
name|an
operator|=
name|absfirst
operator|,
name|ap
operator|=
name|article_ptr
argument_list|(
name|an
argument_list|)
init|;
name|an
operator|<=
name|lastart
condition|;
name|an
operator|++
operator|,
name|ap
operator|++
control|)
block|{
if|if
condition|(
name|artismissing
argument_list|(
name|an
argument_list|)
condition|)
name|onemissing
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|found_bits
argument_list|)
expr_stmt|;
name|found_bits
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_NNTP */
end_comment

begin_comment
comment|/* mark an article unread, keeping track of toread[] */
end_comment

begin_function
name|void
name|onemore
parameter_list|(
name|ap
parameter_list|)
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
condition|)
block|{
specifier|register
name|ART_NUM
name|artnum
init|=
name|article_num
argument_list|(
name|ap
argument_list|)
decl_stmt|;
name|check_first
argument_list|(
name|artnum
argument_list|)
expr_stmt|;
name|ap
operator|->
name|flags
operator|&=
operator|~
name|AF_READ
expr_stmt|;
operator|++
name|toread
index|[
name|ng
index|]
expr_stmt|;
name|ap
operator|->
name|flags
operator|&=
operator|~
name|AF_DEL
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|subj
condition|)
block|{
if|if
condition|(
name|selected_only
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|subj
operator|->
name|flags
operator|&
name|sel_mask
condition|)
block|{
name|ap
operator|->
name|flags
operator||=
name|sel_mask
expr_stmt|;
name|selected_count
operator|++
expr_stmt|;
block|}
block|}
else|else
name|ap
operator|->
name|subj
operator|->
name|flags
operator||=
name|SF_VISIT
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* mark an article read, keeping track of toread[] */
end_comment

begin_function
name|void
name|oneless
parameter_list|(
name|ap
parameter_list|)
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
operator|)
condition|)
block|{
name|ap
operator|->
name|flags
operator||=
name|AF_READ
expr_stmt|;
comment|/* Keep selected_count accurate */
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|sel_mask
condition|)
block|{
name|selected_count
operator|--
expr_stmt|;
name|ap
operator|->
name|flags
operator|&=
operator|~
name|sel_mask
expr_stmt|;
block|}
if|if
condition|(
name|toread
index|[
name|ng
index|]
operator|>
name|TR_NONE
condition|)
operator|--
name|toread
index|[
name|ng
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|onemissing
parameter_list|(
name|ap
parameter_list|)
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
name|oneless
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ap
operator|->
name|flags
operator|=
operator|(
name|ap
operator|->
name|flags
operator|&
operator|~
operator|(
name|AF_HAS_RE
operator||
name|AF_YANKBACK
operator||
name|AF_FROMTRUNCED
operator|)
operator|)
operator||
name|AF_MISSING
operator||
name|AF_CACHED
operator||
name|AF_THREADED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mark an article as unread, with possible xref chasing */
end_comment

begin_function
name|void
name|unmark_as_read
parameter_list|()
block|{
name|onemore
argument_list|(
name|article_ptr
argument_list|(
name|art
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MCHASE
name|chase_xrefs
argument_list|(
name|art
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Mark an article as read in this newsgroup and possibly chase xrefs. ** Don't call this on missing articles. */
end_comment

begin_function
name|void
name|set_read
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|ART_NUM
name|artnum
init|=
name|article_num
argument_list|(
name|ap
argument_list|)
decl_stmt|;
name|oneless
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|olden_days
operator|&&
name|ap
operator|->
name|xrefs
operator|!=
name|nullstr
condition|)
block|{
if|if
condition|(
name|output_chase_phrase
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\nChasing xrefs"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\nXrefs"
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|output_chase_phrase
operator|=
literal|0
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'.'
argument_list|)
operator|,
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|chase_xrefs
argument_list|(
name|artnum
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* temporarily mark article as read.  When newsgroup is exited, articles */
end_comment

begin_comment
comment|/* will be marked as unread.  Called via M command */
end_comment

begin_function
name|void
name|delay_unmark
parameter_list|(
name|ap
parameter_list|)
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_YANKBACK
operator|)
condition|)
block|{
name|ap
operator|->
name|flags
operator||=
name|AF_YANKBACK
expr_stmt|;
name|dmcount
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* mark article as read.  If article is cross referenced to other */
end_comment

begin_comment
comment|/* newsgroups, mark them read there also. */
end_comment

begin_function
name|void
name|mark_as_read
parameter_list|()
block|{
name|oneless
argument_list|(
name|article_ptr
argument_list|(
name|art
argument_list|)
argument_list|)
expr_stmt|;
name|checkcount
operator|++
expr_stmt|;
comment|/* get more worried about crashes */
name|chase_xrefs
argument_list|(
name|art
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* keep firstart pointing at the first unread article */
end_comment

begin_function
name|void
name|check_first
parameter_list|(
name|min
parameter_list|)
name|ART_NUM
name|min
decl_stmt|;
block|{
if|if
condition|(
name|min
operator|<
name|absfirst
condition|)
name|min
operator|=
name|absfirst
expr_stmt|;
if|if
condition|(
name|min
operator|<
name|firstart
condition|)
name|firstart
operator|=
name|min
expr_stmt|;
block|}
end_function

begin_comment
comment|/* bring back articles marked with M */
end_comment

begin_function
name|void
name|yankback
parameter_list|()
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
name|dmcount
condition|)
block|{
comment|/* delayed unmarks pending? */
if|if
condition|(
name|mode
operator|==
literal|'t'
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Returned %ld Marked article%s."
argument_list|,
operator|(
name|long
operator|)
name|dmcount
argument_list|,
name|dmcount
operator|==
literal|1
condition|?
name|nullstr
else|:
literal|"s"
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"\nReturning %ld Marked article%s...\n"
argument_list|,
argument|(long)dmcount
argument_list|,
argument|dmcount ==
literal|1
argument|? nullstr :
literal|"s"
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|art
operator|=
name|absfirst
operator|,
name|ap
operator|=
name|article_ptr
argument_list|(
name|art
argument_list|)
init|;
name|art
operator|<=
name|lastart
condition|;
name|art
operator|++
operator|,
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_YANKBACK
operator||
name|AF_MISSING
operator|)
operator|)
operator|==
name|AF_YANKBACK
condition|)
block|{
name|unmark_as_read
argument_list|()
expr_stmt|;
if|if
condition|(
name|selected_only
condition|)
name|select_article
argument_list|(
name|ap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ap
operator|->
name|flags
operator|&=
operator|~
name|AF_YANKBACK
expr_stmt|;
block|}
block|}
name|dmcount
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* run down xref list and mark as read or unread */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DBM_XREFS
end_ifndef

begin_function
name|int
name|chase_xrefs
parameter_list|(
name|artnum
parameter_list|,
name|markread
parameter_list|)
comment|/* The Xref-line-using version */
name|ART_NUM
name|artnum
decl_stmt|;
name|int
name|markread
decl_stmt|;
block|{
name|bool
name|valid_xref_site
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|xartnum
decl_stmt|;
specifier|register
name|ART_NUM
name|x
decl_stmt|;
name|char
modifier|*
name|xref_buf
decl_stmt|,
modifier|*
name|curxref
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|128
index|]
decl_stmt|;
name|xref_buf
operator|=
name|fetchcache
argument_list|(
name|artnum
argument_list|,
name|XREF_LINE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xref_buf
operator|||
operator|!
operator|*
name|xref_buf
condition|)
return|return
literal|0
return|;
name|xref_buf
operator|=
name|savestr
argument_list|(
name|xref_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DEB_XREF_MARKER
condition|)
name|printf
argument_list|(
literal|"Xref: %s\n"
argument_list|,
argument|xref_buf
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
name|curxref
operator|=
name|cpytill
argument_list|(
name|tmpbuf
argument_list|,
name|xref_buf
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|valid_xref_site
argument_list|(
name|artnum
argument_list|,
name|tmpbuf
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
name|curxref
condition|)
block|{
comment|/* for each newsgroup */
name|curxref
operator|=
name|cpytill
argument_list|(
name|tmpbuf
argument_list|,
name|curxref
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|xartnum
operator|=
name|index
argument_list|(
name|tmpbuf
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xartnum
condition|)
break|break;
operator|*
name|xartnum
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|=
name|atol
argument_list|(
name|xartnum
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|strEQ
argument_list|(
name|tmpbuf
argument_list|,
name|ngname
argument_list|)
condition|)
block|{
comment|/* is this the current newsgroup? */
if|if
condition|(
name|x
operator|<
name|absfirst
operator|||
name|x
operator|>
name|lastart
condition|)
continue|continue;
if|if
condition|(
name|markread
condition|)
name|oneless
argument_list|(
name|article_ptr
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* take care of old C newses */
ifdef|#
directive|ifdef
name|MCHASE
else|else
name|onemore
argument_list|(
name|article_ptr
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|markread
condition|)
block|{
if|if
condition|(
name|addartnum
argument_list|(
name|x
argument_list|,
name|tmpbuf
argument_list|)
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|MCHASE
else|else
name|subartnum
argument_list|(
name|x
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
while|while
condition|(
operator|*
name|curxref
operator|&&
name|isspace
argument_list|(
operator|*
name|curxref
argument_list|)
condition|)
name|curxref
operator|++
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|xref_buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Make sure the site name on Xref matches what inews thinks the site  * is.  Check first against last inews_site.  If it matches, fine.  * If not, fetch inews_site from current Path or Relay-Version line and  * check again.  This is so that if the new administrator decides  * to change the system name as known to inews, rn will still do  * Xrefs correctly--each article need only match itself to be valid.  */
end_comment

begin_function
name|bool
name|valid_xref_site
parameter_list|(
name|artnum
parameter_list|,
name|site
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
name|char
modifier|*
name|site
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|inews_site
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|sitebuf
decl_stmt|,
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|inews_site
operator|&&
name|strEQ
argument_list|(
name|site
argument_list|,
name|inews_site
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|inews_site
condition|)
name|free
argument_list|(
name|inews_site
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANCIENT_NEWS
comment|/* Grab the site from the first component of the Path line */
name|sitebuf
operator|=
name|fetchlines
argument_list|(
name|artnum
argument_list|,
name|PATH_LINE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|index
argument_list|(
name|sitebuf
argument_list|,
literal|'!'
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|inews_site
operator|=
name|savestr
argument_list|(
name|sitebuf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ANCIENT_NEWS */
comment|/* Grab the site from the Posting-Version line */
name|sitebuf
operator|=
name|fetchlines
argument_list|(
name|artnum
argument_list|,
name|RVER_LINE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|instr
argument_list|(
name|sitebuf
argument_list|,
literal|"; site "
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|index
argument_list|(
name|s
operator|+
literal|7
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|inews_site
operator|=
name|savestr
argument_list|(
name|s
operator|+
literal|7
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ANCIENT_NEWS */
else|else
name|inews_site
operator|=
name|savestr
argument_list|(
name|nullstr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sitebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|site
argument_list|,
name|inews_site
argument_list|)
condition|)
return|return
name|TRUE
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Xref not from %s--ignoring\n"
argument_list|,
argument|inews_site
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DBM_XREFS */
end_comment

begin_function
name|int
name|chase_xrefs
parameter_list|(
name|artnum
parameter_list|,
name|markread
parameter_list|)
comment|/* The DBM version */
name|ART_NUM
name|artnum
decl_stmt|;
name|int
name|markread
decl_stmt|;
block|{
name|datum
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|datum
name|fetch
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|idp
decl_stmt|;
name|char
modifier|*
name|ident_buf
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|hist_file
init|=
name|Nullfp
decl_stmt|;
name|long
name|pos
decl_stmt|;
specifier|register
name|char
modifier|*
name|xartnum
decl_stmt|;
specifier|register
name|ART_NUM
name|x
decl_stmt|;
name|char
modifier|*
name|xref_buf
decl_stmt|,
modifier|*
name|curxref
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|128
index|]
decl_stmt|;
name|xref_buf
operator|=
name|fetchcache
argument_list|(
name|artnum
argument_list|,
name|NGS_LINE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xref_buf
operator|||
operator|!
operator|*
name|xref_buf
condition|)
return|return
literal|0
return|;
name|xref_buf
operator|=
name|safemalloc
argument_list|(
operator|(
name|MEM_SIZE
operator|)
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|hist_file
operator|==
name|Nullfp
condition|)
block|{
comment|/* Init. file accesses */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"chase_xref: opening files\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dbminit
argument_list|(
name|filexp
argument_list|(
name|ARTFILE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hist_file
operator|=
name|fopen
argument_list|(
name|filexp
argument_list|(
name|ARTFILE
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|Nullfp
condition|)
return|return
literal|0
return|;
block|}
name|ident_buf
operator|=
name|fetchlines
argument_list|(
name|artnum
argument_list|,
name|MESSID_LINE
argument_list|)
expr_stmt|;
comment|/* get Message-ID */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"chase_xref: Message-ID: %s\n"
argument_list|,
name|ident_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|idp
operator|=
name|index
argument_list|(
name|ident_buf
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|idp
condition|)
comment|/* make message-id case insensitive */
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|idp
argument_list|)
condition|)
operator|*
name|idp
operator|=
name|tolower
argument_list|(
operator|*
name|idp
argument_list|)
expr_stmt|;
block|}
name|lhs
operator|.
name|dptr
operator|=
name|ident_buf
expr_stmt|;
comment|/* look up article by id */
name|lhs
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|lhs
operator|.
name|dptr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|rhs
operator|=
name|fetch
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
comment|/* fetch the record */
if|if
condition|(
name|rhs
operator|.
name|dptr
operator|==
name|NULL
condition|)
comment|/* if null, nothing there */
goto|goto
name|wild_goose
goto|;
name|bcopy
argument_list|(
name|rhs
operator|.
name|dptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pos
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|hist_file
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* datum returned is position in hist file */
name|fgets
argument_list|(
name|xref_buf
argument_list|,
name|BUFSIZ
argument_list|,
name|hist_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Xref from history: %s\n"
argument_list|,
name|xref_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|curxref
operator|=
name|cpytill
argument_list|(
name|tmpbuf
argument_list|,
name|xref_buf
argument_list|,
literal|'\t'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|curxref
operator|=
name|cpytill
argument_list|(
name|tmpbuf
argument_list|,
name|curxref
argument_list|,
literal|'\t'
argument_list|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"chase_xref: curxref: %s\n"
argument_list|,
name|curxref
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|curxref
condition|)
block|{
comment|/* for each newsgroup */
name|curxref
operator|=
name|cpytill
argument_list|(
name|tmpbuf
argument_list|,
name|curxref
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|xartnum
operator|=
name|index
argument_list|(
name|tmpbuf
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xartnum
condition|)
comment|/* probably an old-style Xref */
break|break;
operator|*
name|xartnum
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|=
name|atol
argument_list|(
name|xartnum
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|strNE
argument_list|(
name|tmpbuf
argument_list|,
name|ngname
argument_list|)
condition|)
block|{
comment|/* not the current newsgroup? */
if|if
condition|(
name|markread
condition|)
block|{
if|if
condition|(
name|addartnum
argument_list|(
name|x
argument_list|,
name|tmpbuf
argument_list|)
condition|)
goto|goto
name|wild_goose
goto|;
block|}
ifdef|#
directive|ifdef
name|MCHASE
else|else
name|subartnum
argument_list|(
name|x
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
while|while
condition|(
operator|*
name|curxref
operator|&&
name|isspace
argument_list|(
operator|*
name|curxref
argument_list|)
condition|)
name|curxref
operator|++
expr_stmt|;
block|}
name|wild_goose
label|:
name|free
argument_list|(
name|xref_buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBM_XREFS */
end_comment

end_unit

