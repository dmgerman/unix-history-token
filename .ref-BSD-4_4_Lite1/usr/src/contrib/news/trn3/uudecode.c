begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: uudecode.c,v 4.4.3.1 1992/02/01 03:09:32 $  *   * Decode one or more uuencoded articles back to binary form.  * Trn version created by Wayne Davison.  * Formerly the nn version by Kim Storm.  * From the Berkeley original, modified by MSD, RDR, JPHD& WLS.  */
end_comment

begin_comment
comment|/*  * This software is Copyright 1991 by Stan Barber.   *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"respond.h"
end_include

begin_include
include|#
directive|include
file|"decode.h"
end_include

begin_define
define|#
directive|define
name|MAXCHAR
value|256
end_define

begin_define
define|#
directive|define
name|NORMLEN
value|64
end_define

begin_comment
comment|/* allows for 84 encoded chars per line */
end_comment

begin_define
define|#
directive|define
name|SEQMAX
value|'z'
end_define

begin_define
define|#
directive|define
name|SEQMIN
value|'a'
end_define

begin_decl_stmt
specifier|static
name|char
name|seqc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|first
decl_stmt|,
name|secnd
decl_stmt|,
name|check
decl_stmt|,
name|numl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|blank
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chtbl
index|[
name|MAXCHAR
index|]
decl_stmt|,
name|cdlen
index|[
name|NORMLEN
operator|+
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|Xflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expecting_part
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|decode_line
name|_
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|inittbls
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gettable
name|_
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NO_ADVANCE
value|0x10
end_define

begin_define
define|#
directive|define
name|FIND_BEGIN
value|0x01
end_define

begin_define
define|#
directive|define
name|AFTER_ERROR_FIND_BEGIN
value|0x02
end_define

begin_define
define|#
directive|define
name|DECODE_TEXT
value|0x03
end_define

begin_define
define|#
directive|define
name|SKIP_TRAILING
value|(0x04 | NO_ADVANCE)
end_define

begin_define
define|#
directive|define
name|SKIP_LEADING
value|0x05
end_define

begin_define
define|#
directive|define
name|FOUND_END
value|(0x06 | NO_ADVANCE)
end_define

begin_define
define|#
directive|define
name|DECODE_ERROR
value|(0x07 | NO_ADVANCE)
end_define

begin_define
define|#
directive|define
name|OTHER_ERROR
value|(0x08 | NO_ADVANCE)
end_define

begin_define
define|#
directive|define
name|NEW_BEGIN
value|(0x09 | NO_ADVANCE)
end_define

begin_function
name|void
name|uud_start
parameter_list|()
block|{
name|Xflag
operator|=
name|FALSE
expr_stmt|;
name|expecting_part
operator|=
literal|0
expr_stmt|;
name|seqc
operator|=
name|SEQMAX
expr_stmt|;
name|check
operator|=
literal|1
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|secnd
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|FIND_BEGIN
expr_stmt|;
block|}
end_function

begin_function
name|int
name|uudecode
parameter_list|(
name|in
parameter_list|)
name|FILE
modifier|*
name|in
decl_stmt|;
block|{
name|int
name|mode
decl_stmt|,
name|onedone
decl_stmt|,
name|lens
decl_stmt|;
name|char
name|buff
index|[
name|LBUFLEN
index|]
decl_stmt|;
name|numl
operator|=
name|onedone
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|FIND_BEGIN
condition|)
name|inittbls
argument_list|()
expr_stmt|;
comment|/*      * search for header or translation table line.      */
while|while
condition|(
operator|(
name|state
operator|&
name|NO_ADVANCE
operator|)
operator|||
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|in
argument_list|)
operator|!=
name|Nullch
condition|)
block|{
name|numl
operator|++
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|NEW_BEGIN
case|:
if|if
condition|(
name|decode_fp
operator|!=
name|Nullfp
condition|)
block|{
if|if
condition|(
name|expecting_part
condition|)
block|{
specifier|register
name|int
name|got_part
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|buff
operator|+
literal|6
argument_list|,
literal|"part "
argument_list|,
literal|5
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|buff
operator|+
literal|11
init|;
name|islower
argument_list|(
operator|*
name|bp
argument_list|)
condition|;
name|bp
operator|++
control|)
name|got_part
operator|=
name|got_part
operator|*
literal|26
operator|+
operator|*
name|bp
operator|-
literal|'a'
expr_stmt|;
block|}
if|if
condition|(
name|expecting_part
operator|==
name|got_part
condition|)
block|{
name|state
operator|=
name|DECODE_TEXT
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"Expecting part %d; got part %d.\n"
argument_list|,
name|expecting_part
operator|+
literal|1
argument_list|,
name|got_part
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_part
condition|)
block|{
name|state
operator|=
name|SKIP_LEADING
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|decode_end
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|Xflag
operator|=
name|FALSE
expr_stmt|;
name|expecting_part
operator|=
literal|0
expr_stmt|;
block|}
name|state
operator|=
name|FIND_BEGIN
expr_stmt|;
comment|/* fall thru */
case|case
name|FIND_BEGIN
case|:
case|case
name|AFTER_ERROR_FIND_BEGIN
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|buff
argument_list|,
literal|"table"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|gettable
argument_list|(
name|in
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strnEQ
argument_list|(
name|buff
argument_list|,
literal|"begin "
argument_list|,
literal|6
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|buff
argument_list|,
literal|"Xbegin "
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|lens
operator|=
name|strlen
argument_list|(
name|buff
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|buff
index|[
name|lens
index|]
operator|==
literal|'\n'
condition|)
name|buff
index|[
name|lens
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|buff
operator|+
literal|6
argument_list|,
literal|"%o%s"
argument_list|,
operator|&
name|mode
argument_list|,
name|decode_fname
argument_list|)
operator|!=
literal|2
condition|)
block|{
specifier|register
name|char
modifier|*
name|bp
init|=
name|buff
operator|+
literal|6
decl_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|' '
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|bp
argument_list|,
literal|"part "
argument_list|,
literal|5
argument_list|)
condition|)
block|{
specifier|register
name|int
name|got_part
init|=
literal|0
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|bp
operator|+
literal|5
init|;
name|islower
argument_list|(
operator|*
name|bp
argument_list|)
condition|;
name|bp
operator|++
control|)
name|got_part
operator|=
name|got_part
operator|*
literal|26
operator|+
operator|*
name|bp
operator|-
literal|'a'
expr_stmt|;
name|printf
argument_list|(
literal|"Expecting part 1; got part %d.\n"
argument_list|,
name|got_part
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
continue|continue;
block|}
name|Xflag
operator|=
operator|(
operator|*
name|buff
operator|==
literal|'X'
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|decode_dest
argument_list|,
literal|"%s/%s"
argument_list|,
name|extractdest
argument_list|,
name|decode_fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|decode_fp
operator|=
name|fopen
argument_list|(
name|decode_dest
argument_list|,
name|FOPEN_WB
argument_list|)
operator|)
operator|==
name|Nullfp
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot create file: %s\n"
argument_list|,
name|decode_dest
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|chmod
argument_list|(
name|decode_dest
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Decoding: %s\n"
argument_list|,
name|decode_fname
argument_list|)
expr_stmt|;
name|state
operator|=
name|DECODE_TEXT
expr_stmt|;
block|}
continue|continue;
case|case
name|SKIP_LEADING
case|:
name|state
operator|=
name|decode_line
argument_list|(
name|buff
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DECODE_TEXT
case|:
name|state
operator|=
name|decode_line
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|onedone
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|FOUND_END
case|:
name|fclose
argument_list|(
name|decode_fp
argument_list|)
expr_stmt|;
name|decode_fp
operator|=
name|Nullfp
expr_stmt|;
name|Xflag
operator|=
name|FALSE
expr_stmt|;
name|expecting_part
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|FIND_BEGIN
expr_stmt|;
name|printf
argument_list|(
literal|"Done.\n"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|SKIP_TRAILING
case|:
name|printf
argument_list|(
literal|"(Continued)\n"
argument_list|)
expr_stmt|;
name|state
operator|=
name|SKIP_LEADING
expr_stmt|;
return|return
literal|0
return|;
case|case
name|DECODE_ERROR
case|:
name|state
operator|=
name|SKIP_TRAILING
expr_stmt|;
continue|continue;
case|case
name|OTHER_ERROR
case|:
name|fclose
argument_list|(
name|decode_fp
argument_list|)
expr_stmt|;
name|decode_fp
operator|=
name|Nullfp
expr_stmt|;
name|Xflag
operator|=
name|FALSE
expr_stmt|;
name|expecting_part
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|AFTER_ERROR_FIND_BEGIN
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|onedone
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|DECODE_TEXT
condition|)
block|{
name|printf
argument_list|(
literal|"(Continued)\n"
argument_list|)
expr_stmt|;
name|state
operator|=
name|SKIP_LEADING
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|state
operator|==
name|AFTER_ERROR_FIND_BEGIN
condition|)
return|return
operator|-
literal|1
return|;
name|printf
argument_list|(
literal|"Couldn't find anything to decode.\n"
argument_list|)
expr_stmt|;
name|err
label|:
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * decode one line and write it out using decode_fp  */
end_comment

begin_function
specifier|static
name|int
name|decode_line
parameter_list|(
name|buff
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
block|{
name|char
name|outl
index|[
name|LBUFLEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ut
decl_stmt|;
specifier|register
name|int
modifier|*
name|trtbl
init|=
name|chtbl
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|blen
decl_stmt|;
comment|/* binary length (from decoded file) */
specifier|register
name|int
name|rlen
decl_stmt|;
comment|/* calculated input line length */
specifier|register
name|int
name|len
decl_stmt|;
comment|/* actual input line length */
specifier|register
name|int
name|dash
decl_stmt|;
comment|/* number of '-'s encountered on a line */
comment|/* If it's too high, we reject the line */
define|#
directive|define
name|REJECT
parameter_list|(
name|buf
parameter_list|,
name|rlen
parameter_list|,
name|len
parameter_list|)
define|\
value|((*buf == 'M'&& len> rlen + 5) \ 	 || (*buf != 'M'&& len != rlen&& len != rlen+1) \ 	 || (strnEQ(buf, "BEGIN", 5)) \ 	 || (strnEQ(buf, "END", 3)))
if|if
condition|(
name|Xflag
condition|)
block|{
if|if
condition|(
operator|*
name|buff
operator|==
literal|'X'
condition|)
name|buff
operator|++
expr_stmt|;
else|else
operator|*
name|buff
operator|=
literal|'x'
expr_stmt|;
comment|/* force a mis-parse of a non-x'ed line */
block|}
name|len
operator|=
name|strlen
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|len
operator|<=
literal|0
condition|)
return|return
name|state
return|;
name|buff
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * Get the binary line length.      */
if|if
condition|(
operator|(
name|blen
operator|=
name|trtbl
index|[
name|buff
index|[
literal|0
index|]
index|]
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|SKIP_LEADING
condition|)
block|{
if|if
condition|(
name|strnEQ
argument_list|(
name|buff
argument_list|,
literal|"begin "
argument_list|,
literal|6
argument_list|)
condition|)
return|return
name|NEW_BEGIN
return|;
return|return
name|SKIP_LEADING
return|;
block|}
comment|/* 	 * end of uuencoded file ? 	 */
if|if
condition|(
name|strnEQ
argument_list|(
name|buff
argument_list|,
literal|"end"
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FOUND_END
return|;
comment|/* 	 * end of current file ? : get next one. 	 */
if|if
condition|(
name|strnEQ
argument_list|(
name|buff
argument_list|,
literal|"include "
argument_list|,
literal|8
argument_list|)
condition|)
block|{
for|for
control|(
name|bp
operator|=
name|buff
operator|+
literal|8
init|;
operator|*
name|bp
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'u'
condition|)
block|{
name|expecting_part
operator|=
operator|(
name|bp
index|[
literal|2
index|]
operator|-
literal|'a'
operator|)
operator|*
literal|26
operator|+
name|bp
index|[
literal|3
index|]
operator|-
literal|'a'
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * trailing garbage 	 */
return|return
name|SKIP_TRAILING
return|;
block|}
name|rlen
operator|=
name|cdlen
index|[
name|blen
index|]
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|SKIP_LEADING
operator|&&
name|REJECT
argument_list|(
name|buff
argument_list|,
name|rlen
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|SKIP_LEADING
return|;
comment|/*      * Is it the empty line before the end line ?      */
if|if
condition|(
name|blen
operator|==
literal|0
condition|)
return|return
name|state
return|;
if|if
condition|(
name|REJECT
argument_list|(
name|buff
argument_list|,
name|rlen
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|SKIP_TRAILING
return|;
comment|/*      * Pad with blanks.      */
for|for
control|(
name|bp
operator|=
name|buff
operator|+
name|len
operator|,
name|n
operator|=
name|rlen
operator|-
name|len
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
control|)
operator|*
name|bp
operator|++
operator|=
name|blank
expr_stmt|;
comment|/*      * Verify      */
for|for
control|(
name|n
operator|=
name|rlen
operator|,
name|bp
operator|=
name|buff
operator|,
name|dash
operator|=
literal|0
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
name|trtbl
index|[
operator|*
name|bp
index|]
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|SKIP_LEADING
condition|)
return|return
name|SKIP_LEADING
return|;
return|return
name|DECODE_ERROR
return|;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'-'
condition|)
name|dash
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dash
operator|*
literal|100
operator|/
name|rlen
operator|>
literal|33
condition|)
comment|/* more than 1/3 dashes? */
if|if
condition|(
name|state
operator|==
name|SKIP_LEADING
condition|)
return|return
name|SKIP_LEADING
return|;
comment|/* -> reject */
else|else
return|return
name|SKIP_TRAILING
return|;
comment|/*      * Check for uuencodes that append a 'z' to each line....      */
if|if
condition|(
name|check
condition|)
if|if
condition|(
name|secnd
condition|)
block|{
name|secnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buff
index|[
name|rlen
index|]
operator|==
name|SEQMAX
condition|)
name|check
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|secnd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|buff
index|[
name|rlen
index|]
operator|!=
name|SEQMAX
condition|)
name|check
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * There we check.      */
if|if
condition|(
name|check
condition|)
block|{
if|if
condition|(
name|buff
index|[
name|rlen
index|]
operator|!=
name|seqc
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|SKIP_LEADING
condition|)
return|return
name|SKIP_LEADING
return|;
return|return
name|DECODE_ERROR
return|;
block|}
if|if
condition|(
operator|--
name|seqc
operator|<
name|SEQMIN
condition|)
name|seqc
operator|=
name|SEQMAX
expr_stmt|;
block|}
comment|/*      * output a group of 3 bytes (4 input characters).      * the input chars are pointed to by p, they are to      * be output to file f. blen is used to tell us not to      * output all of them at the end of the file.      */
name|ut
operator|=
name|outl
expr_stmt|;
name|n
operator|=
name|blen
expr_stmt|;
name|bp
operator|=
operator|&
name|buff
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
operator|*
operator|(
name|ut
operator|++
operator|)
operator|=
name|trtbl
index|[
operator|*
name|bp
index|]
operator|<<
literal|2
operator||
name|trtbl
index|[
name|bp
index|[
literal|1
index|]
index|]
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|ut
operator|++
operator|)
operator|=
operator|(
name|trtbl
index|[
name|bp
index|[
literal|1
index|]
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|trtbl
index|[
name|bp
index|[
literal|2
index|]
index|]
operator|>>
literal|2
operator|)
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|ut
operator|++
operator|)
operator|=
name|trtbl
index|[
name|bp
index|[
literal|2
index|]
index|]
operator|<<
literal|6
operator||
name|trtbl
index|[
name|bp
index|[
literal|3
index|]
index|]
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
name|bp
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|outl
argument_list|,
literal|1
argument_list|,
name|blen
argument_list|,
name|decode_fp
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Error on writing decoded file\n"
argument_list|)
expr_stmt|;
return|return
name|OTHER_ERROR
return|;
block|}
return|return
name|DECODE_TEXT
return|;
block|}
end_function

begin_comment
comment|/*  * Install the table in memory for later use.  */
end_comment

begin_function
specifier|static
name|void
name|inittbls
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/*      * Set up the default translation table.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|' '
condition|;
name|i
operator|++
control|)
name|chtbl
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|' '
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|' '
operator|+
literal|64
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|chtbl
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|' '
operator|+
literal|64
init|;
name|i
operator|<
name|MAXCHAR
condition|;
name|i
operator|++
control|)
name|chtbl
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|chtbl
index|[
literal|'`'
index|]
operator|=
name|chtbl
index|[
literal|' '
index|]
expr_stmt|;
comment|/* common mutation */
name|chtbl
index|[
literal|'~'
index|]
operator|=
name|chtbl
index|[
literal|'^'
index|]
expr_stmt|;
comment|/* another common mutation */
name|blank
operator|=
literal|' '
expr_stmt|;
comment|/*      * set up the line length table, to avoid computing lotsa * and / ...      */
name|cdlen
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
literal|5
init|;
name|i
operator|<=
name|NORMLEN
condition|;
name|i
operator|+=
literal|3
operator|,
name|j
operator|+=
literal|4
control|)
name|cdlen
index|[
name|i
index|]
operator|=
operator|(
name|cdlen
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
name|cdlen
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|j
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gettable
parameter_list|(
name|in
parameter_list|)
name|FILE
modifier|*
name|in
decl_stmt|;
block|{
name|char
name|buff
index|[
name|LBUFLEN
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|cpt
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|MAXCHAR
condition|;
name|c
operator|++
control|)
name|chtbl
index|[
name|c
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|in
argument_list|)
operator|==
name|Nullch
condition|)
block|{
name|printf
argument_list|(
literal|"EOF while in translation table.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|numl
operator|++
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|buff
argument_list|,
literal|"begin"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Incomplete translation table.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cpt
operator|=
name|buff
operator|+
name|strlen
argument_list|(
name|buff
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|*
name|cpt
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|*
name|cpt
operator|==
literal|' '
condition|)
block|{
operator|*
name|cpt
operator|=
literal|0
expr_stmt|;
name|cpt
operator|--
expr_stmt|;
block|}
name|cpt
operator|=
name|buff
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|cpt
condition|)
block|{
if|if
condition|(
name|chtbl
index|[
name|c
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Duplicate char in translation table.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|blank
operator|=
name|c
expr_stmt|;
name|chtbl
index|[
name|c
index|]
operator|=
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|64
condition|)
return|return;
name|cpt
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

