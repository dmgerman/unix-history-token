begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: term.c,v 3.0 1992/02/01 03:09:32 davison Trn $  */
end_comment

begin_comment
comment|/* This software is Copyright 1991 by Stan Barber.   *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"help.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_decl_stmt
name|char
name|ERASECH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rubout character */
end_comment

begin_decl_stmt
name|char
name|KILLCH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line delete character */
end_comment

begin_decl_stmt
name|char
name|tcarea
index|[
name|TCSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* area for "compiled" termcap strings */
end_comment

begin_decl_stmt
name|int
name|upcost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* guarantee capability pointer != Nullch */
end_comment

begin_comment
comment|/* (I believe terminfo will ignore the&tmpaddr argument.) */
end_comment

begin_function_decl
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|Tgetstr
parameter_list|(
name|key
parameter_list|)
value|((tmpstr = tgetstr(key,&tmpaddr)) ? tmpstr : nullstr)
end_define

begin_struct
struct|struct
name|keymap
block|{
name|char
name|km_type
index|[
literal|128
index|]
decl_stmt|;
union|union
name|km_union
block|{
name|struct
name|keymap
modifier|*
name|km_km
decl_stmt|;
name|char
modifier|*
name|km_str
decl_stmt|;
block|}
name|km_ptr
index|[
literal|128
index|]
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|KM_NOTHIN
value|0
end_define

begin_define
define|#
directive|define
name|KM_STRING
value|1
end_define

begin_define
define|#
directive|define
name|KM_KEYMAP
value|2
end_define

begin_define
define|#
directive|define
name|KM_BOGUS
value|3
end_define

begin_define
define|#
directive|define
name|KM_TMASK
value|3
end_define

begin_define
define|#
directive|define
name|KM_GSHIFT
value|4
end_define

begin_define
define|#
directive|define
name|KM_GMASK
value|7
end_define

begin_typedef
typedef|typedef
name|struct
name|keymap
name|KEYMAP
typedef|;
end_typedef

begin_decl_stmt
name|KEYMAP
modifier|*
name|topmap
name|INIT
argument_list|(
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|mac_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|KEYMAP
modifier|*
name|newkeymap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|show_keymap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|line_col_calcs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* terminal initialization */
end_comment

begin_function
name|void
name|term_init
parameter_list|()
block|{
name|savetty
argument_list|()
expr_stmt|;
comment|/* remember current tty state */
ifdef|#
directive|ifdef
name|I_TERMIO
name|outspeed
operator|=
name|_tty
operator|.
name|c_cflag
operator|&
name|CBAUD
expr_stmt|;
comment|/* for tputs() */
name|ERASECH
operator|=
name|_tty
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
comment|/* for finish_command() */
name|KILLCH
operator|=
name|_tty
operator|.
name|c_cc
index|[
name|VKILL
index|]
expr_stmt|;
comment|/* for finish_command() */
if|if
condition|(
name|GT
operator|=
operator|(
operator|(
name|_tty
operator|.
name|c_oflag
operator|&
name|TABDLY
operator|)
operator|!=
name|TAB3
operator|)
condition|)
comment|/* we have tabs, so that's OK */
empty_stmt|;
else|else
name|_tty
operator|.
name|c_oflag
operator|&=
operator|~
name|TAB3
expr_stmt|;
comment|/* turn off kernel tabbing -- done in rn */
else|#
directive|else
comment|/* !I_TERMIO */
ifdef|#
directive|ifdef
name|I_TERMIOS
name|outspeed
operator|=
name|cfgetospeed
argument_list|(
operator|&
name|_tty
argument_list|)
expr_stmt|;
comment|/* for tputs() (output) */
name|ERASECH
operator|=
name|_tty
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
comment|/* for finish_command() */
name|KILLCH
operator|=
name|_tty
operator|.
name|c_cc
index|[
name|VKILL
index|]
expr_stmt|;
comment|/* for finish_command() */
comment|/*    _tty.c_oflag&= ~OXTABS;		/* turn off kernel tabbing-done in rn */
else|#
directive|else
comment|/* !I_TERMIOS */
name|outspeed
operator|=
name|_tty
operator|.
name|sg_ospeed
expr_stmt|;
comment|/* for tputs() */
name|ERASECH
operator|=
name|_tty
operator|.
name|sg_erase
expr_stmt|;
comment|/* for finish_command() */
name|KILLCH
operator|=
name|_tty
operator|.
name|sg_kill
expr_stmt|;
comment|/* for finish_command() */
if|if
condition|(
name|GT
operator|=
operator|(
operator|(
name|_tty
operator|.
name|sg_flags
operator|&
name|XTABS
operator|)
operator|!=
name|XTABS
operator|)
condition|)
comment|/* we have tabs, so that's OK */
empty_stmt|;
else|else
name|_tty
operator|.
name|sg_flags
operator|&=
operator|~
name|XTABS
expr_stmt|;
endif|#
directive|endif
comment|/* I_TERMIOS */
endif|#
directive|endif
comment|/* I_TERMIO */
comment|/* The following could be a table but I can't be sure that there isn't */
comment|/* some degree of sparsity out there in the world. */
switch|switch
condition|(
name|outspeed
condition|)
block|{
comment|/* 1 second of padding */
ifdef|#
directive|ifdef
name|BEXTA
case|case
name|BEXTA
case|:
name|just_a_sec
operator|=
literal|1920
expr_stmt|;
break|break;
else|#
directive|else
ifdef|#
directive|ifdef
name|B19200
case|case
name|B19200
case|:
name|just_a_sec
operator|=
literal|1920
expr_stmt|;
break|break;
endif|#
directive|endif
endif|#
directive|endif
case|case
name|B9600
case|:
name|just_a_sec
operator|=
literal|960
expr_stmt|;
break|break;
case|case
name|B4800
case|:
name|just_a_sec
operator|=
literal|480
expr_stmt|;
break|break;
case|case
name|B2400
case|:
name|just_a_sec
operator|=
literal|240
expr_stmt|;
break|break;
case|case
name|B1800
case|:
name|just_a_sec
operator|=
literal|180
expr_stmt|;
break|break;
case|case
name|B1200
case|:
name|just_a_sec
operator|=
literal|120
expr_stmt|;
break|break;
case|case
name|B600
case|:
name|just_a_sec
operator|=
literal|60
expr_stmt|;
break|break;
case|case
name|B300
case|:
name|just_a_sec
operator|=
literal|30
expr_stmt|;
break|break;
comment|/* do I really have to type the rest of this??? */
case|case
name|B200
case|:
name|just_a_sec
operator|=
literal|20
expr_stmt|;
break|break;
case|case
name|B150
case|:
name|just_a_sec
operator|=
literal|15
expr_stmt|;
break|break;
case|case
name|B134
case|:
name|just_a_sec
operator|=
literal|13
expr_stmt|;
break|break;
case|case
name|B110
case|:
name|just_a_sec
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|B75
case|:
name|just_a_sec
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|B50
case|:
name|just_a_sec
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
name|just_a_sec
operator|=
literal|960
expr_stmt|;
break|break;
comment|/* if we are running detached I */
block|}
comment|/*  don't want to know about it! */
block|}
end_function

begin_comment
comment|/* set terminal characteristics */
end_comment

begin_function
name|void
name|term_set
parameter_list|(
name|tcbuf
parameter_list|)
name|char
modifier|*
name|tcbuf
decl_stmt|;
comment|/* temp area for "uncompiled" termcap entry */
block|{
name|char
modifier|*
name|tmpaddr
decl_stmt|;
comment|/* must not be register */
specifier|register
name|char
modifier|*
name|tmpstr
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|struct
name|winsize
name|winsize
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PENDING
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FIONREAD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_RDCHK
argument_list|)
comment|/* do no delay reads on something that always gets closed on exit */
name|devtty
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|devtty
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
argument|cantopen
argument_list|,
literal|"/dev/tty"
argument_list|)
name|FLUSH
expr_stmt|;
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fcntl
argument_list|(
name|devtty
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* get all that good termcap stuff */
ifdef|#
directive|ifdef
name|HAS_TERMLIB
name|status
operator|=
name|tgetent
argument_list|(
name|tcbuf
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get termcap entry */
if|if
condition|(
name|status
operator|<
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"No termcap %s found.\n"
argument_list|,
argument|status ?
literal|"file"
argument|:
literal|"entry"
argument_list|)
name|FLUSH
expr_stmt|;
else|#
directive|else
name|fputs
argument_list|(
literal|"Termcap botch\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tmpaddr
operator|=
name|tcarea
expr_stmt|;
comment|/* set up strange tgetstr pointer */
name|s
operator|=
name|Tgetstr
argument_list|(
literal|"pc"
argument_list|)
expr_stmt|;
comment|/* get pad character */
name|PC
operator|=
operator|*
name|s
expr_stmt|;
comment|/* get it where tputs wants it */
if|if
condition|(
operator|!
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
condition|)
block|{
comment|/* is backspace not used? */
name|BC
operator|=
name|Tgetstr
argument_list|(
literal|"bc"
argument_list|)
expr_stmt|;
comment|/* find out what is */
if|if
condition|(
name|BC
operator|==
name|nullstr
condition|)
comment|/* terminfo grok's 'bs' but not 'bc' */
name|BC
operator|=
name|Tgetstr
argument_list|(
literal|"le"
argument_list|)
expr_stmt|;
block|}
else|else
name|BC
operator|=
literal|"\b"
expr_stmt|;
comment|/* make a backspace handy */
name|UP
operator|=
name|Tgetstr
argument_list|(
literal|"up"
argument_list|)
expr_stmt|;
comment|/* move up a line */
if|if
condition|(
operator|!
operator|*
name|UP
condition|)
comment|/* no UP string? */
name|marking
operator|=
literal|0
expr_stmt|;
comment|/* disable any marking */
if|if
condition|(
name|muck_up_clear
condition|)
comment|/* this is for weird HPs */
name|CL
operator|=
literal|"\n\n\n\n"
expr_stmt|;
else|else
name|CL
operator|=
name|Tgetstr
argument_list|(
literal|"cl"
argument_list|)
expr_stmt|;
comment|/* get clear string */
name|CE
operator|=
name|Tgetstr
argument_list|(
literal|"ce"
argument_list|)
expr_stmt|;
comment|/* clear to end of line string */
name|TI
operator|=
name|Tgetstr
argument_list|(
literal|"ti"
argument_list|)
expr_stmt|;
comment|/* initialize display */
name|TE
operator|=
name|Tgetstr
argument_list|(
literal|"te"
argument_list|)
expr_stmt|;
comment|/* reset display */
name|HO
operator|=
name|Tgetstr
argument_list|(
literal|"ho"
argument_list|)
expr_stmt|;
comment|/* home cursor if no CM */
name|CM
operator|=
name|Tgetstr
argument_list|(
literal|"cm"
argument_list|)
expr_stmt|;
comment|/* cursor motion */
if|if
condition|(
operator|*
name|CM
operator|||
operator|*
name|HO
condition|)
name|can_home
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAREOL
name|CD
operator|=
name|Tgetstr
argument_list|(
literal|"cd"
argument_list|)
expr_stmt|;
comment|/* clear to end of display */
if|if
condition|(
operator|!
operator|*
name|CE
operator|||
operator|!
operator|*
name|CD
operator|||
operator|!
name|can_home
condition|)
comment|/* can we CE, CD, and home? */
name|can_home_clear
operator|=
name|FALSE
expr_stmt|;
comment|/*  no, so disable use of clear eol */
if|if
condition|(
operator|!
operator|*
name|CE
condition|)
name|CE
operator|=
name|CD
expr_stmt|;
endif|#
directive|endif
comment|/* CLEAREOL */
name|upcost
operator|=
name|strlen
argument_list|(
name|UP
argument_list|)
expr_stmt|;
name|SO
operator|=
name|Tgetstr
argument_list|(
literal|"so"
argument_list|)
expr_stmt|;
comment|/* begin standout */
name|SE
operator|=
name|Tgetstr
argument_list|(
literal|"se"
argument_list|)
expr_stmt|;
comment|/* end standout */
if|if
condition|(
operator|(
name|SG
operator|=
name|tgetnum
argument_list|(
literal|"sg"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|SG
operator|=
literal|0
expr_stmt|;
comment|/* blanks left by SG, SE */
name|US
operator|=
name|Tgetstr
argument_list|(
literal|"us"
argument_list|)
expr_stmt|;
comment|/* start underline */
name|UE
operator|=
name|Tgetstr
argument_list|(
literal|"ue"
argument_list|)
expr_stmt|;
comment|/* end underline */
if|if
condition|(
operator|(
name|UG
operator|=
name|tgetnum
argument_list|(
literal|"ug"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|UG
operator|=
literal|0
expr_stmt|;
comment|/* blanks left by US, UE */
if|if
condition|(
operator|*
name|US
condition|)
name|UC
operator|=
name|nullstr
expr_stmt|;
comment|/* UC must not be NULL */
else|else
name|UC
operator|=
name|Tgetstr
argument_list|(
literal|"uc"
argument_list|)
expr_stmt|;
comment|/* underline a character */
if|if
condition|(
operator|!
operator|*
name|US
operator|&&
operator|!
operator|*
name|UC
condition|)
block|{
comment|/* no underline mode? */
name|US
operator|=
name|SO
expr_stmt|;
comment|/* substitute standout mode */
name|UE
operator|=
name|SE
expr_stmt|;
name|UG
operator|=
name|SG
expr_stmt|;
block|}
name|LINES
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
comment|/* lines per page */
name|COLS
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
comment|/* columns on page */
ifdef|#
directive|ifdef
name|TIOCGWINSZ
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|>=
literal|0
operator|&&
name|ws
operator|.
name|ws_row
operator|>
literal|0
operator|&&
name|ws
operator|.
name|ws_col
operator|>
literal|0
condition|)
block|{
name|LINES
operator|=
name|ws
operator|.
name|ws_row
expr_stmt|;
name|COLS
operator|=
name|ws
operator|.
name|ws_col
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|AM
operator|=
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
expr_stmt|;
comment|/* terminal wraps automatically? */
name|XN
operator|=
name|tgetflag
argument_list|(
literal|"xn"
argument_list|)
expr_stmt|;
comment|/* then eats next newline? */
name|VB
operator|=
name|Tgetstr
argument_list|(
literal|"vb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|VB
condition|)
name|VB
operator|=
literal|"\007"
expr_stmt|;
name|CR
operator|=
name|Tgetstr
argument_list|(
literal|"cr"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|CR
condition|)
block|{
if|if
condition|(
name|tgetflag
argument_list|(
literal|"nc"
argument_list|)
operator|&&
operator|*
name|UP
condition|)
block|{
name|CR
operator|=
name|safemalloc
argument_list|(
operator|(
name|MEM_SIZE
operator|)
name|strlen
argument_list|(
name|UP
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|CR
argument_list|,
literal|"%s\r"
argument_list|,
name|UP
argument_list|)
expr_stmt|;
block|}
else|else
name|CR
operator|=
literal|"\r"
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TIOCGWINSZ
if|if
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|winsize
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|winsize
operator|.
name|ws_row
operator|>
literal|0
condition|)
name|LINES
operator|=
name|winsize
operator|.
name|ws_row
expr_stmt|;
if|if
condition|(
name|winsize
operator|.
name|ws_col
operator|>
literal|0
condition|)
name|COLS
operator|=
name|winsize
operator|.
name|ws_col
expr_stmt|;
block|}
endif|#
directive|endif
else|#
directive|else
operator|??????
comment|/* Roll your own... */
endif|#
directive|endif
name|termlib_init
argument_list|()
expr_stmt|;
name|line_col_calcs
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
comment|/* turn off echo */
name|crmode
argument_list|()
expr_stmt|;
comment|/* enter cbreak mode */
name|mac_init
argument_list|(
name|tcbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_macro
parameter_list|(
name|seq
parameter_list|,
name|def
parameter_list|)
name|char
modifier|*
name|seq
decl_stmt|;
comment|/* input sequence of keys */
name|char
modifier|*
name|def
decl_stmt|;
comment|/* definition */
block|{
name|mac_line
argument_list|(
name|def
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* check for common (?) brain damage: ku/kd/etc sequence may be the      * cursor move sequence instead of the input sequence.      * (This happens on the local xterm definitions.)      * Try to recognize and adjust for this case.      */
if|if
condition|(
operator|(
name|seq
index|[
literal|0
index|]
operator|==
operator|(
name|char
operator|)
literal|27
operator|)
operator|&&
operator|(
name|seq
index|[
literal|1
index|]
operator|==
literal|'['
operator|)
operator|&&
name|seq
index|[
literal|2
index|]
condition|)
block|{
name|char
name|lbuf
index|[
name|LBUFLEN
index|]
decl_stmt|;
comment|/* copy of possibly non-writable string */
name|strcpy
argument_list|(
name|lbuf
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|lbuf
index|[
literal|1
index|]
operator|=
literal|'O'
expr_stmt|;
name|mac_line
argument_list|(
name|def
argument_list|,
name|lbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|seq
index|[
literal|0
index|]
operator|==
operator|(
name|char
operator|)
literal|27
operator|)
operator|&&
operator|(
name|seq
index|[
literal|1
index|]
operator|==
literal|'O'
operator|)
operator|&&
name|seq
index|[
literal|2
index|]
condition|)
block|{
name|char
name|lbuf
index|[
name|LBUFLEN
index|]
decl_stmt|;
comment|/* copy of possibly non-writable string */
name|strcpy
argument_list|(
name|lbuf
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|lbuf
index|[
literal|1
index|]
operator|=
literal|'['
expr_stmt|;
name|mac_line
argument_list|(
name|def
argument_list|,
name|lbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Turn the arrow keys into macros that do some basic trn functions. ** Code provided by Clifford Adams. */
end_comment

begin_function
name|void
name|arrow_macros
parameter_list|(
name|tmpbuf
parameter_list|)
name|char
modifier|*
name|tmpbuf
decl_stmt|;
block|{
name|char
name|lbuf
index|[
literal|256
index|]
decl_stmt|;
comment|/* should be long enough */
name|char
modifier|*
name|tmpaddr
init|=
name|tmpbuf
decl_stmt|;
specifier|register
name|char
modifier|*
name|tmpstr
decl_stmt|;
comment|/* If arrows are defined as single keys, we probably don't      * want to redefine them.  (The tvi912c defines kl as ^H)      */
name|strcpy
argument_list|(
name|lbuf
argument_list|,
name|Tgetstr
argument_list|(
literal|"ku"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* up */
comment|/* '(' at article or pager, 'p' otherwise */
if|if
condition|(
name|strlen
argument_list|(
name|lbuf
argument_list|)
operator|>
literal|1
condition|)
name|set_macro
argument_list|(
name|lbuf
argument_list|,
literal|"%(%m=[ap]?\\(:p)"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lbuf
argument_list|,
name|Tgetstr
argument_list|(
literal|"kd"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* down */
comment|/* ')' at article or pager, 'n' otherwise */
if|if
condition|(
name|strlen
argument_list|(
name|lbuf
argument_list|)
operator|>
literal|1
condition|)
name|set_macro
argument_list|(
name|lbuf
argument_list|,
literal|"%(%m=[ap]?\\):n)"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lbuf
argument_list|,
name|Tgetstr
argument_list|(
literal|"kl"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* left */
comment|/* '[' at article or pager, '<' otherwise */
if|if
condition|(
name|strlen
argument_list|(
name|lbuf
argument_list|)
operator|>
literal|1
condition|)
name|set_macro
argument_list|(
name|lbuf
argument_list|,
literal|"%(%m=[ap]?\\[:<)"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lbuf
argument_list|,
name|Tgetstr
argument_list|(
literal|"kr"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* right */
comment|/* CR at newsgroups, ']' at article or pager, '>' otherwise */
if|if
condition|(
name|strlen
argument_list|(
name|lbuf
argument_list|)
operator|>
literal|1
condition|)
name|set_macro
argument_list|(
name|lbuf
argument_list|,
literal|"%(%m=n?^j:%(%m=[ap]?\\]:>))"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mac_init
parameter_list|(
name|tcbuf
parameter_list|)
name|char
modifier|*
name|tcbuf
decl_stmt|;
block|{
name|char
name|tmpbuf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|auto_arrow_macros
condition|)
name|arrow_macros
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_threads
condition|)
name|tmpfp
operator|=
name|fopen
argument_list|(
name|filexp
argument_list|(
name|getval
argument_list|(
literal|"TRNMACRO"
argument_list|,
name|TRNMACRO
argument_list|)
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
name|tmpfp
operator|=
name|Nullfp
expr_stmt|;
if|if
condition|(
operator|!
name|tmpfp
condition|)
name|tmpfp
operator|=
name|fopen
argument_list|(
name|filexp
argument_list|(
name|getval
argument_list|(
literal|"RNMACRO"
argument_list|,
name|RNMACRO
argument_list|)
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfp
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|tcbuf
argument_list|,
literal|1024
argument_list|,
name|tmpfp
argument_list|)
operator|!=
name|Nullch
condition|)
block|{
name|mac_line
argument_list|(
name|tcbuf
argument_list|,
name|tmpbuf
argument_list|,
operator|(
sizeof|sizeof
name|tmpbuf
operator|)
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tmpfp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mac_line
parameter_list|(
name|line
parameter_list|,
name|tmpbuf
parameter_list|,
name|tbsize
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|tmpbuf
decl_stmt|;
name|int
name|tbsize
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|m
decl_stmt|;
specifier|register
name|KEYMAP
modifier|*
name|curmap
decl_stmt|;
specifier|register
name|int
name|ch
decl_stmt|;
specifier|register
name|int
name|garbage
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|override
index|[]
init|=
literal|"\nkeymap overrides string\n"
decl_stmt|;
if|if
condition|(
name|topmap
operator|==
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
condition|)
name|topmap
operator|=
name|newkeymap
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'#'
operator|||
operator|*
name|line
operator|==
literal|'\n'
condition|)
return|return;
if|if
condition|(
name|line
index|[
name|ch
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
name|ch
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* A 0 length signifies we already parsed the macro into tmpbuf,     ** so line is just the definition. */
if|if
condition|(
name|tbsize
condition|)
name|m
operator|=
name|dointerp
argument_list|(
name|tmpbuf
argument_list|,
name|tbsize
argument_list|,
name|line
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|m
condition|)
return|return;
while|while
condition|(
operator|*
name|m
operator|==
literal|' '
operator|||
operator|*
name|m
operator|==
literal|'\t'
condition|)
name|m
operator|++
expr_stmt|;
for|for
control|(
name|s
operator|=
name|tmpbuf
operator|,
name|curmap
operator|=
name|topmap
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|ch
operator|=
operator|*
name|s
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'+'
operator|&&
name|isdigit
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
name|garbage
operator|=
operator|(
operator|*
name|s
operator|&
name|KM_GMASK
operator|)
operator|<<
name|KM_GSHIFT
expr_stmt|;
block|}
else|else
name|garbage
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|curmap
operator|->
name|km_type
index|[
name|ch
index|]
operator|&
name|KM_TMASK
operator|)
operator|==
name|KM_STRING
condition|)
block|{
if|if
condition|(
name|tbsize
condition|)
name|fputs
argument_list|(
argument|override
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|free
argument_list|(
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_str
argument_list|)
expr_stmt|;
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_str
operator|=
name|Nullch
expr_stmt|;
block|}
name|curmap
operator|->
name|km_type
index|[
name|ch
index|]
operator|=
name|KM_KEYMAP
operator|+
name|garbage
expr_stmt|;
if|if
condition|(
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_km
operator|==
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
condition|)
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_km
operator|=
name|newkeymap
argument_list|()
expr_stmt|;
name|curmap
operator|=
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_km
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tbsize
operator|&&
operator|(
name|curmap
operator|->
name|km_type
index|[
name|ch
index|]
operator|&
name|KM_TMASK
operator|)
operator|==
name|KM_KEYMAP
condition|)
name|fputs
argument_list|(
argument|override
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
else|else
block|{
name|curmap
operator|->
name|km_type
index|[
name|ch
index|]
operator|=
name|KM_STRING
operator|+
name|garbage
expr_stmt|;
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_str
operator|=
name|savestr
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|KEYMAP
modifier|*
name|newkeymap
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|KEYMAP
modifier|*
name|map
decl_stmt|;
ifndef|#
directive|ifndef
name|lint
name|map
operator|=
operator|(
name|KEYMAP
operator|*
operator|)
name|safemalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|KEYMAP
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|map
operator|=
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* lint */
for|for
control|(
name|i
operator|=
literal|127
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|map
operator|->
name|km_ptr
index|[
name|i
index|]
operator|.
name|km_km
operator|=
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
expr_stmt|;
name|map
operator|->
name|km_type
index|[
name|i
index|]
operator|=
name|KM_NOTHIN
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
end_function

begin_function
name|void
name|show_macros
parameter_list|()
block|{
name|char
name|prebuf
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|topmap
operator|!=
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
condition|)
block|{
name|print_lines
argument_list|(
literal|"Macros:\n"
argument_list|,
name|STANDOUT
argument_list|)
expr_stmt|;
operator|*
name|prebuf
operator|=
literal|'\0'
expr_stmt|;
name|show_keymap
argument_list|(
name|topmap
argument_list|,
name|prebuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_lines
argument_list|(
literal|"No macros defined.\n"
argument_list|,
name|NOMARKING
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|show_keymap
parameter_list|(
name|curmap
parameter_list|,
name|prefix
parameter_list|)
specifier|register
name|KEYMAP
modifier|*
name|curmap
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|next
init|=
name|prefix
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
specifier|register
name|int
name|kt
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|=
name|curmap
operator|->
name|km_type
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|' '
condition|)
name|sprintf
argument_list|(
name|next
argument_list|,
literal|"^%c"
argument_list|,
name|i
operator|+
literal|64
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|' '
condition|)
name|strcpy
argument_list|(
name|next
argument_list|,
literal|"\\040"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|127
condition|)
name|strcpy
argument_list|(
name|next
argument_list|,
literal|"^?"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|next
argument_list|,
literal|"%c"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kt
operator|>>
name|KM_GSHIFT
operator|)
operator|&
name|KM_GMASK
condition|)
block|{
name|sprintf
argument_list|(
name|cmd_buf
argument_list|,
literal|"+%d"
argument_list|,
operator|(
name|kt
operator|>>
name|KM_GSHIFT
operator|)
operator|&
name|KM_GMASK
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|next
argument_list|,
name|cmd_buf
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|kt
operator|&
name|KM_TMASK
condition|)
block|{
case|case
name|KM_NOTHIN
case|:
name|sprintf
argument_list|(
name|cmd_buf
argument_list|,
literal|"%s	%c\n"
argument_list|,
name|prefix
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print_lines
argument_list|(
name|cmd_buf
argument_list|,
name|NOMARKING
argument_list|)
expr_stmt|;
break|break;
case|case
name|KM_KEYMAP
case|:
name|show_keymap
argument_list|(
name|curmap
operator|->
name|km_ptr
index|[
operator|(
name|char
operator|)
name|i
index|]
operator|.
name|km_km
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
break|break;
case|case
name|KM_STRING
case|:
name|sprintf
argument_list|(
name|cmd_buf
argument_list|,
literal|"%s	%s\n"
argument_list|,
name|prefix
argument_list|,
name|curmap
operator|->
name|km_ptr
index|[
name|i
index|]
operator|.
name|km_str
argument_list|)
expr_stmt|;
name|print_lines
argument_list|(
name|cmd_buf
argument_list|,
name|NOMARKING
argument_list|)
expr_stmt|;
break|break;
case|case
name|KM_BOGUS
case|:
name|sprintf
argument_list|(
name|cmd_buf
argument_list|,
literal|"%s	BOGUS\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|print_lines
argument_list|(
name|cmd_buf
argument_list|,
name|STANDOUT
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* routine to pass to tputs */
end_comment

begin_function
name|char
name|putchr
parameter_list|(
name|ch
parameter_list|)
specifier|register
name|char_int
name|ch
decl_stmt|;
block|{
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|ch
operator|=
name|Null
argument_list|(
name|char
argument_list|)
expr_stmt|;
name|ch
operator|=
name|ch
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|char
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* input the 2nd and succeeding characters of a multi-character command */
end_comment

begin_comment
comment|/* returns TRUE if command finished, FALSE if they rubbed out first character */
end_comment

begin_decl_stmt
name|int
name|buflimit
init|=
name|LBUFLEN
decl_stmt|;
end_decl_stmt

begin_function
name|bool
name|finish_command
parameter_list|(
name|donewline
parameter_list|)
name|int
name|donewline
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|bool
name|quoteone
init|=
name|FALSE
decl_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|!=
name|FINISHCMD
condition|)
comment|/* someone faking up a command? */
return|return
name|TRUE
return|;
do|do
block|{
name|top
label|:
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|<
literal|' '
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|s
operator||
literal|64
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\177'
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
comment|/* echo previous character */
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|-
name|buf
operator|==
name|buflimit
condition|)
break|break;
name|re_read
label|:
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|getcmd
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|quoteone
condition|)
block|{
name|quoteone
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|errno
operator|||
operator|*
name|s
operator|==
literal|'\f'
condition|)
block|{
operator|*
name|s
operator|=
name|Ctl
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
comment|/* force rewrite on CONT */
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\033'
condition|)
block|{
comment|/* substitution desired? */
ifdef|#
directive|ifdef
name|ESCSUBS
name|char
name|tmpbuf
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|cpybuf
decl_stmt|;
name|tmpbuf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|read_tty
argument_list|(
operator|&
name|tmpbuf
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RAWONLY
name|tmpbuf
index|[
literal|1
index|]
operator|&=
literal|0177
expr_stmt|;
endif|#
directive|endif
name|tmpbuf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tmpbuf
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
block|{
operator|(
name|void
operator|)
name|help_subs
argument_list|()
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|reprint
argument_list|()
expr_stmt|;
goto|goto
name|re_read
goto|;
block|}
elseif|else
if|if
condition|(
name|tmpbuf
index|[
literal|1
index|]
operator|==
literal|'\033'
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|cpybuf
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|interp
argument_list|(
name|buf
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|)
argument_list|,
name|cpybuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cpybuf
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|reprint
argument_list|()
expr_stmt|;
goto|goto
name|re_read
goto|;
block|}
else|else
block|{
name|interp
argument_list|(
name|s
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|)
operator|-
operator|(
name|s
operator|-
name|buf
operator|)
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|s
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
goto|goto
name|re_read
goto|;
else|#
directive|else
name|notincl
argument_list|(
literal|"^["
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|reprint
argument_list|()
expr_stmt|;
goto|goto
name|re_read
goto|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|ERASECH
condition|)
block|{
comment|/* they want to rubout a char? */
name|rubout
argument_list|()
expr_stmt|;
name|s
operator|--
expr_stmt|;
comment|/* discount the char rubbed out */
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|<
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\177'
condition|)
name|rubout
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|buf
condition|)
block|{
comment|/* entire string gone? */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* return to single char command mode */
return|return
name|FALSE
return|;
block|}
else|else
goto|goto
name|re_read
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|KILLCH
condition|)
block|{
comment|/* wipe out the whole line? */
while|while
condition|(
name|s
operator|--
operator|!=
name|buf
condition|)
block|{
comment|/* emulate that many ERASEs */
name|rubout
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|<
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\177'
condition|)
name|rubout
argument_list|()
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* return to single char mode */
block|}
ifdef|#
directive|ifdef
name|WORDERASE
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|Ctl
argument_list|(
literal|'w'
argument_list|)
condition|)
block|{
comment|/* wipe out one word? */
operator|*
name|s
operator|--
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|isspace
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|rubout
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|--
operator|==
name|buf
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* return to single char mode */
block|}
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|<
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\177'
condition|)
name|rubout
argument_list|()
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
goto|goto
name|re_read
goto|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|Ctl
argument_list|(
literal|'r'
argument_list|)
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|reprint
argument_list|()
expr_stmt|;
goto|goto
name|re_read
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|Ctl
argument_list|(
literal|'v'
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|getcmd
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
name|quoteone
operator|=
name|TRUE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|cray
block|}
do|while
condition|(
operator|*
name|s
operator|!=
literal|'\r'
condition|)
do|;
comment|/* till a newline (not echoed) */
else|#
directive|else
block|}
end_function

begin_while
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\n'
condition|)
empty_stmt|;
end_while

begin_comment
comment|/* till a newline (not echoed) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* terminate the string nicely */
end_comment

begin_if
if|if
condition|(
name|donewline
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
end_if

begin_return
return|return
name|TRUE
return|;
end_return

begin_comment
comment|/* say we succeeded */
end_comment

begin_macro
unit|}  bool
name|finish_dblchar
argument_list|()
end_macro

begin_block
block|{
name|bool
name|ret
decl_stmt|;
name|buflimit
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
name|finish_command
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|buflimit
operator|=
name|LBUFLEN
expr_stmt|;
return|return
name|ret
return|;
block|}
end_block

begin_comment
comment|/* discard any characters typed ahead */
end_comment

begin_function
name|void
name|eat_typeahead
parameter_list|()
block|{
if|if
condition|(
operator|!
name|typeahead
operator|&&
name|nextin
operator|==
name|nextout
condition|)
block|{
comment|/* cancel only keyboard stuff */
ifdef|#
directive|ifdef
name|PENDING
while|while
condition|(
name|input_pending
argument_list|()
condition|)
name|read_tty
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* this is probably v7 */
ifdef|#
directive|ifdef
name|I_SGTTY
name|ioctl
argument_list|(
name|_tty_ch
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|_tty
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|I_TERMIO
name|ioctl
argument_list|(
name|_tty_ch
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|_tty
argument_list|)
expr_stmt|;
else|#
directive|else
name|tcsetattr
argument_list|(
name|_tty_ch
argument_list|,
name|TCSAFLUSH
argument_list|,
operator|&
name|_tty
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|save_typeahead
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|cnt
decl_stmt|;
while|while
condition|(
name|input_pending
argument_list|()
condition|)
block|{
name|cnt
operator|=
name|read_tty
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|cnt
expr_stmt|;
name|len
operator|-=
name|cnt
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|settle_down
parameter_list|()
block|{
name|dingaling
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/*sleep(1);*/
name|nextout
operator|=
name|nextin
expr_stmt|;
comment|/* empty circlebuf */
name|eat_typeahead
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* read a character from the terminal, with multi-character pushback */
end_comment

begin_function
name|int
name|read_tty
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|nextout
operator|!=
name|nextin
condition|)
block|{
operator|*
name|addr
operator|=
name|circlebuf
index|[
name|nextout
operator|++
index|]
expr_stmt|;
name|nextout
operator|%=
name|PUSHSIZE
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|size
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RAWONLY
operator|*
name|addr
operator|&=
literal|0177
expr_stmt|;
endif|#
directive|endif
return|return
name|size
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PENDING
end_ifdef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FIONREAD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_RDCHK
argument_list|)
end_if

begin_function
name|int
name|circfill
parameter_list|()
block|{
specifier|register
name|int
name|Howmany
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|Howmany
operator|=
name|read
argument_list|(
name|devtty
argument_list|,
name|circlebuf
operator|+
name|nextin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Howmany
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EINTR
operator|)
condition|)
name|Howmany
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Howmany
condition|)
block|{
name|nextin
operator|+=
name|Howmany
expr_stmt|;
name|nextin
operator|%=
name|PUSHSIZE
expr_stmt|;
block|}
return|return
name|Howmany
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PENDING */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FIONREAD */
end_comment

begin_function
name|void
name|pushchar
parameter_list|(
name|c
parameter_list|)
name|char_int
name|c
decl_stmt|;
block|{
name|nextout
operator|--
expr_stmt|;
if|if
condition|(
name|nextout
operator|<
literal|0
condition|)
name|nextout
operator|=
name|PUSHSIZE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nextout
operator|==
name|nextin
condition|)
block|{
name|fputs
argument_list|(
literal|"\npushback buffer overflow\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|circlebuf
index|[
name|nextout
index|]
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print an underlined string, one way or another */
end_comment

begin_function
name|void
name|underprint
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|assert
argument_list|(
name|UC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|UC
condition|)
block|{
comment|/* char by char underline? */
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|<
literal|' '
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
comment|/* back up over it */
name|underchar
argument_list|()
expr_stmt|;
comment|/* and do the underline */
name|putchar
argument_list|(
operator|*
name|s
operator|+
literal|64
argument_list|)
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
comment|/* back up over it */
name|underchar
argument_list|()
expr_stmt|;
comment|/* and do the underline */
block|}
else|else
block|{
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
comment|/* back up over it */
name|underchar
argument_list|()
expr_stmt|;
comment|/* and do the underline */
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* start and stop underline */
name|underline
argument_list|()
expr_stmt|;
comment|/* start underlining */
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|<
literal|' '
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|s
operator|+
literal|64
argument_list|)
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|un_underline
argument_list|()
expr_stmt|;
comment|/* stop underlining */
block|}
block|}
end_function

begin_comment
comment|/* keep screen from flashing strangely on magic cookie terminals */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NOFIREWORKS
end_ifdef

begin_function
name|void
name|no_sofire
parameter_list|()
block|{
if|if
condition|(
operator|*
name|UP
operator|&&
operator|*
name|SE
condition|)
block|{
comment|/* should we disable fireworks? */
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|un_standout
argument_list|()
expr_stmt|;
name|up_line
argument_list|()
expr_stmt|;
name|carriage_return
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|no_ulfire
parameter_list|()
block|{
if|if
condition|(
operator|*
name|UP
operator|&&
operator|*
name|US
condition|)
block|{
comment|/* should we disable fireworks? */
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|un_underline
argument_list|()
expr_stmt|;
name|up_line
argument_list|()
expr_stmt|;
name|carriage_return
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* get a character into a buffer */
end_comment

begin_function
name|void
name|getcmd
parameter_list|(
name|whatbuf
parameter_list|)
specifier|register
name|char
modifier|*
name|whatbuf
decl_stmt|;
block|{
specifier|register
name|KEYMAP
modifier|*
name|curmap
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|bool
name|no_macros
decl_stmt|;
name|int
name|times
init|=
literal|0
decl_stmt|;
comment|/* loop detector */
name|char
name|scrchar
decl_stmt|;
name|tryagain
label|:
name|curmap
operator|=
name|topmap
expr_stmt|;
name|no_macros
operator|=
operator|(
name|whatbuf
operator|!=
name|buf
operator|&&
name|nextin
operator|==
name|nextout
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int_count
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|read_tty
argument_list|(
name|whatbuf
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|errno
condition|)
name|errno
operator|=
name|EINTR
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
return|return;
name|perror
argument_list|(
name|readerr
argument_list|)
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|lastchar
operator|=
operator|*
name|whatbuf
expr_stmt|;
if|if
condition|(
operator|*
name|whatbuf
operator|&
literal|0200
operator|||
name|no_macros
condition|)
block|{
operator|*
name|whatbuf
operator|&=
literal|0177
expr_stmt|;
goto|goto
name|got_canonical
goto|;
block|}
if|if
condition|(
name|curmap
operator|==
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
condition|)
goto|goto
name|got_canonical
goto|;
for|for
control|(
name|i
operator|=
operator|(
name|curmap
operator|->
name|km_type
index|[
operator|*
name|whatbuf
index|]
operator|>>
name|KM_GSHIFT
operator|)
operator|&
name|KM_GMASK
init|;
name|i
condition|;
operator|--
name|i
control|)
block|{
name|read_tty
argument_list|(
operator|&
name|scrchar
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|curmap
operator|->
name|km_type
index|[
operator|*
name|whatbuf
index|]
operator|&
name|KM_TMASK
condition|)
block|{
case|case
name|KM_NOTHIN
case|:
comment|/* no entry? */
if|if
condition|(
name|curmap
operator|==
name|topmap
condition|)
comment|/* unmapped canonical */
goto|goto
name|got_canonical
goto|;
name|settle_down
argument_list|()
expr_stmt|;
goto|goto
name|tryagain
goto|;
case|case
name|KM_KEYMAP
case|:
comment|/* another keymap? */
name|curmap
operator|=
name|curmap
operator|->
name|km_ptr
index|[
operator|*
name|whatbuf
index|]
operator|.
name|km_km
expr_stmt|;
name|assert
argument_list|(
name|curmap
operator|!=
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|KM_STRING
case|:
comment|/* a string? */
name|pushstring
argument_list|(
name|curmap
operator|->
name|km_ptr
index|[
operator|*
name|whatbuf
index|]
operator|.
name|km_str
argument_list|,
literal|0200
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|times
operator|>
literal|20
condition|)
block|{
comment|/* loop? */
name|fputs
argument_list|(
literal|"\nmacro loop?\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|settle_down
argument_list|()
expr_stmt|;
block|}
name|no_macros
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
block|}
name|got_canonical
label|:
ifdef|#
directive|ifdef
name|I_SGTTY
if|if
condition|(
operator|*
name|whatbuf
operator|==
literal|'\r'
condition|)
operator|*
name|whatbuf
operator|=
literal|'\n'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|whatbuf
operator|==
name|buf
condition|)
name|whatbuf
index|[
literal|1
index|]
operator|=
name|FINISHCMD
expr_stmt|;
comment|/* tell finish_command to work */
block|}
end_function

begin_function
name|void
name|pushstring
parameter_list|(
name|str
parameter_list|,
name|bits
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|char_int
name|bits
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|tmpbuf
index|[
name|PUSHSIZE
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|tmpbuf
decl_stmt|;
name|assert
argument_list|(
name|str
operator|!=
name|Nullch
argument_list|)
expr_stmt|;
name|interp
argument_list|(
name|tmpbuf
argument_list|,
name|PUSHSIZE
argument_list|,
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|pushchar
argument_list|(
name|s
index|[
name|i
index|]
operator|^
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|get_anything
parameter_list|()
block|{
name|char
name|tmpbuf
index|[
literal|2
index|]
decl_stmt|;
name|reask_anything
label|:
name|unflush_output
argument_list|()
expr_stmt|;
comment|/* disable any ^O in effect */
name|standout
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"[Type space to continue] "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"[MORE] "
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|un_standout
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|eat_typeahead
argument_list|()
expr_stmt|;
if|if
condition|(
name|int_count
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|cache_until_key
argument_list|()
expr_stmt|;
name|getcmd
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|*
name|tmpbuf
operator|==
literal|'\f'
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
comment|/* if return from stop signal */
goto|goto
name|reask_anything
goto|;
comment|/* give them a prompt again */
block|}
if|if
condition|(
operator|*
name|tmpbuf
operator|==
literal|'h'
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\nType q to quit or space to continue.\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\nq to quit, space to continue.\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
goto|goto
name|reask_anything
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|tmpbuf
operator|!=
literal|' '
operator|&&
operator|*
name|tmpbuf
operator|!=
literal|'\n'
condition|)
block|{
name|carriage_return
argument_list|()
expr_stmt|;
name|erase_eol
argument_list|()
expr_stmt|;
comment|/* erase the prompt */
name|carriage_return
argument_list|()
expr_stmt|;
return|return
operator|*
name|tmpbuf
operator|==
literal|'q'
condition|?
operator|-
literal|1
else|:
operator|*
name|tmpbuf
return|;
block|}
if|if
condition|(
operator|*
name|tmpbuf
operator|==
literal|'\n'
condition|)
block|{
name|page_line
operator|=
name|LINES
operator|-
literal|1
expr_stmt|;
name|carriage_return
argument_list|()
expr_stmt|;
name|erase_eol
argument_list|()
expr_stmt|;
name|carriage_return
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|page_line
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|erase_screen
condition|)
comment|/* -e? */
name|clear
argument_list|()
expr_stmt|;
comment|/* clear screen */
else|else
block|{
name|carriage_return
argument_list|()
expr_stmt|;
name|erase_eol
argument_list|()
expr_stmt|;
comment|/* erase the prompt */
name|carriage_return
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pause_getcmd
parameter_list|()
block|{
name|unflush_output
argument_list|()
expr_stmt|;
comment|/* disable any ^O in effect */
name|standout
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"[Type space or a command] "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"[CMD] "
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|un_standout
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|eat_typeahead
argument_list|()
expr_stmt|;
if|if
condition|(
name|int_count
condition|)
return|return
operator|-
literal|1
return|;
name|cache_until_key
argument_list|()
expr_stmt|;
name|getcmd
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|*
name|buf
operator|==
literal|'\f'
condition|)
return|return
literal|0
return|;
comment|/* if return from stop signal */
elseif|else
if|if
condition|(
operator|*
name|buf
operator|!=
literal|' '
condition|)
block|{
name|carriage_return
argument_list|()
expr_stmt|;
name|erase_eol
argument_list|()
expr_stmt|;
comment|/* erase the prompt */
name|carriage_return
argument_list|()
expr_stmt|;
return|return
operator|*
name|buf
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|in_char
parameter_list|(
name|prompt
parameter_list|,
name|newmode
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
name|char_int
name|newmode
decl_stmt|;
block|{
name|char
name|oldmode
init|=
name|mode
decl_stmt|;
name|reask_in_char
label|:
name|unflush_output
argument_list|()
expr_stmt|;
comment|/* disable any ^O in effect */
name|fputs
argument_list|(
name|prompt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|eat_typeahead
argument_list|()
expr_stmt|;
name|mode
operator|=
name|newmode
expr_stmt|;
name|getcmd
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|*
name|buf
operator|==
literal|'\f'
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
comment|/* if return from stop signal */
goto|goto
name|reask_in_char
goto|;
comment|/* give them a prompt again */
block|}
name|mode
operator|=
name|oldmode
expr_stmt|;
block|}
end_function

begin_function
name|void
name|in_answer
parameter_list|(
name|prompt
parameter_list|,
name|newmode
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
name|char_int
name|newmode
decl_stmt|;
block|{
name|char
name|oldmode
init|=
name|mode
decl_stmt|;
name|reask_in_answer
label|:
name|unflush_output
argument_list|()
expr_stmt|;
comment|/* disable any ^O in effect */
name|fputs
argument_list|(
name|prompt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|eat_typeahead
argument_list|()
expr_stmt|;
name|mode
operator|=
name|newmode
expr_stmt|;
name|reinp_in_answer
label|:
name|getcmd
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|*
name|buf
operator|==
literal|'\f'
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
comment|/* if return from stop signal */
goto|goto
name|reask_in_answer
goto|;
comment|/* give them a prompt again */
block|}
if|if
condition|(
operator|!
name|finish_command
argument_list|(
name|TRUE
argument_list|)
condition|)
goto|goto
name|reinp_in_answer
goto|;
name|mode
operator|=
name|oldmode
expr_stmt|;
block|}
end_function

begin_function
name|int
name|print_lines
parameter_list|(
name|what_to_print
parameter_list|,
name|hilite
parameter_list|)
name|char
modifier|*
name|what_to_print
decl_stmt|;
name|int
name|hilite
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|page_line
operator|<
literal|0
condition|)
comment|/* they do not want to see this? */
return|return
operator|-
literal|1
return|;
for|for
control|(
name|s
operator|=
name|what_to_print
init|;
operator|*
name|s
condition|;
control|)
block|{
if|if
condition|(
name|page_line
operator|>=
name|LINES
operator|||
name|int_count
condition|)
block|{
if|if
condition|(
name|i
operator|=
operator|-
literal|1
operator|,
name|int_count
operator|||
operator|(
name|i
operator|=
name|get_anything
argument_list|()
operator|)
condition|)
block|{
name|page_line
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* disable further print_lines */
return|return
name|i
return|;
block|}
block|}
name|page_line
operator|++
expr_stmt|;
if|if
condition|(
name|hilite
operator|==
name|STANDOUT
condition|)
block|{
ifdef|#
directive|ifdef
name|NOFIREWORKS
if|if
condition|(
name|erase_screen
condition|)
name|no_sofire
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|standout
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hilite
operator|==
name|UNDERLINE
condition|)
block|{
ifdef|#
directive|ifdef
name|NOFIREWORKS
if|if
condition|(
name|erase_screen
condition|)
name|no_ulfire
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|underline
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|s
condition|)
break|break;
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|>=
literal|' '
condition|)
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
operator|(
name|i
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
name|i
operator|=
literal|32000
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|s
operator|+
literal|64
argument_list|)
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
name|hilite
operator|==
name|STANDOUT
condition|)
name|un_standout
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|hilite
operator|==
name|UNDERLINE
condition|)
name|un_underline
argument_list|()
expr_stmt|;
if|if
condition|(
name|AM
operator|&&
name|i
operator|==
name|COLS
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|page_init
parameter_list|()
block|{
name|page_line
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|erase_screen
condition|)
name|clear
argument_list|()
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pad
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|num
init|;
name|i
condition|;
operator|--
name|i
control|)
name|putchar
argument_list|(
name|PC
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* echo the command just typed */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VERIFY
end_ifdef

begin_function
name|void
name|printcmd
parameter_list|()
block|{
if|if
condition|(
name|verify
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
name|FINISHCMD
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|<
literal|' '
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|buf
operator||
literal|64
argument_list|)
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|rubout
parameter_list|()
block|{
name|backspace
argument_list|()
expr_stmt|;
comment|/* do the old backspace, */
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/*   space, */
name|backspace
argument_list|()
expr_stmt|;
comment|/*     backspace trick */
block|}
end_function

begin_function
name|void
name|reprint
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|fputs
argument_list|(
literal|"^R\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|<
literal|' '
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|s
operator||
literal|64
argument_list|)
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|home_cursor
parameter_list|()
block|{
name|char
modifier|*
name|tgoto
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
operator|*
name|HO
condition|)
block|{
comment|/* no home sequence? */
if|if
condition|(
operator|!
operator|*
name|CM
condition|)
block|{
comment|/* no cursor motion either? */
name|fputs
argument_list|(
literal|"\n\n\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
comment|/* forget it. */
block|}
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|,
name|putchr
argument_list|)
expr_stmt|;
comment|/* go to home via CM */
return|return;
block|}
else|else
block|{
comment|/* we have home sequence */
name|tputs
argument_list|(
name|HO
argument_list|,
literal|1
argument_list|,
name|putchr
argument_list|)
expr_stmt|;
comment|/* home via HO */
block|}
block|}
end_function

begin_function
name|void
name|goto_line
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
comment|/* assumes caller is already at beginning of line */
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|char
modifier|*
name|tgoto
argument_list|()
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|int
name|cmcost
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|to
condition|)
return|return;
if|if
condition|(
operator|*
name|CM
operator|&&
operator|!
name|muck_up_clear
condition|)
name|cmcost
operator|=
name|strlen
argument_list|(
name|str
operator|=
name|tgoto
argument_list|(
name|CM
argument_list|,
literal|0
argument_list|,
name|to
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cmcost
operator|=
literal|9999
expr_stmt|;
if|if
condition|(
name|to
operator|>
name|from
condition|)
block|{
name|go_down
label|:
if|if
condition|(
name|to
operator|-
name|from
operator|<=
name|cmcost
condition|)
block|{
while|while
condition|(
name|from
operator|++
operator|<
name|to
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|UP
condition|)
block|{
if|if
condition|(
operator|(
name|from
operator|-
name|to
operator|)
operator|*
name|upcost
operator|<=
name|cmcost
condition|)
block|{
while|while
condition|(
name|from
operator|--
operator|>
name|to
condition|)
name|tputs
argument_list|(
name|UP
argument_list|,
literal|1
argument_list|,
name|putchr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|cmcost
operator|==
literal|9999
condition|)
block|{
name|home_cursor
argument_list|()
expr_stmt|;
name|from
operator|=
literal|0
expr_stmt|;
goto|goto
name|go_down
goto|;
block|}
name|tputs
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|putchr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|line_col_calcs
parameter_list|()
block|{
if|if
condition|(
name|LINES
operator|>
literal|0
condition|)
block|{
comment|/* is this a crt? */
if|if
condition|(
operator|(
operator|!
name|initlines
operator|)
operator|||
operator|(
operator|!
name|initlines_specified
operator|)
condition|)
comment|/* no -i or unreasonable value for initlines */
if|if
condition|(
name|outspeed
operator|>=
name|B9600
condition|)
comment|/* whole page at>= 9600 baud */
name|initlines
operator|=
name|LINES
expr_stmt|;
elseif|else
if|if
condition|(
name|outspeed
operator|>=
name|B4800
condition|)
comment|/* 16 lines at 4800 */
name|initlines
operator|=
literal|16
expr_stmt|;
else|else
comment|/* otherwise just header */
name|initlines
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* not a crt */
name|LINES
operator|=
literal|30000
expr_stmt|;
comment|/* so don't page */
name|CL
operator|=
literal|"\n\n"
expr_stmt|;
comment|/* put a couple of lines between */
if|if
condition|(
operator|(
operator|!
name|initlines
operator|)
operator|||
operator|(
operator|!
name|initlines_specified
operator|)
condition|)
comment|/* make initlines reasonable */
name|initlines
operator|=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|COLS
operator|<=
literal|0
condition|)
name|COLS
operator|=
literal|80
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH
end_ifdef

begin_function
name|Signal_t
name|winch_catcher
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
decl_stmt|;
block|{
comment|/* Reset signal in case of System V dain bramage */
name|sigset
argument_list|(
name|SIGWINCH
argument_list|,
name|winch_catcher
argument_list|)
expr_stmt|;
comment|/* Come here if window size change signal received */
ifdef|#
directive|ifdef
name|TIOCGWINSZ
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|>=
literal|0
operator|&&
name|ws
operator|.
name|ws_row
operator|>
literal|0
operator|&&
name|ws
operator|.
name|ws_col
operator|>
literal|0
condition|)
block|{
name|LINES
operator|=
name|ws
operator|.
name|ws_row
expr_stmt|;
name|COLS
operator|=
name|ws
operator|.
name|ws_col
expr_stmt|;
name|line_col_calcs
argument_list|()
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* Well, if SIGWINCH is defined, but TIOCGWINSZ isn't, there's    */
comment|/* almost certainly something wrong.  Figure it out for yourself, */
comment|/* because I don't know now to deal :-)                           */
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|termlib_init
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USETITE
if|if
condition|(
name|TI
operator|&&
operator|*
name|TI
condition|)
name|tputs
argument_list|(
name|TI
argument_list|,
literal|1
argument_list|,
name|putchr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_function
name|void
name|termlib_reset
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USETITE
if|if
condition|(
name|TE
operator|&&
operator|*
name|TE
condition|)
name|tputs
argument_list|(
name|TE
argument_list|,
literal|1
argument_list|,
name|putchr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

end_unit

