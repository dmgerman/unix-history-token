begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* unship.c -- for unpacking ship files via trn */
end_comment

begin_comment
comment|/* Based on ship.c -- Not copyrighted 1991 Mark Adler. */
end_comment

begin_comment
comment|/* Modified by Wayne Davison, but still not copyrighted. */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"respond.h"
end_include

begin_include
include|#
directive|include
file|"decode.h"
end_include

begin_typedef
typedef|typedef
name|unsigned
name|long
name|ulg
typedef|;
end_typedef

begin_comment
comment|/* 32-bit unsigned integer */
end_comment

begin_comment
comment|/* Function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|decode_line
name|_
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|err
name|_
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Globals for ship() */
end_comment

begin_decl_stmt
name|ulg
name|ccnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of bytes read or written */
end_comment

begin_decl_stmt
name|ulg
name|crc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CRC register */
end_comment

begin_decl_stmt
name|ulg
name|buf4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* four byte buffer */
end_comment

begin_decl_stmt
name|int
name|bcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer count */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|decb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bit buffer for decode */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|decn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bits in decb */
end_comment

begin_decl_stmt
name|bool
name|fast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true for arithmetic coding, else base 85 */
end_comment

begin_decl_stmt
name|bool
name|overwrite
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should we overwrite existing files? */
end_comment

begin_comment
comment|/* Errors */
end_comment

begin_define
define|#
directive|define
name|SE_FORM
value|1
end_define

begin_define
define|#
directive|define
name|SE_CONT
value|2
end_define

begin_define
define|#
directive|define
name|SE_CRC
value|3
end_define

begin_define
define|#
directive|define
name|SE_OVER
value|4
end_define

begin_define
define|#
directive|define
name|SE_FULL
value|5
end_define

begin_decl_stmt
name|char
modifier|*
name|errors
index|[]
init|=
block|{
comment|/* 1 */
literal|"Invalid ship format."
block|,
comment|/* 2 */
literal|"This piece is out of sequence."
block|,
comment|/* 3 */
literal|"CRC check failed."
block|,
comment|/* 4 */
literal|"File already exists."
block|,
comment|/* 5 */
literal|"Error writing file."
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of 86 characters used for the base 85 digits (last one not used), and    the 86 character arithmetic coding.	Selected to be part of both the ASCII    printable characters, and the common EBCDIC printable characters whose    ASCII translations are universal. */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|safe
index|[]
init|=
block|{
literal|'{'
block|,
literal|'"'
block|,
literal|'#'
block|,
literal|'$'
block|,
literal|'%'
block|,
literal|'&'
block|,
literal|'\''
block|,
literal|'('
block|,
literal|')'
block|,
literal|'*'
block|,
literal|'+'
block|,
literal|','
block|,
literal|'-'
block|,
literal|'.'
block|,
literal|'/'
block|,
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|':'
block|,
literal|';'
block|,
literal|'<'
block|,
literal|'='
block|,
literal|'>'
block|,
literal|'?'
block|,
literal|'@'
block|,
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|,
literal|'G'
block|,
literal|'H'
block|,
literal|'I'
block|,
literal|'J'
block|,
literal|'K'
block|,
literal|'L'
block|,
literal|'M'
block|,
literal|'N'
block|,
literal|'O'
block|,
literal|'P'
block|,
literal|'Q'
block|,
literal|'R'
block|,
literal|'S'
block|,
literal|'T'
block|,
literal|'U'
block|,
literal|'V'
block|,
literal|'W'
block|,
literal|'X'
block|,
literal|'Y'
block|,
literal|'Z'
block|,
literal|'_'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'i'
block|,
literal|'j'
block|,
literal|'k'
block|,
literal|'l'
block|,
literal|'m'
block|,
literal|'n'
block|,
literal|'o'
block|,
literal|'p'
block|,
literal|'q'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'u'
block|,
literal|'v'
block|,
literal|'w'
block|,
literal|'x'
block|,
literal|'y'
block|,
literal|'z'
block|,
literal|'}'
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LOWSZ
value|(sizeof(safe)-64)
end_define

begin_comment
comment|/* low set size for fast coding */
end_comment

begin_comment
comment|/* Special replacement pairs--if first of each pair is received, it is    treated like the second member of the pair.	You're probably    wondering why.  The first pair is for compatibility with an    earlier version of ship that used ! for the base 85 zero digit.    However, there exist ASCII-EBCDIC translation tables that don't    know about exclamation marks.  The second set has mysterious    historical origins that are best left unspoken ... */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|aliases
index|[]
init|=
block|{
literal|'!'
block|,
literal|'{'
block|,
literal|'|'
block|,
literal|'+'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Inverse of safe[], filled in by unship_init() */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|invsafe
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of CRC-32's of all single byte values (made by makecrc.c) */
end_comment

begin_decl_stmt
name|ulg
name|crctab
index|[]
init|=
block|{
literal|0x00000000L
block|,
literal|0x77073096L
block|,
literal|0xee0e612cL
block|,
literal|0x990951baL
block|,
literal|0x076dc419L
block|,
literal|0x706af48fL
block|,
literal|0xe963a535L
block|,
literal|0x9e6495a3L
block|,
literal|0x0edb8832L
block|,
literal|0x79dcb8a4L
block|,
literal|0xe0d5e91eL
block|,
literal|0x97d2d988L
block|,
literal|0x09b64c2bL
block|,
literal|0x7eb17cbdL
block|,
literal|0xe7b82d07L
block|,
literal|0x90bf1d91L
block|,
literal|0x1db71064L
block|,
literal|0x6ab020f2L
block|,
literal|0xf3b97148L
block|,
literal|0x84be41deL
block|,
literal|0x1adad47dL
block|,
literal|0x6ddde4ebL
block|,
literal|0xf4d4b551L
block|,
literal|0x83d385c7L
block|,
literal|0x136c9856L
block|,
literal|0x646ba8c0L
block|,
literal|0xfd62f97aL
block|,
literal|0x8a65c9ecL
block|,
literal|0x14015c4fL
block|,
literal|0x63066cd9L
block|,
literal|0xfa0f3d63L
block|,
literal|0x8d080df5L
block|,
literal|0x3b6e20c8L
block|,
literal|0x4c69105eL
block|,
literal|0xd56041e4L
block|,
literal|0xa2677172L
block|,
literal|0x3c03e4d1L
block|,
literal|0x4b04d447L
block|,
literal|0xd20d85fdL
block|,
literal|0xa50ab56bL
block|,
literal|0x35b5a8faL
block|,
literal|0x42b2986cL
block|,
literal|0xdbbbc9d6L
block|,
literal|0xacbcf940L
block|,
literal|0x32d86ce3L
block|,
literal|0x45df5c75L
block|,
literal|0xdcd60dcfL
block|,
literal|0xabd13d59L
block|,
literal|0x26d930acL
block|,
literal|0x51de003aL
block|,
literal|0xc8d75180L
block|,
literal|0xbfd06116L
block|,
literal|0x21b4f4b5L
block|,
literal|0x56b3c423L
block|,
literal|0xcfba9599L
block|,
literal|0xb8bda50fL
block|,
literal|0x2802b89eL
block|,
literal|0x5f058808L
block|,
literal|0xc60cd9b2L
block|,
literal|0xb10be924L
block|,
literal|0x2f6f7c87L
block|,
literal|0x58684c11L
block|,
literal|0xc1611dabL
block|,
literal|0xb6662d3dL
block|,
literal|0x76dc4190L
block|,
literal|0x01db7106L
block|,
literal|0x98d220bcL
block|,
literal|0xefd5102aL
block|,
literal|0x71b18589L
block|,
literal|0x06b6b51fL
block|,
literal|0x9fbfe4a5L
block|,
literal|0xe8b8d433L
block|,
literal|0x7807c9a2L
block|,
literal|0x0f00f934L
block|,
literal|0x9609a88eL
block|,
literal|0xe10e9818L
block|,
literal|0x7f6a0dbbL
block|,
literal|0x086d3d2dL
block|,
literal|0x91646c97L
block|,
literal|0xe6635c01L
block|,
literal|0x6b6b51f4L
block|,
literal|0x1c6c6162L
block|,
literal|0x856530d8L
block|,
literal|0xf262004eL
block|,
literal|0x6c0695edL
block|,
literal|0x1b01a57bL
block|,
literal|0x8208f4c1L
block|,
literal|0xf50fc457L
block|,
literal|0x65b0d9c6L
block|,
literal|0x12b7e950L
block|,
literal|0x8bbeb8eaL
block|,
literal|0xfcb9887cL
block|,
literal|0x62dd1ddfL
block|,
literal|0x15da2d49L
block|,
literal|0x8cd37cf3L
block|,
literal|0xfbd44c65L
block|,
literal|0x4db26158L
block|,
literal|0x3ab551ceL
block|,
literal|0xa3bc0074L
block|,
literal|0xd4bb30e2L
block|,
literal|0x4adfa541L
block|,
literal|0x3dd895d7L
block|,
literal|0xa4d1c46dL
block|,
literal|0xd3d6f4fbL
block|,
literal|0x4369e96aL
block|,
literal|0x346ed9fcL
block|,
literal|0xad678846L
block|,
literal|0xda60b8d0L
block|,
literal|0x44042d73L
block|,
literal|0x33031de5L
block|,
literal|0xaa0a4c5fL
block|,
literal|0xdd0d7cc9L
block|,
literal|0x5005713cL
block|,
literal|0x270241aaL
block|,
literal|0xbe0b1010L
block|,
literal|0xc90c2086L
block|,
literal|0x5768b525L
block|,
literal|0x206f85b3L
block|,
literal|0xb966d409L
block|,
literal|0xce61e49fL
block|,
literal|0x5edef90eL
block|,
literal|0x29d9c998L
block|,
literal|0xb0d09822L
block|,
literal|0xc7d7a8b4L
block|,
literal|0x59b33d17L
block|,
literal|0x2eb40d81L
block|,
literal|0xb7bd5c3bL
block|,
literal|0xc0ba6cadL
block|,
literal|0xedb88320L
block|,
literal|0x9abfb3b6L
block|,
literal|0x03b6e20cL
block|,
literal|0x74b1d29aL
block|,
literal|0xead54739L
block|,
literal|0x9dd277afL
block|,
literal|0x04db2615L
block|,
literal|0x73dc1683L
block|,
literal|0xe3630b12L
block|,
literal|0x94643b84L
block|,
literal|0x0d6d6a3eL
block|,
literal|0x7a6a5aa8L
block|,
literal|0xe40ecf0bL
block|,
literal|0x9309ff9dL
block|,
literal|0x0a00ae27L
block|,
literal|0x7d079eb1L
block|,
literal|0xf00f9344L
block|,
literal|0x8708a3d2L
block|,
literal|0x1e01f268L
block|,
literal|0x6906c2feL
block|,
literal|0xf762575dL
block|,
literal|0x806567cbL
block|,
literal|0x196c3671L
block|,
literal|0x6e6b06e7L
block|,
literal|0xfed41b76L
block|,
literal|0x89d32be0L
block|,
literal|0x10da7a5aL
block|,
literal|0x67dd4accL
block|,
literal|0xf9b9df6fL
block|,
literal|0x8ebeeff9L
block|,
literal|0x17b7be43L
block|,
literal|0x60b08ed5L
block|,
literal|0xd6d6a3e8L
block|,
literal|0xa1d1937eL
block|,
literal|0x38d8c2c4L
block|,
literal|0x4fdff252L
block|,
literal|0xd1bb67f1L
block|,
literal|0xa6bc5767L
block|,
literal|0x3fb506ddL
block|,
literal|0x48b2364bL
block|,
literal|0xd80d2bdaL
block|,
literal|0xaf0a1b4cL
block|,
literal|0x36034af6L
block|,
literal|0x41047a60L
block|,
literal|0xdf60efc3L
block|,
literal|0xa867df55L
block|,
literal|0x316e8eefL
block|,
literal|0x4669be79L
block|,
literal|0xcb61b38cL
block|,
literal|0xbc66831aL
block|,
literal|0x256fd2a0L
block|,
literal|0x5268e236L
block|,
literal|0xcc0c7795L
block|,
literal|0xbb0b4703L
block|,
literal|0x220216b9L
block|,
literal|0x5505262fL
block|,
literal|0xc5ba3bbeL
block|,
literal|0xb2bd0b28L
block|,
literal|0x2bb45a92L
block|,
literal|0x5cb36a04L
block|,
literal|0xc2d7ffa7L
block|,
literal|0xb5d0cf31L
block|,
literal|0x2cd99e8bL
block|,
literal|0x5bdeae1dL
block|,
literal|0x9b64c2b0L
block|,
literal|0xec63f226L
block|,
literal|0x756aa39cL
block|,
literal|0x026d930aL
block|,
literal|0x9c0906a9L
block|,
literal|0xeb0e363fL
block|,
literal|0x72076785L
block|,
literal|0x05005713L
block|,
literal|0x95bf4a82L
block|,
literal|0xe2b87a14L
block|,
literal|0x7bb12baeL
block|,
literal|0x0cb61b38L
block|,
literal|0x92d28e9bL
block|,
literal|0xe5d5be0dL
block|,
literal|0x7cdcefb7L
block|,
literal|0x0bdbdf21L
block|,
literal|0x86d3d2d4L
block|,
literal|0xf1d4e242L
block|,
literal|0x68ddb3f8L
block|,
literal|0x1fda836eL
block|,
literal|0x81be16cdL
block|,
literal|0xf6b9265bL
block|,
literal|0x6fb077e1L
block|,
literal|0x18b74777L
block|,
literal|0x88085ae6L
block|,
literal|0xff0f6a70L
block|,
literal|0x66063bcaL
block|,
literal|0x11010b5cL
block|,
literal|0x8f659effL
block|,
literal|0xf862ae69L
block|,
literal|0x616bffd3L
block|,
literal|0x166ccf45L
block|,
literal|0xa00ae278L
block|,
literal|0xd70dd2eeL
block|,
literal|0x4e048354L
block|,
literal|0x3903b3c2L
block|,
literal|0xa7672661L
block|,
literal|0xd06016f7L
block|,
literal|0x4969474dL
block|,
literal|0x3e6e77dbL
block|,
literal|0xaed16a4aL
block|,
literal|0xd9d65adcL
block|,
literal|0x40df0b66L
block|,
literal|0x37d83bf0L
block|,
literal|0xa9bcae53L
block|,
literal|0xdebb9ec5L
block|,
literal|0x47b2cf7fL
block|,
literal|0x30b5ffe9L
block|,
literal|0xbdbdf21cL
block|,
literal|0xcabac28aL
block|,
literal|0x53b39330L
block|,
literal|0x24b4a3a6L
block|,
literal|0xbad03605L
block|,
literal|0xcdd70693L
block|,
literal|0x54de5729L
block|,
literal|0x23d967bfL
block|,
literal|0xb3667a2eL
block|,
literal|0xc4614ab8L
block|,
literal|0x5d681b02L
block|,
literal|0x2a6f2b94L
block|,
literal|0xb40bbe37L
block|,
literal|0xc30c8ea1L
block|,
literal|0x5a05df1bL
block|,
literal|0x2d02ef8dL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro to update the CRC shift register one byte at a time */
end_comment

begin_define
define|#
directive|define
name|CRC
parameter_list|(
name|c
parameter_list|,
name|b
parameter_list|)
value|(crctab[((int)(c)^(int)(b))&0xff]^((c)>>8))
end_define

begin_comment
comment|/* cputc(d,x)--like putc(d,f), but delays four bytes and computes a CRC.    x is a cfile *, and d is expected to be an ulg. */
end_comment

begin_define
define|#
directive|define
name|cputf
parameter_list|(
name|fp
parameter_list|)
value|(int)(crc=CRC(crc,buf4),putc((int)buf4&0xff,fp),ccnt++)
end_define

begin_define
define|#
directive|define
name|cputc
parameter_list|(
name|d
parameter_list|,
name|fp
parameter_list|)
value|(bcnt!=4?bcnt++:cputf(fp),buf4=(buf4>>8)+((ulg)(d)<<24))
end_define

begin_comment
comment|/* Build invsafe[], the inverse of safe[]. */
end_comment

begin_function
name|void
name|unship_init
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|invsafe
index|[
name|i
index|]
operator|=
literal|127
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|safe
argument_list|)
condition|;
name|i
operator|++
control|)
name|invsafe
index|[
name|safe
index|[
name|i
index|]
index|]
operator|=
operator|(
name|char
operator|)
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|aliases
index|[
name|i
index|]
condition|;
name|i
operator|+=
literal|2
control|)
name|invsafe
index|[
name|aliases
index|[
name|i
index|]
index|]
operator|=
name|invsafe
index|[
name|aliases
index|[
name|i
operator|+
literal|1
index|]
index|]
expr_stmt|;
block|}
end_function

begin_function
name|int
name|unship
parameter_list|(
name|in
parameter_list|)
name|FILE
modifier|*
name|in
decl_stmt|;
block|{
name|int
name|b
decl_stmt|;
comment|/* state of line loop */
name|char
name|l
index|[
name|LBUFLEN
index|]
decl_stmt|;
comment|/* line buffer on input */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* modifies line buffer */
name|char
modifier|*
name|q
decl_stmt|;
comment|/* scans continuation line */
comment|/* Loop on the latest article's lines */
name|b
operator|=
literal|2
expr_stmt|;
comment|/* not in body yet */
while|while
condition|(
literal|1
condition|)
comment|/* return on end of last file */
block|{
comment|/* Get next line from file */
if|if
condition|(
name|fgets
argument_list|(
name|l
argument_list|,
name|LBUFLEN
argument_list|,
name|in
argument_list|)
operator|==
name|Nullch
condition|)
break|break;
comment|/* Strip control characters and leading blank space, if any */
for|for
control|(
name|q
operator|=
name|l
init|;
operator|*
name|q
operator|&&
operator|*
name|q
operator|<=
literal|' '
operator|&&
operator|*
name|q
operator|!=
literal|'\n'
condition|;
name|q
operator|++
control|)
empty_stmt|;
for|for
control|(
name|p
operator|=
name|l
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|>=
literal|' '
operator|||
operator|*
name|q
operator|==
literal|'\n'
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Based on current state, end or start on terminator.  States are: 	 b == 0:  at start of body or body terminator line 	 b == 1:  in middle of body line 	 b == 2:  at start of non-body line 	 b == 3:  in middle of non-body line 	 b == 4:  at information line     */
switch|switch
condition|(
name|b
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|(
operator|!
name|fast
operator|&&
name|strEQ
argument_list|(
name|l
argument_list|,
literal|"$\n"
argument_list|)
operator|)
operator|||
operator|(
name|fast
operator|&&
name|strEQ
argument_list|(
name|l
argument_list|,
literal|"$ f\n"
argument_list|)
operator|)
condition|)
block|{
name|b
operator|=
literal|4
expr_stmt|;
break|break;
block|}
comment|/* fall through to case 1 */
case|case
literal|1
case|:
name|decode_line
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|l
argument_list|)
expr_stmt|;
name|b
operator|=
name|l
index|[
name|strlen
argument_list|(
name|l
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|l
argument_list|,
literal|"$\n"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|l
argument_list|,
literal|"$ f\n"
argument_list|)
condition|)
block|{
name|fast
operator|=
name|l
index|[
literal|1
index|]
operator|==
literal|' '
expr_stmt|;
name|b
operator|=
literal|4
expr_stmt|;
break|break;
block|}
comment|/* fall through to case 3 */
case|case
literal|3
case|:
name|b
operator|=
name|l
index|[
name|strlen
argument_list|(
name|l
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|?
literal|2
else|:
literal|3
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* Possible information lines are ship, more, cont, and end */
if|if
condition|(
name|l
index|[
name|b
operator|=
name|strlen
argument_list|(
name|l
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|err
argument_list|(
name|SE_FORM
argument_list|)
expr_stmt|;
name|decode_end
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l
index|[
name|b
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|l
argument_list|,
literal|"ship "
argument_list|,
literal|5
argument_list|)
condition|)
block|{
comment|/* get name, open new output file */
if|if
condition|(
name|decode_fp
operator|!=
name|Nullfp
condition|)
name|decode_end
argument_list|()
expr_stmt|;
comment|/* outputs an "incomplete" warning */
if|if
condition|(
name|strEQ
argument_list|(
name|l
operator|+
literal|5
argument_list|,
literal|"-"
argument_list|)
condition|)
name|strcpy
argument_list|(
name|decode_fname
argument_list|,
literal|"unnamed"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|decode_fname
argument_list|,
name|l
operator|+
literal|5
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|decode_dest
argument_list|,
literal|"%s/%s"
argument_list|,
name|extractdest
argument_list|,
name|decode_fname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Decoding: %s\n"
argument_list|,
name|decode_fname
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
comment|/* shouldn't have explicit version #, so VMS won't overwrite */
if|if
condition|(
operator|!
name|overwrite
operator|&&
operator|(
name|decode_fp
operator|=
name|fopen
argument_list|(
name|decode_dest
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|Nullfp
condition|)
block|{
name|fclose
argument_list|(
name|decode_fp
argument_list|)
expr_stmt|;
name|decode_fp
operator|=
name|Nullfp
expr_stmt|;
name|err
argument_list|(
name|SE_OVER
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* !VMS */
if|if
condition|(
operator|(
name|decode_fp
operator|=
name|fopen
argument_list|(
name|decode_dest
argument_list|,
name|FOPEN_WB
argument_list|)
operator|)
operator|==
name|Nullfp
condition|)
block|{
name|err
argument_list|(
name|SE_FULL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|crc
operator|=
literal|0xffffffffL
expr_stmt|;
comment|/* preload CRC register */
name|buf4
operator|=
literal|0
expr_stmt|;
comment|/* empty fifo (for output) */
name|bcnt
operator|=
literal|0
expr_stmt|;
comment|/* fifo is empty (output) */
name|b
operator|=
name|decb
operator|=
name|decn
operator|=
literal|0
expr_stmt|;
name|ccnt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|l
argument_list|,
literal|"more"
argument_list|)
condition|)
block|{
comment|/* check if currently writing */
if|if
condition|(
name|decode_fp
operator|==
name|Nullfp
condition|)
block|{
name|err
argument_list|(
name|SE_FORM
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|b
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|l
argument_list|,
literal|"cont "
argument_list|,
literal|5
argument_list|)
condition|)
block|{
comment|/* check name and file offset */
if|if
condition|(
name|decode_fp
operator|==
name|Nullfp
condition|)
block|{
name|err
argument_list|(
name|SE_CONT
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|q
operator|=
name|l
operator|+
literal|5
init|;
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|' '
condition|;
name|q
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|0
operator|||
name|atol
argument_list|(
name|l
operator|+
literal|5
argument_list|)
operator|!=
name|ccnt
operator|+
literal|4
operator|+
operator|(
name|decn
operator|!=
literal|0
operator|)
operator|||
name|strNE
argument_list|(
name|q
operator|+
literal|1
argument_list|,
name|decode_fname
argument_list|)
condition|)
block|{
name|err
argument_list|(
name|SE_CONT
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|b
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|l
argument_list|,
literal|"end"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* check crc, close output file */
if|if
condition|(
name|decode_fp
operator|==
name|Nullfp
condition|)
block|{
name|err
argument_list|(
name|SE_FORM
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|bcnt
operator|!=
literal|4
operator|||
name|buf4
operator|!=
operator|~
name|crc
condition|)
name|err
argument_list|(
name|SE_CRC
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"CRC verified -- Done.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|decode_fp
argument_list|)
operator|||
name|fclose
argument_list|(
name|decode_fp
argument_list|)
condition|)
block|{
name|err
argument_list|(
name|SE_FULL
argument_list|)
expr_stmt|;
name|decode_end
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|decode_fp
operator|=
name|Nullfp
expr_stmt|;
name|b
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|q
operator|=
name|l
init|;
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|' '
condition|;
name|q
operator|++
control|)
empty_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"Ignoring unsupported ship keyword: '%s'\n"
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|b
operator|=
literal|4
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|b
operator|&
literal|2
operator|)
condition|)
block|{
name|err
argument_list|(
name|SE_FORM
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|decode_fp
condition|)
name|printf
argument_list|(
literal|"(Continued)\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Decode s, a string of base 85 digits or, if fast is true, a string of safe    characters generated arithmetically, into its binary equivalent, writing    the result to decode_fp, using cputc(). */
end_comment

begin_function
specifier|static
name|void
name|decode_line
parameter_list|(
name|s
parameter_list|)
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
comment|/* data to decode */
block|{
name|int
name|b
decl_stmt|;
comment|/* state of line loop, next character */
name|int
name|k
decl_stmt|;
comment|/* counts bits or digits read */
comment|/* powers of 85 table for decoding */
specifier|static
name|ulg
name|m
index|[]
init|=
block|{
literal|1L
block|,
literal|85L
block|,
literal|85L
operator|*
literal|85L
block|,
literal|85L
operator|*
literal|85L
operator|*
literal|85L
block|,
literal|85L
operator|*
literal|85L
operator|*
literal|85L
operator|*
literal|85L
block|}
decl_stmt|;
if|if
condition|(
name|fast
condition|)
block|{
name|unsigned
name|int
name|d
decl_stmt|;
comment|/* disperses bits */
name|d
operator|=
name|decb
expr_stmt|;
name|k
operator|=
name|decn
expr_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|0
condition|)
if|if
condition|(
operator|(
name|b
operator|=
name|invsafe
index|[
name|b
index|]
operator|)
operator|<
sizeof|sizeof
argument_list|(
name|safe
argument_list|)
condition|)
block|{
if|if
condition|(
name|b
operator|<
name|LOWSZ
condition|)
block|{
name|d
operator||=
name|b
operator|<<
name|k
expr_stmt|;
name|k
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|b
operator|-=
name|LOWSZ
operator|)
operator|<
name|LOWSZ
condition|)
block|{
name|d
operator||=
operator|(
name|b
operator|+
literal|0x40
operator|)
operator|<<
name|k
expr_stmt|;
name|k
operator|+=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|d
operator||=
name|b
operator|<<
name|k
expr_stmt|;
name|k
operator|+=
literal|6
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|>=
literal|8
condition|)
block|{
name|cputc
argument_list|(
name|d
argument_list|,
name|decode_fp
argument_list|)
expr_stmt|;
name|d
operator|>>=
literal|8
expr_stmt|;
name|k
operator|-=
literal|8
expr_stmt|;
block|}
block|}
name|decb
operator|=
name|d
expr_stmt|;
name|decn
operator|=
name|k
expr_stmt|;
block|}
else|else
block|{
name|ulg
name|d
decl_stmt|;
comment|/* disperses bytes */
name|d
operator|=
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|0
condition|)
if|if
condition|(
operator|(
name|b
operator|=
name|invsafe
index|[
name|b
index|]
operator|)
operator|<
literal|85
condition|)
block|{
name|d
operator|+=
name|m
index|[
name|k
index|]
operator|*
name|b
expr_stmt|;
if|if
condition|(
operator|++
name|k
operator|==
literal|5
condition|)
block|{
name|cputc
argument_list|(
name|d
argument_list|,
name|decode_fp
argument_list|)
expr_stmt|;
name|d
operator|>>=
literal|8
expr_stmt|;
name|cputc
argument_list|(
name|d
argument_list|,
name|decode_fp
argument_list|)
expr_stmt|;
name|d
operator|>>=
literal|8
expr_stmt|;
name|cputc
argument_list|(
name|d
argument_list|,
name|decode_fp
argument_list|)
expr_stmt|;
name|d
operator|>>=
literal|8
expr_stmt|;
name|cputc
argument_list|(
name|d
argument_list|,
name|decode_fp
argument_list|)
expr_stmt|;
name|d
operator|=
name|k
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|--
name|k
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|--
name|k
condition|)
block|{
name|cputc
argument_list|(
name|d
argument_list|,
name|decode_fp
argument_list|)
expr_stmt|;
name|d
operator|>>=
literal|8
expr_stmt|;
block|}
name|cputc
argument_list|(
name|d
argument_list|,
name|decode_fp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|err
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
comment|/* error number */
block|{
if|if
condition|(
name|n
operator|==
name|SE_FULL
condition|)
name|perror
argument_list|(
literal|"ship"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|errors
index|[
name|n
operator|-
literal|1
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
block|}
end_function

end_unit

