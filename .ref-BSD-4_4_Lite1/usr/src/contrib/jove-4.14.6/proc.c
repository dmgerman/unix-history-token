begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"re.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_include
include|#
directive|include
file|"rec.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|void
name|DoShell
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|com_finish
name|proto
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|SigMask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This disgusting RE search string parses output from the GREP    family, from the pdp11 compiler, pcc, and lint.  Jay (HACK)    Fenlasen changed this to work for the lint errors. */
end_comment

begin_decl_stmt
name|char
name|ErrFmtStr
index|[
literal|256
index|]
init|=
literal|"^\\{\",\\}\\([^:\"( \t]*\\)\\{\"\\, line ,:,(\\} *\\([0-9][0-9]*\\)[:)]\ \\|::  *\\([^(]*\\)(\\([0-9]*\\))$\ \\|( \\([^(]*\\)(\\([0-9]*\\)) ),"
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|error
block|{
name|Buffer
modifier|*
name|er_buf
decl_stmt|;
comment|/* Buffer error is in */
name|Line
modifier|*
name|er_mess
decl_stmt|,
comment|/* Actual error message */
modifier|*
name|er_text
decl_stmt|;
comment|/* Actual error */
name|int
name|er_char
decl_stmt|;
comment|/* char pos of error */
name|struct
name|error
modifier|*
name|er_prev
decl_stmt|,
comment|/* List of errors */
modifier|*
name|er_next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|struct
name|error
modifier|*
name|cur_error
init|=
name|NULL
decl_stmt|,
modifier|*
name|errorlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Buffer
modifier|*
name|perr_buf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer with error messages */
end_comment

begin_decl_stmt
name|bool
name|WtOnMk
init|=
name|ON
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write the modified files when we make */
end_comment

begin_comment
comment|/* Eliminate any error records that contain dangling references to Lines.  * We only eliminate error structs when either referent is recycled.  * If it deleted, we keep it (dormant) in case it will be pasted back  * into the same buffer.  */
end_comment

begin_function
name|void
name|ChkErrorLines
parameter_list|()
block|{
specifier|register
name|struct
name|error
modifier|*
name|e
decl_stmt|;
name|struct
name|error
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|e
operator|=
name|errorlist
init|;
name|e
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|error
modifier|*
name|next
init|=
name|e
operator|->
name|er_next
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|er_mess
operator|->
name|l_dline
operator|==
name|NULL_DADDR
operator|||
name|e
operator|->
name|er_text
operator|->
name|l_dline
operator|==
name|NULL_DADDR
condition|)
block|{
comment|/* dangling reference: delete */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|errorlist
operator|=
name|next
expr_stmt|;
else|else
name|prev
operator|->
name|er_next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
name|next
operator|->
name|er_prev
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|cur_error
operator|==
name|e
condition|)
name|cur_error
operator|=
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|e
expr_stmt|;
block|}
name|e
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add an error to the end of the list of errors.  This is used for    parse-{C,LINT}-errors and for the spell-buffer command */
end_comment

begin_decl_stmt
name|private
name|struct
name|error
modifier|*
name|AddError
argument_list|(
name|laste
argument_list|,
name|errline
argument_list|,
name|buf
argument_list|,
name|line
argument_list|,
name|charpos
argument_list|)
decl|struct
name|error
modifier|*
name|laste
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Line
modifier|*
name|errline
decl_stmt|,
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Buffer
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|charpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|error
modifier|*
name|new
init|=
operator|(
expr|struct
name|error
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|)
decl_stmt|;
name|new
operator|->
name|er_prev
operator|=
name|laste
expr_stmt|;
if|if
condition|(
name|laste
condition|)
name|laste
operator|->
name|er_next
operator|=
name|new
expr_stmt|;
else|else
block|{
if|if
condition|(
name|errorlist
condition|)
comment|/* Free up old errors */
name|ErrFree
argument_list|()
expr_stmt|;
name|cur_error
operator|=
name|errorlist
operator|=
name|new
expr_stmt|;
block|}
name|laste
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|er_next
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|er_buf
operator|=
name|buf
expr_stmt|;
name|new
operator|->
name|er_text
operator|=
name|line
expr_stmt|;
name|new
operator|->
name|er_char
operator|=
name|charpos
expr_stmt|;
name|new
operator|->
name|er_mess
operator|=
name|errline
expr_stmt|;
return|return
name|new
return|;
block|}
end_block

begin_function
name|void
name|get_FL_info
parameter_list|(
name|fname
parameter_list|,
name|lineno
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|,
decl|*
name|lineno
decl_stmt|;
end_function

begin_block
block|{
name|putmatch
argument_list|(
literal|1
argument_list|,
name|fname
argument_list|,
operator|(
name|size_t
operator|)
name|FILESIZE
argument_list|)
expr_stmt|;
name|putmatch
argument_list|(
literal|2
argument_list|,
name|lineno
argument_list|,
operator|(
name|size_t
operator|)
name|FILESIZE
argument_list|)
expr_stmt|;
comment|/* error had lineno followed fname, so switch the two */
if|if
condition|(
operator|!
name|jisdigit
argument_list|(
name|lineno
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|char
name|tmp
index|[
name|FILESIZE
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lineno
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fname
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Free up all the errors */
end_comment

begin_function
name|void
name|ErrFree
parameter_list|()
block|{
specifier|register
name|struct
name|error
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|errorlist
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|ep
operator|->
name|er_next
control|)
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|ep
argument_list|)
expr_stmt|;
name|errorlist
operator|=
name|cur_error
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse errors of the form specified in ErrFmtStr in the current    buffer.  Do a show error of the first error.  This is neat because this    will work for any kind of output that prints a file name and a line    number on the same line. */
end_comment

begin_function
name|void
name|ErrParse
parameter_list|()
block|{
name|struct
name|RE_block
name|re_blk
decl_stmt|;
name|Bufpos
modifier|*
name|bp
decl_stmt|;
name|char
name|fname
index|[
name|FILESIZE
index|]
decl_stmt|,
name|lineno
index|[
name|FILESIZE
index|]
decl_stmt|;
name|int
name|lnum
decl_stmt|,
name|last_lnum
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|error
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|Buffer
modifier|*
name|buf
decl_stmt|,
modifier|*
name|lastb
init|=
name|NULL
decl_stmt|;
name|Line
modifier|*
name|err_line
decl_stmt|;
name|ErrFree
argument_list|()
expr_stmt|;
comment|/* This is important! */
name|ToFirst
argument_list|()
expr_stmt|;
name|perr_buf
operator|=
name|curbuf
expr_stmt|;
name|REcompile
argument_list|(
name|ErrFmtStr
argument_list|,
name|YES
argument_list|,
operator|&
name|re_blk
argument_list|)
expr_stmt|;
comment|/* Find a line with a number on it. */
while|while
condition|(
operator|(
name|bp
operator|=
name|docompiled
argument_list|(
name|FORWARD
argument_list|,
operator|&
name|re_blk
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|get_FL_info
argument_list|(
name|fname
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|buf
operator|=
name|do_find
argument_list|(
operator|(
name|Window
operator|*
operator|)
name|NULL
argument_list|,
name|fname
argument_list|,
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|lastb
condition|)
block|{
name|lastb
operator|=
name|buf
expr_stmt|;
name|last_lnum
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* signals new file */
name|err_line
operator|=
name|buf
operator|->
name|b_first
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|chr_to_int
argument_list|(
name|lineno
argument_list|,
literal|10
argument_list|,
name|NO
argument_list|,
operator|&
name|lnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnum
operator|==
name|last_lnum
condition|)
comment|/* one error per line is nicer */
continue|continue;
if|if
condition|(
name|last_lnum
operator|==
operator|-
literal|1
condition|)
name|last_lnum
operator|=
literal|1
expr_stmt|;
comment|/* that's where we really are */
name|err_line
operator|=
name|next_line
argument_list|(
name|err_line
argument_list|,
name|lnum
operator|-
name|last_lnum
argument_list|)
expr_stmt|;
name|ep
operator|=
name|AddError
argument_list|(
name|ep
argument_list|,
name|curline
argument_list|,
name|buf
argument_list|,
name|err_line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last_lnum
operator|=
name|lnum
expr_stmt|;
block|}
if|if
condition|(
name|cur_error
operator|!=
name|NULL
condition|)
name|ShowErr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|NeedErrors
parameter_list|()
block|{
if|if
condition|(
name|cur_error
operator|==
name|NULL
condition|)
name|complain
argument_list|(
literal|"No errors!"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|bool
name|ErrorHasReferents
parameter_list|()
block|{
return|return
name|inlist
argument_list|(
name|cur_error
operator|->
name|er_buf
operator|->
name|b_first
argument_list|,
name|cur_error
operator|->
name|er_text
argument_list|)
operator|&&
name|inlist
argument_list|(
name|perr_buf
operator|->
name|b_first
argument_list|,
name|cur_error
operator|->
name|er_mess
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Go the the next error, if there is one.  Put the error buffer in    one window and the buffer with the error in another window.    It checks to make sure that the error actually exists. */
end_comment

begin_function
name|private
name|void
name|ToError
parameter_list|(
name|forward
parameter_list|)
name|bool
name|forward
decl_stmt|;
block|{
specifier|register
name|struct
name|error
modifier|*
name|e
init|=
name|cur_error
decl_stmt|;
name|int
name|num
init|=
name|arg_value
argument_list|()
decl_stmt|;
name|NeedErrors
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|forward
condition|?
name|e
operator|->
name|er_next
else|:
name|e
operator|->
name|er_prev
operator|)
operator|==
name|NULL
condition|)
name|complain
argument_list|(
literal|"You're at the %s error."
argument_list|,
name|forward
condition|?
literal|"last"
else|:
literal|"first"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|num
operator|>=
literal|0
operator|||
operator|!
name|ErrorHasReferents
argument_list|()
condition|)
block|{
name|e
operator|=
name|forward
condition|?
name|e
operator|->
name|er_next
else|:
name|e
operator|->
name|er_prev
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
break|break;
name|cur_error
operator|=
name|e
expr_stmt|;
block|}
name|ShowErr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|NextError
parameter_list|()
block|{
name|ToError
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|PrevError
parameter_list|()
block|{
name|ToError
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|EWSize
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* percentage of screen the error window 			   should be */
end_comment

begin_function
name|private
name|void
name|set_wsize
parameter_list|(
name|wsize
parameter_list|)
name|int
name|wsize
decl_stmt|;
block|{
name|wsize
operator|=
operator|(
name|LI
operator|*
name|wsize
operator|)
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|wsize
operator|>=
literal|1
operator|&&
operator|!
name|one_windp
argument_list|()
condition|)
name|WindSize
argument_list|(
name|curwind
argument_list|,
name|wsize
operator|-
operator|(
name|curwind
operator|->
name|w_height
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Show the current error, i.e. put the line containing the error message    in one window, and the buffer containing the actual error in another    window. */
end_comment

begin_function
name|void
name|ShowErr
parameter_list|()
block|{
name|Window
modifier|*
name|err_wind
decl_stmt|,
modifier|*
name|buf_wind
decl_stmt|;
name|NeedErrors
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ErrorHasReferents
argument_list|()
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
return|return;
block|}
name|err_wind
operator|=
name|windbp
argument_list|(
name|perr_buf
argument_list|)
expr_stmt|;
name|buf_wind
operator|=
name|windbp
argument_list|(
name|cur_error
operator|->
name|er_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_wind
operator|&&
operator|!
name|buf_wind
condition|)
block|{
name|SetWind
argument_list|(
name|err_wind
argument_list|)
expr_stmt|;
name|pop_wind
argument_list|(
name|cur_error
operator|->
name|er_buf
operator|->
name|b_name
argument_list|,
name|NO
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf_wind
operator|=
name|curwind
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|err_wind
operator|&&
name|buf_wind
condition|)
block|{
name|SetWind
argument_list|(
name|buf_wind
argument_list|)
expr_stmt|;
name|pop_wind
argument_list|(
name|perr_buf
operator|->
name|b_name
argument_list|,
name|NO
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|err_wind
operator|=
name|curwind
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|err_wind
operator|&&
operator|!
name|buf_wind
condition|)
block|{
name|pop_wind
argument_list|(
name|perr_buf
operator|->
name|b_name
argument_list|,
name|NO
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|err_wind
operator|=
name|curwind
expr_stmt|;
name|pop_wind
argument_list|(
name|cur_error
operator|->
name|er_buf
operator|->
name|b_name
argument_list|,
name|NO
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf_wind
operator|=
name|curwind
expr_stmt|;
block|}
comment|/* Put the current error message at the top of its Window */
name|SetWind
argument_list|(
name|err_wind
argument_list|)
expr_stmt|;
name|SetLine
argument_list|(
name|cur_error
operator|->
name|er_mess
argument_list|)
expr_stmt|;
name|SetTop
argument_list|(
name|curwind
argument_list|,
operator|(
name|curwind
operator|->
name|w_line
operator|=
name|cur_error
operator|->
name|er_mess
operator|)
argument_list|)
expr_stmt|;
name|set_wsize
argument_list|(
name|EWSize
argument_list|)
expr_stmt|;
comment|/* now go to the the line with the error in the other window */
name|SetWind
argument_list|(
name|buf_wind
argument_list|)
expr_stmt|;
name|DotTo
argument_list|(
name|cur_error
operator|->
name|er_text
argument_list|,
name|cur_error
operator|->
name|er_char
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
name|ShcomBuf
index|[
name|LBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make a buffer name given the command `command', i.e. "fgrep -n foo *.c"    will return the buffer name "fgrep".  */
end_comment

begin_function
name|char
modifier|*
name|MakeName
parameter_list|(
name|command
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
block|{
specifier|static
name|char
name|bnm
index|[
literal|50
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|bnm
decl_stmt|,
name|c
decl_stmt|;
do|do
empty_stmt|;
do|while
condition|(
operator|(
name|c
operator|=
operator|*
name|command
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
do|;
do|do
block|{
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
operator|*
name|command
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
operator|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|)
condition|)
do|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|bnm
argument_list|,
name|basename
argument_list|(
name|bnm
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bnm
return|;
block|}
end_function

begin_comment
comment|/* Run make, first writing all the modified buffers (if the WtOnMk flag is    on), parse the errors, and go the first error. */
end_comment

begin_decl_stmt
name|private
name|char
name|make_cmd
index|[
name|LBSIZE
index|]
init|=
literal|"make"
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|MakeErrors
parameter_list|()
block|{
name|Window
modifier|*
name|old
init|=
name|curwind
decl_stmt|;
name|int
name|status
decl_stmt|;
name|bool
name|compilation
decl_stmt|;
if|if
condition|(
name|WtOnMk
condition|)
name|put_bufs
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* When we're not doing make or cc (i.e., the last command 	   was probably a grep or something) and the user just types 	   C-X C-E, he probably (possibly, hopefully, usually (in my 	   case)) doesn't want to do the grep again but rather wants 	   to do a make again; so we ring the bell and insert the 	   default command and let the person decide. */
name|compilation
operator|=
operator|(
name|sindex
argument_list|(
literal|"make"
argument_list|,
name|make_cmd
argument_list|)
operator|||
name|sindex
argument_list|(
literal|"cc"
argument_list|,
name|make_cmd
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|is_an_arg
argument_list|()
operator|||
operator|!
name|compilation
condition|)
block|{
if|if
condition|(
operator|!
name|compilation
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
name|Inputp
operator|=
name|make_cmd
expr_stmt|;
comment|/* insert the default for the user */
block|}
name|null_ncpy
argument_list|(
name|make_cmd
argument_list|,
name|ask
argument_list|(
name|make_cmd
argument_list|,
literal|"Compilation command: "
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|make_cmd
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|UnixToBuf
argument_list|(
name|MakeName
argument_list|(
name|make_cmd
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|YES
argument_list|,
name|EWSize
argument_list|,
name|YES
argument_list|,
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|make_cmd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|com_finish
argument_list|(
name|status
argument_list|,
name|make_cmd
argument_list|)
expr_stmt|;
name|ErrParse
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cur_error
condition|)
name|SetWind
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SPELL
end_ifdef

begin_function
name|private
name|void
name|SpelParse
parameter_list|(
name|bname
parameter_list|)
name|char
modifier|*
name|bname
decl_stmt|;
block|{
name|Buffer
modifier|*
name|buftospel
decl_stmt|,
modifier|*
name|wordsb
decl_stmt|;
name|char
name|wordspel
index|[
literal|100
index|]
decl_stmt|;
name|Bufpos
modifier|*
name|bp
decl_stmt|;
name|struct
name|error
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|ErrFree
argument_list|()
expr_stmt|;
comment|/* This is important! */
name|buftospel
operator|=
name|curbuf
expr_stmt|;
name|wordsb
operator|=
name|buf_exists
argument_list|(
name|bname
argument_list|)
expr_stmt|;
name|perr_buf
operator|=
name|wordsb
expr_stmt|;
comment|/* This is important (buffer containing 				   error messages) */
name|SetBuf
argument_list|(
name|wordsb
argument_list|)
expr_stmt|;
name|ToFirst
argument_list|()
expr_stmt|;
name|f_mess
argument_list|(
literal|"Finding misspelled words ... "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|lastp
argument_list|(
name|curline
argument_list|)
condition|)
block|{
name|swritef
argument_list|(
name|wordspel
argument_list|,
sizeof|sizeof
argument_list|(
name|wordspel
argument_list|)
argument_list|,
literal|"\\<%s\\>"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|buftospel
argument_list|)
expr_stmt|;
name|ToFirst
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|dosearch
argument_list|(
name|wordspel
argument_list|,
name|FORWARD
argument_list|,
name|NO
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ep
operator|=
name|AddError
argument_list|(
name|ep
argument_list|,
name|wordsb
operator|->
name|b_dot
argument_list|,
name|buftospel
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
name|SetBuf
argument_list|(
name|wordsb
argument_list|)
expr_stmt|;
name|line_move
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
name|add_mess
argument_list|(
literal|"Done."
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|buftospel
argument_list|)
expr_stmt|;
name|ShowErr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SpelBuffer
parameter_list|()
block|{
name|char
modifier|*
name|Spell
init|=
literal|"Spell"
decl_stmt|,
name|com
index|[
literal|100
index|]
decl_stmt|;
name|Window
modifier|*
name|savewp
init|=
name|curwind
decl_stmt|;
if|if
condition|(
name|curbuf
operator|->
name|b_fname
operator|==
name|NULL
condition|)
name|complain
argument_list|(
literal|"no file name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsModified
argument_list|(
name|curbuf
argument_list|)
condition|)
name|SaveFile
argument_list|()
expr_stmt|;
name|swritef
argument_list|(
name|com
argument_list|,
sizeof|sizeof
argument_list|(
name|com
argument_list|)
argument_list|,
literal|"spell %s"
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|UnixToBuf
argument_list|(
name|Spell
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|YES
argument_list|,
name|EWSize
argument_list|,
name|YES
argument_list|,
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|com
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"[Delete the irrelevant words and then type C-X C-C]"
argument_list|)
expr_stmt|;
name|ToFirst
argument_list|()
expr_stmt|;
name|Recur
argument_list|()
expr_stmt|;
name|SetWind
argument_list|(
name|savewp
argument_list|)
expr_stmt|;
name|SpelParse
argument_list|(
name|Spell
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SpelWords
parameter_list|()
block|{
name|char
modifier|*
name|buftospel
decl_stmt|;
name|Buffer
modifier|*
name|wordsb
init|=
name|curbuf
decl_stmt|;
if|if
condition|(
operator|(
name|buftospel
operator|=
name|ask_buf
argument_list|(
operator|(
name|Buffer
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|SetBuf
argument_list|(
name|do_select
argument_list|(
name|curwind
argument_list|,
name|buftospel
argument_list|)
argument_list|)
expr_stmt|;
name|SpelParse
argument_list|(
name|wordsb
operator|->
name|b_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SPELL */
end_comment

begin_function
name|void
name|ShToBuf
parameter_list|()
block|{
name|char
name|bnm
index|[
literal|128
index|]
decl_stmt|,
name|cmd
index|[
name|LBSIZE
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|bnm
argument_list|,
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"Buffer: "
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cmd
argument_list|,
name|ask
argument_list|(
name|ShcomBuf
argument_list|,
literal|"Command: "
argument_list|)
argument_list|)
expr_stmt|;
name|DoShell
argument_list|(
name|bnm
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ShellCom
parameter_list|()
block|{
name|null_ncpy
argument_list|(
name|ShcomBuf
argument_list|,
name|ask
argument_list|(
name|ShcomBuf
argument_list|,
name|ProcFmt
argument_list|)
argument_list|,
operator|(
sizeof|sizeof
name|ShcomBuf
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|DoShell
argument_list|(
name|MakeName
argument_list|(
name|ShcomBuf
argument_list|)
argument_list|,
name|ShcomBuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ShNoBuf
parameter_list|()
block|{
name|int
name|status
decl_stmt|;
name|null_ncpy
argument_list|(
name|ShcomBuf
argument_list|,
name|ask
argument_list|(
name|ShcomBuf
argument_list|,
name|ProcFmt
argument_list|)
argument_list|,
operator|(
sizeof|sizeof
name|ShcomBuf
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|UnixToBuf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|NO
argument_list|,
literal|0
argument_list|,
name|NO
argument_list|,
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|ShcomBuf
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|com_finish
argument_list|(
name|status
argument_list|,
name|ShcomBuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Shtypeout
parameter_list|()
block|{
name|int
name|status
decl_stmt|;
name|null_ncpy
argument_list|(
name|ShcomBuf
argument_list|,
name|ask
argument_list|(
name|ShcomBuf
argument_list|,
name|ProcFmt
argument_list|)
argument_list|,
operator|(
sizeof|sizeof
name|ShcomBuf
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|UnixToBuf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|YES
argument_list|,
literal|0
argument_list|,
name|NO
argument_list|,
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|ShcomBuf
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|Typeout
argument_list|(
literal|"[%s: completed successfully]"
argument_list|,
name|ShcomBuf
argument_list|)
expr_stmt|;
else|else
name|Typeout
argument_list|(
literal|"[%s: exited (%d)]"
argument_list|,
name|ShcomBuf
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|TOstop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Run the shell command into `bnm'.  Empty the buffer except when we    give a numeric argument, in which case it inserts the output at the    current position in the buffer.  */
end_comment

begin_function
name|private
name|void
name|DoShell
parameter_list|(
name|bnm
parameter_list|,
name|command
parameter_list|)
name|char
modifier|*
name|bnm
decl_stmt|,
decl|*
name|command
decl_stmt|;
end_function

begin_block
block|{
name|Window
modifier|*
name|savewp
init|=
name|curwind
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|fn
init|=
name|pr_name
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
name|NO
argument_list|)
decl_stmt|;
comment|/* Two copies of the file name are passed to the shell: 	 * The Cshell uses the first as a definition of $1 	 * Most version of the Bourne shell use the second as a definition of $1. 	 */
name|status
operator|=
name|UnixToBuf
argument_list|(
name|bnm
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|YES
argument_list|,
literal|0
argument_list|,
operator|!
name|is_an_arg
argument_list|()
argument_list|,
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|command
argument_list|,
name|fn
argument_list|,
name|fn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|com_finish
argument_list|(
name|status
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|SetWind
argument_list|(
name|savewp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|private
name|void
name|com_finish
parameter_list|(
name|status
parameter_list|,
name|cmd
parameter_list|)
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|s_mess
argument_list|(
literal|"[%s: "
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|add_mess
argument_list|(
literal|"completed successfully"
argument_list|)
expr_stmt|;
else|else
name|add_mess
argument_list|(
literal|"exited (%d)"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS
end_ifndef

begin_function
name|void
name|dowait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|,
decl|*
name|status
decl_stmt|;
end_function

begin_block
block|{
ifndef|#
directive|ifndef
name|IPROCS
name|int
name|rpid
decl_stmt|;
do|do
empty_stmt|;
do|while
condition|(
operator|(
name|rpid
operator|=
name|wait
argument_list|(
name|status
argument_list|)
operator|)
operator|!=
name|pid
condition|)
do|;
else|#
directive|else
include|#
directive|include
file|"wait.h"
name|union
name|wait
name|w
decl_stmt|;
name|int
name|rpid
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifndef|#
directive|ifndef
name|WAIT3
name|rpid
operator|=
name|wait2
argument_list|(
operator|&
name|w
operator|.
name|w_status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|rpid
operator|=
name|wait3
argument_list|(
operator|&
name|w
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rpid
operator|==
operator|-
literal|1
condition|)
break|break;
elseif|else
if|if
condition|(
name|rpid
operator|==
name|pid
condition|)
block|{
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|w
operator|.
name|w_status
expr_stmt|;
break|break;
block|}
else|else
name|kill_off
argument_list|(
name|rpid
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPROCS */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_comment
comment|/* Run the command to bnm, erase the buffer if clobber is non-zero,    and redisplay if disp is non-zero.  Leaves current buffer in `bnm'    and leaves any windows it creates lying around.  It's up to the caller    to fix everything up after we're done.  (Usually there's nothing to    fix up.) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_function
name|int
name|UnixToBuf
parameter_list|(
name|char
modifier|*
name|bnm
parameter_list|,
name|char
modifier|*
name|InFName
parameter_list|,
name|bool
name|disp
parameter_list|,
name|int
name|wsize
parameter_list|,
name|bool
name|clobber
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/*VARARGS5*/
function|int UnixToBuf
parameter_list|(
name|bnm
parameter_list|,
name|InFName
parameter_list|,
name|disp
parameter_list|,
name|wsize
parameter_list|,
name|clobber
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|bnm
decl_stmt|,
decl|*
name|InFName
decl_stmt|;
end_function

begin_decl_stmt
name|bool
name|disp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|clobber
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
ifndef|#
directive|ifndef
name|MSDOS
name|int
name|p
index|[
literal|2
index|]
decl_stmt|,
name|pid
decl_stmt|;
else|#
directive|else
comment|/* MSDOS */
name|char
name|pnbuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|char
modifier|*
name|pipename
decl_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|int
name|status
decl_stmt|;
name|bool
name|eof
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|32
index|]
decl_stmt|,
modifier|*
name|mess
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
name|SIGRESULT
argument_list|(
argument|*old_int
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
name|va_init
argument_list|(
name|ap
argument_list|,
name|clobber
argument_list|)
expr_stmt|;
name|make_argv
argument_list|(
name|argv
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|bnm
operator|!=
name|NULL
operator|&&
name|clobber
operator|==
name|YES
condition|)
name|isprocbuf
argument_list|(
name|bnm
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|X_OK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|complain
argument_list|(
literal|"[Couldn't access %s: %s]"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|disp
condition|)
block|{
if|if
condition|(
name|bnm
operator|!=
name|NULL
condition|)
block|{
name|message
argument_list|(
literal|"Starting up..."
argument_list|)
expr_stmt|;
name|pop_wind
argument_list|(
name|bnm
argument_list|,
name|clobber
argument_list|,
name|clobber
condition|?
name|B_PROCESS
else|:
name|B_FILE
argument_list|)
expr_stmt|;
name|set_wsize
argument_list|(
name|wsize
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|TOstart
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"Starting up..."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now I will attempt to describe how I deal with signals during 	   the execution of the shell command.  My desire was to be able 	   to interrupt the shell command AS SOON AS the window pops up. 	   So, if we have BSD_SIGS (i.e., the new signal mechanism) I 	   hold SIGINT, meaning if we interrupt now, we will eventually 	   see the interrupt, but not before we are ready for it.  We 	   fork, the child releases the interrupt, it then sees the 	   interrupt, and so exits.  Meanwhile the parent ignores the 	   signal, so if there was a pending one, it's now lost.  	   With no BSD_SIGS, the best behavior you can expect is, when 	   you type ^] too very quickly after the window pops up, it may 	   be ignored.  The behavior BEFORE was that it would interrupt 	   JOVE and then you would have to continue JOVE and wait a 	   little while longer before trying again.  Now that is fixed, 	   in that you just have to type it twice. */
ifndef|#
directive|ifndef
name|MSDOS
ifdef|#
directive|ifdef
name|IPROCS
name|SigHold
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSD_SIGS
name|SigHold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
else|#
directive|else
name|old_int
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|,
endif|#
directive|endif
name|dopipe
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VFORK
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|pipeclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|complain
argument_list|(
literal|"[Fork failed: %s]"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|VFORK
comment|/* 		 * We want to release SIGCHLD and SIGINT in the child, 		 * but we can't use SigRelse because that would change 		 * Jove's copy of the SigMask variable (because we're in 		 * a vfork).  So we simply set set the mask directly. 		 * There are several other forks in Jove, but this is 		 * the only one we execute often enough to make it worth 		 * using a vfork.  This assumes a system with vfork also 		 * has BSD signals! 		 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|SigMask
operator|&
operator|~
operator|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !VFORK */
ifdef|#
directive|ifdef
name|IPROCS
name|SigRelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
comment|/* don't know if this matters */
endif|#
directive|endif
comment|/* IPROCS */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD_SIGS
name|SigRelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD_SIGS */
endif|#
directive|endif
comment|/* !VFORK */
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|open
argument_list|(
name|InFName
operator|==
name|NULL
condition|?
literal|"/dev/null"
else|:
name|InFName
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pipeclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|jcloseall
argument_list|()
expr_stmt|;
name|execv
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|raw_complain
argument_list|(
literal|"Execl failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BSD_SIGS
name|old_int
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fd_open
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|F_READ
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|iobuff
argument_list|,
name|LBSIZE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MSDOS */
block|{
name|int
name|oldi
init|=
name|dup
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|oldo
init|=
name|dup
argument_list|(
literal|1
argument_list|)
decl_stmt|,
name|olde
init|=
name|dup
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|bool
name|InFailure
init|=
name|FALSE
decl_stmt|;
name|int
name|ph
decl_stmt|;
name|swritef
argument_list|(
name|pnbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pnbuf
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|TmpFilePath
argument_list|,
literal|"jpXXXXXX"
argument_list|)
expr_stmt|;
name|pipename
operator|=
name|mktemp
argument_list|(
name|pnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ph
operator|=
name|creat
argument_list|(
name|pipename
argument_list|,
name|S_IWRITE
operator||
name|S_IREAD
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|complain
argument_list|(
literal|"cannot make pipe for filter: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|ph
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|ph
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|InFName
operator|==
name|NULL
condition|)
if|if
condition|(
name|open
argument_list|(
name|InFName
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|InFailure
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|InFailure
condition|)
name|status
operator|=
name|spawnv
argument_list|(
literal|0
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|oldi
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|oldo
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|olde
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|oldi
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|oldo
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|olde
argument_list|)
expr_stmt|;
if|if
condition|(
name|InFailure
condition|)
name|complain
argument_list|(
literal|"[filter input failed]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
name|complain
argument_list|(
literal|"[Spawn failed]"
argument_list|)
expr_stmt|;
name|ph
operator|=
name|open
argument_list|(
name|pipename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|<
literal|0
condition|)
name|complain
argument_list|(
literal|"[cannot reopen pipe]"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fd_open
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|F_READ
argument_list|,
name|ph
argument_list|,
name|iobuff
argument_list|,
name|LBSIZE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MSDOS */
do|do
block|{
ifndef|#
directive|ifndef
name|MSDOS
name|inIOread
operator|=
name|YES
expr_stmt|;
endif|#
directive|endif
name|eof
operator|=
name|f_gets
argument_list|(
name|fp
argument_list|,
name|genbuf
argument_list|,
operator|(
name|size_t
operator|)
name|LBSIZE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
name|inIOread
operator|=
name|NO
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bnm
operator|!=
name|NULL
condition|)
block|{
name|ins_str
argument_list|(
name|genbuf
argument_list|,
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eof
condition|)
name|LineInsert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|disp
condition|)
name|Typeout
argument_list|(
literal|"%s"
argument_list|,
name|genbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bnm
operator|!=
name|NULL
operator|&&
name|disp
operator|&&
name|fp
operator|->
name|f_cnt
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|LOAD_AV
block|{
name|int
name|la
init|=
name|get_la
argument_list|()
decl_stmt|;
if|if
condition|(
name|la
operator|<
literal|200
condition|)
name|mess
operator|=
literal|"Screaming along..."
expr_stmt|;
elseif|else
if|if
condition|(
name|la
operator|<
literal|500
condition|)
name|mess
operator|=
literal|"Chugging along..."
expr_stmt|;
else|else
name|mess
operator|=
literal|"Crawling along..."
expr_stmt|;
block|}
else|#
directive|else
name|mess
operator|=
literal|"Chugging along..."
expr_stmt|;
endif|#
directive|endif
comment|/* LOAD_AV */
if|if
condition|(
name|bnm
operator|!=
name|NULL
condition|)
block|{
name|message
argument_list|(
name|mess
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|eof
condition|)
do|;
if|if
condition|(
name|disp
condition|)
name|DrawMesg
argument_list|(
name|NO
argument_list|)
expr_stmt|;
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
name|dowait
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD_SIGS
operator|(
name|void
operator|)
name|SigRelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPROCS
name|SigRelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* MSDOS */
name|unlink
argument_list|(
name|pipename
argument_list|)
expr_stmt|;
name|getCWD
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|old_int
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_block

begin_comment
comment|/* Send the current region to CMD and insert the output from the    command into OUT_BUF. */
end_comment

begin_function
name|private
name|void
name|RegToUnix
parameter_list|(
name|outbuf
parameter_list|,
name|cmd
parameter_list|)
name|Buffer
modifier|*
name|outbuf
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|Mark
modifier|*
name|m
init|=
name|CurMark
argument_list|()
decl_stmt|;
specifier|static
name|char
name|tnambuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|char
modifier|*
name|tname
decl_stmt|;
name|Window
modifier|*
name|save_wind
init|=
name|curwind
decl_stmt|;
specifier|volatile
name|int
name|status
decl_stmt|;
specifier|volatile
name|int
name|err
init|=
name|NO
decl_stmt|;
name|File
modifier|*
specifier|volatile
name|fp
decl_stmt|;
name|jmp_buf
name|sav_jmp
decl_stmt|;
name|swritef
argument_list|(
name|tnambuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tnambuf
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|TmpFilePath
argument_list|,
literal|"jfXXXXXX"
argument_list|)
expr_stmt|;
name|tname
operator|=
name|mktemp
argument_list|(
name|tnambuf
argument_list|)
expr_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|tname
argument_list|,
name|iobuff
argument_list|,
name|F_WRITE
argument_list|,
name|YES
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|push_env
argument_list|(
name|sav_jmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|mainjmp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|putreg
argument_list|(
name|fp
argument_list|,
name|m
operator|->
name|m_line
argument_list|,
name|m
operator|->
name|m_char
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|DelReg
argument_list|()
expr_stmt|;
name|f_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|status
operator|=
name|UnixToBuf
argument_list|(
name|outbuf
operator|->
name|b_name
argument_list|,
name|tname
argument_list|,
name|NO
argument_list|,
literal|0
argument_list|,
name|outbuf
operator|->
name|b_type
operator|==
name|B_SCRATCH
argument_list|,
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|cmd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|err
operator|=
name|YES
expr_stmt|;
block|}
name|pop_env
argument_list|(
name|sav_jmp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|SetWind
argument_list|(
name|save_wind
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|com_finish
argument_list|(
name|status
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FilterRegion
parameter_list|()
block|{
specifier|static
name|char
name|FltComBuf
index|[
name|LBSIZE
index|]
decl_stmt|;
name|null_ncpy
argument_list|(
name|FltComBuf
argument_list|,
name|ask
argument_list|(
name|FltComBuf
argument_list|,
literal|": %f (through command) "
argument_list|)
argument_list|,
operator|(
sizeof|sizeof
name|FltComBuf
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|RegToUnix
argument_list|(
name|curbuf
argument_list|,
name|FltComBuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isprocbuf
parameter_list|(
name|bnm
parameter_list|)
name|char
modifier|*
name|bnm
decl_stmt|;
block|{
name|Buffer
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|buf_exists
argument_list|(
name|bnm
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|bp
operator|->
name|b_type
operator|!=
name|B_PROCESS
condition|)
name|confirm
argument_list|(
literal|"Over-write buffer %s? "
argument_list|,
name|bnm
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_comment
comment|/* ??? how many of these includes are redundant?  Are they needed in RegToUnix()? */
end_comment

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* ??? Set the DOS path separator character to '/' from '\\' */
end_comment

begin_function
name|char
name|switchar
parameter_list|()
block|{
name|union
name|REGS
name|regs
decl_stmt|;
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x37
expr_stmt|;
name|regs
operator|.
name|h
operator|.
name|al
operator|=
literal|0
expr_stmt|;
name|intdos
argument_list|(
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
return|return
name|regs
operator|.
name|h
operator|.
name|dl
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

end_unit

