begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|"mac.h"
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IBMPC
end_ifndef

begin_decl_stmt
specifier|const
endif|#
directive|endif
name|struct
name|cmd
modifier|*
name|FindCmd
argument_list|(
name|proc
argument_list|)
decl|register
name|void
argument_list|(
operator|*
name|proc
argument_list|)
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
specifier|const
name|struct
name|cmd
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|commands
init|;
name|cp
operator|->
name|Name
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|cp
operator|->
name|c_proc
operator|==
name|proc
condition|)
return|return
name|cp
return|;
return|return
name|NULL
return|;
block|}
end_block

begin_decl_stmt
name|bool
name|Interactive
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True when we invoke with the command handler? */
end_comment

begin_decl_stmt
name|data_obj
modifier|*
name|LastCmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ProcFmt
init|=
literal|": %f "
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ExecCmd
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|data_obj
modifier|*
name|cp
decl_stmt|;
block|{
name|LastCmd
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|Type
operator|&
name|MAJOR_MODE
condition|)
block|{
name|SetMajor
argument_list|(
operator|(
name|cp
operator|->
name|Type
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|->
name|Type
operator|&
name|MINOR_MODE
condition|)
block|{
name|TogMinor
argument_list|(
operator|(
name|cp
operator|->
name|Type
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|cp
operator|->
name|Type
operator|&
name|TYPEMASK
condition|)
block|{
case|case
name|MACRO
case|:
name|do_macro
argument_list|(
operator|(
expr|struct
name|macro
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION
case|:
block|{
specifier|register
name|struct
name|cmd
modifier|*
name|cmd
init|=
operator|(
expr|struct
name|cmd
operator|*
operator|)
name|cp
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_proc
condition|)
block|{
if|if
condition|(
operator|(
name|cmd
operator|->
name|Type
operator|&
name|MODIFIER
operator|)
operator|&&
operator|(
name|BufMinorMode
argument_list|(
name|curbuf
argument_list|,
name|ReadOnly
argument_list|)
operator|)
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"[Buffer is read-only]"
argument_list|)
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|cmd
operator|->
name|c_proc
call|)
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|Line
modifier|*
name|lastline
parameter_list|(
name|lp
parameter_list|)
specifier|register
name|Line
modifier|*
name|lp
decl_stmt|;
block|{
specifier|register
name|Line
modifier|*
name|next
decl_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|lp
operator|->
name|l_next
operator|)
operator|!=
name|NULL
condition|)
name|lp
operator|=
name|next
expr_stmt|;
return|return
name|lp
return|;
block|}
end_function

begin_decl_stmt
name|char
name|key_strokes
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|keys_p
init|=
name|key_strokes
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pp_key_strokes
parameter_list|(
name|buffer
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|buf_end
init|=
name|buffer
operator|+
name|size
operator|-
literal|1
decl_stmt|,
modifier|*
name|kp
init|=
name|key_strokes
decl_stmt|,
name|c
decl_stmt|;
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|kp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|swritef
argument_list|(
name|buffer
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|buf_end
operator|-
name|buffer
argument_list|)
argument_list|,
literal|"%p "
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|>=
name|buf_end
condition|)
break|break;
block|}
block|}
end_function

begin_decl_stmt
name|private
name|int
modifier|*
name|slowp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for waitchar() */
end_comment

begin_function
name|private
name|SIGRESULT
name|slowpoke
parameter_list|(
name|junk
parameter_list|)
name|int
name|junk
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
comment|/* Subtle, but necessary! */
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|slowp
condition|)
operator|*
name|slowp
operator|=
name|YES
expr_stmt|;
name|pp_key_strokes
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|f_mess
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|SIGRETURN
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_2
end_ifdef

begin_define
define|#
directive|define
name|N_SEC
value|1
end_define

begin_comment
comment|/* will be precisely 1 second on 4.2 */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|N_SEC
value|2
end_define

begin_comment
comment|/* but from 1 to 2 seconds otherwise */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !UNIX */
end_comment

begin_define
define|#
directive|define
name|N_SEC
value|1
end_define

begin_function_decl
name|int
name|in_macro
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !UNIX */
end_comment

begin_function
name|int
name|waitchar
parameter_list|(
name|slow
parameter_list|)
name|int
modifier|*
name|slow
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|UNIX
name|unsigned
name|int
name|old_time
decl_stmt|;
name|SIGRESULT
argument_list|(
argument|*oldproc
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !UNIX */
name|long
name|sw
decl_stmt|,
name|time
argument_list|()
decl_stmt|;
endif|#
directive|endif
comment|/* !UNIX */
name|slowp
operator|=
name|slow
expr_stmt|;
if|if
condition|(
name|in_macro
argument_list|()
condition|)
comment|/* make macros faster ... */
return|return
name|getch
argument_list|()
return|;
comment|/* If slow is a valid pointer and it's value is yes, then 	   we know we have already been slow during this sequence, 	   so we just wait for the character and then echo it. */
if|if
condition|(
name|slow
operator|!=
name|NULL
operator|&&
operator|*
name|slow
operator|==
name|YES
condition|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
name|slowpoke
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
ifdef|#
directive|ifdef
name|UNIX
name|oldproc
operator|=
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|slowpoke
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|old_time
operator|=
name|alarm
argument_list|(
operator|(
name|unsigned
operator|)
name|N_SEC
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|old_time
operator|=
name|UpdFreq
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
name|old_time
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|oldproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|slow
operator|!=
name|NULL
operator|&&
operator|*
name|slow
operator|==
name|YES
condition|)
name|slowpoke
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|c
return|;
else|#
directive|else
comment|/* !UNIX */
ifdef|#
directive|ifdef
name|MAC
name|Keyonly
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|charp
argument_list|()
operator|||
name|in_macro
argument_list|()
condition|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
comment|/* to avoid flicker */
if|if
condition|(
name|slow
operator|!=
name|NULL
operator|&&
operator|*
name|slow
operator|==
name|YES
condition|)
name|slowpoke
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
endif|#
directive|endif
name|time
argument_list|(
operator|&
name|sw
argument_list|)
expr_stmt|;
name|sw
operator|+=
name|N_SEC
expr_stmt|;
while|while
condition|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|<=
name|sw
condition|)
if|if
condition|(
name|charp
argument_list|()
operator|||
name|in_macro
argument_list|()
condition|)
return|return
name|getch
argument_list|()
return|;
ifdef|#
directive|ifdef
name|MAC
name|menus_off
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|slowpoke
argument_list|()
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
name|slowpoke
argument_list|()
expr_stmt|;
return|return
name|c
return|;
endif|#
directive|endif
comment|/* !UNIX */
block|}
end_function

begin_function
name|char
modifier|*
name|StrIndex
parameter_list|(
name|dir
parameter_list|,
name|buf
parameter_list|,
name|charpos
parameter_list|,
name|what
parameter_list|)
name|int
name|dir
decl_stmt|;
comment|/* FORWARD or BACKWARD */
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|charpos
decl_stmt|;
specifier|register
name|int
name|what
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
operator|&
name|buf
index|[
name|charpos
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|(
name|c
operator|==
name|what
operator|)
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|cp
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
while|while
condition|(
name|cp
operator|>=
name|buf
operator|&&
operator|(
name|c
operator|=
operator|*
name|cp
operator|--
operator|)
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|c
operator|==
name|what
condition|)
return|return
operator|(
name|cp
operator|+
literal|1
operator|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|bool
name|blnkp
parameter_list|(
name|buf
parameter_list|)
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
do|do
empty_stmt|;
do|while
condition|(
operator|(
name|c
operator|=
operator|*
name|buf
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
do|;
return|return
name|c
operator|==
literal|0
return|;
comment|/* It's zero if we got to the end of the Line */
block|}
end_function

begin_function
name|bool
name|within_indent
parameter_list|()
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|curchar
expr_stmt|;
do|do
empty_stmt|;
do|while
condition|(
operator|--
name|i
operator|>=
literal|0
operator|&&
operator|(
operator|(
name|c
operator|=
name|linebuf
index|[
name|i
index|]
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
do|;
return|return
name|i
operator|<
literal|0
return|;
comment|/* it's< 0 if we got to the beginning */
block|}
end_function

begin_function
name|Line
modifier|*
name|next_line
parameter_list|(
name|line
parameter_list|,
name|num
parameter_list|)
specifier|register
name|Line
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|<
literal|0
condition|)
return|return
name|prev_line
argument_list|(
name|line
argument_list|,
operator|-
name|num
argument_list|)
return|;
if|if
condition|(
name|line
condition|)
while|while
condition|(
operator|--
name|num
operator|>=
literal|0
operator|&&
name|line
operator|->
name|l_next
operator|!=
name|NULL
condition|)
name|line
operator|=
name|line
operator|->
name|l_next
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_function
name|Line
modifier|*
name|prev_line
parameter_list|(
name|line
parameter_list|,
name|num
parameter_list|)
specifier|register
name|Line
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|<
literal|0
condition|)
return|return
name|next_line
argument_list|(
name|line
argument_list|,
operator|-
name|num
argument_list|)
return|;
if|if
condition|(
name|line
condition|)
while|while
condition|(
operator|--
name|num
operator|>=
literal|0
operator|&&
name|line
operator|->
name|l_prev
operator|!=
name|NULL
condition|)
name|line
operator|=
name|line
operator|->
name|l_prev
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_function
name|void
name|DotTo
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
name|Line
modifier|*
name|line
decl_stmt|;
name|int
name|col
decl_stmt|;
block|{
name|Bufpos
name|bp
decl_stmt|;
name|bp
operator|.
name|p_line
operator|=
name|line
expr_stmt|;
name|bp
operator|.
name|p_char
operator|=
name|col
expr_stmt|;
name|SetDot
argument_list|(
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If bp->p_line is != current line, then save current line.  Then set dot    to bp->p_line, and if they weren't equal get that line into linebuf.  */
end_comment

begin_function
name|void
name|SetDot
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|Bufpos
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|int
name|notequal
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return;
name|notequal
operator|=
name|bp
operator|->
name|p_line
operator|!=
name|curline
expr_stmt|;
if|if
condition|(
name|notequal
condition|)
name|lsave
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|p_line
condition|)
name|curline
operator|=
name|bp
operator|->
name|p_line
expr_stmt|;
if|if
condition|(
name|notequal
condition|)
name|getDOT
argument_list|()
expr_stmt|;
name|curchar
operator|=
name|bp
operator|->
name|p_char
expr_stmt|;
if|if
condition|(
name|curchar
operator|>
name|length
argument_list|(
name|curline
argument_list|)
condition|)
name|curchar
operator|=
name|length
argument_list|(
name|curline
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ToLast
parameter_list|()
block|{
name|SetLine
argument_list|(
name|curbuf
operator|->
name|b_last
argument_list|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|MarkThresh
init|=
literal|22
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* average screen size ... */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_diff
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|LineDist
parameter_list|(
name|nextp
parameter_list|,
name|endp
parameter_list|)
specifier|register
name|Line
modifier|*
name|nextp
decl_stmt|,
decl|*
name|endp
decl_stmt|;
end_function

begin_block
block|{
operator|(
name|void
operator|)
name|inorder
argument_list|(
name|nextp
argument_list|,
literal|0
argument_list|,
name|endp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|line_diff
return|;
block|}
end_block

begin_function
name|int
name|inorder
parameter_list|(
name|nextp
parameter_list|,
name|char1
parameter_list|,
name|endp
parameter_list|,
name|char2
parameter_list|)
specifier|register
name|Line
modifier|*
name|nextp
decl_stmt|,
decl|*
name|endp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|char1
decl_stmt|,
name|char2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Line
modifier|*
name|prevp
init|=
name|nextp
decl_stmt|;
name|line_diff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nextp
operator|==
name|endp
condition|)
return|return
name|char1
operator|<
name|char2
return|;
while|while
condition|(
name|nextp
operator|&&
name|prevp
condition|)
block|{
name|nextp
operator|=
name|nextp
operator|->
name|l_next
expr_stmt|;
name|prevp
operator|=
name|prevp
operator|->
name|l_prev
expr_stmt|;
name|line_diff
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|nextp
operator|==
name|endp
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|prevp
operator|==
name|endp
condition|)
return|return
name|FALSE
return|;
block|}
while|while
condition|(
name|nextp
operator|!=
name|NULL
operator|&&
name|nextp
operator|!=
name|endp
condition|)
block|{
name|nextp
operator|=
name|nextp
operator|->
name|l_next
expr_stmt|;
name|line_diff
operator|+=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|prevp
operator|!=
name|NULL
operator|&&
name|prevp
operator|!=
name|endp
condition|)
block|{
name|prevp
operator|=
name|prevp
operator|->
name|l_prev
expr_stmt|;
name|line_diff
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* nextp == prevp implies both are NULL: the lines are not ordered */
return|return
name|nextp
operator|==
name|prevp
condition|?
operator|-
literal|1
else|:
name|nextp
operator|==
name|endp
return|;
block|}
end_block

begin_function
name|void
name|PushPntp
parameter_list|(
name|line
parameter_list|)
specifier|register
name|Line
modifier|*
name|line
decl_stmt|;
block|{
if|if
condition|(
name|LineDist
argument_list|(
name|curline
argument_list|,
name|line
argument_list|)
operator|>=
name|MarkThresh
condition|)
name|set_mark
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ToFirst
parameter_list|()
block|{
name|SetLine
argument_list|(
name|curbuf
operator|->
name|b_first
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|length
parameter_list|(
name|line
parameter_list|)
name|Line
modifier|*
name|line
decl_stmt|;
block|{
return|return
name|strlen
argument_list|(
name|lcontents
argument_list|(
name|line
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|to_word
parameter_list|(
name|dir
parameter_list|)
specifier|register
name|int
name|dir
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|linebuf
index|[
name|curchar
index|]
operator|)
operator|!=
literal|'\0'
operator|&&
operator|!
name|jisword
argument_list|(
name|c
argument_list|)
condition|)
name|curchar
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|eolp
argument_list|()
condition|)
block|{
if|if
condition|(
name|curline
operator|->
name|l_next
operator|==
name|NULL
condition|)
return|return;
name|SetLine
argument_list|(
name|curline
operator|->
name|l_next
argument_list|)
expr_stmt|;
name|to_word
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|!
name|bolp
argument_list|()
operator|&&
operator|(
name|c
operator|=
name|linebuf
index|[
name|curchar
operator|-
literal|1
index|]
operator|,
operator|!
name|jisword
argument_list|(
name|c
argument_list|)
operator|)
condition|)
name|curchar
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|bolp
argument_list|()
condition|)
block|{
if|if
condition|(
name|curline
operator|->
name|l_prev
operator|==
name|NULL
condition|)
return|return;
name|SetLine
argument_list|(
name|curline
operator|->
name|l_prev
argument_list|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
name|to_word
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Are there any modified buffers?  Allp means include B_PROCESS    buffers in the check. */
end_comment

begin_function
name|bool
name|ModBufs
parameter_list|(
name|allp
parameter_list|)
name|bool
name|allp
decl_stmt|;
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
if|if
condition|(
name|b
operator|->
name|b_type
operator|!=
name|B_SCRATCH
operator|&&
operator|(
name|b
operator|->
name|b_type
operator|==
name|B_FILE
operator|||
name|allp
operator|)
operator|&&
name|IsModified
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|YES
return|;
return|return
name|NO
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|filename
parameter_list|(
name|b
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
block|{
return|return
name|b
operator|->
name|b_fname
condition|?
name|pr_name
argument_list|(
name|b
operator|->
name|b_fname
argument_list|,
name|YES
argument_list|)
else|:
literal|"[No file]"
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|itoa
parameter_list|(
name|num
parameter_list|)
specifier|register
name|int
name|num
decl_stmt|;
block|{
specifier|static
name|char
name|line
index|[
literal|15
index|]
decl_stmt|;
name|swritef
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_function
name|int
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|<
name|b
operator|)
condition|?
name|a
else|:
name|b
return|;
block|}
end_function

begin_function
name|int
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|>
name|b
operator|)
condition|?
name|a
else|:
name|b
return|;
block|}
end_function

begin_function
name|void
name|tiewind
parameter_list|(
name|w
parameter_list|,
name|bp
parameter_list|)
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|not_tied
init|=
operator|(
name|w
operator|->
name|w_bufp
operator|!=
name|bp
operator|)
decl_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
comment|/* kludge ... but speeds things up considerably */
name|w
operator|->
name|w_line
operator|=
name|bp
operator|->
name|b_dot
expr_stmt|;
name|w
operator|->
name|w_char
operator|=
name|bp
operator|->
name|b_char
expr_stmt|;
name|w
operator|->
name|w_bufp
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|not_tied
condition|)
name|CalcWind
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|/* ah, this has been missing since the 				   beginning of time! */
block|}
end_function

begin_function
name|char
modifier|*
name|lcontents
parameter_list|(
name|line
parameter_list|)
specifier|register
name|Line
modifier|*
name|line
decl_stmt|;
block|{
if|if
condition|(
name|line
operator|==
name|curline
condition|)
return|return
name|linebuf
return|;
else|else
return|return
name|lbptr
argument_list|(
name|line
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ltobuf
parameter_list|(
name|line
parameter_list|,
name|buf
parameter_list|)
name|Line
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
name|line
operator|==
name|curline
condition|)
block|{
if|if
condition|(
name|buf
operator|!=
name|linebuf
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|Jr_Len
operator|=
name|strlen
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
else|else
name|getline
argument_list|(
name|line
operator|->
name|l_dline
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|void
name|DOTsave
parameter_list|(
name|buf
parameter_list|)
name|Bufpos
modifier|*
name|buf
decl_stmt|;
block|{
name|buf
operator|->
name|p_line
operator|=
name|curline
expr_stmt|;
name|buf
operator|->
name|p_char
operator|=
name|curchar
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return none-zero if we had to rearrange the order. */
end_comment

begin_function
name|bool
name|fixorder
parameter_list|(
name|line1
parameter_list|,
name|char1
parameter_list|,
name|line2
parameter_list|,
name|char2
parameter_list|)
specifier|register
name|Line
modifier|*
modifier|*
name|line1
decl_stmt|,
decl|*
modifier|*
name|line2
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
modifier|*
name|char1
decl_stmt|,
modifier|*
name|char2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Line
modifier|*
name|tline
decl_stmt|;
name|int
name|tchar
decl_stmt|;
if|if
condition|(
name|inorder
argument_list|(
operator|*
name|line1
argument_list|,
operator|*
name|char1
argument_list|,
operator|*
name|line2
argument_list|,
operator|*
name|char2
argument_list|)
condition|)
return|return
name|NO
return|;
name|tline
operator|=
operator|*
name|line1
expr_stmt|;
name|tchar
operator|=
operator|*
name|char1
expr_stmt|;
operator|*
name|line1
operator|=
operator|*
name|line2
expr_stmt|;
operator|*
name|char1
operator|=
operator|*
name|char2
expr_stmt|;
operator|*
name|line2
operator|=
name|tline
expr_stmt|;
operator|*
name|char2
operator|=
name|tchar
expr_stmt|;
return|return
name|YES
return|;
block|}
end_block

begin_function
name|bool
name|inlist
parameter_list|(
name|first
parameter_list|,
name|what
parameter_list|)
specifier|register
name|Line
modifier|*
name|first
decl_stmt|,
decl|*
name|what
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|first
operator|==
name|what
condition|)
return|return
name|YES
return|;
name|first
operator|=
name|first
operator|->
name|l_next
expr_stmt|;
block|}
return|return
name|NO
return|;
block|}
end_block

begin_comment
comment|/* Make `buf' (un)modified and tell the redisplay code to update the modeline    if it will need to be changed. */
end_comment

begin_decl_stmt
name|int
name|ModCount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|modify
parameter_list|()
block|{
if|if
condition|(
operator|!
name|curbuf
operator|->
name|b_modified
condition|)
block|{
name|UpdModLine
operator|=
name|YES
expr_stmt|;
name|curbuf
operator|->
name|b_modified
operator|=
name|YES
expr_stmt|;
block|}
name|DOLsave
operator|=
name|YES
expr_stmt|;
if|if
condition|(
operator|!
name|Asking
condition|)
name|ModCount
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unmodify
parameter_list|()
block|{
if|if
condition|(
name|curbuf
operator|->
name|b_modified
condition|)
block|{
name|UpdModLine
operator|=
name|YES
expr_stmt|;
name|curbuf
operator|->
name|b_modified
operator|=
name|NO
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|numcomp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s1
operator|!=
literal|'\0'
operator|&&
operator|*
name|s1
operator|++
operator|==
operator|*
name|s2
operator|++
condition|)
name|count
operator|+=
literal|1
expr_stmt|;
return|return
name|count
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|copystr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|val
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|val
operator|=
name|emalloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|val
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|byte_copy
end_ifndef

begin_function
name|void
name|byte_copy
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|count
parameter_list|)
name|UnivConstPtr
modifier|*
name|from
decl_stmt|;
name|UnivPtr
modifier|*
name|to
decl_stmt|;
specifier|register
name|size_t
name|count
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|p
init|=
name|from
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
init|=
name|to
decl_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
do|do
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|count
operator|!=
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|len_error
parameter_list|(
name|flag
parameter_list|)
name|int
name|flag
decl_stmt|;
block|{
name|char
modifier|*
name|mesg
init|=
literal|"[line too long]"
decl_stmt|;
if|if
condition|(
name|flag
operator|==
name|COMPLAIN
condition|)
name|complain
argument_list|(
name|mesg
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|mesg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert num number of c's at offset atchar in a linebuf of LBSIZE */
end_comment

begin_function
name|void
name|ins_c
parameter_list|(
name|c
parameter_list|,
name|buf
parameter_list|,
name|atchar
parameter_list|,
name|num
parameter_list|,
name|max
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|atchar
decl_stmt|,
name|num
decl_stmt|,
name|max
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|pp
decl_stmt|,
modifier|*
name|pp1
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|numchars
decl_stmt|;
comment|/* number of characters to copy forward */
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return;
name|len
operator|=
name|atchar
operator|+
name|strlen
argument_list|(
operator|&
name|buf
index|[
name|atchar
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|num
operator|>=
name|max
condition|)
name|len_error
argument_list|(
name|COMPLAIN
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|&
name|buf
index|[
name|len
operator|+
literal|1
index|]
expr_stmt|;
comment|/* + 1 so we can --pp (not pp--) */
name|pp1
operator|=
operator|&
name|buf
index|[
name|len
operator|+
name|num
operator|+
literal|1
index|]
expr_stmt|;
name|numchars
operator|=
name|len
operator|-
name|atchar
expr_stmt|;
while|while
condition|(
name|numchars
operator|--
operator|>=
literal|0
condition|)
operator|*
operator|--
name|pp1
operator|=
operator|*
operator|--
name|pp
expr_stmt|;
name|pp
operator|=
operator|&
name|buf
index|[
name|atchar
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|num
operator|>=
literal|0
condition|)
operator|*
name|pp
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_function
name|int
name|TwoBlank
parameter_list|()
block|{
specifier|register
name|Line
modifier|*
name|next
init|=
name|curline
operator|->
name|l_next
decl_stmt|;
return|return
operator|(
operator|(
name|next
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
operator|(
name|lcontents
argument_list|(
name|next
argument_list|)
operator|)
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|next
operator|->
name|l_next
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
operator|(
name|lcontents
argument_list|(
name|next
operator|->
name|l_next
argument_list|)
operator|)
operator|==
literal|'\0'
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|linecopy
parameter_list|(
name|onto
parameter_list|,
name|atchar
parameter_list|,
name|from
parameter_list|)
specifier|register
name|char
modifier|*
name|onto
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|atchar
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|endp
init|=
operator|&
name|onto
index|[
name|LBSIZE
index|]
decl_stmt|;
name|onto
operator|+=
name|atchar
expr_stmt|;
do|do
block|{
if|if
condition|(
name|onto
operator|>=
name|endp
condition|)
name|len_error
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|onto
operator|++
operator|=
operator|*
name|from
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
do|;
block|}
end_block

begin_function
name|char
modifier|*
name|IOerr
parameter_list|(
name|err
parameter_list|,
name|file
parameter_list|)
name|char
modifier|*
name|err
decl_stmt|,
decl|*
name|file
decl_stmt|;
end_function

begin_block
block|{
return|return
name|sprint
argument_list|(
literal|"Couldn't %s \"%s\"."
argument_list|,
name|err
argument_list|,
name|file
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_function
name|void
name|dopipe
parameter_list|(
name|p
parameter_list|)
name|int
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|complain
argument_list|(
literal|"[Pipe failed: %s]"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pipeclose
parameter_list|(
name|p
parameter_list|)
name|int
modifier|*
name|p
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

begin_comment
comment|/* NOSTRICT */
end_comment

begin_function
name|UnivPtr
name|emalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|UnivPtr
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Try garbage collecting lines */
name|GCchunks
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Uh ... Oh screw it! */
name|error
argument_list|(
literal|"[Out of memory] "
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|UnivPtr
name|erealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|UnivPtr
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|ptr
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no second chance for realloc! */
name|error
argument_list|(
literal|"[out of memory]"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Return the basename of file F. */
end_comment

begin_function
name|char
modifier|*
name|basename
parameter_list|(
name|f
parameter_list|)
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|f
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|cp
operator|+
literal|1
return|;
elseif|else
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
name|cp
operator|=
name|strrchr
argument_list|(
name|f
argument_list|,
literal|'\\'
argument_list|)
condition|)
return|return
name|cp
operator|+
literal|1
return|;
elseif|else
if|if
condition|(
name|cp
operator|=
name|strrchr
argument_list|(
name|f
argument_list|,
literal|':'
argument_list|)
condition|)
return|return
name|cp
operator|+
literal|1
return|;
endif|#
directive|endif
comment|/* MSDOS */
return|return
name|f
return|;
block|}
end_function

begin_function
name|void
name|push_env
parameter_list|(
name|savejmp
parameter_list|)
name|jmp_buf
name|savejmp
decl_stmt|;
block|{
name|byte_copy
argument_list|(
operator|(
name|UnivPtr
operator|)
name|mainjmp
argument_list|,
operator|(
name|UnivPtr
operator|)
name|savejmp
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_env
parameter_list|(
name|savejmp
parameter_list|)
name|jmp_buf
name|savejmp
decl_stmt|;
block|{
name|byte_copy
argument_list|(
operator|(
name|UnivPtr
operator|)
name|savejmp
argument_list|,
operator|(
name|UnivPtr
operator|)
name|mainjmp
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get the time buf, designated by *timep, from FROM to TO. */
end_comment

begin_function
name|char
modifier|*
name|get_time
parameter_list|(
name|timep
parameter_list|,
name|buf
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|time_t
modifier|*
name|timep
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|time_t
name|now
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|timep
operator|!=
name|NULL
condition|)
name|now
operator|=
operator|*
name|timep
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
operator|+
name|from
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
if|if
condition|(
name|to
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
comment|/* MSDOS */
if|if
condition|(
operator|(
name|to
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|cp
index|[
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
endif|#
directive|endif
comment|/* MSDOS */
name|cp
index|[
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get rid of \n */
else|else
name|cp
index|[
name|to
operator|-
name|from
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
else|else
block|{
return|return
name|cp
return|;
block|}
block|}
end_function

begin_function
name|int
name|casecmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
name|s2
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* which is not zero ... */
while|while
condition|(
name|CharUpcase
argument_list|(
operator|*
name|s1
argument_list|)
operator|==
name|CharUpcase
argument_list|(
operator|*
name|s2
operator|++
argument_list|)
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|*
name|s1
operator|-
operator|*
operator|--
name|s2
operator|)
return|;
block|}
end_block

begin_function
name|int
name|casencmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|size_t
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
name|s2
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* which is not zero ... */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|CharUpcase
argument_list|(
operator|*
name|s1
argument_list|)
operator|!=
name|CharUpcase
argument_list|(
operator|*
name|s2
operator|++
argument_list|)
condition|)
return|return
operator|*
name|s1
operator|-
operator|*
operator|--
name|s2
return|;
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
block|}
block|}
end_block

begin_function
name|void
name|null_ncpy
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|to
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|to
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Tries to pause for delay/10 seconds OR until a character is typed    at the keyboard.  This works well on BSD4_2 and not so well on the    rest. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_2
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|BSD2_10
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_include
include|#
directive|include
file|<bios.h>
end_include

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|SitFor
parameter_list|(
name|delay
parameter_list|)
name|int
name|delay
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MAC
name|long
name|start
decl_stmt|,
name|end
decl_stmt|;
define|#
directive|define
name|Ticks
value|((long *) 0x16A)
comment|/* 1/60 sec */
name|Keyonly
operator|=
name|YES
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
name|start
operator|=
operator|*
name|Ticks
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|delay
operator|*
literal|6
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|InputPending
operator|=
name|charp
argument_list|()
operator|)
operator|!=
name|NO
condition|)
break|break;
block|}
do|while
condition|(
operator|*
name|Ticks
operator|<
name|end
condition|)
do|;
undef|#
directive|undef
name|Ticks
else|#
directive|else
comment|/* !MAC */
ifndef|#
directive|ifndef
name|MSDOS
if|if
condition|(
operator|!
name|charp
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BSD2_10
argument_list|)
name|struct
name|timeval
name|timer
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
literal|0
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
comment|/* So messages that aren't error messages don't 		 * hang around forever. 		 * Gross that I had to snarf this from getch() 		 */
if|if
condition|(
operator|!
name|UpdMesg
operator|&&
operator|!
name|Asking
operator|&&
name|mesgbuf
index|[
literal|0
index|]
operator|&&
operator|!
name|errormsg
condition|)
name|message
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
name|timer
operator|.
name|tv_sec
operator|=
operator|(
name|delay
operator|/
literal|10
operator|)
expr_stmt|;
name|timer
operator|.
name|tv_usec
operator|=
operator|(
name|delay
operator|%
literal|10
operator|)
operator|*
literal|100000
expr_stmt|;
name|select
argument_list|(
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|timer
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !(defined(BSD4_2)&& !defined(BSD2_10)) */
comment|/* Pause by spitting NULs at the terminal.  Ugh! */
specifier|static
specifier|const
name|int
name|cps
index|[]
init|=
block|{
literal|0
block|,
literal|5
block|,
literal|7
block|,
literal|11
block|,
literal|13
block|,
literal|15
block|,
literal|20
block|,
literal|30
block|,
literal|60
block|,
literal|120
block|,
literal|180
block|,
literal|240
block|,
literal|480
block|,
literal|960
block|,
literal|1920
block|,
literal|1920
block|, 		}
decl_stmt|;
specifier|register
name|int
name|nchars
decl_stmt|,
name|check_cnt
decl_stmt|;
name|nchars
operator|=
operator|(
name|delay
operator|*
name|cps
index|[
name|ospeed
index|]
operator|)
operator|/
literal|10
expr_stmt|;
name|check_cnt
operator|=
name|BufSize
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|NP
condition|)
block|{
while|while
condition|(
operator|(
operator|--
name|nchars
operator|>
literal|0
operator|)
operator|&&
operator|!
name|InputPending
condition|)
block|{
name|jputchar
argument_list|(
name|PC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|check_cnt
operator|==
literal|0
condition|)
block|{
name|check_cnt
operator|=
name|BufSize
expr_stmt|;
name|InputPending
operator|=
name|charp
argument_list|()
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* !(defined(BSD4_2)&& !defined(BSD2_10)) */
block|}
else|#
directive|else
comment|/* MSDOS */
name|long
name|start
decl_stmt|,
name|end
decl_stmt|;
ifndef|#
directive|ifndef
name|IBMPC
name|struct
name|dostime_t
name|tc
decl_stmt|;
endif|#
directive|endif
name|redisplay
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
name|_bios_timeofday
argument_list|(
name|_TIME_GETCLOCK
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
else|#
directive|else
name|_dos_gettime
argument_list|(
operator|&
name|tc
argument_list|)
expr_stmt|;
name|start
operator|=
call|(
name|long
call|)
argument_list|(
name|tc
operator|.
name|hour
operator|*
literal|60L
operator|*
literal|60L
operator|*
literal|10L
argument_list|)
operator|+
call|(
name|long
call|)
argument_list|(
name|tc
operator|.
name|minute
operator|*
literal|60L
operator|*
literal|10L
argument_list|)
operator|+
call|(
name|long
call|)
argument_list|(
name|tc
operator|.
name|second
operator|*
literal|10
argument_list|)
operator|+
call|(
name|long
call|)
argument_list|(
name|tc
operator|.
name|hsecond
operator|/
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|end
operator|=
operator|(
name|start
operator|+
name|delay
operator|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|InputPending
operator|=
name|charp
argument_list|()
operator|)
operator|!=
name|NO
condition|)
break|break;
ifdef|#
directive|ifdef
name|IBMPC
if|if
condition|(
name|_bios_timeofday
argument_list|(
name|_TIME_GETCLOCK
argument_list|,
operator|&
name|start
argument_list|)
condition|)
break|break;
comment|/* after midnight */
else|#
directive|else
name|start
operator|=
call|(
name|long
call|)
argument_list|(
name|tc
operator|.
name|hour
operator|*
literal|60L
operator|*
literal|60L
operator|*
literal|10L
argument_list|)
operator|+
call|(
name|long
call|)
argument_list|(
name|tc
operator|.
name|minute
operator|*
literal|60L
operator|*
literal|10L
argument_list|)
operator|+
call|(
name|long
call|)
argument_list|(
name|tc
operator|.
name|second
operator|*
literal|10
argument_list|)
operator|+
call|(
name|long
call|)
argument_list|(
name|tc
operator|.
name|hsecond
operator|/
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
name|start
operator|<
name|end
condition|)
do|;
endif|#
directive|endif
comment|/* MSDOS */
endif|#
directive|endif
comment|/* !MAC */
block|}
end_function

begin_function
name|bool
name|sindex
parameter_list|(
name|pattern
parameter_list|,
name|string
parameter_list|)
specifier|register
name|char
modifier|*
name|pattern
decl_stmt|,
decl|*
name|string
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|pattern
operator|==
operator|*
name|string
operator|&&
name|strncmp
argument_list|(
name|pattern
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|string
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_function
name|void
name|make_argv
parameter_list|(
name|argv
parameter_list|,
name|ap
parameter_list|)
specifier|register
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|basename
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
do|do
empty_stmt|;
do|while
condition|(
operator|(
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_function
name|int
name|pnt_line
parameter_list|()
block|{
specifier|register
name|Line
modifier|*
name|lp
init|=
name|curbuf
operator|->
name|b_first
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lp
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
if|if
condition|(
name|lp
operator|==
name|curline
condition|)
break|break;
return|return
name|i
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Free, then allocate a block.  * Like erealloc, except that the previous contents of the block are lost.  */
end_comment

begin_function
name|UnivPtr
name|freealloc
parameter_list|(
name|obj
parameter_list|,
name|size
parameter_list|)
specifier|register
name|UnivPtr
name|obj
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|UnivPtr
name|new
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|obj
condition|)
name|new
operator|=
name|realloc
argument_list|(
name|obj
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
name|new
operator|=
name|emalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRERROR
end_ifndef

begin_comment
comment|/*  * Unix version of strerror - map error number to descriptive string.  * ANSI systems should have this.  */
end_comment

begin_function
name|char
modifier|*
name|strerror
parameter_list|(
name|errnum
parameter_list|)
name|int
name|errnum
decl_stmt|;
block|{
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
if|if
condition|(
name|errnum
operator|>
literal|0
operator|&&
name|errnum
operator|<
name|sys_nerr
condition|)
return|return
operator|(
name|sys_errlist
index|[
name|errnum
index|]
operator|)
return|;
return|return
name|sprint
argument_list|(
literal|"Error number %d"
argument_list|,
name|errnum
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

