begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|RCSid
index|[]
init|=
literal|"$Header: procedures.c,v 2.2 86/11/11 09:49:06 jqj Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* $Log:	procedures.c,v $  * Revision 2.2  86/11/11  09:49:06  jqj  * Per Ed Flint, if a Courier procedure returns void, the server should still  * do a SendReturnMessage(0,0), so generate the proper code for this case.  * Note that this eventually implies (in xnslib/readwrite.c) that a writev()  * has an iovec with 0 length, which might tickle a kernel bug in some  * implementations.  *   * Revision 2.1  86/06/06  07:28:49  jqj  * many mods for better symbol table management:  added CurrentModule,  *  made check_dependency, make_symbol, check_def set/use/use a symbol  *  table instead of a module name string, etc.  Result is that we can  *  now handle DEPENDS UPON 2 versions of same program.  *   * Revision 2.0  85/11/21  07:21:43  jqj  * 4.3BSD standard release  *   * Revision 1.5  85/05/06  08:13:31  jqj  * *** empty log message ***  *   * Revision 1.5  85/05/06  08:13:31  jqj  * Almost Beta-test version.  *   * Revision 1.4  85/03/26  06:10:21  jqj  * Revised public alpha-test version, released 26 March 1985  *   * Revision 1.3  85/03/11  16:39:55  jqj  * Public alpha-test version, released 11 March 1985  *   * Revision 1.2  85/02/21  11:05:39  jqj  * alpha test version  *   * Revision 1.1  85/02/15  13:55:36  jqj  * Initial revision  *   */
end_comment

begin_define
define|#
directive|define
name|argname
parameter_list|(
name|p
parameter_list|)
value|((char *) car(caar(p)))
end_define

begin_define
define|#
directive|define
name|argtype
parameter_list|(
name|p
parameter_list|)
value|((struct type *) cdar(p))
end_define

begin_comment
comment|/*  * routines for generating procedures and errors  */
end_comment

begin_include
include|#
directive|include
file|"compiler.h"
end_include

begin_comment
comment|/*  * Generate client and server functions for procedure declarations.  */
end_comment

begin_macro
name|define_procedure_constant
argument_list|(
argument|symbol
argument_list|,
argument|typtr
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|object
modifier|*
name|symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|constant
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|type
modifier|*
name|resulttype
decl_stmt|;
name|char
modifier|*
name|procvalue
decl_stmt|;
name|char
modifier|*
name|resultname
decl_stmt|;
name|char
name|buf
index|[
name|MAXSTR
index|]
decl_stmt|;
name|list
name|p
decl_stmt|,
name|q
decl_stmt|;
if|if
condition|(
name|recursive_flag
condition|)
comment|/* don't bother to do anything for procs */
return|return;
comment|/* in DEPENDS UPON modules */
if|if
condition|(
name|typtr
operator|->
name|type_constr
operator|!=
name|C_PROCEDURE
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"internal error (define_procedure): not a procedure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|->
name|cn_constr
operator|!=
name|C_NUMERIC
condition|)
block|{
name|error
argument_list|(
name|ERROR
argument_list|,
literal|"Values of procedure constants must be numeric"
argument_list|)
expr_stmt|;
name|procvalue
operator|=
literal|"-1"
expr_stmt|;
block|}
else|else
name|procvalue
operator|=
name|value
operator|->
name|cn_value
expr_stmt|;
comment|/* 	 * RETURNS stuff:  coerce the result to be a single record 	 */
if|if
condition|(
name|length
argument_list|(
name|typtr
operator|->
name|type_results
argument_list|)
operator|>
literal|0
condition|)
block|{
name|struct
name|object
modifier|*
name|resultobj
decl_stmt|;
name|resulttype
operator|=
name|record_type
argument_list|(
name|typtr
operator|->
name|type_results
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%sResults"
argument_list|,
name|name_of
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|resultname
operator|=
name|copy
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|resultobj
operator|=
name|make_symbol
argument_list|(
name|resultname
argument_list|,
name|CurrentModule
argument_list|)
expr_stmt|;
name|define_type
argument_list|(
name|resultobj
argument_list|,
name|resulttype
argument_list|)
expr_stmt|;
comment|/* replaces define_record_type(resulttype); */
name|typtr
operator|->
name|type_results
operator|=
name|cons
argument_list|(
name|cons
argument_list|(
name|cons
argument_list|(
operator|(
name|list
operator|)
name|resultname
argument_list|,
name|NIL
argument_list|)
argument_list|,
operator|(
name|list
operator|)
name|resulttype
argument_list|)
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * REPORTS stuff:  check here to make sure the errors are all defined 	 */
for|for
control|(
name|p
operator|=
name|typtr
operator|->
name|type_errors
operator|,
name|q
operator|=
name|NIL
init|;
name|p
operator|!=
name|NIL
condition|;
name|q
operator|=
name|p
operator|,
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|struct
name|object
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|check_def
argument_list|(
operator|(
name|char
operator|*
operator|)
name|car
argument_list|(
name|p
argument_list|)
argument_list|,
name|CurrentModule
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
operator|(
expr|struct
name|object
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
name|ERROR
argument_list|,
literal|"Error constant %s not defined"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NIL
condition|)
name|typtr
operator|->
name|type_errors
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|cdr
argument_list|(
name|q
argument_list|)
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|o_class
operator|!=
name|O_CONSTANT
operator|||
name|sym
operator|->
name|o_constant
operator|->
name|cn_constr
operator|!=
name|C_ERROR
condition|)
block|{
name|error
argument_list|(
name|ERROR
argument_list|,
literal|"Symbol %s is not of appropriate type"
argument_list|,
name|name_of
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NIL
condition|)
name|typtr
operator|->
name|type_errors
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|cdr
argument_list|(
name|q
argument_list|)
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Argument stuff:  make sure all the argument types are defined 	 */
for|for
control|(
name|p
operator|=
name|typtr
operator|->
name|type_args
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|typename
argument_list|(
name|argtype
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|object
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|make_symbol
argument_list|(
name|gensym
argument_list|(
literal|"T_p"
argument_list|)
argument_list|,
name|CurrentModule
argument_list|)
expr_stmt|;
name|define_type
argument_list|(
name|name
argument_list|,
name|argtype
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Actually generate code for this procedure 	 */
name|proc_functions
argument_list|(
name|symbol
operator|->
name|o_constant
operator|->
name|cn_name
argument_list|,
name|typtr
argument_list|,
name|procvalue
argument_list|)
expr_stmt|;
comment|/* 	 * Save this procedure on the global procs for wrapup (server  	 * dispatch code) 	 */
name|Procedures
operator|=
name|cons
argument_list|(
name|cons
argument_list|(
operator|(
name|list
operator|)
name|symbol
operator|->
name|o_constant
operator|->
name|cn_name
argument_list|,
operator|(
name|list
operator|)
name|procvalue
argument_list|)
argument_list|,
name|Procedures
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Generate funcions for client and server calls to a procedure.  */
end_comment

begin_macro
name|proc_functions
argument_list|(
argument|proc_name
argument_list|,
argument|type
argument_list|,
argument|proc_number
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|proc_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|proc_number
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|list
name|p
decl_stmt|;
name|int
name|nresults
decl_stmt|,
name|fixed_size
decl_stmt|,
name|variable_size
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|,
modifier|*
name|bt
decl_stmt|,
modifier|*
name|result_type
decl_stmt|;
name|char
modifier|*
name|result_name
decl_stmt|,
modifier|*
name|ref
decl_stmt|,
modifier|*
name|rtname
decl_stmt|;
comment|/* 	 * Make sure there is at most one result returned. 	 */
name|nresults
operator|=
name|length
argument_list|(
name|type
operator|->
name|type_results
argument_list|)
expr_stmt|;
if|if
condition|(
name|nresults
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
name|ERROR
argument_list|,
literal|"procedures that return multiple results are not supported"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nresults
condition|)
block|{
name|result_name
operator|=
literal|"_Results"
expr_stmt|;
name|result_type
operator|=
name|argtype
argument_list|(
name|type
operator|->
name|type_results
argument_list|)
expr_stmt|;
name|rtname
operator|=
name|typename
argument_list|(
name|result_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtname
operator|=
literal|"void"
expr_stmt|;
block|}
comment|/* 	 * Server routine. 	 */
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\nextern %s %s();\n"
argument_list|,
name|rtname
argument_list|,
name|proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\nserver_%s(_buf)\n\ \tregister Unspecified *_buf;\n\ {\n\ \tregister Unspecified *_bp = _buf;\n\ \tregister LongCardinal _n;\n"
argument_list|,
name|proc_name
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|type
operator|->
name|type_args
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|t
operator|=
name|argtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\t%s %s;\n"
argument_list|,
name|typename
argument_list|(
name|t
argument_list|)
argument_list|,
name|argname
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nresults
condition|)
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\t%s %s;\n"
argument_list|,
name|rtname
argument_list|,
name|result_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Generate code to internalize the arguments. 	 */
for|for
control|(
name|p
operator|=
name|type
operator|->
name|type_args
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|t
operator|=
name|argtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ref
operator|=
name|refstr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\t_bp += %s(%s%s, _bp);\n"
argument_list|,
name|xfn
argument_list|(
name|INTERNALIZE
argument_list|,
name|t
argument_list|)
argument_list|,
name|ref
argument_list|,
name|argname
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Generate code to call the procedure. 	 */
if|if
condition|(
name|nresults
condition|)
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\t%s = %s(_serverConnection, 0"
argument_list|,
name|result_name
argument_list|,
name|proc_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\t%s(_serverConnection, 0"
argument_list|,
name|proc_name
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|type
operator|->
name|type_args
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|server
argument_list|,
literal|", %s"
argument_list|,
name|argname
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|server
argument_list|,
literal|");\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Generate code to externalize the result. 	 */
if|if
condition|(
name|nresults
condition|)
block|{
name|ref
operator|=
name|refstr
argument_list|(
name|result_type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\t_n = sizeof_%s(%s%s);\n\ \t_bp = Allocate(_n);\n\ \t%s(%s%s, _bp);\n\ \tSendReturnMessage(_n, _bp);\n\ \tDeallocate(_bp);\n\ }\n"
argument_list|,
name|rtname
argument_list|,
name|ref
argument_list|,
name|result_name
argument_list|,
name|xfn
argument_list|(
name|EXTERNALIZE
argument_list|,
name|result_type
argument_list|)
argument_list|,
name|ref
argument_list|,
name|result_name
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|server
argument_list|,
literal|"\tSendReturnMessage( 0, _bp);\n\ }\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Stub routine for client. 	 */
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\nextern %s %s();\n"
argument_list|,
name|rtname
argument_list|,
name|proc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\n\ %s\n\ %s(_Connection, _BDTprocptr"
argument_list|,
name|rtname
argument_list|,
name|proc_name
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|type
operator|->
name|type_args
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
name|fprintf
argument_list|(
name|client
argument_list|,
literal|", %s"
argument_list|,
name|argname
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|client
argument_list|,
literal|")\n\ \tCourierConnection *_Connection;\n\ \tint (*_BDTprocptr)();\n\ "
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|type
operator|->
name|type_args
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|t
operator|=
name|argtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\t%s %s;\n"
argument_list|,
name|typename
argument_list|(
name|t
argument_list|)
argument_list|,
name|argname
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nresults
condition|)
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\t%s %s;\n"
argument_list|,
name|rtname
argument_list|,
name|result_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\tregister Unspecified *_buf, *_bp;\n\ \tBoolean _errorflag;\n\ \tCardinal _errtype;\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Determine the size of the arguments. 	 * This is like the code in record_type(). 	 */
name|fixed_size
operator|=
literal|0
expr_stmt|;
name|variable_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|type
operator|->
name|type_args
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|bt
operator|=
name|argtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|type_xsize
operator|==
operator|-
literal|1
condition|)
block|{
name|variable_size
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fixed_size
operator|+=
name|bt
operator|->
name|type_xsize
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|variable_size
condition|)
block|{
comment|/* 		 * The argument list is fixed-size. 		 */
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\n\ \t_buf = Allocate(%d);\n"
argument_list|,
name|fixed_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * There are some variable-size arguments. 		 */
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\tregister LongCardinal _n = %d;\n\ \n"
argument_list|,
name|fixed_size
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|type
operator|->
name|type_args
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|t
operator|=
name|argtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bt
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|type_xsize
operator|!=
operator|-
literal|1
condition|)
continue|continue;
name|ref
operator|=
name|refstr
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\t_n += sizeof_%s(%s%s);\n"
argument_list|,
name|typename
argument_list|(
name|t
argument_list|)
argument_list|,
name|ref
argument_list|,
name|argname
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\t_buf = Allocate(_n);\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\t_bp = _buf;\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Generate code to externalize the arguments. 	 */
for|for
control|(
name|p
operator|=
name|type
operator|->
name|type_args
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|t
operator|=
name|argtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ref
operator|=
name|refstr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\t_bp += %s(%s%s, _bp);\n"
argument_list|,
name|xfn
argument_list|(
name|EXTERNALIZE
argument_list|,
name|t
argument_list|)
argument_list|,
name|ref
argument_list|,
name|argname
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|variable_size
condition|)
block|{
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\tSendCallMessage(_Connection, %d, %d, %s, %d, _buf);\n"
argument_list|,
name|CurrentNumber
argument_list|,
name|CurrentVersion
argument_list|,
name|proc_number
argument_list|,
name|fixed_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\tSendCallMessage(_Connection, %d, %d, %s, _n, _buf);\n"
argument_list|,
name|CurrentNumber
argument_list|,
name|CurrentVersion
argument_list|,
name|proc_number
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\tDeallocate(_buf);\n\ \tMaybeCallBDTHandler(_Connection, _BDTprocptr);\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Generate code to receive the results and interpret them 	 * as errors 	 */
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\t_bp = ReceiveReturnMessage(_Connection,&_errorflag);\n\ \t_buf = _bp;\n\ \tif (_errorflag) {\n\ \t\t_bp += %s(&_errtype, _bp);\n\ \t\tswitch (ERROR_OFFSET+_errtype) {\n"
argument_list|,
name|xfn
argument_list|(
name|INTERNALIZE
argument_list|,
name|Cardinal_type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|type
operator|->
name|type_errors
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|struct
name|constant
modifier|*
name|errconst
decl_stmt|;
name|struct
name|type
modifier|*
name|errtype
decl_stmt|;
name|errconst
operator|=
operator|(
name|check_def
argument_list|(
operator|(
name|char
operator|*
operator|)
name|car
argument_list|(
name|p
argument_list|)
argument_list|,
name|CurrentModule
argument_list|)
operator|)
operator|->
name|o_constant
expr_stmt|;
name|errtype
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdr
argument_list|(
name|errconst
operator|->
name|cn_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|errtype
operator|==
name|TNIL
condition|)
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\t\tcase %s:\n\ \t\t\traise(ERROR_OFFSET+_errtype, 0);\n\ \t\t\t/*NOTREACHED*/\n"
argument_list|,
name|errconst
operator|->
name|cn_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\t\tcase %s: {\n\ \t\t\tstatic %s _result;\n\ \t\t\t_bp += %s(%s_result, _bp);\n\ \t\t\traise(ERROR_OFFSET+_errtype, (char *)&_result);\n\ \t\t\t/*NOTREACHED*/\n\ \t\t\t}\n"
argument_list|,
name|errconst
operator|->
name|cn_name
argument_list|,
name|typename
argument_list|(
name|errtype
argument_list|)
argument_list|,
name|xfn
argument_list|(
name|INTERNALIZE
argument_list|,
name|errtype
argument_list|)
argument_list|,
name|refstr
argument_list|(
name|errtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\t\tdefault:\n\ \t\t\t/* don't know how to unpack this */\n\ \t\t\traise(ERROR_OFFSET+_errtype, 0);\n\ \t\t\t/*NOTREACHED*/\n\ \t\t}\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Code to unpack results and return 	 */
if|if
condition|(
name|nresults
condition|)
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\t} else\n\ \t\t_bp += %s(%s%s, _bp);\n\ \tDeallocate(_buf);\n\ \treturn (%s);\n\ }\n"
argument_list|,
name|xfn
argument_list|(
name|INTERNALIZE
argument_list|,
name|result_type
argument_list|)
argument_list|,
name|refstr
argument_list|(
name|result_type
argument_list|)
argument_list|,
name|result_name
argument_list|,
name|result_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|client
argument_list|,
literal|"\t}\n\ \tDeallocate(_buf);\n\ }\n"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

