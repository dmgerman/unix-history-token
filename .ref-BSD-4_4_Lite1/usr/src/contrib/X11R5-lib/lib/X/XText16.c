begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XText16.c,v 11.21 91/01/06 11:48:27 rws Exp $ */
end_comment

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1986	*/
end_comment

begin_comment
comment|/* Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_macro
name|XDrawString16
argument_list|(
argument|register Display *dpy
argument_list|,
argument|Drawable d
argument_list|,
argument|GC gc
argument_list|,
argument|int x
argument_list|,
argument|int y
argument_list|,
argument|_Xconst XChar2b *string
argument_list|,
argument|int length
argument_list|)
end_macro

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|XDrawString16
argument_list|(
name|dpy
argument_list|,
name|d
argument_list|,
name|gc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
specifier|register
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Drawable
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|GC
name|gc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|XChar2b
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|Datalength
init|=
literal|0
decl_stmt|;
specifier|register
name|xPolyText16Req
modifier|*
name|req
decl_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
return|return;
name|LockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|FlushGC
argument_list|(
name|dpy
argument_list|,
name|gc
argument_list|)
expr_stmt|;
name|GetReq
argument_list|(
name|PolyText16
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|req
operator|->
name|drawable
operator|=
name|d
expr_stmt|;
name|req
operator|->
name|gc
operator|=
name|gc
operator|->
name|gid
expr_stmt|;
name|req
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|req
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|Datalength
operator|+=
name|SIZEOF
argument_list|(
name|xTextElt
argument_list|)
operator|*
operator|(
operator|(
name|length
operator|+
literal|253
operator|)
operator|/
literal|254
operator|)
operator|+
operator|(
name|length
operator|<<
literal|1
operator|)
expr_stmt|;
name|req
operator|->
name|length
operator|+=
operator|(
name|Datalength
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* convert to number of 32-bit words */
comment|/*       * If the entire request does not fit into the remaining space in the      * buffer, flush the buffer first.   If the request does fit into the      * empty buffer, then we won't have to flush it at the end to keep      * the buffer 32-bit aligned.       */
if|if
condition|(
name|dpy
operator|->
name|bufptr
operator|+
name|Datalength
operator|>
name|dpy
operator|->
name|bufmax
condition|)
name|_XFlush
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|{
name|int
name|nbytes
decl_stmt|;
name|int
name|PartialNChars
init|=
name|length
decl_stmt|;
specifier|register
name|xTextElt
modifier|*
name|elt
decl_stmt|;
name|XChar2b
modifier|*
name|CharacterOffset
init|=
operator|(
name|XChar2b
operator|*
operator|)
name|string
decl_stmt|;
while|while
condition|(
name|PartialNChars
operator|>
literal|254
condition|)
block|{
name|nbytes
operator|=
literal|254
operator|*
literal|2
operator|+
name|SIZEOF
argument_list|(
name|xTextElt
argument_list|)
expr_stmt|;
name|BufAlloc
argument_list|(
name|xTextElt
operator|*
argument_list|,
name|elt
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|elt
operator|->
name|delta
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|len
operator|=
literal|254
expr_stmt|;
ifdef|#
directive|ifdef
name|MUSTCOPY
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cp
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|elt
operator|)
operator|+
literal|2
init|;
name|i
operator|<
literal|254
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|cp
operator|++
operator|=
name|CharacterOffset
index|[
name|i
index|]
operator|.
name|byte1
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|CharacterOffset
index|[
name|i
index|]
operator|.
name|byte2
expr_stmt|;
block|}
block|}
else|#
directive|else
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|CharacterOffset
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|elt
operator|+
literal|1
operator|)
argument_list|,
literal|254
operator|*
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PartialNChars
operator|=
name|PartialNChars
operator|-
literal|254
expr_stmt|;
name|CharacterOffset
operator|+=
literal|254
expr_stmt|;
block|}
if|if
condition|(
name|PartialNChars
condition|)
block|{
name|nbytes
operator|=
name|PartialNChars
operator|*
literal|2
operator|+
name|SIZEOF
argument_list|(
name|xTextElt
argument_list|)
expr_stmt|;
name|BufAlloc
argument_list|(
name|xTextElt
operator|*
argument_list|,
name|elt
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|elt
operator|->
name|delta
operator|=
literal|0
expr_stmt|;
name|elt
operator|->
name|len
operator|=
name|PartialNChars
expr_stmt|;
ifdef|#
directive|ifdef
name|MUSTCOPY
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cp
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|elt
operator|)
operator|+
literal|2
init|;
name|i
operator|<
name|PartialNChars
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|cp
operator|++
operator|=
name|CharacterOffset
index|[
name|i
index|]
operator|.
name|byte1
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|CharacterOffset
index|[
name|i
index|]
operator|.
name|byte2
expr_stmt|;
block|}
block|}
else|#
directive|else
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|CharacterOffset
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|elt
operator|+
literal|1
operator|)
argument_list|,
name|PartialNChars
operator|*
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Pad request out to a 32-bit boundary */
if|if
condition|(
name|Datalength
operator|&=
literal|3
condition|)
block|{
name|char
modifier|*
name|pad
decl_stmt|;
comment|/*  	 * BufAlloc is a macro that uses its last argument more than 	 * once, otherwise I'd write "BufAlloc (char *, pad, 4-length)"  	 */
name|length
operator|=
literal|4
operator|-
name|Datalength
expr_stmt|;
name|BufAlloc
argument_list|(
name|char
operator|*
argument_list|,
name|pad
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/*  	 * if there are 3 bytes of padding, the first byte MUST be 0 	 * so the pad bytes aren't mistaken for a final xTextElt  	 */
operator|*
name|pad
operator|=
literal|0
expr_stmt|;
block|}
comment|/*       * If the buffer pointer is not now pointing to a 32-bit boundary,      * we must flush the buffer so that it does point to a 32-bit boundary      * at the end of this routine.       */
if|if
condition|(
operator|(
name|dpy
operator|->
name|bufptr
operator|-
name|dpy
operator|->
name|buffer
operator|)
operator|&
literal|3
condition|)
name|_XFlush
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|SyncHandle
argument_list|()
expr_stmt|;
return|return;
block|}
end_block

end_unit

