begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XcmsCCC.c,v 1.11 91/12/20 15:58:21 rws Exp $" */
end_comment

begin_comment
comment|/*  * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.  * 	All Rights Reserved  *   * This file is a component of an X Window System-specific implementation  * of Xcms based on the TekColor Color Management System.  Permission is  * hereby granted to use, copy, modify, sell, and otherwise distribute this  * software and its documentation for any purpose and without fee, provided  * that this copyright, permission, and disclaimer notice is reproduced in  * all copies of this software and in supporting documentation.  TekColor  * is a trademark of Tektronix, Inc.  *   * Tektronix makes no representation about the suitability of this software  * for any purpose.  It is provided "as is" and with all faults.  *   * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,  * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY  * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER  * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF  * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.  *  *  *	NAME  *		XcmsCCC.c - Color Conversion Context Routines  *  *	DESCRIPTION  *		Routines to create, access, and free Color Conversion  *		Context structures.  *  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xcmsint.h"
end_include

begin_function_decl
specifier|extern
name|XcmsIntensityMap
modifier|*
name|_XcmsGetIntensityMap
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/************************************************************************  *									*  *			PUBLIC INTERFACES				*  *									*  ************************************************************************/
end_comment

begin_comment
comment|/*  *	NAME  *		XcmsCreateCCC  *  *	SYNOPSIS  */
end_comment

begin_function
name|XcmsCCC
name|XcmsCreateCCC
parameter_list|(
name|dpy
parameter_list|,
name|screenNumber
parameter_list|,
name|visual
parameter_list|,
name|clientWhitePt
parameter_list|,
name|gamutCompProc
parameter_list|,
name|gamutCompClientData
parameter_list|,
name|whitePtAdjProc
parameter_list|,
name|whitePtAdjClientData
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|int
name|screenNumber
decl_stmt|;
name|Visual
modifier|*
name|visual
decl_stmt|;
name|XcmsColor
modifier|*
name|clientWhitePt
decl_stmt|;
name|XcmsCompressionProc
name|gamutCompProc
decl_stmt|;
name|XPointer
name|gamutCompClientData
decl_stmt|;
name|XcmsWhiteAdjustProc
name|whitePtAdjProc
decl_stmt|;
name|XPointer
name|whitePtAdjClientData
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Given a Display, Screen, Visual, etc., this routine creates  *		an appropriate Color Conversion Context.  *  *	RETURNS  *		Returns NULL if failed; otherwise address of the newly  *		created XcmsCCC.  *  */
block|{
name|XcmsCCC
name|pDefaultCCC
init|=
name|XcmsDefaultCCC
argument_list|(
name|dpy
argument_list|,
name|screenNumber
argument_list|)
decl_stmt|;
name|XcmsCCC
name|newccc
decl_stmt|;
name|XcmsIntensityMap
modifier|*
name|pIMap
decl_stmt|;
name|XcmsPerScrnInfo
modifier|*
name|pNewScrnInfo
decl_stmt|;
if|if
condition|(
name|pDefaultCCC
operator|==
name|NULL
operator|||
operator|!
operator|(
name|newccc
operator|=
operator|(
name|XcmsCCC
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|XcmsCCCRec
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*      * Should inherit the following as result of a bcopy():      *		dpy      *		screenNumber      *		pPerScrnInfo      */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pDefaultCCC
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newccc
argument_list|,
sizeof|sizeof
argument_list|(
name|XcmsCCCRec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clientWhitePt
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|clientWhitePt
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|newccc
operator|->
name|clientWhitePt
argument_list|,
sizeof|sizeof
argument_list|(
name|XcmsColor
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gamutCompProc
condition|)
block|{
name|newccc
operator|->
name|gamutCompProc
operator|=
name|gamutCompProc
expr_stmt|;
block|}
if|if
condition|(
name|gamutCompClientData
condition|)
block|{
name|newccc
operator|->
name|gamutCompClientData
operator|=
name|gamutCompClientData
expr_stmt|;
block|}
if|if
condition|(
name|whitePtAdjProc
condition|)
block|{
name|newccc
operator|->
name|whitePtAdjProc
operator|=
name|whitePtAdjProc
expr_stmt|;
block|}
if|if
condition|(
name|whitePtAdjClientData
condition|)
block|{
name|newccc
operator|->
name|whitePtAdjClientData
operator|=
name|whitePtAdjClientData
expr_stmt|;
block|}
comment|/*      * Now check our list of per-Visual Intensity tables.      * If one exists replace the pPerScrnInfo.      */
if|if
condition|(
operator|(
name|pIMap
operator|=
name|_XcmsGetIntensityMap
argument_list|(
name|dpy
argument_list|,
name|visual
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pNewScrnInfo
operator|=
operator|(
name|XcmsPerScrnInfo
operator|*
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|XcmsPerScrnInfo
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|Xfree
argument_list|(
name|newccc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newccc
operator|->
name|pPerScrnInfo
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pNewScrnInfo
argument_list|,
sizeof|sizeof
argument_list|(
name|XcmsPerScrnInfo
argument_list|)
argument_list|)
expr_stmt|;
name|pNewScrnInfo
operator|->
name|screenData
operator|=
name|pIMap
operator|->
name|screenData
expr_stmt|;
name|newccc
operator|->
name|pPerScrnInfo
operator|=
name|pNewScrnInfo
expr_stmt|;
block|}
comment|/*      * Set visual component      */
name|newccc
operator|->
name|visual
operator|=
name|visual
expr_stmt|;
return|return
operator|(
name|newccc
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		XcmsDefaultCCC  *  *	SYNOPSIS  */
end_comment

begin_function
name|XcmsCCC
name|XcmsDefaultCCC
parameter_list|(
name|dpy
parameter_list|,
name|screenNumber
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|int
name|screenNumber
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Given a Display and Screen, this routine creates  *		returns the Screen's default Color Conversion Context.  *		Note that a Screen's default CCC is built with the  *		screen default visual.  *  *	RETURNS  *		Returns NULL if failed; otherwise address of the  *		XcmsCCC for the Screen's default CCC.  *  */
block|{
name|XcmsCCC
name|ccc
decl_stmt|;
if|if
condition|(
operator|(
name|screenNumber
operator|<
literal|0
operator|)
operator|||
operator|(
name|screenNumber
operator|>=
name|ScreenCount
argument_list|(
name|dpy
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
operator|(
name|XcmsCCC
operator|)
name|NULL
operator|)
return|;
block|}
comment|/*      * Check if the XcmsCCC's for each screen has been created      */
if|if
condition|(
operator|(
name|XcmsCCC
operator|)
name|dpy
operator|->
name|cms
operator|.
name|defaultCCCs
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|_XcmsInitDefaultCCCs
argument_list|(
name|dpy
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|XcmsCCC
operator|)
name|NULL
operator|)
return|;
block|}
block|}
name|ccc
operator|=
operator|(
name|XcmsCCC
operator|)
name|dpy
operator|->
name|cms
operator|.
name|defaultCCCs
operator|+
name|screenNumber
expr_stmt|;
if|if
condition|(
operator|!
name|ccc
operator|->
name|pPerScrnInfo
condition|)
block|{
comment|/* 	 * Need to create the XcmsPerScrnInfo structure.  The 	 * _XcmsInitScrnInfo routine will create the XcmsPerScrnInfo 	 * structure as well as initialize its functionSet and pScreenData 	 * components. 	 */
if|if
condition|(
operator|!
name|_XcmsInitScrnInfo
argument_list|(
name|dpy
argument_list|,
name|screenNumber
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|XcmsCCC
operator|)
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|ccc
operator|)
return|;
block|}
else|else
block|{
comment|/* 	 * If ccc->pPerScrnInfo->state == XcmsInitSuccess, 	 *    then the pPerScrnInfo component has already been initialized 	 *    therefore, just return ccc. 	 * If ccc->pPerScrnInfo->state == XcmsInitDefault, 	 *    then this means that we already attempted to initialize 	 *    the pPerScrnInfo component but failed therefore stuffing 	 *    the pPerScrnInfo component with defaults.  Just return ccc. 	 * If ccc->pPerScrnInfo->state == XcmsInitNone, 	 *    then attempt to initialize the pPerScrnInfo component. 	 */
switch|switch
condition|(
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|state
condition|)
block|{
case|case
name|XcmsInitDefault
case|:
comment|/* fall through */
case|case
name|XcmsInitSuccess
case|:
return|return
operator|(
name|ccc
operator|)
return|;
case|case
name|XcmsInitNone
case|:
comment|/* XcmsPerScreenInfo has not been initialized */
if|if
condition|(
operator|!
name|_XcmsInitScrnInfo
argument_list|(
name|dpy
argument_list|,
name|screenNumber
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|XcmsCCC
operator|)
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|ccc
operator|)
return|;
default|default :
return|return
operator|(
operator|(
name|XcmsCCC
operator|)
name|NULL
operator|)
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		XcmsFreeCCC  *  *	SYNOPSIS  */
end_comment

begin_function
name|void
name|XcmsFreeCCC
parameter_list|(
name|ccc
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Frees memory associated with a Color Conversion Context  *		that was created with XcmsCreateCCC().  *  *	RETURNS  *		void  *  */
block|{
if|if
condition|(
name|ccc
operator|->
name|dpy
operator|->
name|cms
operator|.
name|defaultCCCs
operator|&&
name|ccc
operator|==
operator|(
operator|(
name|XcmsCCC
operator|)
name|ccc
operator|->
name|dpy
operator|->
name|cms
operator|.
name|defaultCCCs
operator|)
operator|+
name|ccc
operator|->
name|screenNumber
condition|)
block|{
comment|/* do not allow clients to free DefaultCCC's */
return|return;
block|}
comment|/*      * Note that XcmsPerScrnInfo sub-structures are freed here only if      * they are for visuals that have per-Visual intensity tables.      * Otherwise the XcmsPerScrnInfo structure is being shared!      * For the latter, there is only one allocated per Screen and it just      * so happens * that we place its initial reference is placed in the      * 	default CCC.  The routine _XcmsFreeDefaultCCCs frees them.      */
if|if
condition|(
name|_XcmsGetIntensityMap
argument_list|(
name|ccc
operator|->
name|dpy
argument_list|,
name|ccc
operator|->
name|visual
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|Xfree
argument_list|(
name|ccc
operator|->
name|pPerScrnInfo
argument_list|)
expr_stmt|;
block|}
name|Xfree
argument_list|(
name|ccc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

