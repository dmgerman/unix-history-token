begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: makekeys.c,v 11.6 91/05/01 14:29:38 rws Exp $ */
end_comment

begin_comment
comment|/* Copyright 1990 by the Massachusetts Institute of Technology  Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_comment
comment|/* Constructs hash tables for XStringToKeysym and XKeysymToString. */
end_comment

begin_include
include|#
directive|include
file|<X11/X.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xos.h>
end_include

begin_include
include|#
directive|include
file|<X11/keysymdef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|X_NOT_STDC_ENV
end_ifndef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|macII
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_comment
comment|/* stdlib.h fails to define these */
end_comment

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* macII */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|Signature
typedef|;
end_typedef

begin_define
define|#
directive|define
name|KTNUM
value|3000
end_define

begin_struct
specifier|static
struct|struct
name|info
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|KeySym
name|val
decl_stmt|;
block|}
name|info
index|[
name|KTNUM
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|MIN_REHASH
value|10
end_define

begin_define
define|#
directive|define
name|MATCHES
value|10
end_define

begin_decl_stmt
name|char
name|tab
index|[
name|KTNUM
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|offsets
index|[
name|KTNUM
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|indexes
index|[
name|KTNUM
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|KeySym
name|values
index|[
name|KTNUM
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|()
block|{
name|int
name|ksnum
decl_stmt|;
name|int
name|max_rehash
decl_stmt|;
name|Signature
name|sig
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|z
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|best_max_rehash
decl_stmt|;
name|int
name|best_z
decl_stmt|;
name|int
name|num_found
decl_stmt|;
name|KeySym
name|val
decl_stmt|;
for|for
control|(
name|ksnum
operator|=
literal|0
init|;
literal|1
condition|;
operator|(
name|void
operator|)
name|gets
argument_list|(
name|buf
argument_list|)
control|)
block|{
name|i
operator|=
name|scanf
argument_list|(
literal|"#define XK_%s 0x%lx"
argument_list|,
name|buf
argument_list|,
operator|&
name|info
index|[
name|ksnum
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
literal|2
condition|)
continue|continue;
if|if
condition|(
name|info
index|[
name|ksnum
index|]
operator|.
name|val
operator|==
name|XK_VoidSymbol
condition|)
name|info
index|[
name|ksnum
index|]
operator|.
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info
index|[
name|ksnum
index|]
operator|.
name|val
operator|>
literal|0xffff
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ignoring illegal keysym (%s), remove it from .h file!\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"makekeys: out of memory!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|info
index|[
name|ksnum
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|ksnum
operator|++
expr_stmt|;
if|if
condition|(
name|ksnum
operator|==
name|KTNUM
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"makekeys: too many keysyms!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"/* This file is generated from keysymdef.h. */\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/* Do not edit. */\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|best_max_rehash
operator|=
name|ksnum
expr_stmt|;
name|num_found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|z
operator|=
name|ksnum
init|;
name|z
operator|<
name|KTNUM
condition|;
name|z
operator|++
control|)
block|{
name|max_rehash
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|name
operator|=
name|tab
operator|,
name|i
operator|=
name|z
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|name
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ksnum
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|info
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|sig
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|name
operator|++
condition|)
name|sig
operator|=
operator|(
name|sig
operator|<<
literal|1
operator|)
operator|+
name|c
expr_stmt|;
name|first
operator|=
name|j
operator|=
name|sig
operator|%
name|z
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|tab
index|[
name|j
index|]
condition|;
name|k
operator|++
control|)
block|{
name|j
operator|+=
name|first
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|z
condition|)
name|j
operator|-=
name|z
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|first
condition|)
goto|goto
name|next1
goto|;
block|}
name|tab
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|max_rehash
condition|)
name|max_rehash
operator|=
name|k
expr_stmt|;
block|}
if|if
condition|(
name|max_rehash
operator|<
name|MIN_REHASH
condition|)
block|{
if|if
condition|(
name|max_rehash
operator|<
name|best_max_rehash
condition|)
block|{
name|best_max_rehash
operator|=
name|max_rehash
expr_stmt|;
name|best_z
operator|=
name|z
expr_stmt|;
block|}
name|num_found
operator|++
expr_stmt|;
if|if
condition|(
name|num_found
operator|>=
name|MATCHES
condition|)
break|break;
block|}
name|next1
label|:
empty_stmt|;
block|}
name|z
operator|=
name|best_z
expr_stmt|;
name|printf
argument_list|(
literal|"#ifdef NEEDKTABLE\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Const unsigned char _XkeyTable[] = {\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0,\n"
argument_list|)
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ksnum
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|info
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|sig
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|name
operator|++
condition|)
name|sig
operator|=
operator|(
name|sig
operator|<<
literal|1
operator|)
operator|+
name|c
expr_stmt|;
name|first
operator|=
name|j
operator|=
name|sig
operator|%
name|z
expr_stmt|;
while|while
condition|(
name|offsets
index|[
name|j
index|]
condition|)
block|{
name|j
operator|+=
name|first
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|z
condition|)
name|j
operator|-=
name|z
expr_stmt|;
block|}
name|offsets
index|[
name|j
index|]
operator|=
name|k
expr_stmt|;
name|indexes
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
name|val
operator|=
name|info
index|[
name|i
index|]
operator|.
name|val
expr_stmt|;
name|printf
argument_list|(
literal|"0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, "
argument_list|,
operator|(
name|sig
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|sig
operator|&
literal|0xff
argument_list|,
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
for|for
control|(
name|name
operator|=
name|info
index|[
name|i
index|]
operator|.
name|name
operator|,
name|k
operator|+=
literal|5
init|;
name|c
operator|=
operator|*
name|name
operator|++
condition|;
name|k
operator|++
control|)
name|printf
argument_list|(
literal|"'%c',"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|printf
argument_list|(
operator|(
name|i
operator|==
operator|(
name|ksnum
operator|-
literal|1
operator|)
operator|)
condition|?
literal|"0\n"
else|:
literal|"0,\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define KTABLESIZE %d\n"
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define KMAXHASH %d\n"
argument_list|,
name|best_max_rehash
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"static Const unsigned short hashString[KTABLESIZE] = {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|z
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"0x%.4x"
argument_list|,
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|z
condition|)
break|break;
name|printf
argument_list|(
operator|(
name|i
operator|&
literal|7
operator|)
condition|?
literal|", "
else|:
literal|",\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"};\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#endif /* NEEDKTABLE */\n"
argument_list|)
expr_stmt|;
name|best_max_rehash
operator|=
name|ksnum
expr_stmt|;
name|num_found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|z
operator|=
name|ksnum
init|;
name|z
operator|<
name|KTNUM
condition|;
name|z
operator|++
control|)
block|{
name|max_rehash
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|name
operator|=
name|tab
operator|,
name|i
operator|=
name|z
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|name
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ksnum
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|info
index|[
name|i
index|]
operator|.
name|val
expr_stmt|;
name|first
operator|=
name|j
operator|=
name|val
operator|%
name|z
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|tab
index|[
name|j
index|]
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|values
index|[
name|j
index|]
operator|==
name|val
condition|)
goto|goto
name|skip1
goto|;
name|j
operator|+=
name|first
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|z
condition|)
name|j
operator|-=
name|z
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|first
condition|)
goto|goto
name|next2
goto|;
block|}
name|tab
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|values
index|[
name|j
index|]
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|max_rehash
condition|)
name|max_rehash
operator|=
name|k
expr_stmt|;
name|skip1
label|:
empty_stmt|;
block|}
if|if
condition|(
name|max_rehash
operator|<
name|MIN_REHASH
condition|)
block|{
if|if
condition|(
name|max_rehash
operator|<
name|best_max_rehash
condition|)
block|{
name|best_max_rehash
operator|=
name|max_rehash
expr_stmt|;
name|best_z
operator|=
name|z
expr_stmt|;
block|}
name|num_found
operator|++
expr_stmt|;
if|if
condition|(
name|num_found
operator|>=
name|MATCHES
condition|)
break|break;
block|}
name|next2
label|:
empty_stmt|;
block|}
name|z
operator|=
name|best_z
expr_stmt|;
for|for
control|(
name|i
operator|=
name|z
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|offsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ksnum
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|info
index|[
name|i
index|]
operator|.
name|val
expr_stmt|;
name|first
operator|=
name|j
operator|=
name|val
operator|%
name|z
expr_stmt|;
while|while
condition|(
name|offsets
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
name|values
index|[
name|j
index|]
operator|==
name|val
condition|)
goto|goto
name|skip2
goto|;
name|j
operator|+=
name|first
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|z
condition|)
name|j
operator|-=
name|z
expr_stmt|;
block|}
name|offsets
index|[
name|j
index|]
operator|=
name|indexes
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
name|values
index|[
name|j
index|]
operator|=
name|val
expr_stmt|;
name|skip2
label|:
empty_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#ifdef NEEDVTABLE\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define VTABLESIZE %d\n"
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define VMAXHASH %d\n"
argument_list|,
name|best_max_rehash
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"static Const unsigned short hashKeysym[VTABLESIZE] = {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|z
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"0x%.4x"
argument_list|,
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|z
condition|)
break|break;
name|printf
argument_list|(
operator|(
name|i
operator|&
literal|7
operator|)
condition|?
literal|", "
else|:
literal|",\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"};\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#endif /* NEEDVTABLE */\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

