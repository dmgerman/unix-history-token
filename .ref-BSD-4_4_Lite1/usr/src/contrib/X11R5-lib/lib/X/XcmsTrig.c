begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XcmsTrig.c,v 1.4 91/11/05 11:02:20 rws Exp $" */
end_comment

begin_comment
comment|/*  * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.  * 	All Rights Reserved  *   * This file is a component of an X Window System-specific implementation  * of Xcms based on the TekColor Color Management System.  Permission is  * hereby granted to use, copy, modify, sell, and otherwise distribute this  * software and its documentation for any purpose and without fee, provided  * that this copyright, permission, and disclaimer notice is reproduced in  * all copies of this software and in supporting documentation.  TekColor  * is a trademark of Tektronix, Inc.  *   * Tektronix makes no representation about the suitability of this software  * for any purpose.  It is provided "as is" and with all faults.  *   * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,  * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY  * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER  * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF  * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  *	It should be pointed out that for simplicity's sake, the  *	environment parameters are defined as floating point constants,  *	rather than octal or hexadecimal initializations of allocated  *	storage areas.  This means that the range of allowed numbers  *	may not exactly match the hardware's capabilities.  For example,  *	if the maximum positive double precision floating point number  *	is EXACTLY 1.11...E100 and the constant "MAXDOUBLE is  *	defined to be 1.11E100 then the numbers between 1.11E100 and  *	1.11...E100 are considered to be undefined.  For most  *	applications, this will cause no problems.  *  *	An alternate method is to allocate a global static "double" variable,  *	say "maxdouble", and use a union declaration and initialization  *	to initialize it with the proper bits for the EXACT maximum value.  *	This was not done because the only compilers available to the  *	author did not fully support union initialization features.  *  */
end_comment

begin_comment
comment|/*  *	EXTERNS  */
end_comment

begin_function_decl
specifier|extern
name|double
name|_XcmsSquareRoot
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *	FORWARD DECLARATIONS  */
end_comment

begin_function_decl
name|double
name|_XcmsCosine
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|_XcmsModulo
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|_XcmsModuloF
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|double
name|_XcmsPolynomial
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|double
name|_XcmsSine
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|double
name|_XcmsArcTangent
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *	DEFINES  */
end_comment

begin_define
define|#
directive|define
name|XCMS_MAXERROR
value|0.000001
end_define

begin_define
define|#
directive|define
name|XCMS_MAXITER
value|10000
end_define

begin_define
define|#
directive|define
name|XCMS_PI
value|3.14159265358979323846264338327950
end_define

begin_define
define|#
directive|define
name|XCMS_TWOPI
value|6.28318530717958620
end_define

begin_define
define|#
directive|define
name|XCMS_HALFPI
value|1.57079632679489660
end_define

begin_define
define|#
directive|define
name|XCMS_FOURTHPI
value|0.785398163397448280
end_define

begin_define
define|#
directive|define
name|XCMS_SIXTHPI
value|0.523598775598298820
end_define

begin_define
define|#
directive|define
name|XCMS_RADIANS
parameter_list|(
name|d
parameter_list|)
value|((d) * XCMS_PI / 180.0)
end_define

begin_define
define|#
directive|define
name|XCMS_DEGREES
parameter_list|(
name|r
parameter_list|)
value|((r) * 180.0 / XCMS_PI)
end_define

begin_define
define|#
directive|define
name|XCMS_X6_UNDERFLOWS
value|(4.209340e-52)
end_define

begin_comment
comment|/* X**6 almost underflows */
end_comment

begin_define
define|#
directive|define
name|XCMS_X16_UNDERFLOWS
value|(5.421010e-20)
end_define

begin_comment
comment|/* X**16 almost underflows*/
end_comment

begin_define
define|#
directive|define
name|XCMS_CHAR_BIT
value|8
end_define

begin_define
define|#
directive|define
name|XCMS_LONG_MAX
value|0x7FFFFFFF
end_define

begin_define
define|#
directive|define
name|XCMS_DEXPLEN
value|11
end_define

begin_define
define|#
directive|define
name|XCMS_NBITS
parameter_list|(
name|type
parameter_list|)
value|(XCMS_CHAR_BIT * (int)sizeof(type))
end_define

begin_define
define|#
directive|define
name|XCMS_FABS
parameter_list|(
name|x
parameter_list|)
value|((x)< 0.0 ? -(x) : (x))
end_define

begin_comment
comment|/* XCMS_DMAXPOWTWO - largest power of two exactly representable as a double */
end_comment

begin_define
define|#
directive|define
name|XCMS_DMAXPOWTWO
value|((double)(XCMS_LONG_MAX) * \ 	    (1L<< (XCMS_NBITS(double)-XCMS_DEXPLEN) - XCMS_NBITS(long) + 1))
end_define

begin_comment
comment|/*  *	LOCAL VARIABLES  */
end_comment

begin_decl_stmt
specifier|static
name|double
name|cos_pcoeffs
index|[]
init|=
block|{
literal|0.12905394659037374438e7
block|,
operator|-
literal|0.37456703915723204710e6
block|,
literal|0.13432300986539084285e5
block|,
operator|-
literal|0.11231450823340933092e3
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|cos_qcoeffs
index|[]
init|=
block|{
literal|0.12905394659037373590e7
block|,
literal|0.23467773107245835052e5
block|,
literal|0.20969518196726306286e3
block|,
literal|1.0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|sin_pcoeffs
index|[]
init|=
block|{
literal|0.20664343336995858240e7
block|,
operator|-
literal|0.18160398797407332550e6
block|,
literal|0.35999306949636188317e4
block|,
operator|-
literal|0.20107483294588615719e2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|sin_qcoeffs
index|[]
init|=
block|{
literal|0.26310659102647698963e7
block|,
literal|0.39270242774649000308e5
block|,
literal|0.27811919481083844087e3
block|,
literal|1.0
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *  *  FUNCTION  *  *	_XcmsCosine   double precision cosine  *  *  KEY WORDS  *  *	cos  *	machine independent routines  *	trigonometric functions  *	math libraries  *  *  DESCRIPTION  *  *	Returns double precision cosine of double precision  *	floating point argument.  *  *  USAGE  *  *	double _XcmsCosine (x)  *	double x;  *  *  REFERENCES  *  *	Computer Approximations, J.F. Hart et al, John Wiley& Sons,  *	1968, pp. 112-120.  *  *  RESTRICTIONS  *  *	The sin and cos routines are interactive in the sense that  *	in the process of reducing the argument to the range -PI/4  *	to PI/4, each may call the other.  Ultimately one or the  *	other uses a polynomial approximation on the reduced  *	argument.  The sin approximation has a maximum relative error  *	of 10**(-17.59) and the cos approximation has a maximum  *	relative error of 10**(-16.18).  *  *	These error bounds assume exact arithmetic  *	in the polynomial evaluation.  Additional rounding and  *	truncation errors may occur as the argument is reduced  *	to the range over which the polynomial approximation  *	is valid, and as the polynomial is evaluated using  *	finite-precision arithmetic.  *	  *  PROGRAMMER  *  *	Fred Fish  *  *  INTERNALS  *  *	Computes cos(x) from:  *  *		(1)	Reduce argument x to range -PI to PI.  *  *		(2)	If x> PI/2 then call cos recursively  *			using relation cos(x) = -cos(x - PI).  *  *		(3)	If x< -PI/2 then call cos recursively  *			using relation cos(x) = -cos(x + PI).  *  *		(4)	If x> PI/4 then call sin using  *			relation cos(x) = sin(PI/2 - x).  *  *		(5)	If x< -PI/4 then call cos using  *			relation cos(x) = sin(PI/2 + x).  *  *		(6)	If x would cause underflow in approx  *			evaluation arithmetic then return  *			sqrt(1.0 - x**2).  *  *		(7)	By now x has been reduced to range  *			-PI/4 to PI/4 and the approximation  *			from HART pg. 119 can be used:  *  *			cos(x) = ( p(y) / q(y) )  *			Where:  *  *			y    =	x * (4/PI)  *  *			p(y) =  SUM [ Pj * (y**(2*j)) ]  *			over j = {0,1,2,3}  *  *			q(y) =  SUM [ Qj * (y**(2*j)) ]  *			over j = {0,1,2,3}  *  *			P0   =	0.12905394659037374438571854e+7  *			P1   =	-0.3745670391572320471032359e+6  *			P2   =	0.134323009865390842853673e+5  *			P3   =	-0.112314508233409330923e+3  *			Q0   =	0.12905394659037373590295914e+7  *			Q1   =	0.234677731072458350524124e+5  *			Q2   =	0.2096951819672630628621e+3  *			Q3   =	1.0000...  *			(coefficients from HART table #3843 pg 244)  *  *  *	**** NOTE ****    The range reduction relations used in  *	this routine depend on the final approximation being valid  *	over the negative argument range in addition to the positive  *	argument range.  The particular approximation chosen from  *	HART satisfies this requirement, although not explicitly  *	stated in the text.  This may not be true of other  *	approximations given in the reference.  *			  */
end_comment

begin_function
name|double
name|_XcmsCosine
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
specifier|auto
name|double
name|y
decl_stmt|;
specifier|auto
name|double
name|yt2
decl_stmt|;
name|double
name|retval
decl_stmt|;
if|if
condition|(
name|x
operator|<
operator|-
name|XCMS_PI
operator|||
name|x
operator|>
name|XCMS_PI
condition|)
block|{
name|x
operator|=
name|_XcmsModulo
argument_list|(
name|x
argument_list|,
name|XCMS_TWOPI
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>
name|XCMS_PI
condition|)
block|{
name|x
operator|=
name|x
operator|-
name|XCMS_TWOPI
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
operator|-
name|XCMS_PI
condition|)
block|{
name|x
operator|=
name|x
operator|+
name|XCMS_TWOPI
expr_stmt|;
block|}
block|}
if|if
condition|(
name|x
operator|>
name|XCMS_HALFPI
condition|)
block|{
name|retval
operator|=
operator|-
operator|(
name|_XcmsCosine
argument_list|(
name|x
operator|-
name|XCMS_PI
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
operator|-
name|XCMS_HALFPI
condition|)
block|{
name|retval
operator|=
operator|-
operator|(
name|_XcmsCosine
argument_list|(
name|x
operator|+
name|XCMS_PI
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>
name|XCMS_FOURTHPI
condition|)
block|{
name|retval
operator|=
name|_XcmsSine
argument_list|(
name|XCMS_HALFPI
operator|-
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
operator|-
name|XCMS_FOURTHPI
condition|)
block|{
name|retval
operator|=
name|_XcmsSine
argument_list|(
name|XCMS_HALFPI
operator|+
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
name|XCMS_X6_UNDERFLOWS
operator|&&
name|x
operator|>
operator|-
name|XCMS_X6_UNDERFLOWS
condition|)
block|{
name|retval
operator|=
name|_XcmsSquareRoot
argument_list|(
literal|1.0
operator|-
operator|(
name|x
operator|*
name|x
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
name|x
operator|/
name|XCMS_FOURTHPI
expr_stmt|;
name|yt2
operator|=
name|y
operator|*
name|y
expr_stmt|;
name|retval
operator|=
name|_XcmsPolynomial
argument_list|(
literal|3
argument_list|,
name|cos_pcoeffs
argument_list|,
name|yt2
argument_list|)
operator|/
name|_XcmsPolynomial
argument_list|(
literal|3
argument_list|,
name|cos_qcoeffs
argument_list|,
name|yt2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *  FUNCTION  *  *	_XcmsModulo   double precision modulo  *  *  KEY WORDS  *  *	_XcmsModulo  *	machine independent routines  *	math libraries  *  *  DESCRIPTION  *  *	Returns double precision modulo of two double  *	precision arguments.  *  *  USAGE  *  *	double _XcmsModulo (value, base)  *	double value;  *	double base;  *  *  PROGRAMMER  *  *	Fred Fish  *  */
end_comment

begin_function
specifier|static
name|double
name|_XcmsModulo
parameter_list|(
name|value
parameter_list|,
name|base
parameter_list|)
name|double
name|value
decl_stmt|;
name|double
name|base
decl_stmt|;
block|{
specifier|auto
name|double
name|intpart
decl_stmt|;
name|value
operator|/=
name|base
expr_stmt|;
name|value
operator|=
name|_XcmsModuloF
argument_list|(
name|value
argument_list|,
operator|&
name|intpart
argument_list|)
expr_stmt|;
name|value
operator|*=
name|base
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * frac = (double) _XcmsModuloF(double val, double *dp)  *	return fractional part of 'val'  *	set *dp to integer part of 'val'  *  * Note  -> only compiled for the CA or KA.  For the KB/MC,  * "math.c" instantiates a copy of the inline function  * defined in "math.h".  */
end_comment

begin_function
specifier|static
name|double
name|_XcmsModuloF
parameter_list|(
name|val
parameter_list|,
name|dp
parameter_list|)
name|double
name|val
decl_stmt|;
specifier|register
name|double
modifier|*
name|dp
decl_stmt|;
block|{
specifier|register
name|double
name|abs
decl_stmt|;
specifier|register
name|double
name|ip
decl_stmt|;
comment|/* should check for illegal values here - nan, inf, etc */
name|abs
operator|=
name|XCMS_FABS
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
operator|>=
name|XCMS_DMAXPOWTWO
condition|)
block|{
name|ip
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|=
name|abs
operator|+
name|XCMS_DMAXPOWTWO
expr_stmt|;
comment|/* dump fraction */
name|ip
operator|-=
name|XCMS_DMAXPOWTWO
expr_stmt|;
comment|/* restore w/o frac */
if|if
condition|(
name|ip
operator|>
name|abs
condition|)
comment|/* if it rounds up */
name|ip
operator|-=
literal|1.0
expr_stmt|;
comment|/* fix it */
name|ip
operator|=
name|XCMS_FABS
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
operator|*
name|dp
operator|=
name|ip
expr_stmt|;
return|return
operator|(
name|val
operator|-
name|ip
operator|)
return|;
comment|/* signed fractional part */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *  FUNCTION  *  *	_XcmsPolynomial   double precision polynomial evaluation  *  *  KEY WORDS  *  *	poly  *	machine independent routines  *	math libraries  *  *  DESCRIPTION  *  *	Evaluates a polynomial and returns double precision  *	result.  Is passed a the order of the polynomial,  *	a pointer to an array of double precision polynomial  *	coefficients (in ascending order), and the independent  *	variable.  *  *  USAGE  *  *	double _XcmsPolynomial (order, coeffs, x)  *	int order;  *	double *coeffs;  *	double x;  *  *  PROGRAMMER  *  *	Fred Fish  *  *  INTERNALS  *  *	Evalates the polynomial using recursion and the form:  *  *		P(x) = P0 + x(P1 + x(P2 +...x(Pn)))  *  */
end_comment

begin_function
specifier|static
name|double
name|_XcmsPolynomial
parameter_list|(
name|order
parameter_list|,
name|coeffs
parameter_list|,
name|x
parameter_list|)
specifier|register
name|int
name|order
decl_stmt|;
name|double
modifier|*
name|coeffs
decl_stmt|;
name|double
name|x
decl_stmt|;
block|{
specifier|auto
name|double
name|rtn_value
decl_stmt|;
if|#
directive|if
literal|0
block|auto double curr_coeff;     if (order<= 0) { 	rtn_value = *coeffs;     } else { 	curr_coeff = *coeffs;
comment|/* Bug in Unisoft's compiler.  Does not */
block|coeffs++;
comment|/* generate good code for *coeffs++ */
block|rtn_value = curr_coeff + x * _XcmsPolynomial (--order, coeffs, x);     }
else|#
directive|else
comment|/* ++jrb -- removed tail recursion */
name|coeffs
operator|+=
name|order
expr_stmt|;
name|rtn_value
operator|=
operator|*
name|coeffs
operator|--
expr_stmt|;
while|while
condition|(
name|order
operator|--
operator|>
literal|0
condition|)
name|rtn_value
operator|=
operator|*
name|coeffs
operator|--
operator|+
operator|(
name|x
operator|*
name|rtn_value
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|rtn_value
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *  FUNCTION  *  *	_XcmsSine	double precision sine  *  *  KEY WORDS  *  *	sin  *	machine independent routines  *	trigonometric functions  *	math libraries  *  *  DESCRIPTION  *  *	Returns double precision sine of double precision  *	floating point argument.  *  *  USAGE  *  *	double _XcmsSine (x)  *	double x;  *  *  REFERENCES  *  *	Computer Approximations, J.F. Hart et al, John Wiley& Sons,  *	1968, pp. 112-120.  *  *  RESTRICTIONS  *  *	The sin and cos routines are interactive in the sense that  *	in the process of reducing the argument to the range -PI/4  *	to PI/4, each may call the other.  Ultimately one or the  *	other uses a polynomial approximation on the reduced  *	argument.  The sin approximation has a maximum relative error  *	of 10**(-17.59) and the cos approximation has a maximum  *	relative error of 10**(-16.18).  *  *	These error bounds assume exact arithmetic  *	in the polynomial evaluation.  Additional rounding and  *	truncation errors may occur as the argument is reduced  *	to the range over which the polynomial approximation  *	is valid, and as the polynomial is evaluated using  *	finite-precision arithmetic.  *	  *  PROGRAMMER  *  *	Fred Fish  *  *  INTERNALS  *  *	Computes sin(x) from:  *  *	  (1)	Reduce argument x to range -PI to PI.  *  *	  (2)	If x> PI/2 then call sin recursively  *		using relation sin(x) = -sin(x - PI).  *  *	  (3)	If x< -PI/2 then call sin recursively  *		using relation sin(x) = -sin(x + PI).  *  *	  (4)	If x> PI/4 then call cos using  *		relation sin(x) = cos(PI/2 - x).  *  *	  (5)	If x< -PI/4 then call cos using  *		relation sin(x) = -cos(PI/2 + x).  *  *	  (6)	If x is small enough that polynomial  *		evaluation would cause underflow  *		then return x, since sin(x)  *		approaches x as x approaches zero.  *  *	  (7)	By now x has been reduced to range  *		-PI/4 to PI/4 and the approximation  *		from HART pg. 118 can be used:  *  *		sin(x) = y * ( p(y) / q(y) )  *		Where:  *  *		y    =  x * (4/PI)  *  *		p(y) =  SUM [ Pj * (y**(2*j)) ]  *		over j = {0,1,2,3}  *  *		q(y) =  SUM [ Qj * (y**(2*j)) ]  *		over j = {0,1,2,3}  *  *		P0   =  0.206643433369958582409167054e+7  *		P1   =  -0.18160398797407332550219213e+6  *		P2   =  0.359993069496361883172836e+4  *		P3   =  -0.2010748329458861571949e+2  *		Q0   =  0.263106591026476989637710307e+7  *		Q1   =  0.3927024277464900030883986e+5  *		Q2   =  0.27811919481083844087953e+3  *		Q3   =  1.0000...  *		(coefficients from HART table #3063 pg 234)  *  *  *	**** NOTE ****	  The range reduction relations used in  *	this routine depend on the final approximation being valid  *	over the negative argument range in addition to the positive  *	argument range.  The particular approximation chosen from  *	HART satisfies this requirement, although not explicitly  *	stated in the text.  This may not be true of other  *	approximations given in the reference.  *			  */
end_comment

begin_function
name|double
name|_XcmsSine
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|y
decl_stmt|;
name|double
name|yt2
decl_stmt|;
name|double
name|retval
decl_stmt|;
if|if
condition|(
name|x
operator|<
operator|-
name|XCMS_PI
operator|||
name|x
operator|>
name|XCMS_PI
condition|)
block|{
name|x
operator|=
name|_XcmsModulo
argument_list|(
name|x
argument_list|,
name|XCMS_TWOPI
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>
name|XCMS_PI
condition|)
block|{
name|x
operator|=
name|x
operator|-
name|XCMS_TWOPI
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
operator|-
name|XCMS_PI
condition|)
block|{
name|x
operator|=
name|x
operator|+
name|XCMS_TWOPI
expr_stmt|;
block|}
block|}
if|if
condition|(
name|x
operator|>
name|XCMS_HALFPI
condition|)
block|{
name|retval
operator|=
operator|-
operator|(
name|_XcmsSine
argument_list|(
name|x
operator|-
name|XCMS_PI
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
operator|-
name|XCMS_HALFPI
condition|)
block|{
name|retval
operator|=
operator|-
operator|(
name|_XcmsSine
argument_list|(
name|x
operator|+
name|XCMS_PI
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>
name|XCMS_FOURTHPI
condition|)
block|{
name|retval
operator|=
name|_XcmsCosine
argument_list|(
name|XCMS_HALFPI
operator|-
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
operator|-
name|XCMS_FOURTHPI
condition|)
block|{
name|retval
operator|=
operator|-
operator|(
name|_XcmsCosine
argument_list|(
name|XCMS_HALFPI
operator|+
name|x
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
name|XCMS_X6_UNDERFLOWS
operator|&&
name|x
operator|>
operator|-
name|XCMS_X6_UNDERFLOWS
condition|)
block|{
name|retval
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
name|x
operator|/
name|XCMS_FOURTHPI
expr_stmt|;
name|yt2
operator|=
name|y
operator|*
name|y
expr_stmt|;
name|retval
operator|=
name|y
operator|*
operator|(
name|_XcmsPolynomial
argument_list|(
literal|3
argument_list|,
name|sin_pcoeffs
argument_list|,
name|yt2
argument_list|)
operator|/
name|_XcmsPolynomial
argument_list|(
literal|3
argument_list|,
name|sin_qcoeffs
argument_list|,
name|yt2
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		_XcmsArcTangent  *  *	SYNOPSIS  */
end_comment

begin_function
name|double
name|_XcmsArcTangent
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Computes the arctangent.  *		This is an implementation of the Gauss algorithm as  *		described in:  *		    Forman S. Acton, Numerical Methods That Work,  *			New York, NY, Harper& Row, 1970.  *  *	RETURNS  *		Returns the arctangent   */
block|{
name|double
name|ai
decl_stmt|,
name|a1
decl_stmt|,
name|bi
decl_stmt|,
name|b1
decl_stmt|,
name|l
decl_stmt|,
name|d
decl_stmt|;
name|double
name|maxerror
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0.0
condition|)
block|{
return|return
operator|(
literal|0.0
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|<
literal|1.0
condition|)
block|{
name|maxerror
operator|=
name|x
operator|*
name|XCMS_MAXERROR
expr_stmt|;
block|}
else|else
block|{
name|maxerror
operator|=
name|XCMS_MAXERROR
expr_stmt|;
block|}
name|ai
operator|=
name|_XcmsSquareRoot
argument_list|(
literal|1.0
operator|/
operator|(
literal|1.0
operator|+
operator|(
name|x
operator|*
name|x
operator|)
operator|)
argument_list|)
expr_stmt|;
name|bi
operator|=
literal|1.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XCMS_MAXITER
condition|;
name|i
operator|++
control|)
block|{
name|a1
operator|=
operator|(
name|ai
operator|+
name|bi
operator|)
operator|/
literal|2.0
expr_stmt|;
name|b1
operator|=
name|_XcmsSquareRoot
argument_list|(
operator|(
name|a1
operator|*
name|bi
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a1
operator|==
name|b1
condition|)
break|break;
name|d
operator|=
name|XCMS_FABS
argument_list|(
name|a1
operator|-
name|b1
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|maxerror
condition|)
break|break;
name|ai
operator|=
name|a1
expr_stmt|;
name|bi
operator|=
name|b1
expr_stmt|;
block|}
name|l
operator|=
operator|(
operator|(
name|a1
operator|>
name|b1
operator|)
condition|?
name|b1
else|:
name|a1
operator|)
expr_stmt|;
name|a1
operator|=
name|_XcmsSquareRoot
argument_list|(
literal|1
operator|+
operator|(
name|x
operator|*
name|x
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|/
operator|(
name|a1
operator|*
name|l
operator|)
operator|)
return|;
block|}
end_function

end_unit

