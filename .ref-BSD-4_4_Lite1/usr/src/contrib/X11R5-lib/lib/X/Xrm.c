begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: Xrm.c,v 1.72 92/01/10 14:21:12 rws Exp $  */
end_comment

begin_comment
comment|/*********************************************************** Copyright 1987, 1988, 1990 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|<X11/Xresource.h>
end_include

begin_include
include|#
directive|include
file|"XrmI.h"
end_include

begin_include
include|#
directive|include
file|"Xlcint.h"
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_define
define|#
directive|define
name|Const
value|const
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Const
end_define

begin_comment
comment|/**/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__STDC__
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_define
define|#
directive|define
name|RConst
value|const
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RConst
end_define

begin_comment
comment|/**/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  These Xrm routines allow very fast lookup of resources in the resource database.  Several usage patterns are exploited:  (1) Widgets get a lot of resources at one time.  Rather than look up each from scratch, we can precompute the prioritized list of database levels once, then search for each resource starting at the beginning of the list.  (2) Many database levels don't contain any leaf resource nodes.  There is no point in looking for resources on a level that doesn't contain any.  This information is kept on a per-level basis.  (3) Sometimes the widget instance tree is structured such that you get the same class name repeated on the fully qualified widget name.  This can result in the same database level occuring multiple times on the search list.  The code below only checks to see if you get two identical search lists in a row, rather than look back through all database levels, but in practice this removes all duplicates I've ever observed.  Joel McCormack  */
end_comment

begin_comment
comment|/*  The Xrm representation has been completely redesigned to substantially reduce memory and hopefully improve performance.  The database is structured into two kinds of tables: LTables that contain only values, and NTables that contain only other tables.  Some invariants:  The next pointer of the top-level node table points to the top-level leaf table, if any.  Within an LTable, for a given name, the tight value always precedes the loose value, and if both are present the loose value is always right after the tight value.  Within an NTable, all of the entries for a given name are contiguous, in the order tight NTable, loose NTable, tight LTable, loose LTable.  Bob Scheifler  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|Signature
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|XrmQuark
name|XrmQString
decl_stmt|,
name|XrmQANY
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|Bool
function_decl|(
modifier|*
name|DBEnumProc
function_decl|)
parameter_list|(
if|#
directive|if
name|NeedNestedPrototypes
comment|/* this is Nested on purpose, to match Xlib.h */
name|XrmDatabase
modifier|*
comment|/* db */
parameter_list|,
name|XrmBindingList
comment|/* bindings */
parameter_list|,
name|XrmQuarkList
comment|/* quarks */
parameter_list|,
name|XrmRepresentation
modifier|*
comment|/* type */
parameter_list|,
name|XrmValue
modifier|*
comment|/* value */
parameter_list|,
name|XPointer
comment|/* closure */
endif|#
directive|endif
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_VEntry
block|{
name|struct
name|_VEntry
modifier|*
name|next
decl_stmt|;
comment|/* next in chain */
name|XrmQuark
name|name
decl_stmt|;
comment|/* name of this entry */
name|unsigned
name|int
name|tight
range|:
literal|1
decl_stmt|;
comment|/* 1 if it is a tight binding */
name|unsigned
name|int
name|string
range|:
literal|1
decl_stmt|;
comment|/* 1 if type is String */
name|unsigned
name|int
name|size
range|:
literal|30
decl_stmt|;
comment|/* size of value */
block|}
name|VEntryRec
operator|,
typedef|*
name|VEntry
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_DEntry
block|{
name|VEntryRec
name|entry
decl_stmt|;
comment|/* entry */
name|XrmRepresentation
name|type
decl_stmt|;
comment|/* representation type */
block|}
name|DEntryRec
operator|,
typedef|*
name|DEntry
typedef|;
end_typedef

begin_comment
comment|/* the value is right after the structure */
end_comment

begin_define
define|#
directive|define
name|StringValue
parameter_list|(
name|ve
parameter_list|)
value|(XPointer)((ve) + 1)
end_define

begin_define
define|#
directive|define
name|RepType
parameter_list|(
name|ve
parameter_list|)
value|((DEntry)(ve))->type
end_define

begin_comment
comment|/* the value is right after the structure */
end_comment

begin_define
define|#
directive|define
name|DataValue
parameter_list|(
name|ve
parameter_list|)
value|(XPointer)(((DEntry)(ve)) + 1)
end_define

begin_define
define|#
directive|define
name|RawValue
parameter_list|(
name|ve
parameter_list|)
value|(char *)((ve)->string ? StringValue(ve) : DataValue(ve))
end_define

begin_typedef
typedef|typedef
struct|struct
name|_NTable
block|{
name|struct
name|_NTable
modifier|*
name|next
decl_stmt|;
comment|/* next in chain */
name|XrmQuark
name|name
decl_stmt|;
comment|/* name of this entry */
name|unsigned
name|int
name|tight
range|:
literal|1
decl_stmt|;
comment|/* 1 if it is a tight binding */
name|unsigned
name|int
name|leaf
range|:
literal|1
decl_stmt|;
comment|/* 1 if children are values */
name|unsigned
name|int
name|hasloose
range|:
literal|1
decl_stmt|;
comment|/* 1 if has loose children */
name|unsigned
name|int
name|hasany
range|:
literal|1
decl_stmt|;
comment|/* 1 if has ANY entry */
name|unsigned
name|int
name|pad
range|:
literal|4
decl_stmt|;
comment|/* unused */
name|unsigned
name|int
name|mask
range|:
literal|8
decl_stmt|;
comment|/* hash size - 1 */
name|unsigned
name|int
name|entries
range|:
literal|16
decl_stmt|;
comment|/* number of children */
block|}
name|NTableRec
operator|,
typedef|*
name|NTable
typedef|;
end_typedef

begin_comment
comment|/* the buckets are right after the structure */
end_comment

begin_define
define|#
directive|define
name|NodeBuckets
parameter_list|(
name|ne
parameter_list|)
value|((NTable *)((ne) + 1))
end_define

begin_define
define|#
directive|define
name|NodeHash
parameter_list|(
name|ne
parameter_list|,
name|q
parameter_list|)
value|NodeBuckets(ne)[(q)& (ne)->mask]
end_define

begin_comment
comment|/* leaf tables have an extra level of indirection for the buckets,  * so that resizing can be done without invalidating a search list.  * This is completely ugly, and wastes some memory, but the Xlib  * spec doesn't really specify whether invalidation is OK, and the  * old implementation did not invalidate.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_LTable
block|{
name|NTableRec
name|table
decl_stmt|;
name|VEntry
modifier|*
name|buckets
decl_stmt|;
block|}
name|LTableRec
operator|,
typedef|*
name|LTable
typedef|;
end_typedef

begin_define
define|#
directive|define
name|LeafHash
parameter_list|(
name|le
parameter_list|,
name|q
parameter_list|)
value|(le)->buckets[(q)& (le)->table.mask]
end_define

begin_comment
comment|/* An XrmDatabase just holds a pointer to the first top-level table.  * The type name is no longer descriptive, but better to not change  * the Xresource.h header file.  This type also gets used to define  * XrmSearchList, which is a complete crock, but we'll just leave it  * and caste types as required.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_XrmHashBucketRec
block|{
name|NTable
name|table
decl_stmt|;
name|XPointer
name|mbstate
decl_stmt|;
name|XrmMethods
name|methods
decl_stmt|;
block|}
name|XrmHashBucketRec
typedef|;
end_typedef

begin_comment
comment|/* closure used in get/put resource */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_VClosure
block|{
name|XrmRepresentation
modifier|*
name|type
decl_stmt|;
comment|/* type of value */
name|XrmValuePtr
name|value
decl_stmt|;
comment|/* value itself */
block|}
name|VClosureRec
operator|,
typedef|*
name|VClosure
typedef|;
end_typedef

begin_comment
comment|/* closure used in get search list */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_SClosure
block|{
name|LTable
modifier|*
name|list
decl_stmt|;
comment|/* search list */
name|int
name|idx
decl_stmt|;
comment|/* index of last filled element */
name|int
name|limit
decl_stmt|;
comment|/* maximum index */
block|}
name|SClosureRec
operator|,
typedef|*
name|SClosure
typedef|;
end_typedef

begin_comment
comment|/* placed in XrmSearchList to indicate next table is loose only */
end_comment

begin_define
define|#
directive|define
name|LOOSESEARCH
value|((LTable)1)
end_define

begin_comment
comment|/* closure used in enumerate database */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_EClosure
block|{
name|XrmDatabase
name|db
decl_stmt|;
comment|/* the database */
name|DBEnumProc
name|proc
decl_stmt|;
comment|/* the user proc */
name|XPointer
name|closure
decl_stmt|;
comment|/* the user closure */
name|XrmBindingList
name|bindings
decl_stmt|;
comment|/* binding list */
name|XrmQuarkList
name|quarks
decl_stmt|;
comment|/* quark list */
name|int
name|mode
decl_stmt|;
comment|/* XrmEnum<kind> */
block|}
name|EClosureRec
operator|,
typedef|*
name|EClosure
typedef|;
end_typedef

begin_comment
comment|/* predicate to determine when to resize a hash table */
end_comment

begin_define
define|#
directive|define
name|GrowthPred
parameter_list|(
name|n
parameter_list|,
name|m
parameter_list|)
value|((unsigned)(n)> (((m) + 1)<< 2))
end_define

begin_define
define|#
directive|define
name|GROW
parameter_list|(
name|prev
parameter_list|)
define|\
value|if (GrowthPred((*prev)->entries, (*prev)->mask)) \ 	GrowTable(prev)
end_define

begin_comment
comment|/* pick a reasonable value for maximum depth of resource database */
end_comment

begin_define
define|#
directive|define
name|MAXDBDEPTH
value|100
end_define

begin_comment
comment|/* macro used in get/search functions */
end_comment

begin_comment
comment|/* find an entry named ename, with leafness given by leaf */
end_comment

begin_define
define|#
directive|define
name|NFIND
parameter_list|(
name|ename
parameter_list|)
define|\
value|q = ename; \     entry = NodeHash(table, q); \     while (entry&& entry->name != q) \ 	entry = entry->next; \     if (leaf&& entry&& !entry->leaf) { \ 	entry = entry->next; \ 	if (entry&& !entry->leaf) \ 	    entry = entry->next; \ 	if (entry&& entry->name != q) \ 	    entry = (NTable)NULL; \     }
end_define

begin_comment
comment|/* resourceQuarks keeps track of what quarks have been associated with values  * in all LTables.  If a quark has never been used in an LTable, we don't need  * to bother looking for it.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|resourceQuarks
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XrmQuark
name|maxResourceQuark
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* determines if a quark has been used for a value in any database */
end_comment

begin_define
define|#
directive|define
name|IsResourceQuark
parameter_list|(
name|q
parameter_list|)
value|((q)> 0&& (q)<= maxResourceQuark&& \ 			     resourceQuarks[(q)>> 3]& (1<< ((q)& 7)))
end_define

begin_typedef
typedef|typedef
name|unsigned
name|char
name|XrmBits
typedef|;
end_typedef

begin_define
define|#
directive|define
name|BSLASH
value|((XrmBits) (1<< 5))
end_define

begin_define
define|#
directive|define
name|NORMAL
value|((XrmBits) (1<< 4))
end_define

begin_define
define|#
directive|define
name|EOQ
value|((XrmBits) (1<< 3))
end_define

begin_define
define|#
directive|define
name|SEP
value|((XrmBits) (1<< 2))
end_define

begin_define
define|#
directive|define
name|ENDOF
value|((XrmBits) (1<< 1))
end_define

begin_define
define|#
directive|define
name|SPACE
value|(NORMAL|EOQ|SEP|(XrmBits)0)
end_define

begin_define
define|#
directive|define
name|RSEP
value|(NORMAL|EOQ|SEP|(XrmBits)1)
end_define

begin_define
define|#
directive|define
name|EOS
value|(EOQ|SEP|ENDOF|(XrmBits)0)
end_define

begin_define
define|#
directive|define
name|EOL
value|(EOQ|SEP|ENDOF|(XrmBits)1)
end_define

begin_define
define|#
directive|define
name|BINDING
value|(NORMAL|EOQ)
end_define

begin_define
define|#
directive|define
name|ODIGIT
value|(NORMAL|(XrmBits)1)
end_define

begin_define
define|#
directive|define
name|next_char
parameter_list|(
name|ch
parameter_list|,
name|str
parameter_list|)
value|xrmtypes[(unsigned char)((ch) = *(++(str)))]
end_define

begin_define
define|#
directive|define
name|next_mbchar
parameter_list|(
name|ch
parameter_list|,
name|len
parameter_list|,
name|str
parameter_list|)
value|xrmtypes[(unsigned char)(ch = (*db->methods->mbchar)(db->mbstate, str,&len), str += len, ch)]
end_define

begin_define
define|#
directive|define
name|is_space
parameter_list|(
name|bits
parameter_list|)
value|((bits) == SPACE)
end_define

begin_define
define|#
directive|define
name|is_EOQ
parameter_list|(
name|bits
parameter_list|)
value|((bits)& EOQ)
end_define

begin_define
define|#
directive|define
name|is_EOF
parameter_list|(
name|bits
parameter_list|)
value|((bits) == EOS)
end_define

begin_define
define|#
directive|define
name|is_EOL
parameter_list|(
name|bits
parameter_list|)
value|((bits)& ENDOF)
end_define

begin_define
define|#
directive|define
name|is_binding
parameter_list|(
name|bits
parameter_list|)
value|((bits) == BINDING)
end_define

begin_define
define|#
directive|define
name|is_odigit
parameter_list|(
name|bits
parameter_list|)
value|((bits) == ODIGIT)
end_define

begin_define
define|#
directive|define
name|is_separator
parameter_list|(
name|bits
parameter_list|)
value|((bits)& SEP)
end_define

begin_define
define|#
directive|define
name|is_nonpcs
parameter_list|(
name|bits
parameter_list|)
value|(!(bits))
end_define

begin_define
define|#
directive|define
name|is_normal
parameter_list|(
name|bits
parameter_list|)
value|((bits)& NORMAL)
end_define

begin_define
define|#
directive|define
name|is_simple
parameter_list|(
name|bits
parameter_list|)
value|((bits)& (NORMAL|BSLASH))
end_define

begin_define
define|#
directive|define
name|is_special
parameter_list|(
name|bits
parameter_list|)
value|((bits)& (ENDOF|BSLASH))
end_define

begin_comment
comment|/* parsing types */
end_comment

begin_decl_stmt
specifier|static
name|XrmBits
name|Const
name|xrmtypes
index|[
literal|256
index|]
init|=
block|{
name|EOS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SPACE
block|,
name|EOL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SPACE
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|BINDING
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|BINDING
block|,
name|NORMAL
block|,
name|ODIGIT
block|,
name|ODIGIT
block|,
name|ODIGIT
block|,
name|ODIGIT
block|,
name|ODIGIT
block|,
name|ODIGIT
block|,
name|ODIGIT
block|,
name|ODIGIT
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|RSEP
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|BSLASH
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
name|NORMAL
block|,
literal|0
comment|/* The rest will be automatically initialized to zero. */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|XrmInitialize
parameter_list|()
block|{
name|XrmQString
operator|=
name|XrmPermStringToQuark
argument_list|(
literal|"String"
argument_list|)
expr_stmt|;
name|XrmQANY
operator|=
name|XrmPermStringToQuark
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|XrmDatabase
name|XrmGetDatabase
parameter_list|(
name|display
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
block|{
return|return
name|display
operator|->
name|db
return|;
block|}
end_function

begin_function
name|void
name|XrmSetDatabase
parameter_list|(
name|display
parameter_list|,
name|database
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|XrmDatabase
name|database
decl_stmt|;
block|{
name|display
operator|->
name|db
operator|=
name|database
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_decl_stmt
name|void
name|XrmStringToQuarkList
argument_list|(
specifier|register
name|_Xconst
name|char
operator|*
name|name
argument_list|,
specifier|register
name|XrmQuarkList
name|quarks
argument_list|)
comment|/* RETURN */
else|#
directive|else
name|void
name|XrmStringToQuarkList
argument_list|(
name|name
argument_list|,
name|quarks
argument_list|)
decl|register
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|XrmQuarkList
name|quarks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|XrmBits
name|bits
decl_stmt|;
specifier|register
name|Signature
name|sig
init|=
literal|0
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|,
modifier|*
name|tname
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tname
operator|=
operator|(
name|char
operator|*
operator|)
name|name
condition|)
block|{
name|tname
operator|--
expr_stmt|;
while|while
condition|(
operator|!
name|is_EOF
argument_list|(
name|bits
operator|=
name|next_char
argument_list|(
name|ch
argument_list|,
name|tname
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_binding
argument_list|(
name|bits
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
condition|)
block|{
comment|/* Found a complete name */
operator|*
name|quarks
operator|++
operator|=
name|_XrmInternalStringToQuark
argument_list|(
name|name
argument_list|,
name|tname
operator|-
name|name
argument_list|,
name|sig
argument_list|,
name|False
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|sig
operator|=
literal|0
expr_stmt|;
block|}
name|name
operator|=
name|tname
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sig
operator|=
operator|(
name|sig
operator|<<
literal|1
operator|)
operator|+
name|ch
expr_stmt|;
comment|/* Compute the signature. */
name|i
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|quarks
operator|++
operator|=
name|_XrmInternalStringToQuark
argument_list|(
name|name
argument_list|,
name|tname
operator|-
name|name
argument_list|,
name|sig
argument_list|,
name|False
argument_list|)
expr_stmt|;
block|}
operator|*
name|quarks
operator|=
name|NULLQUARK
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_decl_stmt
name|void
name|XrmStringToBindingQuarkList
argument_list|(
specifier|register
name|_Xconst
name|char
operator|*
name|name
argument_list|,
specifier|register
name|XrmBindingList
name|bindings
argument_list|,
comment|/* RETURN */
specifier|register
name|XrmQuarkList
name|quarks
argument_list|)
comment|/* RETURN */
else|#
directive|else
name|void
name|XrmStringToBindingQuarkList
argument_list|(
name|name
argument_list|,
name|bindings
argument_list|,
name|quarks
argument_list|)
decl|register
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|XrmBindingList
name|bindings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN */
end_comment

begin_decl_stmt
specifier|register
name|XrmQuarkList
name|quarks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|XrmBits
name|bits
decl_stmt|;
specifier|register
name|Signature
name|sig
init|=
literal|0
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|,
modifier|*
name|tname
decl_stmt|;
specifier|register
name|XrmBinding
name|binding
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tname
operator|=
operator|(
name|char
operator|*
operator|)
name|name
condition|)
block|{
name|tname
operator|--
expr_stmt|;
name|binding
operator|=
name|XrmBindTightly
expr_stmt|;
while|while
condition|(
operator|!
name|is_EOF
argument_list|(
name|bits
operator|=
name|next_char
argument_list|(
name|ch
argument_list|,
name|tname
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_binding
argument_list|(
name|bits
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
condition|)
block|{
comment|/* Found a complete name */
operator|*
name|bindings
operator|++
operator|=
name|binding
expr_stmt|;
operator|*
name|quarks
operator|++
operator|=
name|_XrmInternalStringToQuark
argument_list|(
name|name
argument_list|,
name|tname
operator|-
name|name
argument_list|,
name|sig
argument_list|,
name|False
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|sig
operator|=
literal|0
expr_stmt|;
name|binding
operator|=
name|XrmBindTightly
expr_stmt|;
block|}
name|name
operator|=
name|tname
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
name|binding
operator|=
name|XrmBindLoosely
expr_stmt|;
block|}
else|else
block|{
name|sig
operator|=
operator|(
name|sig
operator|<<
literal|1
operator|)
operator|+
name|ch
expr_stmt|;
comment|/* Compute the signature. */
name|i
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|bindings
operator|=
name|binding
expr_stmt|;
operator|*
name|quarks
operator|++
operator|=
name|_XrmInternalStringToQuark
argument_list|(
name|name
argument_list|,
name|tname
operator|-
name|name
argument_list|,
name|sig
argument_list|,
name|False
argument_list|)
expr_stmt|;
block|}
operator|*
name|quarks
operator|=
name|NULLQUARK
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|PrintQuarkList
parameter_list|(
name|quarks
parameter_list|,
name|stream
parameter_list|)
name|XrmQuarkList
name|quarks
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|Bool
name|firstNameSeen
decl_stmt|;
for|for
control|(
name|firstNameSeen
operator|=
name|False
init|;
operator|*
name|quarks
condition|;
name|quarks
operator|++
control|)
block|{
if|if
condition|(
name|firstNameSeen
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
name|firstNameSeen
operator|=
name|True
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|XrmQuarkToString
argument_list|(
operator|*
name|quarks
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* PrintQuarkList */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|mbnoop
parameter_list|(
name|state
parameter_list|)
name|XPointer
name|state
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|char
name|mbchar
parameter_list|(
name|state
parameter_list|,
name|str
parameter_list|,
name|lenp
parameter_list|)
name|XPointer
name|state
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|;
block|{
operator|*
name|lenp
operator|=
literal|1
expr_stmt|;
return|return
operator|*
name|str
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|lcname
parameter_list|(
name|state
parameter_list|)
name|XPointer
name|state
decl_stmt|;
block|{
return|return
literal|"C"
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|RConst
name|XrmMethodsRec
name|mb_methods
init|=
block|{
name|mbnoop
block|,
name|mbchar
block|,
name|mbnoop
block|,
name|lcname
block|,
name|mbnoop
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|XrmDatabase
name|NewDatabase
parameter_list|()
block|{
specifier|register
name|XrmDatabase
name|db
decl_stmt|;
name|db
operator|=
operator|(
name|XrmDatabase
operator|)
name|Xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XrmHashBucketRec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
condition|)
block|{
name|db
operator|->
name|table
operator|=
operator|(
name|NTable
operator|)
name|NULL
expr_stmt|;
name|db
operator|->
name|methods
operator|=
name|_XrmInitParseInfo
argument_list|(
operator|&
name|db
operator|->
name|mbstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db
operator|->
name|methods
condition|)
name|db
operator|->
name|methods
operator|=
operator|(
name|XrmMethods
operator|)
operator|&
name|mb_methods
expr_stmt|;
block|}
return|return
name|db
return|;
block|}
end_function

begin_comment
comment|/* move all values from ftable to ttable, and free ftable's buckets.  * ttable is quaranteed empty to start with.  */
end_comment

begin_function
specifier|static
name|void
name|MoveValues
parameter_list|(
name|ftable
parameter_list|,
name|ttable
parameter_list|)
name|LTable
name|ftable
decl_stmt|;
specifier|register
name|LTable
name|ttable
decl_stmt|;
block|{
specifier|register
name|VEntry
name|fentry
decl_stmt|,
name|nfentry
decl_stmt|;
specifier|register
name|VEntry
modifier|*
name|prev
decl_stmt|;
specifier|register
name|VEntry
modifier|*
name|bucket
decl_stmt|;
specifier|register
name|VEntry
name|tentry
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ftable
operator|->
name|table
operator|.
name|mask
operator|,
name|bucket
operator|=
name|ftable
operator|->
name|buckets
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
for|for
control|(
name|fentry
operator|=
operator|*
name|bucket
operator|++
init|;
name|fentry
condition|;
name|fentry
operator|=
name|nfentry
control|)
block|{
name|prev
operator|=
operator|&
name|LeafHash
argument_list|(
name|ttable
argument_list|,
name|fentry
operator|->
name|name
argument_list|)
expr_stmt|;
name|tentry
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|fentry
expr_stmt|;
comment|/* chain on all with same name, to preserve invariant order */
while|while
condition|(
operator|(
name|nfentry
operator|=
name|fentry
operator|->
name|next
operator|)
operator|&&
name|nfentry
operator|->
name|name
operator|==
name|fentry
operator|->
name|name
condition|)
name|fentry
operator|=
name|nfentry
expr_stmt|;
name|fentry
operator|->
name|next
operator|=
name|tentry
expr_stmt|;
block|}
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftable
operator|->
name|buckets
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* move all tables from ftable to ttable, and free ftable.  * ttable is quaranteed empty to start with.  */
end_comment

begin_function
specifier|static
name|void
name|MoveTables
parameter_list|(
name|ftable
parameter_list|,
name|ttable
parameter_list|)
name|NTable
name|ftable
decl_stmt|;
specifier|register
name|NTable
name|ttable
decl_stmt|;
block|{
specifier|register
name|NTable
name|fentry
decl_stmt|,
name|nfentry
decl_stmt|;
specifier|register
name|NTable
modifier|*
name|prev
decl_stmt|;
specifier|register
name|NTable
modifier|*
name|bucket
decl_stmt|;
specifier|register
name|NTable
name|tentry
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ftable
operator|->
name|mask
operator|,
name|bucket
operator|=
name|NodeBuckets
argument_list|(
name|ftable
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
for|for
control|(
name|fentry
operator|=
operator|*
name|bucket
operator|++
init|;
name|fentry
condition|;
name|fentry
operator|=
name|nfentry
control|)
block|{
name|prev
operator|=
operator|&
name|NodeHash
argument_list|(
name|ttable
argument_list|,
name|fentry
operator|->
name|name
argument_list|)
expr_stmt|;
name|tentry
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|fentry
expr_stmt|;
comment|/* chain on all with same name, to preserve invariant order */
while|while
condition|(
operator|(
name|nfentry
operator|=
name|fentry
operator|->
name|next
operator|)
operator|&&
name|nfentry
operator|->
name|name
operator|==
name|fentry
operator|->
name|name
condition|)
name|fentry
operator|=
name|nfentry
expr_stmt|;
name|fentry
operator|->
name|next
operator|=
name|tentry
expr_stmt|;
block|}
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* grow the table, based on current number of entries */
end_comment

begin_function
specifier|static
name|void
name|GrowTable
parameter_list|(
name|prev
parameter_list|)
name|NTable
modifier|*
name|prev
decl_stmt|;
block|{
specifier|register
name|NTable
name|table
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|table
operator|=
operator|*
name|prev
expr_stmt|;
name|i
operator|=
name|table
operator|->
name|mask
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|255
condition|)
comment|/* biggest it gets */
return|return;
while|while
condition|(
name|i
operator|<
literal|255
operator|&&
name|GrowthPred
argument_list|(
name|table
operator|->
name|entries
argument_list|,
name|i
argument_list|)
condition|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* i is now the new size */
if|if
condition|(
name|table
operator|->
name|leaf
condition|)
block|{
specifier|register
name|LTable
name|ltable
decl_stmt|;
name|LTableRec
name|otable
decl_stmt|;
name|ltable
operator|=
operator|(
name|LTable
operator|)
name|table
expr_stmt|;
comment|/* cons up a copy to make MoveValues look symmetric */
name|otable
operator|=
operator|*
name|ltable
expr_stmt|;
name|ltable
operator|->
name|buckets
operator|=
operator|(
name|VEntry
operator|*
operator|)
name|Xmalloc
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|VEntry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ltable
operator|->
name|buckets
condition|)
block|{
name|ltable
operator|->
name|buckets
operator|=
name|otable
operator|.
name|buckets
expr_stmt|;
return|return;
block|}
name|ltable
operator|->
name|table
operator|.
name|mask
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ltable
operator|->
name|buckets
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|VEntry
argument_list|)
argument_list|)
expr_stmt|;
name|MoveValues
argument_list|(
operator|&
name|otable
argument_list|,
name|ltable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|NTable
name|ntable
decl_stmt|;
name|ntable
operator|=
operator|(
name|NTable
operator|)
name|Xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NTableRec
argument_list|)
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|NTable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ntable
condition|)
return|return;
operator|*
name|ntable
operator|=
operator|*
name|table
expr_stmt|;
name|ntable
operator|->
name|mask
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NodeBuckets
argument_list|(
name|ntable
argument_list|)
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|NTable
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|ntable
expr_stmt|;
name|MoveTables
argument_list|(
name|table
argument_list|,
name|ntable
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* merge values from ftable into *pprev, destroy ftable in the process */
end_comment

begin_function
specifier|static
name|void
name|MergeValues
parameter_list|(
name|ftable
parameter_list|,
name|pprev
parameter_list|,
name|override
parameter_list|)
name|LTable
name|ftable
decl_stmt|;
name|NTable
modifier|*
name|pprev
decl_stmt|;
name|Bool
name|override
decl_stmt|;
block|{
specifier|register
name|VEntry
name|fentry
decl_stmt|,
name|tentry
decl_stmt|;
specifier|register
name|VEntry
modifier|*
name|prev
decl_stmt|;
specifier|register
name|LTable
name|ttable
decl_stmt|;
name|VEntry
modifier|*
name|bucket
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|XrmQuark
name|q
decl_stmt|;
name|ttable
operator|=
operator|(
name|LTable
operator|)
operator|*
name|pprev
expr_stmt|;
if|if
condition|(
name|ftable
operator|->
name|table
operator|.
name|hasloose
condition|)
name|ttable
operator|->
name|table
operator|.
name|hasloose
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ftable
operator|->
name|table
operator|.
name|mask
operator|,
name|bucket
operator|=
name|ftable
operator|->
name|buckets
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|bucket
operator|++
control|)
block|{
for|for
control|(
name|fentry
operator|=
operator|*
name|bucket
init|;
name|fentry
condition|;
control|)
block|{
name|q
operator|=
name|fentry
operator|->
name|name
expr_stmt|;
name|prev
operator|=
operator|&
name|LeafHash
argument_list|(
name|ttable
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|tentry
operator|=
operator|*
name|prev
expr_stmt|;
while|while
condition|(
name|tentry
operator|&&
name|tentry
operator|->
name|name
operator|!=
name|q
condition|)
name|tentry
operator|=
operator|*
operator|(
name|prev
operator|=
operator|&
name|tentry
operator|->
name|next
operator|)
expr_stmt|;
comment|/* note: test intentionally uses fentry->name instead of q */
comment|/* permits serendipitous inserts */
while|while
condition|(
name|tentry
operator|&&
name|tentry
operator|->
name|name
operator|==
name|fentry
operator|->
name|name
condition|)
block|{
comment|/* if tentry is earlier, skip it */
if|if
condition|(
operator|!
name|fentry
operator|->
name|tight
operator|&&
name|tentry
operator|->
name|tight
condition|)
block|{
name|tentry
operator|=
operator|*
operator|(
name|prev
operator|=
operator|&
name|tentry
operator|->
name|next
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fentry
operator|->
name|tight
operator|!=
name|tentry
operator|->
name|tight
condition|)
block|{
comment|/* no match, chain in fentry */
operator|*
name|prev
operator|=
name|fentry
expr_stmt|;
name|prev
operator|=
operator|&
name|fentry
operator|->
name|next
expr_stmt|;
name|fentry
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|tentry
expr_stmt|;
name|ttable
operator|->
name|table
operator|.
name|entries
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|override
condition|)
block|{
comment|/* match, chain in fentry, splice out and free tentry */
operator|*
name|prev
operator|=
name|fentry
expr_stmt|;
name|prev
operator|=
operator|&
name|fentry
operator|->
name|next
expr_stmt|;
name|fentry
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|tentry
operator|->
name|next
expr_stmt|;
comment|/* free the overridden entry */
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tentry
argument_list|)
expr_stmt|;
comment|/* get next tentry */
name|tentry
operator|=
operator|*
name|prev
expr_stmt|;
block|}
else|else
block|{
comment|/* match, discard fentry */
name|prev
operator|=
operator|&
name|tentry
operator|->
name|next
expr_stmt|;
name|tentry
operator|=
name|fentry
expr_stmt|;
comment|/* use as a temp var */
name|fentry
operator|=
name|fentry
operator|->
name|next
expr_stmt|;
comment|/* free the overpowered entry */
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tentry
argument_list|)
expr_stmt|;
comment|/* get next tentry */
name|tentry
operator|=
operator|*
name|prev
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fentry
condition|)
break|break;
block|}
comment|/* at this point, tentry cannot match any fentry named q */
comment|/* chain in all bindings together, preserve invariant order */
while|while
condition|(
name|fentry
operator|&&
name|fentry
operator|->
name|name
operator|==
name|q
condition|)
block|{
operator|*
name|prev
operator|=
name|fentry
expr_stmt|;
name|prev
operator|=
operator|&
name|fentry
operator|->
name|next
expr_stmt|;
name|fentry
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|tentry
expr_stmt|;
name|ttable
operator|->
name|table
operator|.
name|entries
operator|++
expr_stmt|;
block|}
block|}
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftable
operator|->
name|buckets
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftable
argument_list|)
expr_stmt|;
comment|/* resize if necessary, now that we're all done */
name|GROW
argument_list|(
name|pprev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* merge tables from ftable into *pprev, destroy ftable in the process */
end_comment

begin_function
specifier|static
name|void
name|MergeTables
parameter_list|(
name|ftable
parameter_list|,
name|pprev
parameter_list|,
name|override
parameter_list|)
name|NTable
name|ftable
decl_stmt|;
name|NTable
modifier|*
name|pprev
decl_stmt|;
name|Bool
name|override
decl_stmt|;
block|{
specifier|register
name|NTable
name|fentry
decl_stmt|,
name|tentry
decl_stmt|;
name|NTable
name|nfentry
decl_stmt|;
specifier|register
name|NTable
modifier|*
name|prev
decl_stmt|;
specifier|register
name|NTable
name|ttable
decl_stmt|;
name|NTable
modifier|*
name|bucket
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|XrmQuark
name|q
decl_stmt|;
name|ttable
operator|=
operator|*
name|pprev
expr_stmt|;
if|if
condition|(
name|ftable
operator|->
name|hasloose
condition|)
name|ttable
operator|->
name|hasloose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ftable
operator|->
name|hasany
condition|)
name|ttable
operator|->
name|hasany
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ftable
operator|->
name|mask
operator|,
name|bucket
operator|=
name|NodeBuckets
argument_list|(
name|ftable
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|bucket
operator|++
control|)
block|{
for|for
control|(
name|fentry
operator|=
operator|*
name|bucket
init|;
name|fentry
condition|;
control|)
block|{
name|q
operator|=
name|fentry
operator|->
name|name
expr_stmt|;
name|prev
operator|=
operator|&
name|NodeHash
argument_list|(
name|ttable
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|tentry
operator|=
operator|*
name|prev
expr_stmt|;
while|while
condition|(
name|tentry
operator|&&
name|tentry
operator|->
name|name
operator|!=
name|q
condition|)
name|tentry
operator|=
operator|*
operator|(
name|prev
operator|=
operator|&
name|tentry
operator|->
name|next
operator|)
expr_stmt|;
comment|/* note: test intentionally uses fentry->name instead of q */
comment|/* permits serendipitous inserts */
while|while
condition|(
name|tentry
operator|&&
name|tentry
operator|->
name|name
operator|==
name|fentry
operator|->
name|name
condition|)
block|{
comment|/* if tentry is earlier, skip it */
if|if
condition|(
operator|(
name|fentry
operator|->
name|leaf
operator|&&
operator|!
name|tentry
operator|->
name|leaf
operator|)
operator|||
operator|(
operator|!
name|fentry
operator|->
name|tight
operator|&&
name|tentry
operator|->
name|tight
operator|&&
operator|(
name|fentry
operator|->
name|leaf
operator|||
operator|!
name|tentry
operator|->
name|leaf
operator|)
operator|)
condition|)
block|{
name|tentry
operator|=
operator|*
operator|(
name|prev
operator|=
operator|&
name|tentry
operator|->
name|next
operator|)
expr_stmt|;
continue|continue;
block|}
name|nfentry
operator|=
name|fentry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|fentry
operator|->
name|leaf
operator|!=
name|tentry
operator|->
name|leaf
operator|||
name|fentry
operator|->
name|tight
operator|!=
name|tentry
operator|->
name|tight
condition|)
block|{
comment|/* no match, just chain in */
operator|*
name|prev
operator|=
name|fentry
expr_stmt|;
operator|*
operator|(
name|prev
operator|=
operator|&
name|fentry
operator|->
name|next
operator|)
operator|=
name|tentry
expr_stmt|;
name|ttable
operator|->
name|entries
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fentry
operator|->
name|leaf
condition|)
name|MergeValues
argument_list|(
operator|(
name|LTable
operator|)
name|fentry
argument_list|,
name|prev
argument_list|,
name|override
argument_list|)
expr_stmt|;
else|else
name|MergeTables
argument_list|(
name|fentry
argument_list|,
name|prev
argument_list|,
name|override
argument_list|)
expr_stmt|;
comment|/* bump to next tentry */
name|tentry
operator|=
operator|*
operator|(
name|prev
operator|=
operator|&
operator|(
operator|*
name|prev
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
comment|/* bump to next fentry */
name|fentry
operator|=
name|nfentry
expr_stmt|;
if|if
condition|(
operator|!
name|fentry
condition|)
break|break;
block|}
comment|/* at this point, tentry cannot match any fentry named q */
comment|/* chain in all bindings together, preserve invariant order */
while|while
condition|(
name|fentry
operator|&&
name|fentry
operator|->
name|name
operator|==
name|q
condition|)
block|{
operator|*
name|prev
operator|=
name|fentry
expr_stmt|;
name|prev
operator|=
operator|&
name|fentry
operator|->
name|next
expr_stmt|;
name|fentry
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|tentry
expr_stmt|;
name|ttable
operator|->
name|entries
operator|++
expr_stmt|;
block|}
block|}
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftable
argument_list|)
expr_stmt|;
comment|/* resize if necessary, now that we're all done */
name|GROW
argument_list|(
name|pprev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XrmCombineDatabase
parameter_list|(
name|from
parameter_list|,
name|into
parameter_list|,
name|override
parameter_list|)
name|XrmDatabase
name|from
decl_stmt|,
decl|*
name|into
decl_stmt|;
end_function

begin_decl_stmt
name|Bool
name|override
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|NTable
modifier|*
name|prev
decl_stmt|;
specifier|register
name|NTable
name|ftable
decl_stmt|,
name|ttable
decl_stmt|,
name|nftable
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|into
condition|)
block|{
operator|*
name|into
operator|=
name|from
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from
condition|)
block|{
if|if
condition|(
name|ftable
operator|=
name|from
operator|->
name|table
condition|)
block|{
name|prev
operator|=
operator|&
operator|(
operator|*
name|into
operator|)
operator|->
name|table
expr_stmt|;
name|ttable
operator|=
operator|*
name|prev
expr_stmt|;
if|if
condition|(
operator|!
name|ftable
operator|->
name|leaf
condition|)
block|{
name|nftable
operator|=
name|ftable
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ttable
operator|&&
operator|!
name|ttable
operator|->
name|leaf
condition|)
block|{
comment|/* both have node tables, merge them */
name|MergeTables
argument_list|(
name|ftable
argument_list|,
name|prev
argument_list|,
name|override
argument_list|)
expr_stmt|;
comment|/* bump to into's leaf table, if any */
name|ttable
operator|=
operator|*
operator|(
name|prev
operator|=
operator|&
operator|(
operator|*
name|prev
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* into has no node table, link from's in */
operator|*
name|prev
operator|=
name|ftable
expr_stmt|;
operator|*
operator|(
name|prev
operator|=
operator|&
name|ftable
operator|->
name|next
operator|)
operator|=
name|ttable
expr_stmt|;
block|}
comment|/* bump to from's leaf table, if any */
name|ftable
operator|=
name|nftable
expr_stmt|;
block|}
else|else
block|{
comment|/* bump to into's leaf table, if any */
if|if
condition|(
name|ttable
operator|&&
operator|!
name|ttable
operator|->
name|leaf
condition|)
name|ttable
operator|=
operator|*
operator|(
name|prev
operator|=
operator|&
name|ttable
operator|->
name|next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ftable
condition|)
block|{
comment|/* if into has a leaf, merge, else insert */
if|if
condition|(
name|ttable
condition|)
name|MergeValues
argument_list|(
operator|(
name|LTable
operator|)
name|ftable
argument_list|,
name|prev
argument_list|,
name|override
argument_list|)
expr_stmt|;
else|else
operator|*
name|prev
operator|=
name|ftable
expr_stmt|;
block|}
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|from
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|XrmMergeDatabases
parameter_list|(
name|from
parameter_list|,
name|into
parameter_list|)
name|XrmDatabase
name|from
decl_stmt|,
decl|*
name|into
decl_stmt|;
end_function

begin_block
block|{
name|XrmCombineDatabase
argument_list|(
name|from
argument_list|,
name|into
argument_list|,
name|True
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* store a value in the database, overriding any existing entry */
end_comment

begin_function
specifier|static
name|void
name|PutEntry
parameter_list|(
name|db
parameter_list|,
name|bindings
parameter_list|,
name|quarks
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|)
name|XrmDatabase
name|db
decl_stmt|;
name|XrmBindingList
name|bindings
decl_stmt|;
name|XrmQuarkList
name|quarks
decl_stmt|;
name|XrmRepresentation
name|type
decl_stmt|;
name|XrmValuePtr
name|value
decl_stmt|;
block|{
specifier|register
name|NTable
modifier|*
name|pprev
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
specifier|register
name|NTable
name|table
decl_stmt|;
specifier|register
name|XrmQuark
name|q
decl_stmt|;
specifier|register
name|VEntry
modifier|*
name|vprev
decl_stmt|;
specifier|register
name|VEntry
name|entry
decl_stmt|;
name|NTable
modifier|*
name|nprev
decl_stmt|,
modifier|*
name|firstpprev
decl_stmt|;
define|#
directive|define
name|NEWTABLE
parameter_list|(
name|q
parameter_list|,
name|i
parameter_list|)
define|\
value|table = (NTable)Xmalloc(sizeof(LTableRec)); \     if (!table) \ 	return; \     table->name = q; \     table->hasloose = 0; \     table->hasany = 0; \     table->mask = 0; \     table->entries = 0; \     if (quarks[i]) { \ 	table->leaf = 0; \ 	nprev = NodeBuckets(table); \     } else { \ 	table->leaf = 1; \ 	if (!(nprev = (NTable *)Xmalloc(sizeof(VEntry *)))) \ 	    return; \ 	((LTable)table)->buckets = (VEntry *)nprev; \     } \     *nprev = (NTable)NULL; \     table->next = *prev; \     *prev = table
if|if
condition|(
operator|!
name|db
operator|||
operator|!
operator|*
name|quarks
condition|)
return|return;
name|table
operator|=
operator|*
operator|(
name|prev
operator|=
operator|&
name|db
operator|->
name|table
operator|)
expr_stmt|;
comment|/* if already at leaf, bump to the leaf table */
if|if
condition|(
operator|!
name|quarks
index|[
literal|1
index|]
operator|&&
name|table
operator|&&
operator|!
name|table
operator|->
name|leaf
condition|)
name|table
operator|=
operator|*
operator|(
name|prev
operator|=
operator|&
name|table
operator|->
name|next
operator|)
expr_stmt|;
name|pprev
operator|=
name|prev
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|||
operator|(
name|quarks
index|[
literal|1
index|]
operator|&&
name|table
operator|->
name|leaf
operator|)
condition|)
block|{
comment|/* no top-level node table, create one and chain it in */
name|NEWTABLE
argument_list|(
name|NULLQUARK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|table
operator|->
name|tight
operator|=
literal|1
expr_stmt|;
comment|/* arbitrary */
name|prev
operator|=
name|nprev
expr_stmt|;
block|}
else|else
block|{
comment|/* search along until we need a value */
while|while
condition|(
name|quarks
index|[
literal|1
index|]
condition|)
block|{
name|q
operator|=
operator|*
name|quarks
expr_stmt|;
name|table
operator|=
operator|*
operator|(
name|prev
operator|=
operator|&
name|NodeHash
argument_list|(
name|table
argument_list|,
name|q
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
name|table
operator|&&
name|table
operator|->
name|name
operator|!=
name|q
condition|)
name|table
operator|=
operator|*
operator|(
name|prev
operator|=
operator|&
name|table
operator|->
name|next
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
break|break;
comment|/* not found */
if|if
condition|(
name|quarks
index|[
literal|2
index|]
condition|)
block|{
if|if
condition|(
name|table
operator|->
name|leaf
condition|)
break|break;
comment|/* not found */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|table
operator|->
name|leaf
condition|)
block|{
comment|/* bump to leaf table, if any */
name|table
operator|=
operator|*
operator|(
name|prev
operator|=
operator|&
name|table
operator|->
name|next
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|||
name|table
operator|->
name|name
operator|!=
name|q
condition|)
break|break;
comment|/* not found */
if|if
condition|(
operator|!
name|table
operator|->
name|leaf
condition|)
block|{
comment|/* bump to leaf table, if any */
name|table
operator|=
operator|*
operator|(
name|prev
operator|=
operator|&
name|table
operator|->
name|next
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|||
name|table
operator|->
name|name
operator|!=
name|q
condition|)
break|break;
comment|/* not found */
block|}
block|}
block|}
if|if
condition|(
operator|*
name|bindings
operator|==
name|XrmBindTightly
condition|)
block|{
if|if
condition|(
operator|!
name|table
operator|->
name|tight
condition|)
break|break;
comment|/* not found */
block|}
else|else
block|{
if|if
condition|(
name|table
operator|->
name|tight
condition|)
block|{
comment|/* bump to loose table, if any */
name|table
operator|=
operator|*
operator|(
name|prev
operator|=
operator|&
name|table
operator|->
name|next
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|||
name|table
operator|->
name|name
operator|!=
name|q
operator|||
operator|!
name|quarks
index|[
literal|2
index|]
operator|!=
name|table
operator|->
name|leaf
condition|)
break|break;
comment|/* not found */
block|}
block|}
comment|/* found that one, bump to next quark */
name|pprev
operator|=
name|prev
expr_stmt|;
name|quarks
operator|++
expr_stmt|;
name|bindings
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quarks
index|[
literal|1
index|]
condition|)
block|{
comment|/* found all the way to a leaf */
name|q
operator|=
operator|*
name|quarks
expr_stmt|;
name|entry
operator|=
operator|*
operator|(
name|vprev
operator|=
operator|&
name|LeafHash
argument_list|(
operator|(
name|LTable
operator|)
name|table
argument_list|,
name|q
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
name|entry
operator|&&
name|entry
operator|->
name|name
operator|!=
name|q
condition|)
name|entry
operator|=
operator|*
operator|(
name|vprev
operator|=
operator|&
name|entry
operator|->
name|next
operator|)
expr_stmt|;
comment|/* if want loose and have tight, bump to next entry */
if|if
condition|(
name|entry
operator|&&
operator|*
name|bindings
operator|==
name|XrmBindLoosely
operator|&&
name|entry
operator|->
name|tight
condition|)
name|entry
operator|=
operator|*
operator|(
name|vprev
operator|=
operator|&
name|entry
operator|->
name|next
operator|)
expr_stmt|;
if|if
condition|(
name|entry
operator|&&
name|entry
operator|->
name|name
operator|==
name|q
operator|&&
operator|(
operator|*
name|bindings
operator|==
name|XrmBindTightly
operator|)
operator|==
name|entry
operator|->
name|tight
condition|)
block|{
comment|/* match, need to override */
if|if
condition|(
operator|(
name|type
operator|==
name|XrmQString
operator|)
operator|==
name|entry
operator|->
name|string
operator|&&
name|entry
operator|->
name|size
operator|==
name|value
operator|->
name|size
condition|)
block|{
comment|/* update type if not String, can be different */
if|if
condition|(
operator|!
name|entry
operator|->
name|string
condition|)
name|RepType
argument_list|(
name|entry
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* identical size, just overwrite value */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|value
operator|->
name|addr
argument_list|,
name|RawValue
argument_list|(
name|entry
argument_list|)
argument_list|,
name|value
operator|->
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* splice out and free old entry */
operator|*
name|vprev
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pprev
operator|)
operator|->
name|entries
operator|--
expr_stmt|;
block|}
comment|/* this is where to insert */
name|prev
operator|=
operator|(
name|NTable
operator|*
operator|)
name|vprev
expr_stmt|;
block|}
block|}
comment|/* keep the top table, because we may have to grow it */
name|firstpprev
operator|=
name|pprev
expr_stmt|;
comment|/* iterate until we get to the leaf */
while|while
condition|(
name|quarks
index|[
literal|1
index|]
condition|)
block|{
comment|/* build a new table and chain it in */
name|NEWTABLE
argument_list|(
operator|*
name|quarks
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|quarks
operator|++
operator|==
name|XrmQANY
condition|)
operator|(
operator|*
name|pprev
operator|)
operator|->
name|hasany
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|bindings
operator|++
operator|==
name|XrmBindTightly
condition|)
block|{
name|table
operator|->
name|tight
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|table
operator|->
name|tight
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pprev
operator|)
operator|->
name|hasloose
operator|=
literal|1
expr_stmt|;
block|}
operator|(
operator|*
name|pprev
operator|)
operator|->
name|entries
operator|++
expr_stmt|;
name|pprev
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|nprev
expr_stmt|;
block|}
comment|/* now allocate the value entry */
name|entry
operator|=
operator|(
name|VEntry
operator|)
name|Xmalloc
argument_list|(
operator|(
operator|(
name|type
operator|==
name|XrmQString
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|VEntryRec
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|DEntryRec
argument_list|)
operator|)
operator|+
name|value
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
return|return;
name|entry
operator|->
name|name
operator|=
name|q
operator|=
operator|*
name|quarks
expr_stmt|;
if|if
condition|(
operator|*
name|bindings
operator|==
name|XrmBindTightly
condition|)
block|{
name|entry
operator|->
name|tight
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|->
name|tight
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pprev
operator|)
operator|->
name|hasloose
operator|=
literal|1
expr_stmt|;
block|}
comment|/* chain it in, with a bit of type cast ugliness */
name|entry
operator|->
name|next
operator|=
operator|*
operator|(
operator|(
name|VEntry
operator|*
operator|)
name|prev
operator|)
expr_stmt|;
operator|*
operator|(
operator|(
name|VEntry
operator|*
operator|)
name|prev
operator|)
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|size
operator|=
name|value
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|XrmQString
condition|)
block|{
name|entry
operator|->
name|string
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|->
name|string
operator|=
literal|0
expr_stmt|;
name|RepType
argument_list|(
name|entry
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
comment|/* save a copy of the value */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|value
operator|->
name|addr
argument_list|,
name|RawValue
argument_list|(
name|entry
argument_list|)
argument_list|,
name|value
operator|->
name|size
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pprev
operator|)
operator|->
name|entries
operator|++
expr_stmt|;
comment|/* this is a new leaf, need to remember it for search lists */
if|if
condition|(
name|q
operator|>
name|maxResourceQuark
condition|)
block|{
name|unsigned
name|oldsize
init|=
name|maxResourceQuark
operator|+
literal|1
decl_stmt|;
name|unsigned
name|size
init|=
operator|(
name|q
operator||
literal|0x7f
operator|)
operator|+
literal|1
decl_stmt|;
comment|/* reallocate in reasonable chunks */
if|if
condition|(
name|resourceQuarks
condition|)
name|resourceQuarks
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|Xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|resourceQuarks
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|resourceQuarks
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|Xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|resourceQuarks
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|resourceQuarks
index|[
name|oldsize
index|]
argument_list|,
name|size
operator|-
name|oldsize
argument_list|)
expr_stmt|;
name|maxResourceQuark
operator|=
name|size
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|maxResourceQuark
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
operator|>
literal|0
operator|&&
name|resourceQuarks
condition|)
name|resourceQuarks
index|[
name|q
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|q
operator|&
literal|0x7
operator|)
expr_stmt|;
name|GROW
argument_list|(
name|firstpprev
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|NEWTABLE
block|}
end_function

begin_function
name|void
name|XrmQPutResource
parameter_list|(
name|pdb
parameter_list|,
name|bindings
parameter_list|,
name|quarks
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|)
name|XrmDatabase
modifier|*
name|pdb
decl_stmt|;
name|XrmBindingList
name|bindings
decl_stmt|;
name|XrmQuarkList
name|quarks
decl_stmt|;
name|XrmRepresentation
name|type
decl_stmt|;
name|XrmValuePtr
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|*
name|pdb
condition|)
operator|*
name|pdb
operator|=
name|NewDatabase
argument_list|()
expr_stmt|;
name|PutEntry
argument_list|(
operator|*
name|pdb
argument_list|,
name|bindings
argument_list|,
name|quarks
argument_list|,
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|void
name|XrmPutResource
parameter_list|(
name|XrmDatabase
modifier|*
name|pdb
parameter_list|,
name|_Xconst
name|char
modifier|*
name|specifier
parameter_list|,
name|_Xconst
name|char
modifier|*
name|type
parameter_list|,
name|XrmValuePtr
name|value
parameter_list|)
else|#
directive|else
function|void XrmPutResource
parameter_list|(
name|pdb
parameter_list|,
name|specifier
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|)
name|XrmDatabase
modifier|*
name|pdb
decl_stmt|;
name|char
modifier|*
name|specifier
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|XrmValuePtr
name|value
decl_stmt|;
endif|#
directive|endif
block|{
name|XrmBinding
name|bindings
index|[
name|MAXDBDEPTH
operator|+
literal|1
index|]
decl_stmt|;
name|XrmQuark
name|quarks
index|[
name|MAXDBDEPTH
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|pdb
condition|)
operator|*
name|pdb
operator|=
name|NewDatabase
argument_list|()
expr_stmt|;
name|XrmStringToBindingQuarkList
argument_list|(
name|specifier
argument_list|,
name|bindings
argument_list|,
name|quarks
argument_list|)
expr_stmt|;
name|PutEntry
argument_list|(
operator|*
name|pdb
argument_list|,
name|bindings
argument_list|,
name|quarks
argument_list|,
name|XrmStringToQuark
argument_list|(
name|type
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|void
name|XrmQPutStringResource
parameter_list|(
name|XrmDatabase
modifier|*
name|pdb
parameter_list|,
name|XrmBindingList
name|bindings
parameter_list|,
name|XrmQuarkList
name|quarks
parameter_list|,
name|_Xconst
name|char
modifier|*
name|str
parameter_list|)
else|#
directive|else
function|void XrmQPutStringResource
parameter_list|(
name|pdb
parameter_list|,
name|bindings
parameter_list|,
name|quarks
parameter_list|,
name|str
parameter_list|)
name|XrmDatabase
modifier|*
name|pdb
decl_stmt|;
name|XrmBindingList
name|bindings
decl_stmt|;
name|XrmQuarkList
name|quarks
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
endif|#
directive|endif
block|{
name|XrmValue
name|value
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|pdb
condition|)
operator|*
name|pdb
operator|=
name|NewDatabase
argument_list|()
expr_stmt|;
name|value
operator|.
name|addr
operator|=
operator|(
name|XPointer
operator|)
name|str
expr_stmt|;
name|value
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
name|PutEntry
argument_list|(
operator|*
name|pdb
argument_list|,
name|bindings
argument_list|,
name|quarks
argument_list|,
name|XrmQString
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*	Function Name: GetDatabase  *	Description: Parses a string and stores it as a database.  *	Arguments: db - the database.  *                 str - a pointer to the string containing the database.  *                 filename - source filename, if any.  *                 doall - whether to do all lines or just one  */
end_comment

begin_comment
comment|/*  * This function is highly optimized to inline as much as possible.   * Be very careful with modifications, or simplifications, as they   * may adversely affect the performance.  *  * Chris Peterson, MIT X Consortium		5/17/90.  */
end_comment

begin_define
define|#
directive|define
name|LIST_SIZE
value|101
end_define

begin_define
define|#
directive|define
name|BUFFER_SIZE
value|100
end_define

begin_function_decl
specifier|static
name|void
name|GetIncludeFile
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|GetDatabase
parameter_list|(
name|db
parameter_list|,
name|str
parameter_list|,
name|filename
parameter_list|,
name|doall
parameter_list|)
name|XrmDatabase
name|db
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|Bool
name|doall
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|XrmBits
name|bits
init|=
literal|0
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|register
name|Signature
name|sig
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr_max
decl_stmt|;
specifier|register
name|XrmQuarkList
name|t_quarks
decl_stmt|;
specifier|register
name|XrmBindingList
name|t_bindings
decl_stmt|;
name|int
name|alloc_chars
init|=
name|BUFSIZ
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|value_str
decl_stmt|;
name|XrmQuark
name|quarks
index|[
name|LIST_SIZE
index|]
decl_stmt|;
name|XrmBinding
name|bindings
index|[
name|LIST_SIZE
index|]
decl_stmt|;
name|XrmValue
name|value
decl_stmt|;
name|Bool
name|only_pcs
decl_stmt|;
name|Bool
name|dolines
decl_stmt|;
if|if
condition|(
operator|!
name|db
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|value_str
operator|=
name|Xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|alloc_chars
argument_list|)
operator|)
condition|)
return|return;
call|(
modifier|*
name|db
operator|->
name|methods
operator|->
name|mbinit
call|)
argument_list|(
name|db
operator|->
name|mbstate
argument_list|)
expr_stmt|;
name|str
operator|--
expr_stmt|;
name|dolines
operator|=
name|True
expr_stmt|;
while|while
condition|(
operator|!
name|is_EOF
argument_list|(
name|bits
argument_list|)
operator|&&
name|dolines
condition|)
block|{
name|dolines
operator|=
name|doall
expr_stmt|;
comment|/* 	 * First: Remove extra whitespace.  	 */
do|do
block|{
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
do|while is_space
condition|(
name|bits
condition|)
do|;
comment|/* 	 * Ignore empty lines. 	 */
if|if
condition|(
name|is_EOL
argument_list|(
name|bits
argument_list|)
condition|)
continue|continue;
comment|/* start a new line. */
comment|/* 	 * Second: check the first character in a line to see if it is 	 * "!" signifying a comment, or "#" signifying a directive. 	 */
if|if
condition|(
name|c
operator|==
literal|'!'
condition|)
block|{
comment|/* Comment, spin to next newline */
while|while
condition|(
name|is_simple
argument_list|(
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
argument_list|)
condition|)
block|{}
if|if
condition|(
name|is_EOL
argument_list|(
name|bits
argument_list|)
condition|)
continue|continue;
while|while
condition|(
operator|!
name|is_EOL
argument_list|(
name|bits
operator|=
name|next_mbchar
argument_list|(
name|c
argument_list|,
name|len
argument_list|,
name|str
argument_list|)
argument_list|)
condition|)
block|{}
name|str
operator|--
expr_stmt|;
continue|continue;
comment|/* start a new line. */
block|}
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
comment|/* Directive */
comment|/* remove extra whitespace */
name|only_pcs
operator|=
name|True
expr_stmt|;
while|while
condition|(
name|is_space
argument_list|(
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
argument_list|)
condition|)
block|{}
empty_stmt|;
comment|/* only "include" directive is currently defined */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"include"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|str
operator|+=
operator|(
literal|7
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* remove extra whitespace */
while|while
condition|(
name|is_space
argument_list|(
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
argument_list|)
condition|)
block|{}
empty_stmt|;
comment|/* must have a starting " */
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|char
modifier|*
name|fname
init|=
name|str
operator|+
literal|1
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|only_pcs
condition|)
block|{
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_nonpcs
argument_list|(
name|bits
argument_list|)
condition|)
name|only_pcs
operator|=
name|False
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|only_pcs
condition|)
name|bits
operator|=
name|next_mbchar
argument_list|(
name|c
argument_list|,
name|len
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'"'
operator|&&
operator|!
name|is_EOL
argument_list|(
name|bits
argument_list|)
condition|)
do|;
comment|/* must have an ending " */
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|GetIncludeFile
argument_list|(
name|db
argument_list|,
name|filename
argument_list|,
name|fname
argument_list|,
name|str
operator|-
name|len
operator|-
name|fname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* spin to next newline */
if|if
condition|(
name|only_pcs
condition|)
block|{
while|while
condition|(
name|is_simple
argument_list|(
name|bits
argument_list|)
condition|)
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_EOL
argument_list|(
name|bits
argument_list|)
condition|)
continue|continue;
block|}
while|while
condition|(
operator|!
name|is_EOL
argument_list|(
name|bits
argument_list|)
condition|)
name|bits
operator|=
name|next_mbchar
argument_list|(
name|c
argument_list|,
name|len
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|--
expr_stmt|;
continue|continue;
comment|/* start a new line. */
block|}
comment|/* 	 * Third: loop through the LHS of the resource specification 	 * storing characters and converting this to a Quark. 	 * 	 * If the number of quarks is greater than LIST_SIZE - 1.  This 	 * function will trash your memory. 	 * 	 * If the length of any quark is larger than BUFSIZ this function 	 * will also trash memory. 	 */
name|t_bindings
operator|=
name|bindings
expr_stmt|;
name|t_quarks
operator|=
name|quarks
expr_stmt|;
name|sig
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|buffer
expr_stmt|;
operator|*
name|t_bindings
operator|=
name|XrmBindTightly
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|is_binding
argument_list|(
name|bits
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|is_EOQ
argument_list|(
name|bits
argument_list|)
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
name|sig
operator|=
operator|(
name|sig
operator|<<
literal|1
operator|)
operator|+
name|c
expr_stmt|;
comment|/* Compute the signature. */
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
operator|*
name|t_quarks
operator|++
operator|=
name|_XrmInternalStringToQuark
argument_list|(
name|buffer
argument_list|,
name|ptr
operator|-
name|buffer
argument_list|,
name|sig
argument_list|,
name|False
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_separator
argument_list|(
name|bits
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|is_space
argument_list|(
name|bits
argument_list|)
condition|)
break|break;
comment|/* Remove white space */
do|do
block|{
operator|*
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
name|sig
operator|=
operator|(
name|sig
operator|<<
literal|1
operator|)
operator|+
name|c
expr_stmt|;
comment|/* Compute the signature. */
block|}
do|while
condition|(
name|is_space
argument_list|(
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
argument_list|)
condition|)
do|;
comment|/*  		     * The spec doesn't permit it, but support spaces 		     * internal to resource name/class  		     */
if|if
condition|(
name|is_separator
argument_list|(
name|bits
argument_list|)
condition|)
break|break;
name|t_quarks
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
operator|*
operator|(
operator|++
name|t_bindings
operator|)
operator|=
name|XrmBindTightly
expr_stmt|;
else|else
operator|*
operator|(
operator|++
name|t_bindings
operator|)
operator|=
name|XrmBindLoosely
expr_stmt|;
name|sig
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|buffer
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Magic unspecified feature #254. 		 * 		 * If two separators appear with no Text between them then 		 * ignore them. 		 * 		 * If anyone of those separators is a '*' then the binding  		 * will be loose, otherwise it will be tight. 		 */
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
operator|*
name|t_bindings
operator|=
name|XrmBindLoosely
expr_stmt|;
block|}
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
operator|*
name|t_quarks
operator|=
name|NULLQUARK
expr_stmt|;
comment|/* 	 * Make sure that there is a ':' in this line. 	 */
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
block|{
name|char
name|oldc
decl_stmt|;
comment|/* 	     * A parsing error has occured, toss everything on the line 	     * a new_line can still be escaped with a '\'. 	     */
while|while
condition|(
name|is_normal
argument_list|(
name|bits
argument_list|)
condition|)
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_EOL
argument_list|(
name|bits
argument_list|)
condition|)
continue|continue;
name|bits
operator|=
name|next_mbchar
argument_list|(
name|c
argument_list|,
name|len
argument_list|,
name|str
argument_list|)
expr_stmt|;
do|do
block|{
name|oldc
operator|=
name|c
expr_stmt|;
name|bits
operator|=
name|next_mbchar
argument_list|(
name|c
argument_list|,
name|len
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|||
name|oldc
operator|==
literal|'\\'
operator|)
condition|)
do|;
name|str
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * I now have a quark and binding list for the entire left hand 	 * side.  "c" currently points to the ":" separating the left hand 	 * side for the right hand side.  It is time to begin processing 	 * the right hand side. 	 */
comment|/*  	 * Fourth: Remove more whitespace 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|is_space
argument_list|(
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
break|break;
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
name|str
operator|--
expr_stmt|;
name|bits
operator|=
name|BSLASH
expr_stmt|;
name|c
operator|=
literal|'\\'
expr_stmt|;
break|break;
block|}
comment|/*  	 * Fifth: Process the right hand side. 	 */
name|ptr
operator|=
name|value_str
expr_stmt|;
name|ptr_max
operator|=
name|ptr
operator|+
name|alloc_chars
operator|-
literal|4
expr_stmt|;
name|only_pcs
operator|=
name|True
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	     * Tight loop for the normal case:  Non backslash, non-end of value 	     * character that will fit into the allocated buffer. 	     */
if|if
condition|(
name|only_pcs
condition|)
block|{
while|while
condition|(
name|is_normal
argument_list|(
name|bits
argument_list|)
operator|&&
name|ptr
operator|<
name|ptr_max
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_EOL
argument_list|(
name|bits
argument_list|)
condition|)
break|break;
if|if
condition|(
name|is_nonpcs
argument_list|(
name|bits
argument_list|)
condition|)
block|{
name|only_pcs
operator|=
name|False
expr_stmt|;
name|bits
operator|=
name|next_mbchar
argument_list|(
name|c
argument_list|,
name|len
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|is_special
argument_list|(
name|bits
argument_list|)
operator|&&
name|ptr
operator|+
name|len
operator|<=
name|ptr_max
condition|)
block|{
name|len
operator|=
operator|-
name|len
expr_stmt|;
while|while
condition|(
name|len
condition|)
operator|*
name|ptr
operator|++
operator|=
name|str
index|[
name|len
operator|++
index|]
expr_stmt|;
name|bits
operator|=
name|next_mbchar
argument_list|(
name|c
argument_list|,
name|len
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_EOL
argument_list|(
name|bits
argument_list|)
condition|)
block|{
name|str
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* 		 * We need to do some magic after a backslash. 		 */
if|if
condition|(
name|only_pcs
condition|)
block|{
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_nonpcs
argument_list|(
name|bits
argument_list|)
condition|)
name|only_pcs
operator|=
name|False
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|only_pcs
condition|)
name|bits
operator|=
name|next_mbchar
argument_list|(
name|c
argument_list|,
name|len
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_EOL
argument_list|(
name|bits
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_EOF
argument_list|(
name|bits
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
block|{
comment|/* 		     * "\n" means insert a newline. 		     */
operator|*
name|ptr
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* 		     * "\\" completes to just one backslash. 		     */
operator|*
name|ptr
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * pick up to three octal digits after the '\'. 		     */
name|char
name|temp
index|[
literal|3
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|is_odigit
argument_list|(
name|bits
argument_list|)
operator|&&
name|count
operator|<
literal|3
condition|)
block|{
name|temp
index|[
name|count
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|only_pcs
condition|)
block|{
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_nonpcs
argument_list|(
name|bits
argument_list|)
condition|)
name|only_pcs
operator|=
name|False
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|only_pcs
condition|)
name|bits
operator|=
name|next_mbchar
argument_list|(
name|c
argument_list|,
name|len
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
comment|/* 		     * If we found three digits then insert that octal code 		     * into the value string as a character. 		     */
if|if
condition|(
name|count
operator|==
literal|3
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|temp
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|0100
operator|+
operator|(
name|temp
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|010
operator|+
operator|(
name|temp
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|tcount
decl_stmt|;
comment|/*  			 * Otherwise just insert those characters into the  			 * string, since no special processing is needed on 			 * numerics we can skip the special processing. 			 */
for|for
control|(
name|tcount
operator|=
literal|0
init|;
name|tcount
operator|<
name|count
condition|;
name|tcount
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|temp
index|[
name|tcount
index|]
expr_stmt|;
comment|/* print them in 						      the correct order */
block|}
block|}
continue|continue;
block|}
if|if
condition|(
name|only_pcs
condition|)
block|{
name|bits
operator|=
name|next_char
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_nonpcs
argument_list|(
name|bits
argument_list|)
condition|)
name|only_pcs
operator|=
name|False
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|only_pcs
condition|)
name|bits
operator|=
name|next_mbchar
argument_list|(
name|c
argument_list|,
name|len
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
comment|/*  	     * It is important to make sure that there is room for at least 	     * four more characters in the buffer, since I can add that 	     * many characters into the buffer after a backslash has occured. 	     */
if|if
condition|(
name|ptr
operator|+
name|len
operator|>
name|ptr_max
condition|)
block|{
name|char
modifier|*
name|temp_str
decl_stmt|;
name|alloc_chars
operator|+=
name|BUFSIZ
operator|/
literal|10
expr_stmt|;
name|temp_str
operator|=
name|Xrealloc
argument_list|(
name|value_str
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|alloc_chars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp_str
condition|)
block|{
name|Xfree
argument_list|(
name|value_str
argument_list|)
expr_stmt|;
call|(
modifier|*
name|db
operator|->
name|methods
operator|->
name|mbfinish
call|)
argument_list|(
name|db
operator|->
name|mbstate
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
name|temp_str
operator|+
operator|(
name|ptr
operator|-
name|value_str
operator|)
expr_stmt|;
comment|/* reset pointer. */
name|value_str
operator|=
name|temp_str
expr_stmt|;
name|ptr_max
operator|=
name|value_str
operator|+
name|alloc_chars
operator|-
literal|4
expr_stmt|;
block|}
block|}
comment|/* 	 * Lastly: Terminate the value string, and store this entry  	 * 	   into the database. 	 */
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Store it in database */
name|value
operator|.
name|size
operator|=
name|ptr
operator|-
name|value_str
expr_stmt|;
name|value
operator|.
name|addr
operator|=
operator|(
name|XPointer
operator|)
name|value_str
expr_stmt|;
name|PutEntry
argument_list|(
name|db
argument_list|,
name|bindings
argument_list|,
name|quarks
argument_list|,
name|XrmQString
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
name|Xfree
argument_list|(
name|value_str
argument_list|)
expr_stmt|;
call|(
modifier|*
name|db
operator|->
name|methods
operator|->
name|mbfinish
call|)
argument_list|(
name|db
operator|->
name|mbstate
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|void
name|XrmPutStringResource
parameter_list|(
name|XrmDatabase
modifier|*
name|pdb
parameter_list|,
name|_Xconst
name|char
modifier|*
name|specifier
parameter_list|,
name|_Xconst
name|char
modifier|*
name|str
parameter_list|)
else|#
directive|else
function|void XrmPutStringResource
parameter_list|(
name|pdb
parameter_list|,
name|specifier
parameter_list|,
name|str
parameter_list|)
name|XrmDatabase
modifier|*
name|pdb
decl_stmt|;
name|char
modifier|*
name|specifier
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
endif|#
directive|endif
block|{
name|XrmValue
name|value
decl_stmt|;
name|XrmBinding
name|bindings
index|[
name|MAXDBDEPTH
operator|+
literal|1
index|]
decl_stmt|;
name|XrmQuark
name|quarks
index|[
name|MAXDBDEPTH
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|pdb
condition|)
operator|*
name|pdb
operator|=
name|NewDatabase
argument_list|()
expr_stmt|;
name|XrmStringToBindingQuarkList
argument_list|(
name|specifier
argument_list|,
name|bindings
argument_list|,
name|quarks
argument_list|)
expr_stmt|;
name|value
operator|.
name|addr
operator|=
operator|(
name|XPointer
operator|)
name|str
expr_stmt|;
name|value
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
name|PutEntry
argument_list|(
operator|*
name|pdb
argument_list|,
name|bindings
argument_list|,
name|quarks
argument_list|,
name|XrmQString
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|void
name|XrmPutLineResource
parameter_list|(
name|XrmDatabase
modifier|*
name|pdb
parameter_list|,
name|_Xconst
name|char
modifier|*
name|line
parameter_list|)
else|#
directive|else
function|void XrmPutLineResource
parameter_list|(
name|pdb
parameter_list|,
name|line
parameter_list|)
name|XrmDatabase
modifier|*
name|pdb
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
operator|*
name|pdb
condition|)
operator|*
name|pdb
operator|=
name|NewDatabase
argument_list|()
expr_stmt|;
name|GetDatabase
argument_list|(
operator|*
name|pdb
argument_list|,
name|line
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|False
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|XrmDatabase
name|XrmGetStringDatabase
parameter_list|(
name|_Xconst
name|char
modifier|*
name|data
parameter_list|)
else|#
directive|else
function|XrmDatabase XrmGetStringDatabase
parameter_list|(
name|data
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
endif|#
directive|endif
block|{
name|XrmDatabase
name|db
decl_stmt|;
name|db
operator|=
name|NewDatabase
argument_list|()
expr_stmt|;
name|GetDatabase
argument_list|(
name|db
argument_list|,
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|True
argument_list|)
expr_stmt|;
return|return
name|db
return|;
block|}
end_function

begin_comment
comment|/*	Function Name: ReadInFile  *	Description: Reads the file into a buffer.  *	Arguments: filename - the name of the file.  *	Returns: An allocated string containing the contents of the file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ReadInFile
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|,
name|size
decl_stmt|;
name|char
modifier|*
name|filebuf
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|OpenFile
argument_list|(
name|filename
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
name|GetSizeOfFile
argument_list|(
name|filename
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|filebuf
operator|=
name|Xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
comment|/* leave room for '\0' */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
if|if
condition|(
name|ReadFile
argument_list|(
name|fd
argument_list|,
name|filebuf
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
block|{
comment|/* If we didn't read the 						  correct number of bytes. */
name|CloseFile
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
name|CloseFile
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|filebuf
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* NULL terminate it. */
return|return
name|filebuf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|GetIncludeFile
parameter_list|(
name|db
parameter_list|,
name|base
parameter_list|,
name|fname
parameter_list|,
name|fnamelen
parameter_list|)
name|XrmDatabase
name|db
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|fnamelen
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
name|realfname
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|fnamelen
operator|<=
literal|0
operator|||
name|fnamelen
operator|>=
name|BUFSIZ
condition|)
return|return;
if|if
condition|(
operator|*
name|fname
operator|!=
literal|'/'
operator|&&
name|base
operator|&&
operator|(
name|str
operator|=
name|rindex
argument_list|(
name|base
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
name|len
operator|=
name|str
operator|-
name|base
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|fnamelen
operator|>=
name|BUFSIZ
condition|)
return|return;
name|strncpy
argument_list|(
name|realfname
argument_list|,
name|base
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|realfname
operator|+
name|len
argument_list|,
name|fname
argument_list|,
name|fnamelen
argument_list|)
expr_stmt|;
name|realfname
index|[
name|len
operator|+
name|fnamelen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|realfname
argument_list|,
name|fname
argument_list|,
name|fnamelen
argument_list|)
expr_stmt|;
name|realfname
index|[
name|fnamelen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|str
operator|=
name|ReadInFile
argument_list|(
name|realfname
argument_list|)
operator|)
condition|)
return|return;
name|GetDatabase
argument_list|(
name|db
argument_list|,
name|str
argument_list|,
name|realfname
argument_list|,
name|True
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|XrmDatabase
name|XrmGetFileDatabase
parameter_list|(
name|_Xconst
name|char
modifier|*
name|filename
parameter_list|)
else|#
directive|else
function|XrmDatabase XrmGetFileDatabase
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
endif|#
directive|endif
block|{
name|XrmDatabase
name|db
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|str
operator|=
name|ReadInFile
argument_list|(
name|filename
argument_list|)
operator|)
condition|)
return|return
operator|(
name|XrmDatabase
operator|)
name|NULL
return|;
name|db
operator|=
name|NewDatabase
argument_list|()
expr_stmt|;
name|GetDatabase
argument_list|(
name|db
argument_list|,
name|str
argument_list|,
name|filename
argument_list|,
name|True
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|db
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|Status
name|XrmCombineFileDatabase
parameter_list|(
name|_Xconst
name|char
modifier|*
name|filename
parameter_list|,
name|XrmDatabase
modifier|*
name|target
parameter_list|,
name|Bool
name|override
parameter_list|)
else|#
directive|else
function|Status XrmCombineFileDatabase
parameter_list|(
name|filename
parameter_list|,
name|target
parameter_list|,
name|override
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|XrmDatabase
modifier|*
name|target
decl_stmt|;
name|Bool
name|override
decl_stmt|;
endif|#
directive|endif
block|{
name|XrmDatabase
name|db
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|str
operator|=
name|ReadInFile
argument_list|(
name|filename
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|override
condition|)
block|{
name|db
operator|=
operator|*
name|target
expr_stmt|;
if|if
condition|(
operator|!
name|db
condition|)
operator|*
name|target
operator|=
name|db
operator|=
name|NewDatabase
argument_list|()
expr_stmt|;
block|}
else|else
name|db
operator|=
name|NewDatabase
argument_list|()
expr_stmt|;
name|GetDatabase
argument_list|(
name|db
argument_list|,
name|str
argument_list|,
name|filename
argument_list|,
name|True
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|override
condition|)
name|XrmCombineDatabase
argument_list|(
name|db
argument_list|,
name|target
argument_list|,
name|False
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* call the user proc for every value in the table, arbitrary order.  * stop if user proc returns True.  level is current depth in database.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|Bool
name|EnumLTable
parameter_list|(
name|table
parameter_list|,
name|names
parameter_list|,
name|classes
parameter_list|,
name|level
parameter_list|,
name|closure
parameter_list|)
name|LTable
name|table
decl_stmt|;
name|XrmNameList
name|names
decl_stmt|;
name|XrmClassList
name|classes
decl_stmt|;
specifier|register
name|int
name|level
decl_stmt|;
specifier|register
name|EClosure
name|closure
decl_stmt|;
block|{
specifier|register
name|VEntry
modifier|*
name|bucket
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|VEntry
name|entry
decl_stmt|;
name|XrmValue
name|value
decl_stmt|;
name|XrmRepresentation
name|type
decl_stmt|;
name|Bool
name|tightOk
decl_stmt|;
name|closure
operator|->
name|bindings
index|[
name|level
index|]
operator|=
operator|(
name|table
operator|->
name|table
operator|.
name|tight
condition|?
name|XrmBindTightly
else|:
name|XrmBindLoosely
operator|)
expr_stmt|;
name|closure
operator|->
name|quarks
index|[
name|level
index|]
operator|=
name|table
operator|->
name|table
operator|.
name|name
expr_stmt|;
name|level
operator|++
expr_stmt|;
name|tightOk
operator|=
operator|!
operator|*
name|names
expr_stmt|;
name|closure
operator|->
name|quarks
index|[
name|level
operator|+
literal|1
index|]
operator|=
name|NULLQUARK
expr_stmt|;
for|for
control|(
name|i
operator|=
name|table
operator|->
name|table
operator|.
name|mask
operator|,
name|bucket
operator|=
name|table
operator|->
name|buckets
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|bucket
operator|++
control|)
block|{
for|for
control|(
name|entry
operator|=
operator|*
name|bucket
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|tight
operator|&&
operator|!
name|tightOk
condition|)
continue|continue;
name|closure
operator|->
name|bindings
index|[
name|level
index|]
operator|=
operator|(
name|entry
operator|->
name|tight
condition|?
name|XrmBindTightly
else|:
name|XrmBindLoosely
operator|)
expr_stmt|;
name|closure
operator|->
name|quarks
index|[
name|level
index|]
operator|=
name|entry
operator|->
name|name
expr_stmt|;
name|value
operator|.
name|size
operator|=
name|entry
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|string
condition|)
block|{
name|type
operator|=
name|XrmQString
expr_stmt|;
name|value
operator|.
name|addr
operator|=
name|StringValue
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|RepType
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|value
operator|.
name|addr
operator|=
name|DataValue
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
call|(
modifier|*
name|closure
operator|->
name|proc
call|)
argument_list|(
operator|&
name|closure
operator|->
name|db
argument_list|,
name|closure
operator|->
name|bindings
operator|+
literal|1
argument_list|,
name|closure
operator|->
name|quarks
operator|+
literal|1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|value
argument_list|,
name|closure
operator|->
name|closure
argument_list|)
condition|)
return|return
name|True
return|;
block|}
block|}
return|return
name|False
return|;
block|}
end_function

begin_function
specifier|static
name|Bool
name|EnumAllNTable
parameter_list|(
name|table
parameter_list|,
name|level
parameter_list|,
name|closure
parameter_list|)
name|NTable
name|table
decl_stmt|;
specifier|register
name|int
name|level
decl_stmt|;
specifier|register
name|EClosure
name|closure
decl_stmt|;
block|{
specifier|register
name|NTable
modifier|*
name|bucket
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|NTable
name|entry
decl_stmt|;
name|XrmQuark
name|empty
init|=
name|NULLQUARK
decl_stmt|;
if|if
condition|(
name|level
operator|>=
name|MAXDBDEPTH
condition|)
return|return
name|False
return|;
for|for
control|(
name|i
operator|=
name|table
operator|->
name|mask
operator|,
name|bucket
operator|=
name|NodeBuckets
argument_list|(
name|table
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|bucket
operator|++
control|)
block|{
for|for
control|(
name|entry
operator|=
operator|*
name|bucket
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|leaf
condition|)
block|{
if|if
condition|(
name|EnumLTable
argument_list|(
operator|(
name|LTable
operator|)
name|entry
argument_list|,
operator|&
name|empty
argument_list|,
operator|&
name|empty
argument_list|,
name|level
argument_list|,
name|closure
argument_list|)
condition|)
return|return
name|True
return|;
block|}
else|else
block|{
name|closure
operator|->
name|bindings
index|[
name|level
index|]
operator|=
operator|(
name|entry
operator|->
name|tight
condition|?
name|XrmBindTightly
else|:
name|XrmBindLoosely
operator|)
expr_stmt|;
name|closure
operator|->
name|quarks
index|[
name|level
index|]
operator|=
name|entry
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|EnumAllNTable
argument_list|(
name|entry
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|closure
argument_list|)
condition|)
return|return
name|True
return|;
block|}
block|}
block|}
return|return
name|False
return|;
block|}
end_function

begin_comment
comment|/* recurse on every table in the table, arbitrary order.  * stop if user proc returns True.  level is current depth in database.  */
end_comment

begin_function
specifier|static
name|Bool
name|EnumNTable
parameter_list|(
name|table
parameter_list|,
name|names
parameter_list|,
name|classes
parameter_list|,
name|level
parameter_list|,
name|closure
parameter_list|)
name|NTable
name|table
decl_stmt|;
name|XrmNameList
name|names
decl_stmt|;
name|XrmClassList
name|classes
decl_stmt|;
specifier|register
name|int
name|level
decl_stmt|;
specifier|register
name|EClosure
name|closure
decl_stmt|;
block|{
specifier|register
name|NTable
name|entry
decl_stmt|;
specifier|register
name|XrmQuark
name|q
decl_stmt|;
specifier|register
name|unsigned
name|int
name|leaf
decl_stmt|;
name|Bool
function_decl|(
modifier|*
name|get
function_decl|)
parameter_list|()
function_decl|;
name|Bool
name|bilevel
decl_stmt|;
comment|/* find entries named ename, leafness leaf, tight or loose, and call get */
define|#
directive|define
name|ITIGHTLOOSE
parameter_list|(
name|ename
parameter_list|)
define|\
value|NFIND(ename); \     if (entry) { \ 	if (leaf == entry->leaf) { \ 	    if (!leaf&& !entry->tight&& entry->next&& \ 		entry->next->name == q&& entry->next->tight&& \ 		(bilevel || entry->next->hasloose)&& \ 		EnumLTable((LTable)entry->next, names+1, classes+1, \ 			   level, closure)) \ 		return True; \ 	    if ((*get)(entry, names+1, classes+1, level, closure)) \ 		return True; \ 	    if (entry->tight&& (entry = entry->next)&& \ 		entry->name == q&& leaf == entry->leaf&& \ 		(*get)(entry, names+1, classes+1, level, closure)) \ 		return True; \ 	} else if (entry->leaf) { \ 	    if ((bilevel || entry->hasloose)&& \ 		EnumLTable((LTable)entry, names+1, classes+1, level, closure))\ 		return True; \ 	    if (entry->tight&& (entry = entry->next)&& \ 		entry->name == q&& (bilevel || entry->hasloose)&& \ 		EnumLTable((LTable)entry, names+1, classes+1, level, closure))\ 		return True; \ 	} \     }
comment|/* find entries named ename, leafness leaf, loose only, and call get */
define|#
directive|define
name|ILOOSE
parameter_list|(
name|ename
parameter_list|)
define|\
value|NFIND(ename); \     if (entry&& entry->tight&& (entry = entry->next)&& entry->name != q) \ 	entry = (NTable)NULL; \     if (entry) { \ 	if (leaf == entry->leaf) { \ 	    if ((*get)(entry, names+1, classes+1, level, closure)) \ 		return True; \ 	} else if (entry->leaf&& (bilevel || entry->hasloose)) { \ 	    if (EnumLTable((LTable)entry, names+1, classes+1, level, closure))\ 		return True; \ 	} \     }
if|if
condition|(
name|level
operator|>=
name|MAXDBDEPTH
condition|)
return|return
name|False
return|;
name|closure
operator|->
name|bindings
index|[
name|level
index|]
operator|=
operator|(
name|table
operator|->
name|tight
condition|?
name|XrmBindTightly
else|:
name|XrmBindLoosely
operator|)
expr_stmt|;
name|closure
operator|->
name|quarks
index|[
name|level
index|]
operator|=
name|table
operator|->
name|name
expr_stmt|;
name|level
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|names
condition|)
block|{
if|if
condition|(
name|EnumAllNTable
argument_list|(
name|table
argument_list|,
name|level
argument_list|,
name|closure
argument_list|)
condition|)
return|return
name|True
return|;
block|}
else|else
block|{
if|if
condition|(
name|names
index|[
literal|1
index|]
operator|||
name|closure
operator|->
name|mode
operator|==
name|XrmEnumAllLevels
condition|)
block|{
name|get
operator|=
name|EnumNTable
expr_stmt|;
comment|/* recurse */
name|leaf
operator|=
literal|0
expr_stmt|;
name|bilevel
operator|=
operator|!
name|names
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|get
operator|=
name|EnumLTable
expr_stmt|;
comment|/* bottom of recursion */
name|leaf
operator|=
literal|1
expr_stmt|;
name|bilevel
operator|=
name|False
expr_stmt|;
block|}
if|if
condition|(
name|table
operator|->
name|hasloose
operator|&&
name|closure
operator|->
name|mode
operator|==
name|XrmEnumAllLevels
condition|)
block|{
name|NTable
modifier|*
name|bucket
decl_stmt|;
name|int
name|i
decl_stmt|;
name|XrmQuark
name|empty
init|=
name|NULLQUARK
decl_stmt|;
for|for
control|(
name|i
operator|=
name|table
operator|->
name|mask
operator|,
name|bucket
operator|=
name|NodeBuckets
argument_list|(
name|table
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|bucket
operator|++
control|)
block|{
name|q
operator|=
name|NULLQUARK
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|*
name|bucket
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|entry
operator|->
name|tight
operator|&&
name|entry
operator|->
name|name
operator|!=
name|q
operator|&&
name|entry
operator|->
name|name
operator|!=
operator|*
name|names
operator|&&
name|entry
operator|->
name|name
operator|!=
operator|*
name|classes
condition|)
block|{
name|q
operator|=
name|entry
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|leaf
condition|)
block|{
if|if
condition|(
name|EnumLTable
argument_list|(
operator|(
name|LTable
operator|)
name|entry
argument_list|,
operator|&
name|empty
argument_list|,
operator|&
name|empty
argument_list|,
name|level
argument_list|,
name|closure
argument_list|)
condition|)
return|return
name|True
return|;
block|}
else|else
block|{
if|if
condition|(
name|EnumNTable
argument_list|(
name|entry
argument_list|,
operator|&
name|empty
argument_list|,
operator|&
name|empty
argument_list|,
name|level
argument_list|,
name|closure
argument_list|)
condition|)
return|return
name|True
return|;
block|}
block|}
block|}
block|}
block|}
name|ITIGHTLOOSE
argument_list|(
operator|*
name|names
argument_list|)
expr_stmt|;
comment|/* do name, tight and loose */
name|ITIGHTLOOSE
argument_list|(
operator|*
name|classes
argument_list|)
expr_stmt|;
comment|/* do class, tight and loose */
if|if
condition|(
name|table
operator|->
name|hasany
condition|)
block|{
name|ITIGHTLOOSE
argument_list|(
name|XrmQANY
argument_list|)
expr_stmt|;
comment|/* do ANY, tight and loose */
block|}
if|if
condition|(
name|table
operator|->
name|hasloose
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|names
operator|++
expr_stmt|;
name|classes
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|names
condition|)
break|break;
if|if
condition|(
operator|!
name|names
index|[
literal|1
index|]
operator|&&
name|closure
operator|->
name|mode
operator|!=
name|XrmEnumAllLevels
condition|)
block|{
name|get
operator|=
name|EnumLTable
expr_stmt|;
comment|/* bottom of recursion */
name|leaf
operator|=
literal|1
expr_stmt|;
block|}
name|ILOOSE
argument_list|(
operator|*
name|names
argument_list|)
expr_stmt|;
comment|/* loose names */
name|ILOOSE
argument_list|(
operator|*
name|classes
argument_list|)
expr_stmt|;
comment|/* loose classes */
if|if
condition|(
name|table
operator|->
name|hasany
condition|)
block|{
name|ILOOSE
argument_list|(
name|XrmQANY
argument_list|)
expr_stmt|;
comment|/* loose ANY */
block|}
block|}
name|names
operator|--
expr_stmt|;
name|classes
operator|--
expr_stmt|;
block|}
block|}
comment|/* now look for matching leaf nodes */
name|entry
operator|=
name|table
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
return|return
name|False
return|;
if|if
condition|(
name|entry
operator|->
name|leaf
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|tight
operator|&&
operator|!
name|table
operator|->
name|tight
condition|)
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|||
operator|!
name|entry
operator|->
name|tight
condition|)
return|return
name|False
return|;
block|}
if|if
condition|(
operator|!
name|entry
operator|||
name|entry
operator|->
name|name
operator|!=
name|table
operator|->
name|name
condition|)
return|return
name|False
return|;
comment|/* found one */
name|level
operator|--
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|*
name|names
operator|||
name|entry
operator|->
name|hasloose
operator|)
operator|&&
name|EnumLTable
argument_list|(
operator|(
name|LTable
operator|)
name|entry
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
name|level
argument_list|,
name|closure
argument_list|)
condition|)
return|return
name|True
return|;
if|if
condition|(
name|entry
operator|->
name|tight
operator|&&
name|entry
operator|==
name|table
operator|->
name|next
operator|&&
operator|(
name|entry
operator|=
name|entry
operator|->
name|next
operator|)
operator|&&
name|entry
operator|->
name|name
operator|==
name|table
operator|->
name|name
operator|&&
operator|(
operator|!
operator|*
name|names
operator|||
name|entry
operator|->
name|hasloose
operator|)
condition|)
return|return
name|EnumLTable
argument_list|(
operator|(
name|LTable
operator|)
name|entry
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
name|level
argument_list|,
name|closure
argument_list|)
return|;
return|return
name|False
return|;
undef|#
directive|undef
name|ITIGHTLOOSE
undef|#
directive|undef
name|ILOOSE
block|}
end_function

begin_comment
comment|/* call the proc for every value in the database, arbitrary order.  * stop if the proc returns True.  */
end_comment

begin_function
name|Bool
name|XrmEnumerateDatabase
parameter_list|(
name|db
parameter_list|,
name|names
parameter_list|,
name|classes
parameter_list|,
name|mode
parameter_list|,
name|proc
parameter_list|,
name|closure
parameter_list|)
name|XrmDatabase
name|db
decl_stmt|;
name|XrmNameList
name|names
decl_stmt|;
name|XrmClassList
name|classes
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|DBEnumProc
name|proc
decl_stmt|;
name|XPointer
name|closure
decl_stmt|;
block|{
name|XrmBinding
name|bindings
index|[
name|MAXDBDEPTH
operator|+
literal|2
index|]
decl_stmt|;
name|XrmQuark
name|quarks
index|[
name|MAXDBDEPTH
operator|+
literal|2
index|]
decl_stmt|;
specifier|register
name|NTable
name|table
decl_stmt|;
name|EClosureRec
name|eclosure
decl_stmt|;
if|if
condition|(
operator|!
name|db
condition|)
return|return
name|False
return|;
name|eclosure
operator|.
name|db
operator|=
name|db
expr_stmt|;
name|eclosure
operator|.
name|proc
operator|=
name|proc
expr_stmt|;
name|eclosure
operator|.
name|closure
operator|=
name|closure
expr_stmt|;
name|eclosure
operator|.
name|bindings
operator|=
name|bindings
expr_stmt|;
name|eclosure
operator|.
name|quarks
operator|=
name|quarks
expr_stmt|;
name|eclosure
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|table
operator|=
name|db
operator|->
name|table
expr_stmt|;
if|if
condition|(
name|table
operator|&&
operator|!
name|table
operator|->
name|leaf
operator|&&
operator|!
operator|*
name|names
operator|&&
name|mode
operator|==
name|XrmEnumOneLevel
condition|)
name|table
operator|=
name|table
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|table
condition|)
block|{
if|if
condition|(
operator|!
name|table
operator|->
name|leaf
condition|)
return|return
name|EnumNTable
argument_list|(
name|table
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
literal|0
argument_list|,
operator|&
name|eclosure
argument_list|)
return|;
else|else
return|return
name|EnumLTable
argument_list|(
operator|(
name|LTable
operator|)
name|table
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
literal|0
argument_list|,
operator|&
name|eclosure
argument_list|)
return|;
block|}
return|return
name|False
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|PrintBindingQuarkList
parameter_list|(
name|bindings
parameter_list|,
name|quarks
parameter_list|,
name|stream
parameter_list|)
name|XrmBindingList
name|bindings
decl_stmt|;
name|XrmQuarkList
name|quarks
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|Bool
name|firstNameSeen
decl_stmt|;
for|for
control|(
name|firstNameSeen
operator|=
name|False
init|;
operator|*
name|quarks
condition|;
name|bindings
operator|++
operator|,
name|quarks
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bindings
operator|==
name|XrmBindLoosely
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|firstNameSeen
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
name|firstNameSeen
operator|=
name|True
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|XrmQuarkToString
argument_list|(
operator|*
name|quarks
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* output out the entry in correct file syntax */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|Bool
name|DumpEntry
parameter_list|(
name|db
parameter_list|,
name|bindings
parameter_list|,
name|quarks
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|,
name|data
parameter_list|)
name|XrmDatabase
modifier|*
name|db
decl_stmt|;
name|XrmBindingList
name|bindings
decl_stmt|;
name|XrmQuarkList
name|quarks
decl_stmt|;
name|XrmRepresentation
modifier|*
name|type
decl_stmt|;
name|XrmValuePtr
name|value
decl_stmt|;
name|XPointer
name|data
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
init|=
operator|(
name|FILE
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|type
operator|!=
name|XrmQString
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'!'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|PrintBindingQuarkList
argument_list|(
name|bindings
argument_list|,
name|quarks
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|s
operator|=
name|value
operator|->
name|addr
expr_stmt|;
name|i
operator|=
name|value
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|*
name|type
operator|==
name|XrmQString
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|":\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|i
operator|--
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"=%s:\t"
argument_list|,
name|XrmRepresentationToString
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
operator|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|)
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* preserve leading whitespace */
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|i
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\\n\\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\\\\"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|<
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|)
operator|||
operator|(
operator|(
name|unsigned
name|char
operator|)
name|c
operator|>=
literal|0x7f
operator|&&
operator|(
name|unsigned
name|char
operator|)
name|c
operator|<
literal|0xa0
operator|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|putc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return
name|False
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|PrintTable
parameter_list|(
name|table
parameter_list|,
name|file
parameter_list|)
name|NTable
name|table
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|XrmBinding
name|bindings
index|[
name|MAXDBDEPTH
operator|+
literal|1
index|]
decl_stmt|;
name|XrmQuark
name|quarks
index|[
name|MAXDBDEPTH
operator|+
literal|1
index|]
decl_stmt|;
name|EClosureRec
name|closure
decl_stmt|;
name|XrmQuark
name|empty
init|=
name|NULLQUARK
decl_stmt|;
name|closure
operator|.
name|db
operator|=
operator|(
name|XrmDatabase
operator|)
name|NULL
expr_stmt|;
name|closure
operator|.
name|proc
operator|=
name|DumpEntry
expr_stmt|;
name|closure
operator|.
name|closure
operator|=
operator|(
name|XPointer
operator|)
name|file
expr_stmt|;
name|closure
operator|.
name|bindings
operator|=
name|bindings
expr_stmt|;
name|closure
operator|.
name|quarks
operator|=
name|quarks
expr_stmt|;
name|closure
operator|.
name|mode
operator|=
name|XrmEnumAllLevels
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|leaf
condition|)
name|EnumLTable
argument_list|(
operator|(
name|LTable
operator|)
name|table
argument_list|,
operator|&
name|empty
argument_list|,
operator|&
name|empty
argument_list|,
literal|0
argument_list|,
operator|&
name|closure
argument_list|)
expr_stmt|;
else|else
name|EnumNTable
argument_list|(
name|table
argument_list|,
operator|&
name|empty
argument_list|,
operator|&
name|empty
argument_list|,
literal|0
argument_list|,
operator|&
name|closure
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|void
name|XrmPutFileDatabase
parameter_list|(
name|XrmDatabase
name|db
parameter_list|,
name|_Xconst
name|char
modifier|*
name|fileName
parameter_list|)
else|#
directive|else
function|void XrmPutFileDatabase
parameter_list|(
name|db
parameter_list|,
name|fileName
parameter_list|)
name|XrmDatabase
name|db
decl_stmt|;
name|char
modifier|*
name|fileName
decl_stmt|;
endif|#
directive|endif
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|XrmQuark
name|empty
init|=
name|NULLQUARK
decl_stmt|;
if|if
condition|(
operator|!
name|db
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|file
operator|=
name|fopen
argument_list|(
name|fileName
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
return|return;
operator|(
name|void
operator|)
name|XrmEnumerateDatabase
argument_list|(
name|db
argument_list|,
operator|&
name|empty
argument_list|,
operator|&
name|empty
argument_list|,
name|XrmEnumAllLevels
argument_list|,
name|DumpEntry
argument_list|,
operator|(
name|XPointer
operator|)
name|file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* macros used in get/search functions */
end_comment

begin_comment
comment|/* find entries named ename, leafness leaf, tight or loose, and call get */
end_comment

begin_define
define|#
directive|define
name|GTIGHTLOOSE
parameter_list|(
name|ename
parameter_list|,
name|looseleaf
parameter_list|)
define|\
value|NFIND(ename); \     if (entry) { \ 	if (leaf == entry->leaf) { \ 	    if (!leaf&& !entry->tight&& entry->next&& \ 		entry->next->name == q&& entry->next->tight&& \ 		entry->next->hasloose&& \ 		looseleaf((LTable)entry->next, names+1, classes+1, closure)) \ 		return True; \ 	    if ((*get)(entry, names+1, classes+1, closure)) \ 		return True; \ 	    if (entry->tight&& (entry = entry->next)&& \ 		entry->name == q&& leaf == entry->leaf&& \ 		(*get)(entry, names+1, classes+1, closure)) \ 		return True; \ 	} else if (entry->leaf) { \ 	    if (entry->hasloose&& \ 		looseleaf((LTable)entry, names+1, classes+1, closure)) \ 		return True; \ 	    if (entry->tight&& (entry = entry->next)&& \ 		entry->name == q&& entry->hasloose&& \ 		looseleaf((LTable)entry, names+1, classes+1, closure)) \ 		return True; \ 	} \     }
end_define

begin_comment
comment|/* find entries named ename, leafness leaf, loose only, and call get */
end_comment

begin_define
define|#
directive|define
name|GLOOSE
parameter_list|(
name|ename
parameter_list|,
name|looseleaf
parameter_list|)
define|\
value|NFIND(ename); \     if (entry&& entry->tight&& (entry = entry->next)&& entry->name != q) \ 	entry = (NTable)NULL; \     if (entry) { \ 	if (leaf == entry->leaf) { \ 	    if ((*get)(entry, names+1, classes+1, closure)) \ 		return True; \ 	} else if (entry->leaf&& entry->hasloose) { \ 	    if (looseleaf((LTable)entry, names+1, classes+1, closure)) \ 		return True; \ 	} \     }
end_define

begin_comment
comment|/* add tight/loose entry to the search list, return True if list is full */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|Bool
name|AppendLEntry
parameter_list|(
name|table
parameter_list|,
name|names
parameter_list|,
name|classes
parameter_list|,
name|closure
parameter_list|)
name|LTable
name|table
decl_stmt|;
name|XrmNameList
name|names
decl_stmt|;
name|XrmClassList
name|classes
decl_stmt|;
specifier|register
name|SClosure
name|closure
decl_stmt|;
block|{
comment|/* check for duplicate */
if|if
condition|(
name|closure
operator|->
name|idx
operator|>=
literal|0
operator|&&
name|closure
operator|->
name|list
index|[
name|closure
operator|->
name|idx
index|]
operator|==
name|table
condition|)
return|return
name|False
return|;
if|if
condition|(
name|closure
operator|->
name|idx
operator|==
name|closure
operator|->
name|limit
condition|)
return|return
name|True
return|;
comment|/* append it */
name|closure
operator|->
name|idx
operator|++
expr_stmt|;
name|closure
operator|->
name|list
index|[
name|closure
operator|->
name|idx
index|]
operator|=
name|table
expr_stmt|;
return|return
name|False
return|;
block|}
end_function

begin_comment
comment|/* add loose entry to the search list, return True if list is full */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|Bool
name|AppendLooseLEntry
parameter_list|(
name|table
parameter_list|,
name|names
parameter_list|,
name|classes
parameter_list|,
name|closure
parameter_list|)
name|LTable
name|table
decl_stmt|;
name|XrmNameList
name|names
decl_stmt|;
name|XrmClassList
name|classes
decl_stmt|;
specifier|register
name|SClosure
name|closure
decl_stmt|;
block|{
comment|/* check for duplicate */
if|if
condition|(
name|closure
operator|->
name|idx
operator|>=
literal|0
operator|&&
name|closure
operator|->
name|list
index|[
name|closure
operator|->
name|idx
index|]
operator|==
name|table
condition|)
return|return
name|False
return|;
if|if
condition|(
name|closure
operator|->
name|idx
operator|>=
name|closure
operator|->
name|limit
operator|-
literal|1
condition|)
return|return
name|True
return|;
comment|/* append it */
name|closure
operator|->
name|idx
operator|++
expr_stmt|;
name|closure
operator|->
name|list
index|[
name|closure
operator|->
name|idx
index|]
operator|=
name|LOOSESEARCH
expr_stmt|;
name|closure
operator|->
name|idx
operator|++
expr_stmt|;
name|closure
operator|->
name|list
index|[
name|closure
operator|->
name|idx
index|]
operator|=
name|table
expr_stmt|;
return|return
name|False
return|;
block|}
end_function

begin_comment
comment|/* search for a leaf table */
end_comment

begin_function
specifier|static
name|Bool
name|SearchNEntry
parameter_list|(
name|table
parameter_list|,
name|names
parameter_list|,
name|classes
parameter_list|,
name|closure
parameter_list|)
name|NTable
name|table
decl_stmt|;
name|XrmNameList
name|names
decl_stmt|;
name|XrmClassList
name|classes
decl_stmt|;
name|SClosure
name|closure
decl_stmt|;
block|{
specifier|register
name|NTable
name|entry
decl_stmt|;
specifier|register
name|XrmQuark
name|q
decl_stmt|;
specifier|register
name|unsigned
name|int
name|leaf
decl_stmt|;
name|Bool
function_decl|(
modifier|*
name|get
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|names
index|[
literal|1
index|]
condition|)
block|{
name|get
operator|=
name|SearchNEntry
expr_stmt|;
comment|/* recurse */
name|leaf
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|get
operator|=
name|AppendLEntry
expr_stmt|;
comment|/* bottom of recursion */
name|leaf
operator|=
literal|1
expr_stmt|;
block|}
name|GTIGHTLOOSE
argument_list|(
operator|*
name|names
argument_list|,
name|AppendLooseLEntry
argument_list|)
expr_stmt|;
comment|/* do name, tight and loose */
name|GTIGHTLOOSE
argument_list|(
operator|*
name|classes
argument_list|,
name|AppendLooseLEntry
argument_list|)
expr_stmt|;
comment|/* do class, tight and loose */
if|if
condition|(
name|table
operator|->
name|hasany
condition|)
block|{
name|GTIGHTLOOSE
argument_list|(
name|XrmQANY
argument_list|,
name|AppendLooseLEntry
argument_list|)
expr_stmt|;
comment|/* do ANY, tight and loose */
block|}
if|if
condition|(
name|table
operator|->
name|hasloose
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|names
operator|++
expr_stmt|;
name|classes
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|names
condition|)
break|break;
if|if
condition|(
operator|!
name|names
index|[
literal|1
index|]
condition|)
block|{
name|get
operator|=
name|AppendLEntry
expr_stmt|;
comment|/* bottom of recursion */
name|leaf
operator|=
literal|1
expr_stmt|;
block|}
name|GLOOSE
argument_list|(
operator|*
name|names
argument_list|,
name|AppendLooseLEntry
argument_list|)
expr_stmt|;
comment|/* loose names */
name|GLOOSE
argument_list|(
operator|*
name|classes
argument_list|,
name|AppendLooseLEntry
argument_list|)
expr_stmt|;
comment|/* loose classes */
if|if
condition|(
name|table
operator|->
name|hasany
condition|)
block|{
name|GLOOSE
argument_list|(
name|XrmQANY
argument_list|,
name|AppendLooseLEntry
argument_list|)
expr_stmt|;
comment|/* loose ANY */
block|}
block|}
block|}
comment|/* now look for matching leaf nodes */
name|entry
operator|=
name|table
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
return|return
name|False
return|;
if|if
condition|(
name|entry
operator|->
name|leaf
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|tight
operator|&&
operator|!
name|table
operator|->
name|tight
condition|)
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|||
operator|!
name|entry
operator|->
name|tight
condition|)
return|return
name|False
return|;
block|}
if|if
condition|(
operator|!
name|entry
operator|||
name|entry
operator|->
name|name
operator|!=
name|table
operator|->
name|name
condition|)
return|return
name|False
return|;
comment|/* found one */
if|if
condition|(
name|entry
operator|->
name|hasloose
operator|&&
name|AppendLooseLEntry
argument_list|(
operator|(
name|LTable
operator|)
name|entry
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
name|closure
argument_list|)
condition|)
return|return
name|True
return|;
if|if
condition|(
name|entry
operator|->
name|tight
operator|&&
name|entry
operator|==
name|table
operator|->
name|next
operator|&&
operator|(
name|entry
operator|=
name|entry
operator|->
name|next
operator|)
operator|&&
name|entry
operator|->
name|name
operator|==
name|table
operator|->
name|name
operator|&&
name|entry
operator|->
name|hasloose
condition|)
return|return
name|AppendLooseLEntry
argument_list|(
operator|(
name|LTable
operator|)
name|entry
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
name|closure
argument_list|)
return|;
return|return
name|False
return|;
block|}
end_function

begin_function
name|Bool
name|XrmQGetSearchList
parameter_list|(
name|db
parameter_list|,
name|names
parameter_list|,
name|classes
parameter_list|,
name|searchList
parameter_list|,
name|listLength
parameter_list|)
name|XrmDatabase
name|db
decl_stmt|;
name|XrmNameList
name|names
decl_stmt|;
name|XrmClassList
name|classes
decl_stmt|;
name|XrmSearchList
name|searchList
decl_stmt|;
comment|/* RETURN */
name|int
name|listLength
decl_stmt|;
block|{
specifier|register
name|NTable
name|table
decl_stmt|;
name|SClosureRec
name|closure
decl_stmt|;
if|if
condition|(
name|listLength
operator|<=
literal|0
condition|)
return|return
name|False
return|;
name|closure
operator|.
name|list
operator|=
operator|(
name|LTable
operator|*
operator|)
name|searchList
expr_stmt|;
name|closure
operator|.
name|idx
operator|=
operator|-
literal|1
expr_stmt|;
name|closure
operator|.
name|limit
operator|=
name|listLength
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|db
condition|)
block|{
name|table
operator|=
name|db
operator|->
name|table
expr_stmt|;
if|if
condition|(
operator|*
name|names
condition|)
block|{
if|if
condition|(
name|table
operator|&&
operator|!
name|table
operator|->
name|leaf
condition|)
block|{
if|if
condition|(
name|SearchNEntry
argument_list|(
name|table
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
operator|&
name|closure
argument_list|)
condition|)
return|return
name|False
return|;
block|}
elseif|else
if|if
condition|(
name|table
operator|&&
name|table
operator|->
name|hasloose
operator|&&
name|AppendLooseLEntry
argument_list|(
operator|(
name|LTable
operator|)
name|table
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
operator|&
name|closure
argument_list|)
condition|)
return|return
name|False
return|;
block|}
else|else
block|{
if|if
condition|(
name|table
operator|&&
operator|!
name|table
operator|->
name|leaf
condition|)
name|table
operator|=
name|table
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|table
operator|&&
name|AppendLEntry
argument_list|(
operator|(
name|LTable
operator|)
name|table
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
operator|&
name|closure
argument_list|)
condition|)
return|return
name|False
return|;
block|}
block|}
name|closure
operator|.
name|list
index|[
name|closure
operator|.
name|idx
operator|+
literal|1
index|]
operator|=
operator|(
name|LTable
operator|)
name|NULL
expr_stmt|;
return|return
name|True
return|;
block|}
end_function

begin_function
name|Bool
name|XrmQGetSearchResource
parameter_list|(
name|searchList
parameter_list|,
name|name
parameter_list|,
name|class
parameter_list|,
name|pType
parameter_list|,
name|pValue
parameter_list|)
name|XrmSearchList
name|searchList
decl_stmt|;
specifier|register
name|XrmName
name|name
decl_stmt|;
specifier|register
name|XrmClass
name|class
decl_stmt|;
name|XrmRepresentation
modifier|*
name|pType
decl_stmt|;
comment|/* RETURN */
name|XrmValue
modifier|*
name|pValue
decl_stmt|;
comment|/* RETURN */
block|{
specifier|register
name|LTable
modifier|*
name|list
decl_stmt|;
specifier|register
name|LTable
name|table
decl_stmt|;
specifier|register
name|VEntry
name|entry
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* find tight or loose entry */
define|#
directive|define
name|VTIGHTLOOSE
parameter_list|(
name|q
parameter_list|)
define|\
value|entry = LeafHash(table, q); \     while (entry&& entry->name != q) \ 	entry = entry->next; \     if (entry) \ 	break
comment|/* find loose entry */
define|#
directive|define
name|VLOOSE
parameter_list|(
name|q
parameter_list|)
define|\
value|entry = LeafHash(table, q); \     while (entry&& entry->name != q) \ 	entry = entry->next; \     if (entry) { \ 	if (!entry->tight) \ 	    break; \ 	if ((entry = entry->next)&& entry->name == q) \ 	    break; \     }
name|list
operator|=
operator|(
name|LTable
operator|*
operator|)
name|searchList
expr_stmt|;
comment|/* figure out which combination of name and class we need to search for */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IsResourceQuark
argument_list|(
name|name
argument_list|)
condition|)
name|flags
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|IsResourceQuark
argument_list|(
name|class
argument_list|)
condition|)
name|flags
operator||=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flags
condition|)
block|{
comment|/* neither name nor class has ever been used to name a resource */
name|table
operator|=
operator|(
name|LTable
operator|)
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
literal|3
condition|)
block|{
comment|/* both name and class */
while|while
condition|(
name|table
operator|=
operator|*
name|list
operator|++
condition|)
block|{
if|if
condition|(
name|table
operator|!=
name|LOOSESEARCH
condition|)
block|{
name|VTIGHTLOOSE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* do name, tight and loose */
name|VTIGHTLOOSE
argument_list|(
name|class
argument_list|)
expr_stmt|;
comment|/* do class, tight and loose */
block|}
else|else
block|{
name|table
operator|=
operator|*
name|list
operator|++
expr_stmt|;
name|VLOOSE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* do name, loose only */
name|VLOOSE
argument_list|(
name|class
argument_list|)
expr_stmt|;
comment|/* do class, loose only */
block|}
block|}
block|}
else|else
block|{
comment|/* just one of name or class */
if|if
condition|(
name|flags
operator|==
literal|1
condition|)
name|name
operator|=
name|class
expr_stmt|;
while|while
condition|(
name|table
operator|=
operator|*
name|list
operator|++
condition|)
block|{
if|if
condition|(
name|table
operator|!=
name|LOOSESEARCH
condition|)
block|{
name|VTIGHTLOOSE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* tight and loose */
block|}
else|else
block|{
name|table
operator|=
operator|*
name|list
operator|++
expr_stmt|;
name|VLOOSE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* loose only */
block|}
block|}
block|}
if|if
condition|(
name|table
condition|)
block|{
comment|/* found a match */
if|if
condition|(
name|entry
operator|->
name|string
condition|)
block|{
operator|*
name|pType
operator|=
name|XrmQString
expr_stmt|;
name|pValue
operator|->
name|addr
operator|=
name|StringValue
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pType
operator|=
name|RepType
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|pValue
operator|->
name|addr
operator|=
name|DataValue
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|pValue
operator|->
name|size
operator|=
name|entry
operator|->
name|size
expr_stmt|;
return|return
name|True
return|;
block|}
operator|*
name|pType
operator|=
name|NULLQUARK
expr_stmt|;
name|pValue
operator|->
name|addr
operator|=
operator|(
name|XPointer
operator|)
name|NULL
expr_stmt|;
name|pValue
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|False
return|;
undef|#
directive|undef
name|VTIGHTLOOSE
undef|#
directive|undef
name|VLOOSE
block|}
end_function

begin_comment
comment|/* look for a tight/loose value */
end_comment

begin_function
specifier|static
name|Bool
name|GetVEntry
parameter_list|(
name|table
parameter_list|,
name|names
parameter_list|,
name|classes
parameter_list|,
name|closure
parameter_list|)
name|LTable
name|table
decl_stmt|;
name|XrmNameList
name|names
decl_stmt|;
name|XrmClassList
name|classes
decl_stmt|;
name|VClosure
name|closure
decl_stmt|;
block|{
specifier|register
name|VEntry
name|entry
decl_stmt|;
specifier|register
name|XrmQuark
name|q
decl_stmt|;
comment|/* try name first */
name|q
operator|=
operator|*
name|names
expr_stmt|;
name|entry
operator|=
name|LeafHash
argument_list|(
name|table
argument_list|,
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
name|entry
operator|&&
name|entry
operator|->
name|name
operator|!=
name|q
condition|)
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
comment|/* not found, try class */
name|q
operator|=
operator|*
name|classes
expr_stmt|;
name|entry
operator|=
name|LeafHash
argument_list|(
name|table
argument_list|,
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
name|entry
operator|&&
name|entry
operator|->
name|name
operator|!=
name|q
condition|)
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
return|return
name|False
return|;
block|}
if|if
condition|(
name|entry
operator|->
name|string
condition|)
block|{
operator|*
name|closure
operator|->
name|type
operator|=
name|XrmQString
expr_stmt|;
name|closure
operator|->
name|value
operator|->
name|addr
operator|=
name|StringValue
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|closure
operator|->
name|type
operator|=
name|RepType
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|closure
operator|->
name|value
operator|->
name|addr
operator|=
name|DataValue
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|closure
operator|->
name|value
operator|->
name|size
operator|=
name|entry
operator|->
name|size
expr_stmt|;
return|return
name|True
return|;
block|}
end_function

begin_comment
comment|/* look for a loose value */
end_comment

begin_function
specifier|static
name|Bool
name|GetLooseVEntry
parameter_list|(
name|table
parameter_list|,
name|names
parameter_list|,
name|classes
parameter_list|,
name|closure
parameter_list|)
name|LTable
name|table
decl_stmt|;
name|XrmNameList
name|names
decl_stmt|;
name|XrmClassList
name|classes
decl_stmt|;
name|VClosure
name|closure
decl_stmt|;
block|{
specifier|register
name|VEntry
name|entry
decl_stmt|;
specifier|register
name|XrmQuark
name|q
decl_stmt|;
define|#
directive|define
name|VLOOSE
parameter_list|(
name|ename
parameter_list|)
define|\
value|q = ename; \     entry = LeafHash(table, q); \     while (entry&& entry->name != q) \ 	entry = entry->next; \     if (entry&& entry->tight&& (entry = entry->next)&& entry->name != q) \ 	entry = (VEntry)NULL;
comment|/* bump to last component */
while|while
condition|(
name|names
index|[
literal|1
index|]
condition|)
block|{
name|names
operator|++
expr_stmt|;
name|classes
operator|++
expr_stmt|;
block|}
name|VLOOSE
argument_list|(
operator|*
name|names
argument_list|)
expr_stmt|;
comment|/* do name, loose only */
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|VLOOSE
argument_list|(
operator|*
name|classes
argument_list|)
expr_stmt|;
comment|/* do class, loose only */
if|if
condition|(
operator|!
name|entry
condition|)
return|return
name|False
return|;
block|}
if|if
condition|(
name|entry
operator|->
name|string
condition|)
block|{
operator|*
name|closure
operator|->
name|type
operator|=
name|XrmQString
expr_stmt|;
name|closure
operator|->
name|value
operator|->
name|addr
operator|=
name|StringValue
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|closure
operator|->
name|type
operator|=
name|RepType
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|closure
operator|->
name|value
operator|->
name|addr
operator|=
name|DataValue
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|closure
operator|->
name|value
operator|->
name|size
operator|=
name|entry
operator|->
name|size
expr_stmt|;
return|return
name|True
return|;
undef|#
directive|undef
name|VLOOSE
block|}
end_function

begin_comment
comment|/* recursive search for a value */
end_comment

begin_function
specifier|static
name|Bool
name|GetNEntry
parameter_list|(
name|table
parameter_list|,
name|names
parameter_list|,
name|classes
parameter_list|,
name|closure
parameter_list|)
name|NTable
name|table
decl_stmt|;
name|XrmNameList
name|names
decl_stmt|;
name|XrmClassList
name|classes
decl_stmt|;
name|VClosure
name|closure
decl_stmt|;
block|{
specifier|register
name|NTable
name|entry
decl_stmt|;
specifier|register
name|XrmQuark
name|q
decl_stmt|;
specifier|register
name|unsigned
name|int
name|leaf
decl_stmt|;
name|Bool
function_decl|(
modifier|*
name|get
function_decl|)
parameter_list|()
function_decl|;
name|NTable
name|otable
decl_stmt|;
if|if
condition|(
name|names
index|[
literal|2
index|]
condition|)
block|{
name|get
operator|=
name|GetNEntry
expr_stmt|;
comment|/* recurse */
name|leaf
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|get
operator|=
name|GetVEntry
expr_stmt|;
comment|/* bottom of recursion */
name|leaf
operator|=
literal|1
expr_stmt|;
block|}
name|GTIGHTLOOSE
argument_list|(
operator|*
name|names
argument_list|,
name|GetLooseVEntry
argument_list|)
expr_stmt|;
comment|/* do name, tight and loose */
name|GTIGHTLOOSE
argument_list|(
operator|*
name|classes
argument_list|,
name|GetLooseVEntry
argument_list|)
expr_stmt|;
comment|/* do class, tight and loose */
if|if
condition|(
name|table
operator|->
name|hasany
condition|)
block|{
name|GTIGHTLOOSE
argument_list|(
name|XrmQANY
argument_list|,
name|GetLooseVEntry
argument_list|)
expr_stmt|;
comment|/* do ANY, tight and loose */
block|}
if|if
condition|(
name|table
operator|->
name|hasloose
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|names
operator|++
expr_stmt|;
name|classes
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|names
index|[
literal|1
index|]
condition|)
break|break;
if|if
condition|(
operator|!
name|names
index|[
literal|2
index|]
condition|)
block|{
name|get
operator|=
name|GetVEntry
expr_stmt|;
comment|/* bottom of recursion */
name|leaf
operator|=
literal|1
expr_stmt|;
block|}
name|GLOOSE
argument_list|(
operator|*
name|names
argument_list|,
name|GetLooseVEntry
argument_list|)
expr_stmt|;
comment|/* do name, loose only */
name|GLOOSE
argument_list|(
operator|*
name|classes
argument_list|,
name|GetLooseVEntry
argument_list|)
expr_stmt|;
comment|/* do class, loose only */
if|if
condition|(
name|table
operator|->
name|hasany
condition|)
block|{
name|GLOOSE
argument_list|(
name|XrmQANY
argument_list|,
name|GetLooseVEntry
argument_list|)
expr_stmt|;
comment|/* do ANY, loose only */
block|}
block|}
block|}
comment|/* look for matching leaf tables */
name|otable
operator|=
name|table
expr_stmt|;
name|table
operator|=
name|table
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
return|return
name|False
return|;
if|if
condition|(
name|table
operator|->
name|leaf
condition|)
block|{
if|if
condition|(
name|table
operator|->
name|tight
operator|&&
operator|!
name|otable
operator|->
name|tight
condition|)
name|table
operator|=
name|table
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|table
operator|=
name|table
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|||
operator|!
name|table
operator|->
name|tight
condition|)
return|return
name|False
return|;
block|}
if|if
condition|(
operator|!
name|table
operator|||
name|table
operator|->
name|name
operator|!=
name|otable
operator|->
name|name
condition|)
return|return
name|False
return|;
comment|/* found one */
if|if
condition|(
name|table
operator|->
name|hasloose
operator|&&
name|GetLooseVEntry
argument_list|(
operator|(
name|LTable
operator|)
name|table
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
name|closure
argument_list|)
condition|)
return|return
name|True
return|;
if|if
condition|(
name|table
operator|->
name|tight
operator|&&
name|table
operator|==
name|otable
operator|->
name|next
condition|)
block|{
name|table
operator|=
name|table
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|table
operator|&&
name|table
operator|->
name|name
operator|==
name|otable
operator|->
name|name
operator|&&
name|table
operator|->
name|hasloose
condition|)
return|return
name|GetLooseVEntry
argument_list|(
operator|(
name|LTable
operator|)
name|table
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
name|closure
argument_list|)
return|;
block|}
return|return
name|False
return|;
block|}
end_function

begin_function
name|Bool
name|XrmQGetResource
parameter_list|(
name|db
parameter_list|,
name|names
parameter_list|,
name|classes
parameter_list|,
name|pType
parameter_list|,
name|pValue
parameter_list|)
name|XrmDatabase
name|db
decl_stmt|;
name|XrmNameList
name|names
decl_stmt|;
name|XrmClassList
name|classes
decl_stmt|;
name|XrmRepresentation
modifier|*
name|pType
decl_stmt|;
comment|/* RETURN */
name|XrmValuePtr
name|pValue
decl_stmt|;
comment|/* RETURN */
block|{
specifier|register
name|NTable
name|table
decl_stmt|;
name|VClosureRec
name|closure
decl_stmt|;
if|if
condition|(
name|db
operator|&&
operator|*
name|names
condition|)
block|{
name|closure
operator|.
name|type
operator|=
name|pType
expr_stmt|;
name|closure
operator|.
name|value
operator|=
name|pValue
expr_stmt|;
name|table
operator|=
name|db
operator|->
name|table
expr_stmt|;
if|if
condition|(
name|names
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|table
operator|&&
operator|!
name|table
operator|->
name|leaf
condition|)
block|{
if|if
condition|(
name|GetNEntry
argument_list|(
name|table
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
operator|&
name|closure
argument_list|)
condition|)
return|return
name|True
return|;
block|}
elseif|else
if|if
condition|(
name|table
operator|&&
name|table
operator|->
name|hasloose
operator|&&
name|GetLooseVEntry
argument_list|(
operator|(
name|LTable
operator|)
name|table
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
operator|&
name|closure
argument_list|)
condition|)
return|return
name|True
return|;
block|}
else|else
block|{
if|if
condition|(
name|table
operator|&&
operator|!
name|table
operator|->
name|leaf
condition|)
name|table
operator|=
name|table
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|table
operator|&&
name|GetVEntry
argument_list|(
operator|(
name|LTable
operator|)
name|table
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
operator|&
name|closure
argument_list|)
condition|)
return|return
name|True
return|;
block|}
block|}
operator|*
name|pType
operator|=
name|NULLQUARK
expr_stmt|;
name|pValue
operator|->
name|addr
operator|=
operator|(
name|XPointer
operator|)
name|NULL
expr_stmt|;
name|pValue
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|False
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|Bool
name|XrmGetResource
parameter_list|(
name|db
parameter_list|,
name|name_str
parameter_list|,
name|class_str
parameter_list|,
name|pType_str
parameter_list|,
name|pValue
parameter_list|)
name|XrmDatabase
name|db
decl_stmt|;
name|_Xconst
name|char
modifier|*
name|name_str
decl_stmt|;
name|_Xconst
name|char
modifier|*
name|class_str
decl_stmt|;
name|XrmString
modifier|*
name|pType_str
decl_stmt|;
comment|/* RETURN */
name|XrmValuePtr
name|pValue
decl_stmt|;
comment|/* RETURN */
else|#
directive|else
function|Bool XrmGetResource
parameter_list|(
name|db
parameter_list|,
name|name_str
parameter_list|,
name|class_str
parameter_list|,
name|pType_str
parameter_list|,
name|pValue
parameter_list|)
name|XrmDatabase
name|db
decl_stmt|;
name|XrmString
name|name_str
decl_stmt|;
name|XrmString
name|class_str
decl_stmt|;
name|XrmString
modifier|*
name|pType_str
decl_stmt|;
comment|/* RETURN */
name|XrmValuePtr
name|pValue
decl_stmt|;
comment|/* RETURN */
endif|#
directive|endif
block|{
name|XrmName
name|names
index|[
name|MAXDBDEPTH
operator|+
literal|1
index|]
decl_stmt|;
name|XrmClass
name|classes
index|[
name|MAXDBDEPTH
operator|+
literal|1
index|]
decl_stmt|;
name|XrmRepresentation
name|fromType
decl_stmt|;
name|Bool
name|result
decl_stmt|;
name|XrmStringToNameList
argument_list|(
name|name_str
argument_list|,
name|names
argument_list|)
expr_stmt|;
name|XrmStringToClassList
argument_list|(
name|class_str
argument_list|,
name|classes
argument_list|)
expr_stmt|;
name|result
operator|=
name|XrmQGetResource
argument_list|(
name|db
argument_list|,
name|names
argument_list|,
name|classes
argument_list|,
operator|&
name|fromType
argument_list|,
name|pValue
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pType_str
operator|)
operator|=
name|XrmQuarkToString
argument_list|(
name|fromType
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* destroy all values, plus table itself */
end_comment

begin_function
specifier|static
name|void
name|DestroyLTable
parameter_list|(
name|table
parameter_list|)
name|LTable
name|table
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|VEntry
modifier|*
name|buckets
decl_stmt|;
specifier|register
name|VEntry
name|entry
decl_stmt|,
name|next
decl_stmt|;
name|buckets
operator|=
name|table
operator|->
name|buckets
expr_stmt|;
for|for
control|(
name|i
operator|=
name|table
operator|->
name|table
operator|.
name|mask
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|buckets
operator|++
control|)
block|{
for|for
control|(
name|next
operator|=
operator|*
name|buckets
init|;
name|entry
operator|=
name|next
condition|;
control|)
block|{
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|table
operator|->
name|buckets
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* destroy all contained tables, plus table itself */
end_comment

begin_function
specifier|static
name|void
name|DestroyNTable
parameter_list|(
name|table
parameter_list|)
name|NTable
name|table
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|NTable
modifier|*
name|buckets
decl_stmt|;
specifier|register
name|NTable
name|entry
decl_stmt|,
name|next
decl_stmt|;
name|buckets
operator|=
name|NodeBuckets
argument_list|(
name|table
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|table
operator|->
name|mask
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|buckets
operator|++
control|)
block|{
for|for
control|(
name|next
operator|=
operator|*
name|buckets
init|;
name|entry
operator|=
name|next
condition|;
control|)
block|{
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|leaf
condition|)
name|DestroyLTable
argument_list|(
operator|(
name|LTable
operator|)
name|entry
argument_list|)
expr_stmt|;
else|else
name|DestroyNTable
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|XrmLocaleOfDatabase
parameter_list|(
name|db
parameter_list|)
name|XrmDatabase
name|db
decl_stmt|;
block|{
return|return
call|(
modifier|*
name|db
operator|->
name|methods
operator|->
name|lcname
call|)
argument_list|(
name|db
operator|->
name|mbstate
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|XrmDestroyDatabase
parameter_list|(
name|db
parameter_list|)
name|XrmDatabase
name|db
decl_stmt|;
block|{
specifier|register
name|NTable
name|table
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|db
condition|)
block|{
for|for
control|(
name|next
operator|=
name|db
operator|->
name|table
init|;
name|table
operator|=
name|next
condition|;
control|)
block|{
name|next
operator|=
name|table
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|leaf
condition|)
name|DestroyLTable
argument_list|(
operator|(
name|LTable
operator|)
name|table
argument_list|)
expr_stmt|;
else|else
name|DestroyNTable
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|db
operator|->
name|methods
operator|->
name|destroy
call|)
argument_list|(
name|db
operator|->
name|mbstate
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

