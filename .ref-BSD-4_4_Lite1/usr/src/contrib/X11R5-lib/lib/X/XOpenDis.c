begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: XOpenDis.c,v 11.123 91/12/20 16:04:29 rws Exp $  */
end_comment

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1985, 1986	*/
end_comment

begin_comment
comment|/* Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_include
include|#
directive|include
file|<X11/Xlibint.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xos.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xatom.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|X_NOT_STDC_ENV
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|_Xdebug
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* get rid of ifdefs when locking implemented */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|xReq
name|_dummy_request
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|OutOfMemory
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|Bool
name|_XWireToEvent
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Status
name|_XUnknownNativeEvent
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Bool
name|_XUnknownWireEvent
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*   * Connects to a server, creates a Display object and returns a pointer to  * the newly created Display back to the caller.  */
end_comment

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_decl_stmt
name|Display
modifier|*
name|XOpenDisplay
argument_list|(
specifier|register
name|_Xconst
name|char
operator|*
name|display
argument_list|)
else|#
directive|else
name|Display
modifier|*
name|XOpenDisplay
argument_list|(
name|display
argument_list|)
decl|register
name|char
modifier|*
name|display
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|Display
modifier|*
name|dpy
decl_stmt|;
comment|/* New Display object being created. */
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* random iterator indexes */
name|char
modifier|*
name|display_name
decl_stmt|;
comment|/* pointer to display name */
name|int
name|endian
decl_stmt|;
comment|/* to determine which endian. */
name|xConnClientPrefix
name|client
decl_stmt|;
comment|/* client information */
name|xConnSetupPrefix
name|prefix
decl_stmt|;
comment|/* prefix information */
name|int
name|vendorlen
decl_stmt|;
comment|/* length of vendor string */
name|char
modifier|*
name|setup
init|=
name|NULL
decl_stmt|;
comment|/* memory allocated at startup */
name|char
modifier|*
name|fullname
init|=
name|NULL
decl_stmt|;
comment|/* expanded name of display */
name|int
name|idisplay
decl_stmt|;
comment|/* display number */
name|int
name|iscreen
decl_stmt|;
comment|/* screen number */
union|union
block|{
name|xConnSetup
modifier|*
name|setup
decl_stmt|;
name|char
modifier|*
name|failure
decl_stmt|;
name|char
modifier|*
name|vendor
decl_stmt|;
name|xPixmapFormat
modifier|*
name|sf
decl_stmt|;
name|xWindowRoot
modifier|*
name|rp
decl_stmt|;
name|xDepth
modifier|*
name|dp
decl_stmt|;
name|xVisualType
modifier|*
name|vp
decl_stmt|;
block|}
name|u
union|;
comment|/* proto data returned from server */
name|long
name|setuplength
decl_stmt|;
comment|/* number of bytes in setup message */
name|char
modifier|*
name|conn_auth_name
decl_stmt|,
modifier|*
name|conn_auth_data
decl_stmt|;
name|int
name|conn_auth_namelen
decl_stmt|,
name|conn_auth_datalen
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
specifier|extern
name|Bool
name|_XSendClientPrefix
parameter_list|()
function_decl|;
specifier|extern
name|int
name|_XConnectDisplay
parameter_list|()
function_decl|;
specifier|extern
name|XID
name|_XAllocID
parameter_list|()
function_decl|;
comment|/* 	 * If the display specifier string supplied as an argument to this  	 * routine is NULL or a pointer to NULL, read the DISPLAY variable. 	 */
if|if
condition|(
name|display
operator|==
name|NULL
operator|||
operator|*
name|display
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|display_name
operator|=
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Oops! No DISPLAY environment variable - error. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Display is non-NULL, copy the pointer */
name|display_name
operator|=
operator|(
name|char
operator|*
operator|)
name|display
expr_stmt|;
block|}
comment|/*  * Lock against other threads trying to access global data (like the error  * handlers and display list).  */
name|LockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
comment|/*  * Set the default error handlers.  This allows the global variables to  * default to NULL for use with shared libraries.  */
if|if
condition|(
name|_XErrorFunction
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|XSetErrorHandler
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XIOErrorFunction
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|XSetIOErrorHandler
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * Attempt to allocate a display structure. Return NULL if allocation fails.  */
if|if
condition|(
operator|(
name|dpy
operator|=
operator|(
name|Display
operator|*
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Display
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  * Call the Connect routine to get the network socket. If -1 is returned, the  * connection failed. The connect routine will set fullname to point to the  * expanded name.  */
if|if
condition|(
operator|(
name|dpy
operator|->
name|fd
operator|=
name|_XConnectDisplay
argument_list|(
name|display_name
argument_list|,
operator|&
name|fullname
argument_list|,
operator|&
name|idisplay
argument_list|,
operator|&
name|iscreen
argument_list|,
operator|&
name|conn_auth_name
argument_list|,
operator|&
name|conn_auth_namelen
argument_list|,
operator|&
name|conn_auth_data
argument_list|,
operator|&
name|conn_auth_datalen
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dpy
argument_list|)
expr_stmt|;
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Initialize as much of the display structure as we can */
name|dpy
operator|->
name|display_name
operator|=
name|fullname
expr_stmt|;
name|dpy
operator|->
name|keysyms
operator|=
operator|(
name|KeySym
operator|*
operator|)
name|NULL
expr_stmt|;
name|dpy
operator|->
name|modifiermap
operator|=
name|NULL
expr_stmt|;
name|dpy
operator|->
name|lock_meaning
operator|=
name|NoSymbol
expr_stmt|;
name|dpy
operator|->
name|keysyms_per_keycode
operator|=
literal|0
expr_stmt|;
name|dpy
operator|->
name|current
operator|=
name|None
expr_stmt|;
name|dpy
operator|->
name|xdefaults
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|dpy
operator|->
name|scratch_length
operator|=
literal|0L
expr_stmt|;
name|dpy
operator|->
name|scratch_buffer
operator|=
name|NULL
expr_stmt|;
name|dpy
operator|->
name|key_bindings
operator|=
name|NULL
expr_stmt|;
name|dpy
operator|->
name|ext_procs
operator|=
operator|(
name|_XExtension
operator|*
operator|)
name|NULL
expr_stmt|;
name|dpy
operator|->
name|ext_data
operator|=
operator|(
name|XExtData
operator|*
operator|)
name|NULL
expr_stmt|;
name|dpy
operator|->
name|ext_number
operator|=
literal|0
expr_stmt|;
name|dpy
operator|->
name|event_vec
index|[
name|X_Error
index|]
operator|=
name|_XUnknownWireEvent
expr_stmt|;
name|dpy
operator|->
name|event_vec
index|[
name|X_Reply
index|]
operator|=
name|_XUnknownWireEvent
expr_stmt|;
name|dpy
operator|->
name|wire_vec
index|[
name|X_Error
index|]
operator|=
name|_XUnknownNativeEvent
expr_stmt|;
name|dpy
operator|->
name|wire_vec
index|[
name|X_Reply
index|]
operator|=
name|_XUnknownNativeEvent
expr_stmt|;
for|for
control|(
name|i
operator|=
name|KeyPress
init|;
name|i
operator|<
name|LASTEvent
condition|;
name|i
operator|++
control|)
block|{
name|dpy
operator|->
name|event_vec
index|[
name|i
index|]
operator|=
name|_XWireToEvent
expr_stmt|;
name|dpy
operator|->
name|wire_vec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|LASTEvent
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
name|dpy
operator|->
name|event_vec
index|[
name|i
index|]
operator|=
name|_XUnknownWireEvent
expr_stmt|;
name|dpy
operator|->
name|wire_vec
index|[
name|i
index|]
operator|=
name|_XUnknownNativeEvent
expr_stmt|;
block|}
name|dpy
operator|->
name|resource_id
operator|=
literal|0
expr_stmt|;
name|dpy
operator|->
name|db
operator|=
operator|(
expr|struct
name|_XrmHashBucketRec
operator|*
operator|)
name|NULL
expr_stmt|;
name|dpy
operator|->
name|cursor_font
operator|=
name|None
expr_stmt|;
name|dpy
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/*   * Initialize pointers to NULL so that XFreeDisplayStructure will  * work if we run out of memory  */
name|dpy
operator|->
name|screens
operator|=
name|NULL
expr_stmt|;
name|dpy
operator|->
name|vendor
operator|=
name|NULL
expr_stmt|;
name|dpy
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|dpy
operator|->
name|atoms
operator|=
name|NULL
expr_stmt|;
name|dpy
operator|->
name|error_vec
operator|=
name|NULL
expr_stmt|;
name|dpy
operator|->
name|context_db
operator|=
name|NULL
expr_stmt|;
comment|/*  * Setup other information in this display structure.  */
name|dpy
operator|->
name|vnumber
operator|=
name|X_PROTOCOL
expr_stmt|;
name|dpy
operator|->
name|resource_alloc
operator|=
name|_XAllocID
expr_stmt|;
name|dpy
operator|->
name|synchandler
operator|=
name|NULL
expr_stmt|;
name|dpy
operator|->
name|request
operator|=
literal|0
expr_stmt|;
name|dpy
operator|->
name|last_request_read
operator|=
literal|0
expr_stmt|;
name|dpy
operator|->
name|default_screen
operator|=
name|iscreen
expr_stmt|;
comment|/* Value returned by ConnectDisplay */
name|dpy
operator|->
name|last_req
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|_dummy_request
expr_stmt|;
comment|/* Set up the output buffers. */
if|if
condition|(
operator|(
name|dpy
operator|->
name|bufptr
operator|=
name|dpy
operator|->
name|buffer
operator|=
name|Xmalloc
argument_list|(
name|BUFSIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|OutOfMemory
argument_list|(
name|dpy
argument_list|,
name|setup
argument_list|)
expr_stmt|;
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dpy
operator|->
name|bufmax
operator|=
name|dpy
operator|->
name|buffer
operator|+
name|BUFSIZE
expr_stmt|;
comment|/* Set up the input event queue and input event queue parameters. */
name|dpy
operator|->
name|head
operator|=
name|dpy
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
name|dpy
operator|->
name|qlen
operator|=
literal|0
expr_stmt|;
comment|/* Set up free-function record */
if|if
condition|(
operator|(
name|dpy
operator|->
name|free_funcs
operator|=
operator|(
name|_XFreeFuncRec
operator|*
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|_XFreeFuncRec
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|OutOfMemory
argument_list|(
name|dpy
argument_list|,
name|setup
argument_list|)
expr_stmt|;
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  * The xConnClientPrefix describes the initial connection setup information  * and is followed by the authorization information.  Sites that are interested  * in security are strongly encouraged to use an authentication and   * authorization system such as Kerberos.  */
name|endian
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|)
operator|&
name|endian
condition|)
name|client
operator|.
name|byteOrder
operator|=
literal|'\154'
expr_stmt|;
comment|/* 'l' */
else|else
name|client
operator|.
name|byteOrder
operator|=
literal|'\102'
expr_stmt|;
comment|/* 'B' */
name|client
operator|.
name|majorVersion
operator|=
name|X_PROTOCOL
expr_stmt|;
name|client
operator|.
name|minorVersion
operator|=
name|X_PROTOCOL_REVISION
expr_stmt|;
name|client
operator|.
name|nbytesAuthProto
operator|=
name|conn_auth_namelen
expr_stmt|;
name|client
operator|.
name|nbytesAuthString
operator|=
name|conn_auth_datalen
expr_stmt|;
if|if
condition|(
operator|!
name|_XSendClientPrefix
argument_list|(
name|dpy
argument_list|,
operator|&
name|client
argument_list|,
name|conn_auth_name
argument_list|,
name|conn_auth_data
argument_list|)
condition|)
block|{
name|_XDisconnectDisplay
argument_list|(
name|dpy
operator|->
name|fd
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dpy
argument_list|)
expr_stmt|;
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|conn_auth_name
condition|)
name|Xfree
argument_list|(
name|conn_auth_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn_auth_data
condition|)
name|Xfree
argument_list|(
name|conn_auth_data
argument_list|)
expr_stmt|;
comment|/*  * Now see if connection was accepted...  */
name|_XRead
argument_list|(
name|dpy
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|prefix
argument_list|,
operator|(
name|long
operator|)
name|SIZEOF
argument_list|(
name|xConnSetupPrefix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|.
name|majorVersion
operator|<
name|X_PROTOCOL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Xlib:  warning, client built for newer rev (%d) than server (%d)!\r\n"
argument_list|,
name|X_PROTOCOL
argument_list|,
name|prefix
operator|.
name|majorVersion
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prefix
operator|.
name|minorVersion
operator|!=
name|X_PROTOCOL_REVISION
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Xlib:  warning, client is protocol rev %d, server is rev %d!\r\n"
argument_list|,
name|X_PROTOCOL_REVISION
argument_list|,
name|prefix
operator|.
name|minorVersion
argument_list|)
expr_stmt|;
block|}
name|setuplength
operator|=
name|prefix
operator|.
name|length
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|u
operator|.
name|setup
operator|=
operator|(
name|xConnSetup
operator|*
operator|)
operator|(
name|setup
operator|=
name|Xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|setuplength
argument_list|)
operator|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|_XDisconnectDisplay
argument_list|(
name|dpy
operator|->
name|fd
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dpy
argument_list|)
expr_stmt|;
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|_XRead
argument_list|(
name|dpy
argument_list|,
operator|(
name|char
operator|*
operator|)
name|u
operator|.
name|setup
argument_list|,
name|setuplength
argument_list|)
expr_stmt|;
comment|/*  * If the connection was not accepted by the server due to problems,  * give error message to the user....  */
if|if
condition|(
name|prefix
operator|.
name|success
operator|!=
name|xTrue
condition|)
block|{
comment|/* XXX - printing messages marks a bad programming interface */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  connection to \"%s\" refused by server\r\n%s:  "
argument_list|,
literal|"Xlib"
argument_list|,
name|fullname
argument_list|,
literal|"Xlib"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|u
operator|.
name|failure
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|prefix
operator|.
name|lengthReason
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
literal|"\r\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|2
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|OutOfMemory
argument_list|(
name|dpy
argument_list|,
name|setup
argument_list|)
expr_stmt|;
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  * We succeeded at authorization, so let us move the data into  * the display structure.  */
name|dpy
operator|->
name|proto_major_version
operator|=
name|prefix
operator|.
name|majorVersion
expr_stmt|;
name|dpy
operator|->
name|proto_minor_version
operator|=
name|prefix
operator|.
name|minorVersion
expr_stmt|;
name|dpy
operator|->
name|release
operator|=
name|u
operator|.
name|setup
operator|->
name|release
expr_stmt|;
name|dpy
operator|->
name|resource_base
operator|=
name|u
operator|.
name|setup
operator|->
name|ridBase
expr_stmt|;
name|dpy
operator|->
name|resource_mask
operator|=
name|u
operator|.
name|setup
operator|->
name|ridMask
expr_stmt|;
name|dpy
operator|->
name|min_keycode
operator|=
name|u
operator|.
name|setup
operator|->
name|minKeyCode
expr_stmt|;
name|dpy
operator|->
name|max_keycode
operator|=
name|u
operator|.
name|setup
operator|->
name|maxKeyCode
expr_stmt|;
name|dpy
operator|->
name|motion_buffer
operator|=
name|u
operator|.
name|setup
operator|->
name|motionBufferSize
expr_stmt|;
name|dpy
operator|->
name|nformats
operator|=
name|u
operator|.
name|setup
operator|->
name|numFormats
expr_stmt|;
name|dpy
operator|->
name|nscreens
operator|=
name|u
operator|.
name|setup
operator|->
name|numRoots
expr_stmt|;
name|dpy
operator|->
name|byte_order
operator|=
name|u
operator|.
name|setup
operator|->
name|imageByteOrder
expr_stmt|;
name|dpy
operator|->
name|bitmap_unit
operator|=
name|u
operator|.
name|setup
operator|->
name|bitmapScanlineUnit
expr_stmt|;
name|dpy
operator|->
name|bitmap_pad
operator|=
name|u
operator|.
name|setup
operator|->
name|bitmapScanlinePad
expr_stmt|;
name|dpy
operator|->
name|bitmap_bit_order
operator|=
name|u
operator|.
name|setup
operator|->
name|bitmapBitOrder
expr_stmt|;
name|dpy
operator|->
name|max_request_size
operator|=
name|u
operator|.
name|setup
operator|->
name|maxRequestSize
expr_stmt|;
name|mask
operator|=
name|dpy
operator|->
name|resource_mask
expr_stmt|;
name|dpy
operator|->
name|resource_shift
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|mask
operator|&
literal|1
operator|)
condition|)
block|{
name|dpy
operator|->
name|resource_shift
operator|++
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
comment|/*  * now extract the vendor string...  String must be null terminated,  * padded to multiple of 4 bytes.  */
name|dpy
operator|->
name|vendor
operator|=
operator|(
name|char
operator|*
operator|)
name|Xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|u
operator|.
name|setup
operator|->
name|nbytesVendor
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|vendor
operator|==
name|NULL
condition|)
block|{
name|OutOfMemory
argument_list|(
name|dpy
argument_list|,
name|setup
argument_list|)
expr_stmt|;
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|vendorlen
operator|=
name|u
operator|.
name|setup
operator|->
name|nbytesVendor
expr_stmt|;
name|u
operator|.
name|setup
operator|=
operator|(
name|xConnSetup
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|u
operator|.
name|setup
operator|)
operator|+
name|sz_xConnSetup
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|dpy
operator|->
name|vendor
argument_list|,
name|u
operator|.
name|vendor
argument_list|,
name|vendorlen
argument_list|)
expr_stmt|;
name|dpy
operator|->
name|vendor
index|[
name|vendorlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|vendorlen
operator|=
operator|(
name|vendorlen
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* round up */
name|bcopy
argument_list|(
name|u
operator|.
name|vendor
operator|+
name|vendorlen
argument_list|,
name|setup
argument_list|,
operator|(
name|int
operator|)
name|setuplength
operator|-
name|sz_xConnSetup
operator|-
name|vendorlen
argument_list|)
expr_stmt|;
name|u
operator|.
name|vendor
operator|=
name|setup
expr_stmt|;
comment|/*  * Now iterate down setup information.....  */
name|dpy
operator|->
name|pixmap_format
operator|=
operator|(
name|ScreenFormat
operator|*
operator|)
name|Xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|dpy
operator|->
name|nformats
operator|*
sizeof|sizeof
argument_list|(
name|ScreenFormat
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|pixmap_format
operator|==
name|NULL
condition|)
block|{
name|OutOfMemory
argument_list|(
name|dpy
argument_list|,
name|setup
argument_list|)
expr_stmt|;
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  * First decode the Z axis Screen format information.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dpy
operator|->
name|nformats
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|ScreenFormat
modifier|*
name|fmt
init|=
operator|&
name|dpy
operator|->
name|pixmap_format
index|[
name|i
index|]
decl_stmt|;
name|fmt
operator|->
name|depth
operator|=
name|u
operator|.
name|sf
operator|->
name|depth
expr_stmt|;
name|fmt
operator|->
name|bits_per_pixel
operator|=
name|u
operator|.
name|sf
operator|->
name|bitsPerPixel
expr_stmt|;
name|fmt
operator|->
name|scanline_pad
operator|=
name|u
operator|.
name|sf
operator|->
name|scanLinePad
expr_stmt|;
name|fmt
operator|->
name|ext_data
operator|=
name|NULL
expr_stmt|;
name|u
operator|.
name|sf
operator|=
operator|(
name|xPixmapFormat
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|u
operator|.
name|sf
operator|)
operator|+
name|sz_xPixmapFormat
operator|)
expr_stmt|;
block|}
comment|/*  * next the Screen structures.  */
name|dpy
operator|->
name|screens
operator|=
operator|(
name|Screen
operator|*
operator|)
name|Xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|dpy
operator|->
name|nscreens
operator|*
sizeof|sizeof
argument_list|(
name|Screen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|screens
operator|==
name|NULL
condition|)
block|{
name|OutOfMemory
argument_list|(
name|dpy
argument_list|,
name|setup
argument_list|)
expr_stmt|;
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  * Now go deal with each screen structure.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dpy
operator|->
name|nscreens
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|Screen
modifier|*
name|sp
init|=
operator|&
name|dpy
operator|->
name|screens
index|[
name|i
index|]
decl_stmt|;
name|VisualID
name|root_visualID
init|=
name|u
operator|.
name|rp
operator|->
name|rootVisualID
decl_stmt|;
name|sp
operator|->
name|display
operator|=
name|dpy
expr_stmt|;
name|sp
operator|->
name|root
operator|=
name|u
operator|.
name|rp
operator|->
name|windowId
expr_stmt|;
name|sp
operator|->
name|cmap
operator|=
name|u
operator|.
name|rp
operator|->
name|defaultColormap
expr_stmt|;
name|sp
operator|->
name|white_pixel
operator|=
name|u
operator|.
name|rp
operator|->
name|whitePixel
expr_stmt|;
name|sp
operator|->
name|black_pixel
operator|=
name|u
operator|.
name|rp
operator|->
name|blackPixel
expr_stmt|;
name|sp
operator|->
name|root_input_mask
operator|=
name|u
operator|.
name|rp
operator|->
name|currentInputMask
expr_stmt|;
name|sp
operator|->
name|width
operator|=
name|u
operator|.
name|rp
operator|->
name|pixWidth
expr_stmt|;
name|sp
operator|->
name|height
operator|=
name|u
operator|.
name|rp
operator|->
name|pixHeight
expr_stmt|;
name|sp
operator|->
name|mwidth
operator|=
name|u
operator|.
name|rp
operator|->
name|mmWidth
expr_stmt|;
name|sp
operator|->
name|mheight
operator|=
name|u
operator|.
name|rp
operator|->
name|mmHeight
expr_stmt|;
name|sp
operator|->
name|min_maps
operator|=
name|u
operator|.
name|rp
operator|->
name|minInstalledMaps
expr_stmt|;
name|sp
operator|->
name|max_maps
operator|=
name|u
operator|.
name|rp
operator|->
name|maxInstalledMaps
expr_stmt|;
name|sp
operator|->
name|root_visual
operator|=
name|NULL
expr_stmt|;
comment|/* filled in later, when we alloc Visuals */
name|sp
operator|->
name|backing_store
operator|=
name|u
operator|.
name|rp
operator|->
name|backingStore
expr_stmt|;
name|sp
operator|->
name|save_unders
operator|=
name|u
operator|.
name|rp
operator|->
name|saveUnders
expr_stmt|;
name|sp
operator|->
name|root_depth
operator|=
name|u
operator|.
name|rp
operator|->
name|rootDepth
expr_stmt|;
name|sp
operator|->
name|ndepths
operator|=
name|u
operator|.
name|rp
operator|->
name|nDepths
expr_stmt|;
name|sp
operator|->
name|ext_data
operator|=
name|NULL
expr_stmt|;
name|u
operator|.
name|rp
operator|=
operator|(
name|xWindowRoot
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|u
operator|.
name|rp
operator|)
operator|+
name|sz_xWindowRoot
operator|)
expr_stmt|;
comment|/*  * lets set up the depth structures.  */
name|sp
operator|->
name|depths
operator|=
operator|(
name|Depth
operator|*
operator|)
name|Xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|sp
operator|->
name|ndepths
operator|*
sizeof|sizeof
argument_list|(
name|Depth
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|depths
operator|==
name|NULL
condition|)
block|{
name|OutOfMemory
argument_list|(
name|dpy
argument_list|,
name|setup
argument_list|)
expr_stmt|;
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	     * for all depths on this screen. 	     */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sp
operator|->
name|ndepths
condition|;
name|j
operator|++
control|)
block|{
name|Depth
modifier|*
name|dp
init|=
operator|&
name|sp
operator|->
name|depths
index|[
name|j
index|]
decl_stmt|;
name|dp
operator|->
name|depth
operator|=
name|u
operator|.
name|dp
operator|->
name|depth
expr_stmt|;
name|dp
operator|->
name|nvisuals
operator|=
name|u
operator|.
name|dp
operator|->
name|nVisuals
expr_stmt|;
name|u
operator|.
name|dp
operator|=
operator|(
name|xDepth
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|u
operator|.
name|dp
operator|)
operator|+
name|sz_xDepth
operator|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|nvisuals
operator|>
literal|0
condition|)
block|{
name|dp
operator|->
name|visuals
operator|=
operator|(
name|Visual
operator|*
operator|)
name|Xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|dp
operator|->
name|nvisuals
operator|*
sizeof|sizeof
argument_list|(
name|Visual
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|visuals
operator|==
name|NULL
condition|)
block|{
name|OutOfMemory
argument_list|(
name|dpy
argument_list|,
name|setup
argument_list|)
expr_stmt|;
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|dp
operator|->
name|nvisuals
condition|;
name|k
operator|++
control|)
block|{
specifier|register
name|Visual
modifier|*
name|vp
init|=
operator|&
name|dp
operator|->
name|visuals
index|[
name|k
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|visualid
operator|=
name|u
operator|.
name|vp
operator|->
name|visualID
operator|)
operator|==
name|root_visualID
condition|)
name|sp
operator|->
name|root_visual
operator|=
name|vp
expr_stmt|;
name|vp
operator|->
name|class
operator|=
name|u
operator|.
name|vp
operator|->
name|class
expr_stmt|;
name|vp
operator|->
name|bits_per_rgb
operator|=
name|u
operator|.
name|vp
operator|->
name|bitsPerRGB
expr_stmt|;
name|vp
operator|->
name|map_entries
operator|=
name|u
operator|.
name|vp
operator|->
name|colormapEntries
expr_stmt|;
name|vp
operator|->
name|red_mask
operator|=
name|u
operator|.
name|vp
operator|->
name|redMask
expr_stmt|;
name|vp
operator|->
name|green_mask
operator|=
name|u
operator|.
name|vp
operator|->
name|greenMask
expr_stmt|;
name|vp
operator|->
name|blue_mask
operator|=
name|u
operator|.
name|vp
operator|->
name|blueMask
expr_stmt|;
name|vp
operator|->
name|ext_data
operator|=
name|NULL
expr_stmt|;
name|u
operator|.
name|vp
operator|=
operator|(
name|xVisualType
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|u
operator|.
name|vp
operator|)
operator|+
name|sz_xVisualType
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dp
operator|->
name|visuals
operator|=
operator|(
name|Visual
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/*  * Now start talking to the server to setup all other information...  */
name|Xfree
argument_list|(
name|setup
argument_list|)
expr_stmt|;
comment|/* all finished with setup information */
comment|/*  * Make sure default screen is legal.  */
if|if
condition|(
name|iscreen
operator|>=
name|dpy
operator|->
name|nscreens
condition|)
block|{
name|OutOfMemory
argument_list|(
name|dpy
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  * Set up other stuff clients are always going to use.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dpy
operator|->
name|nscreens
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|Screen
modifier|*
name|sp
init|=
operator|&
name|dpy
operator|->
name|screens
index|[
name|i
index|]
decl_stmt|;
name|XGCValues
name|values
decl_stmt|;
name|values
operator|.
name|foreground
operator|=
name|sp
operator|->
name|black_pixel
expr_stmt|;
name|values
operator|.
name|background
operator|=
name|sp
operator|->
name|white_pixel
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|default_gc
operator|=
name|XCreateGC
argument_list|(
name|dpy
argument_list|,
name|sp
operator|->
name|root
argument_list|,
name|GCForeground
operator||
name|GCBackground
argument_list|,
operator|&
name|values
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|OutOfMemory
argument_list|(
name|dpy
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/*  * call into synchronization routine so that all programs can be  * forced synchronize  */
operator|(
name|void
operator|)
name|XSynchronize
argument_list|(
name|dpy
argument_list|,
name|_Xdebug
argument_list|)
expr_stmt|;
comment|/*  * and done mucking with the display  */
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
comment|/* didn't exist, so didn't lock */
name|UnlockMutex
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
comment|/*  * get the resource manager database off the root window.  */
block|{
name|Atom
name|actual_type
decl_stmt|;
name|int
name|actual_format
decl_stmt|;
name|unsigned
name|long
name|nitems
decl_stmt|;
name|unsigned
name|long
name|leftover
decl_stmt|;
name|char
modifier|*
name|xdef
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|XGetWindowProperty
argument_list|(
name|dpy
argument_list|,
name|RootWindow
argument_list|(
name|dpy
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XA_RESOURCE_MANAGER
argument_list|,
literal|0L
argument_list|,
literal|100000000L
argument_list|,
name|False
argument_list|,
name|XA_STRING
argument_list|,
operator|&
name|actual_type
argument_list|,
operator|&
name|actual_format
argument_list|,
operator|&
name|nitems
argument_list|,
operator|&
name|leftover
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
operator|&
name|xdef
argument_list|)
operator|==
name|Success
condition|)
block|{
if|if
condition|(
operator|(
name|actual_type
operator|==
name|XA_STRING
operator|)
operator|&&
operator|(
name|actual_format
operator|==
literal|8
operator|)
condition|)
block|{
name|LockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|dpy
operator|->
name|xdefaults
operator|=
name|xdef
expr_stmt|;
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xdef
condition|)
block|{
name|Xfree
argument_list|(
name|xdef
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|MOTIFBC
block|{
specifier|extern
name|Display
modifier|*
name|_XHeadOfDisplayList
decl_stmt|;
name|_XHeadOfDisplayList
operator|=
name|dpy
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  * and return successfully  */
return|return
operator|(
name|dpy
operator|)
return|;
block|}
end_block

begin_comment
comment|/* OutOfMemory is called if malloc fails.  XOpenDisplay returns NULL    after this returns. */
end_comment

begin_expr_stmt
specifier|static
name|OutOfMemory
argument_list|(
argument|dpy
argument_list|,
argument|setup
argument_list|)
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|setup
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|_XDisconnectDisplay
argument_list|(
name|dpy
operator|->
name|fd
argument_list|)
expr_stmt|;
name|_XFreeDisplayStructure
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
if|if
condition|(
name|setup
condition|)
name|Xfree
argument_list|(
name|setup
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* XFreeDisplayStructure frees all the storage associated with a   * Display.  It is used by XOpenDisplay if it runs out of memory,  * and also by XCloseDisplay.   It needs to check whether all pointers  * are non-NULL before dereferencing them, since it may be called  * by XOpenDisplay before the Display structure is fully formed.  * XOpenDisplay must be sure to initialize all the pointers to NULL  * before the first possible call on this.  */
end_comment

begin_expr_stmt
name|_XFreeDisplayStructure
argument_list|(
name|dpy
argument_list|)
specifier|register
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
name|dpy
operator|->
name|ext_procs
condition|)
block|{
name|_XExtension
modifier|*
name|ext
init|=
name|dpy
operator|->
name|ext_procs
decl_stmt|;
name|dpy
operator|->
name|ext_procs
operator|=
name|ext
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ext
operator|->
name|name
condition|)
name|Xfree
argument_list|(
name|ext
operator|->
name|name
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ext
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dpy
operator|->
name|im_filters
condition|)
call|(
modifier|*
name|dpy
operator|->
name|free_funcs
operator|->
name|im_filters
call|)
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|cms
operator|.
name|clientCmaps
condition|)
call|(
modifier|*
name|dpy
operator|->
name|free_funcs
operator|->
name|clientCmaps
call|)
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|cms
operator|.
name|defaultCCCs
condition|)
call|(
modifier|*
name|dpy
operator|->
name|free_funcs
operator|->
name|defaultCCCs
call|)
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|cms
operator|.
name|perVisualIntensityMaps
condition|)
call|(
modifier|*
name|dpy
operator|->
name|free_funcs
operator|->
name|intensityMaps
call|)
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|atoms
condition|)
call|(
modifier|*
name|dpy
operator|->
name|free_funcs
operator|->
name|atoms
call|)
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|modifiermap
condition|)
call|(
modifier|*
name|dpy
operator|->
name|free_funcs
operator|->
name|modifiermap
call|)
argument_list|(
name|dpy
operator|->
name|modifiermap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|key_bindings
condition|)
call|(
modifier|*
name|dpy
operator|->
name|free_funcs
operator|->
name|key_bindings
call|)
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|context_db
condition|)
call|(
modifier|*
name|dpy
operator|->
name|free_funcs
operator|->
name|context_db
call|)
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|screens
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dpy
operator|->
name|nscreens
condition|;
name|i
operator|++
control|)
block|{
name|Screen
modifier|*
name|sp
init|=
operator|&
name|dpy
operator|->
name|screens
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|depths
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sp
operator|->
name|ndepths
condition|;
name|j
operator|++
control|)
block|{
name|Depth
modifier|*
name|dp
init|=
operator|&
name|sp
operator|->
name|depths
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|visuals
condition|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|dp
operator|->
name|nvisuals
condition|;
name|k
operator|++
control|)
name|_XFreeExtData
argument_list|(
name|dp
operator|->
name|visuals
index|[
name|k
index|]
operator|.
name|ext_data
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|visuals
argument_list|)
expr_stmt|;
block|}
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
operator|->
name|depths
argument_list|)
expr_stmt|;
block|}
name|_XFreeExtData
argument_list|(
name|sp
operator|->
name|ext_data
argument_list|)
expr_stmt|;
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dpy
operator|->
name|screens
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dpy
operator|->
name|pixmap_format
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dpy
operator|->
name|nformats
condition|;
name|i
operator|++
control|)
name|_XFreeExtData
argument_list|(
name|dpy
operator|->
name|pixmap_format
index|[
name|i
index|]
operator|.
name|ext_data
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dpy
operator|->
name|pixmap_format
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dpy
operator|->
name|display_name
condition|)
name|Xfree
argument_list|(
name|dpy
operator|->
name|display_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|vendor
condition|)
name|Xfree
argument_list|(
name|dpy
operator|->
name|vendor
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|buffer
condition|)
name|Xfree
argument_list|(
name|dpy
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|keysyms
condition|)
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dpy
operator|->
name|keysyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|xdefaults
condition|)
name|Xfree
argument_list|(
name|dpy
operator|->
name|xdefaults
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|error_vec
condition|)
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dpy
operator|->
name|error_vec
argument_list|)
expr_stmt|;
name|_XFreeExtData
argument_list|(
name|dpy
operator|->
name|ext_data
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dpy
operator|->
name|free_funcs
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dpy
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

