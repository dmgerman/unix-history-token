begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XcmsColNm.c,v 1.25 92/03/03 12:16:07 rws Exp $" */
end_comment

begin_comment
comment|/*  * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.  * 	All Rights Reserved  *   * This file is a component of an X Window System-specific implementation  * of Xcms based on the TekColor Color Management System.  Permission is  * hereby granted to use, copy, modify, sell, and otherwise distribute this  * software and its documentation for any purpose and without fee, provided  * that this copyright, permission, and disclaimer notice is reproduced in  * all copies of this software and in supporting documentation.  TekColor  * is a trademark of Tektronix, Inc.  *   * Tektronix makes no representation about the suitability of this software  * for any purpose.  It is provided "as is" and with all faults.  *   * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,  * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY  * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER  * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF  * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.  *  *	NAME  *		XcmsColNm.c  *  *	DESCRIPTION  *		Source for _XcmsLookupColorName().  *  *  */
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xcmsint.h"
end_include

begin_include
include|#
directive|include
file|<X11/Xos.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|XK_LATIN1
end_define

begin_include
include|#
directive|include
file|<X11/keysymdef.h>
end_include

begin_comment
comment|/*  *      EXTERNS  *              External declarations required locally to this package  *              that are not already declared in any of the included header  *		files (external includes or internal includes).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|X_NOT_STDC_ENV
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|qsort
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|bsearch
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|XcmsColorSpace
modifier|*
modifier|*
name|_XcmsDIColorSpaces
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|Status
name|LoadColornameDB
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_XcmsCopyISOLatin1Lowered
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *      LOCAL DEFINES  *		#define declarations local to this package.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XCMSDB
end_ifndef

begin_define
define|#
directive|define
name|XCMSDB
value|"/usr/lib/X11/Xcms.txt"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|isgraph
end_ifndef

begin_define
define|#
directive|define
name|isgraph
parameter_list|(
name|c
parameter_list|)
value|(isprint((c))&& !isspace((c)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|XCMSDB_MAXLINELEN
end_ifndef

begin_define
define|#
directive|define
name|XCMSDB_MAXLINELEN
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FORMAT_VERSION
value|"0.1"
end_define

begin_define
define|#
directive|define
name|START_TOKEN
value|"XCMS_COLORDB_START"
end_define

begin_define
define|#
directive|define
name|END_TOKEN
value|"XCMS_COLORDB_END"
end_define

begin_define
define|#
directive|define
name|DELIM_CHAR
value|'\t'
end_define

begin_define
define|#
directive|define
name|NOT_VISITED
value|0x0
end_define

begin_define
define|#
directive|define
name|VISITED
value|0x1
end_define

begin_define
define|#
directive|define
name|CYCLE
value|0xFFFF
end_define

begin_define
define|#
directive|define
name|XcmsDbInitNone
value|-1
end_define

begin_define
define|#
directive|define
name|XcmsDbInitFailure
value|0
end_define

begin_define
define|#
directive|define
name|XcmsDbInitSuccess
value|1
end_define

begin_comment
comment|/*  *      LOCAL TYPEDEFS  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_XcmsPair
block|{
name|char
modifier|*
name|first
decl_stmt|;
name|char
modifier|*
name|second
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|}
name|XcmsPair
typedef|;
end_typedef

begin_comment
comment|/*  *      LOCAL VARIABLES  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|XcmsColorDbState
init|=
name|XcmsDbInitNone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nEntries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XcmsPair
modifier|*
name|pairs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|whitePtStr
index|[]
init|=
literal|"WhitePoint"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/************************************************************************  *									*  *			PRIVATE ROUTINES				*  *									*  ************************************************************************/
end_comment

begin_comment
comment|/*  *	NAME  *		_XcmsColorSpaceOfString  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|XcmsColorSpace
modifier|*
name|_XcmsColorSpaceOfString
parameter_list|(
name|ccc
parameter_list|,
name|color_string
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|char
modifier|*
name|color_string
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Returns a pointer to the color space structure  *		(XcmsColorSpace) associated with the specified color string.  *  *	RETURNS  *		Pointer to matching XcmsColorSpace structure if found;  *		otherwise NULL.  *  *	CAVEATS  *  */
block|{
name|XcmsColorSpace
modifier|*
modifier|*
name|papColorSpaces
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|pchar
decl_stmt|;
if|if
condition|(
operator|(
name|pchar
operator|=
name|strchr
argument_list|(
name|color_string
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|pchar
operator|-
name|color_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*      * First try Device-Independent color spaces      */
name|papColorSpaces
operator|=
name|_XcmsDIColorSpaces
expr_stmt|;
if|if
condition|(
name|papColorSpaces
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|papColorSpaces
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|(
operator|*
name|papColorSpaces
operator|)
operator|->
name|prefix
argument_list|,
name|color_string
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
operator|(
operator|*
name|papColorSpaces
operator|)
operator|->
name|prefix
operator|)
index|[
name|n
index|]
condition|)
block|{
return|return
operator|(
operator|*
name|papColorSpaces
operator|)
return|;
block|}
name|papColorSpaces
operator|++
expr_stmt|;
block|}
block|}
comment|/*      * Next try Device-Dependent color spaces      */
name|papColorSpaces
operator|=
operator|(
operator|(
name|XcmsFunctionSet
operator|*
operator|)
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|functionSet
operator|)
operator|->
name|DDColorSpaces
expr_stmt|;
if|if
condition|(
name|papColorSpaces
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|papColorSpaces
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|(
operator|*
name|papColorSpaces
operator|)
operator|->
name|prefix
argument_list|,
name|color_string
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
operator|(
operator|*
name|papColorSpaces
operator|)
operator|->
name|prefix
operator|)
index|[
name|n
index|]
condition|)
block|{
return|return
operator|(
operator|*
name|papColorSpaces
operator|)
return|;
block|}
name|papColorSpaces
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		_XcmsParseColorString  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|int
name|_XcmsParseColorString
parameter_list|(
name|ccc
parameter_list|,
name|color_string
parameter_list|,
name|pColor
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|char
modifier|*
name|color_string
decl_stmt|;
name|XcmsColor
modifier|*
name|pColor
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Assuming color_string contains a numerical string color  *		specification, attempts to parse a string into an  *		XcmsColor structure.		  *  *	RETURNS  *		0 if failed; otherwise non-zero.  *  *	CAVEATS  *		A color string containing a numerical color specification  *		must be in ISO Latin-1 encoding!  */
block|{
name|XcmsColorSpace
modifier|*
name|pColorSpace
decl_stmt|;
name|char
name|string_buf
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|string_lowered
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|ccc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * While copying color_string to string_lowered, convert to lowercase      */
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|color_string
argument_list|)
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|string_buf
argument_list|)
condition|)
block|{
name|string_lowered
operator|=
operator|(
name|char
operator|*
operator|)
name|Xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|string_lowered
operator|=
name|string_buf
expr_stmt|;
block|}
name|_XcmsCopyISOLatin1Lowered
argument_list|(
name|string_lowered
argument_list|,
name|color_string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string_lowered
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
operator|(
name|pColorSpace
operator|=
name|_XcmsColorSpaceOfString
argument_list|(
name|ccc
argument_list|,
literal|"rgb:"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
call|(
modifier|*
name|pColorSpace
operator|->
name|parseString
call|)
argument_list|(
name|string_lowered
argument_list|,
name|pColor
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|string_buf
argument_list|)
condition|)
name|Xfree
argument_list|(
name|string_lowered
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
block|}
if|if
condition|(
operator|(
name|pColorSpace
operator|=
name|_XcmsColorSpaceOfString
argument_list|(
name|ccc
argument_list|,
name|string_lowered
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
call|(
modifier|*
name|pColorSpace
operator|->
name|parseString
call|)
argument_list|(
name|string_lowered
argument_list|,
name|pColor
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|string_buf
argument_list|)
condition|)
name|Xfree
argument_list|(
name|string_lowered
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|string_buf
argument_list|)
condition|)
name|Xfree
argument_list|(
name|string_lowered
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		FirstCmp - Compare color names of pair recs  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|int
name|FirstCmp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
if|#
directive|if
name|__STDC__
specifier|const
name|void
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|XcmsPair
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	DESCRIPTION  *		Compares the color names of XcmsColorTuples.  *		This routine is public to allow access from qsort???.  *  *	RETURNS  *		0 if equal;  *< 0 if first precedes second,  *> 0 if first succeeds second.  *  */
end_comment

begin_block
block|{
return|return
operator|(
name|strcmp
argument_list|(
operator|(
operator|(
name|XcmsPair
operator|*
operator|)
name|p1
operator|)
operator|->
name|first
argument_list|,
operator|(
operator|(
name|XcmsPair
operator|*
operator|)
name|p2
operator|)
operator|->
name|first
argument_list|)
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		stringSectionSize - determine memory needed for strings  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|void
name|SetNoVisit
parameter_list|()
comment|/*  *	DESCRIPTION  *  *	RETURNS  *		void  *  */
block|{
name|int
name|i
decl_stmt|;
name|XcmsPair
modifier|*
name|pair
init|=
name|pairs
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nEntries
condition|;
name|i
operator|++
operator|,
name|pair
operator|++
control|)
block|{
if|if
condition|(
name|pair
operator|->
name|flag
operator|!=
name|CYCLE
condition|)
block|{
name|pair
operator|->
name|flag
operator|=
name|NOT_VISITED
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		field2 - extract two fields  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|int
name|field2
parameter_list|(
name|pBuf
parameter_list|,
name|delim
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|)
name|char
modifier|*
name|pBuf
decl_stmt|;
name|char
name|delim
decl_stmt|;
comment|/* in:  field delimiter */
name|char
modifier|*
modifier|*
name|p1
decl_stmt|;
comment|/* in/out: pointer to pointer to field 1 */
name|char
modifier|*
modifier|*
name|p2
decl_stmt|;
comment|/* in/out: pointer to pointer to field 2 */
comment|/*  *	DESCRIPTION  *		Extracts two fields from a "record".  *  *	RETURNS  *		XcmsSuccess if succeeded, otherwise XcmsFailure.  *  */
block|{
operator|*
name|p1
operator|=
operator|*
name|p2
operator|=
name|NULL
expr_stmt|;
comment|/* Find Field 1 */
while|while
condition|(
operator|!
name|isgraph
argument_list|(
operator|*
name|pBuf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|pBuf
operator|!=
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|pBuf
operator|!=
literal|'\0'
operator|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|pBuf
argument_list|)
operator|||
operator|(
operator|*
name|pBuf
operator|==
name|delim
operator|)
condition|)
block|{
name|pBuf
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|p1
operator|=
name|pBuf
expr_stmt|;
comment|/* Find end of Field 2 */
while|while
condition|(
name|isprint
argument_list|(
operator|*
name|pBuf
argument_list|)
operator|&&
operator|(
operator|*
name|pBuf
operator|!=
name|delim
operator|)
condition|)
block|{
name|pBuf
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|pBuf
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|pBuf
operator|==
literal|'\0'
operator|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|pBuf
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|pBuf
operator|==
name|delim
operator|)
condition|)
block|{
operator|*
name|pBuf
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* stuff end of string character */
block|}
else|else
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
comment|/* Find Field 2 */
while|while
condition|(
operator|!
name|isgraph
argument_list|(
operator|*
name|pBuf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|pBuf
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|pBuf
operator|==
literal|'\0'
operator|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|pBuf
argument_list|)
operator|||
operator|(
operator|*
name|pBuf
operator|==
name|delim
operator|)
condition|)
block|{
name|pBuf
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|p2
operator|=
name|pBuf
expr_stmt|;
comment|/* Find end of Field 2 */
while|while
condition|(
name|isprint
argument_list|(
operator|*
name|pBuf
argument_list|)
operator|&&
operator|(
operator|*
name|pBuf
operator|!=
name|delim
operator|)
condition|)
block|{
name|pBuf
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pBuf
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|pBuf
operator|=
literal|'\0'
expr_stmt|;
comment|/* stuff end of string character */
block|}
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		_XcmsLookupColorName - Lookup DB entry for a color name  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|Status
name|_XcmsLookupColorName
parameter_list|(
name|ccc
parameter_list|,
name|name
parameter_list|,
name|pColor
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
name|XcmsColor
modifier|*
name|pColor
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Searches for an entry in the Device-Independent Color Name  *		Database for the specified string.  *  *	RETURNS  *		XcmsFailure if failed to find a matching entry in  *			the database.  *		XcmsSuccess if succeeded in converting color name to  *			XcmsColor.  *		_XCMS_NEWNAME if succeeded in converting color string (which  *			is a color name to yet another color name.  Note  *			that the new name is passed back via 'name'.  */
block|{
name|Status
name|retval
init|=
literal|0
decl_stmt|;
name|char
name|name_lowered_64
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|name_lowered
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|left
decl_stmt|,
name|right
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|tmpName
decl_stmt|;
name|XcmsPair
modifier|*
name|pair
decl_stmt|;
comment|/*      * Check state of Database:      *		XcmsDbInitNone      *		XcmsDbInitSuccess      *		XcmsDbInitFailure      */
if|if
condition|(
name|XcmsColorDbState
operator|==
name|XcmsDbInitFailure
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
name|XcmsColorDbState
operator|==
name|XcmsDbInitNone
condition|)
block|{
if|if
condition|(
operator|!
name|LoadColornameDB
argument_list|()
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
block|}
name|SetNoVisit
argument_list|()
expr_stmt|;
comment|/*      * While copying name to name_lowered, convert to lowercase      */
name|tmpName
operator|=
operator|*
name|name
expr_stmt|;
name|Retry
label|:
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|tmpName
argument_list|)
operator|)
operator|>
literal|63
condition|)
block|{
name|name_lowered
operator|=
operator|(
name|char
operator|*
operator|)
name|Xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name_lowered
operator|=
name|name_lowered_64
expr_stmt|;
block|}
name|_XcmsCopyISOLatin1Lowered
argument_list|(
name|name_lowered
argument_list|,
name|tmpName
argument_list|)
expr_stmt|;
comment|/*      * Now, remove spaces.      */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|name_lowered
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|name_lowered
index|[
name|i
operator|++
index|]
operator|=
name|name_lowered
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
name|name_lowered
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|left
operator|=
literal|0
expr_stmt|;
name|right
operator|=
name|nEntries
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|left
operator|<=
name|right
condition|)
block|{
name|i
operator|=
operator|(
name|left
operator|+
name|right
operator|)
operator|>>
literal|1
expr_stmt|;
name|pair
operator|=
operator|&
name|pairs
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
name|strcmp
argument_list|(
name|name_lowered
argument_list|,
name|pair
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|right
operator|=
name|i
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|>
literal|0
condition|)
name|left
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|63
condition|)
name|Xfree
argument_list|(
name|name_lowered
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|>
name|right
condition|)
block|{
if|if
condition|(
name|retval
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|!=
name|tmpName
condition|)
block|{
operator|*
name|name
operator|=
name|tmpName
expr_stmt|;
block|}
return|return
operator|(
name|_XCMS_NEWNAME
operator|)
return|;
block|}
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
name|pair
operator|->
name|flag
operator|==
name|CYCLE
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
name|pair
operator|->
name|flag
operator|==
name|VISITED
condition|)
block|{
name|pair
operator|->
name|flag
operator|=
name|CYCLE
expr_stmt|;
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
name|_XcmsParseColorString
argument_list|(
name|ccc
argument_list|,
name|pair
operator|->
name|second
argument_list|,
name|pColor
argument_list|)
operator|==
name|XcmsSuccess
condition|)
block|{
comment|/* f2 contains a numerical string specification */
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
else|else
block|{
comment|/* f2 does not contain a numerical string specification */
name|tmpName
operator|=
name|pair
operator|->
name|second
expr_stmt|;
name|pair
operator|->
name|flag
operator|=
name|VISITED
expr_stmt|;
name|retval
operator|=
literal|2
expr_stmt|;
goto|goto
name|Retry
goto|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		RemoveSpaces  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|int
name|RemoveSpaces
parameter_list|(
name|pString
parameter_list|)
name|char
modifier|*
name|pString
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Removes spaces from string.  *  *	RETURNS  *		Void  *  */
block|{
name|int
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cptr
decl_stmt|;
comment|/* REMOVE SPACES */
name|cptr
operator|=
name|pString
expr_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|pString
argument_list|)
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|cptr
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|cptr
argument_list|)
condition|)
block|{
operator|*
name|pString
operator|++
operator|=
operator|*
name|cptr
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|pString
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		stringSectionSize - determine memory needed for strings  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|int
name|stringSectionSize
parameter_list|(
name|stream
parameter_list|,
name|pNumEntries
parameter_list|,
name|pSectionSize
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
modifier|*
name|pNumEntries
decl_stmt|;
name|int
modifier|*
name|pSectionSize
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Determines the amount of memory required to store the  *		color name strings and also the number of strings.  *  *	RETURNS  *		XcmsSuccess if succeeded, otherwise XcmsFailure.  *  */
block|{
name|char
name|buf
index|[
name|XCMSDB_MAXLINELEN
index|]
decl_stmt|;
name|char
name|token
index|[
name|XCMSDB_MAXLINELEN
index|]
decl_stmt|;
name|char
name|token2
index|[
name|XCMSDB_MAXLINELEN
index|]
decl_stmt|;
name|char
modifier|*
name|pBuf
decl_stmt|;
name|char
modifier|*
name|f1
decl_stmt|;
name|char
modifier|*
name|f2
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|pNumEntries
operator|=
literal|0
expr_stmt|;
operator|*
name|pSectionSize
operator|=
literal|0
expr_stmt|;
comment|/*      * Advance to START_TOKEN      *	 Anything before is just considered as comments.      */
while|while
condition|(
operator|(
name|pBuf
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|XCMSDB_MAXLINELEN
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|token
argument_list|,
name|token2
argument_list|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|token
argument_list|,
name|START_TOKEN
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|token2
argument_list|,
name|FORMAT_VERSION
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* text file not in the right format */
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
break|break;
block|}
comment|/* else it was just a blank line or comment */
block|}
if|if
condition|(
name|pBuf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|pBuf
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|XCMSDB_MAXLINELEN
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|token
argument_list|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|token
argument_list|,
name|END_TOKEN
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|field2
argument_list|(
name|buf
argument_list|,
name|DELIM_CHAR
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|f2
argument_list|)
operator|!=
name|XcmsSuccess
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
operator|(
operator|*
name|pNumEntries
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|pSectionSize
operator|)
operator|+=
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|f1
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|f1
operator|++
control|)
block|{
comment|/* REMOVE SPACES FROM COUNT */
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|f1
argument_list|)
condition|)
block|{
operator|(
operator|*
name|pSectionSize
operator|)
operator|--
expr_stmt|;
block|}
block|}
operator|(
operator|*
name|pSectionSize
operator|)
operator|+=
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|f2
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|f2
operator|++
control|)
block|{
comment|/* REMOVE SPACES FROM COUNT */
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|f2
argument_list|)
condition|)
block|{
operator|(
operator|*
name|pSectionSize
operator|)
operator|--
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		ReadColornameDB - Read the Color Name Database  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|Status
name|ReadColornameDB
parameter_list|(
name|stream
parameter_list|,
name|pRec
parameter_list|,
name|pString
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|XcmsPair
modifier|*
name|pRec
decl_stmt|;
name|char
modifier|*
name|pString
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Loads the Color Name Database from a text file.  *  *	RETURNS  *		XcmsSuccess if succeeded, otherwise XcmsFailure.  *  */
block|{
name|char
name|buf
index|[
name|XCMSDB_MAXLINELEN
index|]
decl_stmt|;
name|char
name|token
index|[
name|XCMSDB_MAXLINELEN
index|]
decl_stmt|;
name|char
name|token2
index|[
name|XCMSDB_MAXLINELEN
index|]
decl_stmt|;
name|char
modifier|*
name|f1
decl_stmt|;
name|char
modifier|*
name|f2
decl_stmt|;
name|char
modifier|*
name|pBuf
decl_stmt|;
comment|/*      * Advance to START_TOKEN      *	 Anything before is just considered as comments.      */
while|while
condition|(
operator|(
name|pBuf
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|XCMSDB_MAXLINELEN
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|token
argument_list|,
name|token2
argument_list|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|token
argument_list|,
name|START_TOKEN
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|token2
argument_list|,
name|FORMAT_VERSION
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* text file not in the right format */
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
break|break;
block|}
comment|/* else it was just a blank line or comment */
block|}
if|if
condition|(
name|pBuf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
comment|/*      * Process lines between START_TOKEN to END_TOKEN      */
while|while
condition|(
operator|(
name|pBuf
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|XCMSDB_MAXLINELEN
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|token
argument_list|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|token
argument_list|,
name|END_TOKEN
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	     * Found END_TOKEN so break out of for loop 	     */
break|break;
block|}
comment|/* 	 * Get pairs 	 */
if|if
condition|(
name|field2
argument_list|(
name|buf
argument_list|,
name|DELIM_CHAR
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|f2
argument_list|)
operator|!=
name|XcmsSuccess
condition|)
block|{
comment|/* Invalid line */
continue|continue;
block|}
comment|/* 	 * Add strings 	 */
comment|/* Left String */
name|pRec
operator|->
name|first
operator|=
name|pString
expr_stmt|;
name|_XcmsCopyISOLatin1Lowered
argument_list|(
name|pString
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|pString
operator|+=
operator|(
literal|1
operator|+
name|RemoveSpaces
argument_list|(
name|pString
argument_list|)
operator|)
expr_stmt|;
name|pRec
operator|->
name|second
operator|=
name|pString
expr_stmt|;
comment|/* Right String */
name|_XcmsCopyISOLatin1Lowered
argument_list|(
name|pString
argument_list|,
name|f2
argument_list|)
expr_stmt|;
name|pString
operator|+=
name|RemoveSpaces
argument_list|(
name|pString
argument_list|)
operator|+
literal|1
expr_stmt|;
name|pRec
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		LoadColornameDB - Load the Color Name Database  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|Status
name|LoadColornameDB
parameter_list|()
comment|/*  *	DESCRIPTION  *		Loads the Color Name Database from a text file.  *  *	RETURNS  *		XcmsSuccess if succeeded, otherwise XcmsFailure.  *  */
block|{
name|int
name|size
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|pathname
decl_stmt|;
name|struct
name|stat
name|txt
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* use and name of this env var is not part of the standard */
comment|/* implementation-dependent feature */
if|if
condition|(
operator|(
name|pathname
operator|=
name|getenv
argument_list|(
literal|"XCMSDB"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pathname
operator|=
name|XCMSDB
expr_stmt|;
block|}
name|length
operator|=
name|strlen
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|==
literal|0
operator|)
operator|||
operator|(
name|length
operator|>=
operator|(
name|BUFSIZ
operator|-
literal|5
operator|)
operator|)
condition|)
block|{
name|XcmsColorDbState
operator|=
name|XcmsDbInitFailure
expr_stmt|;
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|pathname
argument_list|,
operator|&
name|txt
argument_list|)
condition|)
block|{
comment|/* can't stat file */
name|XcmsColorDbState
operator|=
name|XcmsDbInitFailure
expr_stmt|;
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|stream
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|stringSectionSize
argument_list|(
name|stream
argument_list|,
operator|&
name|nEntries
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|Xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|pairs
operator|=
operator|(
name|XcmsPair
operator|*
operator|)
name|Xcalloc
argument_list|(
name|nEntries
argument_list|,
sizeof|sizeof
argument_list|(
name|XcmsPair
argument_list|)
argument_list|)
expr_stmt|;
name|ReadColornameDB
argument_list|(
name|stream
argument_list|,
name|pairs
argument_list|,
name|strings
argument_list|)
expr_stmt|;
comment|/*      * sort the pair recs      */
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pairs
argument_list|,
name|nEntries
argument_list|,
sizeof|sizeof
argument_list|(
name|XcmsPair
argument_list|)
argument_list|,
name|FirstCmp
argument_list|)
expr_stmt|;
name|XcmsColorDbState
operator|=
name|XcmsDbInitSuccess
expr_stmt|;
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		XcmsFreeColorDB - Free Color Name Database  *  *	SYNOPSIS  */
end_comment

begin_function
name|void
name|XcmsFreeColorDB
parameter_list|()
comment|/*  *	DESCRIPTION  *		Creates  *  *	RETURNS  *		XcmsSuccess if succeeded, otherwise XcmsFailure.  *  */
block|{
comment|/*      * Check if XcmsColorDB has been intialized      */
if|if
condition|(
name|XcmsColorDbState
operator|!=
name|XcmsDbInitSuccess
condition|)
block|{
return|return;
block|}
comment|/*      * Free memory      */
name|free
argument_list|(
name|strings
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pairs
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/************************************************************************  *									*  *			API PRIVATE ROUTINES				*  *									*  ************************************************************************/
end_comment

begin_comment
comment|/*  *	NAME  *		_XcmsCopyISOLatin1Lowered  *  *	SYNOPSIS  */
end_comment

begin_function
name|void
name|_XcmsCopyISOLatin1Lowered
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|char
modifier|*
name|dst
decl_stmt|,
decl|*
name|src
decl_stmt|;
end_function

begin_comment
comment|/*  *	DESCRIPTION  *		ISO Latin-1 case conversion routine  *		Identical to XmuCopyISOLatin1Lowered() but provided here  *		to eliminate need to link with libXmu.a.  *  *		IMPLEMENTORS NOTE:  *		    This routine is also used in XcmsFormatOfPrefix.  *  *	RETURNS  *		Void  *  */
end_comment

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|dest
decl_stmt|,
modifier|*
name|source
decl_stmt|;
for|for
control|(
name|dest
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dst
operator|,
name|source
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|src
init|;
operator|*
name|source
condition|;
name|source
operator|++
operator|,
name|dest
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|source
operator|>=
name|XK_A
operator|)
operator|&&
operator|(
operator|*
name|source
operator|<=
name|XK_Z
operator|)
condition|)
operator|*
name|dest
operator|=
operator|*
name|source
operator|+
operator|(
name|XK_a
operator|-
name|XK_A
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|source
operator|>=
name|XK_Agrave
operator|)
operator|&&
operator|(
operator|*
name|source
operator|<=
name|XK_Odiaeresis
operator|)
condition|)
operator|*
name|dest
operator|=
operator|*
name|source
operator|+
operator|(
name|XK_agrave
operator|-
name|XK_Agrave
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|source
operator|>=
name|XK_Ooblique
operator|)
operator|&&
operator|(
operator|*
name|source
operator|<=
name|XK_Thorn
operator|)
condition|)
operator|*
name|dest
operator|=
operator|*
name|source
operator|+
operator|(
name|XK_oslash
operator|-
name|XK_Ooblique
operator|)
expr_stmt|;
else|else
operator|*
name|dest
operator|=
operator|*
name|source
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		_XcmsResolveColorString -   *  *	SYNOPSIS  */
end_comment

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|Status
name|_XcmsResolveColorString
parameter_list|(
name|XcmsCCC
name|ccc
parameter_list|,
name|_Xconst
name|char
modifier|*
modifier|*
name|color_string
parameter_list|,
name|XcmsColor
modifier|*
name|pColor_exact_return
parameter_list|,
name|XcmsColorFormat
name|result_format
parameter_list|)
else|#
directive|else
function|Status _XcmsResolveColorString
parameter_list|(
name|ccc
parameter_list|,
name|color_string
parameter_list|,
name|pColor_exact_return
parameter_list|,
name|result_format
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|char
modifier|*
modifier|*
name|color_string
decl_stmt|;
name|XcmsColor
modifier|*
name|pColor_exact_return
decl_stmt|;
name|XcmsColorFormat
name|result_format
decl_stmt|;
endif|#
directive|endif
comment|/*  *	DESCRIPTION  *		The XcmsLookupColor function finds the color specification  *		associated with a color name in the Device-Independent Color  *		Name Database.  *	RETURNS  *		XcmsFailure if failed to parse string or find any entry in  *			the database.  *		XcmsSuccess if succeeded in converting color string to  *			XcmsColor.  *		_XCMS_NEWNAME if succeeded in converting color string (which  *			is a color name to yet another color name.  Note  *			that the new color name is returned via 'name'.  *  *		This function returns both the color specification found in the  *		database (db specification) and the color specification for the  *		color displayable by the specified screen (screen  *		specification).  The calling routine sets the format for these  *		returned specifications in the XcmsColor format component.  *		If XcmsUndefinedFormat, the specification is returned in the  *		format used to store the color in the database.  */
block|{
name|XcmsColor
name|dbWhitePt
decl_stmt|;
comment|/* whitePt associated with pColor_exact_return*/
comment|/*    the screen's white point */
name|XcmsColor
modifier|*
name|pClientWhitePt
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|char
modifier|*
name|strptr
init|=
name|whitePtStr
decl_stmt|;
comment|/*  * 0. Check for invalid arguments.  */
if|if
condition|(
name|ccc
operator|==
name|NULL
operator|||
operator|(
operator|*
name|color_string
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|pColor_exact_return
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
comment|/*  * 1. First attempt to parse the string  *    If successful, then convert the specification to the target format  *    and return.  */
if|if
condition|(
name|_XcmsParseColorString
argument_list|(
name|ccc
argument_list|,
operator|*
name|color_string
argument_list|,
name|pColor_exact_return
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|result_format
operator|!=
name|XcmsUndefinedFormat
operator|&&
name|pColor_exact_return
operator|->
name|format
operator|!=
name|result_format
condition|)
block|{
comment|/* need to be converted to the target format */
return|return
operator|(
name|XcmsConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColor_exact_return
argument_list|,
literal|1
argument_list|,
name|result_format
argument_list|,
operator|(
name|Bool
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
block|}
comment|/*  * 2. Attempt to find it in the DI Color Name Database  */
comment|/*      * a. Convert String into a XcmsColor structure      *       Attempt to extract the specification for color_string from the      *       DI Database (pColor_exact_return).  If the DI Database does not      *	     have this entry, then return failure.      */
name|retval
operator|=
name|_XcmsLookupColorName
argument_list|(
name|ccc
argument_list|,
name|color_string
argument_list|,
name|pColor_exact_return
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|_XCMS_NEWNAME
condition|)
block|{
comment|/* color_string replaced with a color name */
return|return
operator|(
name|retval
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|retval
operator|==
name|XcmsFailure
operator|)
operator|||
operator|(
name|pColor_exact_return
operator|->
name|format
operator|==
name|XcmsUndefinedFormat
operator|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
comment|/*      * b. If result_format not defined, then assume target format      *	  is the exact format.      */
if|if
condition|(
name|result_format
operator|==
name|XcmsUndefinedFormat
condition|)
block|{
name|result_format
operator|=
name|pColor_exact_return
operator|->
name|format
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ClientWhitePointOfCCC
argument_list|(
name|ccc
argument_list|)
operator|)
operator|->
name|format
operator|==
name|XcmsUndefinedFormat
condition|)
block|{
name|pClientWhitePt
operator|=
name|ScreenWhitePointOfCCC
argument_list|(
name|ccc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pClientWhitePt
operator|=
name|ClientWhitePointOfCCC
argument_list|(
name|ccc
argument_list|)
expr_stmt|;
block|}
comment|/*      * c. Convert to the target format, making adjustments for white      *	  point differences as necessary.      */
if|if
condition|(
name|XCMS_DD_ID
argument_list|(
name|pColor_exact_return
operator|->
name|format
argument_list|)
condition|)
block|{
comment|/* 	 * The spec format is Device-Dependent, therefore assume the 	 *    its white point is the Screen White Point. 	 */
if|if
condition|(
name|XCMS_DD_ID
argument_list|(
name|result_format
argument_list|)
condition|)
block|{
comment|/* 	     * Target format is Device-Dependent 	     *	Therefore, DD --> DD conversion 	     */
return|return
operator|(
name|_XcmsDDConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColor_exact_return
argument_list|,
literal|1
argument_list|,
name|result_format
argument_list|,
operator|(
name|Bool
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* 	     * Target format is Device-Independent 	     *	Therefore, DD --> DI conversion 	     */
if|if
condition|(
name|ccc
operator|->
name|whitePtAdjProc
operator|&&
operator|!
name|_XcmsEqualWhitePts
argument_list|(
name|ccc
argument_list|,
name|pClientWhitePt
argument_list|,
name|ScreenWhitePointOfCCC
argument_list|(
name|ccc
argument_list|)
argument_list|)
condition|)
block|{
return|return
operator|(
call|(
modifier|*
name|ccc
operator|->
name|whitePtAdjProc
call|)
argument_list|(
name|ccc
argument_list|,
name|ScreenWhitePointOfCCC
argument_list|(
name|ccc
argument_list|)
argument_list|,
name|pClientWhitePt
argument_list|,
name|result_format
argument_list|,
name|pColor_exact_return
argument_list|,
literal|1
argument_list|,
operator|(
name|Bool
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|_XcmsDDConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColor_exact_return
argument_list|,
literal|1
argument_list|,
name|XcmsCIEXYZFormat
argument_list|,
operator|(
name|Bool
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|XcmsFailure
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
return|return
operator|(
name|_XcmsDIConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColor_exact_return
argument_list|,
name|pClientWhitePt
argument_list|,
literal|1
argument_list|,
name|result_format
argument_list|)
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* 	 * The spec format is Device-Independent, therefore attempt 	 * to find a database white point. 	 * 	 * If the Database does not have a white point, then assume the 	 * database white point is the same as the Screen White Point. 	 */
if|if
condition|(
name|_XcmsLookupColorName
argument_list|(
name|ccc
argument_list|,
operator|&
name|strptr
argument_list|,
operator|&
name|dbWhitePt
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|screenWhitePt
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dbWhitePt
argument_list|,
sizeof|sizeof
argument_list|(
name|XcmsColor
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XCMS_DD_ID
argument_list|(
name|result_format
argument_list|)
condition|)
block|{
comment|/* 	     * Target format is Device-Dependent 	     *	Therefore, DI --> DD conversion 	     */
if|if
condition|(
name|ccc
operator|->
name|whitePtAdjProc
operator|&&
operator|!
name|_XcmsEqualWhitePts
argument_list|(
name|ccc
argument_list|,
operator|&
name|dbWhitePt
argument_list|,
name|ScreenWhitePointOfCCC
argument_list|(
name|ccc
argument_list|)
argument_list|)
condition|)
block|{
return|return
operator|(
call|(
modifier|*
name|ccc
operator|->
name|whitePtAdjProc
call|)
argument_list|(
name|ccc
argument_list|,
operator|&
name|dbWhitePt
argument_list|,
name|ScreenWhitePointOfCCC
argument_list|(
name|ccc
argument_list|)
argument_list|,
name|result_format
argument_list|,
name|pColor_exact_return
argument_list|,
literal|1
argument_list|,
operator|(
name|Bool
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|pColor_exact_return
operator|->
name|format
operator|!=
name|XcmsCIEXYZFormat
condition|)
block|{
if|if
condition|(
name|_XcmsDIConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColor_exact_return
argument_list|,
operator|&
name|dbWhitePt
argument_list|,
literal|1
argument_list|,
name|XcmsCIEXYZFormat
argument_list|)
operator|==
name|XcmsFailure
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
block|}
return|return
operator|(
name|_XcmsDDConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColor_exact_return
argument_list|,
literal|1
argument_list|,
name|result_format
argument_list|,
operator|(
name|Bool
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 	     * Target format is Device-Independent 	     *	Therefore, DI --> DI conversion 	     */
if|if
condition|(
name|ccc
operator|->
name|whitePtAdjProc
operator|&&
operator|!
name|_XcmsEqualWhitePts
argument_list|(
name|ccc
argument_list|,
operator|&
name|dbWhitePt
argument_list|,
name|pClientWhitePt
argument_list|)
condition|)
block|{
comment|/* 		 * The calling routine wants to resolve this color 		 * in terms if it's white point (i.e. Client White Point). 		 * Therefore, apply white adjustment for the displacement 		 * between dbWhitePt to clientWhitePt. 		 */
return|return
operator|(
call|(
modifier|*
name|ccc
operator|->
name|whitePtAdjProc
call|)
argument_list|(
name|ccc
argument_list|,
operator|&
name|dbWhitePt
argument_list|,
name|pClientWhitePt
argument_list|,
name|result_format
argument_list|,
name|pColor_exact_return
argument_list|,
literal|1
argument_list|,
operator|(
name|Bool
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|_XcmsEqualWhitePts
argument_list|(
name|ccc
argument_list|,
operator|&
name|dbWhitePt
argument_list|,
name|pClientWhitePt
argument_list|)
condition|)
block|{
comment|/* 		 * Can use either dbWhitePt or pClientWhitePt to 		 * convert to the result_format. 		 */
if|if
condition|(
name|pColor_exact_return
operator|->
name|format
operator|==
name|result_format
condition|)
block|{
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|_XcmsDIConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColor_exact_return
argument_list|,
operator|&
name|dbWhitePt
argument_list|,
literal|1
argument_list|,
name|result_format
argument_list|)
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * Need to convert to a white point independent color 		 * space (let's choose CIEXYZ) then convert to the 		 * target color space.  Why? Lets assume that 		 * pColor_exact_return->format and result format 		 * are white point dependent format (e.g., CIELUV, CIELAB, 		 * TekHVC ... same or any combination). If so, we'll 		 * need to convert the color with dbWhitePt to an absolute 		 * spec (i.e.  non-white point dependent) then convert that 		 * absolute value with clientWhitePt to the result_format. 		 */
if|if
condition|(
name|pColor_exact_return
operator|->
name|format
operator|!=
name|XcmsCIEXYZFormat
condition|)
block|{
if|if
condition|(
name|_XcmsDIConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColor_exact_return
argument_list|,
operator|&
name|dbWhitePt
argument_list|,
literal|1
argument_list|,
name|XcmsCIEXYZFormat
argument_list|)
operator|==
name|XcmsFailure
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
block|}
if|if
condition|(
name|result_format
operator|==
name|XcmsCIEXYZFormat
condition|)
block|{
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|_XcmsDIConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColor_exact_return
argument_list|,
name|pClientWhitePt
argument_list|,
literal|1
argument_list|,
name|result_format
argument_list|)
operator|)
return|;
block|}
block|}
block|}
block|}
block|}
end_function

end_unit

