begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: TextToStr.c,v 1.3 91/01/08 14:40:22 gildea Exp $ */
end_comment

begin_comment
comment|/* Copyright 1989 Massachusetts Institute of Technology */
end_comment

begin_comment
comment|/* Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_include
include|#
directive|include
file|<X11/Xlibint.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xatom.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xutil.h>
end_include

begin_comment
comment|/*  * XTextPropertyToStringList - set list and count to contain data stored in  * null-separated STRING property.  */
end_comment

begin_function
name|Status
name|XTextPropertyToStringList
parameter_list|(
name|tp
parameter_list|,
name|list_return
parameter_list|,
name|count_return
parameter_list|)
name|XTextProperty
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|list_return
decl_stmt|;
name|int
modifier|*
name|count_return
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|list
decl_stmt|;
comment|/* return value */
name|int
name|nelements
decl_stmt|;
comment|/* return value */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* temp variable */
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of thing to copy */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* iterator variables */
name|int
name|datalen
init|=
operator|(
name|int
operator|)
name|tp
operator|->
name|nitems
decl_stmt|;
comment|/* for convenience */
comment|/*      * make sure we understand how to do it      */
if|if
condition|(
name|tp
operator|->
name|encoding
operator|!=
name|XA_STRING
operator|||
name|tp
operator|->
name|format
operator|!=
literal|8
condition|)
return|return
name|False
return|;
if|if
condition|(
name|datalen
operator|==
literal|0
condition|)
block|{
operator|*
name|list_return
operator|=
name|NULL
expr_stmt|;
operator|*
name|count_return
operator|=
literal|0
expr_stmt|;
return|return
name|True
return|;
block|}
comment|/*      * walk the list to figure out how many elements there are      */
name|nelements
operator|=
literal|1
expr_stmt|;
comment|/* since null-separated */
for|for
control|(
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|tp
operator|->
name|value
operator|,
name|i
operator|=
name|datalen
init|;
name|i
operator|>
literal|0
condition|;
name|cp
operator|++
operator|,
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
name|nelements
operator|++
expr_stmt|;
block|}
comment|/*      * allocate list and duplicate      */
name|list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|Xmalloc
argument_list|(
name|nelements
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return
name|False
return|;
name|start
operator|=
operator|(
name|char
operator|*
operator|)
name|Xmalloc
argument_list|(
operator|(
name|datalen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for<NUL> */
if|if
condition|(
operator|!
name|start
condition|)
block|{
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|list
argument_list|)
expr_stmt|;
return|return
name|False
return|;
block|}
comment|/*      * copy data      */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tp
operator|->
name|value
argument_list|,
name|start
argument_list|,
name|tp
operator|->
name|nitems
argument_list|)
expr_stmt|;
name|start
index|[
name|datalen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * walk down list setting value      */
for|for
control|(
name|cp
operator|=
name|start
operator|,
name|i
operator|=
name|datalen
operator|+
literal|1
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|>
literal|0
condition|;
name|cp
operator|++
operator|,
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|list
index|[
name|j
index|]
operator|=
name|start
expr_stmt|;
name|start
operator|=
operator|(
name|cp
operator|+
literal|1
operator|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
comment|/*      * append final null pointer and then return data      */
operator|*
name|list_return
operator|=
name|list
expr_stmt|;
operator|*
name|count_return
operator|=
name|nelements
expr_stmt|;
return|return
name|True
return|;
block|}
end_function

begin_function
name|void
name|XFreeStringList
parameter_list|(
name|list
parameter_list|)
name|char
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
if|if
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|list
index|[
literal|0
index|]
condition|)
name|Xfree
argument_list|(
name|list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

