begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: XICWrap.c,v 11.7 91/05/30 13:10:36 rws Exp $  */
end_comment

begin_comment
comment|/*  * Copyright 1990, 1991 by OMRON Corporation, NTT Software Corporation,  *                      and Nippon Telegraph and Telephone Corporation  * Copyright 1991 by the Massachusetts Institute of Technology  * Copyright 1991 by the Open Software Foundation  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the names of OMRON, NTT Software, NTT, Open  * Software Foundation and M.I.T. not be used in advertising or   * publicity pertaining to distribution of the software without specific,   * written prior permission. OMRON, NTT Software, NTT, Open Software  * Foundation and M.I.T. make no representations about the suitability of this  * software for any purpose.  It is provided "as is" without express or  * implied warranty.  *  * OMRON, NTT SOFTWARE, NTT, OPEN SOFTWARE FOUNDATION AND M.I.T.   * DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING   * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT   * SHALL OMRON, NTT SOFTWARE, NTT, OPEN SOFTWARE FOUNDATIONN OR M.I.T. BE  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *   *	Authors: Li Yuhong		OMRON Corporation  *		 Tatsuya Kato		NTT Software Corporation  *		 Hiroshi Kuribayashi	OMRON Coproration  *		 Muneiyoshi Suzuki	Nippon Telegraph and Telephone Co.  *   *		 M. Collins		OSF    */
end_comment

begin_define
define|#
directive|define
name|NEED_EVENTS
end_define

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xlcint.h"
end_include

begin_if
if|#
directive|if
name|NeedVarargsPrototypes
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_define
define|#
directive|define
name|Va_start
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|va_start(a,b)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_define
define|#
directive|define
name|Va_start
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|va_start(a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|_XIMNestedListToNestedList
parameter_list|(
name|nlist
parameter_list|,
name|list
parameter_list|)
name|XIMArg
modifier|*
name|nlist
decl_stmt|;
comment|/* This is the new list */
name|XIMArg
modifier|*
name|list
decl_stmt|;
comment|/* The original list */
block|{
specifier|register
name|XIMArg
modifier|*
name|ptr
init|=
name|list
decl_stmt|;
while|while
condition|(
name|ptr
operator|->
name|name
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ptr
operator|->
name|name
argument_list|,
name|XNVaNestedList
argument_list|)
condition|)
block|{
name|nlist
operator|+=
name|_XIMNestedListToNestedList
argument_list|(
name|nlist
argument_list|,
operator|(
name|XIMArg
operator|*
operator|)
name|ptr
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nlist
operator|->
name|name
operator|=
name|ptr
operator|->
name|name
expr_stmt|;
name|nlist
operator|->
name|value
operator|=
name|ptr
operator|->
name|value
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|nlist
operator|++
expr_stmt|;
block|}
block|}
return|return
name|ptr
operator|-
name|list
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_XIMCountNestedList
parameter_list|(
name|args
parameter_list|,
name|total_count
parameter_list|)
name|XIMArg
modifier|*
name|args
decl_stmt|;
name|int
modifier|*
name|total_count
decl_stmt|;
block|{
for|for
control|(
init|;
name|args
operator|->
name|name
condition|;
name|args
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|args
operator|->
name|name
argument_list|,
name|XNVaNestedList
argument_list|)
condition|)
name|_XIMCountNestedList
argument_list|(
operator|(
name|XIMArg
operator|*
operator|)
name|args
operator|->
name|value
argument_list|,
name|total_count
argument_list|)
expr_stmt|;
else|else
operator|++
operator|(
operator|*
name|total_count
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|NeedVarargsPrototypes
end_if

begin_function
specifier|static
name|void
name|_XIMCountVaList
parameter_list|(
name|va_list
name|var
parameter_list|,
name|int
modifier|*
name|total_count
parameter_list|)
else|#
directive|else
function|static void _XIMCountVaList
parameter_list|(
name|var
parameter_list|,
name|total_count
parameter_list|)
name|va_list
name|var
decl_stmt|;
name|int
modifier|*
name|total_count
decl_stmt|;
endif|#
directive|endif
block|{
name|char
modifier|*
name|attr
decl_stmt|;
operator|*
name|total_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|va_arg
argument_list|(
name|var
argument_list|,
name|char
operator|*
argument_list|)
init|;
name|attr
condition|;
name|attr
operator|=
name|va_arg
argument_list|(
name|var
argument_list|,
name|char
operator|*
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
argument_list|,
name|XNVaNestedList
argument_list|)
condition|)
block|{
name|_XIMCountNestedList
argument_list|(
name|va_arg
argument_list|(
name|var
argument_list|,
name|XIMArg
operator|*
argument_list|)
argument_list|,
name|total_count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|va_arg
argument_list|(
name|var
argument_list|,
name|XIMArg
operator|*
argument_list|)
expr_stmt|;
operator|++
operator|(
operator|*
name|total_count
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
name|NeedVarargsPrototypes
end_if

begin_function
specifier|static
name|void
name|_XIMVaToNestedList
parameter_list|(
name|va_list
name|var
parameter_list|,
name|int
name|max_count
parameter_list|,
name|XIMArg
modifier|*
modifier|*
name|args_return
parameter_list|)
else|#
directive|else
function|static void _XIMVaToNestedList
parameter_list|(
name|var
parameter_list|,
name|max_count
parameter_list|,
name|args_return
parameter_list|)
name|va_list
name|var
decl_stmt|;
name|int
name|max_count
decl_stmt|;
name|XIMArg
modifier|*
modifier|*
name|args_return
decl_stmt|;
endif|#
directive|endif
block|{
name|XIMArg
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|attr
decl_stmt|;
if|if
condition|(
name|max_count
operator|<=
literal|0
condition|)
block|{
operator|*
name|args_return
operator|=
operator|(
name|XIMArg
operator|*
operator|)
name|NULL
expr_stmt|;
return|return;
block|}
name|args
operator|=
operator|(
name|XIMArg
operator|*
operator|)
name|Xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|max_count
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|XIMArg
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|args_return
operator|=
name|args
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
return|return;
for|for
control|(
name|attr
operator|=
name|va_arg
argument_list|(
name|var
argument_list|,
name|char
operator|*
argument_list|)
init|;
name|attr
condition|;
name|attr
operator|=
name|va_arg
argument_list|(
name|var
argument_list|,
name|char
operator|*
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
argument_list|,
name|XNVaNestedList
argument_list|)
condition|)
block|{
name|args
operator|+=
name|_XIMNestedListToNestedList
argument_list|(
name|args
argument_list|,
name|va_arg
argument_list|(
name|var
argument_list|,
name|XIMArg
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|args
operator|->
name|name
operator|=
name|attr
expr_stmt|;
name|args
operator|->
name|value
operator|=
name|va_arg
argument_list|(
name|var
argument_list|,
name|XPointer
argument_list|)
expr_stmt|;
name|args
operator|++
expr_stmt|;
block|}
block|}
name|args
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_if
if|#
directive|if
name|NeedVarargsPrototypes
end_if

begin_function
name|XVaNestedList
name|XVaCreateNestedList
parameter_list|(
name|int
name|dummy
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|XVaNestedList XVaCreateNestedList
parameter_list|(
name|dummy
parameter_list|,
name|va_alist
parameter_list|)
name|int
name|dummy
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|var
decl_stmt|;
name|XIMArg
modifier|*
name|args
init|=
name|NULL
decl_stmt|;
name|int
name|total_count
decl_stmt|;
name|Va_start
argument_list|(
name|var
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|_XIMCountVaList
argument_list|(
name|var
argument_list|,
operator|&
name|total_count
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|Va_start
argument_list|(
name|var
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|_XIMVaToNestedList
argument_list|(
name|var
argument_list|,
name|total_count
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|var
argument_list|)
expr_stmt|;
return|return
operator|(
name|XVaNestedList
operator|)
name|args
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedVarargsPrototypes
end_if

begin_function
name|char
modifier|*
name|XGetIMValues
parameter_list|(
name|XIM
name|im
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/* NeedVarargsPrototypes */
function|char * XGetIMValues
parameter_list|(
name|im
parameter_list|,
name|va_alist
parameter_list|)
name|XIM
name|im
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* NeedVarargsPrototypes */
block|{
name|va_list
name|var
decl_stmt|;
name|int
name|total_count
decl_stmt|;
name|XIMArg
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
comment|/*      * so count the stuff dangling here      */
name|Va_start
argument_list|(
name|var
argument_list|,
name|im
argument_list|)
expr_stmt|;
name|_XIMCountVaList
argument_list|(
name|var
argument_list|,
operator|&
name|total_count
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/*      * now package it up so we can send it along      */
name|Va_start
argument_list|(
name|var
argument_list|,
name|im
argument_list|)
expr_stmt|;
name|_XIMVaToNestedList
argument_list|(
name|var
argument_list|,
name|total_count
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|im
operator|->
name|methods
operator|->
name|get_values
call|)
argument_list|(
name|im
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|args
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Create an input context within the input method,   * and return a pointer to the input context.  */
end_comment

begin_if
if|#
directive|if
name|NeedVarargsPrototypes
end_if

begin_function
name|XIC
name|XCreateIC
parameter_list|(
name|XIM
name|im
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|XIC XCreateIC
parameter_list|(
name|im
parameter_list|,
name|va_alist
parameter_list|)
name|XIM
name|im
decl_stmt|;
comment|/* specified the attached input method */
function|va_dcl
comment|/* specified variable length argment list */
endif|#
directive|endif
block|{
name|va_list
name|var
decl_stmt|;
name|int
name|total_count
decl_stmt|;
name|XIMArg
modifier|*
name|args
decl_stmt|;
name|XIC
name|ic
decl_stmt|;
comment|/*      * so count the stuff dangling here      */
name|Va_start
argument_list|(
name|var
argument_list|,
name|im
argument_list|)
expr_stmt|;
name|_XIMCountVaList
argument_list|(
name|var
argument_list|,
operator|&
name|total_count
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/*      * now package it up so we can send it along      */
name|Va_start
argument_list|(
name|var
argument_list|,
name|im
argument_list|)
expr_stmt|;
name|_XIMVaToNestedList
argument_list|(
name|var
argument_list|,
name|total_count
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|ic
operator|=
call|(
name|XIC
call|)
argument_list|(
operator|*
name|im
operator|->
name|methods
operator|->
name|create_ic
argument_list|)
argument_list|(
name|im
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
condition|)
block|{
name|ic
operator|->
name|core
operator|.
name|next
operator|=
name|im
operator|->
name|core
operator|.
name|ic_chain
expr_stmt|;
name|im
operator|->
name|core
operator|.
name|ic_chain
operator|=
name|ic
expr_stmt|;
block|}
return|return
name|ic
return|;
block|}
end_function

begin_comment
comment|/*  * Free the input context.  */
end_comment

begin_function
name|void
name|XDestroyIC
parameter_list|(
name|ic
parameter_list|)
name|XIC
name|ic
decl_stmt|;
block|{
name|XIM
name|im
init|=
name|ic
operator|->
name|core
operator|.
name|im
decl_stmt|;
name|XIC
modifier|*
name|prev
decl_stmt|;
call|(
modifier|*
name|ic
operator|->
name|methods
operator|->
name|destroy
call|)
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|im
condition|)
block|{
for|for
control|(
name|prev
operator|=
operator|&
name|im
operator|->
name|core
operator|.
name|ic_chain
init|;
operator|*
name|prev
condition|;
name|prev
operator|=
operator|&
operator|(
operator|*
name|prev
operator|)
operator|->
name|core
operator|.
name|next
control|)
block|{
if|if
condition|(
operator|*
name|prev
operator|==
name|ic
condition|)
block|{
operator|*
name|prev
operator|=
name|ic
operator|->
name|core
operator|.
name|next
expr_stmt|;
break|break;
block|}
block|}
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedVarargsPrototypes
end_if

begin_function
name|char
modifier|*
name|XGetICValues
parameter_list|(
name|XIC
name|ic
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|char * XGetICValues
parameter_list|(
name|ic
parameter_list|,
name|va_alist
parameter_list|)
name|XIC
name|ic
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|var
decl_stmt|;
name|int
name|total_count
decl_stmt|;
name|XIMArg
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|ic
operator|->
name|core
operator|.
name|im
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
comment|/*      * so count the stuff dangling here      */
name|Va_start
argument_list|(
name|var
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|_XIMCountVaList
argument_list|(
name|var
argument_list|,
operator|&
name|total_count
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/*      * now package it up so we can send it along      */
name|Va_start
argument_list|(
name|var
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|_XIMVaToNestedList
argument_list|(
name|var
argument_list|,
name|total_count
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|ic
operator|->
name|methods
operator|->
name|get_values
call|)
argument_list|(
name|ic
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|args
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedVarargsPrototypes
end_if

begin_function
name|char
modifier|*
name|XSetICValues
parameter_list|(
name|XIC
name|ic
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|char * XSetICValues
parameter_list|(
name|ic
parameter_list|,
name|va_alist
parameter_list|)
name|XIC
name|ic
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|var
decl_stmt|;
name|int
name|total_count
decl_stmt|;
name|XIMArg
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|ic
operator|->
name|core
operator|.
name|im
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
comment|/*      * so count the stuff dangling here      */
name|Va_start
argument_list|(
name|var
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|_XIMCountVaList
argument_list|(
name|var
argument_list|,
operator|&
name|total_count
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/*      * now package it up so we can send it along      */
name|Va_start
argument_list|(
name|var
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|_XIMVaToNestedList
argument_list|(
name|var
argument_list|,
name|total_count
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|ic
operator|->
name|methods
operator|->
name|set_values
call|)
argument_list|(
name|ic
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|args
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Require the input manager to focus the focus window attached to the ic  * argument.  */
end_comment

begin_function
name|void
name|XSetICFocus
parameter_list|(
name|ic
parameter_list|)
name|XIC
name|ic
decl_stmt|;
block|{
if|if
condition|(
name|ic
operator|->
name|core
operator|.
name|im
condition|)
call|(
modifier|*
name|ic
operator|->
name|methods
operator|->
name|set_focus
call|)
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Require the input manager to unfocus the focus window attached to the ic  * argument.  */
end_comment

begin_function
name|void
name|XUnsetICFocus
parameter_list|(
name|ic
parameter_list|)
name|XIC
name|ic
decl_stmt|;
block|{
if|if
condition|(
name|ic
operator|->
name|core
operator|.
name|im
condition|)
call|(
modifier|*
name|ic
operator|->
name|methods
operator|->
name|unset_focus
call|)
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the XIM associated with the input context.  */
end_comment

begin_function
name|XIM
name|XIMOfIC
parameter_list|(
name|ic
parameter_list|)
name|XIC
name|ic
decl_stmt|;
block|{
return|return
name|ic
operator|->
name|core
operator|.
name|im
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|XmbResetIC
parameter_list|(
name|ic
parameter_list|)
name|XIC
name|ic
decl_stmt|;
block|{
if|if
condition|(
name|ic
operator|->
name|core
operator|.
name|im
condition|)
return|return
call|(
modifier|*
name|ic
operator|->
name|methods
operator|->
name|mb_reset
call|)
argument_list|(
name|ic
argument_list|)
return|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_function
name|wchar_t
modifier|*
name|XwcResetIC
parameter_list|(
name|ic
parameter_list|)
name|XIC
name|ic
decl_stmt|;
block|{
if|if
condition|(
name|ic
operator|->
name|core
operator|.
name|im
condition|)
return|return
call|(
modifier|*
name|ic
operator|->
name|methods
operator|->
name|wc_reset
call|)
argument_list|(
name|ic
argument_list|)
return|;
return|return
operator|(
name|wchar_t
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|XmbLookupString
parameter_list|(
name|ic
parameter_list|,
name|ev
parameter_list|,
name|buffer
parameter_list|,
name|nbytes
parameter_list|,
name|keysym
parameter_list|,
name|status
parameter_list|)
name|XIC
name|ic
decl_stmt|;
specifier|register
name|XKeyEvent
modifier|*
name|ev
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|KeySym
modifier|*
name|keysym
decl_stmt|;
name|Status
modifier|*
name|status
decl_stmt|;
block|{
if|if
condition|(
name|ic
operator|->
name|core
operator|.
name|im
condition|)
return|return
call|(
modifier|*
name|ic
operator|->
name|methods
operator|->
name|mb_lookup_string
call|)
argument_list|(
name|ic
argument_list|,
name|ev
argument_list|,
name|buffer
argument_list|,
name|nbytes
argument_list|,
name|keysym
argument_list|,
name|status
argument_list|)
return|;
return|return
name|XLookupNone
return|;
block|}
end_function

begin_function
name|int
name|XwcLookupString
parameter_list|(
name|ic
parameter_list|,
name|ev
parameter_list|,
name|buffer
parameter_list|,
name|nchars
parameter_list|,
name|keysym
parameter_list|,
name|status
parameter_list|)
name|XIC
name|ic
decl_stmt|;
specifier|register
name|XKeyEvent
modifier|*
name|ev
decl_stmt|;
name|wchar_t
modifier|*
name|buffer
decl_stmt|;
name|int
name|nchars
decl_stmt|;
name|KeySym
modifier|*
name|keysym
decl_stmt|;
name|Status
modifier|*
name|status
decl_stmt|;
block|{
if|if
condition|(
name|ic
operator|->
name|core
operator|.
name|im
condition|)
return|return
call|(
modifier|*
name|ic
operator|->
name|methods
operator|->
name|wc_lookup_string
call|)
argument_list|(
name|ic
argument_list|,
name|ev
argument_list|,
name|buffer
argument_list|,
name|nchars
argument_list|,
name|keysym
argument_list|,
name|status
argument_list|)
return|;
return|return
name|XLookupNone
return|;
block|}
end_function

end_unit

